<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"1": {"id": 1, "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_lexopt_templ.c", "content": "/*\n * Copyright 2008-2009 Katholieke Universiteit Leuven\n * Copyright 2010      INRIA Saclay\n * Copyright 2011      Sven Verdoolaege\n *\n * Use of this software is governed by the MIT license\n *\n * Written by Sven Verdoolaege, K.U.Leuven, Departement\n * Computerwetenschappen, Celestijnenlaan 200A, B-3001 Leuven, Belgium\n * and INRIA Saclay - Ile-de-France, Parc Club Orsay Universite,\n * ZAC des vignes, 4 rue Jacques Monod, 91893 Orsay, France\n */\n\n#define xSF(TYPE,SUFFIX) TYPE ## SUFFIX\n#define SF(TYPE,SUFFIX) xSF(TYPE,SUFFIX)\n\n/* Given a basic map with at least two parallel constraints (as found\n * by the function parallel_constraints), first look for more constraints\n * parallel to the two constraint and replace the found list of parallel\n * constraints by a single constraint with as \"input\" part the minimum\n * of the input parts of the list of constraints.  Then, recursively call\n * basic_map_partial_lexopt (possibly finding more parallel constraints)\n * and plug in the definition of the minimum in the result.\n *\n * As in parallel_constraints, only inequality constraints that only\n * involve input variables that do not occur in any other inequality\n * constraints are considered.\n *\n * More specifically, given a set of constraints\n *\n *\ta x + b_i(p) >= 0\n *\n * Replace this set by a single constraint\n *\n *\ta x + u >= 0\n *\n * with u a new parameter with constraints\n *\n *\tu <= b_i(p)\n *\n * Any solution to the new system is also a solution for the original system\n * since\n *\n *\ta x >= -u >= -b_i(p)\n *\n * Moreover, m = min_i(b_i(p)) satisfies the constraints on u and can\n * therefore be plugged into the solution.\n */\nstatic TYPE *SF(basic_map_partial_lexopt_symm,SUFFIX)(\n\t__isl_take isl_basic_map *bmap, __isl_take isl_basic_set *dom,\n\t__isl_give isl_set **empty, int max, int first, int second)\n{\n\tint i, n, k;\n\tint *list = NULL;\n\tisl_size bmap_in, bmap_param, bmap_all;\n\tunsigned n_in, n_out, n_div;\n\tisl_ctx *ctx;\n\tisl_vec *var = NULL;\n\tisl_mat *cst = NULL;\n\tisl_space *map_space, *set_space;\n\n\tmap_space = isl_basic_map_get_space(bmap);\n\tset_space = empty ? isl_basic_set_get_space(dom) : NULL;\n\n\tbmap_in = isl_basic_map_dim(bmap, isl_dim_in);\n\tbmap_param = isl_basic_map_dim(bmap, isl_dim_param);\n\tbmap_all = isl_basic_map_dim(bmap, isl_dim_all);\n\tif (bmap_in < 0 || bmap_param < 0 || bmap_all < 0)\n\t\tgoto error;\n\tn_in = bmap_param + bmap_in;\n\tn_out = bmap_all - n_in;\n\n\tctx = isl_basic_map_get_ctx(bmap);\n\tlist = isl_alloc_array(ctx, int, bmap->n_ineq);\n\tvar = isl_vec_alloc(ctx, n_out);\n\tif ((bmap->n_ineq && !list) || (n_out && !var))\n\t\tgoto error;\n\n\tlist[0] = first;\n\tlist[1] = second;\n\tisl_seq_cpy(var->el, bmap->ineq[first] + 1 + n_in, n_out);\n\tfor (i = second + 1, n = 2; i < bmap->n_ineq; ++i) {\n\t\tif (isl_seq_eq(var->el, bmap->ineq[i] + 1 + n_in, n_out) &&\n\t\t    all_single_occurrence(bmap, i, n_in))\n\t\t\tlist[n++] = i;\n\t}\n\n\tcst = isl_mat_alloc(ctx, n, 1 + n_in);\n\tif (!cst)\n\t\tgoto error;\n\n\tfor (i = 0; i < n; ++i)\n\t\tisl_seq_cpy(cst->row[i], bmap->ineq[list[i]], 1 + n_in);\n\n\tbmap = isl_basic_map_cow(bmap);\n\tif (!bmap)\n\t\tgoto error;\n\tfor (i = n - 1; i >= 0; --i)\n\t\tif (isl_basic_map_drop_inequality(bmap, list[i]) < 0)\n\t\t\tgoto error;\n\n\tbmap = isl_basic_map_add_dims(bmap, isl_dim_in, 1);\n\tbmap = isl_basic_map_extend_constraints(bmap, 0, 1);\n\tk = isl_basic_map_alloc_inequality(bmap);\n\tif (k < 0)\n\t\tgoto error;\n\tisl_seq_clr(bmap->ineq[k], 1 + n_in);\n\tisl_int_set_si(bmap->ineq[k][1 + n_in], 1);\n\tisl_seq_cpy(bmap->ineq[k] + 1 + n_in + 1, var->el, n_out);\n\tbmap = isl_basic_map_finalize(bmap);\n\n\tn_div = isl_basic_set_dim(dom, isl_dim_div);\n\tdom = isl_basic_set_add_dims(dom, isl_dim_set, 1);\n\tdom = isl_basic_set_extend_constraints(dom, 0, n);\n\tfor (i = 0; i < n; ++i) {\n\t\tk = isl_basic_set_alloc_inequality(dom);\n\t\tif (k < 0)\n\t\t\tgoto error;\n\t\tisl_seq_cpy(dom->ineq[k], cst->row[i], 1 + n_in);\n\t\tisl_int_set_si(dom->ineq[k][1 + n_in], -1);\n\t\tisl_seq_clr(dom->ineq[k] + 1 + n_in + 1, n_div);\n\t}\n\n\tisl_vec_free(var);\n\tfree(list);\n\n\treturn SF(basic_map_partial_lexopt_symm_core,SUFFIX)(bmap, dom, empty,\n\t\t\t\t\t\tmax, cst, map_space, set_space);\nerror:\n\tisl_space_free(map_space);\n\tisl_space_free(set_space);\n\tisl_mat_free(cst);\n\tisl_vec_free(var);\n\tfree(list);\n\tisl_basic_set_free(dom);\n\tisl_basic_map_free(bmap);\n\treturn NULL;\n}\n\n/* Recursive part of isl_tab_basic_map_partial_lexopt*, after detecting\n * equalities and removing redundant constraints.\n *\n * We first check if there are any parallel constraints (left).\n * If not, we are in the base case.\n * If there are parallel constraints, we replace them by a single\n * constraint in basic_map_partial_lexopt_symm_pma and then call\n * this function recursively to look for more parallel constraints.\n */\nstatic __isl_give TYPE *SF(basic_map_partial_lexopt,SUFFIX)(\n\t__isl_take isl_basic_map *bmap, __isl_take isl_basic_set *dom,\n\t__isl_give isl_set **empty, int max)\n{\n\tisl_bool par = isl_bool_false;\n\tint first, second;\n\n\tif (!bmap)\n\t\tgoto error;\n\n\tif (bmap->ctx->opt->pip_symmetry)\n\t\tpar = parallel_constraints(bmap, &first, &second);\n\tif (par < 0)\n\t\tgoto error;\n\tif (!par)\n\t\treturn SF(basic_map_partial_lexopt_base,SUFFIX)(bmap, dom,\n\t\t\t\t\t\t\t\tempty, max);\n\n\treturn SF(basic_map_partial_lexopt_symm,SUFFIX)(bmap, dom, empty, max,\n\t\t\t\t\t\t\t first, second);\nerror:\n\tisl_basic_set_free(dom);\n\tisl_basic_map_free(bmap);\n\treturn NULL;\n}\n\n/* Compute the lexicographic minimum (or maximum if \"flags\" includes\n * ISL_OPT_MAX) of \"bmap\" over the domain \"dom\" and return the result as\n * either a map or a piecewise multi-affine expression depending on TYPE.\n * If \"empty\" is not NULL, then *empty is assigned a set that\n * contains those parts of the domain where there is no solution.\n * If \"flags\" includes ISL_OPT_FULL, then \"dom\" is NULL and the optimum\n * should be computed over the domain of \"bmap\".  \"empty\" is also NULL\n * in this case.\n * If \"bmap\" is marked as rational (ISL_BASIC_MAP_RATIONAL),\n * then we compute the rational optimum.  Otherwise, we compute\n * the integral optimum.\n *\n * We perform some preprocessing.  As the PILP solver does not\n * handle implicit equalities very well, we first make sure all\n * the equalities are explicitly available.\n *\n * We also add context constraints to the basic map and remove\n * redundant constraints.  This is only needed because of the\n * way we handle simple symmetries.  In particular, we currently look\n * for symmetries on the constraints, before we set up the main tableau.\n * It is then no good to look for symmetries on possibly redundant constraints.\n * If the domain was extracted from the basic map, then there is\n * no need to add back those constraints again.\n */\n__isl_give TYPE *SF(isl_tab_basic_map_partial_lexopt,SUFFIX)(\n\t__isl_take isl_basic_map *bmap, __isl_take isl_basic_set *dom,\n\t__isl_give isl_set **empty, unsigned flags)\n{\n\tint max, full;\n\tisl_bool compatible;\n\n\tif (empty)\n\t\t*empty = NULL;\n\n\tfull = ISL_FL_ISSET(flags, ISL_OPT_FULL);\n\tif (full)\n\t\tdom = extract_domain(bmap, flags);\n\tcompatible = isl_basic_map_compatible_domain(bmap, dom);\n\tif (compatible < 0)\n\t\tgoto error;\n\tif (!compatible)\n\t\tisl_die(isl_basic_map_get_ctx(bmap), isl_error_invalid,\n\t\t\t\"domain does not match input\", goto error);\n\n\tmax = ISL_FL_ISSET(flags, ISL_OPT_MAX);\n\tif (isl_basic_set_dim(dom, isl_dim_all) == 0)\n\t\treturn SF(basic_map_partial_lexopt,SUFFIX)(bmap, dom, empty,\n\t\t\t\t\t\t\t    max);\n\n\tif (!full)\n\t\tbmap = isl_basic_map_intersect_domain(bmap,\n\t\t\t\t\t\t    isl_basic_set_copy(dom));\n\tbmap = isl_basic_map_detect_equalities(bmap);\n\tbmap = isl_basic_map_remove_redundancies(bmap);\n\n\treturn SF(basic_map_partial_lexopt,SUFFIX)(bmap, dom, empty, max);\nerror:\n\tisl_basic_set_free(dom);\n\tisl_basic_map_free(bmap);\n\treturn NULL;\n}\n"}, "2": {"id": 2, "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "content": "/*\n * Copyright 2008-2009 Katholieke Universiteit Leuven\n * Copyright 2010      INRIA Saclay\n * Copyright 2016-2017 Sven Verdoolaege\n *\n * Use of this software is governed by the MIT license\n *\n * Written by Sven Verdoolaege, K.U.Leuven, Departement\n * Computerwetenschappen, Celestijnenlaan 200A, B-3001 Leuven, Belgium\n * and INRIA Saclay - Ile-de-France, Parc Club Orsay Universite,\n * ZAC des vignes, 4 rue Jacques Monod, 91893 Orsay, France \n */\n\n#include <isl_ctx_private.h>\n#include \"isl_map_private.h\"\n#include <isl_seq.h>\n#include \"isl_tab.h\"\n#include \"isl_sample.h\"\n#include <isl_mat_private.h>\n#include <isl_vec_private.h>\n#include <isl_aff_private.h>\n#include <isl_constraint_private.h>\n#include <isl_options_private.h>\n#include <isl_config.h>\n\n#include <bset_to_bmap.c>\n\n/*\n * The implementation of parametric integer linear programming in this file\n * was inspired by the paper \"Parametric Integer Programming\" and the\n * report \"Solving systems of affine (in)equalities\" by Paul Feautrier\n * (and others).\n *\n * The strategy used for obtaining a feasible solution is different\n * from the one used in isl_tab.c.  In particular, in isl_tab.c,\n * upon finding a constraint that is not yet satisfied, we pivot\n * in a row that increases the constant term of the row holding the\n * constraint, making sure the sample solution remains feasible\n * for all the constraints it already satisfied.\n * Here, we always pivot in the row holding the constraint,\n * choosing a column that induces the lexicographically smallest\n * increment to the sample solution.\n *\n * By starting out from a sample value that is lexicographically\n * smaller than any integer point in the problem space, the first\n * feasible integer sample point we find will also be the lexicographically\n * smallest.  If all variables can be assumed to be non-negative,\n * then the initial sample value may be chosen equal to zero.\n * However, we will not make this assumption.  Instead, we apply\n * the \"big parameter\" trick.  Any variable x is then not directly\n * used in the tableau, but instead it is represented by another\n * variable x' = M + x, where M is an arbitrarily large (positive)\n * value.  x' is therefore always non-negative, whatever the value of x.\n * Taking as initial sample value x' = 0 corresponds to x = -M,\n * which is always smaller than any possible value of x.\n *\n * The big parameter trick is used in the main tableau and\n * also in the context tableau if isl_context_lex is used.\n * In this case, each tableaus has its own big parameter.\n * Before doing any real work, we check if all the parameters\n * happen to be non-negative.  If so, we drop the column corresponding\n * to M from the initial context tableau.\n * If isl_context_gbr is used, then the big parameter trick is only\n * used in the main tableau.\n */\n\nstruct isl_context;\nstruct isl_context_op {\n\t/* detect nonnegative parameters in context and mark them in tab */\n\tstruct isl_tab *(*detect_nonnegative_parameters)(\n\t\t\tstruct isl_context *context, struct isl_tab *tab);\n\t/* return temporary reference to basic set representation of context */\n\tstruct isl_basic_set *(*peek_basic_set)(struct isl_context *context);\n\t/* return temporary reference to tableau representation of context */\n\tstruct isl_tab *(*peek_tab)(struct isl_context *context);\n\t/* add equality; check is 1 if eq may not be valid;\n\t * update is 1 if we may want to call ineq_sign on context later.\n\t */\n\tvoid (*add_eq)(struct isl_context *context, isl_int *eq,\n\t\t\tint check, int update);\n\t/* add inequality; check is 1 if ineq may not be valid;\n\t * update is 1 if we may want to call ineq_sign on context later.\n\t */\n\tvoid (*add_ineq)(struct isl_context *context, isl_int *ineq,\n\t\t\tint check, int update);\n\t/* check sign of ineq based on previous information.\n\t * strict is 1 if saturation should be treated as a positive sign.\n\t */\n\tenum isl_tab_row_sign (*ineq_sign)(struct isl_context *context,\n\t\t\tisl_int *ineq, int strict);\n\t/* check if inequality maintains feasibility */\n\tint (*test_ineq)(struct isl_context *context, isl_int *ineq);\n\t/* return index of a div that corresponds to \"div\" */\n\tint (*get_div)(struct isl_context *context, struct isl_tab *tab,\n\t\t\tstruct isl_vec *div);\n\t/* insert div \"div\" to context at \"pos\" and return non-negativity */\n\tisl_bool (*insert_div)(struct isl_context *context, int pos,\n\t\t__isl_keep isl_vec *div);\n\tint (*detect_equalities)(struct isl_context *context,\n\t\t\tstruct isl_tab *tab);\n\t/* return row index of \"best\" split */\n\tint (*best_split)(struct isl_context *context, struct isl_tab *tab);\n\t/* check if context has already been determined to be empty */\n\tint (*is_empty)(struct isl_context *context);\n\t/* check if context is still usable */\n\tint (*is_ok)(struct isl_context *context);\n\t/* save a copy/snapshot of context */\n\tvoid *(*save)(struct isl_context *context);\n\t/* restore saved context */\n\tvoid (*restore)(struct isl_context *context, void *);\n\t/* discard saved context */\n\tvoid (*discard)(void *);\n\t/* invalidate context */\n\tvoid (*invalidate)(struct isl_context *context);\n\t/* free context */\n\t__isl_null struct isl_context *(*free)(struct isl_context *context);\n};\n\n/* Shared parts of context representation.\n *\n * \"n_unknown\" is the number of final unknown integer divisions\n * in the input domain.\n */\nstruct isl_context {\n\tstruct isl_context_op *op;\n\tint n_unknown;\n};\n\nstruct isl_context_lex {\n\tstruct isl_context context;\n\tstruct isl_tab *tab;\n};\n\n/* A stack (linked list) of solutions of subtrees of the search space.\n *\n * \"ma\" describes the solution as a function of \"dom\".\n * In particular, the domain space of \"ma\" is equal to the space of \"dom\".\n *\n * If \"ma\" is NULL, then there is no solution on \"dom\".\n */\nstruct isl_partial_sol {\n\tint level;\n\tstruct isl_basic_set *dom;\n\tisl_multi_aff *ma;\n\n\tstruct isl_partial_sol *next;\n};\n\nstruct isl_sol;\nstruct isl_sol_callback {\n\tstruct isl_tab_callback callback;\n\tstruct isl_sol *sol;\n};\n\n/* isl_sol is an interface for constructing a solution to\n * a parametric integer linear programming problem.\n * Every time the algorithm reaches a state where a solution\n * can be read off from the tableau, the function \"add\" is called\n * on the isl_sol passed to find_solutions_main.  In a state where\n * the tableau is empty, \"add_empty\" is called instead.\n * \"free\" is called to free the implementation specific fields, if any.\n *\n * \"error\" is set if some error has occurred.  This flag invalidates\n * the remainder of the data structure.\n * If \"rational\" is set, then a rational optimization is being performed.\n * \"level\" is the current level in the tree with nodes for each\n * split in the context.\n * If \"max\" is set, then a maximization problem is being solved, rather than\n * a minimization problem, which means that the variables in the\n * tableau have value \"M - x\" rather than \"M + x\".\n * \"n_out\" is the number of output dimensions in the input.\n * \"space\" is the space in which the solution (and also the input) lives.\n *\n * The context tableau is owned by isl_sol and is updated incrementally.\n *\n * There are currently two implementations of this interface,\n * isl_sol_map, which simply collects the solutions in an isl_map\n * and (optionally) the parts of the context where there is no solution\n * in an isl_set, and\n * isl_sol_pma, which collects an isl_pw_multi_aff instead.\n */\nstruct isl_sol {\n\tint error;\n\tint rational;\n\tint level;\n\tint max;\n\tisl_size n_out;\n\tisl_space *space;\n\tstruct isl_context *context;\n\tstruct isl_partial_sol *partial;\n\tvoid (*add)(struct isl_sol *sol,\n\t\t__isl_take isl_basic_set *dom, __isl_take isl_multi_aff *ma);\n\tvoid (*add_empty)(struct isl_sol *sol, struct isl_basic_set *bset);\n\tvoid (*free)(struct isl_sol *sol);\n\tstruct isl_sol_callback\tdec_level;\n};\n\nstatic void sol_free(struct isl_sol *sol)\n{\n\tstruct isl_partial_sol *partial, *next;\n\tif (!sol)\n\t\treturn;\n\tfor (partial = sol->partial; partial; partial = next) {\n\t\tnext = partial->next;\n\t\tisl_basic_set_free(partial->dom);\n\t\tisl_multi_aff_free(partial->ma);\n\t\tfree(partial);\n\t}\n\tisl_space_free(sol->space);\n\tif (sol->context)\n\t\tsol->context->op->free(sol->context);\n\tsol->free(sol);\n\tfree(sol);\n}\n\n/* Push a partial solution represented by a domain and function \"ma\"\n * onto the stack of partial solutions.\n * If \"ma\" is NULL, then \"dom\" represents a part of the domain\n * with no solution.\n */\nstatic void sol_push_sol(struct isl_sol *sol,\n\t__isl_take isl_basic_set *dom, __isl_take isl_multi_aff *ma)\n{\n\tstruct isl_partial_sol *partial;\n\n\tif (sol->error || !dom)\n\t\tgoto error;\n\n\tpartial = isl_alloc_type(dom->ctx, struct isl_partial_sol);\n\tif (!partial)\n\t\tgoto error;\n\n\tpartial->level = sol->level;\n\tpartial->dom = dom;\n\tpartial->ma = ma;\n\tpartial->next = sol->partial;\n\n\tsol->partial = partial;\n\n\treturn;\nerror:\n\tisl_basic_set_free(dom);\n\tisl_multi_aff_free(ma);\n\tsol->error = 1;\n}\n\n/* Check that the final columns of \"M\", starting at \"first\", are zero.\n */\nstatic isl_stat check_final_columns_are_zero(__isl_keep isl_mat *M,\n\tunsigned first)\n{\n\tint i;\n\tisl_size rows, cols;\n\tunsigned n;\n\n\trows = isl_mat_rows(M);\n\tcols = isl_mat_cols(M);\n\tif (rows < 0 || cols < 0)\n\t\treturn isl_stat_error;\n\tn = cols - first;\n\tfor (i = 0; i < rows; ++i)\n\t\tif (isl_seq_first_non_zero(M->row[i] + first, n) != -1)\n\t\t\tisl_die(isl_mat_get_ctx(M), isl_error_internal,\n\t\t\t\t\"final columns should be zero\",\n\t\t\t\treturn isl_stat_error);\n\treturn isl_stat_ok;\n}\n\n/* Set the affine expressions in \"ma\" according to the rows in \"M\", which\n * are defined over the local space \"ls\".\n * The matrix \"M\" may have extra (zero) columns beyond the number\n * of variables in \"ls\".\n */\nstatic __isl_give isl_multi_aff *set_from_affine_matrix(\n\t__isl_take isl_multi_aff *ma, __isl_take isl_local_space *ls,\n\t__isl_take isl_mat *M)\n{\n\tint i;\n\tisl_size dim;\n\tisl_aff *aff;\n\n\tdim = isl_local_space_dim(ls, isl_dim_all);\n\tif (!ma || dim < 0 || !M)\n\t\tgoto error;\n\n\tif (check_final_columns_are_zero(M, 1 + dim) < 0)\n\t\tgoto error;\n\tfor (i = 1; i < M->n_row; ++i) {\n\t\taff = isl_aff_alloc(isl_local_space_copy(ls));\n\t\tif (aff) {\n\t\t\tisl_int_set(aff->v->el[0], M->row[0][0]);\n\t\t\tisl_seq_cpy(aff->v->el + 1, M->row[i], 1 + dim);\n\t\t}\n\t\taff = isl_aff_normalize(aff);\n\t\tma = isl_multi_aff_set_aff(ma, i - 1, aff);\n\t}\n\tisl_local_space_free(ls);\n\tisl_mat_free(M);\n\n\treturn ma;\nerror:\n\tisl_local_space_free(ls);\n\tisl_mat_free(M);\n\tisl_multi_aff_free(ma);\n\treturn NULL;\n}\n\n/* Push a partial solution represented by a domain and mapping M\n * onto the stack of partial solutions.\n *\n * The affine matrix \"M\" maps the dimensions of the context\n * to the output variables.  Convert it into an isl_multi_aff and\n * then call sol_push_sol.\n *\n * Note that the description of the initial context may have involved\n * existentially quantified variables, in which case they also appear\n * in \"dom\".  These need to be removed before creating the affine\n * expression because an affine expression cannot be defined in terms\n * of existentially quantified variables without a known representation.\n * Since newly added integer divisions are inserted before these\n * existentially quantified variables, they are still in the final\n * positions and the corresponding final columns of \"M\" are zero\n * because align_context_divs adds the existentially quantified\n * variables of the context to the main tableau without any constraints and\n * any equality constraints that are added later on can only serve\n * to eliminate these existentially quantified variables.\n */\nstatic void sol_push_sol_mat(struct isl_sol *sol,\n\t__isl_take isl_basic_set *dom, __isl_take isl_mat *M)\n{\n\tisl_local_space *ls;\n\tisl_multi_aff *ma;\n\tisl_size n_div;\n\tint n_known;\n\n\tn_div = isl_basic_set_dim(dom, isl_dim_div);\n\tif (n_div < 0)\n\t\tgoto error;\n\tn_known = n_div - sol->context->n_unknown;\n\n\tma = isl_multi_aff_alloc(isl_space_copy(sol->space));\n\tls = isl_basic_set_get_local_space(dom);\n\tls = isl_local_space_drop_dims(ls, isl_dim_div,\n\t\t\t\t\tn_known, n_div - n_known);\n\tma = set_from_affine_matrix(ma, ls, M);\n\n\tif (!ma)\n\t\tdom = isl_basic_set_free(dom);\n\tsol_push_sol(sol, dom, ma);\n\treturn;\nerror:\n\tisl_basic_set_free(dom);\n\tisl_mat_free(M);\n\tsol_push_sol(sol, NULL, NULL);\n}\n\n/* Pop one partial solution from the partial solution stack and\n * pass it on to sol->add or sol->add_empty.\n */\nstatic void sol_pop_one(struct isl_sol *sol)\n{\n\tstruct isl_partial_sol *partial;\n\n\tpartial = sol->partial;\n\tsol->partial = partial->next;\n\n\tif (partial->ma)\n\t\tsol->add(sol, partial->dom, partial->ma);\n\telse\n\t\tsol->add_empty(sol, partial->dom);\n\tfree(partial);\n}\n\n/* Return a fresh copy of the domain represented by the context tableau.\n */\nstatic struct isl_basic_set *sol_domain(struct isl_sol *sol)\n{\n\tstruct isl_basic_set *bset;\n\n\tif (sol->error)\n\t\treturn NULL;\n\n\tbset = isl_basic_set_dup(sol->context->op->peek_basic_set(sol->context));\n\tbset = isl_basic_set_update_from_tab(bset,\n\t\t\tsol->context->op->peek_tab(sol->context));\n\n\treturn bset;\n}\n\n/* Check whether two partial solutions have the same affine expressions.\n */\nstatic isl_bool same_solution(struct isl_partial_sol *s1,\n\tstruct isl_partial_sol *s2)\n{\n\tif (!s1->ma != !s2->ma)\n\t\treturn isl_bool_false;\n\tif (!s1->ma)\n\t\treturn isl_bool_true;\n\n\treturn isl_multi_aff_plain_is_equal(s1->ma, s2->ma);\n}\n\n/* Swap the initial two partial solutions in \"sol\".\n *\n * That is, go from\n *\n *\tsol->partial = p1; p1->next = p2; p2->next = p3\n *\n * to\n *\n *\tsol->partial = p2; p2->next = p1; p1->next = p3\n */\nstatic void swap_initial(struct isl_sol *sol)\n{\n\tstruct isl_partial_sol *partial;\n\n\tpartial = sol->partial;\n\tsol->partial = partial->next;\n\tpartial->next = partial->next->next;\n\tsol->partial->next = partial;\n}\n\n/* Combine the initial two partial solution of \"sol\" into\n * a partial solution with the current context domain of \"sol\" and\n * the function description of the second partial solution in the list.\n * The level of the new partial solution is set to the current level.\n *\n * That is, the first two partial solutions (D1,M1) and (D2,M2) are\n * replaced by (D,M2), where D is the domain of \"sol\", which is assumed\n * to be the union of D1 and D2, while M1 is assumed to be equal to M2\n * (at least on D1).\n */\nstatic isl_stat combine_initial_into_second(struct isl_sol *sol)\n{\n\tstruct isl_partial_sol *partial;\n\tisl_basic_set *bset;\n\n\tpartial = sol->partial;\n\n\tbset = sol_domain(sol);\n\tisl_basic_set_free(partial->next->dom);\n\tpartial->next->dom = bset;\n\tpartial->next->level = sol->level;\n\n\tif (!bset)\n\t\treturn isl_stat_error;\n\n\tsol->partial = partial->next;\n\tisl_basic_set_free(partial->dom);\n\tisl_multi_aff_free(partial->ma);\n\tfree(partial);\n\n\treturn isl_stat_ok;\n}\n\n/* Are \"ma1\" and \"ma2\" equal to each other on \"dom\"?\n *\n * Combine \"ma1\" and \"ma2\" with \"dom\" and check if the results are the same.\n * \"dom\" may have existentially quantified variables.  Eliminate them first\n * as otherwise they would have to be eliminated twice, in a more complicated\n * context.\n */\nstatic isl_bool equal_on_domain(__isl_keep isl_multi_aff *ma1,\n\t__isl_keep isl_multi_aff *ma2, __isl_keep isl_basic_set *dom)\n{\n\tisl_set *set;\n\tisl_pw_multi_aff *pma1, *pma2;\n\tisl_bool equal;\n\n\tset = isl_basic_set_compute_divs(isl_basic_set_copy(dom));\n\tpma1 = isl_pw_multi_aff_alloc(isl_set_copy(set),\n\t\t\t\t\tisl_multi_aff_copy(ma1));\n\tpma2 = isl_pw_multi_aff_alloc(set, isl_multi_aff_copy(ma2));\n\tequal = isl_pw_multi_aff_is_equal(pma1, pma2);\n\tisl_pw_multi_aff_free(pma1);\n\tisl_pw_multi_aff_free(pma2);\n\n\treturn equal;\n}\n\n/* The initial two partial solutions of \"sol\" are known to be at\n * the same level.\n * If they represent the same solution (on different parts of the domain),\n * then combine them into a single solution at the current level.\n * Otherwise, pop them both.\n *\n * Even if the two partial solution are not obviously the same,\n * one may still be a simplification of the other over its own domain.\n * Also check if the two sets of affine functions are equal when\n * restricted to one of the domains.  If so, combine the two\n * using the set of affine functions on the other domain.\n * That is, for two partial solutions (D1,M1) and (D2,M2),\n * if M1 = M2 on D1, then the pair of partial solutions can\n * be replaced by (D1+D2,M2) and similarly when M1 = M2 on D2.\n */\nstatic isl_stat combine_initial_if_equal(struct isl_sol *sol)\n{\n\tstruct isl_partial_sol *partial;\n\tisl_bool same;\n\n\tpartial = sol->partial;\n\n\tsame = same_solution(partial, partial->next);\n\tif (same < 0)\n\t\treturn isl_stat_error;\n\tif (same)\n\t\treturn combine_initial_into_second(sol);\n\tif (partial->ma && partial->next->ma) {\n\t\tsame = equal_on_domain(partial->ma, partial->next->ma,\n\t\t\t\t\tpartial->dom);\n\t\tif (same < 0)\n\t\t\treturn isl_stat_error;\n\t\tif (same)\n\t\t\treturn combine_initial_into_second(sol);\n\t\tsame = equal_on_domain(partial->ma, partial->next->ma,\n\t\t\t\t\tpartial->next->dom);\n\t\tif (same) {\n\t\t\tswap_initial(sol);\n\t\t\treturn combine_initial_into_second(sol);\n\t\t}\n\t}\n\n\tsol_pop_one(sol);\n\tsol_pop_one(sol);\n\n\treturn isl_stat_ok;\n}\n\n/* Pop all solutions from the partial solution stack that were pushed onto\n * the stack at levels that are deeper than the current level.\n * If the two topmost elements on the stack have the same level\n * and represent the same solution, then their domains are combined.\n * This combined domain is the same as the current context domain\n * as sol_pop is called each time we move back to a higher level.\n * If the outer level (0) has been reached, then all partial solutions\n * at the current level are also popped off.\n */\nstatic void sol_pop(struct isl_sol *sol)\n{\n\tstruct isl_partial_sol *partial;\n\n\tif (sol->error)\n\t\treturn;\n\n\tpartial = sol->partial;\n\tif (!partial)\n\t\treturn;\n\n\tif (partial->level == 0 && sol->level == 0) {\n\t\tfor (partial = sol->partial; partial; partial = sol->partial)\n\t\t\tsol_pop_one(sol);\n\t\treturn;\n\t}\n\n\tif (partial->level <= sol->level)\n\t\treturn;\n\n\tif (partial->next && partial->next->level == partial->level) {\n\t\tif (combine_initial_if_equal(sol) < 0)\n\t\t\tgoto error;\n\t} else\n\t\tsol_pop_one(sol);\n\n\tif (sol->level == 0) {\n\t\tfor (partial = sol->partial; partial; partial = sol->partial)\n\t\t\tsol_pop_one(sol);\n\t\treturn;\n\t}\n\n\tif (0)\nerror:\t\tsol->error = 1;\n}\n\nstatic void sol_dec_level(struct isl_sol *sol)\n{\n\tif (sol->error)\n\t\treturn;\n\n\tsol->level--;\n\n\tsol_pop(sol);\n}\n\nstatic isl_stat sol_dec_level_wrap(struct isl_tab_callback *cb)\n{\n\tstruct isl_sol_callback *callback = (struct isl_sol_callback *)cb;\n\n\tsol_dec_level(callback->sol);\n\n\treturn callback->sol->error ? isl_stat_error : isl_stat_ok;\n}\n\n/* Move down to next level and push callback onto context tableau\n * to decrease the level again when it gets rolled back across\n * the current state.  That is, dec_level will be called with\n * the context tableau in the same state as it is when inc_level\n * is called.\n */\nstatic void sol_inc_level(struct isl_sol *sol)\n{\n\tstruct isl_tab *tab;\n\n\tif (sol->error)\n\t\treturn;\n\n\tsol->level++;\n\ttab = sol->context->op->peek_tab(sol->context);\n\tif (isl_tab_push_callback(tab, &sol->dec_level.callback) < 0)\n\t\tsol->error = 1;\n}\n\nstatic void scale_rows(struct isl_mat *mat, isl_int m, int n_row)\n{\n\tint i;\n\n\tif (isl_int_is_one(m))\n\t\treturn;\n\n\tfor (i = 0; i < n_row; ++i)\n\t\tisl_seq_scale(mat->row[i], mat->row[i], m, mat->n_col);\n}\n\n/* Add the solution identified by the tableau and the context tableau.\n *\n * The layout of the variables is as follows.\n *\ttab->n_var is equal to the total number of variables in the input\n *\t\t\tmap (including divs that were copied from the context)\n *\t\t\t+ the number of extra divs constructed\n *      Of these, the first tab->n_param and the last tab->n_div variables\n *\tcorrespond to the variables in the context, i.e.,\n *\t\ttab->n_param + tab->n_div = context_tab->n_var\n *\ttab->n_param is equal to the number of parameters and input\n *\t\t\tdimensions in the input map\n *\ttab->n_div is equal to the number of divs in the context\n *\n * If there is no solution, then call add_empty with a basic set\n * that corresponds to the context tableau.  (If add_empty is NULL,\n * then do nothing).\n *\n * If there is a solution, then first construct a matrix that maps\n * all dimensions of the context to the output variables, i.e.,\n * the output dimensions in the input map.\n * The divs in the input map (if any) that do not correspond to any\n * div in the context do not appear in the solution.\n * The algorithm will make sure that they have an integer value,\n * but these values themselves are of no interest.\n * We have to be careful not to drop or rearrange any divs in the\n * context because that would change the meaning of the matrix.\n *\n * To extract the value of the output variables, it should be noted\n * that we always use a big parameter M in the main tableau and so\n * the variable stored in this tableau is not an output variable x itself, but\n *\tx' = M + x (in case of minimization)\n * or\n *\tx' = M - x (in case of maximization)\n * If x' appears in a column, then its optimal value is zero,\n * which means that the optimal value of x is an unbounded number\n * (-M for minimization and M for maximization).\n * We currently assume that the output dimensions in the original map\n * are bounded, so this cannot occur.\n * Similarly, when x' appears in a row, then the coefficient of M in that\n * row is necessarily 1.\n * If the row in the tableau represents\n *\td x' = c + d M + e(y)\n * then, in case of minimization, the corresponding row in the matrix\n * will be\n *\ta c + a e(y)\n * with a d = m, the (updated) common denominator of the matrix.\n * In case of maximization, the row will be\n *\t-a c - a e(y)\n */\nstatic void sol_add(struct isl_sol *sol, struct isl_tab *tab)\n{\n\tstruct isl_basic_set *bset = NULL;\n\tstruct isl_mat *mat = NULL;\n\tunsigned off;\n\tint row;\n\tisl_int m;\n\n\tif (sol->error || !tab)\n\t\tgoto error;\n\n\tif (tab->empty && !sol->add_empty)\n\t\treturn;\n\tif (sol->context->op->is_empty(sol->context))\n\t\treturn;\n\n\tbset = sol_domain(sol);\n\n\tif (tab->empty) {\n\t\tsol_push_sol(sol, bset, NULL);\n\t\treturn;\n\t}\n\n\toff = 2 + tab->M;\n\n\tmat = isl_mat_alloc(tab->mat->ctx, 1 + sol->n_out,\n\t\t\t\t\t    1 + tab->n_param + tab->n_div);\n\tif (!mat)\n\t\tgoto error;\n\n\tisl_int_init(m);\n\n\tisl_seq_clr(mat->row[0] + 1, mat->n_col - 1);\n\tisl_int_set_si(mat->row[0][0], 1);\n\tfor (row = 0; row < sol->n_out; ++row) {\n\t\tint i = tab->n_param + row;\n\t\tint r, j;\n\n\t\tisl_seq_clr(mat->row[1 + row], mat->n_col);\n\t\tif (!tab->var[i].is_row) {\n\t\t\tif (tab->M)\n\t\t\t\tisl_die(mat->ctx, isl_error_invalid,\n\t\t\t\t\t\"unbounded optimum\", goto error2);\n\t\t\tcontinue;\n\t\t}\n\n\t\tr = tab->var[i].index;\n\t\tif (tab->M &&\n\t\t    isl_int_ne(tab->mat->row[r][2], tab->mat->row[r][0]))\n\t\t\tisl_die(mat->ctx, isl_error_invalid,\n\t\t\t\t\"unbounded optimum\", goto error2);\n\t\tisl_int_gcd(m, mat->row[0][0], tab->mat->row[r][0]);\n\t\tisl_int_divexact(m, tab->mat->row[r][0], m);\n\t\tscale_rows(mat, m, 1 + row);\n\t\tisl_int_divexact(m, mat->row[0][0], tab->mat->row[r][0]);\n\t\tisl_int_mul(mat->row[1 + row][0], m, tab->mat->row[r][1]);\n\t\tfor (j = 0; j < tab->n_param; ++j) {\n\t\t\tint col;\n\t\t\tif (tab->var[j].is_row)\n\t\t\t\tcontinue;\n\t\t\tcol = tab->var[j].index;\n\t\t\tisl_int_mul(mat->row[1 + row][1 + j], m,\n\t\t\t\t    tab->mat->row[r][off + col]);\n\t\t}\n\t\tfor (j = 0; j < tab->n_div; ++j) {\n\t\t\tint col;\n\t\t\tif (tab->var[tab->n_var - tab->n_div+j].is_row)\n\t\t\t\tcontinue;\n\t\t\tcol = tab->var[tab->n_var - tab->n_div+j].index;\n\t\t\tisl_int_mul(mat->row[1 + row][1 + tab->n_param + j], m,\n\t\t\t\t    tab->mat->row[r][off + col]);\n\t\t}\n\t\tif (sol->max)\n\t\t\tisl_seq_neg(mat->row[1 + row], mat->row[1 + row],\n\t\t\t\t    mat->n_col);\n\t}\n\n\tisl_int_clear(m);\n\n\tsol_push_sol_mat(sol, bset, mat);\n\treturn;\nerror2:\n\tisl_int_clear(m);\nerror:\n\tisl_basic_set_free(bset);\n\tisl_mat_free(mat);\n\tsol->error = 1;\n}\n\nstruct isl_sol_map {\n\tstruct isl_sol\tsol;\n\tstruct isl_map\t*map;\n\tstruct isl_set\t*empty;\n};\n\nstatic void sol_map_free(struct isl_sol *sol)\n{\n\tstruct isl_sol_map *sol_map = (struct isl_sol_map *) sol;\n\tisl_map_free(sol_map->map);\n\tisl_set_free(sol_map->empty);\n}\n\n/* This function is called for parts of the context where there is\n * no solution, with \"bset\" corresponding to the context tableau.\n * Simply add the basic set to the set \"empty\".\n */\nstatic void sol_map_add_empty(struct isl_sol_map *sol,\n\tstruct isl_basic_set *bset)\n{\n\tif (!bset || !sol->empty)\n\t\tgoto error;\n\n\tsol->empty = isl_set_grow(sol->empty, 1);\n\tbset = isl_basic_set_simplify(bset);\n\tbset = isl_basic_set_finalize(bset);\n\tsol->empty = isl_set_add_basic_set(sol->empty, isl_basic_set_copy(bset));\n\tif (!sol->empty)\n\t\tgoto error;\n\tisl_basic_set_free(bset);\n\treturn;\nerror:\n\tisl_basic_set_free(bset);\n\tsol->sol.error = 1;\n}\n\nstatic void sol_map_add_empty_wrap(struct isl_sol *sol,\n\tstruct isl_basic_set *bset)\n{\n\tsol_map_add_empty((struct isl_sol_map *)sol, bset);\n}\n\n/* Given a basic set \"dom\" that represents the context and a tuple of\n * affine expressions \"ma\" defined over this domain, construct a basic map\n * that expresses this function on the domain.\n */\nstatic void sol_map_add(struct isl_sol_map *sol,\n\t__isl_take isl_basic_set *dom, __isl_take isl_multi_aff *ma)\n{\n\tisl_basic_map *bmap;\n\n\tif (sol->sol.error || !dom || !ma)\n\t\tgoto error;\n\n\tbmap = isl_basic_map_from_multi_aff2(ma, sol->sol.rational);\n\tbmap = isl_basic_map_intersect_domain(bmap, dom);\n\tsol->map = isl_map_grow(sol->map, 1);\n\tsol->map = isl_map_add_basic_map(sol->map, bmap);\n\tif (!sol->map)\n\t\tsol->sol.error = 1;\n\treturn;\nerror:\n\tisl_basic_set_free(dom);\n\tisl_multi_aff_free(ma);\n\tsol->sol.error = 1;\n}\n\nstatic void sol_map_add_wrap(struct isl_sol *sol,\n\t__isl_take isl_basic_set *dom, __isl_take isl_multi_aff *ma)\n{\n\tsol_map_add((struct isl_sol_map *)sol, dom, ma);\n}\n\n\n/* Store the \"parametric constant\" of row \"row\" of tableau \"tab\" in \"line\",\n * i.e., the constant term and the coefficients of all variables that\n * appear in the context tableau.\n * Note that the coefficient of the big parameter M is NOT copied.\n * The context tableau may not have a big parameter and even when it\n * does, it is a different big parameter.\n */\nstatic void get_row_parameter_line(struct isl_tab *tab, int row, isl_int *line)\n{\n\tint i;\n\tunsigned off = 2 + tab->M;\n\n\tisl_int_set(line[0], tab->mat->row[row][1]);\n\tfor (i = 0; i < tab->n_param; ++i) {\n\t\tif (tab->var[i].is_row)\n\t\t\tisl_int_set_si(line[1 + i], 0);\n\t\telse {\n\t\t\tint col = tab->var[i].index;\n\t\t\tisl_int_set(line[1 + i], tab->mat->row[row][off + col]);\n\t\t}\n\t}\n\tfor (i = 0; i < tab->n_div; ++i) {\n\t\tif (tab->var[tab->n_var - tab->n_div + i].is_row)\n\t\t\tisl_int_set_si(line[1 + tab->n_param + i], 0);\n\t\telse {\n\t\t\tint col = tab->var[tab->n_var - tab->n_div + i].index;\n\t\t\tisl_int_set(line[1 + tab->n_param + i],\n\t\t\t\t    tab->mat->row[row][off + col]);\n\t\t}\n\t}\n}\n\n/* Check if rows \"row1\" and \"row2\" have identical \"parametric constants\",\n * as explained above.\n * In this case, we also insist that the coefficients of the big parameter\n * be the same as the values of the constants will only be the same\n * if these coefficients are also the same.\n */\nstatic int identical_parameter_line(struct isl_tab *tab, int row1, int row2)\n{\n\tint i;\n\tunsigned off = 2 + tab->M;\n\n\tif (isl_int_ne(tab->mat->row[row1][1], tab->mat->row[row2][1]))\n\t\treturn 0;\n\n\tif (tab->M && isl_int_ne(tab->mat->row[row1][2],\n\t\t\t\t tab->mat->row[row2][2]))\n\t\treturn 0;\n\n\tfor (i = 0; i < tab->n_param + tab->n_div; ++i) {\n\t\tint pos = i < tab->n_param ? i :\n\t\t\ttab->n_var - tab->n_div + i - tab->n_param;\n\t\tint col;\n\n\t\tif (tab->var[pos].is_row)\n\t\t\tcontinue;\n\t\tcol = tab->var[pos].index;\n\t\tif (isl_int_ne(tab->mat->row[row1][off + col],\n\t\t\t       tab->mat->row[row2][off + col]))\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n/* Return an inequality that expresses that the \"parametric constant\"\n * should be non-negative.\n * This function is only called when the coefficient of the big parameter\n * is equal to zero.\n */\nstatic struct isl_vec *get_row_parameter_ineq(struct isl_tab *tab, int row)\n{\n\tstruct isl_vec *ineq;\n\n\tineq = isl_vec_alloc(tab->mat->ctx, 1 + tab->n_param + tab->n_div);\n\tif (!ineq)\n\t\treturn NULL;\n\n\tget_row_parameter_line(tab, row, ineq->el);\n\tif (ineq)\n\t\tineq = isl_vec_normalize(ineq);\n\n\treturn ineq;\n}\n\n/* Normalize a div expression of the form\n *\n *\t[(g*f(x) + c)/(g * m)]\n *\n * with c the constant term and f(x) the remaining coefficients, to\n *\n *\t[(f(x) + [c/g])/m]\n */\nstatic void normalize_div(__isl_keep isl_vec *div)\n{\n\tisl_ctx *ctx = isl_vec_get_ctx(div);\n\tint len = div->size - 2;\n\n\tisl_seq_gcd(div->el + 2, len, &ctx->normalize_gcd);\n\tisl_int_gcd(ctx->normalize_gcd, ctx->normalize_gcd, div->el[0]);\n\n\tif (isl_int_is_one(ctx->normalize_gcd))\n\t\treturn;\n\n\tisl_int_divexact(div->el[0], div->el[0], ctx->normalize_gcd);\n\tisl_int_fdiv_q(div->el[1], div->el[1], ctx->normalize_gcd);\n\tisl_seq_scale_down(div->el + 2, div->el + 2, ctx->normalize_gcd, len);\n}\n\n/* Return an integer division for use in a parametric cut based\n * on the given row.\n * In particular, let the parametric constant of the row be\n *\n *\t\t\\sum_i a_i y_i\n *\n * where y_0 = 1, but none of the y_i corresponds to the big parameter M.\n * The div returned is equal to\n *\n *\t\tfloor(\\sum_i {-a_i} y_i) = floor((\\sum_i (-a_i mod d) y_i)/d)\n */\nstatic struct isl_vec *get_row_parameter_div(struct isl_tab *tab, int row)\n{\n\tstruct isl_vec *div;\n\n\tdiv = isl_vec_alloc(tab->mat->ctx, 1 + 1 + tab->n_param + tab->n_div);\n\tif (!div)\n\t\treturn NULL;\n\n\tisl_int_set(div->el[0], tab->mat->row[row][0]);\n\tget_row_parameter_line(tab, row, div->el + 1);\n\tisl_seq_neg(div->el + 1, div->el + 1, div->size - 1);\n\tnormalize_div(div);\n\tisl_seq_fdiv_r(div->el + 1, div->el + 1, div->el[0], div->size - 1);\n\n\treturn div;\n}\n\n/* Return an integer division for use in transferring an integrality constraint\n * to the context.\n * In particular, let the parametric constant of the row be\n *\n *\t\t\\sum_i a_i y_i\n *\n * where y_0 = 1, but none of the y_i corresponds to the big parameter M.\n * The the returned div is equal to\n *\n *\t\tfloor(\\sum_i {a_i} y_i) = floor((\\sum_i (a_i mod d) y_i)/d)\n */\nstatic struct isl_vec *get_row_split_div(struct isl_tab *tab, int row)\n{\n\tstruct isl_vec *div;\n\n\tdiv = isl_vec_alloc(tab->mat->ctx, 1 + 1 + tab->n_param + tab->n_div);\n\tif (!div)\n\t\treturn NULL;\n\n\tisl_int_set(div->el[0], tab->mat->row[row][0]);\n\tget_row_parameter_line(tab, row, div->el + 1);\n\tnormalize_div(div);\n\tisl_seq_fdiv_r(div->el + 1, div->el + 1, div->el[0], div->size - 1);\n\n\treturn div;\n}\n\n/* Construct and return an inequality that expresses an upper bound\n * on the given div.\n * In particular, if the div is given by\n *\n *\td = floor(e/m)\n *\n * then the inequality expresses\n *\n *\tm d <= e\n */\nstatic __isl_give isl_vec *ineq_for_div(__isl_keep isl_basic_set *bset,\n\tunsigned div)\n{\n\tisl_size total;\n\tunsigned div_pos;\n\tstruct isl_vec *ineq;\n\n\ttotal = isl_basic_set_dim(bset, isl_dim_all);\n\tif (total < 0)\n\t\treturn NULL;\n\n\tdiv_pos = 1 + total - bset->n_div + div;\n\n\tineq = isl_vec_alloc(bset->ctx, 1 + total);\n\tif (!ineq)\n\t\treturn NULL;\n\n\tisl_seq_cpy(ineq->el, bset->div[div] + 1, 1 + total);\n\tisl_int_neg(ineq->el[div_pos], bset->div[div][0]);\n\treturn ineq;\n}\n\n/* Given a row in the tableau and a div that was created\n * using get_row_split_div and that has been constrained to equality, i.e.,\n *\n *\t\td = floor(\\sum_i {a_i} y_i) = \\sum_i {a_i} y_i\n *\n * replace the expression \"\\sum_i {a_i} y_i\" in the row by d,\n * i.e., we subtract \"\\sum_i {a_i} y_i\" and add 1 d.\n * The coefficients of the non-parameters in the tableau have been\n * verified to be integral.  We can therefore simply replace coefficient b\n * by floor(b).  For the coefficients of the parameters we have\n * floor(a_i) = a_i - {a_i}, while for the other coefficients, we have\n * floor(b) = b.\n */\nstatic struct isl_tab *set_row_cst_to_div(struct isl_tab *tab, int row, int div)\n{\n\tisl_seq_fdiv_q(tab->mat->row[row] + 1, tab->mat->row[row] + 1,\n\t\t\ttab->mat->row[row][0], 1 + tab->M + tab->n_col);\n\n\tisl_int_set_si(tab->mat->row[row][0], 1);\n\n\tif (tab->var[tab->n_var - tab->n_div + div].is_row) {\n\t\tint drow = tab->var[tab->n_var - tab->n_div + div].index;\n\n\t\tisl_assert(tab->mat->ctx,\n\t\t\tisl_int_is_one(tab->mat->row[drow][0]), goto error);\n\t\tisl_seq_combine(tab->mat->row[row] + 1,\n\t\t\ttab->mat->ctx->one, tab->mat->row[row] + 1,\n\t\t\ttab->mat->ctx->one, tab->mat->row[drow] + 1,\n\t\t\t1 + tab->M + tab->n_col);\n\t} else {\n\t\tint dcol = tab->var[tab->n_var - tab->n_div + div].index;\n\n\t\tisl_int_add_ui(tab->mat->row[row][2 + tab->M + dcol],\n\t\t\t\ttab->mat->row[row][2 + tab->M + dcol], 1);\n\t}\n\n\treturn tab;\nerror:\n\tisl_tab_free(tab);\n\treturn NULL;\n}\n\n/* Check if the (parametric) constant of the given row is obviously\n * negative, meaning that we don't need to consult the context tableau.\n * If there is a big parameter and its coefficient is non-zero,\n * then this coefficient determines the outcome.\n * Otherwise, we check whether the constant is negative and\n * all non-zero coefficients of parameters are negative and\n * belong to non-negative parameters.\n */\nstatic int is_obviously_neg(struct isl_tab *tab, int row)\n{\n\tint i;\n\tint col;\n\tunsigned off = 2 + tab->M;\n\n\tif (tab->M) {\n\t\tif (isl_int_is_pos(tab->mat->row[row][2]))\n\t\t\treturn 0;\n\t\tif (isl_int_is_neg(tab->mat->row[row][2]))\n\t\t\treturn 1;\n\t}\n\n\tif (isl_int_is_nonneg(tab->mat->row[row][1]))\n\t\treturn 0;\n\tfor (i = 0; i < tab->n_param; ++i) {\n\t\t/* Eliminated parameter */\n\t\tif (tab->var[i].is_row)\n\t\t\tcontinue;\n\t\tcol = tab->var[i].index;\n\t\tif (isl_int_is_zero(tab->mat->row[row][off + col]))\n\t\t\tcontinue;\n\t\tif (!tab->var[i].is_nonneg)\n\t\t\treturn 0;\n\t\tif (isl_int_is_pos(tab->mat->row[row][off + col]))\n\t\t\treturn 0;\n\t}\n\tfor (i = 0; i < tab->n_div; ++i) {\n\t\tif (tab->var[tab->n_var - tab->n_div + i].is_row)\n\t\t\tcontinue;\n\t\tcol = tab->var[tab->n_var - tab->n_div + i].index;\n\t\tif (isl_int_is_zero(tab->mat->row[row][off + col]))\n\t\t\tcontinue;\n\t\tif (!tab->var[tab->n_var - tab->n_div + i].is_nonneg)\n\t\t\treturn 0;\n\t\tif (isl_int_is_pos(tab->mat->row[row][off + col]))\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n/* Check if the (parametric) constant of the given row is obviously\n * non-negative, meaning that we don't need to consult the context tableau.\n * If there is a big parameter and its coefficient is non-zero,\n * then this coefficient determines the outcome.\n * Otherwise, we check whether the constant is non-negative and\n * all non-zero coefficients of parameters are positive and\n * belong to non-negative parameters.\n */\nstatic int is_obviously_nonneg(struct isl_tab *tab, int row)\n{\n\tint i;\n\tint col;\n\tunsigned off = 2 + tab->M;\n\n\tif (tab->M) {\n\t\tif (isl_int_is_pos(tab->mat->row[row][2]))\n\t\t\treturn 1;\n\t\tif (isl_int_is_neg(tab->mat->row[row][2]))\n\t\t\treturn 0;\n\t}\n\n\tif (isl_int_is_neg(tab->mat->row[row][1]))\n\t\treturn 0;\n\tfor (i = 0; i < tab->n_param; ++i) {\n\t\t/* Eliminated parameter */\n\t\tif (tab->var[i].is_row)\n\t\t\tcontinue;\n\t\tcol = tab->var[i].index;\n\t\tif (isl_int_is_zero(tab->mat->row[row][off + col]))\n\t\t\tcontinue;\n\t\tif (!tab->var[i].is_nonneg)\n\t\t\treturn 0;\n\t\tif (isl_int_is_neg(tab->mat->row[row][off + col]))\n\t\t\treturn 0;\n\t}\n\tfor (i = 0; i < tab->n_div; ++i) {\n\t\tif (tab->var[tab->n_var - tab->n_div + i].is_row)\n\t\t\tcontinue;\n\t\tcol = tab->var[tab->n_var - tab->n_div + i].index;\n\t\tif (isl_int_is_zero(tab->mat->row[row][off + col]))\n\t\t\tcontinue;\n\t\tif (!tab->var[tab->n_var - tab->n_div + i].is_nonneg)\n\t\t\treturn 0;\n\t\tif (isl_int_is_neg(tab->mat->row[row][off + col]))\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n/* Given a row r and two columns, return the column that would\n * lead to the lexicographically smallest increment in the sample\n * solution when leaving the basis in favor of the row.\n * Pivoting with column c will increment the sample value by a non-negative\n * constant times a_{V,c}/a_{r,c}, with a_{V,c} the elements of column c\n * corresponding to the non-parametric variables.\n * If variable v appears in a column c_v, then a_{v,c} = 1 iff c = c_v,\n * with all other entries in this virtual row equal to zero.\n * If variable v appears in a row, then a_{v,c} is the element in column c\n * of that row.\n *\n * Let v be the first variable with a_{v,c1}/a_{r,c1} != a_{v,c2}/a_{r,c2}.\n * Then if a_{v,c1}/a_{r,c1} < a_{v,c2}/a_{r,c2}, i.e.,\n * a_{v,c2} a_{r,c1} - a_{v,c1} a_{r,c2} > 0, c1 results in the minimal\n * increment.  Otherwise, it's c2.\n */\nstatic int lexmin_col_pair(struct isl_tab *tab,\n\tint row, int col1, int col2, isl_int tmp)\n{\n\tint i;\n\tisl_int *tr;\n\n\ttr = tab->mat->row[row] + 2 + tab->M;\n\n\tfor (i = tab->n_param; i < tab->n_var - tab->n_div; ++i) {\n\t\tint s1, s2;\n\t\tisl_int *r;\n\n\t\tif (!tab->var[i].is_row) {\n\t\t\tif (tab->var[i].index == col1)\n\t\t\t\treturn col2;\n\t\t\tif (tab->var[i].index == col2)\n\t\t\t\treturn col1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (tab->var[i].index == row)\n\t\t\tcontinue;\n\n\t\tr = tab->mat->row[tab->var[i].index] + 2 + tab->M;\n\t\ts1 = isl_int_sgn(r[col1]);\n\t\ts2 = isl_int_sgn(r[col2]);\n\t\tif (s1 == 0 && s2 == 0)\n\t\t\tcontinue;\n\t\tif (s1 < s2)\n\t\t\treturn col1;\n\t\tif (s2 < s1)\n\t\t\treturn col2;\n\n\t\tisl_int_mul(tmp, r[col2], tr[col1]);\n\t\tisl_int_submul(tmp, r[col1], tr[col2]);\n\t\tif (isl_int_is_pos(tmp))\n\t\t\treturn col1;\n\t\tif (isl_int_is_neg(tmp))\n\t\t\treturn col2;\n\t}\n\treturn -1;\n}\n\n/* Does the index into the tab->var or tab->con array \"index\"\n * correspond to a variable in the context tableau?\n * In particular, it needs to be an index into the tab->var array and\n * it needs to refer to either one of the first tab->n_param variables or\n * one of the last tab->n_div variables.\n */\nstatic int is_parameter_var(struct isl_tab *tab, int index)\n{\n\tif (index < 0)\n\t\treturn 0;\n\tif (index < tab->n_param)\n\t\treturn 1;\n\tif (index >= tab->n_var - tab->n_div)\n\t\treturn 1;\n\treturn 0;\n}\n\n/* Does column \"col\" of \"tab\" refer to a variable in the context tableau?\n */\nstatic int col_is_parameter_var(struct isl_tab *tab, int col)\n{\n\treturn is_parameter_var(tab, tab->col_var[col]);\n}\n\n/* Does row \"row\" of \"tab\" refer to a variable in the context tableau?\n */\nstatic int row_is_parameter_var(struct isl_tab *tab, int row)\n{\n\treturn is_parameter_var(tab, tab->row_var[row]);\n}\n\n/* Given a row in the tableau, find and return the column that would\n * result in the lexicographically smallest, but positive, increment\n * in the sample point.\n * If there is no such column, then return tab->n_col.\n * If anything goes wrong, return -1.\n */\nstatic int lexmin_pivot_col(struct isl_tab *tab, int row)\n{\n\tint j;\n\tint col = tab->n_col;\n\tisl_int *tr;\n\tisl_int tmp;\n\n\ttr = tab->mat->row[row] + 2 + tab->M;\n\n\tisl_int_init(tmp);\n\n\tfor (j = tab->n_dead; j < tab->n_col; ++j) {\n\t\tif (col_is_parameter_var(tab, j))\n\t\t\tcontinue;\n\n\t\tif (!isl_int_is_pos(tr[j]))\n\t\t\tcontinue;\n\n\t\tif (col == tab->n_col)\n\t\t\tcol = j;\n\t\telse\n\t\t\tcol = lexmin_col_pair(tab, row, col, j, tmp);\n\t\tisl_assert(tab->mat->ctx, col >= 0, goto error);\n\t}\n\n\tisl_int_clear(tmp);\n\treturn col;\nerror:\n\tisl_int_clear(tmp);\n\treturn -1;\n}\n\n/* Return the first known violated constraint, i.e., a non-negative\n * constraint that currently has an either obviously negative value\n * or a previously determined to be negative value.\n *\n * If any constraint has a negative coefficient for the big parameter,\n * if any, then we return one of these first.\n */\nstatic int first_neg(struct isl_tab *tab)\n{\n\tint row;\n\n\tif (tab->M)\n\t\tfor (row = tab->n_redundant; row < tab->n_row; ++row) {\n\t\t\tif (!isl_tab_var_from_row(tab, row)->is_nonneg)\n\t\t\t\tcontinue;\n\t\t\tif (!isl_int_is_neg(tab->mat->row[row][2]))\n\t\t\t\tcontinue;\n\t\t\tif (tab->row_sign)\n\t\t\t\ttab->row_sign[row] = isl_tab_row_neg;\n\t\t\treturn row;\n\t\t}\n\tfor (row = tab->n_redundant; row < tab->n_row; ++row) {\n\t\tif (!isl_tab_var_from_row(tab, row)->is_nonneg)\n\t\t\tcontinue;\n\t\tif (tab->row_sign) {\n\t\t\tif (tab->row_sign[row] == 0 &&\n\t\t\t    is_obviously_neg(tab, row))\n\t\t\t\ttab->row_sign[row] = isl_tab_row_neg;\n\t\t\tif (tab->row_sign[row] != isl_tab_row_neg)\n\t\t\t\tcontinue;\n\t\t} else if (!is_obviously_neg(tab, row))\n\t\t\tcontinue;\n\t\treturn row;\n\t}\n\treturn -1;\n}\n\n/* Check whether the invariant that all columns are lexico-positive\n * is satisfied.  This function is not called from the current code\n * but is useful during debugging.\n */\nstatic void check_lexpos(struct isl_tab *tab) __attribute__ ((unused));\nstatic void check_lexpos(struct isl_tab *tab)\n{\n\tunsigned off = 2 + tab->M;\n\tint col;\n\tint var;\n\tint row;\n\n\tfor (col = tab->n_dead; col < tab->n_col; ++col) {\n\t\tif (col_is_parameter_var(tab, col))\n\t\t\tcontinue;\n\t\tfor (var = tab->n_param; var < tab->n_var - tab->n_div; ++var) {\n\t\t\tif (!tab->var[var].is_row) {\n\t\t\t\tif (tab->var[var].index == col)\n\t\t\t\t\tbreak;\n\t\t\t\telse\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trow = tab->var[var].index;\n\t\t\tif (isl_int_is_zero(tab->mat->row[row][off + col]))\n\t\t\t\tcontinue;\n\t\t\tif (isl_int_is_pos(tab->mat->row[row][off + col]))\n\t\t\t\tbreak;\n\t\t\tfprintf(stderr, \"lexneg column %d (row %d)\\n\",\n\t\t\t\tcol, row);\n\t\t}\n\t\tif (var >= tab->n_var - tab->n_div)\n\t\t\tfprintf(stderr, \"zero column %d\\n\", col);\n\t}\n}\n\n/* Report to the caller that the given constraint is part of an encountered\n * conflict.\n */\nstatic int report_conflicting_constraint(struct isl_tab *tab, int con)\n{\n\treturn tab->conflict(con, tab->conflict_user);\n}\n\n/* Given a conflicting row in the tableau, report all constraints\n * involved in the row to the caller.  That is, the row itself\n * (if it represents a constraint) and all constraint columns with\n * non-zero (and therefore negative) coefficients.\n */\nstatic int report_conflict(struct isl_tab *tab, int row)\n{\n\tint j;\n\tisl_int *tr;\n\n\tif (!tab->conflict)\n\t\treturn 0;\n\n\tif (tab->row_var[row] < 0 &&\n\t    report_conflicting_constraint(tab, ~tab->row_var[row]) < 0)\n\t\treturn -1;\n\n\ttr = tab->mat->row[row] + 2 + tab->M;\n\n\tfor (j = tab->n_dead; j < tab->n_col; ++j) {\n\t\tif (col_is_parameter_var(tab, j))\n\t\t\tcontinue;\n\n\t\tif (!isl_int_is_neg(tr[j]))\n\t\t\tcontinue;\n\n\t\tif (tab->col_var[j] < 0 &&\n\t\t    report_conflicting_constraint(tab, ~tab->col_var[j]) < 0)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n/* Resolve all known or obviously violated constraints through pivoting.\n * In particular, as long as we can find any violated constraint, we\n * look for a pivoting column that would result in the lexicographically\n * smallest increment in the sample point.  If there is no such column\n * then the tableau is infeasible.\n */\nstatic int restore_lexmin(struct isl_tab *tab) WARN_UNUSED;\nstatic int restore_lexmin(struct isl_tab *tab)\n{\n\tint row, col;\n\n\tif (!tab)\n\t\treturn -1;\n\tif (tab->empty)\n\t\treturn 0;\n\twhile ((row = first_neg(tab)) != -1) {\n\t\tcol = lexmin_pivot_col(tab, row);\n\t\tif (col >= tab->n_col) {\n\t\t\tif (report_conflict(tab, row) < 0)\n\t\t\t\treturn -1;\n\t\t\tif (isl_tab_mark_empty(tab) < 0)\n\t\t\t\treturn -1;\n\t\t\treturn 0;\n\t\t}\n\t\tif (col < 0)\n\t\t\treturn -1;\n\t\tif (isl_tab_pivot(tab, row, col) < 0)\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n/* Given a row that represents an equality, look for an appropriate\n * pivoting column.\n * In particular, if there are any non-zero coefficients among\n * the non-parameter variables, then we take the last of these\n * variables.  Eliminating this variable in terms of the other\n * variables and/or parameters does not influence the property\n * that all column in the initial tableau are lexicographically\n * positive.  The row corresponding to the eliminated variable\n * will only have non-zero entries below the diagonal of the\n * initial tableau.  That is, we transform\n *\n *\t\tI\t\t\t\tI\n *\t\t  1\t\tinto\t\ta\n *\t\t    I\t\t\t\t  I\n *\n * If there is no such non-parameter variable, then we are dealing with\n * pure parameter equality and we pick any parameter with coefficient 1 or -1\n * for elimination.  This will ensure that the eliminated parameter\n * always has an integer value whenever all the other parameters are integral.\n * If there is no such parameter then we return -1.\n */\nstatic int last_var_col_or_int_par_col(struct isl_tab *tab, int row)\n{\n\tunsigned off = 2 + tab->M;\n\tint i;\n\n\tfor (i = tab->n_var - tab->n_div - 1; i >= 0 && i >= tab->n_param; --i) {\n\t\tint col;\n\t\tif (tab->var[i].is_row)\n\t\t\tcontinue;\n\t\tcol = tab->var[i].index;\n\t\tif (col <= tab->n_dead)\n\t\t\tcontinue;\n\t\tif (!isl_int_is_zero(tab->mat->row[row][off + col]))\n\t\t\treturn col;\n\t}\n\tfor (i = tab->n_dead; i < tab->n_col; ++i) {\n\t\tif (isl_int_is_one(tab->mat->row[row][off + i]))\n\t\t\treturn i;\n\t\tif (isl_int_is_negone(tab->mat->row[row][off + i]))\n\t\t\treturn i;\n\t}\n\treturn -1;\n}\n\n/* Add an equality that is known to be valid to the tableau.\n * We first check if we can eliminate a variable or a parameter.\n * If not, we add the equality as two inequalities.\n * In this case, the equality was a pure parameter equality and there\n * is no need to resolve any constraint violations.\n *\n * This function assumes that at least two more rows and at least\n * two more elements in the constraint array are available in the tableau.\n */\nstatic struct isl_tab *add_lexmin_valid_eq(struct isl_tab *tab, isl_int *eq)\n{\n\tint i;\n\tint r;\n\n\tif (!tab)\n\t\treturn NULL;\n\tr = isl_tab_add_row(tab, eq);\n\tif (r < 0)\n\t\tgoto error;\n\n\tr = tab->con[r].index;\n\ti = last_var_col_or_int_par_col(tab, r);\n\tif (i < 0) {\n\t\ttab->con[r].is_nonneg = 1;\n\t\tif (isl_tab_push_var(tab, isl_tab_undo_nonneg, &tab->con[r]) < 0)\n\t\t\tgoto error;\n\t\tisl_seq_neg(eq, eq, 1 + tab->n_var);\n\t\tr = isl_tab_add_row(tab, eq);\n\t\tif (r < 0)\n\t\t\tgoto error;\n\t\ttab->con[r].is_nonneg = 1;\n\t\tif (isl_tab_push_var(tab, isl_tab_undo_nonneg, &tab->con[r]) < 0)\n\t\t\tgoto error;\n\t} else {\n\t\tif (isl_tab_pivot(tab, r, i) < 0)\n\t\t\tgoto error;\n\t\tif (isl_tab_kill_col(tab, i) < 0)\n\t\t\tgoto error;\n\t\ttab->n_eq++;\n\t}\n\n\treturn tab;\nerror:\n\tisl_tab_free(tab);\n\treturn NULL;\n}\n\n/* Check if the given row is a pure constant.\n */\nstatic int is_constant(struct isl_tab *tab, int row)\n{\n\tunsigned off = 2 + tab->M;\n\n\treturn isl_seq_first_non_zero(tab->mat->row[row] + off + tab->n_dead,\n\t\t\t\t\ttab->n_col - tab->n_dead) == -1;\n}\n\n/* Is the given row a parametric constant?\n * That is, does it only involve variables that also appear in the context?\n */\nstatic int is_parametric_constant(struct isl_tab *tab, int row)\n{\n\tunsigned off = 2 + tab->M;\n\tint col;\n\n\tfor (col = tab->n_dead; col < tab->n_col; ++col) {\n\t\tif (col_is_parameter_var(tab, col))\n\t\t\tcontinue;\n\t\tif (isl_int_is_zero(tab->mat->row[row][off + col]))\n\t\t\tcontinue;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n/* Add an equality that may or may not be valid to the tableau.\n * If the resulting row is a pure constant, then it must be zero.\n * Otherwise, the resulting tableau is empty.\n *\n * If the row is not a pure constant, then we add two inequalities,\n * each time checking that they can be satisfied.\n * In the end we try to use one of the two constraints to eliminate\n * a column.\n *\n * This function assumes that at least two more rows and at least\n * two more elements in the constraint array are available in the tableau.\n */\nstatic int add_lexmin_eq(struct isl_tab *tab, isl_int *eq) WARN_UNUSED;\nstatic int add_lexmin_eq(struct isl_tab *tab, isl_int *eq)\n{\n\tint r1, r2;\n\tint row;\n\tstruct isl_tab_undo *snap;\n\n\tif (!tab)\n\t\treturn -1;\n\tsnap = isl_tab_snap(tab);\n\tr1 = isl_tab_add_row(tab, eq);\n\tif (r1 < 0)\n\t\treturn -1;\n\ttab->con[r1].is_nonneg = 1;\n\tif (isl_tab_push_var(tab, isl_tab_undo_nonneg, &tab->con[r1]) < 0)\n\t\treturn -1;\n\n\trow = tab->con[r1].index;\n\tif (is_constant(tab, row)) {\n\t\tif (!isl_int_is_zero(tab->mat->row[row][1]) ||\n\t\t    (tab->M && !isl_int_is_zero(tab->mat->row[row][2]))) {\n\t\t\tif (isl_tab_mark_empty(tab) < 0)\n\t\t\t\treturn -1;\n\t\t\treturn 0;\n\t\t}\n\t\tif (isl_tab_rollback(tab, snap) < 0)\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\n\tif (restore_lexmin(tab) < 0)\n\t\treturn -1;\n\tif (tab->empty)\n\t\treturn 0;\n\n\tisl_seq_neg(eq, eq, 1 + tab->n_var);\n\n\tr2 = isl_tab_add_row(tab, eq);\n\tif (r2 < 0)\n\t\treturn -1;\n\ttab->con[r2].is_nonneg = 1;\n\tif (isl_tab_push_var(tab, isl_tab_undo_nonneg, &tab->con[r2]) < 0)\n\t\treturn -1;\n\n\tif (restore_lexmin(tab) < 0)\n\t\treturn -1;\n\tif (tab->empty)\n\t\treturn 0;\n\n\tif (!tab->con[r1].is_row) {\n\t\tif (isl_tab_kill_col(tab, tab->con[r1].index) < 0)\n\t\t\treturn -1;\n\t} else if (!tab->con[r2].is_row) {\n\t\tif (isl_tab_kill_col(tab, tab->con[r2].index) < 0)\n\t\t\treturn -1;\n\t}\n\n\tif (tab->bmap) {\n\t\ttab->bmap = isl_basic_map_add_ineq(tab->bmap, eq);\n\t\tif (isl_tab_push(tab, isl_tab_undo_bmap_ineq) < 0)\n\t\t\treturn -1;\n\t\tisl_seq_neg(eq, eq, 1 + tab->n_var);\n\t\ttab->bmap = isl_basic_map_add_ineq(tab->bmap, eq);\n\t\tisl_seq_neg(eq, eq, 1 + tab->n_var);\n\t\tif (isl_tab_push(tab, isl_tab_undo_bmap_ineq) < 0)\n\t\t\treturn -1;\n\t\tif (!tab->bmap)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n/* Add an inequality to the tableau, resolving violations using\n * restore_lexmin.\n *\n * This function assumes that at least one more row and at least\n * one more element in the constraint array are available in the tableau.\n */\nstatic struct isl_tab *add_lexmin_ineq(struct isl_tab *tab, isl_int *ineq)\n{\n\tint r;\n\n\tif (!tab)\n\t\treturn NULL;\n\tif (tab->bmap) {\n\t\ttab->bmap = isl_basic_map_add_ineq(tab->bmap, ineq);\n\t\tif (isl_tab_push(tab, isl_tab_undo_bmap_ineq) < 0)\n\t\t\tgoto error;\n\t\tif (!tab->bmap)\n\t\t\tgoto error;\n\t}\n\tr = isl_tab_add_row(tab, ineq);\n\tif (r < 0)\n\t\tgoto error;\n\ttab->con[r].is_nonneg = 1;\n\tif (isl_tab_push_var(tab, isl_tab_undo_nonneg, &tab->con[r]) < 0)\n\t\tgoto error;\n\tif (isl_tab_row_is_redundant(tab, tab->con[r].index)) {\n\t\tif (isl_tab_mark_redundant(tab, tab->con[r].index) < 0)\n\t\t\tgoto error;\n\t\treturn tab;\n\t}\n\n\tif (restore_lexmin(tab) < 0)\n\t\tgoto error;\n\tif (!tab->empty && tab->con[r].is_row &&\n\t\t isl_tab_row_is_redundant(tab, tab->con[r].index))\n\t\tif (isl_tab_mark_redundant(tab, tab->con[r].index) < 0)\n\t\t\tgoto error;\n\treturn tab;\nerror:\n\tisl_tab_free(tab);\n\treturn NULL;\n}\n\n/* Check if the coefficients of the parameters are all integral.\n */\nstatic int integer_parameter(struct isl_tab *tab, int row)\n{\n\tint i;\n\tint col;\n\tunsigned off = 2 + tab->M;\n\n\tfor (i = 0; i < tab->n_param; ++i) {\n\t\t/* Eliminated parameter */\n\t\tif (tab->var[i].is_row)\n\t\t\tcontinue;\n\t\tcol = tab->var[i].index;\n\t\tif (!isl_int_is_divisible_by(tab->mat->row[row][off + col],\n\t\t\t\t\t\ttab->mat->row[row][0]))\n\t\t\treturn 0;\n\t}\n\tfor (i = 0; i < tab->n_div; ++i) {\n\t\tif (tab->var[tab->n_var - tab->n_div + i].is_row)\n\t\t\tcontinue;\n\t\tcol = tab->var[tab->n_var - tab->n_div + i].index;\n\t\tif (!isl_int_is_divisible_by(tab->mat->row[row][off + col],\n\t\t\t\t\t\ttab->mat->row[row][0]))\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n/* Check if the coefficients of the non-parameter variables are all integral.\n */\nstatic int integer_variable(struct isl_tab *tab, int row)\n{\n\tint i;\n\tunsigned off = 2 + tab->M;\n\n\tfor (i = tab->n_dead; i < tab->n_col; ++i) {\n\t\tif (col_is_parameter_var(tab, i))\n\t\t\tcontinue;\n\t\tif (!isl_int_is_divisible_by(tab->mat->row[row][off + i],\n\t\t\t\t\t\ttab->mat->row[row][0]))\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n/* Check if the constant term is integral.\n */\nstatic int integer_constant(struct isl_tab *tab, int row)\n{\n\treturn isl_int_is_divisible_by(tab->mat->row[row][1],\n\t\t\t\t\ttab->mat->row[row][0]);\n}\n\n#define I_CST\t1 << 0\n#define I_PAR\t1 << 1\n#define I_VAR\t1 << 2\n\n/* Check for next (non-parameter) variable after \"var\" (first if var == -1)\n * that is non-integer and therefore requires a cut and return\n * the index of the variable.\n * For parametric tableaus, there are three parts in a row,\n * the constant, the coefficients of the parameters and the rest.\n * For each part, we check whether the coefficients in that part\n * are all integral and if so, set the corresponding flag in *f.\n * If the constant and the parameter part are integral, then the\n * current sample value is integral and no cut is required\n * (irrespective of whether the variable part is integral).\n */\nstatic int next_non_integer_var(struct isl_tab *tab, int var, int *f)\n{\n\tvar = var < 0 ? tab->n_param : var + 1;\n\n\tfor (; var < tab->n_var - tab->n_div; ++var) {\n\t\tint flags = 0;\n\t\tint row;\n\t\tif (!tab->var[var].is_row)\n\t\t\tcontinue;\n\t\trow = tab->var[var].index;\n\t\tif (integer_constant(tab, row))\n\t\t\tISL_FL_SET(flags, I_CST);\n\t\tif (integer_parameter(tab, row))\n\t\t\tISL_FL_SET(flags, I_PAR);\n\t\tif (ISL_FL_ISSET(flags, I_CST) && ISL_FL_ISSET(flags, I_PAR))\n\t\t\tcontinue;\n\t\tif (integer_variable(tab, row))\n\t\t\tISL_FL_SET(flags, I_VAR);\n\t\t*f = flags;\n\t\treturn var;\n\t}\n\treturn -1;\n}\n\n/* Check for first (non-parameter) variable that is non-integer and\n * therefore requires a cut and return the corresponding row.\n * For parametric tableaus, there are three parts in a row,\n * the constant, the coefficients of the parameters and the rest.\n * For each part, we check whether the coefficients in that part\n * are all integral and if so, set the corresponding flag in *f.\n * If the constant and the parameter part are integral, then the\n * current sample value is integral and no cut is required\n * (irrespective of whether the variable part is integral).\n */\nstatic int first_non_integer_row(struct isl_tab *tab, int *f)\n{\n\tint var = next_non_integer_var(tab, -1, f);\n\n\treturn var < 0 ? -1 : tab->var[var].index;\n}\n\n/* Add a (non-parametric) cut to cut away the non-integral sample\n * value of the given row.\n *\n * If the row is given by\n *\n *\tm r = f + \\sum_i a_i y_i\n *\n * then the cut is\n *\n *\tc = - {-f/m} + \\sum_i {a_i/m} y_i >= 0\n *\n * The big parameter, if any, is ignored, since it is assumed to be big\n * enough to be divisible by any integer.\n * If the tableau is actually a parametric tableau, then this function\n * is only called when all coefficients of the parameters are integral.\n * The cut therefore has zero coefficients for the parameters.\n *\n * The current value is known to be negative, so row_sign, if it\n * exists, is set accordingly.\n *\n * Return the row of the cut or -1.\n */\nstatic int add_cut(struct isl_tab *tab, int row)\n{\n\tint i;\n\tint r;\n\tisl_int *r_row;\n\tunsigned off = 2 + tab->M;\n\n\tif (isl_tab_extend_cons(tab, 1) < 0)\n\t\treturn -1;\n\tr = isl_tab_allocate_con(tab);\n\tif (r < 0)\n\t\treturn -1;\n\n\tr_row = tab->mat->row[tab->con[r].index];\n\tisl_int_set(r_row[0], tab->mat->row[row][0]);\n\tisl_int_neg(r_row[1], tab->mat->row[row][1]);\n\tisl_int_fdiv_r(r_row[1], r_row[1], tab->mat->row[row][0]);\n\tisl_int_neg(r_row[1], r_row[1]);\n\tif (tab->M)\n\t\tisl_int_set_si(r_row[2], 0);\n\tfor (i = 0; i < tab->n_col; ++i)\n\t\tisl_int_fdiv_r(r_row[off + i],\n\t\t\ttab->mat->row[row][off + i], tab->mat->row[row][0]);\n\n\ttab->con[r].is_nonneg = 1;\n\tif (isl_tab_push_var(tab, isl_tab_undo_nonneg, &tab->con[r]) < 0)\n\t\treturn -1;\n\tif (tab->row_sign)\n\t\ttab->row_sign[tab->con[r].index] = isl_tab_row_neg;\n\n\treturn tab->con[r].index;\n}\n\n#define CUT_ALL 1\n#define CUT_ONE 0\n\n/* Given a non-parametric tableau, add cuts until an integer\n * sample point is obtained or until the tableau is determined\n * to be integer infeasible.\n * As long as there is any non-integer value in the sample point,\n * we add appropriate cuts, if possible, for each of these\n * non-integer values and then resolve the violated\n * cut constraints using restore_lexmin.\n * If one of the corresponding rows is equal to an integral\n * combination of variables/constraints plus a non-integral constant,\n * then there is no way to obtain an integer point and we return\n * a tableau that is marked empty.\n * The parameter cutting_strategy controls the strategy used when adding cuts\n * to remove non-integer points. CUT_ALL adds all possible cuts\n * before continuing the search. CUT_ONE adds only one cut at a time.\n */\nstatic struct isl_tab *cut_to_integer_lexmin(struct isl_tab *tab,\n\tint cutting_strategy)\n{\n\tint var;\n\tint row;\n\tint flags;\n\n\tif (!tab)\n\t\treturn NULL;\n\tif (tab->empty)\n\t\treturn tab;\n\n\twhile ((var = next_non_integer_var(tab, -1, &flags)) != -1) {\n\t\tdo {\n\t\t\tif (ISL_FL_ISSET(flags, I_VAR)) {\n\t\t\t\tif (isl_tab_mark_empty(tab) < 0)\n\t\t\t\t\tgoto error;\n\t\t\t\treturn tab;\n\t\t\t}\n\t\t\trow = tab->var[var].index;\n\t\t\trow = add_cut(tab, row);\n\t\t\tif (row < 0)\n\t\t\t\tgoto error;\n\t\t\tif (cutting_strategy == CUT_ONE)\n\t\t\t\tbreak;\n\t\t} while ((var = next_non_integer_var(tab, var, &flags)) != -1);\n\t\tif (restore_lexmin(tab) < 0)\n\t\t\tgoto error;\n\t\tif (tab->empty)\n\t\t\tbreak;\n\t}\n\treturn tab;\nerror:\n\tisl_tab_free(tab);\n\treturn NULL;\n}\n\n/* Check whether all the currently active samples also satisfy the inequality\n * \"ineq\" (treated as an equality if eq is set).\n * Remove those samples that do not.\n */\nstatic struct isl_tab *check_samples(struct isl_tab *tab, isl_int *ineq, int eq)\n{\n\tint i;\n\tisl_int v;\n\n\tif (!tab)\n\t\treturn NULL;\n\n\tisl_assert(tab->mat->ctx, tab->bmap, goto error);\n\tisl_assert(tab->mat->ctx, tab->samples, goto error);\n\tisl_assert(tab->mat->ctx, tab->samples->n_col == 1 + tab->n_var, goto error);\n\n\tisl_int_init(v);\n\tfor (i = tab->n_outside; i < tab->n_sample; ++i) {\n\t\tint sgn;\n\t\tisl_seq_inner_product(ineq, tab->samples->row[i],\n\t\t\t\t\t1 + tab->n_var, &v);\n\t\tsgn = isl_int_sgn(v);\n\t\tif (eq ? (sgn == 0) : (sgn >= 0))\n\t\t\tcontinue;\n\t\ttab = isl_tab_drop_sample(tab, i);\n\t\tif (!tab)\n\t\t\tbreak;\n\t}\n\tisl_int_clear(v);\n\n\treturn tab;\nerror:\n\tisl_tab_free(tab);\n\treturn NULL;\n}\n\n/* Check whether the sample value of the tableau is finite,\n * i.e., either the tableau does not use a big parameter, or\n * all values of the variables are equal to the big parameter plus\n * some constant.  This constant is the actual sample value.\n */\nstatic int sample_is_finite(struct isl_tab *tab)\n{\n\tint i;\n\n\tif (!tab->M)\n\t\treturn 1;\n\n\tfor (i = 0; i < tab->n_var; ++i) {\n\t\tint row;\n\t\tif (!tab->var[i].is_row)\n\t\t\treturn 0;\n\t\trow = tab->var[i].index;\n\t\tif (isl_int_ne(tab->mat->row[row][0], tab->mat->row[row][2]))\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n/* Check if the context tableau of sol has any integer points.\n * Leave tab in empty state if no integer point can be found.\n * If an integer point can be found and if moreover it is finite,\n * then it is added to the list of sample values.\n *\n * This function is only called when none of the currently active sample\n * values satisfies the most recently added constraint.\n */\nstatic struct isl_tab *check_integer_feasible(struct isl_tab *tab)\n{\n\tstruct isl_tab_undo *snap;\n\n\tif (!tab)\n\t\treturn NULL;\n\n\tsnap = isl_tab_snap(tab);\n\tif (isl_tab_push_basis(tab) < 0)\n\t\tgoto error;\n\n\ttab = cut_to_integer_lexmin(tab, CUT_ALL);\n\tif (!tab)\n\t\tgoto error;\n\n\tif (!tab->empty && sample_is_finite(tab)) {\n\t\tstruct isl_vec *sample;\n\n\t\tsample = isl_tab_get_sample_value(tab);\n\n\t\tif (isl_tab_add_sample(tab, sample) < 0)\n\t\t\tgoto error;\n\t}\n\n\tif (!tab->empty && isl_tab_rollback(tab, snap) < 0)\n\t\tgoto error;\n\n\treturn tab;\nerror:\n\tisl_tab_free(tab);\n\treturn NULL;\n}\n\n/* Check if any of the currently active sample values satisfies\n * the inequality \"ineq\" (an equality if eq is set).\n */\nstatic int tab_has_valid_sample(struct isl_tab *tab, isl_int *ineq, int eq)\n{\n\tint i;\n\tisl_int v;\n\n\tif (!tab)\n\t\treturn -1;\n\n\tisl_assert(tab->mat->ctx, tab->bmap, return -1);\n\tisl_assert(tab->mat->ctx, tab->samples, return -1);\n\tisl_assert(tab->mat->ctx, tab->samples->n_col == 1 + tab->n_var, return -1);\n\n\tisl_int_init(v);\n\tfor (i = tab->n_outside; i < tab->n_sample; ++i) {\n\t\tint sgn;\n\t\tisl_seq_inner_product(ineq, tab->samples->row[i],\n\t\t\t\t\t1 + tab->n_var, &v);\n\t\tsgn = isl_int_sgn(v);\n\t\tif (eq ? (sgn == 0) : (sgn >= 0))\n\t\t\tbreak;\n\t}\n\tisl_int_clear(v);\n\n\treturn i < tab->n_sample;\n}\n\n/* Insert a div specified by \"div\" to the tableau \"tab\" at position \"pos\" and\n * return isl_bool_true if the div is obviously non-negative.\n */\nstatic isl_bool context_tab_insert_div(struct isl_tab *tab, int pos,\n\t__isl_keep isl_vec *div,\n\tisl_stat (*add_ineq)(void *user, isl_int *), void *user)\n{\n\tint i;\n\tint r;\n\tstruct isl_mat *samples;\n\tint nonneg;\n\n\tr = isl_tab_insert_div(tab, pos, div, add_ineq, user);\n\tif (r < 0)\n\t\treturn isl_bool_error;\n\tnonneg = tab->var[r].is_nonneg;\n\ttab->var[r].frozen = 1;\n\n\tsamples = isl_mat_extend(tab->samples,\n\t\t\ttab->n_sample, 1 + tab->n_var);\n\ttab->samples = samples;\n\tif (!samples)\n\t\treturn isl_bool_error;\n\tfor (i = tab->n_outside; i < samples->n_row; ++i) {\n\t\tisl_seq_inner_product(div->el + 1, samples->row[i],\n\t\t\tdiv->size - 1, &samples->row[i][samples->n_col - 1]);\n\t\tisl_int_fdiv_q(samples->row[i][samples->n_col - 1],\n\t\t\t       samples->row[i][samples->n_col - 1], div->el[0]);\n\t}\n\ttab->samples = isl_mat_move_cols(tab->samples, 1 + pos,\n\t\t\t\t\t1 + tab->n_var - 1, 1);\n\tif (!tab->samples)\n\t\treturn isl_bool_error;\n\n\treturn isl_bool_ok(nonneg);\n}\n\n/* Add a div specified by \"div\" to both the main tableau and\n * the context tableau.  In case of the main tableau, we only\n * need to add an extra div.  In the context tableau, we also\n * need to express the meaning of the div.\n * Return the index of the div or -1 if anything went wrong.\n *\n * The new integer division is added before any unknown integer\n * divisions in the context to ensure that it does not get\n * equated to some linear combination involving unknown integer\n * divisions.\n */\nstatic int add_div(struct isl_tab *tab, struct isl_context *context,\n\t__isl_keep isl_vec *div)\n{\n\tint r;\n\tint pos;\n\tisl_bool nonneg;\n\tstruct isl_tab *context_tab = context->op->peek_tab(context);\n\n\tif (!tab || !context_tab)\n\t\tgoto error;\n\n\tpos = context_tab->n_var - context->n_unknown;\n\tif ((nonneg = context->op->insert_div(context, pos, div)) < 0)\n\t\tgoto error;\n\n\tif (!context->op->is_ok(context))\n\t\tgoto error;\n\n\tpos = tab->n_var - context->n_unknown;\n\tif (isl_tab_extend_vars(tab, 1) < 0)\n\t\tgoto error;\n\tr = isl_tab_insert_var(tab, pos);\n\tif (r < 0)\n\t\tgoto error;\n\tif (nonneg)\n\t\ttab->var[r].is_nonneg = 1;\n\ttab->var[r].frozen = 1;\n\ttab->n_div++;\n\n\treturn tab->n_div - 1 - context->n_unknown;\nerror:\n\tcontext->op->invalidate(context);\n\treturn -1;\n}\n\n/* Return the position of the integer division that is equal to div/denom\n * if there is one.  Otherwise, return a position beyond the integer divisions.\n */\nstatic int find_div(struct isl_tab *tab, isl_int *div, isl_int denom)\n{\n\tint i;\n\tisl_size total = isl_basic_map_dim(tab->bmap, isl_dim_all);\n\tisl_size n_div;\n\n\tn_div = isl_basic_map_dim(tab->bmap, isl_dim_div);\n\tif (total < 0 || n_div < 0)\n\t\treturn -1;\n\tfor (i = 0; i < n_div; ++i) {\n\t\tif (isl_int_ne(tab->bmap->div[i][0], denom))\n\t\t\tcontinue;\n\t\tif (!isl_seq_eq(tab->bmap->div[i] + 1, div, 1 + total))\n\t\t\tcontinue;\n\t\treturn i;\n\t}\n\treturn n_div;\n}\n\n/* Return the index of a div that corresponds to \"div\".\n * We first check if we already have such a div and if not, we create one.\n */\nstatic int get_div(struct isl_tab *tab, struct isl_context *context,\n\tstruct isl_vec *div)\n{\n\tint d;\n\tstruct isl_tab *context_tab = context->op->peek_tab(context);\n\tunsigned n_div;\n\n\tif (!context_tab)\n\t\treturn -1;\n\n\tn_div = isl_basic_map_dim(context_tab->bmap, isl_dim_div);\n\td = find_div(context_tab, div->el + 1, div->el[0]);\n\tif (d < 0)\n\t\treturn -1;\n\tif (d < n_div)\n\t\treturn d;\n\n\treturn add_div(tab, context, div);\n}\n\n/* Add a parametric cut to cut away the non-integral sample value\n * of the given row.\n * Let a_i be the coefficients of the constant term and the parameters\n * and let b_i be the coefficients of the variables or constraints\n * in basis of the tableau.\n * Let q be the div q = floor(\\sum_i {-a_i} y_i).\n *\n * The cut is expressed as\n *\n *\tc = \\sum_i -{-a_i} y_i + \\sum_i {b_i} x_i + q >= 0\n *\n * If q did not already exist in the context tableau, then it is added first.\n * If q is in a column of the main tableau then the \"+ q\" can be accomplished\n * by setting the corresponding entry to the denominator of the constraint.\n * If q happens to be in a row of the main tableau, then the corresponding\n * row needs to be added instead (taking care of the denominators).\n * Note that this is very unlikely, but perhaps not entirely impossible.\n *\n * The current value of the cut is known to be negative (or at least\n * non-positive), so row_sign is set accordingly.\n *\n * Return the row of the cut or -1.\n */\nstatic int add_parametric_cut(struct isl_tab *tab, int row,\n\tstruct isl_context *context)\n{\n\tstruct isl_vec *div;\n\tint d;\n\tint i;\n\tint r;\n\tisl_int *r_row;\n\tint col;\n\tint n;\n\tunsigned off = 2 + tab->M;\n\n\tif (!context)\n\t\treturn -1;\n\n\tdiv = get_row_parameter_div(tab, row);\n\tif (!div)\n\t\treturn -1;\n\n\tn = tab->n_div - context->n_unknown;\n\td = context->op->get_div(context, tab, div);\n\tisl_vec_free(div);\n\tif (d < 0)\n\t\treturn -1;\n\n\tif (isl_tab_extend_cons(tab, 1) < 0)\n\t\treturn -1;\n\tr = isl_tab_allocate_con(tab);\n\tif (r < 0)\n\t\treturn -1;\n\n\tr_row = tab->mat->row[tab->con[r].index];\n\tisl_int_set(r_row[0], tab->mat->row[row][0]);\n\tisl_int_neg(r_row[1], tab->mat->row[row][1]);\n\tisl_int_fdiv_r(r_row[1], r_row[1], tab->mat->row[row][0]);\n\tisl_int_neg(r_row[1], r_row[1]);\n\tif (tab->M)\n\t\tisl_int_set_si(r_row[2], 0);\n\tfor (i = 0; i < tab->n_param; ++i) {\n\t\tif (tab->var[i].is_row)\n\t\t\tcontinue;\n\t\tcol = tab->var[i].index;\n\t\tisl_int_neg(r_row[off + col], tab->mat->row[row][off + col]);\n\t\tisl_int_fdiv_r(r_row[off + col], r_row[off + col],\n\t\t\t\ttab->mat->row[row][0]);\n\t\tisl_int_neg(r_row[off + col], r_row[off + col]);\n\t}\n\tfor (i = 0; i < tab->n_div; ++i) {\n\t\tif (tab->var[tab->n_var - tab->n_div + i].is_row)\n\t\t\tcontinue;\n\t\tcol = tab->var[tab->n_var - tab->n_div + i].index;\n\t\tisl_int_neg(r_row[off + col], tab->mat->row[row][off + col]);\n\t\tisl_int_fdiv_r(r_row[off + col], r_row[off + col],\n\t\t\t\ttab->mat->row[row][0]);\n\t\tisl_int_neg(r_row[off + col], r_row[off + col]);\n\t}\n\tfor (i = 0; i < tab->n_col; ++i) {\n\t\tif (tab->col_var[i] >= 0 &&\n\t\t    (tab->col_var[i] < tab->n_param ||\n\t\t     tab->col_var[i] >= tab->n_var - tab->n_div))\n\t\t\tcontinue;\n\t\tisl_int_fdiv_r(r_row[off + i],\n\t\t\ttab->mat->row[row][off + i], tab->mat->row[row][0]);\n\t}\n\tif (tab->var[tab->n_var - tab->n_div + d].is_row) {\n\t\tisl_int gcd;\n\t\tint d_row = tab->var[tab->n_var - tab->n_div + d].index;\n\t\tisl_int_init(gcd);\n\t\tisl_int_gcd(gcd, tab->mat->row[d_row][0], r_row[0]);\n\t\tisl_int_divexact(r_row[0], r_row[0], gcd);\n\t\tisl_int_divexact(gcd, tab->mat->row[d_row][0], gcd);\n\t\tisl_seq_combine(r_row + 1, gcd, r_row + 1,\n\t\t\t\tr_row[0], tab->mat->row[d_row] + 1,\n\t\t\t\toff - 1 + tab->n_col);\n\t\tisl_int_mul(r_row[0], r_row[0], tab->mat->row[d_row][0]);\n\t\tisl_int_clear(gcd);\n\t} else {\n\t\tcol = tab->var[tab->n_var - tab->n_div + d].index;\n\t\tisl_int_set(r_row[off + col], tab->mat->row[row][0]);\n\t}\n\n\ttab->con[r].is_nonneg = 1;\n\tif (isl_tab_push_var(tab, isl_tab_undo_nonneg, &tab->con[r]) < 0)\n\t\treturn -1;\n\tif (tab->row_sign)\n\t\ttab->row_sign[tab->con[r].index] = isl_tab_row_neg;\n\n\trow = tab->con[r].index;\n\n\tif (d >= n && context->op->detect_equalities(context, tab) < 0)\n\t\treturn -1;\n\n\treturn row;\n}\n\n/* Construct a tableau for bmap that can be used for computing\n * the lexicographic minimum (or maximum) of bmap.\n * If not NULL, then dom is the domain where the minimum\n * should be computed.  In this case, we set up a parametric\n * tableau with row signs (initialized to \"unknown\").\n * If M is set, then the tableau will use a big parameter.\n * If max is set, then a maximum should be computed instead of a minimum.\n * This means that for each variable x, the tableau will contain the variable\n * x' = M - x, rather than x' = M + x.  This in turn means that the coefficient\n * of the variables in all constraints are negated prior to adding them\n * to the tableau.\n */\nstatic __isl_give struct isl_tab *tab_for_lexmin(__isl_keep isl_basic_map *bmap,\n\t__isl_keep isl_basic_set *dom, unsigned M, int max)\n{\n\tint i;\n\tstruct isl_tab *tab;\n\tunsigned n_var;\n\tunsigned o_var;\n\tisl_size total;\n\n\ttotal = isl_basic_map_dim(bmap, isl_dim_all);\n\tif (total < 0)\n\t\treturn NULL;\n\ttab = isl_tab_alloc(bmap->ctx, 2 * bmap->n_eq + bmap->n_ineq + 1,\n\t\t\t    total, M);\n\tif (!tab)\n\t\treturn NULL;\n\n\ttab->rational = ISL_F_ISSET(bmap, ISL_BASIC_MAP_RATIONAL);\n\tif (dom) {\n\t\tisl_size dom_total;\n\t\tdom_total = isl_basic_set_dim(dom, isl_dim_all);\n\t\tif (dom_total < 0)\n\t\t\tgoto error;\n\t\ttab->n_param = dom_total - dom->n_div;\n\t\ttab->n_div = dom->n_div;\n\t\ttab->row_sign = isl_calloc_array(bmap->ctx,\n\t\t\t\t\tenum isl_tab_row_sign, tab->mat->n_row);\n\t\tif (tab->mat->n_row && !tab->row_sign)\n\t\t\tgoto error;\n\t}\n\tif (ISL_F_ISSET(bmap, ISL_BASIC_MAP_EMPTY)) {\n\t\tif (isl_tab_mark_empty(tab) < 0)\n\t\t\tgoto error;\n\t\treturn tab;\n\t}\n\n\tfor (i = tab->n_param; i < tab->n_var - tab->n_div; ++i) {\n\t\ttab->var[i].is_nonneg = 1;\n\t\ttab->var[i].frozen = 1;\n\t}\n\to_var = 1 + tab->n_param;\n\tn_var = tab->n_var - tab->n_param - tab->n_div;\n\tfor (i = 0; i < bmap->n_eq; ++i) {\n\t\tif (max)\n\t\t\tisl_seq_neg(bmap->eq[i] + o_var,\n\t\t\t\t    bmap->eq[i] + o_var, n_var);\n\t\ttab = add_lexmin_valid_eq(tab, bmap->eq[i]);\n\t\tif (max)\n\t\t\tisl_seq_neg(bmap->eq[i] + o_var,\n\t\t\t\t    bmap->eq[i] + o_var, n_var);\n\t\tif (!tab || tab->empty)\n\t\t\treturn tab;\n\t}\n\tif (bmap->n_eq && restore_lexmin(tab) < 0)\n\t\tgoto error;\n\tfor (i = 0; i < bmap->n_ineq; ++i) {\n\t\tif (max)\n\t\t\tisl_seq_neg(bmap->ineq[i] + o_var,\n\t\t\t\t    bmap->ineq[i] + o_var, n_var);\n\t\ttab = add_lexmin_ineq(tab, bmap->ineq[i]);\n\t\tif (max)\n\t\t\tisl_seq_neg(bmap->ineq[i] + o_var,\n\t\t\t\t    bmap->ineq[i] + o_var, n_var);\n\t\tif (!tab || tab->empty)\n\t\t\treturn tab;\n\t}\n\treturn tab;\nerror:\n\tisl_tab_free(tab);\n\treturn NULL;\n}\n\n/* Given a main tableau where more than one row requires a split,\n * determine and return the \"best\" row to split on.\n *\n * If any of the rows requiring a split only involves\n * variables that also appear in the context tableau,\n * then the negative part is guaranteed not to have a solution.\n * It is therefore best to split on any of these rows first.\n *\n * Otherwise,\n * given two rows in the main tableau, if the inequality corresponding\n * to the first row is redundant with respect to that of the second row\n * in the current tableau, then it is better to split on the second row,\n * since in the positive part, both rows will be positive.\n * (In the negative part a pivot will have to be performed and just about\n * anything can happen to the sign of the other row.)\n *\n * As a simple heuristic, we therefore select the row that makes the most\n * of the other rows redundant.\n *\n * Perhaps it would also be useful to look at the number of constraints\n * that conflict with any given constraint.\n *\n * best is the best row so far (-1 when we have not found any row yet).\n * best_r is the number of other rows made redundant by row best.\n * When best is still -1, bset_r is meaningless, but it is initialized\n * to some arbitrary value (0) anyway.  Without this redundant initialization\n * valgrind may warn about uninitialized memory accesses when isl\n * is compiled with some versions of gcc.\n */\nstatic int best_split(struct isl_tab *tab, struct isl_tab *context_tab)\n{\n\tstruct isl_tab_undo *snap;\n\tint split;\n\tint row;\n\tint best = -1;\n\tint best_r = 0;\n\n\tif (isl_tab_extend_cons(context_tab, 2) < 0)\n\t\treturn -1;\n\n\tsnap = isl_tab_snap(context_tab);\n\n\tfor (split = tab->n_redundant; split < tab->n_row; ++split) {\n\t\tstruct isl_tab_undo *snap2;\n\t\tstruct isl_vec *ineq = NULL;\n\t\tint r = 0;\n\t\tint ok;\n\n\t\tif (!isl_tab_var_from_row(tab, split)->is_nonneg)\n\t\t\tcontinue;\n\t\tif (tab->row_sign[split] != isl_tab_row_any)\n\t\t\tcontinue;\n\n\t\tif (is_parametric_constant(tab, split))\n\t\t\treturn split;\n\n\t\tineq = get_row_parameter_ineq(tab, split);\n\t\tif (!ineq)\n\t\t\treturn -1;\n\t\tok = isl_tab_add_ineq(context_tab, ineq->el) >= 0;\n\t\tisl_vec_free(ineq);\n\t\tif (!ok)\n\t\t\treturn -1;\n\n\t\tsnap2 = isl_tab_snap(context_tab);\n\n\t\tfor (row = tab->n_redundant; row < tab->n_row; ++row) {\n\t\t\tstruct isl_tab_var *var;\n\n\t\t\tif (row == split)\n\t\t\t\tcontinue;\n\t\t\tif (!isl_tab_var_from_row(tab, row)->is_nonneg)\n\t\t\t\tcontinue;\n\t\t\tif (tab->row_sign[row] != isl_tab_row_any)\n\t\t\t\tcontinue;\n\n\t\t\tineq = get_row_parameter_ineq(tab, row);\n\t\t\tif (!ineq)\n\t\t\t\treturn -1;\n\t\t\tok = isl_tab_add_ineq(context_tab, ineq->el) >= 0;\n\t\t\tisl_vec_free(ineq);\n\t\t\tif (!ok)\n\t\t\t\treturn -1;\n\t\t\tvar = &context_tab->con[context_tab->n_con - 1];\n\t\t\tif (!context_tab->empty &&\n\t\t\t    !isl_tab_min_at_most_neg_one(context_tab, var))\n\t\t\t\tr++;\n\t\t\tif (isl_tab_rollback(context_tab, snap2) < 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\tif (best == -1 || r > best_r) {\n\t\t\tbest = split;\n\t\t\tbest_r = r;\n\t\t}\n\t\tif (isl_tab_rollback(context_tab, snap) < 0)\n\t\t\treturn -1;\n\t}\n\n\treturn best;\n}\n\nstatic struct isl_basic_set *context_lex_peek_basic_set(\n\tstruct isl_context *context)\n{\n\tstruct isl_context_lex *clex = (struct isl_context_lex *)context;\n\tif (!clex->tab)\n\t\treturn NULL;\n\treturn isl_tab_peek_bset(clex->tab);\n}\n\nstatic struct isl_tab *context_lex_peek_tab(struct isl_context *context)\n{\n\tstruct isl_context_lex *clex = (struct isl_context_lex *)context;\n\treturn clex->tab;\n}\n\nstatic void context_lex_add_eq(struct isl_context *context, isl_int *eq,\n\t\tint check, int update)\n{\n\tstruct isl_context_lex *clex = (struct isl_context_lex *)context;\n\tif (isl_tab_extend_cons(clex->tab, 2) < 0)\n\t\tgoto error;\n\tif (add_lexmin_eq(clex->tab, eq) < 0)\n\t\tgoto error;\n\tif (check) {\n\t\tint v = tab_has_valid_sample(clex->tab, eq, 1);\n\t\tif (v < 0)\n\t\t\tgoto error;\n\t\tif (!v)\n\t\t\tclex->tab = check_integer_feasible(clex->tab);\n\t}\n\tif (update)\n\t\tclex->tab = check_samples(clex->tab, eq, 1);\n\treturn;\nerror:\n\tisl_tab_free(clex->tab);\n\tclex->tab = NULL;\n}\n\nstatic void context_lex_add_ineq(struct isl_context *context, isl_int *ineq,\n\t\tint check, int update)\n{\n\tstruct isl_context_lex *clex = (struct isl_context_lex *)context;\n\tif (isl_tab_extend_cons(clex->tab, 1) < 0)\n\t\tgoto error;\n\tclex->tab = add_lexmin_ineq(clex->tab, ineq);\n\tif (check) {\n\t\tint v = tab_has_valid_sample(clex->tab, ineq, 0);\n\t\tif (v < 0)\n\t\t\tgoto error;\n\t\tif (!v)\n\t\t\tclex->tab = check_integer_feasible(clex->tab);\n\t}\n\tif (update)\n\t\tclex->tab = check_samples(clex->tab, ineq, 0);\n\treturn;\nerror:\n\tisl_tab_free(clex->tab);\n\tclex->tab = NULL;\n}\n\nstatic isl_stat context_lex_add_ineq_wrap(void *user, isl_int *ineq)\n{\n\tstruct isl_context *context = (struct isl_context *)user;\n\tcontext_lex_add_ineq(context, ineq, 0, 0);\n\treturn context->op->is_ok(context) ? isl_stat_ok : isl_stat_error;\n}\n\n/* Check which signs can be obtained by \"ineq\" on all the currently\n * active sample values.  See row_sign for more information.\n */\nstatic enum isl_tab_row_sign tab_ineq_sign(struct isl_tab *tab, isl_int *ineq,\n\tint strict)\n{\n\tint i;\n\tint sgn;\n\tisl_int tmp;\n\tenum isl_tab_row_sign res = isl_tab_row_unknown;\n\n\tisl_assert(tab->mat->ctx, tab->samples, return isl_tab_row_unknown);\n\tisl_assert(tab->mat->ctx, tab->samples->n_col == 1 + tab->n_var,\n\t\t\treturn isl_tab_row_unknown);\n\n\tisl_int_init(tmp);\n\tfor (i = tab->n_outside; i < tab->n_sample; ++i) {\n\t\tisl_seq_inner_product(tab->samples->row[i], ineq,\n\t\t\t\t\t1 + tab->n_var, &tmp);\n\t\tsgn = isl_int_sgn(tmp);\n\t\tif (sgn > 0 || (sgn == 0 && strict)) {\n\t\t\tif (res == isl_tab_row_unknown)\n\t\t\t\tres = isl_tab_row_pos;\n\t\t\tif (res == isl_tab_row_neg)\n\t\t\t\tres = isl_tab_row_any;\n\t\t}\n\t\tif (sgn < 0) {\n\t\t\tif (res == isl_tab_row_unknown)\n\t\t\t\tres = isl_tab_row_neg;\n\t\t\tif (res == isl_tab_row_pos)\n\t\t\t\tres = isl_tab_row_any;\n\t\t}\n\t\tif (res == isl_tab_row_any)\n\t\t\tbreak;\n\t}\n\tisl_int_clear(tmp);\n\n\treturn res;\n}\n\nstatic enum isl_tab_row_sign context_lex_ineq_sign(struct isl_context *context,\n\t\t\tisl_int *ineq, int strict)\n{\n\tstruct isl_context_lex *clex = (struct isl_context_lex *)context;\n\treturn tab_ineq_sign(clex->tab, ineq, strict);\n}\n\n/* Check whether \"ineq\" can be added to the tableau without rendering\n * it infeasible.\n */\nstatic int context_lex_test_ineq(struct isl_context *context, isl_int *ineq)\n{\n\tstruct isl_context_lex *clex = (struct isl_context_lex *)context;\n\tstruct isl_tab_undo *snap;\n\tint feasible;\n\n\tif (!clex->tab)\n\t\treturn -1;\n\n\tif (isl_tab_extend_cons(clex->tab, 1) < 0)\n\t\treturn -1;\n\n\tsnap = isl_tab_snap(clex->tab);\n\tif (isl_tab_push_basis(clex->tab) < 0)\n\t\treturn -1;\n\tclex->tab = add_lexmin_ineq(clex->tab, ineq);\n\tclex->tab = check_integer_feasible(clex->tab);\n\tif (!clex->tab)\n\t\treturn -1;\n\tfeasible = !clex->tab->empty;\n\tif (isl_tab_rollback(clex->tab, snap) < 0)\n\t\treturn -1;\n\n\treturn feasible;\n}\n\nstatic int context_lex_get_div(struct isl_context *context, struct isl_tab *tab,\n\t\tstruct isl_vec *div)\n{\n\treturn get_div(tab, context, div);\n}\n\n/* Insert a div specified by \"div\" to the context tableau at position \"pos\" and\n * return isl_bool_true if the div is obviously non-negative.\n * context_tab_add_div will always return isl_bool_true, because all variables\n * in a isl_context_lex tableau are non-negative.\n * However, if we are using a big parameter in the context, then this only\n * reflects the non-negativity of the variable used to _encode_ the\n * div, i.e., div' = M + div, so we can't draw any conclusions.\n */\nstatic isl_bool context_lex_insert_div(struct isl_context *context, int pos,\n\t__isl_keep isl_vec *div)\n{\n\tstruct isl_context_lex *clex = (struct isl_context_lex *)context;\n\tisl_bool nonneg;\n\tnonneg = context_tab_insert_div(clex->tab, pos, div,\n\t\t\t\t\tcontext_lex_add_ineq_wrap, context);\n\tif (nonneg < 0)\n\t\treturn isl_bool_error;\n\tif (clex->tab->M)\n\t\treturn isl_bool_false;\n\treturn nonneg;\n}\n\nstatic int context_lex_detect_equalities(struct isl_context *context,\n\t\tstruct isl_tab *tab)\n{\n\treturn 0;\n}\n\nstatic int context_lex_best_split(struct isl_context *context,\n\t\tstruct isl_tab *tab)\n{\n\tstruct isl_context_lex *clex = (struct isl_context_lex *)context;\n\tstruct isl_tab_undo *snap;\n\tint r;\n\n\tsnap = isl_tab_snap(clex->tab);\n\tif (isl_tab_push_basis(clex->tab) < 0)\n\t\treturn -1;\n\tr = best_split(tab, clex->tab);\n\n\tif (r >= 0 && isl_tab_rollback(clex->tab, snap) < 0)\n\t\treturn -1;\n\n\treturn r;\n}\n\nstatic int context_lex_is_empty(struct isl_context *context)\n{\n\tstruct isl_context_lex *clex = (struct isl_context_lex *)context;\n\tif (!clex->tab)\n\t\treturn -1;\n\treturn clex->tab->empty;\n}\n\nstatic void *context_lex_save(struct isl_context *context)\n{\n\tstruct isl_context_lex *clex = (struct isl_context_lex *)context;\n\tstruct isl_tab_undo *snap;\n\n\tsnap = isl_tab_snap(clex->tab);\n\tif (isl_tab_push_basis(clex->tab) < 0)\n\t\treturn NULL;\n\tif (isl_tab_save_samples(clex->tab) < 0)\n\t\treturn NULL;\n\n\treturn snap;\n}\n\nstatic void context_lex_restore(struct isl_context *context, void *save)\n{\n\tstruct isl_context_lex *clex = (struct isl_context_lex *)context;\n\tif (isl_tab_rollback(clex->tab, (struct isl_tab_undo *)save) < 0) {\n\t\tisl_tab_free(clex->tab);\n\t\tclex->tab = NULL;\n\t}\n}\n\nstatic void context_lex_discard(void *save)\n{\n}\n\nstatic int context_lex_is_ok(struct isl_context *context)\n{\n\tstruct isl_context_lex *clex = (struct isl_context_lex *)context;\n\treturn !!clex->tab;\n}\n\n/* For each variable in the context tableau, check if the variable can\n * only attain non-negative values.  If so, mark the parameter as non-negative\n * in the main tableau.  This allows for a more direct identification of some\n * cases of violated constraints.\n */\nstatic struct isl_tab *tab_detect_nonnegative_parameters(struct isl_tab *tab,\n\tstruct isl_tab *context_tab)\n{\n\tint i;\n\tstruct isl_tab_undo *snap;\n\tstruct isl_vec *ineq = NULL;\n\tstruct isl_tab_var *var;\n\tint n;\n\n\tif (context_tab->n_var == 0)\n\t\treturn tab;\n\n\tineq = isl_vec_alloc(tab->mat->ctx, 1 + context_tab->n_var);\n\tif (!ineq)\n\t\tgoto error;\n\n\tif (isl_tab_extend_cons(context_tab, 1) < 0)\n\t\tgoto error;\n\n\tsnap = isl_tab_snap(context_tab);\n\n\tn = 0;\n\tisl_seq_clr(ineq->el, ineq->size);\n\tfor (i = 0; i < context_tab->n_var; ++i) {\n\t\tisl_int_set_si(ineq->el[1 + i], 1);\n\t\tif (isl_tab_add_ineq(context_tab, ineq->el) < 0)\n\t\t\tgoto error;\n\t\tvar = &context_tab->con[context_tab->n_con - 1];\n\t\tif (!context_tab->empty &&\n\t\t    !isl_tab_min_at_most_neg_one(context_tab, var)) {\n\t\t\tint j = i;\n\t\t\tif (i >= tab->n_param)\n\t\t\t\tj = i - tab->n_param + tab->n_var - tab->n_div;\n\t\t\ttab->var[j].is_nonneg = 1;\n\t\t\tn++;\n\t\t}\n\t\tisl_int_set_si(ineq->el[1 + i], 0);\n\t\tif (isl_tab_rollback(context_tab, snap) < 0)\n\t\t\tgoto error;\n\t}\n\n\tif (context_tab->M && n == context_tab->n_var) {\n\t\tcontext_tab->mat = isl_mat_drop_cols(context_tab->mat, 2, 1);\n\t\tcontext_tab->M = 0;\n\t}\n\n\tisl_vec_free(ineq);\n\treturn tab;\nerror:\n\tisl_vec_free(ineq);\n\tisl_tab_free(tab);\n\treturn NULL;\n}\n\nstatic struct isl_tab *context_lex_detect_nonnegative_parameters(\n\tstruct isl_context *context, struct isl_tab *tab)\n{\n\tstruct isl_context_lex *clex = (struct isl_context_lex *)context;\n\tstruct isl_tab_undo *snap;\n\n\tif (!tab)\n\t\treturn NULL;\n\n\tsnap = isl_tab_snap(clex->tab);\n\tif (isl_tab_push_basis(clex->tab) < 0)\n\t\tgoto error;\n\n\ttab = tab_detect_nonnegative_parameters(tab, clex->tab);\n\n\tif (isl_tab_rollback(clex->tab, snap) < 0)\n\t\tgoto error;\n\n\treturn tab;\nerror:\n\tisl_tab_free(tab);\n\treturn NULL;\n}\n\nstatic void context_lex_invalidate(struct isl_context *context)\n{\n\tstruct isl_context_lex *clex = (struct isl_context_lex *)context;\n\tisl_tab_free(clex->tab);\n\tclex->tab = NULL;\n}\n\nstatic __isl_null struct isl_context *context_lex_free(\n\tstruct isl_context *context)\n{\n\tstruct isl_context_lex *clex = (struct isl_context_lex *)context;\n\tisl_tab_free(clex->tab);\n\tfree(clex);\n\n\treturn NULL;\n}\n\nstruct isl_context_op isl_context_lex_op = {\n\tcontext_lex_detect_nonnegative_parameters,\n\tcontext_lex_peek_basic_set,\n\tcontext_lex_peek_tab,\n\tcontext_lex_add_eq,\n\tcontext_lex_add_ineq,\n\tcontext_lex_ineq_sign,\n\tcontext_lex_test_ineq,\n\tcontext_lex_get_div,\n\tcontext_lex_insert_div,\n\tcontext_lex_detect_equalities,\n\tcontext_lex_best_split,\n\tcontext_lex_is_empty,\n\tcontext_lex_is_ok,\n\tcontext_lex_save,\n\tcontext_lex_restore,\n\tcontext_lex_discard,\n\tcontext_lex_invalidate,\n\tcontext_lex_free,\n};\n\nstatic struct isl_tab *context_tab_for_lexmin(__isl_take isl_basic_set *bset)\n{\n\tstruct isl_tab *tab;\n\n\tif (!bset)\n\t\treturn NULL;\n\ttab = tab_for_lexmin(bset_to_bmap(bset), NULL, 1, 0);\n\tif (isl_tab_track_bset(tab, bset) < 0)\n\t\tgoto error;\n\ttab = isl_tab_init_samples(tab);\n\treturn tab;\nerror:\n\tisl_tab_free(tab);\n\treturn NULL;\n}\n\nstatic struct isl_context *isl_context_lex_alloc(struct isl_basic_set *dom)\n{\n\tstruct isl_context_lex *clex;\n\n\tif (!dom)\n\t\treturn NULL;\n\n\tclex = isl_alloc_type(dom->ctx, struct isl_context_lex);\n\tif (!clex)\n\t\treturn NULL;\n\n\tclex->context.op = &isl_context_lex_op;\n\n\tclex->tab = context_tab_for_lexmin(isl_basic_set_copy(dom));\n\tif (restore_lexmin(clex->tab) < 0)\n\t\tgoto error;\n\tclex->tab = check_integer_feasible(clex->tab);\n\tif (!clex->tab)\n\t\tgoto error;\n\n\treturn &clex->context;\nerror:\n\tclex->context.op->free(&clex->context);\n\treturn NULL;\n}\n\n/* Representation of the context when using generalized basis reduction.\n *\n * \"shifted\" contains the offsets of the unit hypercubes that lie inside the\n * context.  Any rational point in \"shifted\" can therefore be rounded\n * up to an integer point in the context.\n * If the context is constrained by any equality, then \"shifted\" is not used\n * as it would be empty.\n */\nstruct isl_context_gbr {\n\tstruct isl_context context;\n\tstruct isl_tab *tab;\n\tstruct isl_tab *shifted;\n\tstruct isl_tab *cone;\n};\n\nstatic struct isl_tab *context_gbr_detect_nonnegative_parameters(\n\tstruct isl_context *context, struct isl_tab *tab)\n{\n\tstruct isl_context_gbr *cgbr = (struct isl_context_gbr *)context;\n\tif (!tab)\n\t\treturn NULL;\n\treturn tab_detect_nonnegative_parameters(tab, cgbr->tab);\n}\n\nstatic struct isl_basic_set *context_gbr_peek_basic_set(\n\tstruct isl_context *context)\n{\n\tstruct isl_context_gbr *cgbr = (struct isl_context_gbr *)context;\n\tif (!cgbr->tab)\n\t\treturn NULL;\n\treturn isl_tab_peek_bset(cgbr->tab);\n}\n\nstatic struct isl_tab *context_gbr_peek_tab(struct isl_context *context)\n{\n\tstruct isl_context_gbr *cgbr = (struct isl_context_gbr *)context;\n\treturn cgbr->tab;\n}\n\n/* Initialize the \"shifted\" tableau of the context, which\n * contains the constraints of the original tableau shifted\n * by the sum of all negative coefficients.  This ensures\n * that any rational point in the shifted tableau can\n * be rounded up to yield an integer point in the original tableau.\n */\nstatic void gbr_init_shifted(struct isl_context_gbr *cgbr)\n{\n\tint i, j;\n\tstruct isl_vec *cst;\n\tstruct isl_basic_set *bset = isl_tab_peek_bset(cgbr->tab);\n\tisl_size dim = isl_basic_set_dim(bset, isl_dim_all);\n\n\tif (dim < 0)\n\t\treturn;\n\tcst = isl_vec_alloc(cgbr->tab->mat->ctx, bset->n_ineq);\n\tif (!cst)\n\t\treturn;\n\n\tfor (i = 0; i < bset->n_ineq; ++i) {\n\t\tisl_int_set(cst->el[i], bset->ineq[i][0]);\n\t\tfor (j = 0; j < dim; ++j) {\n\t\t\tif (!isl_int_is_neg(bset->ineq[i][1 + j]))\n\t\t\t\tcontinue;\n\t\t\tisl_int_add(bset->ineq[i][0], bset->ineq[i][0],\n\t\t\t\t    bset->ineq[i][1 + j]);\n\t\t}\n\t}\n\n\tcgbr->shifted = isl_tab_from_basic_set(bset, 0);\n\n\tfor (i = 0; i < bset->n_ineq; ++i)\n\t\tisl_int_set(bset->ineq[i][0], cst->el[i]);\n\n\tisl_vec_free(cst);\n}\n\n/* Check if the shifted tableau is non-empty, and if so\n * use the sample point to construct an integer point\n * of the context tableau.\n */\nstatic struct isl_vec *gbr_get_shifted_sample(struct isl_context_gbr *cgbr)\n{\n\tstruct isl_vec *sample;\n\n\tif (!cgbr->shifted)\n\t\tgbr_init_shifted(cgbr);\n\tif (!cgbr->shifted)\n\t\treturn NULL;\n\tif (cgbr->shifted->empty)\n\t\treturn isl_vec_alloc(cgbr->tab->mat->ctx, 0);\n\n\tsample = isl_tab_get_sample_value(cgbr->shifted);\n\tsample = isl_vec_ceil(sample);\n\n\treturn sample;\n}\n\nstatic __isl_give isl_basic_set *drop_constant_terms(\n\t__isl_take isl_basic_set *bset)\n{\n\tint i;\n\n\tif (!bset)\n\t\treturn NULL;\n\n\tfor (i = 0; i < bset->n_eq; ++i)\n\t\tisl_int_set_si(bset->eq[i][0], 0);\n\n\tfor (i = 0; i < bset->n_ineq; ++i)\n\t\tisl_int_set_si(bset->ineq[i][0], 0);\n\n\treturn bset;\n}\n\nstatic int use_shifted(struct isl_context_gbr *cgbr)\n{\n\tif (!cgbr->tab)\n\t\treturn 0;\n\treturn cgbr->tab->bmap->n_eq == 0 && cgbr->tab->bmap->n_div == 0;\n}\n\nstatic struct isl_vec *gbr_get_sample(struct isl_context_gbr *cgbr)\n{\n\tstruct isl_basic_set *bset;\n\tstruct isl_basic_set *cone;\n\n\tif (isl_tab_sample_is_integer(cgbr->tab))\n\t\treturn isl_tab_get_sample_value(cgbr->tab);\n\n\tif (use_shifted(cgbr)) {\n\t\tstruct isl_vec *sample;\n\n\t\tsample = gbr_get_shifted_sample(cgbr);\n\t\tif (!sample || sample->size > 0)\n\t\t\treturn sample;\n\n\t\tisl_vec_free(sample);\n\t}\n\n\tif (!cgbr->cone) {\n\t\tbset = isl_tab_peek_bset(cgbr->tab);\n\t\tcgbr->cone = isl_tab_from_recession_cone(bset, 0);\n\t\tif (!cgbr->cone)\n\t\t\treturn NULL;\n\t\tif (isl_tab_track_bset(cgbr->cone,\n\t\t\t\t\tisl_basic_set_copy(bset)) < 0)\n\t\t\treturn NULL;\n\t}\n\tif (isl_tab_detect_implicit_equalities(cgbr->cone) < 0)\n\t\treturn NULL;\n\n\tif (cgbr->cone->n_dead == cgbr->cone->n_col) {\n\t\tstruct isl_vec *sample;\n\t\tstruct isl_tab_undo *snap;\n\n\t\tif (cgbr->tab->basis) {\n\t\t\tif (cgbr->tab->basis->n_col != 1 + cgbr->tab->n_var) {\n\t\t\t\tisl_mat_free(cgbr->tab->basis);\n\t\t\t\tcgbr->tab->basis = NULL;\n\t\t\t}\n\t\t\tcgbr->tab->n_zero = 0;\n\t\t\tcgbr->tab->n_unbounded = 0;\n\t\t}\n\n\t\tsnap = isl_tab_snap(cgbr->tab);\n\n\t\tsample = isl_tab_sample(cgbr->tab);\n\n\t\tif (!sample || isl_tab_rollback(cgbr->tab, snap) < 0) {\n\t\t\tisl_vec_free(sample);\n\t\t\treturn NULL;\n\t\t}\n\n\t\treturn sample;\n\t}\n\n\tcone = isl_basic_set_dup(isl_tab_peek_bset(cgbr->cone));\n\tcone = drop_constant_terms(cone);\n\tcone = isl_basic_set_update_from_tab(cone, cgbr->cone);\n\tcone = isl_basic_set_underlying_set(cone);\n\tcone = isl_basic_set_gauss(cone, NULL);\n\n\tbset = isl_basic_set_dup(isl_tab_peek_bset(cgbr->tab));\n\tbset = isl_basic_set_update_from_tab(bset, cgbr->tab);\n\tbset = isl_basic_set_underlying_set(bset);\n\tbset = isl_basic_set_gauss(bset, NULL);\n\n\treturn isl_basic_set_sample_with_cone(bset, cone);\n}\n\nstatic void check_gbr_integer_feasible(struct isl_context_gbr *cgbr)\n{\n\tstruct isl_vec *sample;\n\n\tif (!cgbr->tab)\n\t\treturn;\n\n\tif (cgbr->tab->empty)\n\t\treturn;\n\n\tsample = gbr_get_sample(cgbr);\n\tif (!sample)\n\t\tgoto error;\n\n\tif (sample->size == 0) {\n\t\tisl_vec_free(sample);\n\t\tif (isl_tab_mark_empty(cgbr->tab) < 0)\n\t\t\tgoto error;\n\t\treturn;\n\t}\n\n\tif (isl_tab_add_sample(cgbr->tab, sample) < 0)\n\t\tgoto error;\n\n\treturn;\nerror:\n\tisl_tab_free(cgbr->tab);\n\tcgbr->tab = NULL;\n}\n\nstatic struct isl_tab *add_gbr_eq(struct isl_tab *tab, isl_int *eq)\n{\n\tif (!tab)\n\t\treturn NULL;\n\n\tif (isl_tab_extend_cons(tab, 2) < 0)\n\t\tgoto error;\n\n\tif (isl_tab_add_eq(tab, eq) < 0)\n\t\tgoto error;\n\n\treturn tab;\nerror:\n\tisl_tab_free(tab);\n\treturn NULL;\n}\n\n/* Add the equality described by \"eq\" to the context.\n * If \"check\" is set, then we check if the context is empty after\n * adding the equality.\n * If \"update\" is set, then we check if the samples are still valid.\n *\n * We do not explicitly add shifted copies of the equality to\n * cgbr->shifted since they would conflict with each other.\n * Instead, we directly mark cgbr->shifted empty.\n */\nstatic void context_gbr_add_eq(struct isl_context *context, isl_int *eq,\n\t\tint check, int update)\n{\n\tstruct isl_context_gbr *cgbr = (struct isl_context_gbr *)context;\n\n\tcgbr->tab = add_gbr_eq(cgbr->tab, eq);\n\n\tif (cgbr->shifted && !cgbr->shifted->empty && use_shifted(cgbr)) {\n\t\tif (isl_tab_mark_empty(cgbr->shifted) < 0)\n\t\t\tgoto error;\n\t}\n\n\tif (cgbr->cone && cgbr->cone->n_col != cgbr->cone->n_dead) {\n\t\tif (isl_tab_extend_cons(cgbr->cone, 2) < 0)\n\t\t\tgoto error;\n\t\tif (isl_tab_add_eq(cgbr->cone, eq) < 0)\n\t\t\tgoto error;\n\t}\n\n\tif (check) {\n\t\tint v = tab_has_valid_sample(cgbr->tab, eq, 1);\n\t\tif (v < 0)\n\t\t\tgoto error;\n\t\tif (!v)\n\t\t\tcheck_gbr_integer_feasible(cgbr);\n\t}\n\tif (update)\n\t\tcgbr->tab = check_samples(cgbr->tab, eq, 1);\n\treturn;\nerror:\n\tisl_tab_free(cgbr->tab);\n\tcgbr->tab = NULL;\n}\n\nstatic void add_gbr_ineq(struct isl_context_gbr *cgbr, isl_int *ineq)\n{\n\tif (!cgbr->tab)\n\t\treturn;\n\n\tif (isl_tab_extend_cons(cgbr->tab, 1) < 0)\n\t\tgoto error;\n\n\tif (isl_tab_add_ineq(cgbr->tab, ineq) < 0)\n\t\tgoto error;\n\n\tif (cgbr->shifted && !cgbr->shifted->empty && use_shifted(cgbr)) {\n\t\tint i;\n\t\tisl_size dim;\n\t\tdim = isl_basic_map_dim(cgbr->tab->bmap, isl_dim_all);\n\t\tif (dim < 0)\n\t\t\tgoto error;\n\n\t\tif (isl_tab_extend_cons(cgbr->shifted, 1) < 0)\n\t\t\tgoto error;\n\n\t\tfor (i = 0; i < dim; ++i) {\n\t\t\tif (!isl_int_is_neg(ineq[1 + i]))\n\t\t\t\tcontinue;\n\t\t\tisl_int_add(ineq[0], ineq[0], ineq[1 + i]);\n\t\t}\n\n\t\tif (isl_tab_add_ineq(cgbr->shifted, ineq) < 0)\n\t\t\tgoto error;\n\n\t\tfor (i = 0; i < dim; ++i) {\n\t\t\tif (!isl_int_is_neg(ineq[1 + i]))\n\t\t\t\tcontinue;\n\t\t\tisl_int_sub(ineq[0], ineq[0], ineq[1 + i]);\n\t\t}\n\t}\n\n\tif (cgbr->cone && cgbr->cone->n_col != cgbr->cone->n_dead) {\n\t\tif (isl_tab_extend_cons(cgbr->cone, 1) < 0)\n\t\t\tgoto error;\n\t\tif (isl_tab_add_ineq(cgbr->cone, ineq) < 0)\n\t\t\tgoto error;\n\t}\n\n\treturn;\nerror:\n\tisl_tab_free(cgbr->tab);\n\tcgbr->tab = NULL;\n}\n\nstatic void context_gbr_add_ineq(struct isl_context *context, isl_int *ineq,\n\t\tint check, int update)\n{\n\tstruct isl_context_gbr *cgbr = (struct isl_context_gbr *)context;\n\n\tadd_gbr_ineq(cgbr, ineq);\n\tif (!cgbr->tab)\n\t\treturn;\n\n\tif (check) {\n\t\tint v = tab_has_valid_sample(cgbr->tab, ineq, 0);\n\t\tif (v < 0)\n\t\t\tgoto error;\n\t\tif (!v)\n\t\t\tcheck_gbr_integer_feasible(cgbr);\n\t}\n\tif (update)\n\t\tcgbr->tab = check_samples(cgbr->tab, ineq, 0);\n\treturn;\nerror:\n\tisl_tab_free(cgbr->tab);\n\tcgbr->tab = NULL;\n}\n\nstatic isl_stat context_gbr_add_ineq_wrap(void *user, isl_int *ineq)\n{\n\tstruct isl_context *context = (struct isl_context *)user;\n\tcontext_gbr_add_ineq(context, ineq, 0, 0);\n\treturn context->op->is_ok(context) ? isl_stat_ok : isl_stat_error;\n}\n\nstatic enum isl_tab_row_sign context_gbr_ineq_sign(struct isl_context *context,\n\t\t\tisl_int *ineq, int strict)\n{\n\tstruct isl_context_gbr *cgbr = (struct isl_context_gbr *)context;\n\treturn tab_ineq_sign(cgbr->tab, ineq, strict);\n}\n\n/* Check whether \"ineq\" can be added to the tableau without rendering\n * it infeasible.\n */\nstatic int context_gbr_test_ineq(struct isl_context *context, isl_int *ineq)\n{\n\tstruct isl_context_gbr *cgbr = (struct isl_context_gbr *)context;\n\tstruct isl_tab_undo *snap;\n\tstruct isl_tab_undo *shifted_snap = NULL;\n\tstruct isl_tab_undo *cone_snap = NULL;\n\tint feasible;\n\n\tif (!cgbr->tab)\n\t\treturn -1;\n\n\tif (isl_tab_extend_cons(cgbr->tab, 1) < 0)\n\t\treturn -1;\n\n\tsnap = isl_tab_snap(cgbr->tab);\n\tif (cgbr->shifted)\n\t\tshifted_snap = isl_tab_snap(cgbr->shifted);\n\tif (cgbr->cone)\n\t\tcone_snap = isl_tab_snap(cgbr->cone);\n\tadd_gbr_ineq(cgbr, ineq);\n\tcheck_gbr_integer_feasible(cgbr);\n\tif (!cgbr->tab)\n\t\treturn -1;\n\tfeasible = !cgbr->tab->empty;\n\tif (isl_tab_rollback(cgbr->tab, snap) < 0)\n\t\treturn -1;\n\tif (shifted_snap) {\n\t\tif (isl_tab_rollback(cgbr->shifted, shifted_snap))\n\t\t\treturn -1;\n\t} else if (cgbr->shifted) {\n\t\tisl_tab_free(cgbr->shifted);\n\t\tcgbr->shifted = NULL;\n\t}\n\tif (cone_snap) {\n\t\tif (isl_tab_rollback(cgbr->cone, cone_snap))\n\t\t\treturn -1;\n\t} else if (cgbr->cone) {\n\t\tisl_tab_free(cgbr->cone);\n\t\tcgbr->cone = NULL;\n\t}\n\n\treturn feasible;\n}\n\n/* Return the column of the last of the variables associated to\n * a column that has a non-zero coefficient.\n * This function is called in a context where only coefficients\n * of parameters or divs can be non-zero.\n */\nstatic int last_non_zero_var_col(struct isl_tab *tab, isl_int *p)\n{\n\tint i;\n\tint col;\n\n\tif (tab->n_var == 0)\n\t\treturn -1;\n\n\tfor (i = tab->n_var - 1; i >= 0; --i) {\n\t\tif (i >= tab->n_param && i < tab->n_var - tab->n_div)\n\t\t\tcontinue;\n\t\tif (tab->var[i].is_row)\n\t\t\tcontinue;\n\t\tcol = tab->var[i].index;\n\t\tif (!isl_int_is_zero(p[col]))\n\t\t\treturn col;\n\t}\n\n\treturn -1;\n}\n\n/* Look through all the recently added equalities in the context\n * to see if we can propagate any of them to the main tableau.\n *\n * The newly added equalities in the context are encoded as pairs\n * of inequalities starting at inequality \"first\".\n *\n * We tentatively add each of these equalities to the main tableau\n * and if this happens to result in a row with a final coefficient\n * that is one or negative one, we use it to kill a column\n * in the main tableau.  Otherwise, we discard the tentatively\n * added row.\n * This tentative addition of equality constraints turns\n * on the undo facility of the tableau.  Turn it off again\n * at the end, assuming it was turned off to begin with.\n *\n * Return 0 on success and -1 on failure.\n */\nstatic int propagate_equalities(struct isl_context_gbr *cgbr,\n\tstruct isl_tab *tab, unsigned first)\n{\n\tint i;\n\tstruct isl_vec *eq = NULL;\n\tisl_bool needs_undo;\n\n\tneeds_undo = isl_tab_need_undo(tab);\n\tif (needs_undo < 0)\n\t\tgoto error;\n\teq = isl_vec_alloc(tab->mat->ctx, 1 + tab->n_var);\n\tif (!eq)\n\t\tgoto error;\n\n\tif (isl_tab_extend_cons(tab, (cgbr->tab->bmap->n_ineq - first)/2) < 0)\n\t\tgoto error;\n\n\tisl_seq_clr(eq->el + 1 + tab->n_param,\n\t\t    tab->n_var - tab->n_param - tab->n_div);\n\tfor (i = first; i < cgbr->tab->bmap->n_ineq; i += 2) {\n\t\tint j;\n\t\tint r;\n\t\tstruct isl_tab_undo *snap;\n\t\tsnap = isl_tab_snap(tab);\n\n\t\tisl_seq_cpy(eq->el, cgbr->tab->bmap->ineq[i], 1 + tab->n_param);\n\t\tisl_seq_cpy(eq->el + 1 + tab->n_var - tab->n_div,\n\t\t\t    cgbr->tab->bmap->ineq[i] + 1 + tab->n_param,\n\t\t\t    tab->n_div);\n\n\t\tr = isl_tab_add_row(tab, eq->el);\n\t\tif (r < 0)\n\t\t\tgoto error;\n\t\tr = tab->con[r].index;\n\t\tj = last_non_zero_var_col(tab, tab->mat->row[r] + 2 + tab->M);\n\t\tif (j < 0 || j < tab->n_dead ||\n\t\t    !isl_int_is_one(tab->mat->row[r][0]) ||\n\t\t    (!isl_int_is_one(tab->mat->row[r][2 + tab->M + j]) &&\n\t\t     !isl_int_is_negone(tab->mat->row[r][2 + tab->M + j]))) {\n\t\t\tif (isl_tab_rollback(tab, snap) < 0)\n\t\t\t\tgoto error;\n\t\t\tcontinue;\n\t\t}\n\t\tif (isl_tab_pivot(tab, r, j) < 0)\n\t\t\tgoto error;\n\t\tif (isl_tab_kill_col(tab, j) < 0)\n\t\t\tgoto error;\n\n\t\tif (restore_lexmin(tab) < 0)\n\t\t\tgoto error;\n\t}\n\n\tif (!needs_undo)\n\t\tisl_tab_clear_undo(tab);\n\tisl_vec_free(eq);\n\n\treturn 0;\nerror:\n\tisl_vec_free(eq);\n\tisl_tab_free(cgbr->tab);\n\tcgbr->tab = NULL;\n\treturn -1;\n}\n\nstatic int context_gbr_detect_equalities(struct isl_context *context,\n\tstruct isl_tab *tab)\n{\n\tstruct isl_context_gbr *cgbr = (struct isl_context_gbr *)context;\n\tunsigned n_ineq;\n\n\tif (!cgbr->cone) {\n\t\tstruct isl_basic_set *bset = isl_tab_peek_bset(cgbr->tab);\n\t\tcgbr->cone = isl_tab_from_recession_cone(bset, 0);\n\t\tif (!cgbr->cone)\n\t\t\tgoto error;\n\t\tif (isl_tab_track_bset(cgbr->cone,\n\t\t\t\t\tisl_basic_set_copy(bset)) < 0)\n\t\t\tgoto error;\n\t}\n\tif (isl_tab_detect_implicit_equalities(cgbr->cone) < 0)\n\t\tgoto error;\n\n\tn_ineq = cgbr->tab->bmap->n_ineq;\n\tcgbr->tab = isl_tab_detect_equalities(cgbr->tab, cgbr->cone);\n\tif (!cgbr->tab)\n\t\treturn -1;\n\tif (cgbr->tab->bmap->n_ineq > n_ineq &&\n\t    propagate_equalities(cgbr, tab, n_ineq) < 0)\n\t\treturn -1;\n\n\treturn 0;\nerror:\n\tisl_tab_free(cgbr->tab);\n\tcgbr->tab = NULL;\n\treturn -1;\n}\n\nstatic int context_gbr_get_div(struct isl_context *context, struct isl_tab *tab,\n\t\tstruct isl_vec *div)\n{\n\treturn get_div(tab, context, div);\n}\n\nstatic isl_bool context_gbr_insert_div(struct isl_context *context, int pos,\n\t__isl_keep isl_vec *div)\n{\n\tstruct isl_context_gbr *cgbr = (struct isl_context_gbr *)context;\n\tif (cgbr->cone) {\n\t\tint r, o_div;\n\t\tisl_size n_div;\n\n\t\tn_div = isl_basic_map_dim(cgbr->cone->bmap, isl_dim_div);\n\t\tif (n_div < 0)\n\t\t\treturn isl_bool_error;\n\t\to_div = cgbr->cone->n_var - n_div;\n\n\t\tif (isl_tab_extend_cons(cgbr->cone, 3) < 0)\n\t\t\treturn isl_bool_error;\n\t\tif (isl_tab_extend_vars(cgbr->cone, 1) < 0)\n\t\t\treturn isl_bool_error;\n\t\tif ((r = isl_tab_insert_var(cgbr->cone, pos)) <0)\n\t\t\treturn isl_bool_error;\n\n\t\tcgbr->cone->bmap = isl_basic_map_insert_div(cgbr->cone->bmap,\n\t\t\t\t\t\t    r - o_div, div);\n\t\tif (!cgbr->cone->bmap)\n\t\t\treturn isl_bool_error;\n\t\tif (isl_tab_push_var(cgbr->cone, isl_tab_undo_bmap_div,\n\t\t\t\t    &cgbr->cone->var[r]) < 0)\n\t\t\treturn isl_bool_error;\n\t}\n\treturn context_tab_insert_div(cgbr->tab, pos, div,\n\t\t\t\t\tcontext_gbr_add_ineq_wrap, context);\n}\n\nstatic int context_gbr_best_split(struct isl_context *context,\n\t\tstruct isl_tab *tab)\n{\n\tstruct isl_context_gbr *cgbr = (struct isl_context_gbr *)context;\n\tstruct isl_tab_undo *snap;\n\tint r;\n\n\tsnap = isl_tab_snap(cgbr->tab);\n\tr = best_split(tab, cgbr->tab);\n\n\tif (r >= 0 && isl_tab_rollback(cgbr->tab, snap) < 0)\n\t\treturn -1;\n\n\treturn r;\n}\n\nstatic int context_gbr_is_empty(struct isl_context *context)\n{\n\tstruct isl_context_gbr *cgbr = (struct isl_context_gbr *)context;\n\tif (!cgbr->tab)\n\t\treturn -1;\n\treturn cgbr->tab->empty;\n}\n\nstruct isl_gbr_tab_undo {\n\tstruct isl_tab_undo *tab_snap;\n\tstruct isl_tab_undo *shifted_snap;\n\tstruct isl_tab_undo *cone_snap;\n};\n\nstatic void *context_gbr_save(struct isl_context *context)\n{\n\tstruct isl_context_gbr *cgbr = (struct isl_context_gbr *)context;\n\tstruct isl_gbr_tab_undo *snap;\n\n\tif (!cgbr->tab)\n\t\treturn NULL;\n\n\tsnap = isl_alloc_type(cgbr->tab->mat->ctx, struct isl_gbr_tab_undo);\n\tif (!snap)\n\t\treturn NULL;\n\n\tsnap->tab_snap = isl_tab_snap(cgbr->tab);\n\tif (isl_tab_save_samples(cgbr->tab) < 0)\n\t\tgoto error;\n\n\tif (cgbr->shifted)\n\t\tsnap->shifted_snap = isl_tab_snap(cgbr->shifted);\n\telse\n\t\tsnap->shifted_snap = NULL;\n\n\tif (cgbr->cone)\n\t\tsnap->cone_snap = isl_tab_snap(cgbr->cone);\n\telse\n\t\tsnap->cone_snap = NULL;\n\n\treturn snap;\nerror:\n\tfree(snap);\n\treturn NULL;\n}\n\nstatic void context_gbr_restore(struct isl_context *context, void *save)\n{\n\tstruct isl_context_gbr *cgbr = (struct isl_context_gbr *)context;\n\tstruct isl_gbr_tab_undo *snap = (struct isl_gbr_tab_undo *)save;\n\tif (!snap)\n\t\tgoto error;\n\tif (isl_tab_rollback(cgbr->tab, snap->tab_snap) < 0)\n\t\tgoto error;\n\n\tif (snap->shifted_snap) {\n\t\tif (isl_tab_rollback(cgbr->shifted, snap->shifted_snap) < 0)\n\t\t\tgoto error;\n\t} else if (cgbr->shifted) {\n\t\tisl_tab_free(cgbr->shifted);\n\t\tcgbr->shifted = NULL;\n\t}\n\n\tif (snap->cone_snap) {\n\t\tif (isl_tab_rollback(cgbr->cone, snap->cone_snap) < 0)\n\t\t\tgoto error;\n\t} else if (cgbr->cone) {\n\t\tisl_tab_free(cgbr->cone);\n\t\tcgbr->cone = NULL;\n\t}\n\n\tfree(snap);\n\n\treturn;\nerror:\n\tfree(snap);\n\tisl_tab_free(cgbr->tab);\n\tcgbr->tab = NULL;\n}\n\nstatic void context_gbr_discard(void *save)\n{\n\tstruct isl_gbr_tab_undo *snap = (struct isl_gbr_tab_undo *)save;\n\tfree(snap);\n}\n\nstatic int context_gbr_is_ok(struct isl_context *context)\n{\n\tstruct isl_context_gbr *cgbr = (struct isl_context_gbr *)context;\n\treturn !!cgbr->tab;\n}\n\nstatic void context_gbr_invalidate(struct isl_context *context)\n{\n\tstruct isl_context_gbr *cgbr = (struct isl_context_gbr *)context;\n\tisl_tab_free(cgbr->tab);\n\tcgbr->tab = NULL;\n}\n\nstatic __isl_null struct isl_context *context_gbr_free(\n\tstruct isl_context *context)\n{\n\tstruct isl_context_gbr *cgbr = (struct isl_context_gbr *)context;\n\tisl_tab_free(cgbr->tab);\n\tisl_tab_free(cgbr->shifted);\n\tisl_tab_free(cgbr->cone);\n\tfree(cgbr);\n\n\treturn NULL;\n}\n\nstruct isl_context_op isl_context_gbr_op = {\n\tcontext_gbr_detect_nonnegative_parameters,\n\tcontext_gbr_peek_basic_set,\n\tcontext_gbr_peek_tab,\n\tcontext_gbr_add_eq,\n\tcontext_gbr_add_ineq,\n\tcontext_gbr_ineq_sign,\n\tcontext_gbr_test_ineq,\n\tcontext_gbr_get_div,\n\tcontext_gbr_insert_div,\n\tcontext_gbr_detect_equalities,\n\tcontext_gbr_best_split,\n\tcontext_gbr_is_empty,\n\tcontext_gbr_is_ok,\n\tcontext_gbr_save,\n\tcontext_gbr_restore,\n\tcontext_gbr_discard,\n\tcontext_gbr_invalidate,\n\tcontext_gbr_free,\n};\n\nstatic struct isl_context *isl_context_gbr_alloc(__isl_keep isl_basic_set *dom)\n{\n\tstruct isl_context_gbr *cgbr;\n\n\tif (!dom)\n\t\treturn NULL;\n\n\tcgbr = isl_calloc_type(dom->ctx, struct isl_context_gbr);\n\tif (!cgbr)\n\t\treturn NULL;\n\n\tcgbr->context.op = &isl_context_gbr_op;\n\n\tcgbr->shifted = NULL;\n\tcgbr->cone = NULL;\n\tcgbr->tab = isl_tab_from_basic_set(dom, 1);\n\tcgbr->tab = isl_tab_init_samples(cgbr->tab);\n\tif (!cgbr->tab)\n\t\tgoto error;\n\tcheck_gbr_integer_feasible(cgbr);\n\n\treturn &cgbr->context;\nerror:\n\tcgbr->context.op->free(&cgbr->context);\n\treturn NULL;\n}\n\n/* Allocate a context corresponding to \"dom\".\n * The representation specific fields are initialized by\n * isl_context_lex_alloc or isl_context_gbr_alloc.\n * The shared \"n_unknown\" field is initialized to the number\n * of final unknown integer divisions in \"dom\".\n */\nstatic struct isl_context *isl_context_alloc(__isl_keep isl_basic_set *dom)\n{\n\tstruct isl_context *context;\n\tint first;\n\tisl_size n_div;\n\n\tif (!dom)\n\t\treturn NULL;\n\n\tif (dom->ctx->opt->context == ISL_CONTEXT_LEXMIN)\n\t\tcontext = isl_context_lex_alloc(dom);\n\telse\n\t\tcontext = isl_context_gbr_alloc(dom);\n\n\tif (!context)\n\t\treturn NULL;\n\n\tfirst = isl_basic_set_first_unknown_div(dom);\n\tn_div = isl_basic_set_dim(dom, isl_dim_div);\n\tif (first < 0 || n_div < 0)\n\t\treturn context->op->free(context);\n\tcontext->n_unknown = n_div - first;\n\n\treturn context;\n}\n\n/* Initialize some common fields of \"sol\", which keeps track\n * of the solution of an optimization problem on \"bmap\" over\n * the domain \"dom\".\n * If \"max\" is set, then a maximization problem is being solved, rather than\n * a minimization problem, which means that the variables in the\n * tableau have value \"M - x\" rather than \"M + x\".\n */\nstatic isl_stat sol_init(struct isl_sol *sol, __isl_keep isl_basic_map *bmap,\n\t__isl_keep isl_basic_set *dom, int max)\n{\n\tsol->rational = ISL_F_ISSET(bmap, ISL_BASIC_MAP_RATIONAL);\n\tsol->dec_level.callback.run = &sol_dec_level_wrap;\n\tsol->dec_level.sol = sol;\n\tsol->max = max;\n\tsol->n_out = isl_basic_map_dim(bmap, isl_dim_out);\n\tsol->space = isl_basic_map_get_space(bmap);\n\n\tsol->context = isl_context_alloc(dom);\n\tif (sol->n_out < 0 || !sol->space || !sol->context)\n\t\treturn isl_stat_error;\n\n\treturn isl_stat_ok;\n}\n\n/* Construct an isl_sol_map structure for accumulating the solution.\n * If track_empty is set, then we also keep track of the parts\n * of the context where there is no solution.\n * If max is set, then we are solving a maximization, rather than\n * a minimization problem, which means that the variables in the\n * tableau have value \"M - x\" rather than \"M + x\".\n */\nstatic struct isl_sol *sol_map_init(__isl_keep isl_basic_map *bmap,\n\t__isl_take isl_basic_set *dom, int track_empty, int max)\n{\n\tstruct isl_sol_map *sol_map = NULL;\n\tisl_space *space;\n\n\tif (!bmap)\n\t\tgoto error;\n\n\tsol_map = isl_calloc_type(bmap->ctx, struct isl_sol_map);\n\tif (!sol_map)\n\t\tgoto error;\n\n\tsol_map->sol.free = &sol_map_free;\n\tif (sol_init(&sol_map->sol, bmap, dom, max) < 0)\n\t\tgoto error;\n\tsol_map->sol.add = &sol_map_add_wrap;\n\tsol_map->sol.add_empty = track_empty ? &sol_map_add_empty_wrap : NULL;\n\tspace = isl_space_copy(sol_map->sol.space);\n\tsol_map->map = isl_map_alloc_space(space, 1, ISL_MAP_DISJOINT);\n\tif (!sol_map->map)\n\t\tgoto error;\n\n\tif (track_empty) {\n\t\tsol_map->empty = isl_set_alloc_space(isl_basic_set_get_space(dom),\n\t\t\t\t\t\t\t1, ISL_SET_DISJOINT);\n\t\tif (!sol_map->empty)\n\t\t\tgoto error;\n\t}\n\n\tisl_basic_set_free(dom);\n\treturn &sol_map->sol;\nerror:\n\tisl_basic_set_free(dom);\n\tsol_free(&sol_map->sol);\n\treturn NULL;\n}\n\n/* Check whether all coefficients of (non-parameter) variables\n * are non-positive, meaning that no pivots can be performed on the row.\n */\nstatic int is_critical(struct isl_tab *tab, int row)\n{\n\tint j;\n\tunsigned off = 2 + tab->M;\n\n\tfor (j = tab->n_dead; j < tab->n_col; ++j) {\n\t\tif (col_is_parameter_var(tab, j))\n\t\t\tcontinue;\n\n\t\tif (isl_int_is_pos(tab->mat->row[row][off + j]))\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n/* Check whether the inequality represented by vec is strict over the integers,\n * i.e., there are no integer values satisfying the constraint with\n * equality.  This happens if the gcd of the coefficients is not a divisor\n * of the constant term.  If so, scale the constraint down by the gcd\n * of the coefficients.\n */\nstatic int is_strict(struct isl_vec *vec)\n{\n\tisl_int gcd;\n\tint strict = 0;\n\n\tisl_int_init(gcd);\n\tisl_seq_gcd(vec->el + 1, vec->size - 1, &gcd);\n\tif (!isl_int_is_one(gcd)) {\n\t\tstrict = !isl_int_is_divisible_by(vec->el[0], gcd);\n\t\tisl_int_fdiv_q(vec->el[0], vec->el[0], gcd);\n\t\tisl_seq_scale_down(vec->el + 1, vec->el + 1, gcd, vec->size-1);\n\t}\n\tisl_int_clear(gcd);\n\n\treturn strict;\n}\n\n/* Determine the sign of the given row of the main tableau.\n * The result is one of\n *\tisl_tab_row_pos: always non-negative; no pivot needed\n *\tisl_tab_row_neg: always non-positive; pivot\n *\tisl_tab_row_any: can be both positive and negative; split\n *\n * We first handle some simple cases\n *\t- the row sign may be known already\n *\t- the row may be obviously non-negative\n *\t- the parametric constant may be equal to that of another row\n *\t  for which we know the sign.  This sign will be either \"pos\" or\n *\t  \"any\".  If it had been \"neg\" then we would have pivoted before.\n *\n * If none of these cases hold, we check the value of the row for each\n * of the currently active samples.  Based on the signs of these values\n * we make an initial determination of the sign of the row.\n *\n *\tall zero\t\t\t->\tunk(nown)\n *\tall non-negative\t\t->\tpos\n *\tall non-positive\t\t->\tneg\n *\tboth negative and positive\t->\tall\n *\n * If we end up with \"all\", we are done.\n * Otherwise, we perform a check for positive and/or negative\n * values as follows.\n *\n *\tsamples\t       neg\t       unk\t       pos\n *\t<0 ?\t\t\t    Y        N\t    Y        N\n *\t\t\t\t\t    pos    any      pos\n *\t>0 ?\t     Y      N\t Y     N\n *\t\t    any    neg  any   neg\n *\n * There is no special sign for \"zero\", because we can usually treat zero\n * as either non-negative or non-positive, whatever works out best.\n * However, if the row is \"critical\", meaning that pivoting is impossible\n * then we don't want to limp zero with the non-positive case, because\n * then we we would lose the solution for those values of the parameters\n * where the value of the row is zero.  Instead, we treat 0 as non-negative\n * ensuring a split if the row can attain both zero and negative values.\n * The same happens when the original constraint was one that could not\n * be satisfied with equality by any integer values of the parameters.\n * In this case, we normalize the constraint, but then a value of zero\n * for the normalized constraint is actually a positive value for the\n * original constraint, so again we need to treat zero as non-negative.\n * In both these cases, we have the following decision tree instead:\n *\n *\tall non-negative\t\t->\tpos\n *\tall negative\t\t\t->\tneg\n *\tboth negative and non-negative\t->\tall\n *\n *\tsamples\t       neg\t          \t       pos\n *\t<0 ?\t\t\t             \t    Y        N\n *\t\t\t\t\t           any      pos\n *\t>=0 ?\t     Y      N\n *\t\t    any    neg\n */\nstatic enum isl_tab_row_sign row_sign(struct isl_tab *tab,\n\tstruct isl_sol *sol, int row)\n{\n\tstruct isl_vec *ineq = NULL;\n\tenum isl_tab_row_sign res = isl_tab_row_unknown;\n\tint critical;\n\tint strict;\n\tint row2;\n\n\tif (tab->row_sign[row] != isl_tab_row_unknown)\n\t\treturn tab->row_sign[row];\n\tif (is_obviously_nonneg(tab, row))\n\t\treturn isl_tab_row_pos;\n\tfor (row2 = tab->n_redundant; row2 < tab->n_row; ++row2) {\n\t\tif (tab->row_sign[row2] == isl_tab_row_unknown)\n\t\t\tcontinue;\n\t\tif (identical_parameter_line(tab, row, row2))\n\t\t\treturn tab->row_sign[row2];\n\t}\n\n\tcritical = is_critical(tab, row);\n\n\tineq = get_row_parameter_ineq(tab, row);\n\tif (!ineq)\n\t\tgoto error;\n\n\tstrict = is_strict(ineq);\n\n\tres = sol->context->op->ineq_sign(sol->context, ineq->el,\n\t\t\t\t\t  critical || strict);\n\n\tif (res == isl_tab_row_unknown || res == isl_tab_row_pos) {\n\t\t/* test for negative values */\n\t\tint feasible;\n\t\tisl_seq_neg(ineq->el, ineq->el, ineq->size);\n\t\tisl_int_sub_ui(ineq->el[0], ineq->el[0], 1);\n\n\t\tfeasible = sol->context->op->test_ineq(sol->context, ineq->el);\n\t\tif (feasible < 0)\n\t\t\tgoto error;\n\t\tif (!feasible)\n\t\t\tres = isl_tab_row_pos;\n\t\telse\n\t\t\tres = (res == isl_tab_row_unknown) ? isl_tab_row_neg\n\t\t\t\t\t\t\t   : isl_tab_row_any;\n\t\tif (res == isl_tab_row_neg) {\n\t\t\tisl_seq_neg(ineq->el, ineq->el, ineq->size);\n\t\t\tisl_int_sub_ui(ineq->el[0], ineq->el[0], 1);\n\t\t}\n\t}\n\n\tif (res == isl_tab_row_neg) {\n\t\t/* test for positive values */\n\t\tint feasible;\n\t\tif (!critical && !strict)\n\t\t\tisl_int_sub_ui(ineq->el[0], ineq->el[0], 1);\n\n\t\tfeasible = sol->context->op->test_ineq(sol->context, ineq->el);\n\t\tif (feasible < 0)\n\t\t\tgoto error;\n\t\tif (feasible)\n\t\t\tres = isl_tab_row_any;\n\t}\n\n\tisl_vec_free(ineq);\n\treturn res;\nerror:\n\tisl_vec_free(ineq);\n\treturn isl_tab_row_unknown;\n}\n\nstatic void find_solutions(struct isl_sol *sol, struct isl_tab *tab);\n\n/* Find solutions for values of the parameters that satisfy the given\n * inequality.\n *\n * We currently take a snapshot of the context tableau that is reset\n * when we return from this function, while we make a copy of the main\n * tableau, leaving the original main tableau untouched.\n * These are fairly arbitrary choices.  Making a copy also of the context\n * tableau would obviate the need to undo any changes made to it later,\n * while taking a snapshot of the main tableau could reduce memory usage.\n * If we were to switch to taking a snapshot of the main tableau,\n * we would have to keep in mind that we need to save the row signs\n * and that we need to do this before saving the current basis\n * such that the basis has been restore before we restore the row signs.\n */\nstatic void find_in_pos(struct isl_sol *sol, struct isl_tab *tab, isl_int *ineq)\n{\n\tvoid *saved;\n\n\tif (!sol->context)\n\t\tgoto error;\n\tsaved = sol->context->op->save(sol->context);\n\n\ttab = isl_tab_dup(tab);\n\tif (!tab)\n\t\tgoto error;\n\n\tsol->context->op->add_ineq(sol->context, ineq, 0, 1);\n\n\tfind_solutions(sol, tab);\n\n\tif (!sol->error)\n\t\tsol->context->op->restore(sol->context, saved);\n\telse\n\t\tsol->context->op->discard(saved);\n\treturn;\nerror:\n\tsol->error = 1;\n}\n\n/* Record the absence of solutions for those values of the parameters\n * that do not satisfy the given inequality with equality.\n */\nstatic void no_sol_in_strict(struct isl_sol *sol,\n\tstruct isl_tab *tab, struct isl_vec *ineq)\n{\n\tint empty;\n\tvoid *saved;\n\n\tif (!sol->context || sol->error)\n\t\tgoto error;\n\tsaved = sol->context->op->save(sol->context);\n\n\tisl_int_sub_ui(ineq->el[0], ineq->el[0], 1);\n\n\tsol->context->op->add_ineq(sol->context, ineq->el, 1, 0);\n\tif (!sol->context)\n\t\tgoto error;\n\n\tempty = tab->empty;\n\ttab->empty = 1;\n\tsol_add(sol, tab);\n\ttab->empty = empty;\n\n\tisl_int_add_ui(ineq->el[0], ineq->el[0], 1);\n\n\tsol->context->op->restore(sol->context, saved);\n\treturn;\nerror:\n\tsol->error = 1;\n}\n\n/* Reset all row variables that are marked to have a sign that may\n * be both positive and negative to have an unknown sign.\n */\nstatic void reset_any_to_unknown(struct isl_tab *tab)\n{\n\tint row;\n\n\tfor (row = tab->n_redundant; row < tab->n_row; ++row) {\n\t\tif (!isl_tab_var_from_row(tab, row)->is_nonneg)\n\t\t\tcontinue;\n\t\tif (tab->row_sign[row] == isl_tab_row_any)\n\t\t\ttab->row_sign[row] = isl_tab_row_unknown;\n\t}\n}\n\n/* Compute the lexicographic minimum of the set represented by the main\n * tableau \"tab\" within the context \"sol->context_tab\".\n * On entry the sample value of the main tableau is lexicographically\n * less than or equal to this lexicographic minimum.\n * Pivots are performed until a feasible point is found, which is then\n * necessarily equal to the minimum, or until the tableau is found to\n * be infeasible.  Some pivots may need to be performed for only some\n * feasible values of the context tableau.  If so, the context tableau\n * is split into a part where the pivot is needed and a part where it is not.\n *\n * Whenever we enter the main loop, the main tableau is such that no\n * \"obvious\" pivots need to be performed on it, where \"obvious\" means\n * that the given row can be seen to be negative without looking at\n * the context tableau.  In particular, for non-parametric problems,\n * no pivots need to be performed on the main tableau.\n * The caller of find_solutions is responsible for making this property\n * hold prior to the first iteration of the loop, while restore_lexmin\n * is called before every other iteration.\n *\n * Inside the main loop, we first examine the signs of the rows of\n * the main tableau within the context of the context tableau.\n * If we find a row that is always non-positive for all values of\n * the parameters satisfying the context tableau and negative for at\n * least one value of the parameters, we perform the appropriate pivot\n * and start over.  An exception is the case where no pivot can be\n * performed on the row.  In this case, we require that the sign of\n * the row is negative for all values of the parameters (rather than just\n * non-positive).  This special case is handled inside row_sign, which\n * will say that the row can have any sign if it determines that it can\n * attain both negative and zero values.\n *\n * If we can't find a row that always requires a pivot, but we can find\n * one or more rows that require a pivot for some values of the parameters\n * (i.e., the row can attain both positive and negative signs), then we split\n * the context tableau into two parts, one where we force the sign to be\n * non-negative and one where we force is to be negative.\n * The non-negative part is handled by a recursive call (through find_in_pos).\n * Upon returning from this call, we continue with the negative part and\n * perform the required pivot.\n *\n * If no such rows can be found, all rows are non-negative and we have\n * found a (rational) feasible point.  If we only wanted a rational point\n * then we are done.\n * Otherwise, we check if all values of the sample point of the tableau\n * are integral for the variables.  If so, we have found the minimal\n * integral point and we are done.\n * If the sample point is not integral, then we need to make a distinction\n * based on whether the constant term is non-integral or the coefficients\n * of the parameters.  Furthermore, in order to decide how to handle\n * the non-integrality, we also need to know whether the coefficients\n * of the other columns in the tableau are integral.  This leads\n * to the following table.  The first two rows do not correspond\n * to a non-integral sample point and are only mentioned for completeness.\n *\n *\tconstant\tparameters\tother\n *\n *\tint\t\tint\t\tint\t|\n *\tint\t\tint\t\trat\t| -> no problem\n *\n *\trat\t\tint\t\tint\t  -> fail\n *\n *\trat\t\tint\t\trat\t  -> cut\n *\n *\tint\t\trat\t\trat\t|\n *\trat\t\trat\t\trat\t| -> parametric cut\n *\n *\tint\t\trat\t\tint\t|\n *\trat\t\trat\t\tint\t| -> split context\n *\n * If the parametric constant is completely integral, then there is nothing\n * to be done.  If the constant term is non-integral, but all the other\n * coefficient are integral, then there is nothing that can be done\n * and the tableau has no integral solution.\n * If, on the other hand, one or more of the other columns have rational\n * coefficients, but the parameter coefficients are all integral, then\n * we can perform a regular (non-parametric) cut.\n * Finally, if there is any parameter coefficient that is non-integral,\n * then we need to involve the context tableau.  There are two cases here.\n * If at least one other column has a rational coefficient, then we\n * can perform a parametric cut in the main tableau by adding a new\n * integer division in the context tableau.\n * If all other columns have integral coefficients, then we need to\n * enforce that the rational combination of parameters (c + \\sum a_i y_i)/m\n * is always integral.  We do this by introducing an integer division\n * q = floor((c + \\sum a_i y_i)/m) and stipulating that its argument should\n * always be integral in the context tableau, i.e., m q = c + \\sum a_i y_i.\n * Since q is expressed in the tableau as\n *\tc + \\sum a_i y_i - m q >= 0\n *\t-c - \\sum a_i y_i + m q + m - 1 >= 0\n * it is sufficient to add the inequality\n *\t-c - \\sum a_i y_i + m q >= 0\n * In the part of the context where this inequality does not hold, the\n * main tableau is marked as being empty.\n */\nstatic void find_solutions(struct isl_sol *sol, struct isl_tab *tab)\n{\n\tstruct isl_context *context;\n\tint r;\n\n\tif (!tab || sol->error)\n\t\tgoto error;\n\n\tcontext = sol->context;\n\n\tif (tab->empty)\n\t\tgoto done;\n\tif (context->op->is_empty(context))\n\t\tgoto done;\n\n\tfor (r = 0; r >= 0 && tab && !tab->empty; r = restore_lexmin(tab)) {\n\t\tint flags;\n\t\tint row;\n\t\tenum isl_tab_row_sign sgn;\n\t\tint split = -1;\n\t\tint n_split = 0;\n\n\t\tfor (row = tab->n_redundant; row < tab->n_row; ++row) {\n\t\t\tif (!isl_tab_var_from_row(tab, row)->is_nonneg)\n\t\t\t\tcontinue;\n\t\t\tsgn = row_sign(tab, sol, row);\n\t\t\tif (!sgn)\n\t\t\t\tgoto error;\n\t\t\ttab->row_sign[row] = sgn;\n\t\t\tif (sgn == isl_tab_row_any)\n\t\t\t\tn_split++;\n\t\t\tif (sgn == isl_tab_row_any && split == -1)\n\t\t\t\tsplit = row;\n\t\t\tif (sgn == isl_tab_row_neg)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (row < tab->n_row)\n\t\t\tcontinue;\n\t\tif (split != -1) {\n\t\t\tstruct isl_vec *ineq;\n\t\t\tif (n_split != 1)\n\t\t\t\tsplit = context->op->best_split(context, tab);\n\t\t\tif (split < 0)\n\t\t\t\tgoto error;\n\t\t\tineq = get_row_parameter_ineq(tab, split);\n\t\t\tif (!ineq)\n\t\t\t\tgoto error;\n\t\t\tis_strict(ineq);\n\t\t\treset_any_to_unknown(tab);\n\t\t\ttab->row_sign[split] = isl_tab_row_pos;\n\t\t\tsol_inc_level(sol);\n\t\t\tfind_in_pos(sol, tab, ineq->el);\n\t\t\ttab->row_sign[split] = isl_tab_row_neg;\n\t\t\tisl_seq_neg(ineq->el, ineq->el, ineq->size);\n\t\t\tisl_int_sub_ui(ineq->el[0], ineq->el[0], 1);\n\t\t\tif (!sol->error)\n\t\t\t\tcontext->op->add_ineq(context, ineq->el, 0, 1);\n\t\t\tisl_vec_free(ineq);\n\t\t\tif (sol->error)\n\t\t\t\tgoto error;\n\t\t\tcontinue;\n\t\t}\n\t\tif (tab->rational)\n\t\t\tbreak;\n\t\trow = first_non_integer_row(tab, &flags);\n\t\tif (row < 0)\n\t\t\tbreak;\n\t\tif (ISL_FL_ISSET(flags, I_PAR)) {\n\t\t\tif (ISL_FL_ISSET(flags, I_VAR)) {\n\t\t\t\tif (isl_tab_mark_empty(tab) < 0)\n\t\t\t\t\tgoto error;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trow = add_cut(tab, row);\n\t\t} else if (ISL_FL_ISSET(flags, I_VAR)) {\n\t\t\tstruct isl_vec *div;\n\t\t\tstruct isl_vec *ineq;\n\t\t\tint d;\n\t\t\tdiv = get_row_split_div(tab, row);\n\t\t\tif (!div)\n\t\t\t\tgoto error;\n\t\t\td = context->op->get_div(context, tab, div);\n\t\t\tisl_vec_free(div);\n\t\t\tif (d < 0)\n\t\t\t\tgoto error;\n\t\t\tineq = ineq_for_div(context->op->peek_basic_set(context), d);\n\t\t\tif (!ineq)\n\t\t\t\tgoto error;\n\t\t\tsol_inc_level(sol);\n\t\t\tno_sol_in_strict(sol, tab, ineq);\n\t\t\tisl_seq_neg(ineq->el, ineq->el, ineq->size);\n\t\t\tcontext->op->add_ineq(context, ineq->el, 1, 1);\n\t\t\tisl_vec_free(ineq);\n\t\t\tif (sol->error || !context->op->is_ok(context))\n\t\t\t\tgoto error;\n\t\t\ttab = set_row_cst_to_div(tab, row, d);\n\t\t\tif (context->op->is_empty(context))\n\t\t\t\tbreak;\n\t\t} else\n\t\t\trow = add_parametric_cut(tab, row, context);\n\t\tif (row < 0)\n\t\t\tgoto error;\n\t}\n\tif (r < 0)\n\t\tgoto error;\ndone:\n\tsol_add(sol, tab);\n\tisl_tab_free(tab);\n\treturn;\nerror:\n\tisl_tab_free(tab);\n\tsol->error = 1;\n}\n\n/* Does \"sol\" contain a pair of partial solutions that could potentially\n * be merged?\n *\n * We currently only check that \"sol\" is not in an error state\n * and that there are at least two partial solutions of which the final two\n * are defined at the same level.\n */\nstatic int sol_has_mergeable_solutions(struct isl_sol *sol)\n{\n\tif (sol->error)\n\t\treturn 0;\n\tif (!sol->partial)\n\t\treturn 0;\n\tif (!sol->partial->next)\n\t\treturn 0;\n\treturn sol->partial->level == sol->partial->next->level;\n}\n\n/* Compute the lexicographic minimum of the set represented by the main\n * tableau \"tab\" within the context \"sol->context_tab\".\n *\n * As a preprocessing step, we first transfer all the purely parametric\n * equalities from the main tableau to the context tableau, i.e.,\n * parameters that have been pivoted to a row.\n * These equalities are ignored by the main algorithm, because the\n * corresponding rows may not be marked as being non-negative.\n * In parts of the context where the added equality does not hold,\n * the main tableau is marked as being empty.\n *\n * Before we embark on the actual computation, we save a copy\n * of the context.  When we return, we check if there are any\n * partial solutions that can potentially be merged.  If so,\n * we perform a rollback to the initial state of the context.\n * The merging of partial solutions happens inside calls to\n * sol_dec_level that are pushed onto the undo stack of the context.\n * If there are no partial solutions that can potentially be merged\n * then the rollback is skipped as it would just be wasted effort.\n */\nstatic void find_solutions_main(struct isl_sol *sol, struct isl_tab *tab)\n{\n\tint row;\n\tvoid *saved;\n\n\tif (!tab)\n\t\tgoto error;\n\n\tsol->level = 0;\n\n\tfor (row = tab->n_redundant; row < tab->n_row; ++row) {\n\t\tint p;\n\t\tstruct isl_vec *eq;\n\n\t\tif (!row_is_parameter_var(tab, row))\n\t\t\tcontinue;\n\t\tif (tab->row_var[row] < tab->n_param)\n\t\t\tp = tab->row_var[row];\n\t\telse\n\t\t\tp = tab->row_var[row]\n\t\t\t\t+ tab->n_param - (tab->n_var - tab->n_div);\n\n\t\teq = isl_vec_alloc(tab->mat->ctx, 1+tab->n_param+tab->n_div);\n\t\tif (!eq)\n\t\t\tgoto error;\n\t\tget_row_parameter_line(tab, row, eq->el);\n\t\tisl_int_neg(eq->el[1 + p], tab->mat->row[row][0]);\n\t\teq = isl_vec_normalize(eq);\n\n\t\tsol_inc_level(sol);\n\t\tno_sol_in_strict(sol, tab, eq);\n\n\t\tisl_seq_neg(eq->el, eq->el, eq->size);\n\t\tsol_inc_level(sol);\n\t\tno_sol_in_strict(sol, tab, eq);\n\t\tisl_seq_neg(eq->el, eq->el, eq->size);\n\n\t\tsol->context->op->add_eq(sol->context, eq->el, 1, 1);\n\n\t\tisl_vec_free(eq);\n\n\t\tif (isl_tab_mark_redundant(tab, row) < 0)\n\t\t\tgoto error;\n\n\t\tif (sol->context->op->is_empty(sol->context))\n\t\t\tbreak;\n\n\t\trow = tab->n_redundant - 1;\n\t}\n\n\tsaved = sol->context->op->save(sol->context);\n\n\tfind_solutions(sol, tab);\n\n\tif (sol_has_mergeable_solutions(sol))\n\t\tsol->context->op->restore(sol->context, saved);\n\telse\n\t\tsol->context->op->discard(saved);\n\n\tsol->level = 0;\n\tsol_pop(sol);\n\n\treturn;\nerror:\n\tisl_tab_free(tab);\n\tsol->error = 1;\n}\n\n/* Check if integer division \"div\" of \"dom\" also occurs in \"bmap\".\n * If so, return its position within the divs.\n * Otherwise, return a position beyond the integer divisions.\n */\nstatic int find_context_div(__isl_keep isl_basic_map *bmap,\n\t__isl_keep isl_basic_set *dom, unsigned div)\n{\n\tint i;\n\tisl_size b_v_div, d_v_div;\n\tisl_size n_div;\n\n\tb_v_div = isl_basic_map_var_offset(bmap, isl_dim_div);\n\td_v_div = isl_basic_set_var_offset(dom, isl_dim_div);\n\tn_div = isl_basic_map_dim(bmap, isl_dim_div);\n\tif (b_v_div < 0 || d_v_div < 0 || n_div < 0)\n\t\treturn -1;\n\n\tif (isl_int_is_zero(dom->div[div][0]))\n\t\treturn n_div;\n\tif (isl_seq_first_non_zero(dom->div[div] + 2 + d_v_div,\n\t\t\t\t    dom->n_div) != -1)\n\t\treturn n_div;\n\n\tfor (i = 0; i < n_div; ++i) {\n\t\tif (isl_int_is_zero(bmap->div[i][0]))\n\t\t\tcontinue;\n\t\tif (isl_seq_first_non_zero(bmap->div[i] + 2 + d_v_div,\n\t\t\t\t\t   (b_v_div - d_v_div) + n_div) != -1)\n\t\t\tcontinue;\n\t\tif (isl_seq_eq(bmap->div[i], dom->div[div], 2 + d_v_div))\n\t\t\treturn i;\n\t}\n\treturn n_div;\n}\n\n/* The correspondence between the variables in the main tableau,\n * the context tableau, and the input map and domain is as follows.\n * The first n_param and the last n_div variables of the main tableau\n * form the variables of the context tableau.\n * In the basic map, these n_param variables correspond to the\n * parameters and the input dimensions.  In the domain, they correspond\n * to the parameters and the set dimensions.\n * The n_div variables correspond to the integer divisions in the domain.\n * To ensure that everything lines up, we may need to copy some of the\n * integer divisions of the domain to the map.  These have to be placed\n * in the same order as those in the context and they have to be placed\n * after any other integer divisions that the map may have.\n * This function performs the required reordering.\n */\nstatic __isl_give isl_basic_map *align_context_divs(\n\t__isl_take isl_basic_map *bmap, __isl_keep isl_basic_set *dom)\n{\n\tint i;\n\tint common = 0;\n\tint other;\n\tunsigned bmap_n_div;\n\n\tbmap_n_div = isl_basic_map_dim(bmap, isl_dim_div);\n\n\tfor (i = 0; i < dom->n_div; ++i) {\n\t\tint pos;\n\n\t\tpos = find_context_div(bmap, dom, i);\n\t\tif (pos < 0)\n\t\t\treturn isl_basic_map_free(bmap);\n\t\tif (pos < bmap_n_div)\n\t\t\tcommon++;\n\t}\n\tother = bmap_n_div - common;\n\tif (dom->n_div - common > 0) {\n\t\tbmap = isl_basic_map_cow(bmap);\n\t\tbmap = isl_basic_map_extend(bmap, dom->n_div - common, 0, 0);\n\t\tif (!bmap)\n\t\t\treturn NULL;\n\t}\n\tfor (i = 0; i < dom->n_div; ++i) {\n\t\tint pos = find_context_div(bmap, dom, i);\n\t\tif (pos < 0)\n\t\t\tbmap = isl_basic_map_free(bmap);\n\t\tif (pos >= bmap_n_div) {\n\t\t\tpos = isl_basic_map_alloc_div(bmap);\n\t\t\tif (pos < 0)\n\t\t\t\tgoto error;\n\t\t\tisl_int_set_si(bmap->div[pos][0], 0);\n\t\t\tbmap_n_div++;\n\t\t}\n\t\tif (pos != other + i)\n\t\t\tbmap = isl_basic_map_swap_div(bmap, pos, other + i);\n\t}\n\treturn bmap;\nerror:\n\tisl_basic_map_free(bmap);\n\treturn NULL;\n}\n\n/* Base case of isl_tab_basic_map_partial_lexopt, after removing\n * some obvious symmetries.\n *\n * We make sure the divs in the domain are properly ordered,\n * because they will be added one by one in the given order\n * during the construction of the solution map.\n * Furthermore, make sure that the known integer divisions\n * appear before any unknown integer division because the solution\n * may depend on the known integer divisions, while anything that\n * depends on any variable starting from the first unknown integer\n * division is ignored in sol_pma_add.\n */\nstatic struct isl_sol *basic_map_partial_lexopt_base_sol(\n\t__isl_take isl_basic_map *bmap, __isl_take isl_basic_set *dom,\n\t__isl_give isl_set **empty, int max,\n\tstruct isl_sol *(*init)(__isl_keep isl_basic_map *bmap,\n\t\t    __isl_take isl_basic_set *dom, int track_empty, int max))\n{\n\tstruct isl_tab *tab;\n\tstruct isl_sol *sol = NULL;\n\tstruct isl_context *context;\n\n\tif (dom->n_div) {\n\t\tdom = isl_basic_set_sort_divs(dom);\n\t\tbmap = align_context_divs(bmap, dom);\n\t}\n\tsol = init(bmap, dom, !!empty, max);\n\tif (!sol)\n\t\tgoto error;\n\n\tcontext = sol->context;\n\tif (isl_basic_set_plain_is_empty(context->op->peek_basic_set(context)))\n\t\t/* nothing */;\n\telse if (isl_basic_map_plain_is_empty(bmap)) {\n\t\tif (sol->add_empty)\n\t\t\tsol->add_empty(sol,\n\t\t    isl_basic_set_copy(context->op->peek_basic_set(context)));\n\t} else {\n\t\ttab = tab_for_lexmin(bmap,\n\t\t\t\t    context->op->peek_basic_set(context), 1, max);\n\t\ttab = context->op->detect_nonnegative_parameters(context, tab);\n\t\tfind_solutions_main(sol, tab);\n\t}\n\tif (sol->error)\n\t\tgoto error;\n\n\tisl_basic_map_free(bmap);\n\treturn sol;\nerror:\n\tsol_free(sol);\n\tisl_basic_map_free(bmap);\n\treturn NULL;\n}\n\n/* Base case of isl_tab_basic_map_partial_lexopt, after removing\n * some obvious symmetries.\n *\n * We call basic_map_partial_lexopt_base_sol and extract the results.\n */\nstatic __isl_give isl_map *basic_map_partial_lexopt_base(\n\t__isl_take isl_basic_map *bmap, __isl_take isl_basic_set *dom,\n\t__isl_give isl_set **empty, int max)\n{\n\tisl_map *result = NULL;\n\tstruct isl_sol *sol;\n\tstruct isl_sol_map *sol_map;\n\n\tsol = basic_map_partial_lexopt_base_sol(bmap, dom, empty, max,\n\t\t\t\t\t\t&sol_map_init);\n\tif (!sol)\n\t\treturn NULL;\n\tsol_map = (struct isl_sol_map *) sol;\n\n\tresult = isl_map_copy(sol_map->map);\n\tif (empty)\n\t\t*empty = isl_set_copy(sol_map->empty);\n\tsol_free(&sol_map->sol);\n\treturn result;\n}\n\n/* Return a count of the number of occurrences of the \"n\" first\n * variables in the inequality constraints of \"bmap\".\n */\nstatic __isl_give int *count_occurrences(__isl_keep isl_basic_map *bmap,\n\tint n)\n{\n\tint i, j;\n\tisl_ctx *ctx;\n\tint *occurrences;\n\n\tif (!bmap)\n\t\treturn NULL;\n\tctx = isl_basic_map_get_ctx(bmap);\n\toccurrences = isl_calloc_array(ctx, int, n);\n\tif (!occurrences)\n\t\treturn NULL;\n\n\tfor (i = 0; i < bmap->n_ineq; ++i) {\n\t\tfor (j = 0; j < n; ++j) {\n\t\t\tif (!isl_int_is_zero(bmap->ineq[i][1 + j]))\n\t\t\t\toccurrences[j]++;\n\t\t}\n\t}\n\n\treturn occurrences;\n}\n\n/* Do all of the \"n\" variables with non-zero coefficients in \"c\"\n * occur in exactly a single constraint.\n * \"occurrences\" is an array of length \"n\" containing the number\n * of occurrences of each of the variables in the inequality constraints.\n */\nstatic int single_occurrence(int n, isl_int *c, int *occurrences)\n{\n\tint i;\n\n\tfor (i = 0; i < n; ++i) {\n\t\tif (isl_int_is_zero(c[i]))\n\t\t\tcontinue;\n\t\tif (occurrences[i] != 1)\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n/* Do all of the \"n\" initial variables that occur in inequality constraint\n * \"ineq\" of \"bmap\" only occur in that constraint?\n */\nstatic int all_single_occurrence(__isl_keep isl_basic_map *bmap, int ineq,\n\tint n)\n{\n\tint i, j;\n\n\tfor (i = 0; i < n; ++i) {\n\t\tif (isl_int_is_zero(bmap->ineq[ineq][1 + i]))\n\t\t\tcontinue;\n\t\tfor (j = 0; j < bmap->n_ineq; ++j) {\n\t\t\tif (j == ineq)\n\t\t\t\tcontinue;\n\t\t\tif (!isl_int_is_zero(bmap->ineq[j][1 + i]))\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 1;\n}\n\n/* Structure used during detection of parallel constraints.\n * n_in: number of \"input\" variables: isl_dim_param + isl_dim_in\n * n_out: number of \"output\" variables: isl_dim_out + isl_dim_div\n * val: the coefficients of the output variables\n */\nstruct isl_constraint_equal_info {\n\tunsigned n_in;\n\tunsigned n_out;\n\tisl_int *val;\n};\n\n/* Check whether the coefficients of the output variables\n * of the constraint in \"entry\" are equal to info->val.\n */\nstatic isl_bool constraint_equal(const void *entry, const void *val)\n{\n\tisl_int **row = (isl_int **)entry;\n\tconst struct isl_constraint_equal_info *info = val;\n\tint eq;\n\n\teq = isl_seq_eq((*row) + 1 + info->n_in, info->val, info->n_out);\n\treturn isl_bool_ok(eq);\n}\n\n/* Check whether \"bmap\" has a pair of constraints that have\n * the same coefficients for the output variables.\n * Note that the coefficients of the existentially quantified\n * variables need to be zero since the existentially quantified\n * of the result are usually not the same as those of the input.\n * Furthermore, check that each of the input variables that occur\n * in those constraints does not occur in any other constraint.\n * If so, return true and return the row indices of the two constraints\n * in *first and *second.\n */\nstatic isl_bool parallel_constraints(__isl_keep isl_basic_map *bmap,\n\tint *first, int *second)\n{\n\tint i;\n\tisl_ctx *ctx;\n\tint *occurrences = NULL;\n\tstruct isl_hash_table *table = NULL;\n\tstruct isl_hash_table_entry *entry;\n\tstruct isl_constraint_equal_info info;\n\tisl_size nparam, n_in, n_out, n_div;\n\n\tctx = isl_basic_map_get_ctx(bmap);\n\ttable = isl_hash_table_alloc(ctx, bmap->n_ineq);\n\tif (!table)\n\t\tgoto error;\n\n\tnparam = isl_basic_map_dim(bmap, isl_dim_param);\n\tn_in = isl_basic_map_dim(bmap, isl_dim_in);\n\tn_out = isl_basic_map_dim(bmap, isl_dim_out);\n\tn_div = isl_basic_map_dim(bmap, isl_dim_div);\n\tif (nparam < 0 || n_in < 0 || n_out < 0 || n_div < 0)\n\t\tgoto error;\n\tinfo.n_in = nparam + n_in;\n\toccurrences = count_occurrences(bmap, info.n_in);\n\tif (info.n_in && !occurrences)\n\t\tgoto error;\n\tinfo.n_out = n_out + n_div;\n\tfor (i = 0; i < bmap->n_ineq; ++i) {\n\t\tuint32_t hash;\n\n\t\tinfo.val = bmap->ineq[i] + 1 + info.n_in;\n\t\tif (isl_seq_first_non_zero(info.val, n_out) < 0)\n\t\t\tcontinue;\n\t\tif (isl_seq_first_non_zero(info.val + n_out, n_div) >= 0)\n\t\t\tcontinue;\n\t\tif (!single_occurrence(info.n_in, bmap->ineq[i] + 1,\n\t\t\t\t\toccurrences))\n\t\t\tcontinue;\n\t\thash = isl_seq_get_hash(info.val, info.n_out);\n\t\tentry = isl_hash_table_find(ctx, table, hash,\n\t\t\t\t\t    constraint_equal, &info, 1);\n\t\tif (!entry)\n\t\t\tgoto error;\n\t\tif (entry->data)\n\t\t\tbreak;\n\t\tentry->data = &bmap->ineq[i];\n\t}\n\n\tif (i < bmap->n_ineq) {\n\t\t*first = ((isl_int **)entry->data) - bmap->ineq; \n\t\t*second = i;\n\t}\n\n\tisl_hash_table_free(ctx, table);\n\tfree(occurrences);\n\n\treturn isl_bool_ok(i < bmap->n_ineq);\nerror:\n\tisl_hash_table_free(ctx, table);\n\tfree(occurrences);\n\treturn isl_bool_error;\n}\n\n/* Given a set of upper bounds in \"var\", add constraints to \"bset\"\n * that make the i-th bound smallest.\n *\n * In particular, if there are n bounds b_i, then add the constraints\n *\n *\tb_i <= b_j\tfor j > i\n *\tb_i <  b_j\tfor j < i\n */\nstatic __isl_give isl_basic_set *select_minimum(__isl_take isl_basic_set *bset,\n\t__isl_keep isl_mat *var, int i)\n{\n\tisl_ctx *ctx;\n\tint j, k;\n\n\tctx = isl_mat_get_ctx(var);\n\n\tfor (j = 0; j < var->n_row; ++j) {\n\t\tif (j == i)\n\t\t\tcontinue;\n\t\tk = isl_basic_set_alloc_inequality(bset);\n\t\tif (k < 0)\n\t\t\tgoto error;\n\t\tisl_seq_combine(bset->ineq[k], ctx->one, var->row[j],\n\t\t\t\tctx->negone, var->row[i], var->n_col);\n\t\tisl_int_set_si(bset->ineq[k][var->n_col], 0);\n\t\tif (j < i)\n\t\t\tisl_int_sub_ui(bset->ineq[k][0], bset->ineq[k][0], 1);\n\t}\n\n\tbset = isl_basic_set_finalize(bset);\n\n\treturn bset;\nerror:\n\tisl_basic_set_free(bset);\n\treturn NULL;\n}\n\n/* Given a set of upper bounds on the last \"input\" variable m,\n * construct a set that assigns the minimal upper bound to m, i.e.,\n * construct a set that divides the space into cells where one\n * of the upper bounds is smaller than all the others and assign\n * this upper bound to m.\n *\n * In particular, if there are n bounds b_i, then the result\n * consists of n basic sets, each one of the form\n *\n *\tm = b_i\n *\tb_i <= b_j\tfor j > i\n *\tb_i <  b_j\tfor j < i\n */\nstatic __isl_give isl_set *set_minimum(__isl_take isl_space *space,\n\t__isl_take isl_mat *var)\n{\n\tint i, k;\n\tisl_basic_set *bset = NULL;\n\tisl_set *set = NULL;\n\n\tif (!space || !var)\n\t\tgoto error;\n\n\tset = isl_set_alloc_space(isl_space_copy(space),\n\t\t\t\tvar->n_row, ISL_SET_DISJOINT);\n\n\tfor (i = 0; i < var->n_row; ++i) {\n\t\tbset = isl_basic_set_alloc_space(isl_space_copy(space), 0,\n\t\t\t\t\t       1, var->n_row - 1);\n\t\tk = isl_basic_set_alloc_equality(bset);\n\t\tif (k < 0)\n\t\t\tgoto error;\n\t\tisl_seq_cpy(bset->eq[k], var->row[i], var->n_col);\n\t\tisl_int_set_si(bset->eq[k][var->n_col], -1);\n\t\tbset = select_minimum(bset, var, i);\n\t\tset = isl_set_add_basic_set(set, bset);\n\t}\n\n\tisl_space_free(space);\n\tisl_mat_free(var);\n\treturn set;\nerror:\n\tisl_basic_set_free(bset);\n\tisl_set_free(set);\n\tisl_space_free(space);\n\tisl_mat_free(var);\n\treturn NULL;\n}\n\n/* Given that the last input variable of \"bmap\" represents the minimum\n * of the bounds in \"cst\", check whether we need to split the domain\n * based on which bound attains the minimum.\n *\n * A split is needed when the minimum appears in an integer division\n * or in an equality.  Otherwise, it is only needed if it appears in\n * an upper bound that is different from the upper bounds on which it\n * is defined.\n */\nstatic isl_bool need_split_basic_map(__isl_keep isl_basic_map *bmap,\n\t__isl_keep isl_mat *cst)\n{\n\tint i, j;\n\tisl_size total;\n\tunsigned pos;\n\n\tpos = cst->n_col - 1;\n\ttotal = isl_basic_map_dim(bmap, isl_dim_all);\n\tif (total < 0)\n\t\treturn isl_bool_error;\n\n\tfor (i = 0; i < bmap->n_div; ++i)\n\t\tif (!isl_int_is_zero(bmap->div[i][2 + pos]))\n\t\t\treturn isl_bool_true;\n\n\tfor (i = 0; i < bmap->n_eq; ++i)\n\t\tif (!isl_int_is_zero(bmap->eq[i][1 + pos]))\n\t\t\treturn isl_bool_true;\n\n\tfor (i = 0; i < bmap->n_ineq; ++i) {\n\t\tif (isl_int_is_nonneg(bmap->ineq[i][1 + pos]))\n\t\t\tcontinue;\n\t\tif (!isl_int_is_negone(bmap->ineq[i][1 + pos]))\n\t\t\treturn isl_bool_true;\n\t\tif (isl_seq_first_non_zero(bmap->ineq[i] + 1 + pos + 1,\n\t\t\t\t\t   total - pos - 1) >= 0)\n\t\t\treturn isl_bool_true;\n\n\t\tfor (j = 0; j < cst->n_row; ++j)\n\t\t\tif (isl_seq_eq(bmap->ineq[i], cst->row[j], cst->n_col))\n\t\t\t\tbreak;\n\t\tif (j >= cst->n_row)\n\t\t\treturn isl_bool_true;\n\t}\n\n\treturn isl_bool_false;\n}\n\n/* Given that the last set variable of \"bset\" represents the minimum\n * of the bounds in \"cst\", check whether we need to split the domain\n * based on which bound attains the minimum.\n *\n * We simply call need_split_basic_map here.  This is safe because\n * the position of the minimum is computed from \"cst\" and not\n * from \"bmap\".\n */\nstatic isl_bool need_split_basic_set(__isl_keep isl_basic_set *bset,\n\t__isl_keep isl_mat *cst)\n{\n\treturn need_split_basic_map(bset_to_bmap(bset), cst);\n}\n\n/* Given that the last set variable of \"set\" represents the minimum\n * of the bounds in \"cst\", check whether we need to split the domain\n * based on which bound attains the minimum.\n */\nstatic isl_bool need_split_set(__isl_keep isl_set *set, __isl_keep isl_mat *cst)\n{\n\tint i;\n\n\tfor (i = 0; i < set->n; ++i) {\n\t\tisl_bool split;\n\n\t\tsplit = need_split_basic_set(set->p[i], cst);\n\t\tif (split < 0 || split)\n\t\t\treturn split;\n\t}\n\n\treturn isl_bool_false;\n}\n\n/* Given a map of which the last input variable is the minimum\n * of the bounds in \"cst\", split each basic set in the set\n * in pieces where one of the bounds is (strictly) smaller than the others.\n * This subdivision is given in \"min_expr\".\n * The variable is subsequently projected out.\n *\n * We only do the split when it is needed.\n * For example if the last input variable m = min(a,b) and the only\n * constraints in the given basic set are lower bounds on m,\n * i.e., l <= m = min(a,b), then we can simply project out m\n * to obtain l <= a and l <= b, without having to split on whether\n * m is equal to a or b.\n */\nstatic __isl_give isl_map *split_domain(__isl_take isl_map *opt,\n\t__isl_take isl_set *min_expr, __isl_take isl_mat *cst)\n{\n\tisl_size n_in;\n\tint i;\n\tisl_space *space;\n\tisl_map *res;\n\n\tn_in = isl_map_dim(opt, isl_dim_in);\n\tif (n_in < 0 || !min_expr || !cst)\n\t\tgoto error;\n\n\tspace = isl_map_get_space(opt);\n\tspace = isl_space_drop_dims(space, isl_dim_in, n_in - 1, 1);\n\tres = isl_map_empty(space);\n\n\tfor (i = 0; i < opt->n; ++i) {\n\t\tisl_map *map;\n\t\tisl_bool split;\n\n\t\tmap = isl_map_from_basic_map(isl_basic_map_copy(opt->p[i]));\n\t\tsplit = need_split_basic_map(opt->p[i], cst);\n\t\tif (split < 0)\n\t\t\tmap = isl_map_free(map);\n\t\telse if (split)\n\t\t\tmap = isl_map_intersect_domain(map,\n\t\t\t\t\t\t       isl_set_copy(min_expr));\n\t\tmap = isl_map_remove_dims(map, isl_dim_in, n_in - 1, 1);\n\n\t\tres = isl_map_union_disjoint(res, map);\n\t}\n\n\tisl_map_free(opt);\n\tisl_set_free(min_expr);\n\tisl_mat_free(cst);\n\treturn res;\nerror:\n\tisl_map_free(opt);\n\tisl_set_free(min_expr);\n\tisl_mat_free(cst);\n\treturn NULL;\n}\n\n/* Given a set of which the last set variable is the minimum\n * of the bounds in \"cst\", split each basic set in the set\n * in pieces where one of the bounds is (strictly) smaller than the others.\n * This subdivision is given in \"min_expr\".\n * The variable is subsequently projected out.\n */\nstatic __isl_give isl_set *split(__isl_take isl_set *empty,\n\t__isl_take isl_set *min_expr, __isl_take isl_mat *cst)\n{\n\tisl_map *map;\n\n\tmap = isl_map_from_domain(empty);\n\tmap = split_domain(map, min_expr, cst);\n\tempty = isl_map_domain(map);\n\n\treturn empty;\n}\n\nstatic __isl_give isl_map *basic_map_partial_lexopt(\n\t__isl_take isl_basic_map *bmap, __isl_take isl_basic_set *dom,\n\t__isl_give isl_set **empty, int max);\n\n/* This function is called from basic_map_partial_lexopt_symm.\n * The last variable of \"bmap\" and \"dom\" corresponds to the minimum\n * of the bounds in \"cst\".  \"map_space\" is the space of the original\n * input relation (of basic_map_partial_lexopt_symm) and \"set_space\"\n * is the space of the original domain.\n *\n * We recursively call basic_map_partial_lexopt and then plug in\n * the definition of the minimum in the result.\n */\nstatic __isl_give isl_map *basic_map_partial_lexopt_symm_core(\n\t__isl_take isl_basic_map *bmap, __isl_take isl_basic_set *dom,\n\t__isl_give isl_set **empty, int max, __isl_take isl_mat *cst,\n\t__isl_take isl_space *map_space, __isl_take isl_space *set_space)\n{\n\tisl_map *opt;\n\tisl_set *min_expr;\n\n\tmin_expr = set_minimum(isl_basic_set_get_space(dom), isl_mat_copy(cst));\n\n\topt = basic_map_partial_lexopt(bmap, dom, empty, max);\n\n\tif (empty) {\n\t\t*empty = split(*empty,\n\t\t\t       isl_set_copy(min_expr), isl_mat_copy(cst));\n\t\t*empty = isl_set_reset_space(*empty, set_space);\n\t}\n\n\topt = split_domain(opt, min_expr, cst);\n\topt = isl_map_reset_space(opt, map_space);\n\n\treturn opt;\n}\n\n/* Extract a domain from \"bmap\" for the purpose of computing\n * a lexicographic optimum.\n *\n * This function is only called when the caller wants to compute a full\n * lexicographic optimum, i.e., without specifying a domain.  In this case,\n * the caller is not interested in the part of the domain space where\n * there is no solution and the domain can be initialized to those constraints\n * of \"bmap\" that only involve the parameters and the input dimensions.\n * This relieves the parametric programming engine from detecting those\n * inequalities and transferring them to the context.  More importantly,\n * it ensures that those inequalities are transferred first and not\n * intermixed with inequalities that actually split the domain.\n *\n * If the caller does not require the absence of existentially quantified\n * variables in the result (i.e., if ISL_OPT_QE is not set in \"flags\"),\n * then the actual domain of \"bmap\" can be used.  This ensures that\n * the domain does not need to be split at all just to separate out\n * pieces of the domain that do not have a solution from piece that do.\n * This domain cannot be used in general because it may involve\n * (unknown) existentially quantified variables which will then also\n * appear in the solution.\n */\nstatic __isl_give isl_basic_set *extract_domain(__isl_keep isl_basic_map *bmap,\n\tunsigned flags)\n{\n\tisl_size n_div;\n\tisl_size n_out;\n\n\tn_div = isl_basic_map_dim(bmap, isl_dim_div);\n\tn_out = isl_basic_map_dim(bmap, isl_dim_out);\n\tif (n_div < 0 || n_out < 0)\n\t\treturn NULL;\n\tbmap = isl_basic_map_copy(bmap);\n\tif (ISL_FL_ISSET(flags, ISL_OPT_QE)) {\n\t\tbmap = isl_basic_map_drop_constraints_involving_dims(bmap,\n\t\t\t\t\t\t\tisl_dim_div, 0, n_div);\n\t\tbmap = isl_basic_map_drop_constraints_involving_dims(bmap,\n\t\t\t\t\t\t\tisl_dim_out, 0, n_out);\n\t}\n\treturn isl_basic_map_domain(bmap);\n}\n\n#undef TYPE\n#define TYPE\tisl_map\n#undef SUFFIX\n#define SUFFIX\n#include \"isl_tab_lexopt_templ.c\"\n\n/* Extract the subsequence of the sample value of \"tab\"\n * starting at \"pos\" and of length \"len\".\n */\nstatic __isl_give isl_vec *extract_sample_sequence(struct isl_tab *tab,\n\tint pos, int len)\n{\n\tint i;\n\tisl_ctx *ctx;\n\tisl_vec *v;\n\n\tctx = isl_tab_get_ctx(tab);\n\tv = isl_vec_alloc(ctx, len);\n\tif (!v)\n\t\treturn NULL;\n\tfor (i = 0; i < len; ++i) {\n\t\tif (!tab->var[pos + i].is_row) {\n\t\t\tisl_int_set_si(v->el[i], 0);\n\t\t} else {\n\t\t\tint row;\n\n\t\t\trow = tab->var[pos + i].index;\n\t\t\tisl_int_divexact(v->el[i], tab->mat->row[row][1],\n\t\t\t\t\ttab->mat->row[row][0]);\n\t\t}\n\t}\n\n\treturn v;\n}\n\n/* Check if the sequence of variables starting at \"pos\"\n * represents a trivial solution according to \"trivial\".\n * That is, is the result of applying \"trivial\" to this sequence\n * equal to the zero vector?\n */\nstatic isl_bool region_is_trivial(struct isl_tab *tab, int pos,\n\t__isl_keep isl_mat *trivial)\n{\n\tisl_size n, len;\n\tisl_vec *v;\n\tisl_bool is_trivial;\n\n\tn = isl_mat_rows(trivial);\n\tif (n < 0)\n\t\treturn isl_bool_error;\n\n\tif (n == 0)\n\t\treturn isl_bool_false;\n\n\tlen = isl_mat_cols(trivial);\n\tif (len < 0)\n\t\treturn isl_bool_error;\n\tv = extract_sample_sequence(tab, pos, len);\n\tv = isl_mat_vec_product(isl_mat_copy(trivial), v);\n\tis_trivial = isl_vec_is_zero(v);\n\tisl_vec_free(v);\n\n\treturn is_trivial;\n}\n\n/* Global internal data for isl_tab_basic_set_non_trivial_lexmin.\n *\n * \"n_op\" is the number of initial coordinates to optimize,\n * as passed to isl_tab_basic_set_non_trivial_lexmin.\n * \"region\" is the \"n_region\"-sized array of regions passed\n * to isl_tab_basic_set_non_trivial_lexmin.\n *\n * \"tab\" is the tableau that corresponds to the ILP problem.\n * \"local\" is an array of local data structure, one for each\n * (potential) level of the backtracking procedure of\n * isl_tab_basic_set_non_trivial_lexmin.\n * \"v\" is a pre-allocated vector that can be used for adding\n * constraints to the tableau.\n *\n * \"sol\" contains the best solution found so far.\n * It is initialized to a vector of size zero.\n */\nstruct isl_lexmin_data {\n\tint n_op;\n\tint n_region;\n\tstruct isl_trivial_region *region;\n\n\tstruct isl_tab *tab;\n\tstruct isl_local_region *local;\n\tisl_vec *v;\n\n\tisl_vec *sol;\n};\n\n/* Return the index of the first trivial region, \"n_region\" if all regions\n * are non-trivial or -1 in case of error.\n */\nstatic int first_trivial_region(struct isl_lexmin_data *data)\n{\n\tint i;\n\n\tfor (i = 0; i < data->n_region; ++i) {\n\t\tisl_bool trivial;\n\t\ttrivial = region_is_trivial(data->tab, data->region[i].pos,\n\t\t\t\t\tdata->region[i].trivial);\n\t\tif (trivial < 0)\n\t\t\treturn -1;\n\t\tif (trivial)\n\t\t\treturn i;\n\t}\n\n\treturn data->n_region;\n}\n\n/* Check if the solution is optimal, i.e., whether the first\n * n_op entries are zero.\n */\nstatic int is_optimal(__isl_keep isl_vec *sol, int n_op)\n{\n\tint i;\n\n\tfor (i = 0; i < n_op; ++i)\n\t\tif (!isl_int_is_zero(sol->el[1 + i]))\n\t\t\treturn 0;\n\treturn 1;\n}\n\n/* Add constraints to \"tab\" that ensure that any solution is significantly\n * better than that represented by \"sol\".  That is, find the first\n * relevant (within first n_op) non-zero coefficient and force it (along\n * with all previous coefficients) to be zero.\n * If the solution is already optimal (all relevant coefficients are zero),\n * then just mark the table as empty.\n * \"n_zero\" is the number of coefficients that have been forced zero\n * by previous calls to this function at the same level.\n * Return the updated number of forced zero coefficients or -1 on error.\n *\n * This function assumes that at least 2 * (n_op - n_zero) more rows and\n * at least 2 * (n_op - n_zero) more elements in the constraint array\n * are available in the tableau.\n */\nstatic int force_better_solution(struct isl_tab *tab,\n\t__isl_keep isl_vec *sol, int n_op, int n_zero)\n{\n\tint i, n;\n\tisl_ctx *ctx;\n\tisl_vec *v = NULL;\n\n\tif (!sol)\n\t\treturn -1;\n\n\tfor (i = n_zero; i < n_op; ++i)\n\t\tif (!isl_int_is_zero(sol->el[1 + i]))\n\t\t\tbreak;\n\n\tif (i == n_op) {\n\t\tif (isl_tab_mark_empty(tab) < 0)\n\t\t\treturn -1;\n\t\treturn n_op;\n\t}\n\n\tctx = isl_vec_get_ctx(sol);\n\tv = isl_vec_alloc(ctx, 1 + tab->n_var);\n\tif (!v)\n\t\treturn -1;\n\n\tn = i + 1;\n\tfor (; i >= n_zero; --i) {\n\t\tv = isl_vec_clr(v);\n\t\tisl_int_set_si(v->el[1 + i], -1);\n\t\tif (add_lexmin_eq(tab, v->el) < 0)\n\t\t\tgoto error;\n\t}\n\n\tisl_vec_free(v);\n\treturn n;\nerror:\n\tisl_vec_free(v);\n\treturn -1;\n}\n\n/* Fix triviality direction \"dir\" of the given region to zero.\n *\n * This function assumes that at least two more rows and at least\n * two more elements in the constraint array are available in the tableau.\n */\nstatic isl_stat fix_zero(struct isl_tab *tab, struct isl_trivial_region *region,\n\tint dir, struct isl_lexmin_data *data)\n{\n\tisl_size len;\n\n\tdata->v = isl_vec_clr(data->v);\n\tif (!data->v)\n\t\treturn isl_stat_error;\n\tlen = isl_mat_cols(region->trivial);\n\tif (len < 0)\n\t\treturn isl_stat_error;\n\tisl_seq_cpy(data->v->el + 1 + region->pos, region->trivial->row[dir],\n\t\t    len);\n\tif (add_lexmin_eq(tab, data->v->el) < 0)\n\t\treturn isl_stat_error;\n\n\treturn isl_stat_ok;\n}\n\n/* This function selects case \"side\" for non-triviality region \"region\",\n * assuming all the equality constraints have been imposed already.\n * In particular, the triviality direction side/2 is made positive\n * if side is even and made negative if side is odd.\n *\n * This function assumes that at least one more row and at least\n * one more element in the constraint array are available in the tableau.\n */\nstatic struct isl_tab *pos_neg(struct isl_tab *tab,\n\tstruct isl_trivial_region *region,\n\tint side, struct isl_lexmin_data *data)\n{\n\tisl_size len;\n\n\tdata->v = isl_vec_clr(data->v);\n\tif (!data->v)\n\t\tgoto error;\n\tisl_int_set_si(data->v->el[0], -1);\n\tlen = isl_mat_cols(region->trivial);\n\tif (len < 0)\n\t\tgoto error;\n\tif (side % 2 == 0)\n\t\tisl_seq_cpy(data->v->el + 1 + region->pos,\n\t\t\t    region->trivial->row[side / 2], len);\n\telse\n\t\tisl_seq_neg(data->v->el + 1 + region->pos,\n\t\t\t    region->trivial->row[side / 2], len);\n\treturn add_lexmin_ineq(tab, data->v->el);\nerror:\n\tisl_tab_free(tab);\n\treturn NULL;\n}\n\n/* Local data at each level of the backtracking procedure of\n * isl_tab_basic_set_non_trivial_lexmin.\n *\n * \"update\" is set if a solution has been found in the current case\n * of this level, such that a better solution needs to be enforced\n * in the next case.\n * \"n_zero\" is the number of initial coordinates that have already\n * been forced to be zero at this level.\n * \"region\" is the non-triviality region considered at this level.\n * \"side\" is the index of the current case at this level.\n * \"n\" is the number of triviality directions.\n * \"snap\" is a snapshot of the tableau holding a state that needs\n * to be satisfied by all subsequent cases.\n */\nstruct isl_local_region {\n\tint update;\n\tint n_zero;\n\tint region;\n\tint side;\n\tint n;\n\tstruct isl_tab_undo *snap;\n};\n\n/* Initialize the global data structure \"data\" used while solving\n * the ILP problem \"bset\".\n */\nstatic isl_stat init_lexmin_data(struct isl_lexmin_data *data,\n\t__isl_keep isl_basic_set *bset)\n{\n\tisl_ctx *ctx;\n\n\tctx = isl_basic_set_get_ctx(bset);\n\n\tdata->tab = tab_for_lexmin(bset, NULL, 0, 0);\n\tif (!data->tab)\n\t\treturn isl_stat_error;\n\n\tdata->v = isl_vec_alloc(ctx, 1 + data->tab->n_var);\n\tif (!data->v)\n\t\treturn isl_stat_error;\n\tdata->local = isl_calloc_array(ctx, struct isl_local_region,\n\t\t\t\t\tdata->n_region);\n\tif (data->n_region && !data->local)\n\t\treturn isl_stat_error;\n\n\tdata->sol = isl_vec_alloc(ctx, 0);\n\n\treturn isl_stat_ok;\n}\n\n/* Mark all outer levels as requiring a better solution\n * in the next cases.\n */\nstatic void update_outer_levels(struct isl_lexmin_data *data, int level)\n{\n\tint i;\n\n\tfor (i = 0; i < level; ++i)\n\t\tdata->local[i].update = 1;\n}\n\n/* Initialize \"local\" to refer to region \"region\" and\n * to initiate processing at this level.\n */\nstatic isl_stat init_local_region(struct isl_local_region *local, int region,\n\tstruct isl_lexmin_data *data)\n{\n\tisl_size n = isl_mat_rows(data->region[region].trivial);\n\n\tif (n < 0)\n\t\treturn isl_stat_error;\n\tlocal->n = n;\n\tlocal->region = region;\n\tlocal->side = 0;\n\tlocal->update = 0;\n\tlocal->n_zero = 0;\n\n\treturn isl_stat_ok;\n}\n\n/* What to do next after entering a level of the backtracking procedure.\n *\n * error: some error has occurred; abort\n * done: an optimal solution has been found; stop search\n * backtrack: backtrack to the previous level\n * handle: add the constraints for the current level and\n * \tmove to the next level\n */\nenum isl_next {\n\tisl_next_error = -1,\n\tisl_next_done,\n\tisl_next_backtrack,\n\tisl_next_handle,\n};\n\n/* Have all cases of the current region been considered?\n * If there are n directions, then there are 2n cases.\n *\n * The constraints in the current tableau are imposed\n * in all subsequent cases.  This means that if the current\n * tableau is empty, then none of those cases should be considered\n * anymore and all cases have effectively been considered.\n */\nstatic int finished_all_cases(struct isl_local_region *local,\n\tstruct isl_lexmin_data *data)\n{\n\tif (data->tab->empty)\n\t\treturn 1;\n\treturn local->side >= 2 * local->n;\n}\n\n/* Enter level \"level\" of the backtracking search and figure out\n * what to do next.  \"init\" is set if the level was entered\n * from a higher level and needs to be initialized.\n * Otherwise, the level is entered as a result of backtracking and\n * the tableau needs to be restored to a position that can\n * be used for the next case at this level.\n * The snapshot is assumed to have been saved in the previous case,\n * before the constraints specific to that case were added.\n *\n * In the initialization case, the local region is initialized\n * to point to the first violated region.\n * If the constraints of all regions are satisfied by the current\n * sample of the tableau, then tell the caller to continue looking\n * for a better solution or to stop searching if an optimal solution\n * has been found.\n *\n * If the tableau is empty or if all cases at the current level\n * have been considered, then the caller needs to backtrack as well.\n */\nstatic enum isl_next enter_level(int level, int init,\n\tstruct isl_lexmin_data *data)\n{\n\tstruct isl_local_region *local = &data->local[level];\n\n\tif (init) {\n\t\tint r;\n\n\t\tdata->tab = cut_to_integer_lexmin(data->tab, CUT_ONE);\n\t\tif (!data->tab)\n\t\t\treturn isl_next_error;\n\t\tif (data->tab->empty)\n\t\t\treturn isl_next_backtrack;\n\t\tr = first_trivial_region(data);\n\t\tif (r < 0)\n\t\t\treturn isl_next_error;\n\t\tif (r == data->n_region) {\n\t\t\tupdate_outer_levels(data, level);\n\t\t\tisl_vec_free(data->sol);\n\t\t\tdata->sol = isl_tab_get_sample_value(data->tab);\n\t\t\tif (!data->sol)\n\t\t\t\treturn isl_next_error;\n\t\t\tif (is_optimal(data->sol, data->n_op))\n\t\t\t\treturn isl_next_done;\n\t\t\treturn isl_next_backtrack;\n\t\t}\n\t\tif (level >= data->n_region)\n\t\t\tisl_die(isl_vec_get_ctx(data->v), isl_error_internal,\n\t\t\t\t\"nesting level too deep\",\n\t\t\t\treturn isl_next_error);\n\t\tif (init_local_region(local, r, data) < 0)\n\t\t\treturn isl_next_error;\n\t\tif (isl_tab_extend_cons(data->tab,\n\t\t\t\t    2 * local->n + 2 * data->n_op) < 0)\n\t\t\treturn isl_next_error;\n\t} else {\n\t\tif (isl_tab_rollback(data->tab, local->snap) < 0)\n\t\t\treturn isl_next_error;\n\t}\n\n\tif (finished_all_cases(local, data))\n\t\treturn isl_next_backtrack;\n\treturn isl_next_handle;\n}\n\n/* If a solution has been found in the previous case at this level\n * (marked by local->update being set), then add constraints\n * that enforce a better solution in the present and all following cases.\n * The constraints only need to be imposed once because they are\n * included in the snapshot (taken in pick_side) that will be used in\n * subsequent cases.\n */\nstatic isl_stat better_next_side(struct isl_local_region *local,\n\tstruct isl_lexmin_data *data)\n{\n\tif (!local->update)\n\t\treturn isl_stat_ok;\n\n\tlocal->n_zero = force_better_solution(data->tab,\n\t\t\t\tdata->sol, data->n_op, local->n_zero);\n\tif (local->n_zero < 0)\n\t\treturn isl_stat_error;\n\n\tlocal->update = 0;\n\n\treturn isl_stat_ok;\n}\n\n/* Add constraints to data->tab that select the current case (local->side)\n * at the current level.\n *\n * If the linear combinations v should not be zero, then the cases are\n *\tv_0 >= 1\n *\tv_0 <= -1\n *\tv_0 = 0 and v_1 >= 1\n *\tv_0 = 0 and v_1 <= -1\n *\tv_0 = 0 and v_1 = 0 and v_2 >= 1\n *\tv_0 = 0 and v_1 = 0 and v_2 <= -1\n *\t...\n * in this order.\n *\n * A snapshot is taken after the equality constraint (if any) has been added\n * such that the next case can start off from this position.\n * The rollback to this position is performed in enter_level.\n */\nstatic isl_stat pick_side(struct isl_local_region *local,\n\tstruct isl_lexmin_data *data)\n{\n\tstruct isl_trivial_region *region;\n\tint side, base;\n\n\tregion = &data->region[local->region];\n\tside = local->side;\n\tbase = 2 * (side/2);\n\n\tif (side == base && base >= 2 &&\n\t    fix_zero(data->tab, region, base / 2 - 1, data) < 0)\n\t\treturn isl_stat_error;\n\n\tlocal->snap = isl_tab_snap(data->tab);\n\tif (isl_tab_push_basis(data->tab) < 0)\n\t\treturn isl_stat_error;\n\n\tdata->tab = pos_neg(data->tab, region, side, data);\n\tif (!data->tab)\n\t\treturn isl_stat_error;\n\treturn isl_stat_ok;\n}\n\n/* Free the memory associated to \"data\".\n */\nstatic void clear_lexmin_data(struct isl_lexmin_data *data)\n{\n\tfree(data->local);\n\tisl_vec_free(data->v);\n\tisl_tab_free(data->tab);\n}\n\n/* Return the lexicographically smallest non-trivial solution of the\n * given ILP problem.\n *\n * All variables are assumed to be non-negative.\n *\n * n_op is the number of initial coordinates to optimize.\n * That is, once a solution has been found, we will only continue looking\n * for solutions that result in significantly better values for those\n * initial coordinates.  That is, we only continue looking for solutions\n * that increase the number of initial zeros in this sequence.\n *\n * A solution is non-trivial, if it is non-trivial on each of the\n * specified regions.  Each region represents a sequence of\n * triviality directions on a sequence of variables that starts\n * at a given position.  A solution is non-trivial on such a region if\n * at least one of the triviality directions is non-zero\n * on that sequence of variables.\n *\n * Whenever a conflict is encountered, all constraints involved are\n * reported to the caller through a call to \"conflict\".\n *\n * We perform a simple branch-and-bound backtracking search.\n * Each level in the search represents an initially trivial region\n * that is forced to be non-trivial.\n * At each level we consider 2 * n cases, where n\n * is the number of triviality directions.\n * In terms of those n directions v_i, we consider the cases\n *\tv_0 >= 1\n *\tv_0 <= -1\n *\tv_0 = 0 and v_1 >= 1\n *\tv_0 = 0 and v_1 <= -1\n *\tv_0 = 0 and v_1 = 0 and v_2 >= 1\n *\tv_0 = 0 and v_1 = 0 and v_2 <= -1\n *\t...\n * in this order.\n */\n__isl_give isl_vec *isl_tab_basic_set_non_trivial_lexmin(\n\t__isl_take isl_basic_set *bset, int n_op, int n_region,\n\tstruct isl_trivial_region *region,\n\tint (*conflict)(int con, void *user), void *user)\n{\n\tstruct isl_lexmin_data data = { n_op, n_region, region };\n\tint level, init;\n\n\tif (!bset)\n\t\treturn NULL;\n\n\tif (init_lexmin_data(&data, bset) < 0)\n\t\tgoto error;\n\tdata.tab->conflict = conflict;\n\tdata.tab->conflict_user = user;\n\n\tlevel = 0;\n\tinit = 1;\n\n\twhile (level >= 0) {\n\t\tenum isl_next next;\n\t\tstruct isl_local_region *local = &data.local[level];\n\n\t\tnext = enter_level(level, init, &data);\n\t\tif (next < 0)\n\t\t\tgoto error;\n\t\tif (next == isl_next_done)\n\t\t\tbreak;\n\t\tif (next == isl_next_backtrack) {\n\t\t\tlevel--;\n\t\t\tinit = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (better_next_side(local, &data) < 0)\n\t\t\tgoto error;\n\t\tif (pick_side(local, &data) < 0)\n\t\t\tgoto error;\n\n\t\tlocal->side++;\n\t\tlevel++;\n\t\tinit = 1;\n\t}\n\n\tclear_lexmin_data(&data);\n\tisl_basic_set_free(bset);\n\n\treturn data.sol;\nerror:\n\tclear_lexmin_data(&data);\n\tisl_basic_set_free(bset);\n\tisl_vec_free(data.sol);\n\treturn NULL;\n}\n\n/* Wrapper for a tableau that is used for computing\n * the lexicographically smallest rational point of a non-negative set.\n * This point is represented by the sample value of \"tab\",\n * unless \"tab\" is empty.\n */\nstruct isl_tab_lexmin {\n\tisl_ctx *ctx;\n\tstruct isl_tab *tab;\n};\n\n/* Free \"tl\" and return NULL.\n */\n__isl_null isl_tab_lexmin *isl_tab_lexmin_free(__isl_take isl_tab_lexmin *tl)\n{\n\tif (!tl)\n\t\treturn NULL;\n\tisl_ctx_deref(tl->ctx);\n\tisl_tab_free(tl->tab);\n\tfree(tl);\n\n\treturn NULL;\n}\n\n/* Construct an isl_tab_lexmin for computing\n * the lexicographically smallest rational point in \"bset\",\n * assuming that all variables are non-negative.\n */\n__isl_give isl_tab_lexmin *isl_tab_lexmin_from_basic_set(\n\t__isl_take isl_basic_set *bset)\n{\n\tisl_ctx *ctx;\n\tisl_tab_lexmin *tl;\n\n\tif (!bset)\n\t\treturn NULL;\n\n\tctx = isl_basic_set_get_ctx(bset);\n\ttl = isl_calloc_type(ctx, struct isl_tab_lexmin);\n\tif (!tl)\n\t\tgoto error;\n\ttl->ctx = ctx;\n\tisl_ctx_ref(ctx);\n\ttl->tab = tab_for_lexmin(bset, NULL, 0, 0);\n\tisl_basic_set_free(bset);\n\tif (!tl->tab)\n\t\treturn isl_tab_lexmin_free(tl);\n\treturn tl;\nerror:\n\tisl_basic_set_free(bset);\n\tisl_tab_lexmin_free(tl);\n\treturn NULL;\n}\n\n/* Return the dimension of the set represented by \"tl\".\n */\nint isl_tab_lexmin_dim(__isl_keep isl_tab_lexmin *tl)\n{\n\treturn tl ? tl->tab->n_var : -1;\n}\n\n/* Add the equality with coefficients \"eq\" to \"tl\", updating the optimal\n * solution if needed.\n * The equality is added as two opposite inequality constraints.\n */\n__isl_give isl_tab_lexmin *isl_tab_lexmin_add_eq(__isl_take isl_tab_lexmin *tl,\n\tisl_int *eq)\n{\n\tunsigned n_var;\n\n\tif (!tl || !eq)\n\t\treturn isl_tab_lexmin_free(tl);\n\n\tif (isl_tab_extend_cons(tl->tab, 2) < 0)\n\t\treturn isl_tab_lexmin_free(tl);\n\tn_var = tl->tab->n_var;\n\tisl_seq_neg(eq, eq, 1 + n_var);\n\ttl->tab = add_lexmin_ineq(tl->tab, eq);\n\tisl_seq_neg(eq, eq, 1 + n_var);\n\ttl->tab = add_lexmin_ineq(tl->tab, eq);\n\n\tif (!tl->tab)\n\t\treturn isl_tab_lexmin_free(tl);\n\n\treturn tl;\n}\n\n/* Add cuts to \"tl\" until the sample value reaches an integer value or\n * until the result becomes empty.\n */\n__isl_give isl_tab_lexmin *isl_tab_lexmin_cut_to_integer(\n\t__isl_take isl_tab_lexmin *tl)\n{\n\tif (!tl)\n\t\treturn NULL;\n\ttl->tab = cut_to_integer_lexmin(tl->tab, CUT_ONE);\n\tif (!tl->tab)\n\t\treturn isl_tab_lexmin_free(tl);\n\treturn tl;\n}\n\n/* Return the lexicographically smallest rational point in the basic set\n * from which \"tl\" was constructed.\n * If the original input was empty, then return a zero-length vector.\n */\n__isl_give isl_vec *isl_tab_lexmin_get_solution(__isl_keep isl_tab_lexmin *tl)\n{\n\tif (!tl)\n\t\treturn NULL;\n\tif (tl->tab->empty)\n\t\treturn isl_vec_alloc(tl->ctx, 0);\n\telse\n\t\treturn isl_tab_get_sample_value(tl->tab);\n}\n\nstruct isl_sol_pma {\n\tstruct isl_sol\tsol;\n\tisl_pw_multi_aff *pma;\n\tisl_set *empty;\n};\n\nstatic void sol_pma_free(struct isl_sol *sol)\n{\n\tstruct isl_sol_pma *sol_pma = (struct isl_sol_pma *) sol;\n\tisl_pw_multi_aff_free(sol_pma->pma);\n\tisl_set_free(sol_pma->empty);\n}\n\n/* This function is called for parts of the context where there is\n * no solution, with \"bset\" corresponding to the context tableau.\n * Simply add the basic set to the set \"empty\".\n */\nstatic void sol_pma_add_empty(struct isl_sol_pma *sol,\n\t__isl_take isl_basic_set *bset)\n{\n\tif (!bset || !sol->empty)\n\t\tgoto error;\n\n\tsol->empty = isl_set_grow(sol->empty, 1);\n\tbset = isl_basic_set_simplify(bset);\n\tbset = isl_basic_set_finalize(bset);\n\tsol->empty = isl_set_add_basic_set(sol->empty, bset);\n\tif (!sol->empty)\n\t\tsol->sol.error = 1;\n\treturn;\nerror:\n\tisl_basic_set_free(bset);\n\tsol->sol.error = 1;\n}\n\n/* Given a basic set \"dom\" that represents the context and a tuple of\n * affine expressions \"maff\" defined over this domain, construct\n * an isl_pw_multi_aff with a single cell corresponding to \"dom\" and\n * the affine expressions in \"maff\".\n */\nstatic void sol_pma_add(struct isl_sol_pma *sol,\n\t__isl_take isl_basic_set *dom, __isl_take isl_multi_aff *maff)\n{\n\tisl_pw_multi_aff *pma;\n\n\tdom = isl_basic_set_simplify(dom);\n\tdom = isl_basic_set_finalize(dom);\n\tpma = isl_pw_multi_aff_alloc(isl_set_from_basic_set(dom), maff);\n\tsol->pma = isl_pw_multi_aff_add_disjoint(sol->pma, pma);\n\tif (!sol->pma)\n\t\tsol->sol.error = 1;\n}\n\nstatic void sol_pma_add_empty_wrap(struct isl_sol *sol,\n\t__isl_take isl_basic_set *bset)\n{\n\tsol_pma_add_empty((struct isl_sol_pma *)sol, bset);\n}\n\nstatic void sol_pma_add_wrap(struct isl_sol *sol,\n\t__isl_take isl_basic_set *dom, __isl_take isl_multi_aff *ma)\n{\n\tsol_pma_add((struct isl_sol_pma *)sol, dom, ma);\n}\n\n/* Construct an isl_sol_pma structure for accumulating the solution.\n * If track_empty is set, then we also keep track of the parts\n * of the context where there is no solution.\n * If max is set, then we are solving a maximization, rather than\n * a minimization problem, which means that the variables in the\n * tableau have value \"M - x\" rather than \"M + x\".\n */\nstatic struct isl_sol *sol_pma_init(__isl_keep isl_basic_map *bmap,\n\t__isl_take isl_basic_set *dom, int track_empty, int max)\n{\n\tstruct isl_sol_pma *sol_pma = NULL;\n\tisl_space *space;\n\n\tif (!bmap)\n\t\tgoto error;\n\n\tsol_pma = isl_calloc_type(bmap->ctx, struct isl_sol_pma);\n\tif (!sol_pma)\n\t\tgoto error;\n\n\tsol_pma->sol.free = &sol_pma_free;\n\tif (sol_init(&sol_pma->sol, bmap, dom, max) < 0)\n\t\tgoto error;\n\tsol_pma->sol.add = &sol_pma_add_wrap;\n\tsol_pma->sol.add_empty = track_empty ? &sol_pma_add_empty_wrap : NULL;\n\tspace = isl_space_copy(sol_pma->sol.space);\n\tsol_pma->pma = isl_pw_multi_aff_empty(space);\n\tif (!sol_pma->pma)\n\t\tgoto error;\n\n\tif (track_empty) {\n\t\tsol_pma->empty = isl_set_alloc_space(isl_basic_set_get_space(dom),\n\t\t\t\t\t\t\t1, ISL_SET_DISJOINT);\n\t\tif (!sol_pma->empty)\n\t\t\tgoto error;\n\t}\n\n\tisl_basic_set_free(dom);\n\treturn &sol_pma->sol;\nerror:\n\tisl_basic_set_free(dom);\n\tsol_free(&sol_pma->sol);\n\treturn NULL;\n}\n\n/* Base case of isl_tab_basic_map_partial_lexopt, after removing\n * some obvious symmetries.\n *\n * We call basic_map_partial_lexopt_base_sol and extract the results.\n */\nstatic __isl_give isl_pw_multi_aff *basic_map_partial_lexopt_base_pw_multi_aff(\n\t__isl_take isl_basic_map *bmap, __isl_take isl_basic_set *dom,\n\t__isl_give isl_set **empty, int max)\n{\n\tisl_pw_multi_aff *result = NULL;\n\tstruct isl_sol *sol;\n\tstruct isl_sol_pma *sol_pma;\n\n\tsol = basic_map_partial_lexopt_base_sol(bmap, dom, empty, max,\n\t\t\t\t\t\t&sol_pma_init);\n\tif (!sol)\n\t\treturn NULL;\n\tsol_pma = (struct isl_sol_pma *) sol;\n\n\tresult = isl_pw_multi_aff_copy(sol_pma->pma);\n\tif (empty)\n\t\t*empty = isl_set_copy(sol_pma->empty);\n\tsol_free(&sol_pma->sol);\n\treturn result;\n}\n\n/* Given that the last input variable of \"maff\" represents the minimum\n * of some bounds, check whether we need to plug in the expression\n * of the minimum.\n *\n * In particular, check if the last input variable appears in any\n * of the expressions in \"maff\".\n */\nstatic isl_bool need_substitution(__isl_keep isl_multi_aff *maff)\n{\n\tint i;\n\tisl_size n_in;\n\tunsigned pos;\n\n\tn_in = isl_multi_aff_dim(maff, isl_dim_in);\n\tif (n_in < 0)\n\t\treturn isl_bool_error;\n\tpos = n_in - 1;\n\n\tfor (i = 0; i < maff->n; ++i) {\n\t\tisl_bool involves;\n\n\t\tinvolves = isl_aff_involves_dims(maff->u.p[i],\n\t\t\t\t\t\tisl_dim_in, pos, 1);\n\t\tif (involves < 0 || involves)\n\t\t\treturn involves;\n\t}\n\n\treturn isl_bool_false;\n}\n\n/* Given a set of upper bounds on the last \"input\" variable m,\n * construct a piecewise affine expression that selects\n * the minimal upper bound to m, i.e.,\n * divide the space into cells where one\n * of the upper bounds is smaller than all the others and select\n * this upper bound on that cell.\n *\n * In particular, if there are n bounds b_i, then the result\n * consists of n cell, each one of the form\n *\n *\tb_i <= b_j\tfor j > i\n *\tb_i <  b_j\tfor j < i\n *\n * The affine expression on this cell is\n *\n *\tb_i\n */\nstatic __isl_give isl_pw_aff *set_minimum_pa(__isl_take isl_space *space,\n\t__isl_take isl_mat *var)\n{\n\tint i;\n\tisl_aff *aff = NULL;\n\tisl_basic_set *bset = NULL;\n\tisl_pw_aff *paff = NULL;\n\tisl_space *pw_space;\n\tisl_local_space *ls = NULL;\n\n\tif (!space || !var)\n\t\tgoto error;\n\n\tls = isl_local_space_from_space(isl_space_copy(space));\n\tpw_space = isl_space_copy(space);\n\tpw_space = isl_space_from_domain(pw_space);\n\tpw_space = isl_space_add_dims(pw_space, isl_dim_out, 1);\n\tpaff = isl_pw_aff_alloc_size(pw_space, var->n_row);\n\n\tfor (i = 0; i < var->n_row; ++i) {\n\t\tisl_pw_aff *paff_i;\n\n\t\taff = isl_aff_alloc(isl_local_space_copy(ls));\n\t\tbset = isl_basic_set_alloc_space(isl_space_copy(space), 0,\n\t\t\t\t\t       0, var->n_row - 1);\n\t\tif (!aff || !bset)\n\t\t\tgoto error;\n\t\tisl_int_set_si(aff->v->el[0], 1);\n\t\tisl_seq_cpy(aff->v->el + 1, var->row[i], var->n_col);\n\t\tisl_int_set_si(aff->v->el[1 + var->n_col], 0);\n\t\tbset = select_minimum(bset, var, i);\n\t\tpaff_i = isl_pw_aff_alloc(isl_set_from_basic_set(bset), aff);\n\t\tpaff = isl_pw_aff_add_disjoint(paff, paff_i);\n\t}\n\n\tisl_local_space_free(ls);\n\tisl_space_free(space);\n\tisl_mat_free(var);\n\treturn paff;\nerror:\n\tisl_aff_free(aff);\n\tisl_basic_set_free(bset);\n\tisl_pw_aff_free(paff);\n\tisl_local_space_free(ls);\n\tisl_space_free(space);\n\tisl_mat_free(var);\n\treturn NULL;\n}\n\n/* Given a piecewise multi-affine expression of which the last input variable\n * is the minimum of the bounds in \"cst\", plug in the value of the minimum.\n * This minimum expression is given in \"min_expr_pa\".\n * The set \"min_expr\" contains the same information, but in the form of a set.\n * The variable is subsequently projected out.\n *\n * The implementation is similar to those of \"split\" and \"split_domain\".\n * If the variable appears in a given expression, then minimum expression\n * is plugged in.  Otherwise, if the variable appears in the constraints\n * and a split is required, then the domain is split.  Otherwise, no split\n * is performed.\n */\nstatic __isl_give isl_pw_multi_aff *split_domain_pma(\n\t__isl_take isl_pw_multi_aff *opt, __isl_take isl_pw_aff *min_expr_pa,\n\t__isl_take isl_set *min_expr, __isl_take isl_mat *cst)\n{\n\tisl_size n_in;\n\tint i;\n\tisl_space *space;\n\tisl_pw_multi_aff *res;\n\n\tif (!opt || !min_expr || !cst)\n\t\tgoto error;\n\n\tn_in = isl_pw_multi_aff_dim(opt, isl_dim_in);\n\tif (n_in < 0)\n\t\tgoto error;\n\tspace = isl_pw_multi_aff_get_space(opt);\n\tspace = isl_space_drop_dims(space, isl_dim_in, n_in - 1, 1);\n\tres = isl_pw_multi_aff_empty(space);\n\n\tfor (i = 0; i < opt->n; ++i) {\n\t\tisl_bool subs;\n\t\tisl_pw_multi_aff *pma;\n\n\t\tpma = isl_pw_multi_aff_alloc(isl_set_copy(opt->p[i].set),\n\t\t\t\t\t isl_multi_aff_copy(opt->p[i].maff));\n\t\tsubs = need_substitution(opt->p[i].maff);\n\t\tif (subs < 0) {\n\t\t\tpma = isl_pw_multi_aff_free(pma);\n\t\t} else if (subs) {\n\t\t\tpma = isl_pw_multi_aff_substitute(pma,\n\t\t\t\t\tisl_dim_in, n_in - 1, min_expr_pa);\n\t\t} else {\n\t\t\tisl_bool split;\n\t\t\tsplit = need_split_set(opt->p[i].set, cst);\n\t\t\tif (split < 0)\n\t\t\t\tpma = isl_pw_multi_aff_free(pma);\n\t\t\telse if (split)\n\t\t\t\tpma = isl_pw_multi_aff_intersect_domain(pma,\n\t\t\t\t\t\t       isl_set_copy(min_expr));\n\t\t}\n\t\tpma = isl_pw_multi_aff_project_out(pma,\n\t\t\t\t\t\t    isl_dim_in, n_in - 1, 1);\n\n\t\tres = isl_pw_multi_aff_add_disjoint(res, pma);\n\t}\n\n\tisl_pw_multi_aff_free(opt);\n\tisl_pw_aff_free(min_expr_pa);\n\tisl_set_free(min_expr);\n\tisl_mat_free(cst);\n\treturn res;\nerror:\n\tisl_pw_multi_aff_free(opt);\n\tisl_pw_aff_free(min_expr_pa);\n\tisl_set_free(min_expr);\n\tisl_mat_free(cst);\n\treturn NULL;\n}\n\nstatic __isl_give isl_pw_multi_aff *basic_map_partial_lexopt_pw_multi_aff(\n\t__isl_take isl_basic_map *bmap, __isl_take isl_basic_set *dom,\n\t__isl_give isl_set **empty, int max);\n\n/* This function is called from basic_map_partial_lexopt_symm.\n * The last variable of \"bmap\" and \"dom\" corresponds to the minimum\n * of the bounds in \"cst\".  \"map_space\" is the space of the original\n * input relation (of basic_map_partial_lexopt_symm) and \"set_space\"\n * is the space of the original domain.\n *\n * We recursively call basic_map_partial_lexopt and then plug in\n * the definition of the minimum in the result.\n */\nstatic __isl_give isl_pw_multi_aff *\nbasic_map_partial_lexopt_symm_core_pw_multi_aff(\n\t__isl_take isl_basic_map *bmap, __isl_take isl_basic_set *dom,\n\t__isl_give isl_set **empty, int max, __isl_take isl_mat *cst,\n\t__isl_take isl_space *map_space, __isl_take isl_space *set_space)\n{\n\tisl_pw_multi_aff *opt;\n\tisl_pw_aff *min_expr_pa;\n\tisl_set *min_expr;\n\n\tmin_expr = set_minimum(isl_basic_set_get_space(dom), isl_mat_copy(cst));\n\tmin_expr_pa = set_minimum_pa(isl_basic_set_get_space(dom),\n\t\t\t\t\tisl_mat_copy(cst));\n\n\topt = basic_map_partial_lexopt_pw_multi_aff(bmap, dom, empty, max);\n\n\tif (empty) {\n\t\t*empty = split(*empty,\n\t\t\t       isl_set_copy(min_expr), isl_mat_copy(cst));\n\t\t*empty = isl_set_reset_space(*empty, set_space);\n\t}\n\n\topt = split_domain_pma(opt, min_expr_pa, min_expr, cst);\n\topt = isl_pw_multi_aff_reset_space(opt, map_space);\n\n\treturn opt;\n}\n\n#undef TYPE\n#define TYPE\tisl_pw_multi_aff\n#undef SUFFIX\n#define SUFFIX\t_pw_multi_aff\n#include \"isl_tab_lexopt_templ.c\"\n"}}, "reports": [{"events": [{"location": {"col": 32, "file": 1, "line": 82}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_lexopt_templ.c", "reportHash": "3e9820ff42f88e3d80e984d521e7d5bc", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 288}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "02151ca098466bc1f52a399113a7b6ef", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 17, "file": 2, "line": 728}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "989f2790f739b0b222c6f852dd861e7d", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 17, "file": 2, "line": 736}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "7532300e740038fdfd5f36b54a12d12d", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 848}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "fb3541b11c683533b6027ed37f2d8c7f", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 856}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "0ae6890ea3026f00aaa40cee30cc8552", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 885}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "cf439cc62ec43ce289c4b6afc756fdce", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 15, "file": 2, "line": 886}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "78b94577e8ad841330739ec04fcff66d", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 1096}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "fb3541b11c683533b6027ed37f2d8c7f", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 1108}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "0ae6890ea3026f00aaa40cee30cc8552", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 1145}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "fb3541b11c683533b6027ed37f2d8c7f", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 1157}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "0ae6890ea3026f00aaa40cee30cc8552", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 27, "file": 2, "line": 1195}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "4e8a69585cc9f27591e694f8a2b6ef48", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 12, "file": 2, "line": 1240}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "ac065359937e7a6344826157c779e02e", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 12, "file": 2, "line": 1242}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "040f365966d3603b1c7149bc27bb12a5", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 26, "file": 2, "line": 1278}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "7852722d98e52df723240953e43e6974", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 11, "file": 2, "line": 1285}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "a56070a9c7a2626397271ba43208cbba", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 36, "file": 2, "line": 1311}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "4a50b9696834b7f83bb1b3d0d1dd5f3d", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 35, "file": 2, "line": 1320}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "4090af74f94cc8c495b729a1710a6b3c", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 30, "file": 2, "line": 1348}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "c484e4f61a1efd26dda1fb158c5c5832", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 32, "file": 2, "line": 1351}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "9cf02dacfe88ae42d167e915b1d4af94", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 11, "file": 2, "line": 1366}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "3322c7d4718ee99b74e6de3b96546aa8", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 26, "file": 2, "line": 1398}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "7852722d98e52df723240953e43e6974", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 11, "file": 2, "line": 1430}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "559916594c83cf6c30dc6b280c7d22bd", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 52, "file": 2, "line": 1471}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "9f82cb1e92f30aad38e3d67226ca4a35", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 11, "file": 2, "line": 1476}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "92236f4267bd411085077f0dbf869c64", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 26, "file": 2, "line": 1481}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "80407b6954e71e6321b974d073f818a3", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 30, "file": 2, "line": 1555}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "c484e4f61a1efd26dda1fb158c5c5832", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 1702}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "fb3541b11c683533b6027ed37f2d8c7f", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 1711}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "0ae6890ea3026f00aaa40cee30cc8552", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 26, "file": 2, "line": 1729}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "80407b6954e71e6321b974d073f818a3", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 13, "file": 2, "line": 1766}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "3f8fbd1cef7ce713feac6d8d99bdbc26", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 1845}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "fbad6ba50273d33a796c3c929fd0bb3a", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 29, "file": 2, "line": 1930}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "081f61f4e63b80cd5f40dac38a90f734", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 1961}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "79d6478746034492633670d70b53ab58", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 29, "file": 2, "line": 2029}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "081f61f4e63b80cd5f40dac38a90f734", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 11, "file": 2, "line": 2039}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "8443628acc6c1bec5339c6ec5b076d39", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 29, "file": 2, "line": 2065}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "3d3fd865ce08649705255ea4d9c1d7b0", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 8, "file": 2, "line": 2164}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "f8e2ab045950dd78bae975adca428088", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 2231}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "fb3541b11c683533b6027ed37f2d8c7f", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 2240}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "0ae6890ea3026f00aaa40cee30cc8552", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 2249}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "e2a577f3b12e3898d222008bfdadaf62", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 24, "file": 2, "line": 2251}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "54a5e3c9ddf075fd4976ccaaf4b52ea4", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 24, "file": 2, "line": 2252}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "1b5cdfacad558c4070974994de6e06fc", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 27, "file": 2, "line": 2336}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "4e8a69585cc9f27591e694f8a2b6ef48", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 2342}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "b56ef5bff1ba998c375a81e061b8badb", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 2355}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "a9c7d5575fb3da20998ef636fb73e5be", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 39, "file": 2, "line": 2414}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "1e663e66c6598f3a504881d3c70c4d0e", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 36, "file": 2, "line": 2438}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "4a50b9696834b7f83bb1b3d0d1dd5f3d", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 29, "file": 2, "line": 2556}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "081f61f4e63b80cd5f40dac38a90f734", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 2737}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "eba07280875b7656899f710091a2fbdd", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 10, "file": 2, "line": 2745}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "7aa2c027993a88ec4a930cf3cc52e39d", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 26, "file": 2, "line": 2755}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "d38c0917a6cde7e417a8017c2cd9fa10", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 2930}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "b723ea98dff4152639d6747d9a85bd15", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 2942}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "9b5a830bb9c9e49bb2950f5dc9c3cd8d", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 2977}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "ceb24ff6b201531a8adceb21380523e4", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 2980}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "9b5a830bb9c9e49bb2950f5dc9c3cd8d", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 9, "file": 2, "line": 3301}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "1f8389a77b943c18ae69a96fca0c48df", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 30, "file": 2, "line": 3301}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "cf733f7bba878f2b094de8b218080735", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 20, "file": 2, "line": 3349}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "563224bbfb91856abdcb13abf2bc3d34", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 18, "file": 2, "line": 3365}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "cf94a6fe79af741144416f6f994ea194", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 26, "file": 2, "line": 3749}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "7852722d98e52df723240953e43e6974", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 37, "file": 2, "line": 3852}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "3965b981e028992afb526a83bb2d0794", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 35, "file": 2, "line": 3990}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "4090af74f94cc8c495b729a1710a6b3c", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 36, "file": 2, "line": 4114}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "4a50b9696834b7f83bb1b3d0d1dd5f3d", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 11, "file": 2, "line": 4128}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "5d67039fd3e7312c31691326d0fa4a2d", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 35, "file": 2, "line": 4254}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "4090af74f94cc8c495b729a1710a6b3c", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 25, "file": 2, "line": 4260}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "664fef78f771ae54324a6a2e789d619b", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 4371}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "b028f083d0103aa3020da599e8e6695c", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 11, "file": 2, "line": 4377}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "6051c801f7abcd8329280b18a29f5d2d", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 4387}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "b028f083d0103aa3020da599e8e6695c", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 11, "file": 2, "line": 4391}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "2c1e07c22e3e4abeeece650d5c22b3fc", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 4504}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "a9c7d5575fb3da20998ef636fb73e5be", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 17, "file": 2, "line": 4544}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "5e053cb891c69297a4a2a4c135b41fbb", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 4616}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "a9c7d5575fb3da20998ef636fb73e5be", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 8, "file": 2, "line": 4637}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "e93bb0d804b8c215742f7c1bab989214", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 23, "file": 2, "line": 4645}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "3f068ffe4b99ba7819f6cb5158c01e65", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 4668}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "e2d4d595f334f4a8287abe820a331999", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 4715}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "11d5f07dd4eea6fdd2bd413674d736f8", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 4759}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "a5cf69b910d786310f0296959acb807f", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 4763}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "37faa246c5255cfbbde1422c2daef5bc", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 4767}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "a9c7d5575fb3da20998ef636fb73e5be", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 17, "file": 2, "line": 4776}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "57ad0a99f52ae2813df13f962727e935", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 9, "file": 2, "line": 4779}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "cbd1ba4589afcc64947455e4ce0e801c", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 5865}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_tab_pip.c", "reportHash": "11d5f07dd4eea6fdd2bd413674d736f8", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
