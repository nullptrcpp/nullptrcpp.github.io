<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/scudo/standalone/allocator_config.h", "content": "//===-- allocator_config.h --------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef SCUDO_ALLOCATOR_CONFIG_H_\n#define SCUDO_ALLOCATOR_CONFIG_H_\n\n#include \"combined.h\"\n#include \"common.h\"\n#include \"flags.h\"\n#include \"primary32.h\"\n#include \"primary64.h\"\n#include \"secondary.h\"\n#include \"size_class_map.h\"\n#include \"tsd_exclusive.h\"\n#include \"tsd_shared.h\"\n\nnamespace scudo {\n\n// The combined allocator uses a structure as a template argument that\n// specifies the configuration options for the various subcomponents of the\n// allocator.\n//\n// struct ExampleConfig {\n//   // SizeClasMmap to use with the Primary.\n//   using SizeClassMap = DefaultSizeClassMap;\n//   // Indicates possible support for Memory Tagging.\n//   static const bool MaySupportMemoryTagging = false;\n//   // Defines the Primary allocator to use.\n//   typedef SizeClassAllocator64<ExampleConfig> Primary;\n//   // Log2 of the size of a size class region, as used by the Primary.\n//   static const uptr PrimaryRegionSizeLog = 30U;\n//   // Defines the type and scale of a compact pointer. A compact pointer can\n//   // be understood as the offset of a pointer within the region it belongs\n//   // to, in increments of a power-of-2 scale.\n//   // eg: Ptr = Base + (CompactPtr << Scale).\n//   typedef u32 PrimaryCompactPtrT;\n//   static const uptr PrimaryCompactPtrScale = SCUDO_MIN_ALIGNMENT_LOG;\n//   // Defines the minimal & maximal release interval that can be set.\n//   static const s32 PrimaryMinReleaseToOsIntervalMs = INT32_MIN;\n//   static const s32 PrimaryMaxReleaseToOsIntervalMs = INT32_MAX;\n//   // Defines the type of cache used by the Secondary. Some additional\n//   // configuration entries can be necessary depending on the Cache.\n//   typedef MapAllocatorNoCache SecondaryCache;\n//   // Thread-Specific Data Registry used, shared or exclusive.\n//   template <class A> using TSDRegistryT = TSDRegistrySharedT<A, 8U, 4U>;\n// };\n\n// Default configurations for various platforms.\n\nstruct DefaultConfig {\n  using SizeClassMap = DefaultSizeClassMap;\n  static const bool MaySupportMemoryTagging = false;\n\n#if SCUDO_CAN_USE_PRIMARY64\n  typedef SizeClassAllocator64<DefaultConfig> Primary;\n  static const uptr PrimaryRegionSizeLog = 32U;\n  typedef uptr PrimaryCompactPtrT;\n  static const uptr PrimaryCompactPtrScale = 0;\n#else\n  typedef SizeClassAllocator32<DefaultConfig> Primary;\n  static const uptr PrimaryRegionSizeLog = 19U;\n  typedef uptr PrimaryCompactPtrT;\n#endif\n  static const s32 PrimaryMinReleaseToOsIntervalMs = INT32_MIN;\n  static const s32 PrimaryMaxReleaseToOsIntervalMs = INT32_MAX;\n\n  typedef MapAllocatorCache<DefaultConfig> SecondaryCache;\n  static const u32 SecondaryCacheEntriesArraySize = 32U;\n  static const u32 SecondaryCacheQuarantineSize = 0U;\n  static const u32 SecondaryCacheDefaultMaxEntriesCount = 32U;\n  static const uptr SecondaryCacheDefaultMaxEntrySize = 1UL << 19;\n  static const s32 SecondaryCacheMinReleaseToOsIntervalMs = INT32_MIN;\n  static const s32 SecondaryCacheMaxReleaseToOsIntervalMs = INT32_MAX;\n\n  template <class A> using TSDRegistryT = TSDRegistryExT<A>; // Exclusive\n};\n\nstruct AndroidConfig {\n  using SizeClassMap = AndroidSizeClassMap;\n  static const bool MaySupportMemoryTagging = true;\n\n#if SCUDO_CAN_USE_PRIMARY64\n  typedef SizeClassAllocator64<AndroidConfig> Primary;\n  static const uptr PrimaryRegionSizeLog = 28U;\n  typedef u32 PrimaryCompactPtrT;\n  static const uptr PrimaryCompactPtrScale = SCUDO_MIN_ALIGNMENT_LOG;\n#else\n  typedef SizeClassAllocator32<AndroidConfig> Primary;\n  static const uptr PrimaryRegionSizeLog = 18U;\n  typedef uptr PrimaryCompactPtrT;\n#endif\n  static const s32 PrimaryMinReleaseToOsIntervalMs = 1000;\n  static const s32 PrimaryMaxReleaseToOsIntervalMs = 1000;\n\n  typedef MapAllocatorCache<AndroidConfig> SecondaryCache;\n  static const u32 SecondaryCacheEntriesArraySize = 256U;\n  static const u32 SecondaryCacheQuarantineSize = 32U;\n  static const u32 SecondaryCacheDefaultMaxEntriesCount = 32U;\n  static const uptr SecondaryCacheDefaultMaxEntrySize = 2UL << 20;\n  static const s32 SecondaryCacheMinReleaseToOsIntervalMs = 0;\n  static const s32 SecondaryCacheMaxReleaseToOsIntervalMs = 1000;\n\n  template <class A>\n  using TSDRegistryT = TSDRegistrySharedT<A, 8U, 2U>; // Shared, max 8 TSDs.\n};\n\nstruct AndroidSvelteConfig {\n  using SizeClassMap = SvelteSizeClassMap;\n  static const bool MaySupportMemoryTagging = false;\n\n#if SCUDO_CAN_USE_PRIMARY64\n  typedef SizeClassAllocator64<AndroidSvelteConfig> Primary;\n  static const uptr PrimaryRegionSizeLog = 27U;\n  typedef u32 PrimaryCompactPtrT;\n  static const uptr PrimaryCompactPtrScale = SCUDO_MIN_ALIGNMENT_LOG;\n#else\n  typedef SizeClassAllocator32<AndroidSvelteConfig> Primary;\n  static const uptr PrimaryRegionSizeLog = 16U;\n  typedef uptr PrimaryCompactPtrT;\n#endif\n  static const s32 PrimaryMinReleaseToOsIntervalMs = 1000;\n  static const s32 PrimaryMaxReleaseToOsIntervalMs = 1000;\n\n  typedef MapAllocatorCache<AndroidSvelteConfig> SecondaryCache;\n  static const u32 SecondaryCacheEntriesArraySize = 16U;\n  static const u32 SecondaryCacheQuarantineSize = 32U;\n  static const u32 SecondaryCacheDefaultMaxEntriesCount = 4U;\n  static const uptr SecondaryCacheDefaultMaxEntrySize = 1UL << 18;\n  static const s32 SecondaryCacheMinReleaseToOsIntervalMs = 0;\n  static const s32 SecondaryCacheMaxReleaseToOsIntervalMs = 0;\n\n  template <class A>\n  using TSDRegistryT = TSDRegistrySharedT<A, 2U, 1U>; // Shared, max 2 TSDs.\n};\n\n#if SCUDO_CAN_USE_PRIMARY64\nstruct FuchsiaConfig {\n  using SizeClassMap = DefaultSizeClassMap;\n  static const bool MaySupportMemoryTagging = false;\n\n  typedef SizeClassAllocator64<FuchsiaConfig> Primary;\n  static const uptr PrimaryRegionSizeLog = 30U;\n  typedef u32 PrimaryCompactPtrT;\n  static const uptr PrimaryCompactPtrScale = SCUDO_MIN_ALIGNMENT_LOG;\n  static const s32 PrimaryMinReleaseToOsIntervalMs = INT32_MIN;\n  static const s32 PrimaryMaxReleaseToOsIntervalMs = INT32_MAX;\n\n  typedef MapAllocatorNoCache SecondaryCache;\n  template <class A>\n  using TSDRegistryT = TSDRegistrySharedT<A, 8U, 4U>; // Shared, max 8 TSDs.\n};\n#endif\n\n#if SCUDO_ANDROID\ntypedef AndroidConfig Config;\n#elif SCUDO_FUCHSIA\ntypedef FuchsiaConfig Config;\n#else\ntypedef DefaultConfig Config;\n#endif\n\n} // namespace scudo\n\n#endif // SCUDO_ALLOCATOR_CONFIG_H_\n"}, "1": {"id": 1, "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/scudo/standalone/atomic_helpers.h", "content": "//===-- atomic_helpers.h ----------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef SCUDO_ATOMIC_H_\n#define SCUDO_ATOMIC_H_\n\n#include \"internal_defs.h\"\n\nnamespace scudo {\n\nenum memory_order {\n  memory_order_relaxed = 0,\n  memory_order_consume = 1,\n  memory_order_acquire = 2,\n  memory_order_release = 3,\n  memory_order_acq_rel = 4,\n  memory_order_seq_cst = 5\n};\nstatic_assert(memory_order_relaxed == __ATOMIC_RELAXED, \"\");\nstatic_assert(memory_order_consume == __ATOMIC_CONSUME, \"\");\nstatic_assert(memory_order_acquire == __ATOMIC_ACQUIRE, \"\");\nstatic_assert(memory_order_release == __ATOMIC_RELEASE, \"\");\nstatic_assert(memory_order_acq_rel == __ATOMIC_ACQ_REL, \"\");\nstatic_assert(memory_order_seq_cst == __ATOMIC_SEQ_CST, \"\");\n\nstruct atomic_u8 {\n  typedef u8 Type;\n  volatile Type ValDoNotUse;\n};\n\nstruct atomic_u16 {\n  typedef u16 Type;\n  volatile Type ValDoNotUse;\n};\n\nstruct atomic_s32 {\n  typedef s32 Type;\n  volatile Type ValDoNotUse;\n};\n\nstruct atomic_u32 {\n  typedef u32 Type;\n  volatile Type ValDoNotUse;\n};\n\nstruct atomic_u64 {\n  typedef u64 Type;\n  // On 32-bit platforms u64 is not necessarily aligned on 8 bytes.\n  alignas(8) volatile Type ValDoNotUse;\n};\n\nstruct atomic_uptr {\n  typedef uptr Type;\n  volatile Type ValDoNotUse;\n};\n\ntemplate <typename T>\ninline typename T::Type atomic_load(const volatile T *A, memory_order MO) {\n  DCHECK(!(reinterpret_cast<uptr>(A) % sizeof(*A)));\n  typename T::Type V;\n  __atomic_load(&A->ValDoNotUse, &V, MO);\n  return V;\n}\n\ntemplate <typename T>\ninline void atomic_store(volatile T *A, typename T::Type V, memory_order MO) {\n  DCHECK(!(reinterpret_cast<uptr>(A) % sizeof(*A)));\n  __atomic_store(&A->ValDoNotUse, &V, MO);\n}\n\ninline void atomic_thread_fence(memory_order) { __sync_synchronize(); }\n\ntemplate <typename T>\ninline typename T::Type atomic_fetch_add(volatile T *A, typename T::Type V,\n                                         memory_order MO) {\n  DCHECK(!(reinterpret_cast<uptr>(A) % sizeof(*A)));\n  return __atomic_fetch_add(&A->ValDoNotUse, V, MO);\n}\n\ntemplate <typename T>\ninline typename T::Type atomic_fetch_sub(volatile T *A, typename T::Type V,\n                                         memory_order MO) {\n  DCHECK(!(reinterpret_cast<uptr>(A) % sizeof(*A)));\n  return __atomic_fetch_sub(&A->ValDoNotUse, V, MO);\n}\n\ntemplate <typename T>\ninline typename T::Type atomic_fetch_and(volatile T *A, typename T::Type V,\n                                         memory_order MO) {\n  DCHECK(!(reinterpret_cast<uptr>(A) % sizeof(*A)));\n  return __atomic_fetch_and(&A->ValDoNotUse, V, MO);\n}\n\ntemplate <typename T>\ninline typename T::Type atomic_fetch_or(volatile T *A, typename T::Type V,\n                                        memory_order MO) {\n  DCHECK(!(reinterpret_cast<uptr>(A) % sizeof(*A)));\n  return __atomic_fetch_or(&A->ValDoNotUse, V, MO);\n}\n\ntemplate <typename T>\ninline typename T::Type atomic_exchange(volatile T *A, typename T::Type V,\n                                        memory_order MO) {\n  DCHECK(!(reinterpret_cast<uptr>(A) % sizeof(*A)));\n  typename T::Type R;\n  __atomic_exchange(&A->ValDoNotUse, &V, &R, MO);\n  return R;\n}\n\ntemplate <typename T>\ninline bool atomic_compare_exchange_strong(volatile T *A, typename T::Type *Cmp,\n                                           typename T::Type Xchg,\n                                           memory_order MO) {\n  return __atomic_compare_exchange(&A->ValDoNotUse, Cmp, &Xchg, false, MO,\n                                   __ATOMIC_RELAXED);\n}\n\n// Clutter-reducing helpers.\n\ntemplate <typename T>\ninline typename T::Type atomic_load_relaxed(const volatile T *A) {\n  return atomic_load(A, memory_order_relaxed);\n}\n\ntemplate <typename T>\ninline void atomic_store_relaxed(volatile T *A, typename T::Type V) {\n  atomic_store(A, V, memory_order_relaxed);\n}\n\ntemplate <typename T>\ninline typename T::Type atomic_compare_exchange(volatile T *A,\n                                                typename T::Type Cmp,\n                                                typename T::Type Xchg) {\n  atomic_compare_exchange_strong(A, &Cmp, Xchg, memory_order_acquire);\n  return Cmp;\n}\n\n} // namespace scudo\n\n#endif // SCUDO_ATOMIC_H_\n"}, "2": {"id": 2, "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/scudo/standalone/benchmarks/malloc_benchmark.cpp", "content": "//===-- malloc_benchmark.cpp ------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#include \"allocator_config.h\"\n#include \"combined.h\"\n#include \"common.h\"\n\n#include \"benchmark/benchmark.h\"\n\n#include <memory>\n\ntemplate <typename Config> static void BM_malloc_free(benchmark::State &State) {\n  using AllocatorT = scudo::Allocator<Config>;\n  auto Deleter = [](AllocatorT *A) {\n    A->unmapTestOnly();\n    delete A;\n  };\n  std::unique_ptr<AllocatorT, decltype(Deleter)> Allocator(new AllocatorT,\n                                                           Deleter);\n  Allocator->reset();\n\n  const size_t NBytes = State.range(0);\n  size_t PageSize = scudo::getPageSizeCached();\n\n  for (auto _ : State) {\n    void *Ptr = Allocator->allocate(NBytes, scudo::Chunk::Origin::Malloc);\n    auto *Data = reinterpret_cast<uint8_t *>(Ptr);\n    for (size_t I = 0; I < NBytes; I += PageSize)\n      Data[I] = 1;\n    benchmark::DoNotOptimize(Ptr);\n    Allocator->deallocate(Ptr, scudo::Chunk::Origin::Malloc);\n  }\n\n  State.SetBytesProcessed(uint64_t(State.iterations()) * uint64_t(NBytes));\n}\n\nstatic const size_t MinSize = 8;\nstatic const size_t MaxSize = 128 * 1024;\n\n// FIXME: Add DefaultConfig here once we can tear down the exclusive TSD\n// cleanly.\nBENCHMARK_TEMPLATE(BM_malloc_free, scudo::AndroidConfig)\n    ->Range(MinSize, MaxSize);\nBENCHMARK_TEMPLATE(BM_malloc_free, scudo::AndroidSvelteConfig)\n    ->Range(MinSize, MaxSize);\n#if SCUDO_CAN_USE_PRIMARY64\nBENCHMARK_TEMPLATE(BM_malloc_free, scudo::FuchsiaConfig)\n    ->Range(MinSize, MaxSize);\n#endif\n\ntemplate <typename Config>\nstatic void BM_malloc_free_loop(benchmark::State &State) {\n  using AllocatorT = scudo::Allocator<Config>;\n  auto Deleter = [](AllocatorT *A) {\n    A->unmapTestOnly();\n    delete A;\n  };\n  std::unique_ptr<AllocatorT, decltype(Deleter)> Allocator(new AllocatorT,\n                                                           Deleter);\n  Allocator->reset();\n\n  const size_t NumIters = State.range(0);\n  size_t PageSize = scudo::getPageSizeCached();\n  void *Ptrs[NumIters];\n\n  for (auto _ : State) {\n    size_t SizeLog2 = 0;\n    for (void *&Ptr : Ptrs) {\n      Ptr = Allocator->allocate(1 << SizeLog2, scudo::Chunk::Origin::Malloc);\n      auto *Data = reinterpret_cast<uint8_t *>(Ptr);\n      for (size_t I = 0; I < 1 << SizeLog2; I += PageSize)\n        Data[I] = 1;\n      benchmark::DoNotOptimize(Ptr);\n      SizeLog2 = (SizeLog2 + 1) % 16;\n    }\n    for (void *&Ptr : Ptrs)\n      Allocator->deallocate(Ptr, scudo::Chunk::Origin::Malloc);\n  }\n\n  State.SetBytesProcessed(uint64_t(State.iterations()) * uint64_t(NumIters) *\n                          8192);\n}\n\nstatic const size_t MinIters = 8;\nstatic const size_t MaxIters = 32 * 1024;\n\n// FIXME: Add DefaultConfig here once we can tear down the exclusive TSD\n// cleanly.\nBENCHMARK_TEMPLATE(BM_malloc_free_loop, scudo::AndroidConfig)\n    ->Range(MinIters, MaxIters);\nBENCHMARK_TEMPLATE(BM_malloc_free_loop, scudo::AndroidSvelteConfig)\n    ->Range(MinIters, MaxIters);\n#if SCUDO_CAN_USE_PRIMARY64\nBENCHMARK_TEMPLATE(BM_malloc_free_loop, scudo::FuchsiaConfig)\n    ->Range(MinIters, MaxIters);\n#endif\n\nBENCHMARK_MAIN();\n"}, "3": {"id": 3, "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/scudo/standalone/bytemap.h", "content": "//===-- bytemap.h -----------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef SCUDO_BYTEMAP_H_\n#define SCUDO_BYTEMAP_H_\n\n#include \"atomic_helpers.h\"\n#include \"common.h\"\n#include \"mutex.h\"\n\nnamespace scudo {\n\ntemplate <uptr Size> class FlatByteMap {\npublic:\n  void initLinkerInitialized() {}\n  void init() { memset(Map, 0, sizeof(Map)); }\n\n  void unmapTestOnly() {}\n\n  void set(uptr Index, u8 Value) {\n    DCHECK_LT(Index, Size);\n    DCHECK_EQ(0U, Map[Index]);\n    Map[Index] = Value;\n  }\n  u8 operator[](uptr Index) {\n    DCHECK_LT(Index, Size);\n    return Map[Index];\n  }\n\n  void disable() {}\n  void enable() {}\n\nprivate:\n  u8 Map[Size];\n};\n\n} // namespace scudo\n\n#endif // SCUDO_BYTEMAP_H_\n"}, "4": {"id": 4, "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/scudo/standalone/checksum.h", "content": "//===-- checksum.h ----------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef SCUDO_CHECKSUM_H_\n#define SCUDO_CHECKSUM_H_\n\n#include \"internal_defs.h\"\n\n// Hardware CRC32 is supported at compilation via the following:\n// - for i386 & x86_64: -msse4.2\n// - for ARM & AArch64: -march=armv8-a+crc or -mcrc\n// An additional check must be performed at runtime as well to make sure the\n// emitted instructions are valid on the target host.\n\n#ifdef __SSE4_2__\n#include <smmintrin.h>\n#define CRC32_INTRINSIC FIRST_32_SECOND_64(_mm_crc32_u32, _mm_crc32_u64)\n#endif\n#ifdef __ARM_FEATURE_CRC32\n#include <arm_acle.h>\n#define CRC32_INTRINSIC FIRST_32_SECOND_64(__crc32cw, __crc32cd)\n#endif\n\nnamespace scudo {\n\nenum class Checksum : u8 {\n  BSD = 0,\n  HardwareCRC32 = 1,\n};\n\n// BSD checksum, unlike a software CRC32, doesn't use any array lookup. We save\n// significantly on memory accesses, as well as 1K of CRC32 table, on platforms\n// that do no support hardware CRC32. The checksum itself is 16-bit, which is at\n// odds with CRC32, but enough for our needs.\ninline u16 computeBSDChecksum(u16 Sum, uptr Data) {\n  for (u8 I = 0; I < sizeof(Data); I++) {\n    Sum = static_cast<u16>((Sum >> 1) | ((Sum & 1) << 15));\n    Sum = static_cast<u16>(Sum + (Data & 0xff));\n    Data >>= 8;\n  }\n  return Sum;\n}\n\nbool hasHardwareCRC32();\nWEAK u32 computeHardwareCRC32(u32 Crc, uptr Data);\n\n} // namespace scudo\n\n#endif // SCUDO_CHECKSUM_H_\n"}, "5": {"id": 5, "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/scudo/standalone/chunk.h", "content": "//===-- chunk.h -------------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef SCUDO_CHUNK_H_\n#define SCUDO_CHUNK_H_\n\n#include \"platform.h\"\n\n#include \"atomic_helpers.h\"\n#include \"checksum.h\"\n#include \"common.h\"\n#include \"report.h\"\n\nnamespace scudo {\n\nextern Checksum HashAlgorithm;\n\ninline u16 computeChecksum(u32 Seed, uptr Value, uptr *Array, uptr ArraySize) {\n  // If the hardware CRC32 feature is defined here, it was enabled everywhere,\n  // as opposed to only for crc32_hw.cpp. This means that other hardware\n  // specific instructions were likely emitted at other places, and as a result\n  // there is no reason to not use it here.\n#if defined(__SSE4_2__) || defined(__ARM_FEATURE_CRC32)\n  u32 Crc = static_cast<u32>(CRC32_INTRINSIC(Seed, Value));\n  for (uptr I = 0; I < ArraySize; I++)\n    Crc = static_cast<u32>(CRC32_INTRINSIC(Crc, Array[I]));\n  return static_cast<u16>(Crc ^ (Crc >> 16));\n#else\n  if (HashAlgorithm == Checksum::HardwareCRC32) {\n    u32 Crc = computeHardwareCRC32(Seed, Value);\n    for (uptr I = 0; I < ArraySize; I++)\n      Crc = computeHardwareCRC32(Crc, Array[I]);\n    return static_cast<u16>(Crc ^ (Crc >> 16));\n  } else {\n    u16 Checksum = computeBSDChecksum(static_cast<u16>(Seed), Value);\n    for (uptr I = 0; I < ArraySize; I++)\n      Checksum = computeBSDChecksum(Checksum, Array[I]);\n    return Checksum;\n  }\n#endif // defined(__SSE4_2__) || defined(__ARM_FEATURE_CRC32)\n}\n\nnamespace Chunk {\n\n// Note that in an ideal world, `State` and `Origin` should be `enum class`, and\n// the associated `UnpackedHeader` fields of their respective enum class type\n// but https://gcc.gnu.org/bugzilla/show_bug.cgi?id=61414 prevents it from\n// happening, as it will error, complaining the number of bits is not enough.\nenum Origin : u8 {\n  Malloc = 0,\n  New = 1,\n  NewArray = 2,\n  Memalign = 3,\n};\n\nenum State : u8 { Available = 0, Allocated = 1, Quarantined = 2 };\n\ntypedef u64 PackedHeader;\n// Update the 'Mask' constants to reflect changes in this structure.\nstruct UnpackedHeader {\n  uptr ClassId : 8;\n  u8 State : 2;\n  // Origin if State == Allocated, or WasZeroed otherwise.\n  u8 OriginOrWasZeroed : 2;\n  uptr SizeOrUnusedBytes : 20;\n  uptr Offset : 16;\n  uptr Checksum : 16;\n};\ntypedef atomic_u64 AtomicPackedHeader;\nstatic_assert(sizeof(UnpackedHeader) == sizeof(PackedHeader), \"\");\n\n// Those constants are required to silence some -Werror=conversion errors when\n// assigning values to the related bitfield variables.\nconstexpr uptr ClassIdMask = (1UL << 8) - 1;\nconstexpr u8 StateMask = (1U << 2) - 1;\nconstexpr u8 OriginMask = (1U << 2) - 1;\nconstexpr uptr SizeOrUnusedBytesMask = (1UL << 20) - 1;\nconstexpr uptr OffsetMask = (1UL << 16) - 1;\nconstexpr uptr ChecksumMask = (1UL << 16) - 1;\n\nconstexpr uptr getHeaderSize() {\n  return roundUpTo(sizeof(PackedHeader), 1U << SCUDO_MIN_ALIGNMENT_LOG);\n}\n\ninline AtomicPackedHeader *getAtomicHeader(void *Ptr) {\n  return reinterpret_cast<AtomicPackedHeader *>(reinterpret_cast<uptr>(Ptr) -\n                                                getHeaderSize());\n}\n\ninline const AtomicPackedHeader *getConstAtomicHeader(const void *Ptr) {\n  return reinterpret_cast<const AtomicPackedHeader *>(\n      reinterpret_cast<uptr>(Ptr) - getHeaderSize());\n}\n\n// We do not need a cryptographically strong hash for the checksum, but a CRC\n// type function that can alert us in the event a header is invalid or\n// corrupted. Ideally slightly better than a simple xor of all fields.\nstatic inline u16 computeHeaderChecksum(u32 Cookie, const void *Ptr,\n                                        UnpackedHeader *Header) {\n  UnpackedHeader ZeroChecksumHeader = *Header;\n  ZeroChecksumHeader.Checksum = 0;\n  uptr HeaderHolder[sizeof(UnpackedHeader) / sizeof(uptr)];\n  memcpy(&HeaderHolder, &ZeroChecksumHeader, sizeof(HeaderHolder));\n  return computeChecksum(Cookie, reinterpret_cast<uptr>(Ptr), HeaderHolder,\n                         ARRAY_SIZE(HeaderHolder));\n}\n\ninline void storeHeader(u32 Cookie, void *Ptr,\n                        UnpackedHeader *NewUnpackedHeader) {\n  NewUnpackedHeader->Checksum =\n      computeHeaderChecksum(Cookie, Ptr, NewUnpackedHeader);\n  PackedHeader NewPackedHeader = bit_cast<PackedHeader>(*NewUnpackedHeader);\n  atomic_store_relaxed(getAtomicHeader(Ptr), NewPackedHeader);\n}\n\ninline void loadHeader(u32 Cookie, const void *Ptr,\n                       UnpackedHeader *NewUnpackedHeader) {\n  PackedHeader NewPackedHeader = atomic_load_relaxed(getConstAtomicHeader(Ptr));\n  *NewUnpackedHeader = bit_cast<UnpackedHeader>(NewPackedHeader);\n  if (UNLIKELY(NewUnpackedHeader->Checksum !=\n               computeHeaderChecksum(Cookie, Ptr, NewUnpackedHeader)))\n    reportHeaderCorruption(const_cast<void *>(Ptr));\n}\n\ninline void compareExchangeHeader(u32 Cookie, void *Ptr,\n                                  UnpackedHeader *NewUnpackedHeader,\n                                  UnpackedHeader *OldUnpackedHeader) {\n  NewUnpackedHeader->Checksum =\n      computeHeaderChecksum(Cookie, Ptr, NewUnpackedHeader);\n  PackedHeader NewPackedHeader = bit_cast<PackedHeader>(*NewUnpackedHeader);\n  PackedHeader OldPackedHeader = bit_cast<PackedHeader>(*OldUnpackedHeader);\n  if (UNLIKELY(!atomic_compare_exchange_strong(\n          getAtomicHeader(Ptr), &OldPackedHeader, NewPackedHeader,\n          memory_order_relaxed)))\n    reportHeaderRace(Ptr);\n}\n\ninline bool isValid(u32 Cookie, const void *Ptr,\n                    UnpackedHeader *NewUnpackedHeader) {\n  PackedHeader NewPackedHeader = atomic_load_relaxed(getConstAtomicHeader(Ptr));\n  *NewUnpackedHeader = bit_cast<UnpackedHeader>(NewPackedHeader);\n  return NewUnpackedHeader->Checksum ==\n         computeHeaderChecksum(Cookie, Ptr, NewUnpackedHeader);\n}\n\n} // namespace Chunk\n\n} // namespace scudo\n\n#endif // SCUDO_CHUNK_H_\n"}, "6": {"id": 6, "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/scudo/standalone/combined.h", "content": "//===-- combined.h ----------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef SCUDO_COMBINED_H_\n#define SCUDO_COMBINED_H_\n\n#include \"chunk.h\"\n#include \"common.h\"\n#include \"flags.h\"\n#include \"flags_parser.h\"\n#include \"local_cache.h\"\n#include \"memtag.h\"\n#include \"options.h\"\n#include \"quarantine.h\"\n#include \"report.h\"\n#include \"secondary.h\"\n#include \"stack_depot.h\"\n#include \"string_utils.h\"\n#include \"tsd.h\"\n\n#include \"scudo/interface.h\"\n\n#ifdef GWP_ASAN_HOOKS\n#include \"gwp_asan/guarded_pool_allocator.h\"\n#include \"gwp_asan/optional/backtrace.h\"\n#include \"gwp_asan/optional/segv_handler.h\"\n#endif // GWP_ASAN_HOOKS\n\nextern \"C\" inline void EmptyCallback() {}\n\n#ifdef HAVE_ANDROID_UNSAFE_FRAME_POINTER_CHASE\n// This function is not part of the NDK so it does not appear in any public\n// header files. We only declare/use it when targeting the platform.\nextern \"C\" size_t android_unsafe_frame_pointer_chase(scudo::uptr *buf,\n                                                     size_t num_entries);\n#endif\n\nnamespace scudo {\n\ntemplate <class Params, void (*PostInitCallback)(void) = EmptyCallback>\nclass Allocator {\npublic:\n  using PrimaryT = typename Params::Primary;\n  using CacheT = typename PrimaryT::CacheT;\n  typedef Allocator<Params, PostInitCallback> ThisT;\n  typedef typename Params::template TSDRegistryT<ThisT> TSDRegistryT;\n\n  void callPostInitCallback() {\n    static pthread_once_t OnceControl = PTHREAD_ONCE_INIT;\n    pthread_once(&OnceControl, PostInitCallback);\n  }\n\n  struct QuarantineCallback {\n    explicit QuarantineCallback(ThisT &Instance, CacheT &LocalCache)\n        : Allocator(Instance), Cache(LocalCache) {}\n\n    // Chunk recycling function, returns a quarantined chunk to the backend,\n    // first making sure it hasn't been tampered with.\n    void recycle(void *Ptr) {\n      Chunk::UnpackedHeader Header;\n      Chunk::loadHeader(Allocator.Cookie, Ptr, &Header);\n      if (UNLIKELY(Header.State != Chunk::State::Quarantined))\n        reportInvalidChunkState(AllocatorAction::Recycling, Ptr);\n\n      Chunk::UnpackedHeader NewHeader = Header;\n      NewHeader.State = Chunk::State::Available;\n      Chunk::compareExchangeHeader(Allocator.Cookie, Ptr, &NewHeader, &Header);\n\n      if (allocatorSupportsMemoryTagging<Params>())\n        Ptr = untagPointer(Ptr);\n      void *BlockBegin = Allocator::getBlockBegin(Ptr, &NewHeader);\n      Cache.deallocate(NewHeader.ClassId, BlockBegin);\n    }\n\n    // We take a shortcut when allocating a quarantine batch by working with the\n    // appropriate class ID instead of using Size. The compiler should optimize\n    // the class ID computation and work with the associated cache directly.\n    void *allocate(UNUSED uptr Size) {\n      const uptr QuarantineClassId = SizeClassMap::getClassIdBySize(\n          sizeof(QuarantineBatch) + Chunk::getHeaderSize());\n      void *Ptr = Cache.allocate(QuarantineClassId);\n      // Quarantine batch allocation failure is fatal.\n      if (UNLIKELY(!Ptr))\n        reportOutOfMemory(SizeClassMap::getSizeByClassId(QuarantineClassId));\n\n      Ptr = reinterpret_cast<void *>(reinterpret_cast<uptr>(Ptr) +\n                                     Chunk::getHeaderSize());\n      Chunk::UnpackedHeader Header = {};\n      Header.ClassId = QuarantineClassId & Chunk::ClassIdMask;\n      Header.SizeOrUnusedBytes = sizeof(QuarantineBatch);\n      Header.State = Chunk::State::Allocated;\n      Chunk::storeHeader(Allocator.Cookie, Ptr, &Header);\n\n      // Reset tag to 0 as this chunk may have been previously used for a tagged\n      // user allocation.\n      if (UNLIKELY(useMemoryTagging<Params>(Allocator.Primary.Options.load())))\n        storeTags(reinterpret_cast<uptr>(Ptr),\n                  reinterpret_cast<uptr>(Ptr) + sizeof(QuarantineBatch));\n\n      return Ptr;\n    }\n\n    void deallocate(void *Ptr) {\n      const uptr QuarantineClassId = SizeClassMap::getClassIdBySize(\n          sizeof(QuarantineBatch) + Chunk::getHeaderSize());\n      Chunk::UnpackedHeader Header;\n      Chunk::loadHeader(Allocator.Cookie, Ptr, &Header);\n\n      if (UNLIKELY(Header.State != Chunk::State::Allocated))\n        reportInvalidChunkState(AllocatorAction::Deallocating, Ptr);\n      DCHECK_EQ(Header.ClassId, QuarantineClassId);\n      DCHECK_EQ(Header.Offset, 0);\n      DCHECK_EQ(Header.SizeOrUnusedBytes, sizeof(QuarantineBatch));\n\n      Chunk::UnpackedHeader NewHeader = Header;\n      NewHeader.State = Chunk::State::Available;\n      Chunk::compareExchangeHeader(Allocator.Cookie, Ptr, &NewHeader, &Header);\n      Cache.deallocate(QuarantineClassId,\n                       reinterpret_cast<void *>(reinterpret_cast<uptr>(Ptr) -\n                                                Chunk::getHeaderSize()));\n    }\n\n  private:\n    ThisT &Allocator;\n    CacheT &Cache;\n  };\n\n  typedef GlobalQuarantine<QuarantineCallback, void> QuarantineT;\n  typedef typename QuarantineT::CacheT QuarantineCacheT;\n\n  void initLinkerInitialized() {\n    performSanityChecks();\n\n    // Check if hardware CRC32 is supported in the binary and by the platform,\n    // if so, opt for the CRC32 hardware version of the checksum.\n    if (&computeHardwareCRC32 && hasHardwareCRC32())\n      HashAlgorithm = Checksum::HardwareCRC32;\n\n    if (UNLIKELY(!getRandom(&Cookie, sizeof(Cookie))))\n      Cookie = static_cast<u32>(getMonotonicTime() ^\n                                (reinterpret_cast<uptr>(this) >> 4));\n\n    initFlags();\n    reportUnrecognizedFlags();\n\n    // Store some flags locally.\n    if (getFlags()->may_return_null)\n      Primary.Options.set(OptionBit::MayReturnNull);\n    if (getFlags()->zero_contents)\n      Primary.Options.setFillContentsMode(ZeroFill);\n    else if (getFlags()->pattern_fill_contents)\n      Primary.Options.setFillContentsMode(PatternOrZeroFill);\n    if (getFlags()->dealloc_type_mismatch)\n      Primary.Options.set(OptionBit::DeallocTypeMismatch);\n    if (getFlags()->delete_size_mismatch)\n      Primary.Options.set(OptionBit::DeleteSizeMismatch);\n    if (allocatorSupportsMemoryTagging<Params>() &&\n        systemSupportsMemoryTagging())\n      Primary.Options.set(OptionBit::UseMemoryTagging);\n    Primary.Options.set(OptionBit::UseOddEvenTags);\n\n    QuarantineMaxChunkSize =\n        static_cast<u32>(getFlags()->quarantine_max_chunk_size);\n\n    Stats.initLinkerInitialized();\n    const s32 ReleaseToOsIntervalMs = getFlags()->release_to_os_interval_ms;\n    Primary.initLinkerInitialized(ReleaseToOsIntervalMs);\n    Secondary.initLinkerInitialized(&Stats, ReleaseToOsIntervalMs);\n\n    Quarantine.init(\n        static_cast<uptr>(getFlags()->quarantine_size_kb << 10),\n        static_cast<uptr>(getFlags()->thread_local_quarantine_size_kb << 10));\n  }\n\n  // Initialize the embedded GWP-ASan instance. Requires the main allocator to\n  // be functional, best called from PostInitCallback.\n  void initGwpAsan() {\n#ifdef GWP_ASAN_HOOKS\n    gwp_asan::options::Options Opt;\n    Opt.Enabled = getFlags()->GWP_ASAN_Enabled;\n    Opt.MaxSimultaneousAllocations =\n        getFlags()->GWP_ASAN_MaxSimultaneousAllocations;\n    Opt.SampleRate = getFlags()->GWP_ASAN_SampleRate;\n    Opt.InstallSignalHandlers = getFlags()->GWP_ASAN_InstallSignalHandlers;\n    // Embedded GWP-ASan is locked through the Scudo atfork handler (via\n    // Allocator::disable calling GWPASan.disable). Disable GWP-ASan's atfork\n    // handler.\n    Opt.InstallForkHandlers = false;\n    Opt.Backtrace = gwp_asan::backtrace::getBacktraceFunction();\n    GuardedAlloc.init(Opt);\n\n    if (Opt.InstallSignalHandlers)\n      gwp_asan::segv_handler::installSignalHandlers(\n          &GuardedAlloc, Printf,\n          gwp_asan::backtrace::getPrintBacktraceFunction(),\n          gwp_asan::backtrace::getSegvBacktraceFunction());\n#endif // GWP_ASAN_HOOKS\n  }\n\n  ALWAYS_INLINE void initThreadMaybe(bool MinimalInit = false) {\n    TSDRegistry.initThreadMaybe(this, MinimalInit);\n  }\n\n  void reset() { memset(this, 0, sizeof(*this)); }\n\n  void unmapTestOnly() {\n    TSDRegistry.unmapTestOnly();\n    Primary.unmapTestOnly();\n#ifdef GWP_ASAN_HOOKS\n    if (getFlags()->GWP_ASAN_InstallSignalHandlers)\n      gwp_asan::segv_handler::uninstallSignalHandlers();\n    GuardedAlloc.uninitTestOnly();\n#endif // GWP_ASAN_HOOKS\n  }\n\n  TSDRegistryT *getTSDRegistry() { return &TSDRegistry; }\n\n  // The Cache must be provided zero-initialized.\n  void initCache(CacheT *Cache) {\n    Cache->initLinkerInitialized(&Stats, &Primary);\n  }\n\n  // Release the resources used by a TSD, which involves:\n  // - draining the local quarantine cache to the global quarantine;\n  // - releasing the cached pointers back to the Primary;\n  // - unlinking the local stats from the global ones (destroying the cache does\n  //   the last two items).\n  void commitBack(TSD<ThisT> *TSD) {\n    Quarantine.drain(&TSD->QuarantineCache,\n                     QuarantineCallback(*this, TSD->Cache));\n    TSD->Cache.destroy(&Stats);\n  }\n\n  ALWAYS_INLINE void *getHeaderTaggedPointer(void *Ptr) {\n    if (!allocatorSupportsMemoryTagging<Params>())\n      return Ptr;\n    auto UntaggedPtr = untagPointer(Ptr);\n    if (UntaggedPtr != Ptr)\n      return UntaggedPtr;\n    // Secondary, or pointer allocated while memory tagging is unsupported or\n    // disabled. The tag mismatch is okay in the latter case because tags will\n    // not be checked.\n    return addHeaderTag(Ptr);\n  }\n\n  ALWAYS_INLINE uptr addHeaderTag(uptr Ptr) {\n    if (!allocatorSupportsMemoryTagging<Params>())\n      return Ptr;\n    return addFixedTag(Ptr, 2);\n  }\n\n  ALWAYS_INLINE void *addHeaderTag(void *Ptr) {\n    return reinterpret_cast<void *>(addHeaderTag(reinterpret_cast<uptr>(Ptr)));\n  }\n\n  NOINLINE u32 collectStackTrace() {\n#ifdef HAVE_ANDROID_UNSAFE_FRAME_POINTER_CHASE\n    // Discard collectStackTrace() frame and allocator function frame.\n    constexpr uptr DiscardFrames = 2;\n    uptr Stack[MaxTraceSize + DiscardFrames];\n    uptr Size =\n        android_unsafe_frame_pointer_chase(Stack, MaxTraceSize + DiscardFrames);\n    Size = Min<uptr>(Size, MaxTraceSize + DiscardFrames);\n    return Depot.insert(Stack + Min<uptr>(DiscardFrames, Size), Stack + Size);\n#else\n    return 0;\n#endif\n  }\n\n  uptr computeOddEvenMaskForPointerMaybe(Options Options, uptr Ptr,\n                                         uptr ClassId) {\n    if (!Options.get(OptionBit::UseOddEvenTags))\n      return 0;\n\n    // If a chunk's tag is odd, we want the tags of the surrounding blocks to be\n    // even, and vice versa. Blocks are laid out Size bytes apart, and adding\n    // Size to Ptr will flip the least significant set bit of Size in Ptr, so\n    // that bit will have the pattern 010101... for consecutive blocks, which we\n    // can use to determine which tag mask to use.\n    return 0x5555U << ((Ptr >> SizeClassMap::getSizeLSBByClassId(ClassId)) & 1);\n  }\n\n  NOINLINE void *allocate(uptr Size, Chunk::Origin Origin,\n                          uptr Alignment = MinAlignment,\n                          bool ZeroContents = false) {\n    initThreadMaybe();\n\n#ifdef GWP_ASAN_HOOKS\n    if (UNLIKELY(GuardedAlloc.shouldSample())) {\n      if (void *Ptr = GuardedAlloc.allocate(roundUpTo(Size, Alignment)))\n        return Ptr;\n    }\n#endif // GWP_ASAN_HOOKS\n\n    const Options Options = Primary.Options.load();\n    const FillContentsMode FillContents = ZeroContents ? ZeroFill\n                                          : TSDRegistry.getDisableMemInit()\n                                              ? NoFill\n                                              : Options.getFillContentsMode();\n\n    if (UNLIKELY(Alignment > MaxAlignment)) {\n      if (Options.get(OptionBit::MayReturnNull))\n        return nullptr;\n      reportAlignmentTooBig(Alignment, MaxAlignment);\n    }\n    if (Alignment < MinAlignment)\n      Alignment = MinAlignment;\n\n    // If the requested size happens to be 0 (more common than you might think),\n    // allocate MinAlignment bytes on top of the header. Then add the extra\n    // bytes required to fulfill the alignment requirements: we allocate enough\n    // to be sure that there will be an address in the block that will satisfy\n    // the alignment.\n    const uptr NeededSize =\n        roundUpTo(Size, MinAlignment) +\n        ((Alignment > MinAlignment) ? Alignment : Chunk::getHeaderSize());\n\n    // Takes care of extravagantly large sizes as well as integer overflows.\n    static_assert(MaxAllowedMallocSize < UINTPTR_MAX - MaxAlignment, \"\");\n    if (UNLIKELY(Size >= MaxAllowedMallocSize)) {\n      if (Options.get(OptionBit::MayReturnNull))\n        return nullptr;\n      reportAllocationSizeTooBig(Size, NeededSize, MaxAllowedMallocSize);\n    }\n    DCHECK_LE(Size, NeededSize);\n\n    void *Block = nullptr;\n    uptr ClassId = 0;\n    uptr SecondaryBlockEnd = 0;\n    if (LIKELY(PrimaryT::canAllocate(NeededSize))) {\n      ClassId = SizeClassMap::getClassIdBySize(NeededSize);\n      DCHECK_NE(ClassId, 0U);\n      bool UnlockRequired;\n      auto *TSD = TSDRegistry.getTSDAndLock(&UnlockRequired);\n      Block = TSD->Cache.allocate(ClassId);\n      // If the allocation failed, the most likely reason with a 32-bit primary\n      // is the region being full. In that event, retry in each successively\n      // larger class until it fits. If it fails to fit in the largest class,\n      // fallback to the Secondary.\n      if (UNLIKELY(!Block)) {\n        while (ClassId < SizeClassMap::LargestClassId && !Block)\n          Block = TSD->Cache.allocate(++ClassId);\n        if (!Block)\n          ClassId = 0;\n      }\n      if (UnlockRequired)\n        TSD->unlock();\n    }\n    if (UNLIKELY(ClassId == 0))\n      Block = Secondary.allocate(Options, Size, Alignment, &SecondaryBlockEnd,\n                                 FillContents);\n\n    if (UNLIKELY(!Block)) {\n      if (Options.get(OptionBit::MayReturnNull))\n        return nullptr;\n      reportOutOfMemory(NeededSize);\n    }\n\n    const uptr BlockUptr = reinterpret_cast<uptr>(Block);\n    const uptr UnalignedUserPtr = BlockUptr + Chunk::getHeaderSize();\n    const uptr UserPtr = roundUpTo(UnalignedUserPtr, Alignment);\n\n    void *Ptr = reinterpret_cast<void *>(UserPtr);\n    void *TaggedPtr = Ptr;\n    if (LIKELY(ClassId)) {\n      // We only need to zero or tag the contents for Primary backed\n      // allocations. We only set tags for primary allocations in order to avoid\n      // faulting potentially large numbers of pages for large secondary\n      // allocations. We assume that guard pages are enough to protect these\n      // allocations.\n      //\n      // FIXME: When the kernel provides a way to set the background tag of a\n      // mapping, we should be able to tag secondary allocations as well.\n      //\n      // When memory tagging is enabled, zeroing the contents is done as part of\n      // setting the tag.\n      if (UNLIKELY(useMemoryTagging<Params>(Options))) {\n        uptr PrevUserPtr;\n        Chunk::UnpackedHeader Header;\n        const uptr BlockSize = PrimaryT::getSizeByClassId(ClassId);\n        const uptr BlockEnd = BlockUptr + BlockSize;\n        // If possible, try to reuse the UAF tag that was set by deallocate().\n        // For simplicity, only reuse tags if we have the same start address as\n        // the previous allocation. This handles the majority of cases since\n        // most allocations will not be more aligned than the minimum alignment.\n        //\n        // We need to handle situations involving reclaimed chunks, and retag\n        // the reclaimed portions if necessary. In the case where the chunk is\n        // fully reclaimed, the chunk's header will be zero, which will trigger\n        // the code path for new mappings and invalid chunks that prepares the\n        // chunk from scratch. There are three possibilities for partial\n        // reclaiming:\n        //\n        // (1) Header was reclaimed, data was partially reclaimed.\n        // (2) Header was not reclaimed, all data was reclaimed (e.g. because\n        //     data started on a page boundary).\n        // (3) Header was not reclaimed, data was partially reclaimed.\n        //\n        // Case (1) will be handled in the same way as for full reclaiming,\n        // since the header will be zero.\n        //\n        // We can detect case (2) by loading the tag from the start\n        // of the chunk. If it is zero, it means that either all data was\n        // reclaimed (since we never use zero as the chunk tag), or that the\n        // previous allocation was of size zero. Either way, we need to prepare\n        // a new chunk from scratch.\n        //\n        // We can detect case (3) by moving to the next page (if covered by the\n        // chunk) and loading the tag of its first granule. If it is zero, it\n        // means that all following pages may need to be retagged. On the other\n        // hand, if it is nonzero, we can assume that all following pages are\n        // still tagged, according to the logic that if any of the pages\n        // following the next page were reclaimed, the next page would have been\n        // reclaimed as well.\n        uptr TaggedUserPtr;\n        if (getChunkFromBlock(BlockUptr, &PrevUserPtr, &Header) &&\n            PrevUserPtr == UserPtr &&\n            (TaggedUserPtr = loadTag(UserPtr)) != UserPtr) {\n          uptr PrevEnd = TaggedUserPtr + Header.SizeOrUnusedBytes;\n          const uptr NextPage = roundUpTo(TaggedUserPtr, getPageSizeCached());\n          if (NextPage < PrevEnd && loadTag(NextPage) != NextPage)\n            PrevEnd = NextPage;\n          TaggedPtr = reinterpret_cast<void *>(TaggedUserPtr);\n          resizeTaggedChunk(PrevEnd, TaggedUserPtr + Size, BlockEnd);\n          if (UNLIKELY(FillContents != NoFill && !Header.OriginOrWasZeroed)) {\n            // If an allocation needs to be zeroed (i.e. calloc) we can normally\n            // avoid zeroing the memory now since we can rely on memory having\n            // been zeroed on free, as this is normally done while setting the\n            // UAF tag. But if tagging was disabled per-thread when the memory\n            // was freed, it would not have been retagged and thus zeroed, and\n            // therefore it needs to be zeroed now.\n            memset(TaggedPtr, 0,\n                   Min(Size, roundUpTo(PrevEnd - TaggedUserPtr,\n                                       archMemoryTagGranuleSize())));\n          } else if (Size) {\n            // Clear any stack metadata that may have previously been stored in\n            // the chunk data.\n            memset(TaggedPtr, 0, archMemoryTagGranuleSize());\n          }\n        } else {\n          const uptr OddEvenMask =\n              computeOddEvenMaskForPointerMaybe(Options, BlockUptr, ClassId);\n          TaggedPtr = prepareTaggedChunk(Ptr, Size, OddEvenMask, BlockEnd);\n        }\n        storePrimaryAllocationStackMaybe(Options, Ptr);\n      } else {\n        Block = addHeaderTag(Block);\n        Ptr = addHeaderTag(Ptr);\n        if (UNLIKELY(FillContents != NoFill)) {\n          // This condition is not necessarily unlikely, but since memset is\n          // costly, we might as well mark it as such.\n          memset(Block, FillContents == ZeroFill ? 0 : PatternFillByte,\n                 PrimaryT::getSizeByClassId(ClassId));\n        }\n      }\n    } else {\n      Block = addHeaderTag(Block);\n      Ptr = addHeaderTag(Ptr);\n      if (UNLIKELY(useMemoryTagging<Params>(Options))) {\n        storeTags(reinterpret_cast<uptr>(Block), reinterpret_cast<uptr>(Ptr));\n        storeSecondaryAllocationStackMaybe(Options, Ptr, Size);\n      }\n    }\n\n    Chunk::UnpackedHeader Header = {};\n    if (UNLIKELY(UnalignedUserPtr != UserPtr)) {\n      const uptr Offset = UserPtr - UnalignedUserPtr;\n      DCHECK_GE(Offset, 2 * sizeof(u32));\n      // The BlockMarker has no security purpose, but is specifically meant for\n      // the chunk iteration function that can be used in debugging situations.\n      // It is the only situation where we have to locate the start of a chunk\n      // based on its block address.\n      reinterpret_cast<u32 *>(Block)[0] = BlockMarker;\n      reinterpret_cast<u32 *>(Block)[1] = static_cast<u32>(Offset);\n      Header.Offset = (Offset >> MinAlignmentLog) & Chunk::OffsetMask;\n    }\n    Header.ClassId = ClassId & Chunk::ClassIdMask;\n    Header.State = Chunk::State::Allocated;\n    Header.OriginOrWasZeroed = Origin & Chunk::OriginMask;\n    Header.SizeOrUnusedBytes =\n        (ClassId ? Size : SecondaryBlockEnd - (UserPtr + Size)) &\n        Chunk::SizeOrUnusedBytesMask;\n    Chunk::storeHeader(Cookie, Ptr, &Header);\n\n    if (UNLIKELY(&__scudo_allocate_hook))\n      __scudo_allocate_hook(TaggedPtr, Size);\n\n    return TaggedPtr;\n  }\n\n  NOINLINE void deallocate(void *Ptr, Chunk::Origin Origin, uptr DeleteSize = 0,\n                           UNUSED uptr Alignment = MinAlignment) {\n    // For a deallocation, we only ensure minimal initialization, meaning thread\n    // local data will be left uninitialized for now (when using ELF TLS). The\n    // fallback cache will be used instead. This is a workaround for a situation\n    // where the only heap operation performed in a thread would be a free past\n    // the TLS destructors, ending up in initialized thread specific data never\n    // being destroyed properly. Any other heap operation will do a full init.\n    initThreadMaybe(/*MinimalInit=*/true);\n\n#ifdef GWP_ASAN_HOOKS\n    if (UNLIKELY(GuardedAlloc.pointerIsMine(Ptr))) {\n      GuardedAlloc.deallocate(Ptr);\n      return;\n    }\n#endif // GWP_ASAN_HOOKS\n\n    if (UNLIKELY(&__scudo_deallocate_hook))\n      __scudo_deallocate_hook(Ptr);\n\n    if (UNLIKELY(!Ptr))\n      return;\n    if (UNLIKELY(!isAligned(reinterpret_cast<uptr>(Ptr), MinAlignment)))\n      reportMisalignedPointer(AllocatorAction::Deallocating, Ptr);\n\n    void *TaggedPtr = Ptr;\n    Ptr = getHeaderTaggedPointer(Ptr);\n\n    Chunk::UnpackedHeader Header;\n    Chunk::loadHeader(Cookie, Ptr, &Header);\n\n    if (UNLIKELY(Header.State != Chunk::State::Allocated))\n      reportInvalidChunkState(AllocatorAction::Deallocating, Ptr);\n\n    const Options Options = Primary.Options.load();\n    if (Options.get(OptionBit::DeallocTypeMismatch)) {\n      if (UNLIKELY(Header.OriginOrWasZeroed != Origin)) {\n        // With the exception of memalign'd chunks, that can be still be free'd.\n        if (Header.OriginOrWasZeroed != Chunk::Origin::Memalign ||\n            Origin != Chunk::Origin::Malloc)\n          reportDeallocTypeMismatch(AllocatorAction::Deallocating, Ptr,\n                                    Header.OriginOrWasZeroed, Origin);\n      }\n    }\n\n    const uptr Size = getSize(Ptr, &Header);\n    if (DeleteSize && Options.get(OptionBit::DeleteSizeMismatch)) {\n      if (UNLIKELY(DeleteSize != Size))\n        reportDeleteSizeMismatch(Ptr, DeleteSize, Size);\n    }\n\n    quarantineOrDeallocateChunk(Options, TaggedPtr, &Header, Size);\n  }\n\n  void *reallocate(void *OldPtr, uptr NewSize, uptr Alignment = MinAlignment) {\n    initThreadMaybe();\n\n    const Options Options = Primary.Options.load();\n    if (UNLIKELY(NewSize >= MaxAllowedMallocSize)) {\n      if (Options.get(OptionBit::MayReturnNull))\n        return nullptr;\n      reportAllocationSizeTooBig(NewSize, 0, MaxAllowedMallocSize);\n    }\n\n    void *OldTaggedPtr = OldPtr;\n    OldPtr = getHeaderTaggedPointer(OldPtr);\n\n    // The following cases are handled by the C wrappers.\n    DCHECK_NE(OldPtr, nullptr);\n    DCHECK_NE(NewSize, 0);\n\n#ifdef GWP_ASAN_HOOKS\n    if (UNLIKELY(GuardedAlloc.pointerIsMine(OldPtr))) {\n      uptr OldSize = GuardedAlloc.getSize(OldPtr);\n      void *NewPtr = allocate(NewSize, Chunk::Origin::Malloc, Alignment);\n      if (NewPtr)\n        memcpy(NewPtr, OldPtr, (NewSize < OldSize) ? NewSize : OldSize);\n      GuardedAlloc.deallocate(OldPtr);\n      return NewPtr;\n    }\n#endif // GWP_ASAN_HOOKS\n\n    if (UNLIKELY(!isAligned(reinterpret_cast<uptr>(OldPtr), MinAlignment)))\n      reportMisalignedPointer(AllocatorAction::Reallocating, OldPtr);\n\n    Chunk::UnpackedHeader OldHeader;\n    Chunk::loadHeader(Cookie, OldPtr, &OldHeader);\n\n    if (UNLIKELY(OldHeader.State != Chunk::State::Allocated))\n      reportInvalidChunkState(AllocatorAction::Reallocating, OldPtr);\n\n    // Pointer has to be allocated with a malloc-type function. Some\n    // applications think that it is OK to realloc a memalign'ed pointer, which\n    // will trigger this check. It really isn't.\n    if (Options.get(OptionBit::DeallocTypeMismatch)) {\n      if (UNLIKELY(OldHeader.OriginOrWasZeroed != Chunk::Origin::Malloc))\n        reportDeallocTypeMismatch(AllocatorAction::Reallocating, OldPtr,\n                                  OldHeader.OriginOrWasZeroed,\n                                  Chunk::Origin::Malloc);\n    }\n\n    void *BlockBegin = getBlockBegin(OldTaggedPtr, &OldHeader);\n    uptr BlockEnd;\n    uptr OldSize;\n    const uptr ClassId = OldHeader.ClassId;\n    if (LIKELY(ClassId)) {\n      BlockEnd = reinterpret_cast<uptr>(BlockBegin) +\n                 SizeClassMap::getSizeByClassId(ClassId);\n      OldSize = OldHeader.SizeOrUnusedBytes;\n    } else {\n      BlockEnd = SecondaryT::getBlockEnd(BlockBegin);\n      OldSize = BlockEnd - (reinterpret_cast<uptr>(OldTaggedPtr) +\n                            OldHeader.SizeOrUnusedBytes);\n    }\n    // If the new chunk still fits in the previously allocated block (with a\n    // reasonable delta), we just keep the old block, and update the chunk\n    // header to reflect the size change.\n    if (reinterpret_cast<uptr>(OldTaggedPtr) + NewSize <= BlockEnd) {\n      if (NewSize > OldSize || (OldSize - NewSize) < getPageSizeCached()) {\n        Chunk::UnpackedHeader NewHeader = OldHeader;\n        NewHeader.SizeOrUnusedBytes =\n            (ClassId ? NewSize\n                     : BlockEnd -\n                           (reinterpret_cast<uptr>(OldTaggedPtr) + NewSize)) &\n            Chunk::SizeOrUnusedBytesMask;\n        Chunk::compareExchangeHeader(Cookie, OldPtr, &NewHeader, &OldHeader);\n        if (UNLIKELY(useMemoryTagging<Params>(Options))) {\n          if (ClassId) {\n            resizeTaggedChunk(reinterpret_cast<uptr>(OldTaggedPtr) + OldSize,\n                              reinterpret_cast<uptr>(OldTaggedPtr) + NewSize,\n                              BlockEnd);\n            storePrimaryAllocationStackMaybe(Options, OldPtr);\n          } else {\n            storeSecondaryAllocationStackMaybe(Options, OldPtr, NewSize);\n          }\n        }\n        return OldTaggedPtr;\n      }\n    }\n\n    // Otherwise we allocate a new one, and deallocate the old one. Some\n    // allocators will allocate an even larger chunk (by a fixed factor) to\n    // allow for potential further in-place realloc. The gains of such a trick\n    // are currently unclear.\n    void *NewPtr = allocate(NewSize, Chunk::Origin::Malloc, Alignment);\n    if (LIKELY(NewPtr)) {\n      memcpy(NewPtr, OldTaggedPtr, Min(NewSize, OldSize));\n      quarantineOrDeallocateChunk(Options, OldTaggedPtr, &OldHeader, OldSize);\n    }\n    return NewPtr;\n  }\n\n  // TODO(kostyak): disable() is currently best-effort. There are some small\n  //                windows of time when an allocation could still succeed after\n  //                this function finishes. We will revisit that later.\n  void disable() {\n    initThreadMaybe();\n#ifdef GWP_ASAN_HOOKS\n    GuardedAlloc.disable();\n#endif\n    TSDRegistry.disable();\n    Stats.disable();\n    Quarantine.disable();\n    Primary.disable();\n    Secondary.disable();\n  }\n\n  void enable() {\n    initThreadMaybe();\n    Secondary.enable();\n    Primary.enable();\n    Quarantine.enable();\n    Stats.enable();\n    TSDRegistry.enable();\n#ifdef GWP_ASAN_HOOKS\n    GuardedAlloc.enable();\n#endif\n  }\n\n  // The function returns the amount of bytes required to store the statistics,\n  // which might be larger than the amount of bytes provided. Note that the\n  // statistics buffer is not necessarily constant between calls to this\n  // function. This can be called with a null buffer or zero size for buffer\n  // sizing purposes.\n  uptr getStats(char *Buffer, uptr Size) {\n    ScopedString Str(1024);\n    disable();\n    const uptr Length = getStats(&Str) + 1;\n    enable();\n    if (Length < Size)\n      Size = Length;\n    if (Buffer && Size) {\n      memcpy(Buffer, Str.data(), Size);\n      Buffer[Size - 1] = '\\0';\n    }\n    return Length;\n  }\n\n  void printStats() {\n    ScopedString Str(1024);\n    disable();\n    getStats(&Str);\n    enable();\n    Str.output();\n  }\n\n  void releaseToOS() {\n    initThreadMaybe();\n    Primary.releaseToOS();\n    Secondary.releaseToOS();\n  }\n\n  // Iterate over all chunks and call a callback for all busy chunks located\n  // within the provided memory range. Said callback must not use this allocator\n  // or a deadlock can ensue. This fits Android's malloc_iterate() needs.\n  void iterateOverChunks(uptr Base, uptr Size, iterate_callback Callback,\n                         void *Arg) {\n    initThreadMaybe();\n    const uptr From = Base;\n    const uptr To = Base + Size;\n    bool MayHaveTaggedPrimary = allocatorSupportsMemoryTagging<Params>() &&\n                                systemSupportsMemoryTagging();\n    auto Lambda = [this, From, To, MayHaveTaggedPrimary, Callback,\n                   Arg](uptr Block) {\n      if (Block < From || Block >= To)\n        return;\n      uptr Chunk;\n      Chunk::UnpackedHeader Header;\n      if (MayHaveTaggedPrimary) {\n        // A chunk header can either have a zero tag (tagged primary) or the\n        // header tag (secondary, or untagged primary). We don't know which so\n        // try both.\n        ScopedDisableMemoryTagChecks x;\n        if (!getChunkFromBlock(Block, &Chunk, &Header) &&\n            !getChunkFromBlock(addHeaderTag(Block), &Chunk, &Header))\n          return;\n      } else {\n        if (!getChunkFromBlock(addHeaderTag(Block), &Chunk, &Header))\n          return;\n      }\n      if (Header.State == Chunk::State::Allocated) {\n        uptr TaggedChunk = Chunk;\n        if (allocatorSupportsMemoryTagging<Params>())\n          TaggedChunk = untagPointer(TaggedChunk);\n        if (useMemoryTagging<Params>(Primary.Options.load()))\n          TaggedChunk = loadTag(Chunk);\n        Callback(TaggedChunk, getSize(reinterpret_cast<void *>(Chunk), &Header),\n                 Arg);\n      }\n    };\n    Primary.iterateOverBlocks(Lambda);\n    Secondary.iterateOverBlocks(Lambda);\n#ifdef GWP_ASAN_HOOKS\n    GuardedAlloc.iterate(reinterpret_cast<void *>(Base), Size, Callback, Arg);\n#endif\n  }\n\n  bool canReturnNull() {\n    initThreadMaybe();\n    return Primary.Options.load().get(OptionBit::MayReturnNull);\n  }\n\n  bool setOption(Option O, sptr Value) {\n    initThreadMaybe();\n    if (O == Option::MemtagTuning) {\n      // Enabling odd/even tags involves a tradeoff between use-after-free\n      // detection and buffer overflow detection. Odd/even tags make it more\n      // likely for buffer overflows to be detected by increasing the size of\n      // the guaranteed \"red zone\" around the allocation, but on the other hand\n      // use-after-free is less likely to be detected because the tag space for\n      // any particular chunk is cut in half. Therefore we use this tuning\n      // setting to control whether odd/even tags are enabled.\n      if (Value == M_MEMTAG_TUNING_BUFFER_OVERFLOW)\n        Primary.Options.set(OptionBit::UseOddEvenTags);\n      else if (Value == M_MEMTAG_TUNING_UAF)\n        Primary.Options.clear(OptionBit::UseOddEvenTags);\n      return true;\n    } else {\n      // We leave it to the various sub-components to decide whether or not they\n      // want to handle the option, but we do not want to short-circuit\n      // execution if one of the setOption was to return false.\n      const bool PrimaryResult = Primary.setOption(O, Value);\n      const bool SecondaryResult = Secondary.setOption(O, Value);\n      const bool RegistryResult = TSDRegistry.setOption(O, Value);\n      return PrimaryResult && SecondaryResult && RegistryResult;\n    }\n    return false;\n  }\n\n  // Return the usable size for a given chunk. Technically we lie, as we just\n  // report the actual size of a chunk. This is done to counteract code actively\n  // writing past the end of a chunk (like sqlite3) when the usable size allows\n  // for it, which then forces realloc to copy the usable size of a chunk as\n  // opposed to its actual size.\n  uptr getUsableSize(const void *Ptr) {\n    initThreadMaybe();\n    if (UNLIKELY(!Ptr))\n      return 0;\n\n#ifdef GWP_ASAN_HOOKS\n    if (UNLIKELY(GuardedAlloc.pointerIsMine(Ptr)))\n      return GuardedAlloc.getSize(Ptr);\n#endif // GWP_ASAN_HOOKS\n\n    Ptr = getHeaderTaggedPointer(const_cast<void *>(Ptr));\n    Chunk::UnpackedHeader Header;\n    Chunk::loadHeader(Cookie, Ptr, &Header);\n    // Getting the usable size of a chunk only makes sense if it's allocated.\n    if (UNLIKELY(Header.State != Chunk::State::Allocated))\n      reportInvalidChunkState(AllocatorAction::Sizing, const_cast<void *>(Ptr));\n    return getSize(Ptr, &Header);\n  }\n\n  void getStats(StatCounters S) {\n    initThreadMaybe();\n    Stats.get(S);\n  }\n\n  // Returns true if the pointer provided was allocated by the current\n  // allocator instance, which is compliant with tcmalloc's ownership concept.\n  // A corrupted chunk will not be reported as owned, which is WAI.\n  bool isOwned(const void *Ptr) {\n    initThreadMaybe();\n#ifdef GWP_ASAN_HOOKS\n    if (GuardedAlloc.pointerIsMine(Ptr))\n      return true;\n#endif // GWP_ASAN_HOOKS\n    if (!Ptr || !isAligned(reinterpret_cast<uptr>(Ptr), MinAlignment))\n      return false;\n    Ptr = getHeaderTaggedPointer(const_cast<void *>(Ptr));\n    Chunk::UnpackedHeader Header;\n    return Chunk::isValid(Cookie, Ptr, &Header) &&\n           Header.State == Chunk::State::Allocated;\n  }\n\n  bool useMemoryTaggingTestOnly() const {\n    return useMemoryTagging<Params>(Primary.Options.load());\n  }\n  void disableMemoryTagging() {\n    // If we haven't been initialized yet, we need to initialize now in order to\n    // prevent a future call to initThreadMaybe() from enabling memory tagging\n    // based on feature detection. But don't call initThreadMaybe() because it\n    // may end up calling the allocator (via pthread_atfork, via the post-init\n    // callback), which may cause mappings to be created with memory tagging\n    // enabled.\n    TSDRegistry.initOnceMaybe(this);\n    if (allocatorSupportsMemoryTagging<Params>()) {\n      Secondary.disableMemoryTagging();\n      Primary.Options.clear(OptionBit::UseMemoryTagging);\n    }\n  }\n\n  void setTrackAllocationStacks(bool Track) {\n    initThreadMaybe();\n    if (Track)\n      Primary.Options.set(OptionBit::TrackAllocationStacks);\n    else\n      Primary.Options.clear(OptionBit::TrackAllocationStacks);\n  }\n\n  void setFillContents(FillContentsMode FillContents) {\n    initThreadMaybe();\n    Primary.Options.setFillContentsMode(FillContents);\n  }\n\n  void setAddLargeAllocationSlack(bool AddSlack) {\n    initThreadMaybe();\n    if (AddSlack)\n      Primary.Options.set(OptionBit::AddLargeAllocationSlack);\n    else\n      Primary.Options.clear(OptionBit::AddLargeAllocationSlack);\n  }\n\n  const char *getStackDepotAddress() const {\n    return reinterpret_cast<const char *>(&Depot);\n  }\n\n  const char *getRegionInfoArrayAddress() const {\n    return Primary.getRegionInfoArrayAddress();\n  }\n\n  static uptr getRegionInfoArraySize() {\n    return PrimaryT::getRegionInfoArraySize();\n  }\n\n  const char *getRingBufferAddress() const {\n    return reinterpret_cast<const char *>(&RingBuffer);\n  }\n\n  static uptr getRingBufferSize() { return sizeof(RingBuffer); }\n\n  static const uptr MaxTraceSize = 64;\n\n  static void collectTraceMaybe(const StackDepot *Depot,\n                                uintptr_t (&Trace)[MaxTraceSize], u32 Hash) {\n    uptr RingPos, Size;\n    if (!Depot->find(Hash, &RingPos, &Size))\n      return;\n    for (unsigned I = 0; I != Size && I != MaxTraceSize; ++I)\n      Trace[I] = (*Depot)[RingPos + I];\n  }\n\n  static void getErrorInfo(struct scudo_error_info *ErrorInfo,\n                           uintptr_t FaultAddr, const char *DepotPtr,\n                           const char *RegionInfoPtr, const char *RingBufferPtr,\n                           const char *Memory, const char *MemoryTags,\n                           uintptr_t MemoryAddr, size_t MemorySize) {\n    *ErrorInfo = {};\n    if (!allocatorSupportsMemoryTagging<Params>() ||\n        MemoryAddr + MemorySize < MemoryAddr)\n      return;\n\n    auto *Depot = reinterpret_cast<const StackDepot *>(DepotPtr);\n    size_t NextErrorReport = 0;\n    if (extractTag(FaultAddr) != 0)\n      getInlineErrorInfo(ErrorInfo, NextErrorReport, FaultAddr, Depot,\n                         RegionInfoPtr, Memory, MemoryTags, MemoryAddr,\n                         MemorySize);\n    getRingBufferErrorInfo(ErrorInfo, NextErrorReport, FaultAddr, Depot,\n                           RingBufferPtr);\n  }\n\nprivate:\n  using SecondaryT = MapAllocator<Params>;\n  typedef typename PrimaryT::SizeClassMap SizeClassMap;\n\n  static const uptr MinAlignmentLog = SCUDO_MIN_ALIGNMENT_LOG;\n  static const uptr MaxAlignmentLog = 24U; // 16 MB seems reasonable.\n  static const uptr MinAlignment = 1UL << MinAlignmentLog;\n  static const uptr MaxAlignment = 1UL << MaxAlignmentLog;\n  static const uptr MaxAllowedMallocSize =\n      FIRST_32_SECOND_64(1UL << 31, 1ULL << 40);\n\n  static_assert(MinAlignment >= sizeof(Chunk::PackedHeader),\n                \"Minimal alignment must at least cover a chunk header.\");\n  static_assert(!allocatorSupportsMemoryTagging<Params>() ||\n                    MinAlignment >= archMemoryTagGranuleSize(),\n                \"\");\n\n  static const u32 BlockMarker = 0x44554353U;\n\n  // These are indexes into an \"array\" of 32-bit values that store information\n  // inline with a chunk that is relevant to diagnosing memory tag faults, where\n  // 0 corresponds to the address of the user memory. This means that only\n  // negative indexes may be used. The smallest index that may be used is -2,\n  // which corresponds to 8 bytes before the user memory, because the chunk\n  // header size is 8 bytes and in allocators that support memory tagging the\n  // minimum alignment is at least the tag granule size (16 on aarch64).\n  static const sptr MemTagAllocationTraceIndex = -2;\n  static const sptr MemTagAllocationTidIndex = -1;\n\n  u32 Cookie = 0;\n  u32 QuarantineMaxChunkSize = 0;\n\n  GlobalStats Stats;\n  PrimaryT Primary;\n  SecondaryT Secondary;\n  QuarantineT Quarantine;\n  TSDRegistryT TSDRegistry;\n\n#ifdef GWP_ASAN_HOOKS\n  gwp_asan::GuardedPoolAllocator GuardedAlloc;\n#endif // GWP_ASAN_HOOKS\n\n  StackDepot Depot;\n\n  struct AllocationRingBuffer {\n    struct Entry {\n      atomic_uptr Ptr;\n      atomic_uptr AllocationSize;\n      atomic_u32 AllocationTrace;\n      atomic_u32 AllocationTid;\n      atomic_u32 DeallocationTrace;\n      atomic_u32 DeallocationTid;\n    };\n\n    atomic_uptr Pos;\n#ifdef SCUDO_FUZZ\n    static const uptr NumEntries = 2;\n#else\n    static const uptr NumEntries = 32768;\n#endif\n    Entry Entries[NumEntries];\n  };\n  AllocationRingBuffer RingBuffer = {};\n\n  // The following might get optimized out by the compiler.\n  NOINLINE void performSanityChecks() {\n    // Verify that the header offset field can hold the maximum offset. In the\n    // case of the Secondary allocator, it takes care of alignment and the\n    // offset will always be small. In the case of the Primary, the worst case\n    // scenario happens in the last size class, when the backend allocation\n    // would already be aligned on the requested alignment, which would happen\n    // to be the maximum alignment that would fit in that size class. As a\n    // result, the maximum offset will be at most the maximum alignment for the\n    // last size class minus the header size, in multiples of MinAlignment.\n    Chunk::UnpackedHeader Header = {};\n    const uptr MaxPrimaryAlignment = 1UL << getMostSignificantSetBitIndex(\n                                         SizeClassMap::MaxSize - MinAlignment);\n    const uptr MaxOffset =\n        (MaxPrimaryAlignment - Chunk::getHeaderSize()) >> MinAlignmentLog;\n    Header.Offset = MaxOffset & Chunk::OffsetMask;\n    if (UNLIKELY(Header.Offset != MaxOffset))\n      reportSanityCheckError(\"offset\");\n\n    // Verify that we can fit the maximum size or amount of unused bytes in the\n    // header. Given that the Secondary fits the allocation to a page, the worst\n    // case scenario happens in the Primary. It will depend on the second to\n    // last and last class sizes, as well as the dynamic base for the Primary.\n    // The following is an over-approximation that works for our needs.\n    const uptr MaxSizeOrUnusedBytes = SizeClassMap::MaxSize - 1;\n    Header.SizeOrUnusedBytes = MaxSizeOrUnusedBytes;\n    if (UNLIKELY(Header.SizeOrUnusedBytes != MaxSizeOrUnusedBytes))\n      reportSanityCheckError(\"size (or unused bytes)\");\n\n    const uptr LargestClassId = SizeClassMap::LargestClassId;\n    Header.ClassId = LargestClassId;\n    if (UNLIKELY(Header.ClassId != LargestClassId))\n      reportSanityCheckError(\"class ID\");\n  }\n\n  static inline void *getBlockBegin(const void *Ptr,\n                                    Chunk::UnpackedHeader *Header) {\n    return reinterpret_cast<void *>(\n        reinterpret_cast<uptr>(Ptr) - Chunk::getHeaderSize() -\n        (static_cast<uptr>(Header->Offset) << MinAlignmentLog));\n  }\n\n  // Return the size of a chunk as requested during its allocation.\n  inline uptr getSize(const void *Ptr, Chunk::UnpackedHeader *Header) {\n    const uptr SizeOrUnusedBytes = Header->SizeOrUnusedBytes;\n    if (LIKELY(Header->ClassId))\n      return SizeOrUnusedBytes;\n    if (allocatorSupportsMemoryTagging<Params>())\n      Ptr = untagPointer(const_cast<void *>(Ptr));\n    return SecondaryT::getBlockEnd(getBlockBegin(Ptr, Header)) -\n           reinterpret_cast<uptr>(Ptr) - SizeOrUnusedBytes;\n  }\n\n  void quarantineOrDeallocateChunk(Options Options, void *TaggedPtr,\n                                   Chunk::UnpackedHeader *Header, uptr Size) {\n    void *Ptr = getHeaderTaggedPointer(TaggedPtr);\n    Chunk::UnpackedHeader NewHeader = *Header;\n    // If the quarantine is disabled, the actual size of a chunk is 0 or larger\n    // than the maximum allowed, we return a chunk directly to the backend.\n    // This purposefully underflows for Size == 0.\n    const bool BypassQuarantine = !Quarantine.getCacheSize() ||\n                                  ((Size - 1) >= QuarantineMaxChunkSize) ||\n                                  !NewHeader.ClassId;\n    if (BypassQuarantine)\n      NewHeader.State = Chunk::State::Available;\n    else\n      NewHeader.State = Chunk::State::Quarantined;\n    NewHeader.OriginOrWasZeroed = useMemoryTagging<Params>(Options) &&\n                                  NewHeader.ClassId &&\n                                  !TSDRegistry.getDisableMemInit();\n    Chunk::compareExchangeHeader(Cookie, Ptr, &NewHeader, Header);\n\n    if (UNLIKELY(useMemoryTagging<Params>(Options))) {\n      u8 PrevTag = extractTag(reinterpret_cast<uptr>(TaggedPtr));\n      storeDeallocationStackMaybe(Options, Ptr, PrevTag, Size);\n      if (NewHeader.ClassId) {\n        if (!TSDRegistry.getDisableMemInit()) {\n          uptr TaggedBegin, TaggedEnd;\n          const uptr OddEvenMask = computeOddEvenMaskForPointerMaybe(\n              Options, reinterpret_cast<uptr>(getBlockBegin(Ptr, &NewHeader)),\n              NewHeader.ClassId);\n          // Exclude the previous tag so that immediate use after free is\n          // detected 100% of the time.\n          setRandomTag(Ptr, Size, OddEvenMask | (1UL << PrevTag), &TaggedBegin,\n                       &TaggedEnd);\n        }\n      }\n    }\n    if (BypassQuarantine) {\n      if (allocatorSupportsMemoryTagging<Params>())\n        Ptr = untagPointer(Ptr);\n      void *BlockBegin = getBlockBegin(Ptr, &NewHeader);\n      const uptr ClassId = NewHeader.ClassId;\n      if (LIKELY(ClassId)) {\n        bool UnlockRequired;\n        auto *TSD = TSDRegistry.getTSDAndLock(&UnlockRequired);\n        TSD->Cache.deallocate(ClassId, BlockBegin);\n        if (UnlockRequired)\n          TSD->unlock();\n      } else {\n        if (UNLIKELY(useMemoryTagging<Params>(Options)))\n          storeTags(reinterpret_cast<uptr>(BlockBegin),\n                    reinterpret_cast<uptr>(Ptr));\n        Secondary.deallocate(Options, BlockBegin);\n      }\n    } else {\n      bool UnlockRequired;\n      auto *TSD = TSDRegistry.getTSDAndLock(&UnlockRequired);\n      Quarantine.put(&TSD->QuarantineCache,\n                     QuarantineCallback(*this, TSD->Cache), Ptr, Size);\n      if (UnlockRequired)\n        TSD->unlock();\n    }\n  }\n\n  bool getChunkFromBlock(uptr Block, uptr *Chunk,\n                         Chunk::UnpackedHeader *Header) {\n    *Chunk =\n        Block + getChunkOffsetFromBlock(reinterpret_cast<const char *>(Block));\n    return Chunk::isValid(Cookie, reinterpret_cast<void *>(*Chunk), Header);\n  }\n\n  static uptr getChunkOffsetFromBlock(const char *Block) {\n    u32 Offset = 0;\n    if (reinterpret_cast<const u32 *>(Block)[0] == BlockMarker)\n      Offset = reinterpret_cast<const u32 *>(Block)[1];\n    return Offset + Chunk::getHeaderSize();\n  }\n\n  void *prepareTaggedChunk(void *Ptr, uptr Size, uptr ExcludeMask,\n                           uptr BlockEnd) {\n    // Prepare the granule before the chunk to store the chunk header by setting\n    // its tag to 0. Normally its tag will already be 0, but in the case where a\n    // chunk holding a low alignment allocation is reused for a higher alignment\n    // allocation, the chunk may already have a non-zero tag from the previous\n    // allocation.\n    storeTag(reinterpret_cast<uptr>(Ptr) - archMemoryTagGranuleSize());\n\n    uptr TaggedBegin, TaggedEnd;\n    setRandomTag(Ptr, Size, ExcludeMask, &TaggedBegin, &TaggedEnd);\n\n    // Finally, set the tag of the granule past the end of the allocation to 0,\n    // to catch linear overflows even if a previous larger allocation used the\n    // same block and tag. Only do this if the granule past the end is in our\n    // block, because this would otherwise lead to a SEGV if the allocation\n    // covers the entire block and our block is at the end of a mapping. The tag\n    // of the next block's header granule will be set to 0, so it will serve the\n    // purpose of catching linear overflows in this case.\n    uptr UntaggedEnd = untagPointer(TaggedEnd);\n    if (UntaggedEnd != BlockEnd)\n      storeTag(UntaggedEnd);\n    return reinterpret_cast<void *>(TaggedBegin);\n  }\n\n  void resizeTaggedChunk(uptr OldPtr, uptr NewPtr, uptr BlockEnd) {\n    uptr RoundOldPtr = roundUpTo(OldPtr, archMemoryTagGranuleSize());\n    uptr RoundNewPtr;\n    if (RoundOldPtr >= NewPtr) {\n      // If the allocation is shrinking we just need to set the tag past the end\n      // of the allocation to 0. See explanation in prepareTaggedChunk above.\n      RoundNewPtr = roundUpTo(NewPtr, archMemoryTagGranuleSize());\n    } else {\n      // Set the memory tag of the region\n      // [RoundOldPtr, roundUpTo(NewPtr, archMemoryTagGranuleSize()))\n      // to the pointer tag stored in OldPtr.\n      RoundNewPtr = storeTags(RoundOldPtr, NewPtr);\n    }\n\n    uptr UntaggedNewPtr = untagPointer(RoundNewPtr);\n    if (UntaggedNewPtr != BlockEnd)\n      storeTag(UntaggedNewPtr);\n  }\n\n  void storePrimaryAllocationStackMaybe(Options Options, void *Ptr) {\n    if (!UNLIKELY(Options.get(OptionBit::TrackAllocationStacks)))\n      return;\n    auto *Ptr32 = reinterpret_cast<u32 *>(Ptr);\n    Ptr32[MemTagAllocationTraceIndex] = collectStackTrace();\n    Ptr32[MemTagAllocationTidIndex] = getThreadID();\n  }\n\n  void storeRingBufferEntry(void *Ptr, u32 AllocationTrace, u32 AllocationTid,\n                            uptr AllocationSize, u32 DeallocationTrace,\n                            u32 DeallocationTid) {\n    uptr Pos = atomic_fetch_add(&RingBuffer.Pos, 1, memory_order_relaxed);\n    typename AllocationRingBuffer::Entry *Entry =\n        &RingBuffer.Entries[Pos % AllocationRingBuffer::NumEntries];\n\n    // First invalidate our entry so that we don't attempt to interpret a\n    // partially written state in getSecondaryErrorInfo(). The fences below\n    // ensure that the compiler does not move the stores to Ptr in between the\n    // stores to the other fields.\n    atomic_store_relaxed(&Entry->Ptr, 0);\n\n    __atomic_signal_fence(__ATOMIC_SEQ_CST);\n    atomic_store_relaxed(&Entry->AllocationTrace, AllocationTrace);\n    atomic_store_relaxed(&Entry->AllocationTid, AllocationTid);\n    atomic_store_relaxed(&Entry->AllocationSize, AllocationSize);\n    atomic_store_relaxed(&Entry->DeallocationTrace, DeallocationTrace);\n    atomic_store_relaxed(&Entry->DeallocationTid, DeallocationTid);\n    __atomic_signal_fence(__ATOMIC_SEQ_CST);\n\n    atomic_store_relaxed(&Entry->Ptr, reinterpret_cast<uptr>(Ptr));\n  }\n\n  void storeSecondaryAllocationStackMaybe(Options Options, void *Ptr,\n                                          uptr Size) {\n    if (!UNLIKELY(Options.get(OptionBit::TrackAllocationStacks)))\n      return;\n\n    u32 Trace = collectStackTrace();\n    u32 Tid = getThreadID();\n\n    auto *Ptr32 = reinterpret_cast<u32 *>(Ptr);\n    Ptr32[MemTagAllocationTraceIndex] = Trace;\n    Ptr32[MemTagAllocationTidIndex] = Tid;\n\n    storeRingBufferEntry(untagPointer(Ptr), Trace, Tid, Size, 0, 0);\n  }\n\n  void storeDeallocationStackMaybe(Options Options, void *Ptr, u8 PrevTag,\n                                   uptr Size) {\n    if (!UNLIKELY(Options.get(OptionBit::TrackAllocationStacks)))\n      return;\n\n    auto *Ptr32 = reinterpret_cast<u32 *>(Ptr);\n    u32 AllocationTrace = Ptr32[MemTagAllocationTraceIndex];\n    u32 AllocationTid = Ptr32[MemTagAllocationTidIndex];\n\n    u32 DeallocationTrace = collectStackTrace();\n    u32 DeallocationTid = getThreadID();\n\n    storeRingBufferEntry(addFixedTag(untagPointer(Ptr), PrevTag),\n                         AllocationTrace, AllocationTid, Size,\n                         DeallocationTrace, DeallocationTid);\n  }\n\n  static const size_t NumErrorReports =\n      sizeof(((scudo_error_info *)0)->reports) /\n      sizeof(((scudo_error_info *)0)->reports[0]);\n\n  static void getInlineErrorInfo(struct scudo_error_info *ErrorInfo,\n                                 size_t &NextErrorReport, uintptr_t FaultAddr,\n                                 const StackDepot *Depot,\n                                 const char *RegionInfoPtr, const char *Memory,\n                                 const char *MemoryTags, uintptr_t MemoryAddr,\n                                 size_t MemorySize) {\n    uptr UntaggedFaultAddr = untagPointer(FaultAddr);\n    u8 FaultAddrTag = extractTag(FaultAddr);\n    BlockInfo Info =\n        PrimaryT::findNearestBlock(RegionInfoPtr, UntaggedFaultAddr);\n\n    auto GetGranule = [&](uptr Addr, const char **Data, uint8_t *Tag) -> bool {\n      if (Addr < MemoryAddr || Addr + archMemoryTagGranuleSize() < Addr ||\n          Addr + archMemoryTagGranuleSize() > MemoryAddr + MemorySize)\n        return false;\n      *Data = &Memory[Addr - MemoryAddr];\n      *Tag = static_cast<u8>(\n          MemoryTags[(Addr - MemoryAddr) / archMemoryTagGranuleSize()]);\n      return true;\n    };\n\n    auto ReadBlock = [&](uptr Addr, uptr *ChunkAddr,\n                         Chunk::UnpackedHeader *Header, const u32 **Data,\n                         u8 *Tag) {\n      const char *BlockBegin;\n      u8 BlockBeginTag;\n      if (!GetGranule(Addr, &BlockBegin, &BlockBeginTag))\n        return false;\n      uptr ChunkOffset = getChunkOffsetFromBlock(BlockBegin);\n      *ChunkAddr = Addr + ChunkOffset;\n\n      const char *ChunkBegin;\n      if (!GetGranule(*ChunkAddr, &ChunkBegin, Tag))\n        return false;\n      *Header = *reinterpret_cast<const Chunk::UnpackedHeader *>(\n          ChunkBegin - Chunk::getHeaderSize());\n      *Data = reinterpret_cast<const u32 *>(ChunkBegin);\n      return true;\n    };\n\n    if (NextErrorReport == NumErrorReports)\n      return;\n\n    auto CheckOOB = [&](uptr BlockAddr) {\n      if (BlockAddr < Info.RegionBegin || BlockAddr >= Info.RegionEnd)\n        return false;\n\n      uptr ChunkAddr;\n      Chunk::UnpackedHeader Header;\n      const u32 *Data;\n      uint8_t Tag;\n      if (!ReadBlock(BlockAddr, &ChunkAddr, &Header, &Data, &Tag) ||\n          Header.State != Chunk::State::Allocated || Tag != FaultAddrTag)\n        return false;\n\n      auto *R = &ErrorInfo->reports[NextErrorReport++];\n      R->error_type =\n          UntaggedFaultAddr < ChunkAddr ? BUFFER_UNDERFLOW : BUFFER_OVERFLOW;\n      R->allocation_address = ChunkAddr;\n      R->allocation_size = Header.SizeOrUnusedBytes;\n      collectTraceMaybe(Depot, R->allocation_trace,\n                        Data[MemTagAllocationTraceIndex]);\n      R->allocation_tid = Data[MemTagAllocationTidIndex];\n      return NextErrorReport == NumErrorReports;\n    };\n\n    if (CheckOOB(Info.BlockBegin))\n      return;\n\n    // Check for OOB in the 30 surrounding blocks. Beyond that we are likely to\n    // hit false positives.\n    for (int I = 1; I != 16; ++I)\n      if (CheckOOB(Info.BlockBegin + I * Info.BlockSize) ||\n          CheckOOB(Info.BlockBegin - I * Info.BlockSize))\n        return;\n  }\n\n  static void getRingBufferErrorInfo(struct scudo_error_info *ErrorInfo,\n                                     size_t &NextErrorReport,\n                                     uintptr_t FaultAddr,\n                                     const StackDepot *Depot,\n                                     const char *RingBufferPtr) {\n    auto *RingBuffer =\n        reinterpret_cast<const AllocationRingBuffer *>(RingBufferPtr);\n    uptr Pos = atomic_load_relaxed(&RingBuffer->Pos);\n\n    for (uptr I = Pos - 1; I != Pos - 1 - AllocationRingBuffer::NumEntries &&\n                           NextErrorReport != NumErrorReports;\n         --I) {\n      auto *Entry = &RingBuffer->Entries[I % AllocationRingBuffer::NumEntries];\n      uptr EntryPtr = atomic_load_relaxed(&Entry->Ptr);\n      uptr UntaggedEntryPtr = untagPointer(EntryPtr);\n      uptr EntrySize = atomic_load_relaxed(&Entry->AllocationSize);\n      if (!EntryPtr || FaultAddr < EntryPtr - getPageSizeCached() ||\n          FaultAddr >= EntryPtr + EntrySize + getPageSizeCached())\n        continue;\n\n      u32 AllocationTrace = atomic_load_relaxed(&Entry->AllocationTrace);\n      u32 AllocationTid = atomic_load_relaxed(&Entry->AllocationTid);\n      u32 DeallocationTrace = atomic_load_relaxed(&Entry->DeallocationTrace);\n      u32 DeallocationTid = atomic_load_relaxed(&Entry->DeallocationTid);\n\n      // For UAF the ring buffer will contain two entries, one for the\n      // allocation and another for the deallocation. Don't report buffer\n      // overflow/underflow using the allocation entry if we have already\n      // collected a report from the deallocation entry.\n      if (!DeallocationTrace) {\n        bool Found = false;\n        for (uptr J = 0; J != NextErrorReport; ++J) {\n          if (ErrorInfo->reports[J].allocation_address == UntaggedEntryPtr) {\n            Found = true;\n            break;\n          }\n        }\n        if (Found)\n          continue;\n      }\n\n      auto *R = &ErrorInfo->reports[NextErrorReport++];\n      if (DeallocationTid)\n        R->error_type = USE_AFTER_FREE;\n      else if (FaultAddr < EntryPtr)\n        R->error_type = BUFFER_UNDERFLOW;\n      else\n        R->error_type = BUFFER_OVERFLOW;\n\n      R->allocation_address = UntaggedEntryPtr;\n      R->allocation_size = EntrySize;\n      collectTraceMaybe(Depot, R->allocation_trace, AllocationTrace);\n      R->allocation_tid = AllocationTid;\n      collectTraceMaybe(Depot, R->deallocation_trace, DeallocationTrace);\n      R->deallocation_tid = DeallocationTid;\n    }\n  }\n\n  uptr getStats(ScopedString *Str) {\n    Primary.getStats(Str);\n    Secondary.getStats(Str);\n    Quarantine.getStats(Str);\n    return Str->length();\n  }\n};\n\n} // namespace scudo\n\n#endif // SCUDO_COMBINED_H_\n"}, "8": {"id": 8, "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/scudo/standalone/flags.h", "content": "//===-- flags.h -------------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef SCUDO_FLAGS_H_\n#define SCUDO_FLAGS_H_\n\n#include \"internal_defs.h\"\n\nnamespace scudo {\n\nstruct Flags {\n#define SCUDO_FLAG(Type, Name, DefaultValue, Description) Type Name;\n#include \"flags.inc\"\n#undef SCUDO_FLAG\n\n#ifdef GWP_ASAN_HOOKS\n#define GWP_ASAN_OPTION(Type, Name, DefaultValue, Description)                 \\\n  Type GWP_ASAN_##Name;\n#include \"gwp_asan/options.inc\"\n#undef GWP_ASAN_OPTION\n#endif // GWP_ASAN_HOOKS\n\n  void setDefaults();\n};\n\nFlags *getFlags();\nvoid initFlags();\nclass FlagParser;\nvoid registerFlags(FlagParser *Parser, Flags *F);\n\n} // namespace scudo\n\n#endif // SCUDO_FLAGS_H_\n"}, "9": {"id": 9, "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/scudo/standalone/flags_parser.h", "content": "//===-- flags_parser.h ------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef SCUDO_FLAGS_PARSER_H_\n#define SCUDO_FLAGS_PARSER_H_\n\n#include \"report.h\"\n#include \"string_utils.h\"\n\n#include <stddef.h>\n\nnamespace scudo {\n\nenum class FlagType : u8 {\n  FT_bool,\n  FT_int,\n};\n\nclass FlagParser {\npublic:\n  void registerFlag(const char *Name, const char *Desc, FlagType Type,\n                    void *Var);\n  void parseString(const char *S);\n  void printFlagDescriptions();\n\nprivate:\n  static const u32 MaxFlags = 20;\n  struct Flag {\n    const char *Name;\n    const char *Desc;\n    FlagType Type;\n    void *Var;\n  } Flags[MaxFlags];\n\n  u32 NumberOfFlags = 0;\n  const char *Buffer = nullptr;\n  uptr Pos = 0;\n\n  void reportFatalError(const char *Error);\n  void skipWhitespace();\n  void parseFlags();\n  void parseFlag();\n  bool runHandler(const char *Name, const char *Value);\n};\n\nvoid reportUnrecognizedFlags();\n\n} // namespace scudo\n\n#endif // SCUDO_FLAGS_PARSER_H_\n"}, "13": {"id": 13, "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/scudo/standalone/list.h", "content": "//===-- list.h --------------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef SCUDO_LIST_H_\n#define SCUDO_LIST_H_\n\n#include \"internal_defs.h\"\n\nnamespace scudo {\n\n// Intrusive POD singly and doubly linked list.\n// An object with all zero fields should represent a valid empty list. clear()\n// should be called on all non-zero-initialized objects before using.\n\ntemplate <class T> class IteratorBase {\npublic:\n  explicit IteratorBase(T *CurrentT) : Current(CurrentT) {}\n  IteratorBase &operator++() {\n    Current = Current->Next;\n    return *this;\n  }\n  bool operator!=(IteratorBase Other) const { return Current != Other.Current; }\n  T &operator*() { return *Current; }\n\nprivate:\n  T *Current;\n};\n\ntemplate <class T> struct IntrusiveList {\n  bool empty() const { return Size == 0; }\n  uptr size() const { return Size; }\n\n  T *front() { return First; }\n  const T *front() const { return First; }\n  T *back() { return Last; }\n  const T *back() const { return Last; }\n\n  void clear() {\n    First = Last = nullptr;\n    Size = 0;\n  }\n\n  typedef IteratorBase<T> Iterator;\n  typedef IteratorBase<const T> ConstIterator;\n\n  Iterator begin() { return Iterator(First); }\n  Iterator end() { return Iterator(nullptr); }\n\n  ConstIterator begin() const { return ConstIterator(First); }\n  ConstIterator end() const { return ConstIterator(nullptr); }\n\n  void checkConsistency() const;\n\nprotected:\n  uptr Size = 0;\n  T *First = nullptr;\n  T *Last = nullptr;\n};\n\ntemplate <class T> void IntrusiveList<T>::checkConsistency() const {\n  if (Size == 0) {\n    CHECK_EQ(First, nullptr);\n    CHECK_EQ(Last, nullptr);\n  } else {\n    uptr Count = 0;\n    for (T *I = First;; I = I->Next) {\n      Count++;\n      if (I == Last)\n        break;\n    }\n    CHECK_EQ(this->size(), Count);\n    CHECK_EQ(Last->Next, nullptr);\n  }\n}\n\ntemplate <class T> struct SinglyLinkedList : public IntrusiveList<T> {\n  using IntrusiveList<T>::First;\n  using IntrusiveList<T>::Last;\n  using IntrusiveList<T>::Size;\n  using IntrusiveList<T>::empty;\n\n  void push_back(T *X) {\n    X->Next = nullptr;\n    if (empty())\n      First = X;\n    else\n      Last->Next = X;\n    Last = X;\n    Size++;\n  }\n\n  void push_front(T *X) {\n    if (empty())\n      Last = X;\n    X->Next = First;\n    First = X;\n    Size++;\n  }\n\n  void pop_front() {\n    DCHECK(!empty());\n    First = First->Next;\n    if (!First)\n      Last = nullptr;\n    Size--;\n  }\n\n  void extract(T *Prev, T *X) {\n    DCHECK(!empty());\n    DCHECK_NE(Prev, nullptr);\n    DCHECK_NE(X, nullptr);\n    DCHECK_EQ(Prev->Next, X);\n    Prev->Next = X->Next;\n    if (Last == X)\n      Last = Prev;\n    Size--;\n  }\n\n  void append_back(SinglyLinkedList<T> *L) {\n    DCHECK_NE(this, L);\n    if (L->empty())\n      return;\n    if (empty()) {\n      *this = *L;\n    } else {\n      Last->Next = L->First;\n      Last = L->Last;\n      Size += L->size();\n    }\n    L->clear();\n  }\n};\n\ntemplate <class T> struct DoublyLinkedList : IntrusiveList<T> {\n  using IntrusiveList<T>::First;\n  using IntrusiveList<T>::Last;\n  using IntrusiveList<T>::Size;\n  using IntrusiveList<T>::empty;\n\n  void push_front(T *X) {\n    X->Prev = nullptr;\n    if (empty()) {\n      Last = X;\n    } else {\n      DCHECK_EQ(First->Prev, nullptr);\n      First->Prev = X;\n    }\n    X->Next = First;\n    First = X;\n    Size++;\n  }\n\n  // Inserts X before Y.\n  void insert(T *X, T *Y) {\n    if (Y == First)\n      return push_front(X);\n    T *Prev = Y->Prev;\n    // This is a hard CHECK to ensure consistency in the event of an intentional\n    // corruption of Y->Prev, to prevent a potential write-{4,8}.\n    CHECK_EQ(Prev->Next, Y);\n    Prev->Next = X;\n    X->Prev = Prev;\n    X->Next = Y;\n    Y->Prev = X;\n    Size++;\n  }\n\n  void push_back(T *X) {\n    X->Next = nullptr;\n    if (empty()) {\n      First = X;\n    } else {\n      DCHECK_EQ(Last->Next, nullptr);\n      Last->Next = X;\n    }\n    X->Prev = Last;\n    Last = X;\n    Size++;\n  }\n\n  void pop_front() {\n    DCHECK(!empty());\n    First = First->Next;\n    if (!First)\n      Last = nullptr;\n    else\n      First->Prev = nullptr;\n    Size--;\n  }\n\n  // The consistency of the adjacent links is aggressively checked in order to\n  // catch potential corruption attempts, that could yield a mirrored\n  // write-{4,8} primitive. nullptr checks are deemed less vital.\n  void remove(T *X) {\n    T *Prev = X->Prev;\n    T *Next = X->Next;\n    if (Prev) {\n      CHECK_EQ(Prev->Next, X);\n      Prev->Next = Next;\n    }\n    if (Next) {\n      CHECK_EQ(Next->Prev, X);\n      Next->Prev = Prev;\n    }\n    if (First == X) {\n      DCHECK_EQ(Prev, nullptr);\n      First = Next;\n    } else {\n      DCHECK_NE(Prev, nullptr);\n    }\n    if (Last == X) {\n      DCHECK_EQ(Next, nullptr);\n      Last = Prev;\n    } else {\n      DCHECK_NE(Next, nullptr);\n    }\n    Size--;\n  }\n};\n\n} // namespace scudo\n\n#endif // SCUDO_LIST_H_\n"}, "14": {"id": 14, "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/scudo/standalone/local_cache.h", "content": "//===-- local_cache.h -------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef SCUDO_LOCAL_CACHE_H_\n#define SCUDO_LOCAL_CACHE_H_\n\n#include \"internal_defs.h\"\n#include \"report.h\"\n#include \"stats.h\"\n\nnamespace scudo {\n\ntemplate <class SizeClassAllocator> struct SizeClassAllocatorLocalCache {\n  typedef typename SizeClassAllocator::SizeClassMap SizeClassMap;\n  typedef typename SizeClassAllocator::CompactPtrT CompactPtrT;\n\n  struct TransferBatch {\n    static const u32 MaxNumCached = SizeClassMap::MaxNumCachedHint;\n    void setFromArray(CompactPtrT *Array, u32 N) {\n      DCHECK_LE(N, MaxNumCached);\n      Count = N;\n      memcpy(Batch, Array, sizeof(Batch[0]) * Count);\n    }\n    void clear() { Count = 0; }\n    void add(CompactPtrT P) {\n      DCHECK_LT(Count, MaxNumCached);\n      Batch[Count++] = P;\n    }\n    void copyToArray(CompactPtrT *Array) const {\n      memcpy(Array, Batch, sizeof(Batch[0]) * Count);\n    }\n    u32 getCount() const { return Count; }\n    CompactPtrT get(u32 I) const {\n      DCHECK_LE(I, Count);\n      return Batch[I];\n    }\n    static u32 getMaxCached(uptr Size) {\n      return Min(MaxNumCached, SizeClassMap::getMaxCachedHint(Size));\n    }\n    TransferBatch *Next;\n\n  private:\n    u32 Count;\n    CompactPtrT Batch[MaxNumCached];\n  };\n\n  void initLinkerInitialized(GlobalStats *S, SizeClassAllocator *A) {\n    Stats.initLinkerInitialized();\n    if (LIKELY(S))\n      S->link(&Stats);\n    Allocator = A;\n  }\n\n  void init(GlobalStats *S, SizeClassAllocator *A) {\n    memset(this, 0, sizeof(*this));\n    initLinkerInitialized(S, A);\n  }\n\n  void destroy(GlobalStats *S) {\n    drain();\n    if (LIKELY(S))\n      S->unlink(&Stats);\n  }\n\n  void *allocate(uptr ClassId) {\n    DCHECK_LT(ClassId, NumClasses);\n    PerClass *C = &PerClassArray[ClassId];\n    if (C->Count == 0) {\n      if (UNLIKELY(!refill(C, ClassId)))\n        return nullptr;\n      DCHECK_GT(C->Count, 0);\n    }\n    // We read ClassSize first before accessing Chunks because it's adjacent to\n    // Count, while Chunks might be further off (depending on Count). That keeps\n    // the memory accesses in close quarters.\n    const uptr ClassSize = C->ClassSize;\n    CompactPtrT CompactP = C->Chunks[--C->Count];\n    Stats.add(StatAllocated, ClassSize);\n    Stats.sub(StatFree, ClassSize);\n    return Allocator->decompactPtr(ClassId, CompactP);\n  }\n\n  void deallocate(uptr ClassId, void *P) {\n    CHECK_LT(ClassId, NumClasses);\n    PerClass *C = &PerClassArray[ClassId];\n    // We still have to initialize the cache in the event that the first heap\n    // operation in a thread is a deallocation.\n    initCacheMaybe(C);\n    if (C->Count == C->MaxCount)\n      drain(C, ClassId);\n    // See comment in allocate() about memory accesses.\n    const uptr ClassSize = C->ClassSize;\n    C->Chunks[C->Count++] =\n        Allocator->compactPtr(ClassId, reinterpret_cast<uptr>(P));\n    Stats.sub(StatAllocated, ClassSize);\n    Stats.add(StatFree, ClassSize);\n  }\n\n  bool isEmpty() const {\n    for (uptr I = 0; I < NumClasses; ++I)\n      if (PerClassArray[I].Count)\n        return false;\n    return true;\n  }\n\n  void drain() {\n    // Drain BatchClassId last as createBatch can refill it.\n    for (uptr I = 0; I < NumClasses; ++I) {\n      if (I == BatchClassId)\n        continue;\n      while (PerClassArray[I].Count > 0)\n        drain(&PerClassArray[I], I);\n    }\n    while (PerClassArray[BatchClassId].Count > 0)\n      drain(&PerClassArray[BatchClassId], BatchClassId);\n    DCHECK(isEmpty());\n  }\n\n  TransferBatch *createBatch(uptr ClassId, void *B) {\n    if (ClassId != BatchClassId)\n      B = allocate(BatchClassId);\n    return reinterpret_cast<TransferBatch *>(B);\n  }\n\n  LocalStats &getStats() { return Stats; }\n\nprivate:\n  static const uptr NumClasses = SizeClassMap::NumClasses;\n  static const uptr BatchClassId = SizeClassMap::BatchClassId;\n  struct PerClass {\n    u32 Count;\n    u32 MaxCount;\n    uptr ClassSize;\n    CompactPtrT Chunks[2 * TransferBatch::MaxNumCached];\n  };\n  PerClass PerClassArray[NumClasses] = {};\n  LocalStats Stats;\n  SizeClassAllocator *Allocator = nullptr;\n\n  ALWAYS_INLINE void initCacheMaybe(PerClass *C) {\n    if (LIKELY(C->MaxCount))\n      return;\n    initCache();\n    DCHECK_NE(C->MaxCount, 0U);\n  }\n\n  NOINLINE void initCache() {\n    for (uptr I = 0; I < NumClasses; I++) {\n      PerClass *P = &PerClassArray[I];\n      const uptr Size = SizeClassAllocator::getSizeByClassId(I);\n      P->MaxCount = 2 * TransferBatch::getMaxCached(Size);\n      P->ClassSize = Size;\n    }\n  }\n\n  void destroyBatch(uptr ClassId, void *B) {\n    if (ClassId != BatchClassId)\n      deallocate(BatchClassId, B);\n  }\n\n  NOINLINE bool refill(PerClass *C, uptr ClassId) {\n    initCacheMaybe(C);\n    TransferBatch *B = Allocator->popBatch(this, ClassId);\n    if (UNLIKELY(!B))\n      return false;\n    DCHECK_GT(B->getCount(), 0);\n    C->Count = B->getCount();\n    B->copyToArray(C->Chunks);\n    B->clear();\n    destroyBatch(ClassId, B);\n    return true;\n  }\n\n  NOINLINE void drain(PerClass *C, uptr ClassId) {\n    const u32 Count = Min(C->MaxCount / 2, C->Count);\n    TransferBatch *B =\n        createBatch(ClassId, Allocator->decompactPtr(ClassId, C->Chunks[0]));\n    if (UNLIKELY(!B))\n      reportOutOfMemory(SizeClassAllocator::getSizeByClassId(BatchClassId));\n    B->setFromArray(&C->Chunks[0], Count);\n    C->Count -= Count;\n    for (uptr I = 0; I < C->Count; I++)\n      C->Chunks[I] = C->Chunks[I + Count];\n    Allocator->pushBatch(ClassId, B);\n  }\n};\n\n} // namespace scudo\n\n#endif // SCUDO_LOCAL_CACHE_H_\n"}, "15": {"id": 15, "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/scudo/standalone/memtag.h", "content": "//===-- memtag.h ------------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef SCUDO_MEMTAG_H_\n#define SCUDO_MEMTAG_H_\n\n#include \"internal_defs.h\"\n\n#if SCUDO_LINUX\n#include <sys/auxv.h>\n#include <sys/prctl.h>\n#endif\n\nnamespace scudo {\n\n#if defined(__aarch64__) || defined(SCUDO_FUZZ)\n\n// We assume that Top-Byte Ignore is enabled if the architecture supports memory\n// tagging. Not all operating systems enable TBI, so we only claim architectural\n// support for memory tagging if the operating system enables TBI.\n#if SCUDO_LINUX && !defined(SCUDO_DISABLE_TBI)\ninline constexpr bool archSupportsMemoryTagging() { return true; }\n#else\ninline constexpr bool archSupportsMemoryTagging() { return false; }\n#endif\n\ninline constexpr uptr archMemoryTagGranuleSize() { return 16; }\n\ninline uptr untagPointer(uptr Ptr) { return Ptr & ((1ULL << 56) - 1); }\n\ninline uint8_t extractTag(uptr Ptr) { return (Ptr >> 56) & 0xf; }\n\n#else\n\ninline constexpr bool archSupportsMemoryTagging() { return false; }\n\ninline uptr archMemoryTagGranuleSize() {\n  UNREACHABLE(\"memory tagging not supported\");\n}\n\ninline uptr untagPointer(uptr Ptr) {\n  (void)Ptr;\n  UNREACHABLE(\"memory tagging not supported\");\n}\n\ninline uint8_t extractTag(uptr Ptr) {\n  (void)Ptr;\n  UNREACHABLE(\"memory tagging not supported\");\n}\n\n#endif\n\n#if defined(__aarch64__)\n\n#if SCUDO_LINUX\n\ninline bool systemSupportsMemoryTagging() {\n#ifndef HWCAP2_MTE\n#define HWCAP2_MTE (1 << 18)\n#endif\n  return getauxval(AT_HWCAP2) & HWCAP2_MTE;\n}\n\ninline bool systemDetectsMemoryTagFaultsTestOnly() {\n#ifndef PR_GET_TAGGED_ADDR_CTRL\n#define PR_GET_TAGGED_ADDR_CTRL 56\n#endif\n#ifndef PR_MTE_TCF_SHIFT\n#define PR_MTE_TCF_SHIFT 1\n#endif\n#ifndef PR_MTE_TCF_NONE\n#define PR_MTE_TCF_NONE (0UL << PR_MTE_TCF_SHIFT)\n#endif\n#ifndef PR_MTE_TCF_MASK\n#define PR_MTE_TCF_MASK (3UL << PR_MTE_TCF_SHIFT)\n#endif\n  return (static_cast<unsigned long>(\n              prctl(PR_GET_TAGGED_ADDR_CTRL, 0, 0, 0, 0)) &\n          PR_MTE_TCF_MASK) != PR_MTE_TCF_NONE;\n}\n\n#else // !SCUDO_LINUX\n\ninline bool systemSupportsMemoryTagging() { return false; }\n\ninline bool systemDetectsMemoryTagFaultsTestOnly() { return false; }\n\n#endif // SCUDO_LINUX\n\ninline void disableMemoryTagChecksTestOnly() {\n  __asm__ __volatile__(\n      R\"(\n      .arch_extension memtag\n      msr tco, #1\n      )\");\n}\n\ninline void enableMemoryTagChecksTestOnly() {\n  __asm__ __volatile__(\n      R\"(\n      .arch_extension memtag\n      msr tco, #0\n      )\");\n}\n\nclass ScopedDisableMemoryTagChecks {\n  size_t PrevTCO;\n\npublic:\n  ScopedDisableMemoryTagChecks() {\n    __asm__ __volatile__(\n        R\"(\n        .arch_extension memtag\n        mrs %0, tco\n        msr tco, #1\n        )\"\n        : \"=r\"(PrevTCO));\n  }\n\n  ~ScopedDisableMemoryTagChecks() {\n    __asm__ __volatile__(\n        R\"(\n        .arch_extension memtag\n        msr tco, %0\n        )\"\n        :\n        : \"r\"(PrevTCO));\n  }\n};\n\ninline uptr selectRandomTag(uptr Ptr, uptr ExcludeMask) {\n  uptr TaggedPtr;\n  __asm__ __volatile__(\n      R\"(\n      .arch_extension memtag\n      irg %[TaggedPtr], %[Ptr], %[ExcludeMask]\n      )\"\n      : [TaggedPtr] \"=r\"(TaggedPtr)\n      : [Ptr] \"r\"(Ptr), [ExcludeMask] \"r\"(ExcludeMask));\n  return TaggedPtr;\n}\n\ninline uptr addFixedTag(uptr Ptr, uptr Tag) { return Ptr | (Tag << 56); }\n\ninline uptr storeTags(uptr Begin, uptr End) {\n  DCHECK(Begin % 16 == 0);\n  uptr LineSize, Next, Tmp;\n  __asm__ __volatile__(\n      R\"(\n    .arch_extension memtag\n\n    // Compute the cache line size in bytes (DCZID_EL0 stores it as the log2\n    // of the number of 4-byte words) and bail out to the slow path if DCZID_EL0\n    // indicates that the DC instructions are unavailable.\n    DCZID .req %[Tmp]\n    mrs DCZID, dczid_el0\n    tbnz DCZID, #4, 3f\n    and DCZID, DCZID, #15\n    mov %[LineSize], #4\n    lsl %[LineSize], %[LineSize], DCZID\n    .unreq DCZID\n\n    // Our main loop doesn't handle the case where we don't need to perform any\n    // DC GZVA operations. If the size of our tagged region is less than\n    // twice the cache line size, bail out to the slow path since it's not\n    // guaranteed that we'll be able to do a DC GZVA.\n    Size .req %[Tmp]\n    sub Size, %[End], %[Cur]\n    cmp Size, %[LineSize], lsl #1\n    b.lt 3f\n    .unreq Size\n\n    LineMask .req %[Tmp]\n    sub LineMask, %[LineSize], #1\n\n    // STZG until the start of the next cache line.\n    orr %[Next], %[Cur], LineMask\n  1:\n    stzg %[Cur], [%[Cur]], #16\n    cmp %[Cur], %[Next]\n    b.lt 1b\n\n    // DC GZVA cache lines until we have no more full cache lines.\n    bic %[Next], %[End], LineMask\n    .unreq LineMask\n  2:\n    dc gzva, %[Cur]\n    add %[Cur], %[Cur], %[LineSize]\n    cmp %[Cur], %[Next]\n    b.lt 2b\n\n    // STZG until the end of the tagged region. This loop is also used to handle\n    // slow path cases.\n  3:\n    cmp %[Cur], %[End]\n    b.ge 4f\n    stzg %[Cur], [%[Cur]], #16\n    b 3b\n\n  4:\n  )\"\n      : [Cur] \"+&r\"(Begin), [LineSize] \"=&r\"(LineSize), [Next] \"=&r\"(Next),\n        [Tmp] \"=&r\"(Tmp)\n      : [End] \"r\"(End)\n      : \"memory\");\n  return Begin;\n}\n\ninline void storeTag(uptr Ptr) {\n  __asm__ __volatile__(R\"(\n    .arch_extension memtag\n    stg %0, [%0]\n  )\"\n                       :\n                       : \"r\"(Ptr)\n                       : \"memory\");\n}\n\ninline uptr loadTag(uptr Ptr) {\n  uptr TaggedPtr = Ptr;\n  __asm__ __volatile__(\n      R\"(\n      .arch_extension memtag\n      ldg %0, [%0]\n      )\"\n      : \"+r\"(TaggedPtr)\n      :\n      : \"memory\");\n  return TaggedPtr;\n}\n\n#else\n\ninline bool systemSupportsMemoryTagging() {\n  UNREACHABLE(\"memory tagging not supported\");\n}\n\ninline bool systemDetectsMemoryTagFaultsTestOnly() {\n  UNREACHABLE(\"memory tagging not supported\");\n}\n\ninline void disableMemoryTagChecksTestOnly() {\n  UNREACHABLE(\"memory tagging not supported\");\n}\n\ninline void enableMemoryTagChecksTestOnly() {\n  UNREACHABLE(\"memory tagging not supported\");\n}\n\nstruct ScopedDisableMemoryTagChecks {\n  ScopedDisableMemoryTagChecks() {}\n};\n\ninline uptr selectRandomTag(uptr Ptr, uptr ExcludeMask) {\n  (void)Ptr;\n  (void)ExcludeMask;\n  UNREACHABLE(\"memory tagging not supported\");\n}\n\ninline uptr addFixedTag(uptr Ptr, uptr Tag) {\n  (void)Ptr;\n  (void)Tag;\n  UNREACHABLE(\"memory tagging not supported\");\n}\n\ninline uptr storeTags(uptr Begin, uptr End) {\n  (void)Begin;\n  (void)End;\n  UNREACHABLE(\"memory tagging not supported\");\n}\n\ninline void storeTag(uptr Ptr) {\n  (void)Ptr;\n  UNREACHABLE(\"memory tagging not supported\");\n}\n\ninline uptr loadTag(uptr Ptr) {\n  (void)Ptr;\n  UNREACHABLE(\"memory tagging not supported\");\n}\n\n#endif\n\ninline void setRandomTag(void *Ptr, uptr Size, uptr ExcludeMask,\n                         uptr *TaggedBegin, uptr *TaggedEnd) {\n  *TaggedBegin = selectRandomTag(reinterpret_cast<uptr>(Ptr), ExcludeMask);\n  *TaggedEnd = storeTags(*TaggedBegin, *TaggedBegin + Size);\n}\n\ninline void *untagPointer(void *Ptr) {\n  return reinterpret_cast<void *>(untagPointer(reinterpret_cast<uptr>(Ptr)));\n}\n\ninline void *loadTag(void *Ptr) {\n  return reinterpret_cast<void *>(loadTag(reinterpret_cast<uptr>(Ptr)));\n}\n\ninline void *addFixedTag(void *Ptr, uptr Tag) {\n  return reinterpret_cast<void *>(\n      addFixedTag(reinterpret_cast<uptr>(Ptr), Tag));\n}\n\ntemplate <typename Config>\ninline constexpr bool allocatorSupportsMemoryTagging() {\n  return archSupportsMemoryTagging() && Config::MaySupportMemoryTagging;\n}\n\n} // namespace scudo\n\n#endif\n"}, "16": {"id": 16, "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/scudo/standalone/mutex.h", "content": "//===-- mutex.h -------------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef SCUDO_MUTEX_H_\n#define SCUDO_MUTEX_H_\n\n#include \"atomic_helpers.h\"\n#include \"common.h\"\n\n#include <string.h>\n\n#if SCUDO_FUCHSIA\n#include <lib/sync/mutex.h> // for sync_mutex_t\n#endif\n\nnamespace scudo {\n\nclass HybridMutex {\npublic:\n  void init() { M = {}; }\n  bool tryLock();\n  NOINLINE void lock() {\n    if (LIKELY(tryLock()))\n      return;\n      // The compiler may try to fully unroll the loop, ending up in a\n      // NumberOfTries*NumberOfYields block of pauses mixed with tryLocks. This\n      // is large, ugly and unneeded, a compact loop is better for our purpose\n      // here. Use a pragma to tell the compiler not to unroll the loop.\n#ifdef __clang__\n#pragma nounroll\n#endif\n    for (u8 I = 0U; I < NumberOfTries; I++) {\n      yieldProcessor(NumberOfYields);\n      if (tryLock())\n        return;\n    }\n    lockSlow();\n  }\n  void unlock();\n\nprivate:\n  static constexpr u8 NumberOfTries = 8U;\n  static constexpr u8 NumberOfYields = 8U;\n\n#if SCUDO_LINUX\n  atomic_u32 M = {};\n#elif SCUDO_FUCHSIA\n  sync_mutex_t M = {};\n#endif\n\n  void lockSlow();\n};\n\nclass ScopedLock {\npublic:\n  explicit ScopedLock(HybridMutex &M) : Mutex(M) { Mutex.lock(); }\n  ~ScopedLock() { Mutex.unlock(); }\n\nprivate:\n  HybridMutex &Mutex;\n\n  ScopedLock(const ScopedLock &) = delete;\n  void operator=(const ScopedLock &) = delete;\n};\n\n} // namespace scudo\n\n#endif // SCUDO_MUTEX_H_\n"}, "17": {"id": 17, "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/scudo/standalone/options.h", "content": "//===-- options.h -----------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef SCUDO_OPTIONS_H_\n#define SCUDO_OPTIONS_H_\n\n#include \"atomic_helpers.h\"\n#include \"common.h\"\n#include \"memtag.h\"\n\nnamespace scudo {\n\nenum class OptionBit {\n  MayReturnNull,\n  FillContents0of2,\n  FillContents1of2,\n  DeallocTypeMismatch,\n  DeleteSizeMismatch,\n  TrackAllocationStacks,\n  UseOddEvenTags,\n  UseMemoryTagging,\n  AddLargeAllocationSlack,\n};\n\nstruct Options {\n  u32 Val;\n\n  bool get(OptionBit Opt) const { return Val & (1U << static_cast<u32>(Opt)); }\n\n  FillContentsMode getFillContentsMode() const {\n    return static_cast<FillContentsMode>(\n        (Val >> static_cast<u32>(OptionBit::FillContents0of2)) & 3);\n  }\n};\n\ntemplate <typename Config> bool useMemoryTagging(Options Options) {\n  return allocatorSupportsMemoryTagging<Config>() &&\n         Options.get(OptionBit::UseMemoryTagging);\n}\n\nstruct AtomicOptions {\n  atomic_u32 Val = {};\n\n  Options load() const { return Options{atomic_load_relaxed(&Val)}; }\n\n  void clear(OptionBit Opt) {\n    atomic_fetch_and(&Val, ~(1U << static_cast<u32>(Opt)),\n                     memory_order_relaxed);\n  }\n\n  void set(OptionBit Opt) {\n    atomic_fetch_or(&Val, 1U << static_cast<u32>(Opt), memory_order_relaxed);\n  }\n\n  void setFillContentsMode(FillContentsMode FillContents) {\n    u32 Opts = atomic_load_relaxed(&Val), NewOpts;\n    do {\n      NewOpts = Opts;\n      NewOpts &= ~(3U << static_cast<u32>(OptionBit::FillContents0of2));\n      NewOpts |= static_cast<u32>(FillContents)\n                 << static_cast<u32>(OptionBit::FillContents0of2);\n    } while (!atomic_compare_exchange_strong(&Val, &Opts, NewOpts,\n                                             memory_order_relaxed));\n  }\n};\n\n} // namespace scudo\n\n#endif // SCUDO_OPTIONS_H_\n"}, "19": {"id": 19, "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/scudo/standalone/primary32.h", "content": "//===-- primary32.h ---------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef SCUDO_PRIMARY32_H_\n#define SCUDO_PRIMARY32_H_\n\n#include \"bytemap.h\"\n#include \"common.h\"\n#include \"list.h\"\n#include \"local_cache.h\"\n#include \"options.h\"\n#include \"release.h\"\n#include \"report.h\"\n#include \"stats.h\"\n#include \"string_utils.h\"\n\nnamespace scudo {\n\n// SizeClassAllocator32 is an allocator for 32 or 64-bit address space.\n//\n// It maps Regions of 2^RegionSizeLog bytes aligned on a 2^RegionSizeLog bytes\n// boundary, and keeps a bytemap of the mappable address space to track the size\n// class they are associated with.\n//\n// Mapped regions are split into equally sized Blocks according to the size\n// class they belong to, and the associated pointers are shuffled to prevent any\n// predictable address pattern (the predictability increases with the block\n// size).\n//\n// Regions for size class 0 are special and used to hold TransferBatches, which\n// allow to transfer arrays of pointers from the global size class freelist to\n// the thread specific freelist for said class, and back.\n//\n// Memory used by this allocator is never unmapped but can be partially\n// reclaimed if the platform allows for it.\n\ntemplate <typename Config> class SizeClassAllocator32 {\npublic:\n  typedef typename Config::PrimaryCompactPtrT CompactPtrT;\n  typedef typename Config::SizeClassMap SizeClassMap;\n  // The bytemap can only track UINT8_MAX - 1 classes.\n  static_assert(SizeClassMap::LargestClassId <= (UINT8_MAX - 1), \"\");\n  // Regions should be large enough to hold the largest Block.\n  static_assert((1UL << Config::PrimaryRegionSizeLog) >= SizeClassMap::MaxSize,\n                \"\");\n  typedef SizeClassAllocator32<Config> ThisT;\n  typedef SizeClassAllocatorLocalCache<ThisT> CacheT;\n  typedef typename CacheT::TransferBatch TransferBatch;\n\n  static uptr getSizeByClassId(uptr ClassId) {\n    return (ClassId == SizeClassMap::BatchClassId)\n               ? sizeof(TransferBatch)\n               : SizeClassMap::getSizeByClassId(ClassId);\n  }\n\n  static bool canAllocate(uptr Size) { return Size <= SizeClassMap::MaxSize; }\n\n  void initLinkerInitialized(s32 ReleaseToOsInterval) {\n    if (SCUDO_FUCHSIA)\n      reportError(\"SizeClassAllocator32 is not supported on Fuchsia\");\n\n    PossibleRegions.initLinkerInitialized();\n\n    u32 Seed;\n    const u64 Time = getMonotonicTime();\n    if (!getRandom(reinterpret_cast<void *>(&Seed), sizeof(Seed)))\n      Seed = static_cast<u32>(\n          Time ^ (reinterpret_cast<uptr>(SizeClassInfoArray) >> 6));\n    for (uptr I = 0; I < NumClasses; I++) {\n      SizeClassInfo *Sci = getSizeClassInfo(I);\n      Sci->RandState = getRandomU32(&Seed);\n      // Sci->MaxRegionIndex is already initialized to 0.\n      Sci->MinRegionIndex = NumRegions;\n      Sci->ReleaseInfo.LastReleaseAtNs = Time;\n    }\n    setOption(Option::ReleaseInterval, static_cast<sptr>(ReleaseToOsInterval));\n  }\n  void init(s32 ReleaseToOsInterval) {\n    memset(this, 0, sizeof(*this));\n    initLinkerInitialized(ReleaseToOsInterval);\n  }\n\n  void unmapTestOnly() {\n    while (NumberOfStashedRegions > 0)\n      unmap(reinterpret_cast<void *>(RegionsStash[--NumberOfStashedRegions]),\n            RegionSize);\n    uptr MinRegionIndex = NumRegions, MaxRegionIndex = 0;\n    for (uptr I = 0; I < NumClasses; I++) {\n      SizeClassInfo *Sci = getSizeClassInfo(I);\n      if (Sci->MinRegionIndex < MinRegionIndex)\n        MinRegionIndex = Sci->MinRegionIndex;\n      if (Sci->MaxRegionIndex > MaxRegionIndex)\n        MaxRegionIndex = Sci->MaxRegionIndex;\n    }\n    for (uptr I = MinRegionIndex; I < MaxRegionIndex; I++)\n      if (PossibleRegions[I])\n        unmap(reinterpret_cast<void *>(I * RegionSize), RegionSize);\n    PossibleRegions.unmapTestOnly();\n  }\n\n  CompactPtrT compactPtr(UNUSED uptr ClassId, uptr Ptr) const {\n    return static_cast<CompactPtrT>(Ptr);\n  }\n\n  void *decompactPtr(UNUSED uptr ClassId, CompactPtrT CompactPtr) const {\n    return reinterpret_cast<void *>(static_cast<uptr>(CompactPtr));\n  }\n\n  TransferBatch *popBatch(CacheT *C, uptr ClassId) {\n    DCHECK_LT(ClassId, NumClasses);\n    SizeClassInfo *Sci = getSizeClassInfo(ClassId);\n    ScopedLock L(Sci->Mutex);\n    TransferBatch *B = Sci->FreeList.front();\n    if (B) {\n      Sci->FreeList.pop_front();\n    } else {\n      B = populateFreeList(C, ClassId, Sci);\n      if (UNLIKELY(!B))\n        return nullptr;\n    }\n    DCHECK_GT(B->getCount(), 0);\n    Sci->Stats.PoppedBlocks += B->getCount();\n    return B;\n  }\n\n  void pushBatch(uptr ClassId, TransferBatch *B) {\n    DCHECK_LT(ClassId, NumClasses);\n    DCHECK_GT(B->getCount(), 0);\n    SizeClassInfo *Sci = getSizeClassInfo(ClassId);\n    ScopedLock L(Sci->Mutex);\n    Sci->FreeList.push_front(B);\n    Sci->Stats.PushedBlocks += B->getCount();\n    if (ClassId != SizeClassMap::BatchClassId)\n      releaseToOSMaybe(Sci, ClassId);\n  }\n\n  void disable() {\n    // The BatchClassId must be locked last since other classes can use it.\n    for (sptr I = static_cast<sptr>(NumClasses) - 1; I >= 0; I--) {\n      if (static_cast<uptr>(I) == SizeClassMap::BatchClassId)\n        continue;\n      getSizeClassInfo(static_cast<uptr>(I))->Mutex.lock();\n    }\n    getSizeClassInfo(SizeClassMap::BatchClassId)->Mutex.lock();\n    RegionsStashMutex.lock();\n    PossibleRegions.disable();\n  }\n\n  void enable() {\n    PossibleRegions.enable();\n    RegionsStashMutex.unlock();\n    getSizeClassInfo(SizeClassMap::BatchClassId)->Mutex.unlock();\n    for (uptr I = 0; I < NumClasses; I++) {\n      if (I == SizeClassMap::BatchClassId)\n        continue;\n      getSizeClassInfo(I)->Mutex.unlock();\n    }\n  }\n\n  template <typename F> void iterateOverBlocks(F Callback) {\n    uptr MinRegionIndex = NumRegions, MaxRegionIndex = 0;\n    for (uptr I = 0; I < NumClasses; I++) {\n      SizeClassInfo *Sci = getSizeClassInfo(I);\n      if (Sci->MinRegionIndex < MinRegionIndex)\n        MinRegionIndex = Sci->MinRegionIndex;\n      if (Sci->MaxRegionIndex > MaxRegionIndex)\n        MaxRegionIndex = Sci->MaxRegionIndex;\n    }\n    for (uptr I = MinRegionIndex; I <= MaxRegionIndex; I++)\n      if (PossibleRegions[I] &&\n          (PossibleRegions[I] - 1U) != SizeClassMap::BatchClassId) {\n        const uptr BlockSize = getSizeByClassId(PossibleRegions[I] - 1U);\n        const uptr From = I * RegionSize;\n        const uptr To = From + (RegionSize / BlockSize) * BlockSize;\n        for (uptr Block = From; Block < To; Block += BlockSize)\n          Callback(Block);\n      }\n  }\n\n  void getStats(ScopedString *Str) {\n    // TODO(kostyak): get the RSS per region.\n    uptr TotalMapped = 0;\n    uptr PoppedBlocks = 0;\n    uptr PushedBlocks = 0;\n    for (uptr I = 0; I < NumClasses; I++) {\n      SizeClassInfo *Sci = getSizeClassInfo(I);\n      TotalMapped += Sci->AllocatedUser;\n      PoppedBlocks += Sci->Stats.PoppedBlocks;\n      PushedBlocks += Sci->Stats.PushedBlocks;\n    }\n    Str->append(\"Stats: SizeClassAllocator32: %zuM mapped in %zu allocations; \"\n                \"remains %zu\\n\",\n                TotalMapped >> 20, PoppedBlocks, PoppedBlocks - PushedBlocks);\n    for (uptr I = 0; I < NumClasses; I++)\n      getStats(Str, I, 0);\n  }\n\n  bool setOption(Option O, sptr Value) {\n    if (O == Option::ReleaseInterval) {\n      const s32 Interval = Max(\n          Min(static_cast<s32>(Value), Config::PrimaryMaxReleaseToOsIntervalMs),\n          Config::PrimaryMinReleaseToOsIntervalMs);\n      atomic_store_relaxed(&ReleaseToOsIntervalMs, Interval);\n      return true;\n    }\n    // Not supported by the Primary, but not an error either.\n    return true;\n  }\n\n  uptr releaseToOS() {\n    uptr TotalReleasedBytes = 0;\n    for (uptr I = 0; I < NumClasses; I++) {\n      if (I == SizeClassMap::BatchClassId)\n        continue;\n      SizeClassInfo *Sci = getSizeClassInfo(I);\n      ScopedLock L(Sci->Mutex);\n      TotalReleasedBytes += releaseToOSMaybe(Sci, I, /*Force=*/true);\n    }\n    return TotalReleasedBytes;\n  }\n\n  const char *getRegionInfoArrayAddress() const { return nullptr; }\n  static uptr getRegionInfoArraySize() { return 0; }\n\n  static BlockInfo findNearestBlock(UNUSED const char *RegionInfoData,\n                                    UNUSED uptr Ptr) {\n    return {};\n  }\n\n  AtomicOptions Options;\n\nprivate:\n  static const uptr NumClasses = SizeClassMap::NumClasses;\n  static const uptr RegionSize = 1UL << Config::PrimaryRegionSizeLog;\n  static const uptr NumRegions =\n      SCUDO_MMAP_RANGE_SIZE >> Config::PrimaryRegionSizeLog;\n  static const u32 MaxNumBatches = SCUDO_ANDROID ? 4U : 8U;\n  typedef FlatByteMap<NumRegions> ByteMap;\n\n  struct SizeClassStats {\n    uptr PoppedBlocks;\n    uptr PushedBlocks;\n  };\n\n  struct ReleaseToOsInfo {\n    uptr PushedBlocksAtLastRelease;\n    uptr RangesReleased;\n    uptr LastReleasedBytes;\n    u64 LastReleaseAtNs;\n  };\n\n  struct alignas(SCUDO_CACHE_LINE_SIZE) SizeClassInfo {\n    HybridMutex Mutex;\n    SinglyLinkedList<TransferBatch> FreeList;\n    uptr CurrentRegion;\n    uptr CurrentRegionAllocated;\n    SizeClassStats Stats;\n    u32 RandState;\n    uptr AllocatedUser;\n    // Lowest & highest region index allocated for this size class, to avoid\n    // looping through the whole NumRegions.\n    uptr MinRegionIndex;\n    uptr MaxRegionIndex;\n    ReleaseToOsInfo ReleaseInfo;\n  };\n  static_assert(sizeof(SizeClassInfo) % SCUDO_CACHE_LINE_SIZE == 0, \"\");\n\n  uptr computeRegionId(uptr Mem) {\n    const uptr Id = Mem >> Config::PrimaryRegionSizeLog;\n    CHECK_LT(Id, NumRegions);\n    return Id;\n  }\n\n  uptr allocateRegionSlow() {\n    uptr MapSize = 2 * RegionSize;\n    const uptr MapBase = reinterpret_cast<uptr>(\n        map(nullptr, MapSize, \"scudo:primary\", MAP_ALLOWNOMEM));\n    if (!MapBase)\n      return 0;\n    const uptr MapEnd = MapBase + MapSize;\n    uptr Region = MapBase;\n    if (isAligned(Region, RegionSize)) {\n      ScopedLock L(RegionsStashMutex);\n      if (NumberOfStashedRegions < MaxStashedRegions)\n        RegionsStash[NumberOfStashedRegions++] = MapBase + RegionSize;\n      else\n        MapSize = RegionSize;\n    } else {\n      Region = roundUpTo(MapBase, RegionSize);\n      unmap(reinterpret_cast<void *>(MapBase), Region - MapBase);\n      MapSize = RegionSize;\n    }\n    const uptr End = Region + MapSize;\n    if (End != MapEnd)\n      unmap(reinterpret_cast<void *>(End), MapEnd - End);\n    return Region;\n  }\n\n  uptr allocateRegion(SizeClassInfo *Sci, uptr ClassId) {\n    DCHECK_LT(ClassId, NumClasses);\n    uptr Region = 0;\n    {\n      ScopedLock L(RegionsStashMutex);\n      if (NumberOfStashedRegions > 0)\n        Region = RegionsStash[--NumberOfStashedRegions];\n    }\n    if (!Region)\n      Region = allocateRegionSlow();\n    if (LIKELY(Region)) {\n      // Sci->Mutex is held by the caller, updating the Min/Max is safe.\n      const uptr RegionIndex = computeRegionId(Region);\n      if (RegionIndex < Sci->MinRegionIndex)\n        Sci->MinRegionIndex = RegionIndex;\n      if (RegionIndex > Sci->MaxRegionIndex)\n        Sci->MaxRegionIndex = RegionIndex;\n      PossibleRegions.set(RegionIndex, static_cast<u8>(ClassId + 1U));\n    }\n    return Region;\n  }\n\n  SizeClassInfo *getSizeClassInfo(uptr ClassId) {\n    DCHECK_LT(ClassId, NumClasses);\n    return &SizeClassInfoArray[ClassId];\n  }\n\n  NOINLINE TransferBatch *populateFreeList(CacheT *C, uptr ClassId,\n                                           SizeClassInfo *Sci) {\n    uptr Region;\n    uptr Offset;\n    // If the size-class currently has a region associated to it, use it. The\n    // newly created blocks will be located after the currently allocated memory\n    // for that region (up to RegionSize). Otherwise, create a new region, where\n    // the new blocks will be carved from the beginning.\n    if (Sci->CurrentRegion) {\n      Region = Sci->CurrentRegion;\n      DCHECK_GT(Sci->CurrentRegionAllocated, 0U);\n      Offset = Sci->CurrentRegionAllocated;\n    } else {\n      DCHECK_EQ(Sci->CurrentRegionAllocated, 0U);\n      Region = allocateRegion(Sci, ClassId);\n      if (UNLIKELY(!Region))\n        return nullptr;\n      C->getStats().add(StatMapped, RegionSize);\n      Sci->CurrentRegion = Region;\n      Offset = 0;\n    }\n\n    const uptr Size = getSizeByClassId(ClassId);\n    const u32 MaxCount = TransferBatch::getMaxCached(Size);\n    DCHECK_GT(MaxCount, 0U);\n    // The maximum number of blocks we should carve in the region is dictated\n    // by the maximum number of batches we want to fill, and the amount of\n    // memory left in the current region (we use the lowest of the two). This\n    // will not be 0 as we ensure that a region can at least hold one block (via\n    // static_assert and at the end of this function).\n    const u32 NumberOfBlocks =\n        Min(MaxNumBatches * MaxCount,\n            static_cast<u32>((RegionSize - Offset) / Size));\n    DCHECK_GT(NumberOfBlocks, 0U);\n\n    constexpr u32 ShuffleArraySize =\n        MaxNumBatches * TransferBatch::MaxNumCached;\n    // Fill the transfer batches and put them in the size-class freelist. We\n    // need to randomize the blocks for security purposes, so we first fill a\n    // local array that we then shuffle before populating the batches.\n    CompactPtrT ShuffleArray[ShuffleArraySize];\n    DCHECK_LE(NumberOfBlocks, ShuffleArraySize);\n\n    uptr P = Region + Offset;\n    for (u32 I = 0; I < NumberOfBlocks; I++, P += Size)\n      ShuffleArray[I] = reinterpret_cast<CompactPtrT>(P);\n    // No need to shuffle the batches size class.\n    if (ClassId != SizeClassMap::BatchClassId)\n      shuffle(ShuffleArray, NumberOfBlocks, &Sci->RandState);\n    for (u32 I = 0; I < NumberOfBlocks;) {\n      TransferBatch *B =\n          C->createBatch(ClassId, reinterpret_cast<void *>(ShuffleArray[I]));\n      if (UNLIKELY(!B))\n        return nullptr;\n      const u32 N = Min(MaxCount, NumberOfBlocks - I);\n      B->setFromArray(&ShuffleArray[I], N);\n      Sci->FreeList.push_back(B);\n      I += N;\n    }\n    TransferBatch *B = Sci->FreeList.front();\n    Sci->FreeList.pop_front();\n    DCHECK(B);\n    DCHECK_GT(B->getCount(), 0);\n\n    const uptr AllocatedUser = Size * NumberOfBlocks;\n    C->getStats().add(StatFree, AllocatedUser);\n    DCHECK_LE(Sci->CurrentRegionAllocated + AllocatedUser, RegionSize);\n    // If there is not enough room in the region currently associated to fit\n    // more blocks, we deassociate the region by resetting CurrentRegion and\n    // CurrentRegionAllocated. Otherwise, update the allocated amount.\n    if (RegionSize - (Sci->CurrentRegionAllocated + AllocatedUser) < Size) {\n      Sci->CurrentRegion = 0;\n      Sci->CurrentRegionAllocated = 0;\n    } else {\n      Sci->CurrentRegionAllocated += AllocatedUser;\n    }\n    Sci->AllocatedUser += AllocatedUser;\n\n    return B;\n  }\n\n  void getStats(ScopedString *Str, uptr ClassId, uptr Rss) {\n    SizeClassInfo *Sci = getSizeClassInfo(ClassId);\n    if (Sci->AllocatedUser == 0)\n      return;\n    const uptr InUse = Sci->Stats.PoppedBlocks - Sci->Stats.PushedBlocks;\n    const uptr AvailableChunks = Sci->AllocatedUser / getSizeByClassId(ClassId);\n    Str->append(\"  %02zu (%6zu): mapped: %6zuK popped: %7zu pushed: %7zu \"\n                \"inuse: %6zu avail: %6zu rss: %6zuK releases: %6zu\\n\",\n                ClassId, getSizeByClassId(ClassId), Sci->AllocatedUser >> 10,\n                Sci->Stats.PoppedBlocks, Sci->Stats.PushedBlocks, InUse,\n                AvailableChunks, Rss >> 10, Sci->ReleaseInfo.RangesReleased);\n  }\n\n  NOINLINE uptr releaseToOSMaybe(SizeClassInfo *Sci, uptr ClassId,\n                                 bool Force = false) {\n    const uptr BlockSize = getSizeByClassId(ClassId);\n    const uptr PageSize = getPageSizeCached();\n\n    DCHECK_GE(Sci->Stats.PoppedBlocks, Sci->Stats.PushedBlocks);\n    const uptr BytesInFreeList =\n        Sci->AllocatedUser -\n        (Sci->Stats.PoppedBlocks - Sci->Stats.PushedBlocks) * BlockSize;\n    if (BytesInFreeList < PageSize)\n      return 0; // No chance to release anything.\n    const uptr BytesPushed =\n        (Sci->Stats.PushedBlocks - Sci->ReleaseInfo.PushedBlocksAtLastRelease) *\n        BlockSize;\n    if (BytesPushed < PageSize)\n      return 0; // Nothing new to release.\n\n    // Releasing smaller blocks is expensive, so we want to make sure that a\n    // significant amount of bytes are free, and that there has been a good\n    // amount of batches pushed to the freelist before attempting to release.\n    if (BlockSize < PageSize / 16U) {\n      if (!Force && BytesPushed < Sci->AllocatedUser / 16U)\n        return 0;\n      // We want 8x% to 9x% free bytes (the larger the block, the lower the %).\n      if ((BytesInFreeList * 100U) / Sci->AllocatedUser <\n          (100U - 1U - BlockSize / 16U))\n        return 0;\n    }\n\n    if (!Force) {\n      const s32 IntervalMs = atomic_load_relaxed(&ReleaseToOsIntervalMs);\n      if (IntervalMs < 0)\n        return 0;\n      if (Sci->ReleaseInfo.LastReleaseAtNs +\n              static_cast<u64>(IntervalMs) * 1000000 >\n          getMonotonicTime()) {\n        return 0; // Memory was returned recently.\n      }\n    }\n\n    const uptr First = Sci->MinRegionIndex;\n    const uptr Last = Sci->MaxRegionIndex;\n    DCHECK_NE(Last, 0U);\n    DCHECK_LE(First, Last);\n    uptr TotalReleasedBytes = 0;\n    const uptr Base = First * RegionSize;\n    const uptr NumberOfRegions = Last - First + 1U;\n    ReleaseRecorder Recorder(Base);\n    auto SkipRegion = [this, First, ClassId](uptr RegionIndex) {\n      return (PossibleRegions[First + RegionIndex] - 1U) != ClassId;\n    };\n    auto DecompactPtr = [](CompactPtrT CompactPtr) {\n      return reinterpret_cast<uptr>(CompactPtr);\n    };\n    releaseFreeMemoryToOS(Sci->FreeList, RegionSize, NumberOfRegions, BlockSize,\n                          &Recorder, DecompactPtr, SkipRegion);\n    if (Recorder.getReleasedRangesCount() > 0) {\n      Sci->ReleaseInfo.PushedBlocksAtLastRelease = Sci->Stats.PushedBlocks;\n      Sci->ReleaseInfo.RangesReleased += Recorder.getReleasedRangesCount();\n      Sci->ReleaseInfo.LastReleasedBytes = Recorder.getReleasedBytes();\n      TotalReleasedBytes += Sci->ReleaseInfo.LastReleasedBytes;\n    }\n    Sci->ReleaseInfo.LastReleaseAtNs = getMonotonicTime();\n\n    return TotalReleasedBytes;\n  }\n\n  SizeClassInfo SizeClassInfoArray[NumClasses] = {};\n\n  // Track the regions in use, 0 is unused, otherwise store ClassId + 1.\n  ByteMap PossibleRegions = {};\n  atomic_s32 ReleaseToOsIntervalMs = {};\n  // Unless several threads request regions simultaneously from different size\n  // classes, the stash rarely contains more than 1 entry.\n  static constexpr uptr MaxStashedRegions = 4;\n  HybridMutex RegionsStashMutex;\n  uptr NumberOfStashedRegions = 0;\n  uptr RegionsStash[MaxStashedRegions] = {};\n};\n\n} // namespace scudo\n\n#endif // SCUDO_PRIMARY32_H_\n"}, "20": {"id": 20, "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/scudo/standalone/primary64.h", "content": "//===-- primary64.h ---------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef SCUDO_PRIMARY64_H_\n#define SCUDO_PRIMARY64_H_\n\n#include \"bytemap.h\"\n#include \"common.h\"\n#include \"list.h\"\n#include \"local_cache.h\"\n#include \"memtag.h\"\n#include \"options.h\"\n#include \"release.h\"\n#include \"stats.h\"\n#include \"string_utils.h\"\n\nnamespace scudo {\n\n// SizeClassAllocator64 is an allocator tuned for 64-bit address space.\n//\n// It starts by reserving NumClasses * 2^RegionSizeLog bytes, equally divided in\n// Regions, specific to each size class. Note that the base of that mapping is\n// random (based to the platform specific map() capabilities), and that each\n// Region actually starts at a random offset from its base.\n//\n// Regions are mapped incrementally on demand to fulfill allocation requests,\n// those mappings being split into equally sized Blocks based on the size class\n// they belong to. The Blocks created are shuffled to prevent predictable\n// address patterns (the predictability increases with the size of the Blocks).\n//\n// The 1st Region (for size class 0) holds the TransferBatches. This is a\n// structure used to transfer arrays of available pointers from the class size\n// freelist to the thread specific freelist, and back.\n//\n// The memory used by this allocator is never unmapped, but can be partially\n// released if the platform allows for it.\n\ntemplate <typename Config> class SizeClassAllocator64 {\npublic:\n  typedef typename Config::PrimaryCompactPtrT CompactPtrT;\n  static const uptr CompactPtrScale = Config::PrimaryCompactPtrScale;\n  typedef typename Config::SizeClassMap SizeClassMap;\n  typedef SizeClassAllocator64<Config> ThisT;\n  typedef SizeClassAllocatorLocalCache<ThisT> CacheT;\n  typedef typename CacheT::TransferBatch TransferBatch;\n\n  static uptr getSizeByClassId(uptr ClassId) {\n    return (ClassId == SizeClassMap::BatchClassId)\n               ? roundUpTo(sizeof(TransferBatch), 1U << CompactPtrScale)\n               : SizeClassMap::getSizeByClassId(ClassId);\n  }\n\n  static bool canAllocate(uptr Size) { return Size <= SizeClassMap::MaxSize; }\n\n  void initLinkerInitialized(s32 ReleaseToOsInterval) {\n    // Reserve the space required for the Primary.\n    PrimaryBase = reinterpret_cast<uptr>(\n        map(nullptr, PrimarySize, nullptr, MAP_NOACCESS, &Data));\n\n    u32 Seed;\n    const u64 Time = getMonotonicTime();\n    if (!getRandom(reinterpret_cast<void *>(&Seed), sizeof(Seed)))\n      Seed = static_cast<u32>(Time ^ (PrimaryBase >> 12));\n    const uptr PageSize = getPageSizeCached();\n    for (uptr I = 0; I < NumClasses; I++) {\n      RegionInfo *Region = getRegionInfo(I);\n      // The actual start of a region is offseted by a random number of pages.\n      Region->RegionBeg =\n          getRegionBaseByClassId(I) + (getRandomModN(&Seed, 16) + 1) * PageSize;\n      Region->RandState = getRandomU32(&Seed);\n      Region->ReleaseInfo.LastReleaseAtNs = Time;\n    }\n    setOption(Option::ReleaseInterval, static_cast<sptr>(ReleaseToOsInterval));\n  }\n  void init(s32 ReleaseToOsInterval) {\n    memset(this, 0, sizeof(*this));\n    initLinkerInitialized(ReleaseToOsInterval);\n  }\n\n  void unmapTestOnly() {\n    unmap(reinterpret_cast<void *>(PrimaryBase), PrimarySize, UNMAP_ALL, &Data);\n  }\n\n  TransferBatch *popBatch(CacheT *C, uptr ClassId) {\n    DCHECK_LT(ClassId, NumClasses);\n    RegionInfo *Region = getRegionInfo(ClassId);\n    ScopedLock L(Region->Mutex);\n    TransferBatch *B = Region->FreeList.front();\n    if (B) {\n      Region->FreeList.pop_front();\n    } else {\n      B = populateFreeList(C, ClassId, Region);\n      if (UNLIKELY(!B))\n        return nullptr;\n    }\n    DCHECK_GT(B->getCount(), 0);\n    Region->Stats.PoppedBlocks += B->getCount();\n    return B;\n  }\n\n  void pushBatch(uptr ClassId, TransferBatch *B) {\n    DCHECK_GT(B->getCount(), 0);\n    RegionInfo *Region = getRegionInfo(ClassId);\n    ScopedLock L(Region->Mutex);\n    Region->FreeList.push_front(B);\n    Region->Stats.PushedBlocks += B->getCount();\n    if (ClassId != SizeClassMap::BatchClassId)\n      releaseToOSMaybe(Region, ClassId);\n  }\n\n  void disable() {\n    // The BatchClassId must be locked last since other classes can use it.\n    for (sptr I = static_cast<sptr>(NumClasses) - 1; I >= 0; I--) {\n      if (static_cast<uptr>(I) == SizeClassMap::BatchClassId)\n        continue;\n      getRegionInfo(static_cast<uptr>(I))->Mutex.lock();\n    }\n    getRegionInfo(SizeClassMap::BatchClassId)->Mutex.lock();\n  }\n\n  void enable() {\n    getRegionInfo(SizeClassMap::BatchClassId)->Mutex.unlock();\n    for (uptr I = 0; I < NumClasses; I++) {\n      if (I == SizeClassMap::BatchClassId)\n        continue;\n      getRegionInfo(I)->Mutex.unlock();\n    }\n  }\n\n  template <typename F> void iterateOverBlocks(F Callback) {\n    for (uptr I = 0; I < NumClasses; I++) {\n      if (I == SizeClassMap::BatchClassId)\n        continue;\n      const RegionInfo *Region = getRegionInfo(I);\n      const uptr BlockSize = getSizeByClassId(I);\n      const uptr From = Region->RegionBeg;\n      const uptr To = From + Region->AllocatedUser;\n      for (uptr Block = From; Block < To; Block += BlockSize)\n        Callback(Block);\n    }\n  }\n\n  void getStats(ScopedString *Str) {\n    // TODO(kostyak): get the RSS per region.\n    uptr TotalMapped = 0;\n    uptr PoppedBlocks = 0;\n    uptr PushedBlocks = 0;\n    for (uptr I = 0; I < NumClasses; I++) {\n      RegionInfo *Region = getRegionInfo(I);\n      if (Region->MappedUser)\n        TotalMapped += Region->MappedUser;\n      PoppedBlocks += Region->Stats.PoppedBlocks;\n      PushedBlocks += Region->Stats.PushedBlocks;\n    }\n    Str->append(\"Stats: SizeClassAllocator64: %zuM mapped (%zuM rss) in %zu \"\n                \"allocations; remains %zu\\n\",\n                TotalMapped >> 20, 0, PoppedBlocks,\n                PoppedBlocks - PushedBlocks);\n\n    for (uptr I = 0; I < NumClasses; I++)\n      getStats(Str, I, 0);\n  }\n\n  bool setOption(Option O, sptr Value) {\n    if (O == Option::ReleaseInterval) {\n      const s32 Interval = Max(\n          Min(static_cast<s32>(Value), Config::PrimaryMaxReleaseToOsIntervalMs),\n          Config::PrimaryMinReleaseToOsIntervalMs);\n      atomic_store_relaxed(&ReleaseToOsIntervalMs, Interval);\n      return true;\n    }\n    // Not supported by the Primary, but not an error either.\n    return true;\n  }\n\n  uptr releaseToOS() {\n    uptr TotalReleasedBytes = 0;\n    for (uptr I = 0; I < NumClasses; I++) {\n      if (I == SizeClassMap::BatchClassId)\n        continue;\n      RegionInfo *Region = getRegionInfo(I);\n      ScopedLock L(Region->Mutex);\n      TotalReleasedBytes += releaseToOSMaybe(Region, I, /*Force=*/true);\n    }\n    return TotalReleasedBytes;\n  }\n\n  const char *getRegionInfoArrayAddress() const {\n    return reinterpret_cast<const char *>(RegionInfoArray);\n  }\n\n  static uptr getRegionInfoArraySize() { return sizeof(RegionInfoArray); }\n\n  uptr getCompactPtrBaseByClassId(uptr ClassId) {\n    // If we are not compacting pointers, base everything off of 0.\n    if (sizeof(CompactPtrT) == sizeof(uptr) && CompactPtrScale == 0)\n      return 0;\n    return getRegionInfo(ClassId)->RegionBeg;\n  }\n\n  CompactPtrT compactPtr(uptr ClassId, uptr Ptr) {\n    DCHECK_LE(ClassId, SizeClassMap::LargestClassId);\n    return compactPtrInternal(getCompactPtrBaseByClassId(ClassId), Ptr);\n  }\n\n  void *decompactPtr(uptr ClassId, CompactPtrT CompactPtr) {\n    DCHECK_LE(ClassId, SizeClassMap::LargestClassId);\n    return reinterpret_cast<void *>(\n        decompactPtrInternal(getCompactPtrBaseByClassId(ClassId), CompactPtr));\n  }\n\n  static BlockInfo findNearestBlock(const char *RegionInfoData, uptr Ptr) {\n    const RegionInfo *RegionInfoArray =\n        reinterpret_cast<const RegionInfo *>(RegionInfoData);\n    uptr ClassId;\n    uptr MinDistance = -1UL;\n    for (uptr I = 0; I != NumClasses; ++I) {\n      if (I == SizeClassMap::BatchClassId)\n        continue;\n      uptr Begin = RegionInfoArray[I].RegionBeg;\n      uptr End = Begin + RegionInfoArray[I].AllocatedUser;\n      if (Begin > End || End - Begin < SizeClassMap::getSizeByClassId(I))\n        continue;\n      uptr RegionDistance;\n      if (Begin <= Ptr) {\n        if (Ptr < End)\n          RegionDistance = 0;\n        else\n          RegionDistance = Ptr - End;\n      } else {\n        RegionDistance = Begin - Ptr;\n      }\n\n      if (RegionDistance < MinDistance) {\n        MinDistance = RegionDistance;\n        ClassId = I;\n      }\n    }\n\n    BlockInfo B = {};\n    if (MinDistance <= 8192) {\n      B.RegionBegin = RegionInfoArray[ClassId].RegionBeg;\n      B.RegionEnd = B.RegionBegin + RegionInfoArray[ClassId].AllocatedUser;\n      B.BlockSize = SizeClassMap::getSizeByClassId(ClassId);\n      B.BlockBegin =\n          B.RegionBegin + uptr(sptr(Ptr - B.RegionBegin) / sptr(B.BlockSize) *\n                               sptr(B.BlockSize));\n      while (B.BlockBegin < B.RegionBegin)\n        B.BlockBegin += B.BlockSize;\n      while (B.RegionEnd < B.BlockBegin + B.BlockSize)\n        B.BlockBegin -= B.BlockSize;\n    }\n    return B;\n  }\n\n  AtomicOptions Options;\n\nprivate:\n  static const uptr RegionSize = 1UL << Config::PrimaryRegionSizeLog;\n  static const uptr NumClasses = SizeClassMap::NumClasses;\n  static const uptr PrimarySize = RegionSize * NumClasses;\n\n  // Call map for user memory with at least this size.\n  static const uptr MapSizeIncrement = 1UL << 18;\n  // Fill at most this number of batches from the newly map'd memory.\n  static const u32 MaxNumBatches = SCUDO_ANDROID ? 4U : 8U;\n\n  struct RegionStats {\n    uptr PoppedBlocks;\n    uptr PushedBlocks;\n  };\n\n  struct ReleaseToOsInfo {\n    uptr PushedBlocksAtLastRelease;\n    uptr RangesReleased;\n    uptr LastReleasedBytes;\n    u64 LastReleaseAtNs;\n  };\n\n  struct UnpaddedRegionInfo {\n    HybridMutex Mutex;\n    SinglyLinkedList<TransferBatch> FreeList;\n    uptr RegionBeg = 0;\n    RegionStats Stats = {};\n    u32 RandState = 0;\n    uptr MappedUser = 0;    // Bytes mapped for user memory.\n    uptr AllocatedUser = 0; // Bytes allocated for user memory.\n    MapPlatformData Data = {};\n    ReleaseToOsInfo ReleaseInfo = {};\n    bool Exhausted = false;\n  };\n  struct RegionInfo : UnpaddedRegionInfo {\n    char Padding[SCUDO_CACHE_LINE_SIZE -\n                 (sizeof(UnpaddedRegionInfo) % SCUDO_CACHE_LINE_SIZE)] = {};\n  };\n  static_assert(sizeof(RegionInfo) % SCUDO_CACHE_LINE_SIZE == 0, \"\");\n\n  uptr PrimaryBase = 0;\n  MapPlatformData Data = {};\n  atomic_s32 ReleaseToOsIntervalMs = {};\n  alignas(SCUDO_CACHE_LINE_SIZE) RegionInfo RegionInfoArray[NumClasses];\n\n  RegionInfo *getRegionInfo(uptr ClassId) {\n    DCHECK_LT(ClassId, NumClasses);\n    return &RegionInfoArray[ClassId];\n  }\n\n  uptr getRegionBaseByClassId(uptr ClassId) const {\n    return PrimaryBase + (ClassId << Config::PrimaryRegionSizeLog);\n  }\n\n  static CompactPtrT compactPtrInternal(uptr Base, uptr Ptr) {\n    return static_cast<CompactPtrT>((Ptr - Base) >> CompactPtrScale);\n  }\n\n  static uptr decompactPtrInternal(uptr Base, CompactPtrT CompactPtr) {\n    return Base + (static_cast<uptr>(CompactPtr) << CompactPtrScale);\n  }\n\n  NOINLINE TransferBatch *populateFreeList(CacheT *C, uptr ClassId,\n                                           RegionInfo *Region) {\n    const uptr Size = getSizeByClassId(ClassId);\n    const u32 MaxCount = TransferBatch::getMaxCached(Size);\n\n    const uptr RegionBeg = Region->RegionBeg;\n    const uptr MappedUser = Region->MappedUser;\n    const uptr TotalUserBytes = Region->AllocatedUser + MaxCount * Size;\n    // Map more space for blocks, if necessary.\n    if (TotalUserBytes > MappedUser) {\n      // Do the mmap for the user memory.\n      const uptr MapSize =\n          roundUpTo(TotalUserBytes - MappedUser, MapSizeIncrement);\n      const uptr RegionBase = RegionBeg - getRegionBaseByClassId(ClassId);\n      if (UNLIKELY(RegionBase + MappedUser + MapSize > RegionSize)) {\n        if (!Region->Exhausted) {\n          Region->Exhausted = true;\n          ScopedString Str(1024);\n          getStats(&Str);\n          Str.append(\n              \"Scudo OOM: The process has exhausted %zuM for size class %zu.\\n\",\n              RegionSize >> 20, Size);\n          Str.output();\n        }\n        return nullptr;\n      }\n      if (MappedUser == 0)\n        Region->Data = Data;\n      if (UNLIKELY(!map(\n              reinterpret_cast<void *>(RegionBeg + MappedUser), MapSize,\n              \"scudo:primary\",\n              MAP_ALLOWNOMEM | MAP_RESIZABLE |\n                  (useMemoryTagging<Config>(Options.load()) ? MAP_MEMTAG : 0),\n              &Region->Data)))\n        return nullptr;\n      Region->MappedUser += MapSize;\n      C->getStats().add(StatMapped, MapSize);\n    }\n\n    const u32 NumberOfBlocks = Min(\n        MaxNumBatches * MaxCount,\n        static_cast<u32>((Region->MappedUser - Region->AllocatedUser) / Size));\n    DCHECK_GT(NumberOfBlocks, 0);\n\n    constexpr u32 ShuffleArraySize =\n        MaxNumBatches * TransferBatch::MaxNumCached;\n    CompactPtrT ShuffleArray[ShuffleArraySize];\n    DCHECK_LE(NumberOfBlocks, ShuffleArraySize);\n\n    const uptr CompactPtrBase = getCompactPtrBaseByClassId(ClassId);\n    uptr P = RegionBeg + Region->AllocatedUser;\n    for (u32 I = 0; I < NumberOfBlocks; I++, P += Size)\n      ShuffleArray[I] = compactPtrInternal(CompactPtrBase, P);\n    // No need to shuffle the batches size class.\n    if (ClassId != SizeClassMap::BatchClassId)\n      shuffle(ShuffleArray, NumberOfBlocks, &Region->RandState);\n    for (u32 I = 0; I < NumberOfBlocks;) {\n      TransferBatch *B =\n          C->createBatch(ClassId, reinterpret_cast<void *>(decompactPtrInternal(\n                                      CompactPtrBase, ShuffleArray[I])));\n      if (UNLIKELY(!B))\n        return nullptr;\n      const u32 N = Min(MaxCount, NumberOfBlocks - I);\n      B->setFromArray(&ShuffleArray[I], N);\n      Region->FreeList.push_back(B);\n      I += N;\n    }\n    TransferBatch *B = Region->FreeList.front();\n    Region->FreeList.pop_front();\n    DCHECK(B);\n    DCHECK_GT(B->getCount(), 0);\n\n    const uptr AllocatedUser = Size * NumberOfBlocks;\n    C->getStats().add(StatFree, AllocatedUser);\n    Region->AllocatedUser += AllocatedUser;\n\n    return B;\n  }\n\n  void getStats(ScopedString *Str, uptr ClassId, uptr Rss) {\n    RegionInfo *Region = getRegionInfo(ClassId);\n    if (Region->MappedUser == 0)\n      return;\n    const uptr InUse = Region->Stats.PoppedBlocks - Region->Stats.PushedBlocks;\n    const uptr TotalChunks = Region->AllocatedUser / getSizeByClassId(ClassId);\n    Str->append(\"%s %02zu (%6zu): mapped: %6zuK popped: %7zu pushed: %7zu \"\n                \"inuse: %6zu total: %6zu rss: %6zuK releases: %6zu last \"\n                \"released: %6zuK region: 0x%zx (0x%zx)\\n\",\n                Region->Exhausted ? \"F\" : \" \", ClassId,\n                getSizeByClassId(ClassId), Region->MappedUser >> 10,\n                Region->Stats.PoppedBlocks, Region->Stats.PushedBlocks, InUse,\n                TotalChunks, Rss >> 10, Region->ReleaseInfo.RangesReleased,\n                Region->ReleaseInfo.LastReleasedBytes >> 10, Region->RegionBeg,\n                getRegionBaseByClassId(ClassId));\n  }\n\n  NOINLINE uptr releaseToOSMaybe(RegionInfo *Region, uptr ClassId,\n                                 bool Force = false) {\n    const uptr BlockSize = getSizeByClassId(ClassId);\n    const uptr PageSize = getPageSizeCached();\n\n    DCHECK_GE(Region->Stats.PoppedBlocks, Region->Stats.PushedBlocks);\n    const uptr BytesInFreeList =\n        Region->AllocatedUser -\n        (Region->Stats.PoppedBlocks - Region->Stats.PushedBlocks) * BlockSize;\n    if (BytesInFreeList < PageSize)\n      return 0; // No chance to release anything.\n    const uptr BytesPushed = (Region->Stats.PushedBlocks -\n                              Region->ReleaseInfo.PushedBlocksAtLastRelease) *\n                             BlockSize;\n    if (BytesPushed < PageSize)\n      return 0; // Nothing new to release.\n\n    // Releasing smaller blocks is expensive, so we want to make sure that a\n    // significant amount of bytes are free, and that there has been a good\n    // amount of batches pushed to the freelist before attempting to release.\n    if (BlockSize < PageSize / 16U) {\n      if (!Force && BytesPushed < Region->AllocatedUser / 16U)\n        return 0;\n      // We want 8x% to 9x% free bytes (the larger the block, the lower the %).\n      if ((BytesInFreeList * 100U) / Region->AllocatedUser <\n          (100U - 1U - BlockSize / 16U))\n        return 0;\n    }\n\n    if (!Force) {\n      const s32 IntervalMs = atomic_load_relaxed(&ReleaseToOsIntervalMs);\n      if (IntervalMs < 0)\n        return 0;\n      if (Region->ReleaseInfo.LastReleaseAtNs +\n              static_cast<u64>(IntervalMs) * 1000000 >\n          getMonotonicTime()) {\n        return 0; // Memory was returned recently.\n      }\n    }\n\n    ReleaseRecorder Recorder(Region->RegionBeg, &Region->Data);\n    const uptr CompactPtrBase = getCompactPtrBaseByClassId(ClassId);\n    auto DecompactPtr = [CompactPtrBase](CompactPtrT CompactPtr) {\n      return decompactPtrInternal(CompactPtrBase, CompactPtr);\n    };\n    auto SkipRegion = [](UNUSED uptr RegionIndex) { return false; };\n    releaseFreeMemoryToOS(Region->FreeList, Region->AllocatedUser, 1U,\n                          BlockSize, &Recorder, DecompactPtr, SkipRegion);\n\n    if (Recorder.getReleasedRangesCount() > 0) {\n      Region->ReleaseInfo.PushedBlocksAtLastRelease =\n          Region->Stats.PushedBlocks;\n      Region->ReleaseInfo.RangesReleased += Recorder.getReleasedRangesCount();\n      Region->ReleaseInfo.LastReleasedBytes = Recorder.getReleasedBytes();\n    }\n    Region->ReleaseInfo.LastReleaseAtNs = getMonotonicTime();\n    return Recorder.getReleasedBytes();\n  }\n};\n\n} // namespace scudo\n\n#endif // SCUDO_PRIMARY64_H_\n"}, "21": {"id": 21, "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/scudo/standalone/quarantine.h", "content": "//===-- quarantine.h --------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef SCUDO_QUARANTINE_H_\n#define SCUDO_QUARANTINE_H_\n\n#include \"list.h\"\n#include \"mutex.h\"\n#include \"string_utils.h\"\n\nnamespace scudo {\n\nstruct QuarantineBatch {\n  // With the following count, a batch (and the header that protects it) occupy\n  // 4096 bytes on 32-bit platforms, and 8192 bytes on 64-bit.\n  static const u32 MaxCount = 1019;\n  QuarantineBatch *Next;\n  uptr Size;\n  u32 Count;\n  void *Batch[MaxCount];\n\n  void init(void *Ptr, uptr Size) {\n    Count = 1;\n    Batch[0] = Ptr;\n    this->Size = Size + sizeof(QuarantineBatch); // Account for the Batch Size.\n  }\n\n  // The total size of quarantined nodes recorded in this batch.\n  uptr getQuarantinedSize() const { return Size - sizeof(QuarantineBatch); }\n\n  void push_back(void *Ptr, uptr Size) {\n    DCHECK_LT(Count, MaxCount);\n    Batch[Count++] = Ptr;\n    this->Size += Size;\n  }\n\n  bool canMerge(const QuarantineBatch *const From) const {\n    return Count + From->Count <= MaxCount;\n  }\n\n  void merge(QuarantineBatch *const From) {\n    DCHECK_LE(Count + From->Count, MaxCount);\n    DCHECK_GE(Size, sizeof(QuarantineBatch));\n\n    for (uptr I = 0; I < From->Count; ++I)\n      Batch[Count + I] = From->Batch[I];\n    Count += From->Count;\n    Size += From->getQuarantinedSize();\n\n    From->Count = 0;\n    From->Size = sizeof(QuarantineBatch);\n  }\n\n  void shuffle(u32 State) { ::scudo::shuffle(Batch, Count, &State); }\n};\n\nstatic_assert(sizeof(QuarantineBatch) <= (1U << 13), \"\"); // 8Kb.\n\n// Per-thread cache of memory blocks.\ntemplate <typename Callback> class QuarantineCache {\npublic:\n  void initLinkerInitialized() {}\n  void init() {\n    memset(this, 0, sizeof(*this));\n    initLinkerInitialized();\n  }\n\n  // Total memory used, including internal accounting.\n  uptr getSize() const { return atomic_load_relaxed(&Size); }\n  // Memory used for internal accounting.\n  uptr getOverheadSize() const { return List.size() * sizeof(QuarantineBatch); }\n\n  void enqueue(Callback Cb, void *Ptr, uptr Size) {\n    if (List.empty() || List.back()->Count == QuarantineBatch::MaxCount) {\n      QuarantineBatch *B =\n          reinterpret_cast<QuarantineBatch *>(Cb.allocate(sizeof(*B)));\n      DCHECK(B);\n      B->init(Ptr, Size);\n      enqueueBatch(B);\n    } else {\n      List.back()->push_back(Ptr, Size);\n      addToSize(Size);\n    }\n  }\n\n  void transfer(QuarantineCache *From) {\n    List.append_back(&From->List);\n    addToSize(From->getSize());\n    atomic_store_relaxed(&From->Size, 0);\n  }\n\n  void enqueueBatch(QuarantineBatch *B) {\n    List.push_back(B);\n    addToSize(B->Size);\n  }\n\n  QuarantineBatch *dequeueBatch() {\n    if (List.empty())\n      return nullptr;\n    QuarantineBatch *B = List.front();\n    List.pop_front();\n    subFromSize(B->Size);\n    return B;\n  }\n\n  void mergeBatches(QuarantineCache *ToDeallocate) {\n    uptr ExtractedSize = 0;\n    QuarantineBatch *Current = List.front();\n    while (Current && Current->Next) {\n      if (Current->canMerge(Current->Next)) {\n        QuarantineBatch *Extracted = Current->Next;\n        // Move all the chunks into the current batch.\n        Current->merge(Extracted);\n        DCHECK_EQ(Extracted->Count, 0);\n        DCHECK_EQ(Extracted->Size, sizeof(QuarantineBatch));\n        // Remove the next batch From the list and account for its Size.\n        List.extract(Current, Extracted);\n        ExtractedSize += Extracted->Size;\n        // Add it to deallocation list.\n        ToDeallocate->enqueueBatch(Extracted);\n      } else {\n        Current = Current->Next;\n      }\n    }\n    subFromSize(ExtractedSize);\n  }\n\n  void getStats(ScopedString *Str) const {\n    uptr BatchCount = 0;\n    uptr TotalOverheadBytes = 0;\n    uptr TotalBytes = 0;\n    uptr TotalQuarantineChunks = 0;\n    for (const QuarantineBatch &Batch : List) {\n      BatchCount++;\n      TotalBytes += Batch.Size;\n      TotalOverheadBytes += Batch.Size - Batch.getQuarantinedSize();\n      TotalQuarantineChunks += Batch.Count;\n    }\n    const uptr QuarantineChunksCapacity =\n        BatchCount * QuarantineBatch::MaxCount;\n    const uptr ChunksUsagePercent =\n        (QuarantineChunksCapacity == 0)\n            ? 0\n            : TotalQuarantineChunks * 100 / QuarantineChunksCapacity;\n    const uptr TotalQuarantinedBytes = TotalBytes - TotalOverheadBytes;\n    const uptr MemoryOverheadPercent =\n        (TotalQuarantinedBytes == 0)\n            ? 0\n            : TotalOverheadBytes * 100 / TotalQuarantinedBytes;\n    Str->append(\n        \"Stats: Quarantine: batches: %zu; bytes: %zu (user: %zu); chunks: %zu \"\n        \"(capacity: %zu); %zu%% chunks used; %zu%% memory overhead\\n\",\n        BatchCount, TotalBytes, TotalQuarantinedBytes, TotalQuarantineChunks,\n        QuarantineChunksCapacity, ChunksUsagePercent, MemoryOverheadPercent);\n  }\n\nprivate:\n  SinglyLinkedList<QuarantineBatch> List;\n  atomic_uptr Size = {};\n\n  void addToSize(uptr add) { atomic_store_relaxed(&Size, getSize() + add); }\n  void subFromSize(uptr sub) { atomic_store_relaxed(&Size, getSize() - sub); }\n};\n\n// The callback interface is:\n// void Callback::recycle(Node *Ptr);\n// void *Callback::allocate(uptr Size);\n// void Callback::deallocate(void *Ptr);\ntemplate <typename Callback, typename Node> class GlobalQuarantine {\npublic:\n  typedef QuarantineCache<Callback> CacheT;\n\n  void initLinkerInitialized(uptr Size, uptr CacheSize) {\n    // Thread local quarantine size can be zero only when global quarantine size\n    // is zero (it allows us to perform just one atomic read per put() call).\n    CHECK((Size == 0 && CacheSize == 0) || CacheSize != 0);\n\n    atomic_store_relaxed(&MaxSize, Size);\n    atomic_store_relaxed(&MinSize, Size / 10 * 9); // 90% of max size.\n    atomic_store_relaxed(&MaxCacheSize, CacheSize);\n\n    Cache.initLinkerInitialized();\n  }\n  void init(uptr Size, uptr CacheSize) {\n    CacheMutex.init();\n    Cache.init();\n    RecycleMutex.init();\n    MinSize = {};\n    MaxSize = {};\n    MaxCacheSize = {};\n    initLinkerInitialized(Size, CacheSize);\n  }\n\n  uptr getMaxSize() const { return atomic_load_relaxed(&MaxSize); }\n  uptr getCacheSize() const { return atomic_load_relaxed(&MaxCacheSize); }\n\n  void put(CacheT *C, Callback Cb, Node *Ptr, uptr Size) {\n    C->enqueue(Cb, Ptr, Size);\n    if (C->getSize() > getCacheSize())\n      drain(C, Cb);\n  }\n\n  void NOINLINE drain(CacheT *C, Callback Cb) {\n    {\n      ScopedLock L(CacheMutex);\n      Cache.transfer(C);\n    }\n    if (Cache.getSize() > getMaxSize() && RecycleMutex.tryLock())\n      recycle(atomic_load_relaxed(&MinSize), Cb);\n  }\n\n  void NOINLINE drainAndRecycle(CacheT *C, Callback Cb) {\n    {\n      ScopedLock L(CacheMutex);\n      Cache.transfer(C);\n    }\n    RecycleMutex.lock();\n    recycle(0, Cb);\n  }\n\n  void getStats(ScopedString *Str) const {\n    // It assumes that the world is stopped, just as the allocator's printStats.\n    Cache.getStats(Str);\n    Str->append(\"Quarantine limits: global: %zuK; thread local: %zuK\\n\",\n                getMaxSize() >> 10, getCacheSize() >> 10);\n  }\n\n  void disable() {\n    // RecycleMutex must be locked 1st since we grab CacheMutex within recycle.\n    RecycleMutex.lock();\n    CacheMutex.lock();\n  }\n\n  void enable() {\n    CacheMutex.unlock();\n    RecycleMutex.unlock();\n  }\n\nprivate:\n  // Read-only data.\n  alignas(SCUDO_CACHE_LINE_SIZE) HybridMutex CacheMutex;\n  CacheT Cache;\n  alignas(SCUDO_CACHE_LINE_SIZE) HybridMutex RecycleMutex;\n  atomic_uptr MinSize = {};\n  atomic_uptr MaxSize = {};\n  alignas(SCUDO_CACHE_LINE_SIZE) atomic_uptr MaxCacheSize = {};\n\n  void NOINLINE recycle(uptr MinSize, Callback Cb) {\n    CacheT Tmp;\n    Tmp.init();\n    {\n      ScopedLock L(CacheMutex);\n      // Go over the batches and merge partially filled ones to\n      // save some memory, otherwise batches themselves (since the memory used\n      // by them is counted against quarantine limit) can overcome the actual\n      // user's quarantined chunks, which diminishes the purpose of the\n      // quarantine.\n      const uptr CacheSize = Cache.getSize();\n      const uptr OverheadSize = Cache.getOverheadSize();\n      DCHECK_GE(CacheSize, OverheadSize);\n      // Do the merge only when overhead exceeds this predefined limit (might\n      // require some tuning). It saves us merge attempt when the batch list\n      // quarantine is unlikely to contain batches suitable for merge.\n      constexpr uptr OverheadThresholdPercents = 100;\n      if (CacheSize > OverheadSize &&\n          OverheadSize * (100 + OverheadThresholdPercents) >\n              CacheSize * OverheadThresholdPercents) {\n        Cache.mergeBatches(&Tmp);\n      }\n      // Extract enough chunks from the quarantine to get below the max\n      // quarantine size and leave some leeway for the newly quarantined chunks.\n      while (Cache.getSize() > MinSize)\n        Tmp.enqueueBatch(Cache.dequeueBatch());\n    }\n    RecycleMutex.unlock();\n    doRecycle(&Tmp, Cb);\n  }\n\n  void NOINLINE doRecycle(CacheT *C, Callback Cb) {\n    while (QuarantineBatch *B = C->dequeueBatch()) {\n      const u32 Seed = static_cast<u32>(\n          (reinterpret_cast<uptr>(B) ^ reinterpret_cast<uptr>(C)) >> 4);\n      B->shuffle(Seed);\n      constexpr uptr NumberOfPrefetch = 8UL;\n      CHECK(NumberOfPrefetch <= ARRAY_SIZE(B->Batch));\n      for (uptr I = 0; I < NumberOfPrefetch; I++)\n        PREFETCH(B->Batch[I]);\n      for (uptr I = 0, Count = B->Count; I < Count; I++) {\n        if (I + NumberOfPrefetch < Count)\n          PREFETCH(B->Batch[I + NumberOfPrefetch]);\n        Cb.recycle(reinterpret_cast<Node *>(B->Batch[I]));\n      }\n      Cb.deallocate(B);\n    }\n  }\n};\n\n} // namespace scudo\n\n#endif // SCUDO_QUARANTINE_H_\n"}, "22": {"id": 22, "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/scudo/standalone/release.h", "content": "//===-- release.h -----------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef SCUDO_RELEASE_H_\n#define SCUDO_RELEASE_H_\n\n#include \"common.h\"\n#include \"list.h\"\n#include \"mutex.h\"\n\nnamespace scudo {\n\nclass ReleaseRecorder {\npublic:\n  ReleaseRecorder(uptr Base, MapPlatformData *Data = nullptr)\n      : Base(Base), Data(Data) {}\n\n  uptr getReleasedRangesCount() const { return ReleasedRangesCount; }\n\n  uptr getReleasedBytes() const { return ReleasedBytes; }\n\n  uptr getBase() const { return Base; }\n\n  // Releases [From, To) range of pages back to OS.\n  void releasePageRangeToOS(uptr From, uptr To) {\n    const uptr Size = To - From;\n    releasePagesToOS(Base, From, Size, Data);\n    ReleasedRangesCount++;\n    ReleasedBytes += Size;\n  }\n\nprivate:\n  uptr ReleasedRangesCount = 0;\n  uptr ReleasedBytes = 0;\n  uptr Base = 0;\n  MapPlatformData *Data = nullptr;\n};\n\n// A packed array of Counters. Each counter occupies 2^N bits, enough to store\n// counter's MaxValue. Ctor will try to use a static buffer first, and if that\n// fails (the buffer is too small or already locked), will allocate the\n// required Buffer via map(). The caller is expected to check whether the\n// initialization was successful by checking isAllocated() result. For\n// performance sake, none of the accessors check the validity of the arguments,\n// It is assumed that Index is always in [0, N) range and the value is not\n// incremented past MaxValue.\nclass PackedCounterArray {\npublic:\n  PackedCounterArray(uptr NumberOfRegions, uptr CountersPerRegion,\n                     uptr MaxValue)\n      : Regions(NumberOfRegions), NumCounters(CountersPerRegion) {\n    DCHECK_GT(Regions, 0);\n    DCHECK_GT(NumCounters, 0);\n    DCHECK_GT(MaxValue, 0);\n    constexpr uptr MaxCounterBits = sizeof(*Buffer) * 8UL;\n    // Rounding counter storage size up to the power of two allows for using\n    // bit shifts calculating particular counter's Index and offset.\n    const uptr CounterSizeBits =\n        roundUpToPowerOfTwo(getMostSignificantSetBitIndex(MaxValue) + 1);\n    DCHECK_LE(CounterSizeBits, MaxCounterBits);\n    CounterSizeBitsLog = getLog2(CounterSizeBits);\n    CounterMask = ~(static_cast<uptr>(0)) >> (MaxCounterBits - CounterSizeBits);\n\n    const uptr PackingRatio = MaxCounterBits >> CounterSizeBitsLog;\n    DCHECK_GT(PackingRatio, 0);\n    PackingRatioLog = getLog2(PackingRatio);\n    BitOffsetMask = PackingRatio - 1;\n\n    SizePerRegion =\n        roundUpTo(NumCounters, static_cast<uptr>(1U) << PackingRatioLog) >>\n        PackingRatioLog;\n    BufferSize = SizePerRegion * sizeof(*Buffer) * Regions;\n    if (BufferSize <= (StaticBufferCount * sizeof(Buffer[0])) &&\n        Mutex.tryLock()) {\n      Buffer = &StaticBuffer[0];\n      memset(Buffer, 0, BufferSize);\n    } else {\n      Buffer = reinterpret_cast<uptr *>(\n          map(nullptr, roundUpTo(BufferSize, getPageSizeCached()),\n              \"scudo:counters\", MAP_ALLOWNOMEM));\n    }\n  }\n  ~PackedCounterArray() {\n    if (!isAllocated())\n      return;\n    if (Buffer == &StaticBuffer[0])\n      Mutex.unlock();\n    else\n      unmap(reinterpret_cast<void *>(Buffer),\n            roundUpTo(BufferSize, getPageSizeCached()));\n  }\n\n  bool isAllocated() const { return !!Buffer; }\n\n  uptr getCount() const { return NumCounters; }\n\n  uptr get(uptr Region, uptr I) const {\n    DCHECK_LT(Region, Regions);\n    DCHECK_LT(I, NumCounters);\n    const uptr Index = I >> PackingRatioLog;\n    const uptr BitOffset = (I & BitOffsetMask) << CounterSizeBitsLog;\n    return (Buffer[Region * SizePerRegion + Index] >> BitOffset) & CounterMask;\n  }\n\n  void inc(uptr Region, uptr I) const {\n    DCHECK_LT(get(Region, I), CounterMask);\n    const uptr Index = I >> PackingRatioLog;\n    const uptr BitOffset = (I & BitOffsetMask) << CounterSizeBitsLog;\n    DCHECK_LT(BitOffset, SCUDO_WORDSIZE);\n    Buffer[Region * SizePerRegion + Index] += static_cast<uptr>(1U)\n                                              << BitOffset;\n  }\n\n  void incRange(uptr Region, uptr From, uptr To) const {\n    DCHECK_LE(From, To);\n    const uptr Top = Min(To + 1, NumCounters);\n    for (uptr I = From; I < Top; I++)\n      inc(Region, I);\n  }\n\n  uptr getBufferSize() const { return BufferSize; }\n\n  static const uptr StaticBufferCount = 2048U;\n\nprivate:\n  const uptr Regions;\n  const uptr NumCounters;\n  uptr CounterSizeBitsLog;\n  uptr CounterMask;\n  uptr PackingRatioLog;\n  uptr BitOffsetMask;\n\n  uptr SizePerRegion;\n  uptr BufferSize;\n  uptr *Buffer;\n\n  static HybridMutex Mutex;\n  static uptr StaticBuffer[StaticBufferCount];\n};\n\ntemplate <class ReleaseRecorderT> class FreePagesRangeTracker {\npublic:\n  explicit FreePagesRangeTracker(ReleaseRecorderT *Recorder)\n      : Recorder(Recorder), PageSizeLog(getLog2(getPageSizeCached())) {}\n\n  void processNextPage(bool Freed) {\n    if (Freed) {\n      if (!InRange) {\n        CurrentRangeStatePage = CurrentPage;\n        InRange = true;\n      }\n    } else {\n      closeOpenedRange();\n    }\n    CurrentPage++;\n  }\n\n  void skipPages(uptr N) {\n    closeOpenedRange();\n    CurrentPage += N;\n  }\n\n  void finish() { closeOpenedRange(); }\n\nprivate:\n  void closeOpenedRange() {\n    if (InRange) {\n      Recorder->releasePageRangeToOS((CurrentRangeStatePage << PageSizeLog),\n                                     (CurrentPage << PageSizeLog));\n      InRange = false;\n    }\n  }\n\n  ReleaseRecorderT *const Recorder;\n  const uptr PageSizeLog;\n  bool InRange = false;\n  uptr CurrentPage = 0;\n  uptr CurrentRangeStatePage = 0;\n};\n\ntemplate <class TransferBatchT, class ReleaseRecorderT, typename DecompactPtrT,\n          typename SkipRegionT>\nNOINLINE void\nreleaseFreeMemoryToOS(const IntrusiveList<TransferBatchT> &FreeList,\n                      uptr RegionSize, uptr NumberOfRegions, uptr BlockSize,\n                      ReleaseRecorderT *Recorder, DecompactPtrT DecompactPtr,\n                      SkipRegionT SkipRegion) {\n  const uptr PageSize = getPageSizeCached();\n\n  // Figure out the number of chunks per page and whether we can take a fast\n  // path (the number of chunks per page is the same for all pages).\n  uptr FullPagesBlockCountMax;\n  bool SameBlockCountPerPage;\n  if (BlockSize <= PageSize) {\n    if (PageSize % BlockSize == 0) {\n      // Same number of chunks per page, no cross overs.\n      FullPagesBlockCountMax = PageSize / BlockSize;\n      SameBlockCountPerPage = true;\n    } else if (BlockSize % (PageSize % BlockSize) == 0) {\n      // Some chunks are crossing page boundaries, which means that the page\n      // contains one or two partial chunks, but all pages contain the same\n      // number of chunks.\n      FullPagesBlockCountMax = PageSize / BlockSize + 1;\n      SameBlockCountPerPage = true;\n    } else {\n      // Some chunks are crossing page boundaries, which means that the page\n      // contains one or two partial chunks.\n      FullPagesBlockCountMax = PageSize / BlockSize + 2;\n      SameBlockCountPerPage = false;\n    }\n  } else {\n    if (BlockSize % PageSize == 0) {\n      // One chunk covers multiple pages, no cross overs.\n      FullPagesBlockCountMax = 1;\n      SameBlockCountPerPage = true;\n    } else {\n      // One chunk covers multiple pages, Some chunks are crossing page\n      // boundaries. Some pages contain one chunk, some contain two.\n      FullPagesBlockCountMax = 2;\n      SameBlockCountPerPage = false;\n    }\n  }\n\n  const uptr PagesCount = roundUpTo(RegionSize, PageSize) / PageSize;\n  PackedCounterArray Counters(NumberOfRegions, PagesCount,\n                              FullPagesBlockCountMax);\n  if (!Counters.isAllocated())\n    return;\n\n  const uptr PageSizeLog = getLog2(PageSize);\n  const uptr RoundedRegionSize = PagesCount << PageSizeLog;\n  const uptr RoundedSize = NumberOfRegions * RoundedRegionSize;\n\n  // Iterate over free chunks and count how many free chunks affect each\n  // allocated page.\n  if (BlockSize <= PageSize && PageSize % BlockSize == 0) {\n    // Each chunk affects one page only.\n    for (const auto &It : FreeList) {\n      for (u32 I = 0; I < It.getCount(); I++) {\n        const uptr P = DecompactPtr(It.get(I)) - Recorder->getBase();\n        if (P >= RoundedSize)\n          continue;\n        const uptr RegionIndex = NumberOfRegions == 1U ? 0 : P / RegionSize;\n        const uptr PInRegion = P - RegionIndex * RegionSize;\n        Counters.inc(RegionIndex, PInRegion >> PageSizeLog);\n      }\n    }\n  } else {\n    // In all other cases chunks might affect more than one page.\n    DCHECK_GE(RegionSize, BlockSize);\n    const uptr LastBlockInRegion = ((RegionSize / BlockSize) - 1U) * BlockSize;\n    for (const auto &It : FreeList) {\n      for (u32 I = 0; I < It.getCount(); I++) {\n        const uptr P = DecompactPtr(It.get(I)) - Recorder->getBase();\n        if (P >= RoundedSize)\n          continue;\n        const uptr RegionIndex = NumberOfRegions == 1U ? 0 : P / RegionSize;\n        uptr PInRegion = P - RegionIndex * RegionSize;\n        Counters.incRange(RegionIndex, PInRegion >> PageSizeLog,\n                          (PInRegion + BlockSize - 1) >> PageSizeLog);\n        // The last block in a region might straddle a page, so if it's\n        // free, we mark the following \"pretend\" memory block(s) as free.\n        if (PInRegion == LastBlockInRegion) {\n          PInRegion += BlockSize;\n          while (PInRegion < RoundedRegionSize) {\n            Counters.incRange(RegionIndex, PInRegion >> PageSizeLog,\n                              (PInRegion + BlockSize - 1) >> PageSizeLog);\n            PInRegion += BlockSize;\n          }\n        }\n      }\n    }\n  }\n\n  // Iterate over pages detecting ranges of pages with chunk Counters equal\n  // to the expected number of chunks for the particular page.\n  FreePagesRangeTracker<ReleaseRecorderT> RangeTracker(Recorder);\n  if (SameBlockCountPerPage) {\n    // Fast path, every page has the same number of chunks affecting it.\n    for (uptr I = 0; I < NumberOfRegions; I++) {\n      if (SkipRegion(I)) {\n        RangeTracker.skipPages(PagesCount);\n        continue;\n      }\n      for (uptr J = 0; J < PagesCount; J++)\n        RangeTracker.processNextPage(Counters.get(I, J) ==\n                                     FullPagesBlockCountMax);\n    }\n  } else {\n    // Slow path, go through the pages keeping count how many chunks affect\n    // each page.\n    const uptr Pn = BlockSize < PageSize ? PageSize / BlockSize : 1;\n    const uptr Pnc = Pn * BlockSize;\n    // The idea is to increment the current page pointer by the first chunk\n    // size, middle portion size (the portion of the page covered by chunks\n    // except the first and the last one) and then the last chunk size, adding\n    // up the number of chunks on the current page and checking on every step\n    // whether the page boundary was crossed.\n    for (uptr I = 0; I < NumberOfRegions; I++) {\n      if (SkipRegion(I)) {\n        RangeTracker.skipPages(PagesCount);\n        continue;\n      }\n      uptr PrevPageBoundary = 0;\n      uptr CurrentBoundary = 0;\n      for (uptr J = 0; J < PagesCount; J++) {\n        const uptr PageBoundary = PrevPageBoundary + PageSize;\n        uptr BlocksPerPage = Pn;\n        if (CurrentBoundary < PageBoundary) {\n          if (CurrentBoundary > PrevPageBoundary)\n            BlocksPerPage++;\n          CurrentBoundary += Pnc;\n          if (CurrentBoundary < PageBoundary) {\n            BlocksPerPage++;\n            CurrentBoundary += BlockSize;\n          }\n        }\n        PrevPageBoundary = PageBoundary;\n        RangeTracker.processNextPage(Counters.get(I, J) == BlocksPerPage);\n      }\n    }\n  }\n  RangeTracker.finish();\n}\n\n} // namespace scudo\n\n#endif // SCUDO_RELEASE_H_\n"}, "23": {"id": 23, "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/scudo/standalone/report.h", "content": "//===-- report.h ------------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef SCUDO_REPORT_H_\n#define SCUDO_REPORT_H_\n\n#include \"internal_defs.h\"\n\nnamespace scudo {\n\n// Reports are *fatal* unless stated otherwise.\n\n// Generic error.\nvoid NORETURN reportError(const char *Message);\n\n// Flags related errors.\nvoid NORETURN reportInvalidFlag(const char *FlagType, const char *Value);\n\n// Chunk header related errors.\nvoid NORETURN reportHeaderCorruption(void *Ptr);\nvoid NORETURN reportHeaderRace(void *Ptr);\n\n// Sanity checks related error.\nvoid NORETURN reportSanityCheckError(const char *Field);\n\n// Combined allocator errors.\nvoid NORETURN reportAlignmentTooBig(uptr Alignment, uptr MaxAlignment);\nvoid NORETURN reportAllocationSizeTooBig(uptr UserSize, uptr TotalSize,\n                                         uptr MaxSize);\nvoid NORETURN reportOutOfMemory(uptr RequestedSize);\nenum class AllocatorAction : u8 {\n  Recycling,\n  Deallocating,\n  Reallocating,\n  Sizing,\n};\nvoid NORETURN reportInvalidChunkState(AllocatorAction Action, void *Ptr);\nvoid NORETURN reportMisalignedPointer(AllocatorAction Action, void *Ptr);\nvoid NORETURN reportDeallocTypeMismatch(AllocatorAction Action, void *Ptr,\n                                        u8 TypeA, u8 TypeB);\nvoid NORETURN reportDeleteSizeMismatch(void *Ptr, uptr Size, uptr ExpectedSize);\n\n// C wrappers errors.\nvoid NORETURN reportAlignmentNotPowerOfTwo(uptr Alignment);\nvoid NORETURN reportInvalidPosixMemalignAlignment(uptr Alignment);\nvoid NORETURN reportCallocOverflow(uptr Count, uptr Size);\nvoid NORETURN reportPvallocOverflow(uptr Size);\nvoid NORETURN reportInvalidAlignedAllocAlignment(uptr Size, uptr Alignment);\n\n} // namespace scudo\n\n#endif // SCUDO_REPORT_H_\n"}, "24": {"id": 24, "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/scudo/standalone/secondary.h", "content": "//===-- secondary.h ---------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef SCUDO_SECONDARY_H_\n#define SCUDO_SECONDARY_H_\n\n#include \"chunk.h\"\n#include \"common.h\"\n#include \"list.h\"\n#include \"memtag.h\"\n#include \"mutex.h\"\n#include \"options.h\"\n#include \"stats.h\"\n#include \"string_utils.h\"\n\nnamespace scudo {\n\n// This allocator wraps the platform allocation primitives, and as such is on\n// the slower side and should preferably be used for larger sized allocations.\n// Blocks allocated will be preceded and followed by a guard page, and hold\n// their own header that is not checksummed: the guard pages and the Combined\n// header should be enough for our purpose.\n\nnamespace LargeBlock {\n\nstruct Header {\n  LargeBlock::Header *Prev;\n  LargeBlock::Header *Next;\n  uptr CommitBase;\n  uptr CommitSize;\n  uptr MapBase;\n  uptr MapSize;\n  [[no_unique_address]] MapPlatformData Data;\n};\n\nconstexpr uptr getHeaderSize() {\n  return roundUpTo(sizeof(Header), 1U << SCUDO_MIN_ALIGNMENT_LOG);\n}\n\ntemplate <typename Config> static uptr addHeaderTag(uptr Ptr) {\n  if (allocatorSupportsMemoryTagging<Config>())\n    return addFixedTag(Ptr, 1);\n  return Ptr;\n}\n\ntemplate <typename Config> static Header *getHeader(uptr Ptr) {\n  return reinterpret_cast<Header *>(addHeaderTag<Config>(Ptr) -\n                                    getHeaderSize());\n}\n\ntemplate <typename Config> static Header *getHeader(const void *Ptr) {\n  return getHeader<Config>(reinterpret_cast<uptr>(Ptr));\n}\n\n} // namespace LargeBlock\n\nstatic void unmap(LargeBlock::Header *H) {\n  MapPlatformData Data = H->Data;\n  unmap(reinterpret_cast<void *>(H->MapBase), H->MapSize, UNMAP_ALL, &Data);\n}\n\nclass MapAllocatorNoCache {\npublic:\n  void initLinkerInitialized(UNUSED s32 ReleaseToOsInterval) {}\n  void init(UNUSED s32 ReleaseToOsInterval) {}\n  bool retrieve(UNUSED Options Options, UNUSED uptr Size, UNUSED uptr Alignment,\n                UNUSED LargeBlock::Header **H, UNUSED bool *Zeroed) {\n    return false;\n  }\n  void store(UNUSED Options Options, LargeBlock::Header *H) { unmap(H); }\n  bool canCache(UNUSED uptr Size) { return false; }\n  void disable() {}\n  void enable() {}\n  void releaseToOS() {}\n  void disableMemoryTagging() {}\n  bool setOption(Option O, UNUSED sptr Value) {\n    if (O == Option::ReleaseInterval || O == Option::MaxCacheEntriesCount ||\n        O == Option::MaxCacheEntrySize)\n      return false;\n    // Not supported by the Secondary Cache, but not an error either.\n    return true;\n  }\n};\n\nstatic const uptr MaxUnusedCachePages = 4U;\n\ntemplate <typename Config>\nvoid mapSecondary(Options Options, uptr CommitBase, uptr CommitSize,\n                  uptr AllocPos, uptr Flags, MapPlatformData *Data) {\n  const uptr MaxUnusedCacheBytes = MaxUnusedCachePages * getPageSizeCached();\n  if (useMemoryTagging<Config>(Options) && CommitSize > MaxUnusedCacheBytes) {\n    const uptr UntaggedPos = Max(AllocPos, CommitBase + MaxUnusedCacheBytes);\n    map(reinterpret_cast<void *>(CommitBase), UntaggedPos - CommitBase,\n        \"scudo:secondary\", MAP_RESIZABLE | MAP_MEMTAG | Flags, Data);\n    map(reinterpret_cast<void *>(UntaggedPos),\n        CommitBase + CommitSize - UntaggedPos, \"scudo:secondary\",\n        MAP_RESIZABLE | Flags, Data);\n  } else {\n    map(reinterpret_cast<void *>(CommitBase), CommitSize, \"scudo:secondary\",\n        MAP_RESIZABLE | (useMemoryTagging<Config>(Options) ? MAP_MEMTAG : 0) |\n            Flags,\n        Data);\n  }\n}\n\ntemplate <typename Config> class MapAllocatorCache {\npublic:\n  // Ensure the default maximum specified fits the array.\n  static_assert(Config::SecondaryCacheDefaultMaxEntriesCount <=\n                    Config::SecondaryCacheEntriesArraySize,\n                \"\");\n\n  void initLinkerInitialized(s32 ReleaseToOsInterval) {\n    setOption(Option::MaxCacheEntriesCount,\n              static_cast<sptr>(Config::SecondaryCacheDefaultMaxEntriesCount));\n    setOption(Option::MaxCacheEntrySize,\n              static_cast<sptr>(Config::SecondaryCacheDefaultMaxEntrySize));\n    setOption(Option::ReleaseInterval, static_cast<sptr>(ReleaseToOsInterval));\n  }\n  void init(s32 ReleaseToOsInterval) {\n    memset(this, 0, sizeof(*this));\n    initLinkerInitialized(ReleaseToOsInterval);\n  }\n\n  void store(Options Options, LargeBlock::Header *H) {\n    if (!canCache(H->CommitSize))\n      return unmap(H);\n\n    bool EntryCached = false;\n    bool EmptyCache = false;\n    const s32 Interval = atomic_load_relaxed(&ReleaseToOsIntervalMs);\n    const u64 Time = getMonotonicTime();\n    const u32 MaxCount = atomic_load_relaxed(&MaxEntriesCount);\n    CachedBlock Entry;\n    Entry.CommitBase = H->CommitBase;\n    Entry.CommitSize = H->CommitSize;\n    Entry.MapBase = H->MapBase;\n    Entry.MapSize = H->MapSize;\n    Entry.BlockBegin = reinterpret_cast<uptr>(H + 1);\n    Entry.Data = H->Data;\n    Entry.Time = Time;\n    if (useMemoryTagging<Config>(Options)) {\n      if (Interval == 0 && !SCUDO_FUCHSIA) {\n        // Release the memory and make it inaccessible at the same time by\n        // creating a new MAP_NOACCESS mapping on top of the existing mapping.\n        // Fuchsia does not support replacing mappings by creating a new mapping\n        // on top so we just do the two syscalls there.\n        Entry.Time = 0;\n        mapSecondary<Config>(Options, Entry.CommitBase, Entry.CommitSize,\n                             Entry.CommitBase, MAP_NOACCESS, &Entry.Data);\n      } else {\n        setMemoryPermission(Entry.CommitBase, Entry.CommitSize, MAP_NOACCESS,\n                            &Entry.Data);\n      }\n    } else if (Interval == 0) {\n      releasePagesToOS(Entry.CommitBase, 0, Entry.CommitSize, &Entry.Data);\n      Entry.Time = 0;\n    }\n    do {\n      ScopedLock L(Mutex);\n      if (useMemoryTagging<Config>(Options) && QuarantinePos == -1U) {\n        // If we get here then memory tagging was disabled in between when we\n        // read Options and when we locked Mutex. We can't insert our entry into\n        // the quarantine or the cache because the permissions would be wrong so\n        // just unmap it.\n        break;\n      }\n      if (Config::SecondaryCacheQuarantineSize &&\n          useMemoryTagging<Config>(Options)) {\n        QuarantinePos =\n            (QuarantinePos + 1) % Max(Config::SecondaryCacheQuarantineSize, 1u);\n        if (!Quarantine[QuarantinePos].CommitBase) {\n          Quarantine[QuarantinePos] = Entry;\n          return;\n        }\n        CachedBlock PrevEntry = Quarantine[QuarantinePos];\n        Quarantine[QuarantinePos] = Entry;\n        if (OldestTime == 0)\n          OldestTime = Entry.Time;\n        Entry = PrevEntry;\n      }\n      if (EntriesCount >= MaxCount) {\n        if (IsFullEvents++ == 4U)\n          EmptyCache = true;\n      } else {\n        for (u32 I = 0; I < MaxCount; I++) {\n          if (Entries[I].CommitBase)\n            continue;\n          if (I != 0)\n            Entries[I] = Entries[0];\n          Entries[0] = Entry;\n          EntriesCount++;\n          if (OldestTime == 0)\n            OldestTime = Entry.Time;\n          EntryCached = true;\n          break;\n        }\n      }\n    } while (0);\n    if (EmptyCache)\n      empty();\n    else if (Interval >= 0)\n      releaseOlderThan(Time - static_cast<u64>(Interval) * 1000000);\n    if (!EntryCached)\n      unmap(reinterpret_cast<void *>(Entry.MapBase), Entry.MapSize, UNMAP_ALL,\n            &Entry.Data);\n  }\n\n  bool retrieve(Options Options, uptr Size, uptr Alignment,\n                LargeBlock::Header **H, bool *Zeroed) {\n    const uptr PageSize = getPageSizeCached();\n    const u32 MaxCount = atomic_load_relaxed(&MaxEntriesCount);\n    bool Found = false;\n    CachedBlock Entry;\n    uptr HeaderPos;\n    {\n      ScopedLock L(Mutex);\n      if (EntriesCount == 0)\n        return false;\n      for (u32 I = 0; I < MaxCount; I++) {\n        const uptr CommitBase = Entries[I].CommitBase;\n        if (!CommitBase)\n          continue;\n        const uptr CommitSize = Entries[I].CommitSize;\n        const uptr AllocPos =\n            roundDownTo(CommitBase + CommitSize - Size, Alignment);\n        HeaderPos =\n            AllocPos - Chunk::getHeaderSize() - LargeBlock::getHeaderSize();\n        if (HeaderPos > CommitBase + CommitSize)\n          continue;\n        if (HeaderPos < CommitBase ||\n            AllocPos > CommitBase + PageSize * MaxUnusedCachePages)\n          continue;\n        Found = true;\n        Entry = Entries[I];\n        Entries[I].CommitBase = 0;\n        break;\n      }\n    }\n    if (Found) {\n      *H = reinterpret_cast<LargeBlock::Header *>(\n          LargeBlock::addHeaderTag<Config>(HeaderPos));\n      *Zeroed = Entry.Time == 0;\n      if (useMemoryTagging<Config>(Options))\n        setMemoryPermission(Entry.CommitBase, Entry.CommitSize, 0, &Entry.Data);\n      uptr NewBlockBegin = reinterpret_cast<uptr>(*H + 1);\n      if (useMemoryTagging<Config>(Options)) {\n        if (*Zeroed)\n          storeTags(LargeBlock::addHeaderTag<Config>(Entry.CommitBase),\n                    NewBlockBegin);\n        else if (Entry.BlockBegin < NewBlockBegin)\n          storeTags(Entry.BlockBegin, NewBlockBegin);\n        else\n          storeTags(untagPointer(NewBlockBegin),\n                    untagPointer(Entry.BlockBegin));\n      }\n      (*H)->CommitBase = Entry.CommitBase;\n      (*H)->CommitSize = Entry.CommitSize;\n      (*H)->MapBase = Entry.MapBase;\n      (*H)->MapSize = Entry.MapSize;\n      (*H)->Data = Entry.Data;\n      EntriesCount--;\n    }\n    return Found;\n  }\n\n  bool canCache(uptr Size) {\n    return atomic_load_relaxed(&MaxEntriesCount) != 0U &&\n           Size <= atomic_load_relaxed(&MaxEntrySize);\n  }\n\n  bool setOption(Option O, sptr Value) {\n    if (O == Option::ReleaseInterval) {\n      const s32 Interval =\n          Max(Min(static_cast<s32>(Value),\n                  Config::SecondaryCacheMaxReleaseToOsIntervalMs),\n              Config::SecondaryCacheMinReleaseToOsIntervalMs);\n      atomic_store_relaxed(&ReleaseToOsIntervalMs, Interval);\n      return true;\n    }\n    if (O == Option::MaxCacheEntriesCount) {\n      const u32 MaxCount = static_cast<u32>(Value);\n      if (MaxCount > Config::SecondaryCacheEntriesArraySize)\n        return false;\n      atomic_store_relaxed(&MaxEntriesCount, MaxCount);\n      return true;\n    }\n    if (O == Option::MaxCacheEntrySize) {\n      atomic_store_relaxed(&MaxEntrySize, static_cast<uptr>(Value));\n      return true;\n    }\n    // Not supported by the Secondary Cache, but not an error either.\n    return true;\n  }\n\n  void releaseToOS() { releaseOlderThan(UINT64_MAX); }\n\n  void disableMemoryTagging() {\n    ScopedLock L(Mutex);\n    for (u32 I = 0; I != Config::SecondaryCacheQuarantineSize; ++I) {\n      if (Quarantine[I].CommitBase) {\n        unmap(reinterpret_cast<void *>(Quarantine[I].MapBase),\n              Quarantine[I].MapSize, UNMAP_ALL, &Quarantine[I].Data);\n        Quarantine[I].CommitBase = 0;\n      }\n    }\n    const u32 MaxCount = atomic_load_relaxed(&MaxEntriesCount);\n    for (u32 I = 0; I < MaxCount; I++)\n      if (Entries[I].CommitBase)\n        setMemoryPermission(Entries[I].CommitBase, Entries[I].CommitSize, 0,\n                            &Entries[I].Data);\n    QuarantinePos = -1U;\n  }\n\n  void disable() { Mutex.lock(); }\n\n  void enable() { Mutex.unlock(); }\n\nprivate:\n  void empty() {\n    struct {\n      void *MapBase;\n      uptr MapSize;\n      MapPlatformData Data;\n    } MapInfo[Config::SecondaryCacheEntriesArraySize];\n    uptr N = 0;\n    {\n      ScopedLock L(Mutex);\n      for (uptr I = 0; I < Config::SecondaryCacheEntriesArraySize; I++) {\n        if (!Entries[I].CommitBase)\n          continue;\n        MapInfo[N].MapBase = reinterpret_cast<void *>(Entries[I].MapBase);\n        MapInfo[N].MapSize = Entries[I].MapSize;\n        MapInfo[N].Data = Entries[I].Data;\n        Entries[I].CommitBase = 0;\n        N++;\n      }\n      EntriesCount = 0;\n      IsFullEvents = 0;\n    }\n    for (uptr I = 0; I < N; I++)\n      unmap(MapInfo[I].MapBase, MapInfo[I].MapSize, UNMAP_ALL,\n            &MapInfo[I].Data);\n  }\n\n  struct CachedBlock {\n    uptr CommitBase;\n    uptr CommitSize;\n    uptr MapBase;\n    uptr MapSize;\n    uptr BlockBegin;\n    [[no_unique_address]] MapPlatformData Data;\n    u64 Time;\n  };\n\n  void releaseIfOlderThan(CachedBlock &Entry, u64 Time) {\n    if (!Entry.CommitBase || !Entry.Time)\n      return;\n    if (Entry.Time > Time) {\n      if (OldestTime == 0 || Entry.Time < OldestTime)\n        OldestTime = Entry.Time;\n      return;\n    }\n    releasePagesToOS(Entry.CommitBase, 0, Entry.CommitSize, &Entry.Data);\n    Entry.Time = 0;\n  }\n\n  void releaseOlderThan(u64 Time) {\n    ScopedLock L(Mutex);\n    if (!EntriesCount || OldestTime == 0 || OldestTime > Time)\n      return;\n    OldestTime = 0;\n    for (uptr I = 0; I < Config::SecondaryCacheQuarantineSize; I++)\n      releaseIfOlderThan(Quarantine[I], Time);\n    for (uptr I = 0; I < Config::SecondaryCacheEntriesArraySize; I++)\n      releaseIfOlderThan(Entries[I], Time);\n  }\n\n  HybridMutex Mutex;\n  u32 EntriesCount = 0;\n  u32 QuarantinePos = 0;\n  atomic_u32 MaxEntriesCount = {};\n  atomic_uptr MaxEntrySize = {};\n  u64 OldestTime = 0;\n  u32 IsFullEvents = 0;\n  atomic_s32 ReleaseToOsIntervalMs = {};\n\n  CachedBlock Entries[Config::SecondaryCacheEntriesArraySize] = {};\n  CachedBlock Quarantine[Config::SecondaryCacheQuarantineSize] = {};\n};\n\ntemplate <typename Config> class MapAllocator {\npublic:\n  void initLinkerInitialized(GlobalStats *S, s32 ReleaseToOsInterval = -1) {\n    Cache.initLinkerInitialized(ReleaseToOsInterval);\n    Stats.initLinkerInitialized();\n    if (LIKELY(S))\n      S->link(&Stats);\n  }\n  void init(GlobalStats *S, s32 ReleaseToOsInterval = -1) {\n    memset(this, 0, sizeof(*this));\n    initLinkerInitialized(S, ReleaseToOsInterval);\n  }\n\n  void *allocate(Options Options, uptr Size, uptr AlignmentHint = 0,\n                 uptr *BlockEnd = nullptr,\n                 FillContentsMode FillContents = NoFill);\n\n  void deallocate(Options Options, void *Ptr);\n\n  static uptr getBlockEnd(void *Ptr) {\n    auto *B = LargeBlock::getHeader<Config>(Ptr);\n    return B->CommitBase + B->CommitSize;\n  }\n\n  static uptr getBlockSize(void *Ptr) {\n    return getBlockEnd(Ptr) - reinterpret_cast<uptr>(Ptr);\n  }\n\n  void getStats(ScopedString *Str) const;\n\n  void disable() {\n    Mutex.lock();\n    Cache.disable();\n  }\n\n  void enable() {\n    Cache.enable();\n    Mutex.unlock();\n  }\n\n  template <typename F> void iterateOverBlocks(F Callback) const {\n    for (const auto &H : InUseBlocks) {\n      uptr Ptr = reinterpret_cast<uptr>(&H) + LargeBlock::getHeaderSize();\n      if (allocatorSupportsMemoryTagging<Config>())\n        Ptr = untagPointer(Ptr);\n      Callback(Ptr);\n    }\n  }\n\n  uptr canCache(uptr Size) { return Cache.canCache(Size); }\n\n  bool setOption(Option O, sptr Value) { return Cache.setOption(O, Value); }\n\n  void releaseToOS() { Cache.releaseToOS(); }\n\n  void disableMemoryTagging() { Cache.disableMemoryTagging(); }\n\nprivate:\n  typename Config::SecondaryCache Cache;\n\n  HybridMutex Mutex;\n  DoublyLinkedList<LargeBlock::Header> InUseBlocks;\n  uptr AllocatedBytes = 0;\n  uptr FreedBytes = 0;\n  uptr LargestSize = 0;\n  u32 NumberOfAllocs = 0;\n  u32 NumberOfFrees = 0;\n  LocalStats Stats;\n};\n\n// As with the Primary, the size passed to this function includes any desired\n// alignment, so that the frontend can align the user allocation. The hint\n// parameter allows us to unmap spurious memory when dealing with larger\n// (greater than a page) alignments on 32-bit platforms.\n// Due to the sparsity of address space available on those platforms, requesting\n// an allocation from the Secondary with a large alignment would end up wasting\n// VA space (even though we are not committing the whole thing), hence the need\n// to trim off some of the reserved space.\n// For allocations requested with an alignment greater than or equal to a page,\n// the committed memory will amount to something close to Size - AlignmentHint\n// (pending rounding and headers).\ntemplate <typename Config>\nvoid *MapAllocator<Config>::allocate(Options Options, uptr Size, uptr Alignment,\n                                     uptr *BlockEndPtr,\n                                     FillContentsMode FillContents) {\n  if (Options.get(OptionBit::AddLargeAllocationSlack))\n    Size += 1UL << SCUDO_MIN_ALIGNMENT_LOG;\n  Alignment = Max(Alignment, 1UL << SCUDO_MIN_ALIGNMENT_LOG);\n  const uptr PageSize = getPageSizeCached();\n  uptr RoundedSize =\n      roundUpTo(roundUpTo(Size, Alignment) + LargeBlock::getHeaderSize() +\n                    Chunk::getHeaderSize(),\n                PageSize);\n  if (Alignment > PageSize)\n    RoundedSize += Alignment - PageSize;\n\n  if (Alignment < PageSize && Cache.canCache(RoundedSize)) {\n    LargeBlock::Header *H;\n    bool Zeroed;\n    if (Cache.retrieve(Options, Size, Alignment, &H, &Zeroed)) {\n      const uptr BlockEnd = H->CommitBase + H->CommitSize;\n      if (BlockEndPtr)\n        *BlockEndPtr = BlockEnd;\n      uptr HInt = reinterpret_cast<uptr>(H);\n      if (allocatorSupportsMemoryTagging<Config>())\n        HInt = untagPointer(HInt);\n      const uptr PtrInt = HInt + LargeBlock::getHeaderSize();\n      void *Ptr = reinterpret_cast<void *>(PtrInt);\n      if (FillContents && !Zeroed)\n        memset(Ptr, FillContents == ZeroFill ? 0 : PatternFillByte,\n               BlockEnd - PtrInt);\n      const uptr BlockSize = BlockEnd - HInt;\n      {\n        ScopedLock L(Mutex);\n        InUseBlocks.push_back(H);\n        AllocatedBytes += BlockSize;\n        NumberOfAllocs++;\n        Stats.add(StatAllocated, BlockSize);\n        Stats.add(StatMapped, H->MapSize);\n      }\n      return Ptr;\n    }\n  }\n\n  MapPlatformData Data = {};\n  const uptr MapSize = RoundedSize + 2 * PageSize;\n  uptr MapBase = reinterpret_cast<uptr>(\n      map(nullptr, MapSize, nullptr, MAP_NOACCESS | MAP_ALLOWNOMEM, &Data));\n  if (UNLIKELY(!MapBase))\n    return nullptr;\n  uptr CommitBase = MapBase + PageSize;\n  uptr MapEnd = MapBase + MapSize;\n\n  // In the unlikely event of alignments larger than a page, adjust the amount\n  // of memory we want to commit, and trim the extra memory.\n  if (UNLIKELY(Alignment >= PageSize)) {\n    // For alignments greater than or equal to a page, the user pointer (eg: the\n    // pointer that is returned by the C or C++ allocation APIs) ends up on a\n    // page boundary , and our headers will live in the preceding page.\n    CommitBase = roundUpTo(MapBase + PageSize + 1, Alignment) - PageSize;\n    const uptr NewMapBase = CommitBase - PageSize;\n    DCHECK_GE(NewMapBase, MapBase);\n    // We only trim the extra memory on 32-bit platforms: 64-bit platforms\n    // are less constrained memory wise, and that saves us two syscalls.\n    if (SCUDO_WORDSIZE == 32U && NewMapBase != MapBase) {\n      unmap(reinterpret_cast<void *>(MapBase), NewMapBase - MapBase, 0, &Data);\n      MapBase = NewMapBase;\n    }\n    const uptr NewMapEnd =\n        CommitBase + PageSize + roundUpTo(Size, PageSize) + PageSize;\n    DCHECK_LE(NewMapEnd, MapEnd);\n    if (SCUDO_WORDSIZE == 32U && NewMapEnd != MapEnd) {\n      unmap(reinterpret_cast<void *>(NewMapEnd), MapEnd - NewMapEnd, 0, &Data);\n      MapEnd = NewMapEnd;\n    }\n  }\n\n  const uptr CommitSize = MapEnd - PageSize - CommitBase;\n  const uptr AllocPos = roundDownTo(CommitBase + CommitSize - Size, Alignment);\n  mapSecondary<Config>(Options, CommitBase, CommitSize, AllocPos, 0, &Data);\n  const uptr HeaderPos =\n      AllocPos - Chunk::getHeaderSize() - LargeBlock::getHeaderSize();\n  LargeBlock::Header *H = reinterpret_cast<LargeBlock::Header *>(\n      LargeBlock::addHeaderTag<Config>(HeaderPos));\n  if (useMemoryTagging<Config>(Options))\n    storeTags(LargeBlock::addHeaderTag<Config>(CommitBase),\n              reinterpret_cast<uptr>(H + 1));\n  H->MapBase = MapBase;\n  H->MapSize = MapEnd - MapBase;\n  H->CommitBase = CommitBase;\n  H->CommitSize = CommitSize;\n  H->Data = Data;\n  if (BlockEndPtr)\n    *BlockEndPtr = CommitBase + CommitSize;\n  {\n    ScopedLock L(Mutex);\n    InUseBlocks.push_back(H);\n    AllocatedBytes += CommitSize;\n    if (LargestSize < CommitSize)\n      LargestSize = CommitSize;\n    NumberOfAllocs++;\n    Stats.add(StatAllocated, CommitSize);\n    Stats.add(StatMapped, H->MapSize);\n  }\n  return reinterpret_cast<void *>(HeaderPos + LargeBlock::getHeaderSize());\n}\n\ntemplate <typename Config>\nvoid MapAllocator<Config>::deallocate(Options Options, void *Ptr) {\n  LargeBlock::Header *H = LargeBlock::getHeader<Config>(Ptr);\n  const uptr CommitSize = H->CommitSize;\n  {\n    ScopedLock L(Mutex);\n    InUseBlocks.remove(H);\n    FreedBytes += CommitSize;\n    NumberOfFrees++;\n    Stats.sub(StatAllocated, CommitSize);\n    Stats.sub(StatMapped, H->MapSize);\n  }\n  Cache.store(Options, H);\n}\n\ntemplate <typename Config>\nvoid MapAllocator<Config>::getStats(ScopedString *Str) const {\n  Str->append(\n      \"Stats: MapAllocator: allocated %zu times (%zuK), freed %zu times \"\n      \"(%zuK), remains %zu (%zuK) max %zuM\\n\",\n      NumberOfAllocs, AllocatedBytes >> 10, NumberOfFrees, FreedBytes >> 10,\n      NumberOfAllocs - NumberOfFrees, (AllocatedBytes - FreedBytes) >> 10,\n      LargestSize >> 20);\n}\n\n} // namespace scudo\n\n#endif // SCUDO_SECONDARY_H_\n"}, "25": {"id": 25, "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/scudo/standalone/size_class_map.h", "content": "//===-- size_class_map.h ----------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef SCUDO_SIZE_CLASS_MAP_H_\n#define SCUDO_SIZE_CLASS_MAP_H_\n\n#include \"chunk.h\"\n#include \"common.h\"\n#include \"string_utils.h\"\n\nnamespace scudo {\n\ninline uptr scaledLog2(uptr Size, uptr ZeroLog, uptr LogBits) {\n  const uptr L = getMostSignificantSetBitIndex(Size);\n  const uptr LBits = (Size >> (L - LogBits)) - (1 << LogBits);\n  const uptr HBits = (L - ZeroLog) << LogBits;\n  return LBits + HBits;\n}\n\ntemplate <typename Config> struct SizeClassMapBase {\n  static u32 getMaxCachedHint(uptr Size) {\n    DCHECK_NE(Size, 0);\n    u32 N;\n    // Force a 32-bit division if the template parameters allow for it.\n    if (Config::MaxBytesCachedLog > 31 || Config::MaxSizeLog > 31)\n      N = static_cast<u32>((1UL << Config::MaxBytesCachedLog) / Size);\n    else\n      N = (1U << Config::MaxBytesCachedLog) / static_cast<u32>(Size);\n    return Max(1U, Min(Config::MaxNumCachedHint, N));\n  }\n};\n\n// SizeClassMap maps allocation sizes into size classes and back, in an\n// efficient table-free manner.\n//\n// Class 0 is a special class that doesn't abide by the same rules as other\n// classes. The allocator uses it to hold batches.\n//\n// The other sizes are controlled by the template parameters:\n// - MinSizeLog: defines the first class as 2^MinSizeLog bytes.\n// - MaxSizeLog: defines the last class as 2^MaxSizeLog bytes.\n// - MidSizeLog: classes increase with step 2^MinSizeLog from 2^MinSizeLog to\n//               2^MidSizeLog bytes.\n// - NumBits: the number of non-zero bits in sizes after 2^MidSizeLog.\n//            eg. with NumBits==3 all size classes after 2^MidSizeLog look like\n//            0b1xx0..0 (where x is either 0 or 1).\n//\n// This class also gives a hint to a thread-caching allocator about the amount\n// of chunks that can be cached per-thread:\n// - MaxNumCachedHint is a hint for the max number of chunks cached per class.\n// - 2^MaxBytesCachedLog is the max number of bytes cached per class.\ntemplate <typename Config>\nclass FixedSizeClassMap : public SizeClassMapBase<Config> {\n  typedef SizeClassMapBase<Config> Base;\n\n  static const uptr MinSize = 1UL << Config::MinSizeLog;\n  static const uptr MidSize = 1UL << Config::MidSizeLog;\n  static const uptr MidClass = MidSize / MinSize;\n  static const u8 S = Config::NumBits - 1;\n  static const uptr M = (1UL << S) - 1;\n\n  static const uptr SizeDelta = Chunk::getHeaderSize();\n\npublic:\n  static const u32 MaxNumCachedHint = Config::MaxNumCachedHint;\n\n  static const uptr MaxSize = (1UL << Config::MaxSizeLog) + SizeDelta;\n  static const uptr NumClasses =\n      MidClass + ((Config::MaxSizeLog - Config::MidSizeLog) << S) + 1;\n  static_assert(NumClasses <= 256, \"\");\n  static const uptr LargestClassId = NumClasses - 1;\n  static const uptr BatchClassId = 0;\n\n  static uptr getSizeByClassId(uptr ClassId) {\n    DCHECK_NE(ClassId, BatchClassId);\n    if (ClassId <= MidClass)\n      return (ClassId << Config::MinSizeLog) + SizeDelta;\n    ClassId -= MidClass;\n    const uptr T = MidSize << (ClassId >> S);\n    return T + (T >> S) * (ClassId & M) + SizeDelta;\n  }\n\n  static u8 getSizeLSBByClassId(uptr ClassId) {\n    return u8(getLeastSignificantSetBitIndex(getSizeByClassId(ClassId)));\n  }\n\n  static constexpr bool usesCompressedLSBFormat() {\n    return false;\n  }\n\n  static uptr getClassIdBySize(uptr Size) {\n    if (Size <= SizeDelta + (1 << Config::MinSizeLog))\n      return 1;\n    Size -= SizeDelta;\n    DCHECK_LE(Size, MaxSize);\n    if (Size <= MidSize)\n      return (Size + MinSize - 1) >> Config::MinSizeLog;\n    return MidClass + 1 + scaledLog2(Size - 1, Config::MidSizeLog, S);\n  }\n\n  static u32 getMaxCachedHint(uptr Size) {\n    DCHECK_LE(Size, MaxSize);\n    return Base::getMaxCachedHint(Size);\n  }\n};\n\ntemplate <typename Config>\nclass TableSizeClassMap : public SizeClassMapBase<Config> {\n  typedef SizeClassMapBase<Config> Base;\n\n  static const u8 S = Config::NumBits - 1;\n  static const uptr M = (1UL << S) - 1;\n  static const uptr ClassesSize =\n      sizeof(Config::Classes) / sizeof(Config::Classes[0]);\n\n  struct SizeTable {\n    constexpr SizeTable() {\n      uptr Pos = 1 << Config::MidSizeLog;\n      uptr Inc = 1 << (Config::MidSizeLog - S);\n      for (uptr i = 0; i != getTableSize(); ++i) {\n        Pos += Inc;\n        if ((Pos & (Pos - 1)) == 0)\n          Inc *= 2;\n        Tab[i] = computeClassId(Pos + Config::SizeDelta);\n      }\n    }\n\n    constexpr static u8 computeClassId(uptr Size) {\n      for (uptr i = 0; i != ClassesSize; ++i) {\n        if (Size <= Config::Classes[i])\n          return static_cast<u8>(i + 1);\n      }\n      return static_cast<u8>(-1);\n    }\n\n    constexpr static uptr getTableSize() {\n      return (Config::MaxSizeLog - Config::MidSizeLog) << S;\n    }\n\n    u8 Tab[getTableSize()] = {};\n  };\n\n  static constexpr SizeTable SzTable = {};\n\n  struct LSBTable {\n    constexpr LSBTable() {\n      u8 Min = 255, Max = 0;\n      for (uptr I = 0; I != ClassesSize; ++I) {\n        for (u8 Bit = 0; Bit != 64; ++Bit) {\n          if (Config::Classes[I] & (1 << Bit)) {\n            Tab[I] = Bit;\n            if (Bit < Min)\n              Min = Bit;\n            if (Bit > Max)\n              Max = Bit;\n            break;\n          }\n        }\n      }\n\n      if (Max - Min > 3 || ClassesSize > 32)\n        return;\n\n      UseCompressedFormat = true;\n      CompressedMin = Min;\n      for (uptr I = 0; I != ClassesSize; ++I)\n        CompressedValue |= u64(Tab[I] - Min) << (I * 2);\n    }\n\n    u8 Tab[ClassesSize] = {};\n\n    bool UseCompressedFormat = false;\n    u8 CompressedMin = 0;\n    u64 CompressedValue = 0;\n  };\n\n  static constexpr LSBTable LTable = {};\n\npublic:\n  static const u32 MaxNumCachedHint = Config::MaxNumCachedHint;\n\n  static const uptr NumClasses = ClassesSize + 1;\n  static_assert(NumClasses < 256, \"\");\n  static const uptr LargestClassId = NumClasses - 1;\n  static const uptr BatchClassId = 0;\n  static const uptr MaxSize = Config::Classes[LargestClassId - 1];\n\n  static uptr getSizeByClassId(uptr ClassId) {\n    return Config::Classes[ClassId - 1];\n  }\n\n  static u8 getSizeLSBByClassId(uptr ClassId) {\n    if (LTable.UseCompressedFormat)\n      return ((LTable.CompressedValue >> ((ClassId - 1) * 2)) & 3) +\n             LTable.CompressedMin;\n    else\n      return LTable.Tab[ClassId - 1];\n  }\n\n  static constexpr bool usesCompressedLSBFormat() {\n    return LTable.UseCompressedFormat;\n  }\n\n  static uptr getClassIdBySize(uptr Size) {\n    if (Size <= Config::Classes[0])\n      return 1;\n    Size -= Config::SizeDelta;\n    DCHECK_LE(Size, MaxSize);\n    if (Size <= (1 << Config::MidSizeLog))\n      return ((Size - 1) >> Config::MinSizeLog) + 1;\n    return SzTable.Tab[scaledLog2(Size - 1, Config::MidSizeLog, S)];\n  }\n\n  static u32 getMaxCachedHint(uptr Size) {\n    DCHECK_LE(Size, MaxSize);\n    return Base::getMaxCachedHint(Size);\n  }\n};\n\nstruct DefaultSizeClassConfig {\n  static const uptr NumBits = 3;\n  static const uptr MinSizeLog = 5;\n  static const uptr MidSizeLog = 8;\n  static const uptr MaxSizeLog = 17;\n  static const u32 MaxNumCachedHint = 10;\n  static const uptr MaxBytesCachedLog = 10;\n};\n\ntypedef FixedSizeClassMap<DefaultSizeClassConfig> DefaultSizeClassMap;\n\nstruct AndroidSizeClassConfig {\n#if SCUDO_WORDSIZE == 64U\n  static const uptr NumBits = 7;\n  static const uptr MinSizeLog = 4;\n  static const uptr MidSizeLog = 6;\n  static const uptr MaxSizeLog = 16;\n  static const u32 MaxNumCachedHint = 13;\n  static const uptr MaxBytesCachedLog = 13;\n\n  static constexpr u32 Classes[] = {\n      0x00020, 0x00030, 0x00040, 0x00050, 0x00060, 0x00070, 0x00090, 0x000b0,\n      0x000c0, 0x000e0, 0x00120, 0x00160, 0x001c0, 0x00250, 0x00320, 0x00450,\n      0x00670, 0x00830, 0x00a10, 0x00c30, 0x01010, 0x01210, 0x01bd0, 0x02210,\n      0x02d90, 0x03790, 0x04010, 0x04810, 0x05a10, 0x07310, 0x08210, 0x10010,\n  };\n  static const uptr SizeDelta = 16;\n#else\n  static const uptr NumBits = 8;\n  static const uptr MinSizeLog = 4;\n  static const uptr MidSizeLog = 7;\n  static const uptr MaxSizeLog = 16;\n  static const u32 MaxNumCachedHint = 14;\n  static const uptr MaxBytesCachedLog = 13;\n\n  static constexpr u32 Classes[] = {\n      0x00020, 0x00030, 0x00040, 0x00050, 0x00060, 0x00070, 0x00080, 0x00090,\n      0x000a0, 0x000b0, 0x000c0, 0x000e0, 0x000f0, 0x00110, 0x00120, 0x00130,\n      0x00150, 0x00160, 0x00170, 0x00190, 0x001d0, 0x00210, 0x00240, 0x002a0,\n      0x00330, 0x00370, 0x003a0, 0x00400, 0x00430, 0x004a0, 0x00530, 0x00610,\n      0x00730, 0x00840, 0x00910, 0x009c0, 0x00a60, 0x00b10, 0x00ca0, 0x00e00,\n      0x00fb0, 0x01030, 0x01130, 0x011f0, 0x01490, 0x01650, 0x01930, 0x02010,\n      0x02190, 0x02490, 0x02850, 0x02d50, 0x03010, 0x03210, 0x03c90, 0x04090,\n      0x04510, 0x04810, 0x05c10, 0x06f10, 0x07310, 0x08010, 0x0c010, 0x10010,\n  };\n  static const uptr SizeDelta = 16;\n#endif\n};\n\ntypedef TableSizeClassMap<AndroidSizeClassConfig> AndroidSizeClassMap;\n\n#if SCUDO_WORDSIZE == 64U && defined(__clang__)\nstatic_assert(AndroidSizeClassMap::usesCompressedLSBFormat(), \"\");\n#endif\n\nstruct SvelteSizeClassConfig {\n#if SCUDO_WORDSIZE == 64U\n  static const uptr NumBits = 4;\n  static const uptr MinSizeLog = 4;\n  static const uptr MidSizeLog = 8;\n  static const uptr MaxSizeLog = 14;\n  static const u32 MaxNumCachedHint = 13;\n  static const uptr MaxBytesCachedLog = 10;\n#else\n  static const uptr NumBits = 4;\n  static const uptr MinSizeLog = 3;\n  static const uptr MidSizeLog = 7;\n  static const uptr MaxSizeLog = 14;\n  static const u32 MaxNumCachedHint = 14;\n  static const uptr MaxBytesCachedLog = 10;\n#endif\n};\n\ntypedef FixedSizeClassMap<SvelteSizeClassConfig> SvelteSizeClassMap;\n\ntemplate <typename SCMap> inline void printMap() {\n  ScopedString Buffer(1024);\n  uptr PrevS = 0;\n  uptr TotalCached = 0;\n  for (uptr I = 0; I < SCMap::NumClasses; I++) {\n    if (I == SCMap::BatchClassId)\n      continue;\n    const uptr S = SCMap::getSizeByClassId(I);\n    const uptr D = S - PrevS;\n    const uptr P = PrevS ? (D * 100 / PrevS) : 0;\n    const uptr L = S ? getMostSignificantSetBitIndex(S) : 0;\n    const uptr Cached = SCMap::getMaxCachedHint(S) * S;\n    Buffer.append(\n        \"C%02zu => S: %zu diff: +%zu %02zu%% L %zu Cached: %zu %zu; id %zu\\n\",\n        I, S, D, P, L, SCMap::getMaxCachedHint(S), Cached,\n        SCMap::getClassIdBySize(S));\n    TotalCached += Cached;\n    PrevS = S;\n  }\n  Buffer.append(\"Total Cached: %zu\\n\", TotalCached);\n  Buffer.output();\n}\n\ntemplate <typename SCMap> static void validateMap() {\n  for (uptr C = 0; C < SCMap::NumClasses; C++) {\n    if (C == SCMap::BatchClassId)\n      continue;\n    const uptr S = SCMap::getSizeByClassId(C);\n    CHECK_NE(S, 0U);\n    CHECK_EQ(SCMap::getClassIdBySize(S), C);\n    if (C < SCMap::LargestClassId)\n      CHECK_EQ(SCMap::getClassIdBySize(S + 1), C + 1);\n    CHECK_EQ(SCMap::getClassIdBySize(S - 1), C);\n    if (C - 1 != SCMap::BatchClassId)\n      CHECK_GT(SCMap::getSizeByClassId(C), SCMap::getSizeByClassId(C - 1));\n  }\n  // Do not perform the loop if the maximum size is too large.\n  if (SCMap::MaxSize > (1 << 19))\n    return;\n  for (uptr S = 1; S <= SCMap::MaxSize; S++) {\n    const uptr C = SCMap::getClassIdBySize(S);\n    CHECK_LT(C, SCMap::NumClasses);\n    CHECK_GE(SCMap::getSizeByClassId(C), S);\n    if (C - 1 != SCMap::BatchClassId)\n      CHECK_LT(SCMap::getSizeByClassId(C - 1), S);\n  }\n}\n} // namespace scudo\n\n#endif // SCUDO_SIZE_CLASS_MAP_H_\n"}, "26": {"id": 26, "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/scudo/standalone/stack_depot.h", "content": "//===-- stack_depot.h -------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef SCUDO_STACK_DEPOT_H_\n#define SCUDO_STACK_DEPOT_H_\n\n#include \"atomic_helpers.h\"\n#include \"mutex.h\"\n\nnamespace scudo {\n\nclass MurMur2HashBuilder {\n  static const u32 M = 0x5bd1e995;\n  static const u32 Seed = 0x9747b28c;\n  static const u32 R = 24;\n  u32 H;\n\npublic:\n  explicit MurMur2HashBuilder(u32 Init = 0) { H = Seed ^ Init; }\n  void add(u32 K) {\n    K *= M;\n    K ^= K >> R;\n    K *= M;\n    H *= M;\n    H ^= K;\n  }\n  u32 get() {\n    u32 X = H;\n    X ^= X >> 13;\n    X *= M;\n    X ^= X >> 15;\n    return X;\n  }\n};\n\nclass StackDepot {\n  HybridMutex RingEndMu;\n  u32 RingEnd = 0;\n\n  // This data structure stores a stack trace for each allocation and\n  // deallocation when stack trace recording is enabled, that may be looked up\n  // using a hash of the stack trace. The lower bits of the hash are an index\n  // into the Tab array, which stores an index into the Ring array where the\n  // stack traces are stored. As the name implies, Ring is a ring buffer, so a\n  // stack trace may wrap around to the start of the array.\n  //\n  // Each stack trace in Ring is prefixed by a stack trace marker consisting of\n  // a fixed 1 bit in bit 0 (this allows disambiguation between stack frames\n  // and stack trace markers in the case where instruction pointers are 4-byte\n  // aligned, as they are on arm64), the stack trace hash in bits 1-32, and the\n  // size of the stack trace in bits 33-63.\n  //\n  // The insert() function is potentially racy in its accesses to the Tab and\n  // Ring arrays, but find() is resilient to races in the sense that, barring\n  // hash collisions, it will either return the correct stack trace or no stack\n  // trace at all, even if two instances of insert() raced with one another.\n  // This is achieved by re-checking the hash of the stack trace before\n  // returning the trace.\n\n#ifdef SCUDO_FUZZ\n  // Use smaller table sizes for fuzzing in order to reduce input size.\n  static const uptr TabBits = 4;\n#else\n  static const uptr TabBits = 16;\n#endif\n  static const uptr TabSize = 1 << TabBits;\n  static const uptr TabMask = TabSize - 1;\n  atomic_u32 Tab[TabSize] = {};\n\n#ifdef SCUDO_FUZZ\n  static const uptr RingBits = 4;\n#else\n  static const uptr RingBits = 19;\n#endif\n  static const uptr RingSize = 1 << RingBits;\n  static const uptr RingMask = RingSize - 1;\n  atomic_u64 Ring[RingSize] = {};\n\npublic:\n  // Insert hash of the stack trace [Begin, End) into the stack depot, and\n  // return the hash.\n  u32 insert(uptr *Begin, uptr *End) {\n    MurMur2HashBuilder B;\n    for (uptr *I = Begin; I != End; ++I)\n      B.add(u32(*I) >> 2);\n    u32 Hash = B.get();\n\n    u32 Pos = Hash & TabMask;\n    u32 RingPos = atomic_load_relaxed(&Tab[Pos]);\n    u64 Entry = atomic_load_relaxed(&Ring[RingPos]);\n    u64 Id = (u64(End - Begin) << 33) | (u64(Hash) << 1) | 1;\n    if (Entry == Id)\n      return Hash;\n\n    ScopedLock Lock(RingEndMu);\n    RingPos = RingEnd;\n    atomic_store_relaxed(&Tab[Pos], RingPos);\n    atomic_store_relaxed(&Ring[RingPos], Id);\n    for (uptr *I = Begin; I != End; ++I) {\n      RingPos = (RingPos + 1) & RingMask;\n      atomic_store_relaxed(&Ring[RingPos], *I);\n    }\n    RingEnd = (RingPos + 1) & RingMask;\n    return Hash;\n  }\n\n  // Look up a stack trace by hash. Returns true if successful. The trace may be\n  // accessed via operator[] passing indexes between *RingPosPtr and\n  // *RingPosPtr + *SizePtr.\n  bool find(u32 Hash, uptr *RingPosPtr, uptr *SizePtr) const {\n    u32 Pos = Hash & TabMask;\n    u32 RingPos = atomic_load_relaxed(&Tab[Pos]);\n    if (RingPos >= RingSize)\n      return false;\n    u64 Entry = atomic_load_relaxed(&Ring[RingPos]);\n    u64 HashWithTagBit = (u64(Hash) << 1) | 1;\n    if ((Entry & 0x1ffffffff) != HashWithTagBit)\n      return false;\n    u32 Size = u32(Entry >> 33);\n    if (Size >= RingSize)\n      return false;\n    *RingPosPtr = (RingPos + 1) & RingMask;\n    *SizePtr = Size;\n    MurMur2HashBuilder B;\n    for (uptr I = 0; I != Size; ++I) {\n      RingPos = (RingPos + 1) & RingMask;\n      B.add(u32(atomic_load_relaxed(&Ring[RingPos])) >> 2);\n    }\n    return B.get() == Hash;\n  }\n\n  u64 operator[](uptr RingPos) const {\n    return atomic_load_relaxed(&Ring[RingPos & RingMask]);\n  }\n};\n\n} // namespace scudo\n\n#endif // SCUDO_STACK_DEPOT_H_\n"}, "27": {"id": 27, "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/scudo/standalone/stats.h", "content": "//===-- stats.h -------------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef SCUDO_STATS_H_\n#define SCUDO_STATS_H_\n\n#include \"atomic_helpers.h\"\n#include \"list.h\"\n#include \"mutex.h\"\n\n#include <string.h>\n\nnamespace scudo {\n\n// Memory allocator statistics\nenum StatType { StatAllocated, StatFree, StatMapped, StatCount };\n\ntypedef uptr StatCounters[StatCount];\n\n// Per-thread stats, live in per-thread cache. We use atomics so that the\n// numbers themselves are consistent. But we don't use atomic_{add|sub} or a\n// lock, because those are expensive operations , and we only care for the stats\n// to be \"somewhat\" correct: eg. if we call GlobalStats::get while a thread is\n// LocalStats::add'ing, this is OK, we will still get a meaningful number.\nclass LocalStats {\npublic:\n  void initLinkerInitialized() {}\n  void init() { memset(this, 0, sizeof(*this)); }\n\n  void add(StatType I, uptr V) {\n    V += atomic_load_relaxed(&StatsArray[I]);\n    atomic_store_relaxed(&StatsArray[I], V);\n  }\n\n  void sub(StatType I, uptr V) {\n    V = atomic_load_relaxed(&StatsArray[I]) - V;\n    atomic_store_relaxed(&StatsArray[I], V);\n  }\n\n  void set(StatType I, uptr V) { atomic_store_relaxed(&StatsArray[I], V); }\n\n  uptr get(StatType I) const { return atomic_load_relaxed(&StatsArray[I]); }\n\n  LocalStats *Next = nullptr;\n  LocalStats *Prev = nullptr;\n\nprivate:\n  atomic_uptr StatsArray[StatCount] = {};\n};\n\n// Global stats, used for aggregation and querying.\nclass GlobalStats : public LocalStats {\npublic:\n  void initLinkerInitialized() {}\n  void init() {\n    LocalStats::init();\n    Mutex.init();\n    StatsList = {};\n    initLinkerInitialized();\n  }\n\n  void link(LocalStats *S) {\n    ScopedLock L(Mutex);\n    StatsList.push_back(S);\n  }\n\n  void unlink(LocalStats *S) {\n    ScopedLock L(Mutex);\n    StatsList.remove(S);\n    for (uptr I = 0; I < StatCount; I++)\n      add(static_cast<StatType>(I), S->get(static_cast<StatType>(I)));\n  }\n\n  void get(uptr *S) const {\n    ScopedLock L(Mutex);\n    for (uptr I = 0; I < StatCount; I++)\n      S[I] = LocalStats::get(static_cast<StatType>(I));\n    for (const auto &Stats : StatsList) {\n      for (uptr I = 0; I < StatCount; I++)\n        S[I] += Stats.get(static_cast<StatType>(I));\n    }\n    // All stats must be non-negative.\n    for (uptr I = 0; I < StatCount; I++)\n      S[I] = static_cast<sptr>(S[I]) >= 0 ? S[I] : 0;\n  }\n\n  void disable() { Mutex.lock(); }\n  void enable() { Mutex.unlock(); }\n\nprivate:\n  mutable HybridMutex Mutex;\n  DoublyLinkedList<LocalStats> StatsList;\n};\n\n} // namespace scudo\n\n#endif // SCUDO_STATS_H_\n"}, "29": {"id": 29, "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/scudo/standalone/tsd.h", "content": "//===-- tsd.h ---------------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef SCUDO_TSD_H_\n#define SCUDO_TSD_H_\n\n#include \"atomic_helpers.h\"\n#include \"common.h\"\n#include \"mutex.h\"\n\n#include <limits.h> // for PTHREAD_DESTRUCTOR_ITERATIONS\n#include <pthread.h>\n\n// With some build setups, this might still not be defined.\n#ifndef PTHREAD_DESTRUCTOR_ITERATIONS\n#define PTHREAD_DESTRUCTOR_ITERATIONS 4\n#endif\n\nnamespace scudo {\n\ntemplate <class Allocator> struct alignas(SCUDO_CACHE_LINE_SIZE) TSD {\n  typename Allocator::CacheT Cache;\n  typename Allocator::QuarantineCacheT QuarantineCache;\n  u8 DestructorIterations = 0;\n\n  void initLinkerInitialized(Allocator *Instance) {\n    Instance->initCache(&Cache);\n    DestructorIterations = PTHREAD_DESTRUCTOR_ITERATIONS;\n  }\n  void init(Allocator *Instance) {\n    memset(this, 0, sizeof(*this));\n    initLinkerInitialized(Instance);\n  }\n\n  void commitBack(Allocator *Instance) { Instance->commitBack(this); }\n\n  inline bool tryLock() {\n    if (Mutex.tryLock()) {\n      atomic_store_relaxed(&Precedence, 0);\n      return true;\n    }\n    if (atomic_load_relaxed(&Precedence) == 0)\n      atomic_store_relaxed(\n          &Precedence,\n          static_cast<uptr>(getMonotonicTime() >> FIRST_32_SECOND_64(16, 0)));\n    return false;\n  }\n  inline void lock() {\n    atomic_store_relaxed(&Precedence, 0);\n    Mutex.lock();\n  }\n  inline void unlock() { Mutex.unlock(); }\n  inline uptr getPrecedence() { return atomic_load_relaxed(&Precedence); }\n\nprivate:\n  HybridMutex Mutex;\n  atomic_uptr Precedence = {};\n};\n\n} // namespace scudo\n\n#endif // SCUDO_TSD_H_\n"}, "30": {"id": 30, "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/scudo/standalone/tsd_exclusive.h", "content": "//===-- tsd_exclusive.h -----------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef SCUDO_TSD_EXCLUSIVE_H_\n#define SCUDO_TSD_EXCLUSIVE_H_\n\n#include \"tsd.h\"\n\nnamespace scudo {\n\nstruct ThreadState {\n  bool DisableMemInit : 1;\n  enum {\n    NotInitialized = 0,\n    Initialized,\n    TornDown,\n  } InitState : 2;\n};\n\ntemplate <class Allocator> void teardownThread(void *Ptr);\n\ntemplate <class Allocator> struct TSDRegistryExT {\n  void initLinkerInitialized(Allocator *Instance) {\n    Instance->initLinkerInitialized();\n    CHECK_EQ(pthread_key_create(&PThreadKey, teardownThread<Allocator>), 0);\n    FallbackTSD.initLinkerInitialized(Instance);\n    Initialized = true;\n  }\n  void init(Allocator *Instance) {\n    memset(this, 0, sizeof(*this));\n    initLinkerInitialized(Instance);\n  }\n\n  void initOnceMaybe(Allocator *Instance) {\n    ScopedLock L(Mutex);\n    if (LIKELY(Initialized))\n      return;\n    initLinkerInitialized(Instance); // Sets Initialized.\n  }\n\n  void unmapTestOnly() {\n    Allocator *Instance =\n        reinterpret_cast<Allocator *>(pthread_getspecific(PThreadKey));\n    if (!Instance)\n      return;\n    ThreadTSD.commitBack(Instance);\n    State = {};\n  }\n\n  ALWAYS_INLINE void initThreadMaybe(Allocator *Instance, bool MinimalInit) {\n    if (LIKELY(State.InitState != ThreadState::NotInitialized))\n      return;\n    initThread(Instance, MinimalInit);\n  }\n\n  ALWAYS_INLINE TSD<Allocator> *getTSDAndLock(bool *UnlockRequired) {\n    if (LIKELY(State.InitState == ThreadState::Initialized &&\n               !atomic_load(&Disabled, memory_order_acquire))) {\n      *UnlockRequired = false;\n      return &ThreadTSD;\n    }\n    FallbackTSD.lock();\n    *UnlockRequired = true;\n    return &FallbackTSD;\n  }\n\n  // To disable the exclusive TSD registry, we effectively lock the fallback TSD\n  // and force all threads to attempt to use it instead of their local one.\n  void disable() {\n    Mutex.lock();\n    FallbackTSD.lock();\n    atomic_store(&Disabled, 1U, memory_order_release);\n  }\n\n  void enable() {\n    atomic_store(&Disabled, 0U, memory_order_release);\n    FallbackTSD.unlock();\n    Mutex.unlock();\n  }\n\n  bool setOption(Option O, UNUSED sptr Value) {\n    if (O == Option::ThreadDisableMemInit)\n      State.DisableMemInit = Value;\n    if (O == Option::MaxTSDsCount)\n      return false;\n    return true;\n  }\n\n  bool getDisableMemInit() { return State.DisableMemInit; }\n\nprivate:\n  // Using minimal initialization allows for global initialization while keeping\n  // the thread specific structure untouched. The fallback structure will be\n  // used instead.\n  NOINLINE void initThread(Allocator *Instance, bool MinimalInit) {\n    initOnceMaybe(Instance);\n    if (UNLIKELY(MinimalInit))\n      return;\n    CHECK_EQ(\n        pthread_setspecific(PThreadKey, reinterpret_cast<void *>(Instance)), 0);\n    ThreadTSD.initLinkerInitialized(Instance);\n    State.InitState = ThreadState::Initialized;\n    Instance->callPostInitCallback();\n  }\n\n  pthread_key_t PThreadKey = {};\n  bool Initialized = false;\n  atomic_u8 Disabled = {};\n  TSD<Allocator> FallbackTSD;\n  HybridMutex Mutex;\n  static thread_local ThreadState State;\n  static thread_local TSD<Allocator> ThreadTSD;\n\n  friend void teardownThread<Allocator>(void *Ptr);\n};\n\ntemplate <class Allocator>\nthread_local TSD<Allocator> TSDRegistryExT<Allocator>::ThreadTSD;\ntemplate <class Allocator>\nthread_local ThreadState TSDRegistryExT<Allocator>::State;\n\ntemplate <class Allocator> void teardownThread(void *Ptr) {\n  typedef TSDRegistryExT<Allocator> TSDRegistryT;\n  Allocator *Instance = reinterpret_cast<Allocator *>(Ptr);\n  // The glibc POSIX thread-local-storage deallocation routine calls user\n  // provided destructors in a loop of PTHREAD_DESTRUCTOR_ITERATIONS.\n  // We want to be called last since other destructors might call free and the\n  // like, so we wait until PTHREAD_DESTRUCTOR_ITERATIONS before draining the\n  // quarantine and swallowing the cache.\n  if (TSDRegistryT::ThreadTSD.DestructorIterations > 1) {\n    TSDRegistryT::ThreadTSD.DestructorIterations--;\n    // If pthread_setspecific fails, we will go ahead with the teardown.\n    if (LIKELY(pthread_setspecific(Instance->getTSDRegistry()->PThreadKey,\n                                   Ptr) == 0))\n      return;\n  }\n  TSDRegistryT::ThreadTSD.commitBack(Instance);\n  TSDRegistryT::State.InitState = ThreadState::TornDown;\n}\n\n} // namespace scudo\n\n#endif // SCUDO_TSD_EXCLUSIVE_H_\n"}, "31": {"id": 31, "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/scudo/standalone/tsd_shared.h", "content": "//===-- tsd_shared.h --------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef SCUDO_TSD_SHARED_H_\n#define SCUDO_TSD_SHARED_H_\n\n#include \"tsd.h\"\n\n#if SCUDO_HAS_PLATFORM_TLS_SLOT\n// This is a platform-provided header that needs to be on the include path when\n// Scudo is compiled. It must declare a function with the prototype:\n//   uintptr_t *getPlatformAllocatorTlsSlot()\n// that returns the address of a thread-local word of storage reserved for\n// Scudo, that must be zero-initialized in newly created threads.\n#include \"scudo_platform_tls_slot.h\"\n#endif\n\nnamespace scudo {\n\ntemplate <class Allocator, u32 TSDsArraySize, u32 DefaultTSDCount>\nstruct TSDRegistrySharedT {\n  void initLinkerInitialized(Allocator *Instance) {\n    Instance->initLinkerInitialized();\n    for (u32 I = 0; I < TSDsArraySize; I++)\n      TSDs[I].initLinkerInitialized(Instance);\n    const u32 NumberOfCPUs = getNumberOfCPUs();\n    setNumberOfTSDs((NumberOfCPUs == 0) ? DefaultTSDCount\n                                        : Min(NumberOfCPUs, DefaultTSDCount));\n    Initialized = true;\n  }\n  void init(Allocator *Instance) {\n    memset(this, 0, sizeof(*this));\n    initLinkerInitialized(Instance);\n  }\n\n  void initOnceMaybe(Allocator *Instance) {\n    ScopedLock L(Mutex);\n    if (LIKELY(Initialized))\n      return;\n    initLinkerInitialized(Instance); // Sets Initialized.\n  }\n\n  void unmapTestOnly() { setCurrentTSD(nullptr); }\n\n  ALWAYS_INLINE void initThreadMaybe(Allocator *Instance,\n                                     UNUSED bool MinimalInit) {\n    if (LIKELY(getCurrentTSD()))\n      return;\n    initThread(Instance);\n  }\n\n  ALWAYS_INLINE TSD<Allocator> *getTSDAndLock(bool *UnlockRequired) {\n    TSD<Allocator> *TSD = getCurrentTSD();\n    DCHECK(TSD);\n    *UnlockRequired = true;\n    // Try to lock the currently associated context.\n    if (TSD->tryLock())\n      return TSD;\n    // If that fails, go down the slow path.\n    if (TSDsArraySize == 1U) {\n      // Only 1 TSD, not need to go any further.\n      // The compiler will optimize this one way or the other.\n      TSD->lock();\n      return TSD;\n    }\n    return getTSDAndLockSlow(TSD);\n  }\n\n  void disable() {\n    Mutex.lock();\n    for (u32 I = 0; I < TSDsArraySize; I++)\n      TSDs[I].lock();\n  }\n\n  void enable() {\n    for (s32 I = static_cast<s32>(TSDsArraySize - 1); I >= 0; I--)\n      TSDs[I].unlock();\n    Mutex.unlock();\n  }\n\n  bool setOption(Option O, sptr Value) {\n    if (O == Option::MaxTSDsCount)\n      return setNumberOfTSDs(static_cast<u32>(Value));\n    if (O == Option::ThreadDisableMemInit)\n      setDisableMemInit(Value);\n    // Not supported by the TSD Registry, but not an error either.\n    return true;\n  }\n\n  bool getDisableMemInit() const { return *getTlsPtr() & 1; }\n\nprivate:\n  ALWAYS_INLINE uptr *getTlsPtr() const {\n#if SCUDO_HAS_PLATFORM_TLS_SLOT\n    return reinterpret_cast<uptr *>(getPlatformAllocatorTlsSlot());\n#else\n    static thread_local uptr ThreadTSD;\n    return &ThreadTSD;\n#endif\n  }\n\n  static_assert(alignof(TSD<Allocator>) >= 2, \"\");\n\n  ALWAYS_INLINE void setCurrentTSD(TSD<Allocator> *CurrentTSD) {\n    *getTlsPtr() &= 1;\n    *getTlsPtr() |= reinterpret_cast<uptr>(CurrentTSD);\n  }\n\n  ALWAYS_INLINE TSD<Allocator> *getCurrentTSD() {\n    return reinterpret_cast<TSD<Allocator> *>(*getTlsPtr() & ~1ULL);\n  }\n\n  bool setNumberOfTSDs(u32 N) {\n    ScopedLock L(MutexTSDs);\n    if (N < NumberOfTSDs)\n      return false;\n    if (N > TSDsArraySize)\n      N = TSDsArraySize;\n    NumberOfTSDs = N;\n    NumberOfCoPrimes = 0;\n    // Compute all the coprimes of NumberOfTSDs. This will be used to walk the\n    // array of TSDs in a random order. For details, see:\n    // https://lemire.me/blog/2017/09/18/visiting-all-values-in-an-array-exactly-once-in-random-order/\n    for (u32 I = 0; I < N; I++) {\n      u32 A = I + 1;\n      u32 B = N;\n      // Find the GCD between I + 1 and N. If 1, they are coprimes.\n      while (B != 0) {\n        const u32 T = A;\n        A = B;\n        B = T % B;\n      }\n      if (A == 1)\n        CoPrimes[NumberOfCoPrimes++] = I + 1;\n    }\n    return true;\n  }\n\n  void setDisableMemInit(bool B) {\n    *getTlsPtr() &= ~1ULL;\n    *getTlsPtr() |= B;\n  }\n\n  NOINLINE void initThread(Allocator *Instance) {\n    initOnceMaybe(Instance);\n    // Initial context assignment is done in a plain round-robin fashion.\n    const u32 Index = atomic_fetch_add(&CurrentIndex, 1U, memory_order_relaxed);\n    setCurrentTSD(&TSDs[Index % NumberOfTSDs]);\n    Instance->callPostInitCallback();\n  }\n\n  NOINLINE TSD<Allocator> *getTSDAndLockSlow(TSD<Allocator> *CurrentTSD) {\n    // Use the Precedence of the current TSD as our random seed. Since we are\n    // in the slow path, it means that tryLock failed, and as a result it's\n    // very likely that said Precedence is non-zero.\n    const u32 R = static_cast<u32>(CurrentTSD->getPrecedence());\n    u32 N, Inc;\n    {\n      ScopedLock L(MutexTSDs);\n      N = NumberOfTSDs;\n      DCHECK_NE(NumberOfCoPrimes, 0U);\n      Inc = CoPrimes[R % NumberOfCoPrimes];\n    }\n    if (N > 1U) {\n      u32 Index = R % N;\n      uptr LowestPrecedence = UINTPTR_MAX;\n      TSD<Allocator> *CandidateTSD = nullptr;\n      // Go randomly through at most 4 contexts and find a candidate.\n      for (u32 I = 0; I < Min(4U, N); I++) {\n        if (TSDs[Index].tryLock()) {\n          setCurrentTSD(&TSDs[Index]);\n          return &TSDs[Index];\n        }\n        const uptr Precedence = TSDs[Index].getPrecedence();\n        // A 0 precedence here means another thread just locked this TSD.\n        if (Precedence && Precedence < LowestPrecedence) {\n          CandidateTSD = &TSDs[Index];\n          LowestPrecedence = Precedence;\n        }\n        Index += Inc;\n        if (Index >= N)\n          Index -= N;\n      }\n      if (CandidateTSD) {\n        CandidateTSD->lock();\n        setCurrentTSD(CandidateTSD);\n        return CandidateTSD;\n      }\n    }\n    // Last resort, stick with the current one.\n    CurrentTSD->lock();\n    return CurrentTSD;\n  }\n\n  atomic_u32 CurrentIndex;\n  u32 NumberOfTSDs;\n  u32 NumberOfCoPrimes;\n  u32 CoPrimes[TSDsArraySize];\n  bool Initialized;\n  HybridMutex Mutex;\n  HybridMutex MutexTSDs;\n  TSD<Allocator> TSDs[TSDsArraySize];\n};\n\n} // namespace scudo\n\n#endif // SCUDO_TSD_SHARED_H_\n"}}, "reports": [{"events": [{"location": {"col": 9, "file": 0, "line": 9}, "message": "LLVM_COMPILER_RT_LIB_SCUDO_STANDALONE_ALLOCATOR_CONFIG_H (fixit)"}, {"location": {"col": 9, "file": 0, "line": 9}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/scudo/standalone/allocator_config.h", "reportHash": "2d1c39243aa4922d992b95921f3ebdb6", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 1, "line": 9}, "message": "LLVM_COMPILER_RT_LIB_SCUDO_STANDALONE_ATOMIC_HELPERS_H (fixit)"}, {"location": {"col": 9, "file": 1, "line": 9}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/scudo/standalone/atomic_helpers.h", "reportHash": "8d0def1498c8aa8a8b07e6667c7eb5ae", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 14, "file": 2, "line": 69}, "message": "initializer of 'NumIters' is not a constant expression"}, {"location": {"col": 16, "file": 2, "line": 67}, "message": "declared here"}, {"location": {"col": 14, "file": 2, "line": 69}, "message": "variable length arrays are a C99 feature"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/scudo/standalone/benchmarks/malloc_benchmark.cpp", "reportHash": "c69624fc25931427b82bb09adef00235", "checkerName": "clang-diagnostic-vla-extension", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 9, "file": 3, "line": 9}, "message": "LLVM_COMPILER_RT_LIB_SCUDO_STANDALONE_BYTEMAP_H (fixit)"}, {"location": {"col": 9, "file": 3, "line": 9}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/scudo/standalone/bytemap.h", "reportHash": "15a029fdd740daacfc86a4d6bc1c45dc", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 4, "line": 9}, "message": "LLVM_COMPILER_RT_LIB_SCUDO_STANDALONE_CHECKSUM_H (fixit)"}, {"location": {"col": 9, "file": 4, "line": 9}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/scudo/standalone/checksum.h", "reportHash": "1b4924493827609c9c5882c03c2c8e71", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 5, "line": 9}, "message": "LLVM_COMPILER_RT_LIB_SCUDO_STANDALONE_CHUNK_H (fixit)"}, {"location": {"col": 9, "file": 5, "line": 9}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/scudo/standalone/chunk.h", "reportHash": "8f01200d36f155309e44c37bd64cfec9", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 6, "line": 9}, "message": "LLVM_COMPILER_RT_LIB_SCUDO_STANDALONE_COMBINED_H (fixit)"}, {"location": {"col": 9, "file": 6, "line": 9}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/scudo/standalone/combined.h", "reportHash": "2fefe85b81f6cee5ada7155b9db69239", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 8, "line": 9}, "message": "LLVM_COMPILER_RT_LIB_SCUDO_STANDALONE_FLAGS_H (fixit)"}, {"location": {"col": 9, "file": 8, "line": 9}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/scudo/standalone/flags.h", "reportHash": "b6c93c48d699dfe765266bfa7aef149c", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 9, "line": 9}, "message": "LLVM_COMPILER_RT_LIB_SCUDO_STANDALONE_FLAGS_PARSER_H (fixit)"}, {"location": {"col": 9, "file": 9, "line": 9}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/scudo/standalone/flags_parser.h", "reportHash": "1c56f425a864c6af65990b162449b3ad", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 13, "line": 9}, "message": "LLVM_COMPILER_RT_LIB_SCUDO_STANDALONE_LIST_H (fixit)"}, {"location": {"col": 9, "file": 13, "line": 9}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/scudo/standalone/list.h", "reportHash": "7d79548eb9c6bcce8bddb03801bc3f26", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 14, "line": 9}, "message": "LLVM_COMPILER_RT_LIB_SCUDO_STANDALONE_LOCAL_CACHE_H (fixit)"}, {"location": {"col": 9, "file": 14, "line": 9}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/scudo/standalone/local_cache.h", "reportHash": "1ddd14045861b29f10b99cf1ddb306ca", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 15, "line": 9}, "message": "LLVM_COMPILER_RT_LIB_SCUDO_STANDALONE_MEMTAG_H (fixit)"}, {"location": {"col": 9, "file": 15, "line": 9}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/scudo/standalone/memtag.h", "reportHash": "48bd57a92b5327fa53ce670a0516929f", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 16, "line": 9}, "message": "LLVM_COMPILER_RT_LIB_SCUDO_STANDALONE_MUTEX_H (fixit)"}, {"location": {"col": 9, "file": 16, "line": 9}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/scudo/standalone/mutex.h", "reportHash": "44ca37a631fe496b66b2be4e55551532", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 17, "line": 9}, "message": "LLVM_COMPILER_RT_LIB_SCUDO_STANDALONE_OPTIONS_H (fixit)"}, {"location": {"col": 9, "file": 17, "line": 9}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/scudo/standalone/options.h", "reportHash": "3364feeecc6be737c93795a2bc630e93", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 19, "line": 9}, "message": "LLVM_COMPILER_RT_LIB_SCUDO_STANDALONE_PRIMARY32_H (fixit)"}, {"location": {"col": 9, "file": 19, "line": 9}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/scudo/standalone/primary32.h", "reportHash": "f8166ce22748b5c8ed0077052a17adfc", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 20, "line": 9}, "message": "LLVM_COMPILER_RT_LIB_SCUDO_STANDALONE_PRIMARY64_H (fixit)"}, {"location": {"col": 9, "file": 20, "line": 9}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/scudo/standalone/primary64.h", "reportHash": "fe677759bb9fc2d17960bc61cd4defe1", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 21, "line": 9}, "message": "LLVM_COMPILER_RT_LIB_SCUDO_STANDALONE_QUARANTINE_H (fixit)"}, {"location": {"col": 9, "file": 21, "line": 9}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/scudo/standalone/quarantine.h", "reportHash": "61bcc13cb9768181afe19ff2691bfee5", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 22, "line": 9}, "message": "LLVM_COMPILER_RT_LIB_SCUDO_STANDALONE_RELEASE_H (fixit)"}, {"location": {"col": 9, "file": 22, "line": 9}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/scudo/standalone/release.h", "reportHash": "40660a0dceb0c47b044876a033e94e6b", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 23, "line": 9}, "message": "LLVM_COMPILER_RT_LIB_SCUDO_STANDALONE_REPORT_H (fixit)"}, {"location": {"col": 9, "file": 23, "line": 9}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/scudo/standalone/report.h", "reportHash": "7bd5cbd849485440cad39eb6eab21228", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 24, "line": 9}, "message": "LLVM_COMPILER_RT_LIB_SCUDO_STANDALONE_SECONDARY_H (fixit)"}, {"location": {"col": 9, "file": 24, "line": 9}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/scudo/standalone/secondary.h", "reportHash": "ae1a22ee039a9bd2cdfedd1f83eecd73", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 25, "line": 9}, "message": "LLVM_COMPILER_RT_LIB_SCUDO_STANDALONE_SIZE_CLASS_MAP_H (fixit)"}, {"location": {"col": 9, "file": 25, "line": 9}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/scudo/standalone/size_class_map.h", "reportHash": "887d74f3504adb35c9caa1f472ead725", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 26, "line": 9}, "message": "LLVM_COMPILER_RT_LIB_SCUDO_STANDALONE_STACK_DEPOT_H (fixit)"}, {"location": {"col": 9, "file": 26, "line": 9}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/scudo/standalone/stack_depot.h", "reportHash": "332ee389fafb84efe6f5a17d7b21921d", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 27, "line": 9}, "message": "LLVM_COMPILER_RT_LIB_SCUDO_STANDALONE_STATS_H (fixit)"}, {"location": {"col": 9, "file": 27, "line": 9}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/scudo/standalone/stats.h", "reportHash": "94b754e1020eb12487eb5140a7de5680", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 29, "line": 9}, "message": "LLVM_COMPILER_RT_LIB_SCUDO_STANDALONE_TSD_H (fixit)"}, {"location": {"col": 9, "file": 29, "line": 9}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/scudo/standalone/tsd.h", "reportHash": "8e20626ab63f0cbd768b64d89fb8fd4a", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 30, "line": 9}, "message": "LLVM_COMPILER_RT_LIB_SCUDO_STANDALONE_TSD_EXCLUSIVE_H (fixit)"}, {"location": {"col": 9, "file": 30, "line": 9}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/scudo/standalone/tsd_exclusive.h", "reportHash": "8ed2692319eb3fbfe83172a305e735ae", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 31, "line": 9}, "message": "LLVM_COMPILER_RT_LIB_SCUDO_STANDALONE_TSD_SHARED_H (fixit)"}, {"location": {"col": 9, "file": 31, "line": 9}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/scudo/standalone/tsd_shared.h", "reportHash": "d1655b3b44e2a246e228f29474620545", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
