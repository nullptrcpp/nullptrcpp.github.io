<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"1": {"id": 1, "path": "/home/vsts/work/1/llvm-project/llvm/lib/Support/APInt.cpp", "content": "//===-- APInt.cpp - Implement APInt class ---------------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file implements a class to represent arbitrary precision integer\n// constant values and provide a variety of arithmetic operations on them.\n//\n//===----------------------------------------------------------------------===//\n\n#include \"llvm/ADT/APInt.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/Hashing.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/SmallString.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/bit.h\"\n#include \"llvm/Config/llvm-config.h\"\n#include \"llvm/Support/Debug.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <climits>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\nusing namespace llvm;\n\n#define DEBUG_TYPE \"apint\"\n\n/// A utility function for allocating memory, checking for allocation failures,\n/// and ensuring the contents are zeroed.\ninline static uint64_t* getClearedMemory(unsigned numWords) {\n  uint64_t *result = new uint64_t[numWords];\n  memset(result, 0, numWords * sizeof(uint64_t));\n  return result;\n}\n\n/// A utility function for allocating memory and checking for allocation\n/// failure.  The content is not zeroed.\ninline static uint64_t* getMemory(unsigned numWords) {\n  return new uint64_t[numWords];\n}\n\n/// A utility function that converts a character to a digit.\ninline static unsigned getDigit(char cdigit, uint8_t radix) {\n  unsigned r;\n\n  if (radix == 16 || radix == 36) {\n    r = cdigit - '0';\n    if (r <= 9)\n      return r;\n\n    r = cdigit - 'A';\n    if (r <= radix - 11U)\n      return r + 10;\n\n    r = cdigit - 'a';\n    if (r <= radix - 11U)\n      return r + 10;\n\n    radix = 10;\n  }\n\n  r = cdigit - '0';\n  if (r < radix)\n    return r;\n\n  return -1U;\n}\n\n\nvoid APInt::initSlowCase(uint64_t val, bool isSigned) {\n  U.pVal = getClearedMemory(getNumWords());\n  U.pVal[0] = val;\n  if (isSigned && int64_t(val) < 0)\n    for (unsigned i = 1; i < getNumWords(); ++i)\n      U.pVal[i] = WORDTYPE_MAX;\n  clearUnusedBits();\n}\n\nvoid APInt::initSlowCase(const APInt& that) {\n  U.pVal = getMemory(getNumWords());\n  memcpy(U.pVal, that.U.pVal, getNumWords() * APINT_WORD_SIZE);\n}\n\nvoid APInt::initFromArray(ArrayRef<uint64_t> bigVal) {\n  assert(BitWidth && \"Bitwidth too small\");\n  assert(bigVal.data() && \"Null pointer detected!\");\n  if (isSingleWord())\n    U.VAL = bigVal[0];\n  else {\n    // Get memory, cleared to 0\n    U.pVal = getClearedMemory(getNumWords());\n    // Calculate the number of words to copy\n    unsigned words = std::min<unsigned>(bigVal.size(), getNumWords());\n    // Copy the words from bigVal to pVal\n    memcpy(U.pVal, bigVal.data(), words * APINT_WORD_SIZE);\n  }\n  // Make sure unused high bits are cleared\n  clearUnusedBits();\n}\n\nAPInt::APInt(unsigned numBits, ArrayRef<uint64_t> bigVal)\n  : BitWidth(numBits) {\n  initFromArray(bigVal);\n}\n\nAPInt::APInt(unsigned numBits, unsigned numWords, const uint64_t bigVal[])\n  : BitWidth(numBits) {\n  initFromArray(makeArrayRef(bigVal, numWords));\n}\n\nAPInt::APInt(unsigned numbits, StringRef Str, uint8_t radix)\n  : BitWidth(numbits) {\n  assert(BitWidth && \"Bitwidth too small\");\n  fromString(numbits, Str, radix);\n}\n\nvoid APInt::reallocate(unsigned NewBitWidth) {\n  // If the number of words is the same we can just change the width and stop.\n  if (getNumWords() == getNumWords(NewBitWidth)) {\n    BitWidth = NewBitWidth;\n    return;\n  }\n\n  // If we have an allocation, delete it.\n  if (!isSingleWord())\n    delete [] U.pVal;\n\n  // Update BitWidth.\n  BitWidth = NewBitWidth;\n\n  // If we are supposed to have an allocation, create it.\n  if (!isSingleWord())\n    U.pVal = getMemory(getNumWords());\n}\n\nvoid APInt::AssignSlowCase(const APInt& RHS) {\n  // Don't do anything for X = X\n  if (this == &RHS)\n    return;\n\n  // Adjust the bit width and handle allocations as necessary.\n  reallocate(RHS.getBitWidth());\n\n  // Copy the data.\n  if (isSingleWord())\n    U.VAL = RHS.U.VAL;\n  else\n    memcpy(U.pVal, RHS.U.pVal, getNumWords() * APINT_WORD_SIZE);\n}\n\n/// This method 'profiles' an APInt for use with FoldingSet.\nvoid APInt::Profile(FoldingSetNodeID& ID) const {\n  ID.AddInteger(BitWidth);\n\n  if (isSingleWord()) {\n    ID.AddInteger(U.VAL);\n    return;\n  }\n\n  unsigned NumWords = getNumWords();\n  for (unsigned i = 0; i < NumWords; ++i)\n    ID.AddInteger(U.pVal[i]);\n}\n\n/// Prefix increment operator. Increments the APInt by one.\nAPInt& APInt::operator++() {\n  if (isSingleWord())\n    ++U.VAL;\n  else\n    tcIncrement(U.pVal, getNumWords());\n  return clearUnusedBits();\n}\n\n/// Prefix decrement operator. Decrements the APInt by one.\nAPInt& APInt::operator--() {\n  if (isSingleWord())\n    --U.VAL;\n  else\n    tcDecrement(U.pVal, getNumWords());\n  return clearUnusedBits();\n}\n\n/// Adds the RHS APInt to this APInt.\n/// @returns this, after addition of RHS.\n/// Addition assignment operator.\nAPInt& APInt::operator+=(const APInt& RHS) {\n  assert(BitWidth == RHS.BitWidth && \"Bit widths must be the same\");\n  if (isSingleWord())\n    U.VAL += RHS.U.VAL;\n  else\n    tcAdd(U.pVal, RHS.U.pVal, 0, getNumWords());\n  return clearUnusedBits();\n}\n\nAPInt& APInt::operator+=(uint64_t RHS) {\n  if (isSingleWord())\n    U.VAL += RHS;\n  else\n    tcAddPart(U.pVal, RHS, getNumWords());\n  return clearUnusedBits();\n}\n\n/// Subtracts the RHS APInt from this APInt\n/// @returns this, after subtraction\n/// Subtraction assignment operator.\nAPInt& APInt::operator-=(const APInt& RHS) {\n  assert(BitWidth == RHS.BitWidth && \"Bit widths must be the same\");\n  if (isSingleWord())\n    U.VAL -= RHS.U.VAL;\n  else\n    tcSubtract(U.pVal, RHS.U.pVal, 0, getNumWords());\n  return clearUnusedBits();\n}\n\nAPInt& APInt::operator-=(uint64_t RHS) {\n  if (isSingleWord())\n    U.VAL -= RHS;\n  else\n    tcSubtractPart(U.pVal, RHS, getNumWords());\n  return clearUnusedBits();\n}\n\nAPInt APInt::operator*(const APInt& RHS) const {\n  assert(BitWidth == RHS.BitWidth && \"Bit widths must be the same\");\n  if (isSingleWord())\n    return APInt(BitWidth, U.VAL * RHS.U.VAL);\n\n  APInt Result(getMemory(getNumWords()), getBitWidth());\n\n  tcMultiply(Result.U.pVal, U.pVal, RHS.U.pVal, getNumWords());\n\n  Result.clearUnusedBits();\n  return Result;\n}\n\nvoid APInt::AndAssignSlowCase(const APInt& RHS) {\n  tcAnd(U.pVal, RHS.U.pVal, getNumWords());\n}\n\nvoid APInt::OrAssignSlowCase(const APInt& RHS) {\n  tcOr(U.pVal, RHS.U.pVal, getNumWords());\n}\n\nvoid APInt::XorAssignSlowCase(const APInt& RHS) {\n  tcXor(U.pVal, RHS.U.pVal, getNumWords());\n}\n\nAPInt& APInt::operator*=(const APInt& RHS) {\n  assert(BitWidth == RHS.BitWidth && \"Bit widths must be the same\");\n  *this = *this * RHS;\n  return *this;\n}\n\nAPInt& APInt::operator*=(uint64_t RHS) {\n  if (isSingleWord()) {\n    U.VAL *= RHS;\n  } else {\n    unsigned NumWords = getNumWords();\n    tcMultiplyPart(U.pVal, U.pVal, RHS, 0, NumWords, NumWords, false);\n  }\n  return clearUnusedBits();\n}\n\nbool APInt::EqualSlowCase(const APInt& RHS) const {\n  return std::equal(U.pVal, U.pVal + getNumWords(), RHS.U.pVal);\n}\n\nint APInt::compare(const APInt& RHS) const {\n  assert(BitWidth == RHS.BitWidth && \"Bit widths must be same for comparison\");\n  if (isSingleWord())\n    return U.VAL < RHS.U.VAL ? -1 : U.VAL > RHS.U.VAL;\n\n  return tcCompare(U.pVal, RHS.U.pVal, getNumWords());\n}\n\nint APInt::compareSigned(const APInt& RHS) const {\n  assert(BitWidth == RHS.BitWidth && \"Bit widths must be same for comparison\");\n  if (isSingleWord()) {\n    int64_t lhsSext = SignExtend64(U.VAL, BitWidth);\n    int64_t rhsSext = SignExtend64(RHS.U.VAL, BitWidth);\n    return lhsSext < rhsSext ? -1 : lhsSext > rhsSext;\n  }\n\n  bool lhsNeg = isNegative();\n  bool rhsNeg = RHS.isNegative();\n\n  // If the sign bits don't match, then (LHS < RHS) if LHS is negative\n  if (lhsNeg != rhsNeg)\n    return lhsNeg ? -1 : 1;\n\n  // Otherwise we can just use an unsigned comparison, because even negative\n  // numbers compare correctly this way if both have the same signed-ness.\n  return tcCompare(U.pVal, RHS.U.pVal, getNumWords());\n}\n\nvoid APInt::setBitsSlowCase(unsigned loBit, unsigned hiBit) {\n  unsigned loWord = whichWord(loBit);\n  unsigned hiWord = whichWord(hiBit);\n\n  // Create an initial mask for the low word with zeros below loBit.\n  uint64_t loMask = WORDTYPE_MAX << whichBit(loBit);\n\n  // If hiBit is not aligned, we need a high mask.\n  unsigned hiShiftAmt = whichBit(hiBit);\n  if (hiShiftAmt != 0) {\n    // Create a high mask with zeros above hiBit.\n    uint64_t hiMask = WORDTYPE_MAX >> (APINT_BITS_PER_WORD - hiShiftAmt);\n    // If loWord and hiWord are equal, then we combine the masks. Otherwise,\n    // set the bits in hiWord.\n    if (hiWord == loWord)\n      loMask &= hiMask;\n    else\n      U.pVal[hiWord] |= hiMask;\n  }\n  // Apply the mask to the low word.\n  U.pVal[loWord] |= loMask;\n\n  // Fill any words between loWord and hiWord with all ones.\n  for (unsigned word = loWord + 1; word < hiWord; ++word)\n    U.pVal[word] = WORDTYPE_MAX;\n}\n\n/// Toggle every bit to its opposite value.\nvoid APInt::flipAllBitsSlowCase() {\n  tcComplement(U.pVal, getNumWords());\n  clearUnusedBits();\n}\n\n/// Toggle a given bit to its opposite value whose position is given\n/// as \"bitPosition\".\n/// Toggles a given bit to its opposite value.\nvoid APInt::flipBit(unsigned bitPosition) {\n  assert(bitPosition < BitWidth && \"Out of the bit-width range!\");\n  setBitVal(bitPosition, !(*this)[bitPosition]);\n}\n\nvoid APInt::insertBits(const APInt &subBits, unsigned bitPosition) {\n  unsigned subBitWidth = subBits.getBitWidth();\n  assert(0 < subBitWidth && (subBitWidth + bitPosition) <= BitWidth &&\n         \"Illegal bit insertion\");\n\n  // Insertion is a direct copy.\n  if (subBitWidth == BitWidth) {\n    *this = subBits;\n    return;\n  }\n\n  // Single word result can be done as a direct bitmask.\n  if (isSingleWord()) {\n    uint64_t mask = WORDTYPE_MAX >> (APINT_BITS_PER_WORD - subBitWidth);\n    U.VAL &= ~(mask << bitPosition);\n    U.VAL |= (subBits.U.VAL << bitPosition);\n    return;\n  }\n\n  unsigned loBit = whichBit(bitPosition);\n  unsigned loWord = whichWord(bitPosition);\n  unsigned hi1Word = whichWord(bitPosition + subBitWidth - 1);\n\n  // Insertion within a single word can be done as a direct bitmask.\n  if (loWord == hi1Word) {\n    uint64_t mask = WORDTYPE_MAX >> (APINT_BITS_PER_WORD - subBitWidth);\n    U.pVal[loWord] &= ~(mask << loBit);\n    U.pVal[loWord] |= (subBits.U.VAL << loBit);\n    return;\n  }\n\n  // Insert on word boundaries.\n  if (loBit == 0) {\n    // Direct copy whole words.\n    unsigned numWholeSubWords = subBitWidth / APINT_BITS_PER_WORD;\n    memcpy(U.pVal + loWord, subBits.getRawData(),\n           numWholeSubWords * APINT_WORD_SIZE);\n\n    // Mask+insert remaining bits.\n    unsigned remainingBits = subBitWidth % APINT_BITS_PER_WORD;\n    if (remainingBits != 0) {\n      uint64_t mask = WORDTYPE_MAX >> (APINT_BITS_PER_WORD - remainingBits);\n      U.pVal[hi1Word] &= ~mask;\n      U.pVal[hi1Word] |= subBits.getWord(subBitWidth - 1);\n    }\n    return;\n  }\n\n  // General case - set/clear individual bits in dst based on src.\n  // TODO - there is scope for optimization here, but at the moment this code\n  // path is barely used so prefer readability over performance.\n  for (unsigned i = 0; i != subBitWidth; ++i)\n    setBitVal(bitPosition + i, subBits[i]);\n}\n\nvoid APInt::insertBits(uint64_t subBits, unsigned bitPosition, unsigned numBits) {\n  uint64_t maskBits = maskTrailingOnes<uint64_t>(numBits);\n  subBits &= maskBits;\n  if (isSingleWord()) {\n    U.VAL &= ~(maskBits << bitPosition);\n    U.VAL |= subBits << bitPosition;\n    return;\n  }\n\n  unsigned loBit = whichBit(bitPosition);\n  unsigned loWord = whichWord(bitPosition);\n  unsigned hiWord = whichWord(bitPosition + numBits - 1);\n  if (loWord == hiWord) {\n    U.pVal[loWord] &= ~(maskBits << loBit);\n    U.pVal[loWord] |= subBits << loBit;\n    return;\n  }\n\n  static_assert(8 * sizeof(WordType) <= 64, \"This code assumes only two words affected\");\n  unsigned wordBits = 8 * sizeof(WordType);\n  U.pVal[loWord] &= ~(maskBits << loBit);\n  U.pVal[loWord] |= subBits << loBit;\n\n  U.pVal[hiWord] &= ~(maskBits >> (wordBits - loBit));\n  U.pVal[hiWord] |= subBits >> (wordBits - loBit);\n}\n\nAPInt APInt::extractBits(unsigned numBits, unsigned bitPosition) const {\n  assert(numBits > 0 && \"Can't extract zero bits\");\n  assert(bitPosition < BitWidth && (numBits + bitPosition) <= BitWidth &&\n         \"Illegal bit extraction\");\n\n  if (isSingleWord())\n    return APInt(numBits, U.VAL >> bitPosition);\n\n  unsigned loBit = whichBit(bitPosition);\n  unsigned loWord = whichWord(bitPosition);\n  unsigned hiWord = whichWord(bitPosition + numBits - 1);\n\n  // Single word result extracting bits from a single word source.\n  if (loWord == hiWord)\n    return APInt(numBits, U.pVal[loWord] >> loBit);\n\n  // Extracting bits that start on a source word boundary can be done\n  // as a fast memory copy.\n  if (loBit == 0)\n    return APInt(numBits, makeArrayRef(U.pVal + loWord, 1 + hiWord - loWord));\n\n  // General case - shift + copy source words directly into place.\n  APInt Result(numBits, 0);\n  unsigned NumSrcWords = getNumWords();\n  unsigned NumDstWords = Result.getNumWords();\n\n  uint64_t *DestPtr = Result.isSingleWord() ? &Result.U.VAL : Result.U.pVal;\n  for (unsigned word = 0; word < NumDstWords; ++word) {\n    uint64_t w0 = U.pVal[loWord + word];\n    uint64_t w1 =\n        (loWord + word + 1) < NumSrcWords ? U.pVal[loWord + word + 1] : 0;\n    DestPtr[word] = (w0 >> loBit) | (w1 << (APINT_BITS_PER_WORD - loBit));\n  }\n\n  return Result.clearUnusedBits();\n}\n\nuint64_t APInt::extractBitsAsZExtValue(unsigned numBits,\n                                       unsigned bitPosition) const {\n  assert(numBits > 0 && \"Can't extract zero bits\");\n  assert(bitPosition < BitWidth && (numBits + bitPosition) <= BitWidth &&\n         \"Illegal bit extraction\");\n  assert(numBits <= 64 && \"Illegal bit extraction\");\n\n  uint64_t maskBits = maskTrailingOnes<uint64_t>(numBits);\n  if (isSingleWord())\n    return (U.VAL >> bitPosition) & maskBits;\n\n  unsigned loBit = whichBit(bitPosition);\n  unsigned loWord = whichWord(bitPosition);\n  unsigned hiWord = whichWord(bitPosition + numBits - 1);\n  if (loWord == hiWord)\n    return (U.pVal[loWord] >> loBit) & maskBits;\n\n  static_assert(8 * sizeof(WordType) <= 64, \"This code assumes only two words affected\");\n  unsigned wordBits = 8 * sizeof(WordType);\n  uint64_t retBits = U.pVal[loWord] >> loBit;\n  retBits |= U.pVal[hiWord] << (wordBits - loBit);\n  retBits &= maskBits;\n  return retBits;\n}\n\nunsigned APInt::getBitsNeeded(StringRef str, uint8_t radix) {\n  assert(!str.empty() && \"Invalid string length\");\n  assert((radix == 10 || radix == 8 || radix == 16 || radix == 2 ||\n          radix == 36) &&\n         \"Radix should be 2, 8, 10, 16, or 36!\");\n\n  size_t slen = str.size();\n\n  // Each computation below needs to know if it's negative.\n  StringRef::iterator p = str.begin();\n  unsigned isNegative = *p == '-';\n  if (*p == '-' || *p == '+') {\n    p++;\n    slen--;\n    assert(slen && \"String is only a sign, needs a value.\");\n  }\n\n  // For radixes of power-of-two values, the bits required is accurately and\n  // easily computed\n  if (radix == 2)\n    return slen + isNegative;\n  if (radix == 8)\n    return slen * 3 + isNegative;\n  if (radix == 16)\n    return slen * 4 + isNegative;\n\n  // FIXME: base 36\n\n  // This is grossly inefficient but accurate. We could probably do something\n  // with a computation of roughly slen*64/20 and then adjust by the value of\n  // the first few digits. But, I'm not sure how accurate that could be.\n\n  // Compute a sufficient number of bits that is always large enough but might\n  // be too large. This avoids the assertion in the constructor. This\n  // calculation doesn't work appropriately for the numbers 0-9, so just use 4\n  // bits in that case.\n  unsigned sufficient\n    = radix == 10? (slen == 1 ? 4 : slen * 64/18)\n                 : (slen == 1 ? 7 : slen * 16/3);\n\n  // Convert to the actual binary value.\n  APInt tmp(sufficient, StringRef(p, slen), radix);\n\n  // Compute how many bits are required. If the log is infinite, assume we need\n  // just bit. If the log is exact and value is negative, then the value is\n  // MinSignedValue with (log + 1) bits.\n  unsigned log = tmp.logBase2();\n  if (log == (unsigned)-1) {\n    return isNegative + 1;\n  } else if (isNegative && tmp.isPowerOf2()) {\n    return isNegative + log;\n  } else {\n    return isNegative + log + 1;\n  }\n}\n\nhash_code llvm::hash_value(const APInt &Arg) {\n  if (Arg.isSingleWord())\n    return hash_combine(Arg.BitWidth, Arg.U.VAL);\n\n  return hash_combine(\n      Arg.BitWidth,\n      hash_combine_range(Arg.U.pVal, Arg.U.pVal + Arg.getNumWords()));\n}\n\nbool APInt::isSplat(unsigned SplatSizeInBits) const {\n  assert(getBitWidth() % SplatSizeInBits == 0 &&\n         \"SplatSizeInBits must divide width!\");\n  // We can check that all parts of an integer are equal by making use of a\n  // little trick: rotate and check if it's still the same value.\n  return *this == rotl(SplatSizeInBits);\n}\n\n/// This function returns the high \"numBits\" bits of this APInt.\nAPInt APInt::getHiBits(unsigned numBits) const {\n  return this->lshr(BitWidth - numBits);\n}\n\n/// This function returns the low \"numBits\" bits of this APInt.\nAPInt APInt::getLoBits(unsigned numBits) const {\n  APInt Result(getLowBitsSet(BitWidth, numBits));\n  Result &= *this;\n  return Result;\n}\n\n/// Return a value containing V broadcasted over NewLen bits.\nAPInt APInt::getSplat(unsigned NewLen, const APInt &V) {\n  assert(NewLen >= V.getBitWidth() && \"Can't splat to smaller bit width!\");\n\n  APInt Val = V.zextOrSelf(NewLen);\n  for (unsigned I = V.getBitWidth(); I < NewLen; I <<= 1)\n    Val |= Val << I;\n\n  return Val;\n}\n\nunsigned APInt::countLeadingZerosSlowCase() const {\n  unsigned Count = 0;\n  for (int i = getNumWords()-1; i >= 0; --i) {\n    uint64_t V = U.pVal[i];\n    if (V == 0)\n      Count += APINT_BITS_PER_WORD;\n    else {\n      Count += llvm::countLeadingZeros(V);\n      break;\n    }\n  }\n  // Adjust for unused bits in the most significant word (they are zero).\n  unsigned Mod = BitWidth % APINT_BITS_PER_WORD;\n  Count -= Mod > 0 ? APINT_BITS_PER_WORD - Mod : 0;\n  return Count;\n}\n\nunsigned APInt::countLeadingOnesSlowCase() const {\n  unsigned highWordBits = BitWidth % APINT_BITS_PER_WORD;\n  unsigned shift;\n  if (!highWordBits) {\n    highWordBits = APINT_BITS_PER_WORD;\n    shift = 0;\n  } else {\n    shift = APINT_BITS_PER_WORD - highWordBits;\n  }\n  int i = getNumWords() - 1;\n  unsigned Count = llvm::countLeadingOnes(U.pVal[i] << shift);\n  if (Count == highWordBits) {\n    for (i--; i >= 0; --i) {\n      if (U.pVal[i] == WORDTYPE_MAX)\n        Count += APINT_BITS_PER_WORD;\n      else {\n        Count += llvm::countLeadingOnes(U.pVal[i]);\n        break;\n      }\n    }\n  }\n  return Count;\n}\n\nunsigned APInt::countTrailingZerosSlowCase() const {\n  unsigned Count = 0;\n  unsigned i = 0;\n  for (; i < getNumWords() && U.pVal[i] == 0; ++i)\n    Count += APINT_BITS_PER_WORD;\n  if (i < getNumWords())\n    Count += llvm::countTrailingZeros(U.pVal[i]);\n  return std::min(Count, BitWidth);\n}\n\nunsigned APInt::countTrailingOnesSlowCase() const {\n  unsigned Count = 0;\n  unsigned i = 0;\n  for (; i < getNumWords() && U.pVal[i] == WORDTYPE_MAX; ++i)\n    Count += APINT_BITS_PER_WORD;\n  if (i < getNumWords())\n    Count += llvm::countTrailingOnes(U.pVal[i]);\n  assert(Count <= BitWidth);\n  return Count;\n}\n\nunsigned APInt::countPopulationSlowCase() const {\n  unsigned Count = 0;\n  for (unsigned i = 0; i < getNumWords(); ++i)\n    Count += llvm::countPopulation(U.pVal[i]);\n  return Count;\n}\n\nbool APInt::intersectsSlowCase(const APInt &RHS) const {\n  for (unsigned i = 0, e = getNumWords(); i != e; ++i)\n    if ((U.pVal[i] & RHS.U.pVal[i]) != 0)\n      return true;\n\n  return false;\n}\n\nbool APInt::isSubsetOfSlowCase(const APInt &RHS) const {\n  for (unsigned i = 0, e = getNumWords(); i != e; ++i)\n    if ((U.pVal[i] & ~RHS.U.pVal[i]) != 0)\n      return false;\n\n  return true;\n}\n\nAPInt APInt::byteSwap() const {\n  assert(BitWidth >= 16 && BitWidth % 8 == 0 && \"Cannot byteswap!\");\n  if (BitWidth == 16)\n    return APInt(BitWidth, ByteSwap_16(uint16_t(U.VAL)));\n  if (BitWidth == 32)\n    return APInt(BitWidth, ByteSwap_32(unsigned(U.VAL)));\n  if (BitWidth <= 64) {\n    uint64_t Tmp1 = ByteSwap_64(U.VAL);\n    Tmp1 >>= (64 - BitWidth);\n    return APInt(BitWidth, Tmp1);\n  }\n\n  APInt Result(getNumWords() * APINT_BITS_PER_WORD, 0);\n  for (unsigned I = 0, N = getNumWords(); I != N; ++I)\n    Result.U.pVal[I] = ByteSwap_64(U.pVal[N - I - 1]);\n  if (Result.BitWidth != BitWidth) {\n    Result.lshrInPlace(Result.BitWidth - BitWidth);\n    Result.BitWidth = BitWidth;\n  }\n  return Result;\n}\n\nAPInt APInt::reverseBits() const {\n  switch (BitWidth) {\n  case 64:\n    return APInt(BitWidth, llvm::reverseBits<uint64_t>(U.VAL));\n  case 32:\n    return APInt(BitWidth, llvm::reverseBits<uint32_t>(U.VAL));\n  case 16:\n    return APInt(BitWidth, llvm::reverseBits<uint16_t>(U.VAL));\n  case 8:\n    return APInt(BitWidth, llvm::reverseBits<uint8_t>(U.VAL));\n  default:\n    break;\n  }\n\n  APInt Val(*this);\n  APInt Reversed(BitWidth, 0);\n  unsigned S = BitWidth;\n\n  for (; Val != 0; Val.lshrInPlace(1)) {\n    Reversed <<= 1;\n    Reversed |= Val[0];\n    --S;\n  }\n\n  Reversed <<= S;\n  return Reversed;\n}\n\nAPInt llvm::APIntOps::GreatestCommonDivisor(APInt A, APInt B) {\n  // Fast-path a common case.\n  if (A == B) return A;\n\n  // Corner cases: if either operand is zero, the other is the gcd.\n  if (!A) return B;\n  if (!B) return A;\n\n  // Count common powers of 2 and remove all other powers of 2.\n  unsigned Pow2;\n  {\n    unsigned Pow2_A = A.countTrailingZeros();\n    unsigned Pow2_B = B.countTrailingZeros();\n    if (Pow2_A > Pow2_B) {\n      A.lshrInPlace(Pow2_A - Pow2_B);\n      Pow2 = Pow2_B;\n    } else if (Pow2_B > Pow2_A) {\n      B.lshrInPlace(Pow2_B - Pow2_A);\n      Pow2 = Pow2_A;\n    } else {\n      Pow2 = Pow2_A;\n    }\n  }\n\n  // Both operands are odd multiples of 2^Pow_2:\n  //\n  //   gcd(a, b) = gcd(|a - b| / 2^i, min(a, b))\n  //\n  // This is a modified version of Stein's algorithm, taking advantage of\n  // efficient countTrailingZeros().\n  while (A != B) {\n    if (A.ugt(B)) {\n      A -= B;\n      A.lshrInPlace(A.countTrailingZeros() - Pow2);\n    } else {\n      B -= A;\n      B.lshrInPlace(B.countTrailingZeros() - Pow2);\n    }\n  }\n\n  return A;\n}\n\nAPInt llvm::APIntOps::RoundDoubleToAPInt(double Double, unsigned width) {\n  uint64_t I = bit_cast<uint64_t>(Double);\n\n  // Get the sign bit from the highest order bit\n  bool isNeg = I >> 63;\n\n  // Get the 11-bit exponent and adjust for the 1023 bit bias\n  int64_t exp = ((I >> 52) & 0x7ff) - 1023;\n\n  // If the exponent is negative, the value is < 0 so just return 0.\n  if (exp < 0)\n    return APInt(width, 0u);\n\n  // Extract the mantissa by clearing the top 12 bits (sign + exponent).\n  uint64_t mantissa = (I & (~0ULL >> 12)) | 1ULL << 52;\n\n  // If the exponent doesn't shift all bits out of the mantissa\n  if (exp < 52)\n    return isNeg ? -APInt(width, mantissa >> (52 - exp)) :\n                    APInt(width, mantissa >> (52 - exp));\n\n  // If the client didn't provide enough bits for us to shift the mantissa into\n  // then the result is undefined, just return 0\n  if (width <= exp - 52)\n    return APInt(width, 0);\n\n  // Otherwise, we have to shift the mantissa bits up to the right location\n  APInt Tmp(width, mantissa);\n  Tmp <<= (unsigned)exp - 52;\n  return isNeg ? -Tmp : Tmp;\n}\n\n/// This function converts this APInt to a double.\n/// The layout for double is as following (IEEE Standard 754):\n///  --------------------------------------\n/// |  Sign    Exponent    Fraction    Bias |\n/// |-------------------------------------- |\n/// |  1[63]   11[62-52]   52[51-00]   1023 |\n///  --------------------------------------\ndouble APInt::roundToDouble(bool isSigned) const {\n\n  // Handle the simple case where the value is contained in one uint64_t.\n  // It is wrong to optimize getWord(0) to VAL; there might be more than one word.\n  if (isSingleWord() || getActiveBits() <= APINT_BITS_PER_WORD) {\n    if (isSigned) {\n      int64_t sext = SignExtend64(getWord(0), BitWidth);\n      return double(sext);\n    } else\n      return double(getWord(0));\n  }\n\n  // Determine if the value is negative.\n  bool isNeg = isSigned ? (*this)[BitWidth-1] : false;\n\n  // Construct the absolute value if we're negative.\n  APInt Tmp(isNeg ? -(*this) : (*this));\n\n  // Figure out how many bits we're using.\n  unsigned n = Tmp.getActiveBits();\n\n  // The exponent (without bias normalization) is just the number of bits\n  // we are using. Note that the sign bit is gone since we constructed the\n  // absolute value.\n  uint64_t exp = n;\n\n  // Return infinity for exponent overflow\n  if (exp > 1023) {\n    if (!isSigned || !isNeg)\n      return std::numeric_limits<double>::infinity();\n    else\n      return -std::numeric_limits<double>::infinity();\n  }\n  exp += 1023; // Increment for 1023 bias\n\n  // Number of bits in mantissa is 52. To obtain the mantissa value, we must\n  // extract the high 52 bits from the correct words in pVal.\n  uint64_t mantissa;\n  unsigned hiWord = whichWord(n-1);\n  if (hiWord == 0) {\n    mantissa = Tmp.U.pVal[0];\n    if (n > 52)\n      mantissa >>= n - 52; // shift down, we want the top 52 bits.\n  } else {\n    assert(hiWord > 0 && \"huh?\");\n    uint64_t hibits = Tmp.U.pVal[hiWord] << (52 - n % APINT_BITS_PER_WORD);\n    uint64_t lobits = Tmp.U.pVal[hiWord-1] >> (11 + n % APINT_BITS_PER_WORD);\n    mantissa = hibits | lobits;\n  }\n\n  // The leading bit of mantissa is implicit, so get rid of it.\n  uint64_t sign = isNeg ? (1ULL << (APINT_BITS_PER_WORD - 1)) : 0;\n  uint64_t I = sign | (exp << 52) | mantissa;\n  return bit_cast<double>(I);\n}\n\n// Truncate to new width.\nAPInt APInt::trunc(unsigned width) const {\n  assert(width < BitWidth && \"Invalid APInt Truncate request\");\n  assert(width && \"Can't truncate to 0 bits\");\n\n  if (width <= APINT_BITS_PER_WORD)\n    return APInt(width, getRawData()[0]);\n\n  APInt Result(getMemory(getNumWords(width)), width);\n\n  // Copy full words.\n  unsigned i;\n  for (i = 0; i != width / APINT_BITS_PER_WORD; i++)\n    Result.U.pVal[i] = U.pVal[i];\n\n  // Truncate and copy any partial word.\n  unsigned bits = (0 - width) % APINT_BITS_PER_WORD;\n  if (bits != 0)\n    Result.U.pVal[i] = U.pVal[i] << bits >> bits;\n\n  return Result;\n}\n\n// Truncate to new width with unsigned saturation.\nAPInt APInt::truncUSat(unsigned width) const {\n  assert(width < BitWidth && \"Invalid APInt Truncate request\");\n  assert(width && \"Can't truncate to 0 bits\");\n\n  // Can we just losslessly truncate it?\n  if (isIntN(width))\n    return trunc(width);\n  // If not, then just return the new limit.\n  return APInt::getMaxValue(width);\n}\n\n// Truncate to new width with signed saturation.\nAPInt APInt::truncSSat(unsigned width) const {\n  assert(width < BitWidth && \"Invalid APInt Truncate request\");\n  assert(width && \"Can't truncate to 0 bits\");\n\n  // Can we just losslessly truncate it?\n  if (isSignedIntN(width))\n    return trunc(width);\n  // If not, then just return the new limits.\n  return isNegative() ? APInt::getSignedMinValue(width)\n                      : APInt::getSignedMaxValue(width);\n}\n\n// Sign extend to a new width.\nAPInt APInt::sext(unsigned Width) const {\n  assert(Width > BitWidth && \"Invalid APInt SignExtend request\");\n\n  if (Width <= APINT_BITS_PER_WORD)\n    return APInt(Width, SignExtend64(U.VAL, BitWidth));\n\n  APInt Result(getMemory(getNumWords(Width)), Width);\n\n  // Copy words.\n  std::memcpy(Result.U.pVal, getRawData(), getNumWords() * APINT_WORD_SIZE);\n\n  // Sign extend the last word since there may be unused bits in the input.\n  Result.U.pVal[getNumWords() - 1] =\n      SignExtend64(Result.U.pVal[getNumWords() - 1],\n                   ((BitWidth - 1) % APINT_BITS_PER_WORD) + 1);\n\n  // Fill with sign bits.\n  std::memset(Result.U.pVal + getNumWords(), isNegative() ? -1 : 0,\n              (Result.getNumWords() - getNumWords()) * APINT_WORD_SIZE);\n  Result.clearUnusedBits();\n  return Result;\n}\n\n//  Zero extend to a new width.\nAPInt APInt::zext(unsigned width) const {\n  assert(width > BitWidth && \"Invalid APInt ZeroExtend request\");\n\n  if (width <= APINT_BITS_PER_WORD)\n    return APInt(width, U.VAL);\n\n  APInt Result(getMemory(getNumWords(width)), width);\n\n  // Copy words.\n  std::memcpy(Result.U.pVal, getRawData(), getNumWords() * APINT_WORD_SIZE);\n\n  // Zero remaining words.\n  std::memset(Result.U.pVal + getNumWords(), 0,\n              (Result.getNumWords() - getNumWords()) * APINT_WORD_SIZE);\n\n  return Result;\n}\n\nAPInt APInt::zextOrTrunc(unsigned width) const {\n  if (BitWidth < width)\n    return zext(width);\n  if (BitWidth > width)\n    return trunc(width);\n  return *this;\n}\n\nAPInt APInt::sextOrTrunc(unsigned width) const {\n  if (BitWidth < width)\n    return sext(width);\n  if (BitWidth > width)\n    return trunc(width);\n  return *this;\n}\n\nAPInt APInt::truncOrSelf(unsigned width) const {\n  if (BitWidth > width)\n    return trunc(width);\n  return *this;\n}\n\nAPInt APInt::zextOrSelf(unsigned width) const {\n  if (BitWidth < width)\n    return zext(width);\n  return *this;\n}\n\nAPInt APInt::sextOrSelf(unsigned width) const {\n  if (BitWidth < width)\n    return sext(width);\n  return *this;\n}\n\n/// Arithmetic right-shift this APInt by shiftAmt.\n/// Arithmetic right-shift function.\nvoid APInt::ashrInPlace(const APInt &shiftAmt) {\n  ashrInPlace((unsigned)shiftAmt.getLimitedValue(BitWidth));\n}\n\n/// Arithmetic right-shift this APInt by shiftAmt.\n/// Arithmetic right-shift function.\nvoid APInt::ashrSlowCase(unsigned ShiftAmt) {\n  // Don't bother performing a no-op shift.\n  if (!ShiftAmt)\n    return;\n\n  // Save the original sign bit for later.\n  bool Negative = isNegative();\n\n  // WordShift is the inter-part shift; BitShift is intra-part shift.\n  unsigned WordShift = ShiftAmt / APINT_BITS_PER_WORD;\n  unsigned BitShift = ShiftAmt % APINT_BITS_PER_WORD;\n\n  unsigned WordsToMove = getNumWords() - WordShift;\n  if (WordsToMove != 0) {\n    // Sign extend the last word to fill in the unused bits.\n    U.pVal[getNumWords() - 1] = SignExtend64(\n        U.pVal[getNumWords() - 1], ((BitWidth - 1) % APINT_BITS_PER_WORD) + 1);\n\n    // Fastpath for moving by whole words.\n    if (BitShift == 0) {\n      std::memmove(U.pVal, U.pVal + WordShift, WordsToMove * APINT_WORD_SIZE);\n    } else {\n      // Move the words containing significant bits.\n      for (unsigned i = 0; i != WordsToMove - 1; ++i)\n        U.pVal[i] = (U.pVal[i + WordShift] >> BitShift) |\n                    (U.pVal[i + WordShift + 1] << (APINT_BITS_PER_WORD - BitShift));\n\n      // Handle the last word which has no high bits to copy.\n      U.pVal[WordsToMove - 1] = U.pVal[WordShift + WordsToMove - 1] >> BitShift;\n      // Sign extend one more time.\n      U.pVal[WordsToMove - 1] =\n          SignExtend64(U.pVal[WordsToMove - 1], APINT_BITS_PER_WORD - BitShift);\n    }\n  }\n\n  // Fill in the remainder based on the original sign.\n  std::memset(U.pVal + WordsToMove, Negative ? -1 : 0,\n              WordShift * APINT_WORD_SIZE);\n  clearUnusedBits();\n}\n\n/// Logical right-shift this APInt by shiftAmt.\n/// Logical right-shift function.\nvoid APInt::lshrInPlace(const APInt &shiftAmt) {\n  lshrInPlace((unsigned)shiftAmt.getLimitedValue(BitWidth));\n}\n\n/// Logical right-shift this APInt by shiftAmt.\n/// Logical right-shift function.\nvoid APInt::lshrSlowCase(unsigned ShiftAmt) {\n  tcShiftRight(U.pVal, getNumWords(), ShiftAmt);\n}\n\n/// Left-shift this APInt by shiftAmt.\n/// Left-shift function.\nAPInt &APInt::operator<<=(const APInt &shiftAmt) {\n  // It's undefined behavior in C to shift by BitWidth or greater.\n  *this <<= (unsigned)shiftAmt.getLimitedValue(BitWidth);\n  return *this;\n}\n\nvoid APInt::shlSlowCase(unsigned ShiftAmt) {\n  tcShiftLeft(U.pVal, getNumWords(), ShiftAmt);\n  clearUnusedBits();\n}\n\n// Calculate the rotate amount modulo the bit width.\nstatic unsigned rotateModulo(unsigned BitWidth, const APInt &rotateAmt) {\n  unsigned rotBitWidth = rotateAmt.getBitWidth();\n  APInt rot = rotateAmt;\n  if (rotBitWidth < BitWidth) {\n    // Extend the rotate APInt, so that the urem doesn't divide by 0.\n    // e.g. APInt(1, 32) would give APInt(1, 0).\n    rot = rotateAmt.zext(BitWidth);\n  }\n  rot = rot.urem(APInt(rot.getBitWidth(), BitWidth));\n  return rot.getLimitedValue(BitWidth);\n}\n\nAPInt APInt::rotl(const APInt &rotateAmt) const {\n  return rotl(rotateModulo(BitWidth, rotateAmt));\n}\n\nAPInt APInt::rotl(unsigned rotateAmt) const {\n  rotateAmt %= BitWidth;\n  if (rotateAmt == 0)\n    return *this;\n  return shl(rotateAmt) | lshr(BitWidth - rotateAmt);\n}\n\nAPInt APInt::rotr(const APInt &rotateAmt) const {\n  return rotr(rotateModulo(BitWidth, rotateAmt));\n}\n\nAPInt APInt::rotr(unsigned rotateAmt) const {\n  rotateAmt %= BitWidth;\n  if (rotateAmt == 0)\n    return *this;\n  return lshr(rotateAmt) | shl(BitWidth - rotateAmt);\n}\n\n// Square Root - this method computes and returns the square root of \"this\".\n// Three mechanisms are used for computation. For small values (<= 5 bits),\n// a table lookup is done. This gets some performance for common cases. For\n// values using less than 52 bits, the value is converted to double and then\n// the libc sqrt function is called. The result is rounded and then converted\n// back to a uint64_t which is then used to construct the result. Finally,\n// the Babylonian method for computing square roots is used.\nAPInt APInt::sqrt() const {\n\n  // Determine the magnitude of the value.\n  unsigned magnitude = getActiveBits();\n\n  // Use a fast table for some small values. This also gets rid of some\n  // rounding errors in libc sqrt for small values.\n  if (magnitude <= 5) {\n    static const uint8_t results[32] = {\n      /*     0 */ 0,\n      /*  1- 2 */ 1, 1,\n      /*  3- 6 */ 2, 2, 2, 2,\n      /*  7-12 */ 3, 3, 3, 3, 3, 3,\n      /* 13-20 */ 4, 4, 4, 4, 4, 4, 4, 4,\n      /* 21-30 */ 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n      /*    31 */ 6\n    };\n    return APInt(BitWidth, results[ (isSingleWord() ? U.VAL : U.pVal[0]) ]);\n  }\n\n  // If the magnitude of the value fits in less than 52 bits (the precision of\n  // an IEEE double precision floating point value), then we can use the\n  // libc sqrt function which will probably use a hardware sqrt computation.\n  // This should be faster than the algorithm below.\n  if (magnitude < 52) {\n    return APInt(BitWidth,\n                 uint64_t(::round(::sqrt(double(isSingleWord() ? U.VAL\n                                                               : U.pVal[0])))));\n  }\n\n  // Okay, all the short cuts are exhausted. We must compute it. The following\n  // is a classical Babylonian method for computing the square root. This code\n  // was adapted to APInt from a wikipedia article on such computations.\n  // See http://www.wikipedia.org/ and go to the page named\n  // Calculate_an_integer_square_root.\n  unsigned nbits = BitWidth, i = 4;\n  APInt testy(BitWidth, 16);\n  APInt x_old(BitWidth, 1);\n  APInt x_new(BitWidth, 0);\n  APInt two(BitWidth, 2);\n\n  // Select a good starting value using binary logarithms.\n  for (;; i += 2, testy = testy.shl(2))\n    if (i >= nbits || this->ule(testy)) {\n      x_old = x_old.shl(i / 2);\n      break;\n    }\n\n  // Use the Babylonian method to arrive at the integer square root:\n  for (;;) {\n    x_new = (this->udiv(x_old) + x_old).udiv(two);\n    if (x_old.ule(x_new))\n      break;\n    x_old = x_new;\n  }\n\n  // Make sure we return the closest approximation\n  // NOTE: The rounding calculation below is correct. It will produce an\n  // off-by-one discrepancy with results from pari/gp. That discrepancy has been\n  // determined to be a rounding issue with pari/gp as it begins to use a\n  // floating point representation after 192 bits. There are no discrepancies\n  // between this algorithm and pari/gp for bit widths < 192 bits.\n  APInt square(x_old * x_old);\n  APInt nextSquare((x_old + 1) * (x_old +1));\n  if (this->ult(square))\n    return x_old;\n  assert(this->ule(nextSquare) && \"Error in APInt::sqrt computation\");\n  APInt midpoint((nextSquare - square).udiv(two));\n  APInt offset(*this - square);\n  if (offset.ult(midpoint))\n    return x_old;\n  return x_old + 1;\n}\n\n/// Computes the multiplicative inverse of this APInt for a given modulo. The\n/// iterative extended Euclidean algorithm is used to solve for this value,\n/// however we simplify it to speed up calculating only the inverse, and take\n/// advantage of div+rem calculations. We also use some tricks to avoid copying\n/// (potentially large) APInts around.\n/// WARNING: a value of '0' may be returned,\n///          signifying that no multiplicative inverse exists!\nAPInt APInt::multiplicativeInverse(const APInt& modulo) const {\n  assert(ult(modulo) && \"This APInt must be smaller than the modulo\");\n\n  // Using the properties listed at the following web page (accessed 06/21/08):\n  //   http://www.numbertheory.org/php/euclid.html\n  // (especially the properties numbered 3, 4 and 9) it can be proved that\n  // BitWidth bits suffice for all the computations in the algorithm implemented\n  // below. More precisely, this number of bits suffice if the multiplicative\n  // inverse exists, but may not suffice for the general extended Euclidean\n  // algorithm.\n\n  APInt r[2] = { modulo, *this };\n  APInt t[2] = { APInt(BitWidth, 0), APInt(BitWidth, 1) };\n  APInt q(BitWidth, 0);\n\n  unsigned i;\n  for (i = 0; r[i^1] != 0; i ^= 1) {\n    // An overview of the math without the confusing bit-flipping:\n    // q = r[i-2] / r[i-1]\n    // r[i] = r[i-2] % r[i-1]\n    // t[i] = t[i-2] - t[i-1] * q\n    udivrem(r[i], r[i^1], q, r[i]);\n    t[i] -= t[i^1] * q;\n  }\n\n  // If this APInt and the modulo are not coprime, there is no multiplicative\n  // inverse, so return 0. We check this by looking at the next-to-last\n  // remainder, which is the gcd(*this,modulo) as calculated by the Euclidean\n  // algorithm.\n  if (r[i] != 1)\n    return APInt(BitWidth, 0);\n\n  // The next-to-last t is the multiplicative inverse.  However, we are\n  // interested in a positive inverse. Calculate a positive one from a negative\n  // one if necessary. A simple addition of the modulo suffices because\n  // abs(t[i]) is known to be less than *this/2 (see the link above).\n  if (t[i].isNegative())\n    t[i] += modulo;\n\n  return std::move(t[i]);\n}\n\n/// Calculate the magic numbers required to implement a signed integer division\n/// by a constant as a sequence of multiplies, adds and shifts.  Requires that\n/// the divisor not be 0, 1, or -1.  Taken from \"Hacker's Delight\", Henry S.\n/// Warren, Jr., chapter 10.\nAPInt::ms APInt::magic() const {\n  const APInt& d = *this;\n  unsigned p;\n  APInt ad, anc, delta, q1, r1, q2, r2, t;\n  APInt signedMin = APInt::getSignedMinValue(d.getBitWidth());\n  struct ms mag;\n\n  ad = d.abs();\n  t = signedMin + (d.lshr(d.getBitWidth() - 1));\n  anc = t - 1 - t.urem(ad);   // absolute value of nc\n  p = d.getBitWidth() - 1;    // initialize p\n  q1 = signedMin.udiv(anc);   // initialize q1 = 2p/abs(nc)\n  r1 = signedMin - q1*anc;    // initialize r1 = rem(2p,abs(nc))\n  q2 = signedMin.udiv(ad);    // initialize q2 = 2p/abs(d)\n  r2 = signedMin - q2*ad;     // initialize r2 = rem(2p,abs(d))\n  do {\n    p = p + 1;\n    q1 = q1<<1;          // update q1 = 2p/abs(nc)\n    r1 = r1<<1;          // update r1 = rem(2p/abs(nc))\n    if (r1.uge(anc)) {  // must be unsigned comparison\n      q1 = q1 + 1;\n      r1 = r1 - anc;\n    }\n    q2 = q2<<1;          // update q2 = 2p/abs(d)\n    r2 = r2<<1;          // update r2 = rem(2p/abs(d))\n    if (r2.uge(ad)) {   // must be unsigned comparison\n      q2 = q2 + 1;\n      r2 = r2 - ad;\n    }\n    delta = ad - r2;\n  } while (q1.ult(delta) || (q1 == delta && r1 == 0));\n\n  mag.m = q2 + 1;\n  if (d.isNegative()) mag.m = -mag.m;   // resulting magic number\n  mag.s = p - d.getBitWidth();          // resulting shift\n  return mag;\n}\n\n/// Calculate the magic numbers required to implement an unsigned integer\n/// division by a constant as a sequence of multiplies, adds and shifts.\n/// Requires that the divisor not be 0.  Taken from \"Hacker's Delight\", Henry\n/// S. Warren, Jr., chapter 10.\n/// LeadingZeros can be used to simplify the calculation if the upper bits\n/// of the divided value are known zero.\nAPInt::mu APInt::magicu(unsigned LeadingZeros) const {\n  const APInt& d = *this;\n  unsigned p;\n  APInt nc, delta, q1, r1, q2, r2;\n  struct mu magu;\n  magu.a = 0;               // initialize \"add\" indicator\n  APInt allOnes = APInt::getAllOnesValue(d.getBitWidth()).lshr(LeadingZeros);\n  APInt signedMin = APInt::getSignedMinValue(d.getBitWidth());\n  APInt signedMax = APInt::getSignedMaxValue(d.getBitWidth());\n\n  nc = allOnes - (allOnes - d).urem(d);\n  p = d.getBitWidth() - 1;  // initialize p\n  q1 = signedMin.udiv(nc);  // initialize q1 = 2p/nc\n  r1 = signedMin - q1*nc;   // initialize r1 = rem(2p,nc)\n  q2 = signedMax.udiv(d);   // initialize q2 = (2p-1)/d\n  r2 = signedMax - q2*d;    // initialize r2 = rem((2p-1),d)\n  do {\n    p = p + 1;\n    if (r1.uge(nc - r1)) {\n      q1 = q1 + q1 + 1;  // update q1\n      r1 = r1 + r1 - nc; // update r1\n    }\n    else {\n      q1 = q1+q1; // update q1\n      r1 = r1+r1; // update r1\n    }\n    if ((r2 + 1).uge(d - r2)) {\n      if (q2.uge(signedMax)) magu.a = 1;\n      q2 = q2+q2 + 1;     // update q2\n      r2 = r2+r2 + 1 - d; // update r2\n    }\n    else {\n      if (q2.uge(signedMin)) magu.a = 1;\n      q2 = q2+q2;     // update q2\n      r2 = r2+r2 + 1; // update r2\n    }\n    delta = d - 1 - r2;\n  } while (p < d.getBitWidth()*2 &&\n           (q1.ult(delta) || (q1 == delta && r1 == 0)));\n  magu.m = q2 + 1; // resulting magic number\n  magu.s = p - d.getBitWidth();  // resulting shift\n  return magu;\n}\n\n/// Implementation of Knuth's Algorithm D (Division of nonnegative integers)\n/// from \"Art of Computer Programming, Volume 2\", section 4.3.1, p. 272. The\n/// variables here have the same names as in the algorithm. Comments explain\n/// the algorithm and any deviation from it.\nstatic void KnuthDiv(uint32_t *u, uint32_t *v, uint32_t *q, uint32_t* r,\n                     unsigned m, unsigned n) {\n  assert(u && \"Must provide dividend\");\n  assert(v && \"Must provide divisor\");\n  assert(q && \"Must provide quotient\");\n  assert(u != v && u != q && v != q && \"Must use different memory\");\n  assert(n>1 && \"n must be > 1\");\n\n  // b denotes the base of the number system. In our case b is 2^32.\n  const uint64_t b = uint64_t(1) << 32;\n\n// The DEBUG macros here tend to be spam in the debug output if you're not\n// debugging this code. Disable them unless KNUTH_DEBUG is defined.\n#ifdef KNUTH_DEBUG\n#define DEBUG_KNUTH(X) LLVM_DEBUG(X)\n#else\n#define DEBUG_KNUTH(X) do {} while(false)\n#endif\n\n  DEBUG_KNUTH(dbgs() << \"KnuthDiv: m=\" << m << \" n=\" << n << '\\n');\n  DEBUG_KNUTH(dbgs() << \"KnuthDiv: original:\");\n  DEBUG_KNUTH(for (int i = m + n; i >= 0; i--) dbgs() << \" \" << u[i]);\n  DEBUG_KNUTH(dbgs() << \" by\");\n  DEBUG_KNUTH(for (int i = n; i > 0; i--) dbgs() << \" \" << v[i - 1]);\n  DEBUG_KNUTH(dbgs() << '\\n');\n  // D1. [Normalize.] Set d = b / (v[n-1] + 1) and multiply all the digits of\n  // u and v by d. Note that we have taken Knuth's advice here to use a power\n  // of 2 value for d such that d * v[n-1] >= b/2 (b is the base). A power of\n  // 2 allows us to shift instead of multiply and it is easy to determine the\n  // shift amount from the leading zeros.  We are basically normalizing the u\n  // and v so that its high bits are shifted to the top of v's range without\n  // overflow. Note that this can require an extra word in u so that u must\n  // be of length m+n+1.\n  unsigned shift = countLeadingZeros(v[n-1]);\n  uint32_t v_carry = 0;\n  uint32_t u_carry = 0;\n  if (shift) {\n    for (unsigned i = 0; i < m+n; ++i) {\n      uint32_t u_tmp = u[i] >> (32 - shift);\n      u[i] = (u[i] << shift) | u_carry;\n      u_carry = u_tmp;\n    }\n    for (unsigned i = 0; i < n; ++i) {\n      uint32_t v_tmp = v[i] >> (32 - shift);\n      v[i] = (v[i] << shift) | v_carry;\n      v_carry = v_tmp;\n    }\n  }\n  u[m+n] = u_carry;\n\n  DEBUG_KNUTH(dbgs() << \"KnuthDiv:   normal:\");\n  DEBUG_KNUTH(for (int i = m + n; i >= 0; i--) dbgs() << \" \" << u[i]);\n  DEBUG_KNUTH(dbgs() << \" by\");\n  DEBUG_KNUTH(for (int i = n; i > 0; i--) dbgs() << \" \" << v[i - 1]);\n  DEBUG_KNUTH(dbgs() << '\\n');\n\n  // D2. [Initialize j.]  Set j to m. This is the loop counter over the places.\n  int j = m;\n  do {\n    DEBUG_KNUTH(dbgs() << \"KnuthDiv: quotient digit #\" << j << '\\n');\n    // D3. [Calculate q'.].\n    //     Set qp = (u[j+n]*b + u[j+n-1]) / v[n-1]. (qp=qprime=q')\n    //     Set rp = (u[j+n]*b + u[j+n-1]) % v[n-1]. (rp=rprime=r')\n    // Now test if qp == b or qp*v[n-2] > b*rp + u[j+n-2]; if so, decrease\n    // qp by 1, increase rp by v[n-1], and repeat this test if rp < b. The test\n    // on v[n-2] determines at high speed most of the cases in which the trial\n    // value qp is one too large, and it eliminates all cases where qp is two\n    // too large.\n    uint64_t dividend = Make_64(u[j+n], u[j+n-1]);\n    DEBUG_KNUTH(dbgs() << \"KnuthDiv: dividend == \" << dividend << '\\n');\n    uint64_t qp = dividend / v[n-1];\n    uint64_t rp = dividend % v[n-1];\n    if (qp == b || qp*v[n-2] > b*rp + u[j+n-2]) {\n      qp--;\n      rp += v[n-1];\n      if (rp < b && (qp == b || qp*v[n-2] > b*rp + u[j+n-2]))\n        qp--;\n    }\n    DEBUG_KNUTH(dbgs() << \"KnuthDiv: qp == \" << qp << \", rp == \" << rp << '\\n');\n\n    // D4. [Multiply and subtract.] Replace (u[j+n]u[j+n-1]...u[j]) with\n    // (u[j+n]u[j+n-1]..u[j]) - qp * (v[n-1]...v[1]v[0]). This computation\n    // consists of a simple multiplication by a one-place number, combined with\n    // a subtraction.\n    // The digits (u[j+n]...u[j]) should be kept positive; if the result of\n    // this step is actually negative, (u[j+n]...u[j]) should be left as the\n    // true value plus b**(n+1), namely as the b's complement of\n    // the true value, and a \"borrow\" to the left should be remembered.\n    int64_t borrow = 0;\n    for (unsigned i = 0; i < n; ++i) {\n      uint64_t p = uint64_t(qp) * uint64_t(v[i]);\n      int64_t subres = int64_t(u[j+i]) - borrow - Lo_32(p);\n      u[j+i] = Lo_32(subres);\n      borrow = Hi_32(p) - Hi_32(subres);\n      DEBUG_KNUTH(dbgs() << \"KnuthDiv: u[j+i] = \" << u[j + i]\n                        << \", borrow = \" << borrow << '\\n');\n    }\n    bool isNeg = u[j+n] < borrow;\n    u[j+n] -= Lo_32(borrow);\n\n    DEBUG_KNUTH(dbgs() << \"KnuthDiv: after subtraction:\");\n    DEBUG_KNUTH(for (int i = m + n; i >= 0; i--) dbgs() << \" \" << u[i]);\n    DEBUG_KNUTH(dbgs() << '\\n');\n\n    // D5. [Test remainder.] Set q[j] = qp. If the result of step D4 was\n    // negative, go to step D6; otherwise go on to step D7.\n    q[j] = Lo_32(qp);\n    if (isNeg) {\n      // D6. [Add back]. The probability that this step is necessary is very\n      // small, on the order of only 2/b. Make sure that test data accounts for\n      // this possibility. Decrease q[j] by 1\n      q[j]--;\n      // and add (0v[n-1]...v[1]v[0]) to (u[j+n]u[j+n-1]...u[j+1]u[j]).\n      // A carry will occur to the left of u[j+n], and it should be ignored\n      // since it cancels with the borrow that occurred in D4.\n      bool carry = false;\n      for (unsigned i = 0; i < n; i++) {\n        uint32_t limit = std::min(u[j+i],v[i]);\n        u[j+i] += v[i] + carry;\n        carry = u[j+i] < limit || (carry && u[j+i] == limit);\n      }\n      u[j+n] += carry;\n    }\n    DEBUG_KNUTH(dbgs() << \"KnuthDiv: after correction:\");\n    DEBUG_KNUTH(for (int i = m + n; i >= 0; i--) dbgs() << \" \" << u[i]);\n    DEBUG_KNUTH(dbgs() << \"\\nKnuthDiv: digit result = \" << q[j] << '\\n');\n\n    // D7. [Loop on j.]  Decrease j by one. Now if j >= 0, go back to D3.\n  } while (--j >= 0);\n\n  DEBUG_KNUTH(dbgs() << \"KnuthDiv: quotient:\");\n  DEBUG_KNUTH(for (int i = m; i >= 0; i--) dbgs() << \" \" << q[i]);\n  DEBUG_KNUTH(dbgs() << '\\n');\n\n  // D8. [Unnormalize]. Now q[...] is the desired quotient, and the desired\n  // remainder may be obtained by dividing u[...] by d. If r is non-null we\n  // compute the remainder (urem uses this).\n  if (r) {\n    // The value d is expressed by the \"shift\" value above since we avoided\n    // multiplication by d by using a shift left. So, all we have to do is\n    // shift right here.\n    if (shift) {\n      uint32_t carry = 0;\n      DEBUG_KNUTH(dbgs() << \"KnuthDiv: remainder:\");\n      for (int i = n-1; i >= 0; i--) {\n        r[i] = (u[i] >> shift) | carry;\n        carry = u[i] << (32 - shift);\n        DEBUG_KNUTH(dbgs() << \" \" << r[i]);\n      }\n    } else {\n      for (int i = n-1; i >= 0; i--) {\n        r[i] = u[i];\n        DEBUG_KNUTH(dbgs() << \" \" << r[i]);\n      }\n    }\n    DEBUG_KNUTH(dbgs() << '\\n');\n  }\n  DEBUG_KNUTH(dbgs() << '\\n');\n}\n\nvoid APInt::divide(const WordType *LHS, unsigned lhsWords, const WordType *RHS,\n                   unsigned rhsWords, WordType *Quotient, WordType *Remainder) {\n  assert(lhsWords >= rhsWords && \"Fractional result\");\n\n  // First, compose the values into an array of 32-bit words instead of\n  // 64-bit words. This is a necessity of both the \"short division\" algorithm\n  // and the Knuth \"classical algorithm\" which requires there to be native\n  // operations for +, -, and * on an m bit value with an m*2 bit result. We\n  // can't use 64-bit operands here because we don't have native results of\n  // 128-bits. Furthermore, casting the 64-bit values to 32-bit values won't\n  // work on large-endian machines.\n  unsigned n = rhsWords * 2;\n  unsigned m = (lhsWords * 2) - n;\n\n  // Allocate space for the temporary values we need either on the stack, if\n  // it will fit, or on the heap if it won't.\n  uint32_t SPACE[128];\n  uint32_t *U = nullptr;\n  uint32_t *V = nullptr;\n  uint32_t *Q = nullptr;\n  uint32_t *R = nullptr;\n  if ((Remainder?4:3)*n+2*m+1 <= 128) {\n    U = &SPACE[0];\n    V = &SPACE[m+n+1];\n    Q = &SPACE[(m+n+1) + n];\n    if (Remainder)\n      R = &SPACE[(m+n+1) + n + (m+n)];\n  } else {\n    U = new uint32_t[m + n + 1];\n    V = new uint32_t[n];\n    Q = new uint32_t[m+n];\n    if (Remainder)\n      R = new uint32_t[n];\n  }\n\n  // Initialize the dividend\n  memset(U, 0, (m+n+1)*sizeof(uint32_t));\n  for (unsigned i = 0; i < lhsWords; ++i) {\n    uint64_t tmp = LHS[i];\n    U[i * 2] = Lo_32(tmp);\n    U[i * 2 + 1] = Hi_32(tmp);\n  }\n  U[m+n] = 0; // this extra word is for \"spill\" in the Knuth algorithm.\n\n  // Initialize the divisor\n  memset(V, 0, (n)*sizeof(uint32_t));\n  for (unsigned i = 0; i < rhsWords; ++i) {\n    uint64_t tmp = RHS[i];\n    V[i * 2] = Lo_32(tmp);\n    V[i * 2 + 1] = Hi_32(tmp);\n  }\n\n  // initialize the quotient and remainder\n  memset(Q, 0, (m+n) * sizeof(uint32_t));\n  if (Remainder)\n    memset(R, 0, n * sizeof(uint32_t));\n\n  // Now, adjust m and n for the Knuth division. n is the number of words in\n  // the divisor. m is the number of words by which the dividend exceeds the\n  // divisor (i.e. m+n is the length of the dividend). These sizes must not\n  // contain any zero words or the Knuth algorithm fails.\n  for (unsigned i = n; i > 0 && V[i-1] == 0; i--) {\n    n--;\n    m++;\n  }\n  for (unsigned i = m+n; i > 0 && U[i-1] == 0; i--)\n    m--;\n\n  // If we're left with only a single word for the divisor, Knuth doesn't work\n  // so we implement the short division algorithm here. This is much simpler\n  // and faster because we are certain that we can divide a 64-bit quantity\n  // by a 32-bit quantity at hardware speed and short division is simply a\n  // series of such operations. This is just like doing short division but we\n  // are using base 2^32 instead of base 10.\n  assert(n != 0 && \"Divide by zero?\");\n  if (n == 1) {\n    uint32_t divisor = V[0];\n    uint32_t remainder = 0;\n    for (int i = m; i >= 0; i--) {\n      uint64_t partial_dividend = Make_64(remainder, U[i]);\n      if (partial_dividend == 0) {\n        Q[i] = 0;\n        remainder = 0;\n      } else if (partial_dividend < divisor) {\n        Q[i] = 0;\n        remainder = Lo_32(partial_dividend);\n      } else if (partial_dividend == divisor) {\n        Q[i] = 1;\n        remainder = 0;\n      } else {\n        Q[i] = Lo_32(partial_dividend / divisor);\n        remainder = Lo_32(partial_dividend - (Q[i] * divisor));\n      }\n    }\n    if (R)\n      R[0] = remainder;\n  } else {\n    // Now we're ready to invoke the Knuth classical divide algorithm. In this\n    // case n > 1.\n    KnuthDiv(U, V, Q, R, m, n);\n  }\n\n  // If the caller wants the quotient\n  if (Quotient) {\n    for (unsigned i = 0; i < lhsWords; ++i)\n      Quotient[i] = Make_64(Q[i*2+1], Q[i*2]);\n  }\n\n  // If the caller wants the remainder\n  if (Remainder) {\n    for (unsigned i = 0; i < rhsWords; ++i)\n      Remainder[i] = Make_64(R[i*2+1], R[i*2]);\n  }\n\n  // Clean up the memory we allocated.\n  if (U != &SPACE[0]) {\n    delete [] U;\n    delete [] V;\n    delete [] Q;\n    delete [] R;\n  }\n}\n\nAPInt APInt::udiv(const APInt &RHS) const {\n  assert(BitWidth == RHS.BitWidth && \"Bit widths must be the same\");\n\n  // First, deal with the easy case\n  if (isSingleWord()) {\n    assert(RHS.U.VAL != 0 && \"Divide by zero?\");\n    return APInt(BitWidth, U.VAL / RHS.U.VAL);\n  }\n\n  // Get some facts about the LHS and RHS number of bits and words\n  unsigned lhsWords = getNumWords(getActiveBits());\n  unsigned rhsBits  = RHS.getActiveBits();\n  unsigned rhsWords = getNumWords(rhsBits);\n  assert(rhsWords && \"Divided by zero???\");\n\n  // Deal with some degenerate cases\n  if (!lhsWords)\n    // 0 / X ===> 0\n    return APInt(BitWidth, 0);\n  if (rhsBits == 1)\n    // X / 1 ===> X\n    return *this;\n  if (lhsWords < rhsWords || this->ult(RHS))\n    // X / Y ===> 0, iff X < Y\n    return APInt(BitWidth, 0);\n  if (*this == RHS)\n    // X / X ===> 1\n    return APInt(BitWidth, 1);\n  if (lhsWords == 1) // rhsWords is 1 if lhsWords is 1.\n    // All high words are zero, just use native divide\n    return APInt(BitWidth, this->U.pVal[0] / RHS.U.pVal[0]);\n\n  // We have to compute it the hard way. Invoke the Knuth divide algorithm.\n  APInt Quotient(BitWidth, 0); // to hold result.\n  divide(U.pVal, lhsWords, RHS.U.pVal, rhsWords, Quotient.U.pVal, nullptr);\n  return Quotient;\n}\n\nAPInt APInt::udiv(uint64_t RHS) const {\n  assert(RHS != 0 && \"Divide by zero?\");\n\n  // First, deal with the easy case\n  if (isSingleWord())\n    return APInt(BitWidth, U.VAL / RHS);\n\n  // Get some facts about the LHS words.\n  unsigned lhsWords = getNumWords(getActiveBits());\n\n  // Deal with some degenerate cases\n  if (!lhsWords)\n    // 0 / X ===> 0\n    return APInt(BitWidth, 0);\n  if (RHS == 1)\n    // X / 1 ===> X\n    return *this;\n  if (this->ult(RHS))\n    // X / Y ===> 0, iff X < Y\n    return APInt(BitWidth, 0);\n  if (*this == RHS)\n    // X / X ===> 1\n    return APInt(BitWidth, 1);\n  if (lhsWords == 1) // rhsWords is 1 if lhsWords is 1.\n    // All high words are zero, just use native divide\n    return APInt(BitWidth, this->U.pVal[0] / RHS);\n\n  // We have to compute it the hard way. Invoke the Knuth divide algorithm.\n  APInt Quotient(BitWidth, 0); // to hold result.\n  divide(U.pVal, lhsWords, &RHS, 1, Quotient.U.pVal, nullptr);\n  return Quotient;\n}\n\nAPInt APInt::sdiv(const APInt &RHS) const {\n  if (isNegative()) {\n    if (RHS.isNegative())\n      return (-(*this)).udiv(-RHS);\n    return -((-(*this)).udiv(RHS));\n  }\n  if (RHS.isNegative())\n    return -(this->udiv(-RHS));\n  return this->udiv(RHS);\n}\n\nAPInt APInt::sdiv(int64_t RHS) const {\n  if (isNegative()) {\n    if (RHS < 0)\n      return (-(*this)).udiv(-RHS);\n    return -((-(*this)).udiv(RHS));\n  }\n  if (RHS < 0)\n    return -(this->udiv(-RHS));\n  return this->udiv(RHS);\n}\n\nAPInt APInt::urem(const APInt &RHS) const {\n  assert(BitWidth == RHS.BitWidth && \"Bit widths must be the same\");\n  if (isSingleWord()) {\n    assert(RHS.U.VAL != 0 && \"Remainder by zero?\");\n    return APInt(BitWidth, U.VAL % RHS.U.VAL);\n  }\n\n  // Get some facts about the LHS\n  unsigned lhsWords = getNumWords(getActiveBits());\n\n  // Get some facts about the RHS\n  unsigned rhsBits = RHS.getActiveBits();\n  unsigned rhsWords = getNumWords(rhsBits);\n  assert(rhsWords && \"Performing remainder operation by zero ???\");\n\n  // Check the degenerate cases\n  if (lhsWords == 0)\n    // 0 % Y ===> 0\n    return APInt(BitWidth, 0);\n  if (rhsBits == 1)\n    // X % 1 ===> 0\n    return APInt(BitWidth, 0);\n  if (lhsWords < rhsWords || this->ult(RHS))\n    // X % Y ===> X, iff X < Y\n    return *this;\n  if (*this == RHS)\n    // X % X == 0;\n    return APInt(BitWidth, 0);\n  if (lhsWords == 1)\n    // All high words are zero, just use native remainder\n    return APInt(BitWidth, U.pVal[0] % RHS.U.pVal[0]);\n\n  // We have to compute it the hard way. Invoke the Knuth divide algorithm.\n  APInt Remainder(BitWidth, 0);\n  divide(U.pVal, lhsWords, RHS.U.pVal, rhsWords, nullptr, Remainder.U.pVal);\n  return Remainder;\n}\n\nuint64_t APInt::urem(uint64_t RHS) const {\n  assert(RHS != 0 && \"Remainder by zero?\");\n\n  if (isSingleWord())\n    return U.VAL % RHS;\n\n  // Get some facts about the LHS\n  unsigned lhsWords = getNumWords(getActiveBits());\n\n  // Check the degenerate cases\n  if (lhsWords == 0)\n    // 0 % Y ===> 0\n    return 0;\n  if (RHS == 1)\n    // X % 1 ===> 0\n    return 0;\n  if (this->ult(RHS))\n    // X % Y ===> X, iff X < Y\n    return getZExtValue();\n  if (*this == RHS)\n    // X % X == 0;\n    return 0;\n  if (lhsWords == 1)\n    // All high words are zero, just use native remainder\n    return U.pVal[0] % RHS;\n\n  // We have to compute it the hard way. Invoke the Knuth divide algorithm.\n  uint64_t Remainder;\n  divide(U.pVal, lhsWords, &RHS, 1, nullptr, &Remainder);\n  return Remainder;\n}\n\nAPInt APInt::srem(const APInt &RHS) const {\n  if (isNegative()) {\n    if (RHS.isNegative())\n      return -((-(*this)).urem(-RHS));\n    return -((-(*this)).urem(RHS));\n  }\n  if (RHS.isNegative())\n    return this->urem(-RHS);\n  return this->urem(RHS);\n}\n\nint64_t APInt::srem(int64_t RHS) const {\n  if (isNegative()) {\n    if (RHS < 0)\n      return -((-(*this)).urem(-RHS));\n    return -((-(*this)).urem(RHS));\n  }\n  if (RHS < 0)\n    return this->urem(-RHS);\n  return this->urem(RHS);\n}\n\nvoid APInt::udivrem(const APInt &LHS, const APInt &RHS,\n                    APInt &Quotient, APInt &Remainder) {\n  assert(LHS.BitWidth == RHS.BitWidth && \"Bit widths must be the same\");\n  unsigned BitWidth = LHS.BitWidth;\n\n  // First, deal with the easy case\n  if (LHS.isSingleWord()) {\n    assert(RHS.U.VAL != 0 && \"Divide by zero?\");\n    uint64_t QuotVal = LHS.U.VAL / RHS.U.VAL;\n    uint64_t RemVal = LHS.U.VAL % RHS.U.VAL;\n    Quotient = APInt(BitWidth, QuotVal);\n    Remainder = APInt(BitWidth, RemVal);\n    return;\n  }\n\n  // Get some size facts about the dividend and divisor\n  unsigned lhsWords = getNumWords(LHS.getActiveBits());\n  unsigned rhsBits  = RHS.getActiveBits();\n  unsigned rhsWords = getNumWords(rhsBits);\n  assert(rhsWords && \"Performing divrem operation by zero ???\");\n\n  // Check the degenerate cases\n  if (lhsWords == 0) {\n    Quotient = APInt(BitWidth, 0);    // 0 / Y ===> 0\n    Remainder = APInt(BitWidth, 0);   // 0 % Y ===> 0\n    return;\n  }\n\n  if (rhsBits == 1) {\n    Quotient = LHS;                   // X / 1 ===> X\n    Remainder = APInt(BitWidth, 0);   // X % 1 ===> 0\n  }\n\n  if (lhsWords < rhsWords || LHS.ult(RHS)) {\n    Remainder = LHS;                  // X % Y ===> X, iff X < Y\n    Quotient = APInt(BitWidth, 0);    // X / Y ===> 0, iff X < Y\n    return;\n  }\n\n  if (LHS == RHS) {\n    Quotient  = APInt(BitWidth, 1);   // X / X ===> 1\n    Remainder = APInt(BitWidth, 0);   // X % X ===> 0;\n    return;\n  }\n\n  // Make sure there is enough space to hold the results.\n  // NOTE: This assumes that reallocate won't affect any bits if it doesn't\n  // change the size. This is necessary if Quotient or Remainder is aliased\n  // with LHS or RHS.\n  Quotient.reallocate(BitWidth);\n  Remainder.reallocate(BitWidth);\n\n  if (lhsWords == 1) { // rhsWords is 1 if lhsWords is 1.\n    // There is only one word to consider so use the native versions.\n    uint64_t lhsValue = LHS.U.pVal[0];\n    uint64_t rhsValue = RHS.U.pVal[0];\n    Quotient = lhsValue / rhsValue;\n    Remainder = lhsValue % rhsValue;\n    return;\n  }\n\n  // Okay, lets do it the long way\n  divide(LHS.U.pVal, lhsWords, RHS.U.pVal, rhsWords, Quotient.U.pVal,\n         Remainder.U.pVal);\n  // Clear the rest of the Quotient and Remainder.\n  std::memset(Quotient.U.pVal + lhsWords, 0,\n              (getNumWords(BitWidth) - lhsWords) * APINT_WORD_SIZE);\n  std::memset(Remainder.U.pVal + rhsWords, 0,\n              (getNumWords(BitWidth) - rhsWords) * APINT_WORD_SIZE);\n}\n\nvoid APInt::udivrem(const APInt &LHS, uint64_t RHS, APInt &Quotient,\n                    uint64_t &Remainder) {\n  assert(RHS != 0 && \"Divide by zero?\");\n  unsigned BitWidth = LHS.BitWidth;\n\n  // First, deal with the easy case\n  if (LHS.isSingleWord()) {\n    uint64_t QuotVal = LHS.U.VAL / RHS;\n    Remainder = LHS.U.VAL % RHS;\n    Quotient = APInt(BitWidth, QuotVal);\n    return;\n  }\n\n  // Get some size facts about the dividend and divisor\n  unsigned lhsWords = getNumWords(LHS.getActiveBits());\n\n  // Check the degenerate cases\n  if (lhsWords == 0) {\n    Quotient = APInt(BitWidth, 0);    // 0 / Y ===> 0\n    Remainder = 0;                    // 0 % Y ===> 0\n    return;\n  }\n\n  if (RHS == 1) {\n    Quotient = LHS;                   // X / 1 ===> X\n    Remainder = 0;                    // X % 1 ===> 0\n    return;\n  }\n\n  if (LHS.ult(RHS)) {\n    Remainder = LHS.getZExtValue();   // X % Y ===> X, iff X < Y\n    Quotient = APInt(BitWidth, 0);    // X / Y ===> 0, iff X < Y\n    return;\n  }\n\n  if (LHS == RHS) {\n    Quotient  = APInt(BitWidth, 1);   // X / X ===> 1\n    Remainder = 0;                    // X % X ===> 0;\n    return;\n  }\n\n  // Make sure there is enough space to hold the results.\n  // NOTE: This assumes that reallocate won't affect any bits if it doesn't\n  // change the size. This is necessary if Quotient is aliased with LHS.\n  Quotient.reallocate(BitWidth);\n\n  if (lhsWords == 1) { // rhsWords is 1 if lhsWords is 1.\n    // There is only one word to consider so use the native versions.\n    uint64_t lhsValue = LHS.U.pVal[0];\n    Quotient = lhsValue / RHS;\n    Remainder = lhsValue % RHS;\n    return;\n  }\n\n  // Okay, lets do it the long way\n  divide(LHS.U.pVal, lhsWords, &RHS, 1, Quotient.U.pVal, &Remainder);\n  // Clear the rest of the Quotient.\n  std::memset(Quotient.U.pVal + lhsWords, 0,\n              (getNumWords(BitWidth) - lhsWords) * APINT_WORD_SIZE);\n}\n\nvoid APInt::sdivrem(const APInt &LHS, const APInt &RHS,\n                    APInt &Quotient, APInt &Remainder) {\n  if (LHS.isNegative()) {\n    if (RHS.isNegative())\n      APInt::udivrem(-LHS, -RHS, Quotient, Remainder);\n    else {\n      APInt::udivrem(-LHS, RHS, Quotient, Remainder);\n      Quotient.negate();\n    }\n    Remainder.negate();\n  } else if (RHS.isNegative()) {\n    APInt::udivrem(LHS, -RHS, Quotient, Remainder);\n    Quotient.negate();\n  } else {\n    APInt::udivrem(LHS, RHS, Quotient, Remainder);\n  }\n}\n\nvoid APInt::sdivrem(const APInt &LHS, int64_t RHS,\n                    APInt &Quotient, int64_t &Remainder) {\n  uint64_t R = Remainder;\n  if (LHS.isNegative()) {\n    if (RHS < 0)\n      APInt::udivrem(-LHS, -RHS, Quotient, R);\n    else {\n      APInt::udivrem(-LHS, RHS, Quotient, R);\n      Quotient.negate();\n    }\n    R = -R;\n  } else if (RHS < 0) {\n    APInt::udivrem(LHS, -RHS, Quotient, R);\n    Quotient.negate();\n  } else {\n    APInt::udivrem(LHS, RHS, Quotient, R);\n  }\n  Remainder = R;\n}\n\nAPInt APInt::sadd_ov(const APInt &RHS, bool &Overflow) const {\n  APInt Res = *this+RHS;\n  Overflow = isNonNegative() == RHS.isNonNegative() &&\n             Res.isNonNegative() != isNonNegative();\n  return Res;\n}\n\nAPInt APInt::uadd_ov(const APInt &RHS, bool &Overflow) const {\n  APInt Res = *this+RHS;\n  Overflow = Res.ult(RHS);\n  return Res;\n}\n\nAPInt APInt::ssub_ov(const APInt &RHS, bool &Overflow) const {\n  APInt Res = *this - RHS;\n  Overflow = isNonNegative() != RHS.isNonNegative() &&\n             Res.isNonNegative() != isNonNegative();\n  return Res;\n}\n\nAPInt APInt::usub_ov(const APInt &RHS, bool &Overflow) const {\n  APInt Res = *this-RHS;\n  Overflow = Res.ugt(*this);\n  return Res;\n}\n\nAPInt APInt::sdiv_ov(const APInt &RHS, bool &Overflow) const {\n  // MININT/-1  -->  overflow.\n  Overflow = isMinSignedValue() && RHS.isAllOnesValue();\n  return sdiv(RHS);\n}\n\nAPInt APInt::smul_ov(const APInt &RHS, bool &Overflow) const {\n  APInt Res = *this * RHS;\n\n  if (*this != 0 && RHS != 0)\n    Overflow = Res.sdiv(RHS) != *this || Res.sdiv(*this) != RHS;\n  else\n    Overflow = false;\n  return Res;\n}\n\nAPInt APInt::umul_ov(const APInt &RHS, bool &Overflow) const {\n  if (countLeadingZeros() + RHS.countLeadingZeros() + 2 <= BitWidth) {\n    Overflow = true;\n    return *this * RHS;\n  }\n\n  APInt Res = lshr(1) * RHS;\n  Overflow = Res.isNegative();\n  Res <<= 1;\n  if ((*this)[0]) {\n    Res += RHS;\n    if (Res.ult(RHS))\n      Overflow = true;\n  }\n  return Res;\n}\n\nAPInt APInt::sshl_ov(const APInt &ShAmt, bool &Overflow) const {\n  Overflow = ShAmt.uge(getBitWidth());\n  if (Overflow)\n    return APInt(BitWidth, 0);\n\n  if (isNonNegative()) // Don't allow sign change.\n    Overflow = ShAmt.uge(countLeadingZeros());\n  else\n    Overflow = ShAmt.uge(countLeadingOnes());\n\n  return *this << ShAmt;\n}\n\nAPInt APInt::ushl_ov(const APInt &ShAmt, bool &Overflow) const {\n  Overflow = ShAmt.uge(getBitWidth());\n  if (Overflow)\n    return APInt(BitWidth, 0);\n\n  Overflow = ShAmt.ugt(countLeadingZeros());\n\n  return *this << ShAmt;\n}\n\nAPInt APInt::sadd_sat(const APInt &RHS) const {\n  bool Overflow;\n  APInt Res = sadd_ov(RHS, Overflow);\n  if (!Overflow)\n    return Res;\n\n  return isNegative() ? APInt::getSignedMinValue(BitWidth)\n                      : APInt::getSignedMaxValue(BitWidth);\n}\n\nAPInt APInt::uadd_sat(const APInt &RHS) const {\n  bool Overflow;\n  APInt Res = uadd_ov(RHS, Overflow);\n  if (!Overflow)\n    return Res;\n\n  return APInt::getMaxValue(BitWidth);\n}\n\nAPInt APInt::ssub_sat(const APInt &RHS) const {\n  bool Overflow;\n  APInt Res = ssub_ov(RHS, Overflow);\n  if (!Overflow)\n    return Res;\n\n  return isNegative() ? APInt::getSignedMinValue(BitWidth)\n                      : APInt::getSignedMaxValue(BitWidth);\n}\n\nAPInt APInt::usub_sat(const APInt &RHS) const {\n  bool Overflow;\n  APInt Res = usub_ov(RHS, Overflow);\n  if (!Overflow)\n    return Res;\n\n  return APInt(BitWidth, 0);\n}\n\nAPInt APInt::smul_sat(const APInt &RHS) const {\n  bool Overflow;\n  APInt Res = smul_ov(RHS, Overflow);\n  if (!Overflow)\n    return Res;\n\n  // The result is negative if one and only one of inputs is negative.\n  bool ResIsNegative = isNegative() ^ RHS.isNegative();\n\n  return ResIsNegative ? APInt::getSignedMinValue(BitWidth)\n                       : APInt::getSignedMaxValue(BitWidth);\n}\n\nAPInt APInt::umul_sat(const APInt &RHS) const {\n  bool Overflow;\n  APInt Res = umul_ov(RHS, Overflow);\n  if (!Overflow)\n    return Res;\n\n  return APInt::getMaxValue(BitWidth);\n}\n\nAPInt APInt::sshl_sat(const APInt &RHS) const {\n  bool Overflow;\n  APInt Res = sshl_ov(RHS, Overflow);\n  if (!Overflow)\n    return Res;\n\n  return isNegative() ? APInt::getSignedMinValue(BitWidth)\n                      : APInt::getSignedMaxValue(BitWidth);\n}\n\nAPInt APInt::ushl_sat(const APInt &RHS) const {\n  bool Overflow;\n  APInt Res = ushl_ov(RHS, Overflow);\n  if (!Overflow)\n    return Res;\n\n  return APInt::getMaxValue(BitWidth);\n}\n\nvoid APInt::fromString(unsigned numbits, StringRef str, uint8_t radix) {\n  // Check our assumptions here\n  assert(!str.empty() && \"Invalid string length\");\n  assert((radix == 10 || radix == 8 || radix == 16 || radix == 2 ||\n          radix == 36) &&\n         \"Radix should be 2, 8, 10, 16, or 36!\");\n\n  StringRef::iterator p = str.begin();\n  size_t slen = str.size();\n  bool isNeg = *p == '-';\n  if (*p == '-' || *p == '+') {\n    p++;\n    slen--;\n    assert(slen && \"String is only a sign, needs a value.\");\n  }\n  assert((slen <= numbits || radix != 2) && \"Insufficient bit width\");\n  assert(((slen-1)*3 <= numbits || radix != 8) && \"Insufficient bit width\");\n  assert(((slen-1)*4 <= numbits || radix != 16) && \"Insufficient bit width\");\n  assert((((slen-1)*64)/22 <= numbits || radix != 10) &&\n         \"Insufficient bit width\");\n\n  // Allocate memory if needed\n  if (isSingleWord())\n    U.VAL = 0;\n  else\n    U.pVal = getClearedMemory(getNumWords());\n\n  // Figure out if we can shift instead of multiply\n  unsigned shift = (radix == 16 ? 4 : radix == 8 ? 3 : radix == 2 ? 1 : 0);\n\n  // Enter digit traversal loop\n  for (StringRef::iterator e = str.end(); p != e; ++p) {\n    unsigned digit = getDigit(*p, radix);\n    assert(digit < radix && \"Invalid character in digit string\");\n\n    // Shift or multiply the value by the radix\n    if (slen > 1) {\n      if (shift)\n        *this <<= shift;\n      else\n        *this *= radix;\n    }\n\n    // Add in the digit we just interpreted\n    *this += digit;\n  }\n  // If its negative, put it in two's complement form\n  if (isNeg)\n    this->negate();\n}\n\nvoid APInt::toString(SmallVectorImpl<char> &Str, unsigned Radix,\n                     bool Signed, bool formatAsCLiteral) const {\n  assert((Radix == 10 || Radix == 8 || Radix == 16 || Radix == 2 ||\n          Radix == 36) &&\n         \"Radix should be 2, 8, 10, 16, or 36!\");\n\n  const char *Prefix = \"\";\n  if (formatAsCLiteral) {\n    switch (Radix) {\n      case 2:\n        // Binary literals are a non-standard extension added in gcc 4.3:\n        // http://gcc.gnu.org/onlinedocs/gcc-4.3.0/gcc/Binary-constants.html\n        Prefix = \"0b\";\n        break;\n      case 8:\n        Prefix = \"0\";\n        break;\n      case 10:\n        break; // No prefix\n      case 16:\n        Prefix = \"0x\";\n        break;\n      default:\n        llvm_unreachable(\"Invalid radix!\");\n    }\n  }\n\n  // First, check for a zero value and just short circuit the logic below.\n  if (*this == 0) {\n    while (*Prefix) {\n      Str.push_back(*Prefix);\n      ++Prefix;\n    };\n    Str.push_back('0');\n    return;\n  }\n\n  static const char Digits[] = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\n  if (isSingleWord()) {\n    char Buffer[65];\n    char *BufPtr = std::end(Buffer);\n\n    uint64_t N;\n    if (!Signed) {\n      N = getZExtValue();\n    } else {\n      int64_t I = getSExtValue();\n      if (I >= 0) {\n        N = I;\n      } else {\n        Str.push_back('-');\n        N = -(uint64_t)I;\n      }\n    }\n\n    while (*Prefix) {\n      Str.push_back(*Prefix);\n      ++Prefix;\n    };\n\n    while (N) {\n      *--BufPtr = Digits[N % Radix];\n      N /= Radix;\n    }\n    Str.append(BufPtr, std::end(Buffer));\n    return;\n  }\n\n  APInt Tmp(*this);\n\n  if (Signed && isNegative()) {\n    // They want to print the signed version and it is a negative value\n    // Flip the bits and add one to turn it into the equivalent positive\n    // value and put a '-' in the result.\n    Tmp.negate();\n    Str.push_back('-');\n  }\n\n  while (*Prefix) {\n    Str.push_back(*Prefix);\n    ++Prefix;\n  };\n\n  // We insert the digits backward, then reverse them to get the right order.\n  unsigned StartDig = Str.size();\n\n  // For the 2, 8 and 16 bit cases, we can just shift instead of divide\n  // because the number of bits per digit (1, 3 and 4 respectively) divides\n  // equally.  We just shift until the value is zero.\n  if (Radix == 2 || Radix == 8 || Radix == 16) {\n    // Just shift tmp right for each digit width until it becomes zero\n    unsigned ShiftAmt = (Radix == 16 ? 4 : (Radix == 8 ? 3 : 1));\n    unsigned MaskAmt = Radix - 1;\n\n    while (Tmp.getBoolValue()) {\n      unsigned Digit = unsigned(Tmp.getRawData()[0]) & MaskAmt;\n      Str.push_back(Digits[Digit]);\n      Tmp.lshrInPlace(ShiftAmt);\n    }\n  } else {\n    while (Tmp.getBoolValue()) {\n      uint64_t Digit;\n      udivrem(Tmp, Radix, Tmp, Digit);\n      assert(Digit < Radix && \"divide failed\");\n      Str.push_back(Digits[Digit]);\n    }\n  }\n\n  // Reverse the digits before returning.\n  std::reverse(Str.begin()+StartDig, Str.end());\n}\n\n/// Returns the APInt as a std::string. Note that this is an inefficient method.\n/// It is better to pass in a SmallVector/SmallString to the methods above.\nstd::string APInt::toString(unsigned Radix = 10, bool Signed = true) const {\n  SmallString<40> S;\n  toString(S, Radix, Signed, /* formatAsCLiteral = */false);\n  return std::string(S.str());\n}\n\n#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)\nLLVM_DUMP_METHOD void APInt::dump() const {\n  SmallString<40> S, U;\n  this->toStringUnsigned(U);\n  this->toStringSigned(S);\n  dbgs() << \"APInt(\" << BitWidth << \"b, \"\n         << U << \"u \" << S << \"s)\\n\";\n}\n#endif\n\nvoid APInt::print(raw_ostream &OS, bool isSigned) const {\n  SmallString<40> S;\n  this->toString(S, 10, isSigned, /* formatAsCLiteral = */false);\n  OS << S;\n}\n\n// This implements a variety of operations on a representation of\n// arbitrary precision, two's-complement, bignum integer values.\n\n// Assumed by lowHalf, highHalf, partMSB and partLSB.  A fairly safe\n// and unrestricting assumption.\nstatic_assert(APInt::APINT_BITS_PER_WORD % 2 == 0,\n              \"Part width must be divisible by 2!\");\n\n/* Some handy functions local to this file.  */\n\n/* Returns the integer part with the least significant BITS set.\n   BITS cannot be zero.  */\nstatic inline APInt::WordType lowBitMask(unsigned bits) {\n  assert(bits != 0 && bits <= APInt::APINT_BITS_PER_WORD);\n\n  return ~(APInt::WordType) 0 >> (APInt::APINT_BITS_PER_WORD - bits);\n}\n\n/* Returns the value of the lower half of PART.  */\nstatic inline APInt::WordType lowHalf(APInt::WordType part) {\n  return part & lowBitMask(APInt::APINT_BITS_PER_WORD / 2);\n}\n\n/* Returns the value of the upper half of PART.  */\nstatic inline APInt::WordType highHalf(APInt::WordType part) {\n  return part >> (APInt::APINT_BITS_PER_WORD / 2);\n}\n\n/* Returns the bit number of the most significant set bit of a part.\n   If the input number has no bits set -1U is returned.  */\nstatic unsigned partMSB(APInt::WordType value) {\n  return findLastSet(value, ZB_Max);\n}\n\n/* Returns the bit number of the least significant set bit of a\n   part.  If the input number has no bits set -1U is returned.  */\nstatic unsigned partLSB(APInt::WordType value) {\n  return findFirstSet(value, ZB_Max);\n}\n\n/* Sets the least significant part of a bignum to the input value, and\n   zeroes out higher parts.  */\nvoid APInt::tcSet(WordType *dst, WordType part, unsigned parts) {\n  assert(parts > 0);\n\n  dst[0] = part;\n  for (unsigned i = 1; i < parts; i++)\n    dst[i] = 0;\n}\n\n/* Assign one bignum to another.  */\nvoid APInt::tcAssign(WordType *dst, const WordType *src, unsigned parts) {\n  for (unsigned i = 0; i < parts; i++)\n    dst[i] = src[i];\n}\n\n/* Returns true if a bignum is zero, false otherwise.  */\nbool APInt::tcIsZero(const WordType *src, unsigned parts) {\n  for (unsigned i = 0; i < parts; i++)\n    if (src[i])\n      return false;\n\n  return true;\n}\n\n/* Extract the given bit of a bignum; returns 0 or 1.  */\nint APInt::tcExtractBit(const WordType *parts, unsigned bit) {\n  return (parts[whichWord(bit)] & maskBit(bit)) != 0;\n}\n\n/* Set the given bit of a bignum. */\nvoid APInt::tcSetBit(WordType *parts, unsigned bit) {\n  parts[whichWord(bit)] |= maskBit(bit);\n}\n\n/* Clears the given bit of a bignum. */\nvoid APInt::tcClearBit(WordType *parts, unsigned bit) {\n  parts[whichWord(bit)] &= ~maskBit(bit);\n}\n\n/* Returns the bit number of the least significant set bit of a\n   number.  If the input number has no bits set -1U is returned.  */\nunsigned APInt::tcLSB(const WordType *parts, unsigned n) {\n  for (unsigned i = 0; i < n; i++) {\n    if (parts[i] != 0) {\n      unsigned lsb = partLSB(parts[i]);\n\n      return lsb + i * APINT_BITS_PER_WORD;\n    }\n  }\n\n  return -1U;\n}\n\n/* Returns the bit number of the most significant set bit of a number.\n   If the input number has no bits set -1U is returned.  */\nunsigned APInt::tcMSB(const WordType *parts, unsigned n) {\n  do {\n    --n;\n\n    if (parts[n] != 0) {\n      unsigned msb = partMSB(parts[n]);\n\n      return msb + n * APINT_BITS_PER_WORD;\n    }\n  } while (n);\n\n  return -1U;\n}\n\n/* Copy the bit vector of width srcBITS from SRC, starting at bit\n   srcLSB, to DST, of dstCOUNT parts, such that the bit srcLSB becomes\n   the least significant bit of DST.  All high bits above srcBITS in\n   DST are zero-filled.  */\nvoid\nAPInt::tcExtract(WordType *dst, unsigned dstCount, const WordType *src,\n                 unsigned srcBits, unsigned srcLSB) {\n  unsigned dstParts = (srcBits + APINT_BITS_PER_WORD - 1) / APINT_BITS_PER_WORD;\n  assert(dstParts <= dstCount);\n\n  unsigned firstSrcPart = srcLSB / APINT_BITS_PER_WORD;\n  tcAssign (dst, src + firstSrcPart, dstParts);\n\n  unsigned shift = srcLSB % APINT_BITS_PER_WORD;\n  tcShiftRight (dst, dstParts, shift);\n\n  /* We now have (dstParts * APINT_BITS_PER_WORD - shift) bits from SRC\n     in DST.  If this is less that srcBits, append the rest, else\n     clear the high bits.  */\n  unsigned n = dstParts * APINT_BITS_PER_WORD - shift;\n  if (n < srcBits) {\n    WordType mask = lowBitMask (srcBits - n);\n    dst[dstParts - 1] |= ((src[firstSrcPart + dstParts] & mask)\n                          << n % APINT_BITS_PER_WORD);\n  } else if (n > srcBits) {\n    if (srcBits % APINT_BITS_PER_WORD)\n      dst[dstParts - 1] &= lowBitMask (srcBits % APINT_BITS_PER_WORD);\n  }\n\n  /* Clear high parts.  */\n  while (dstParts < dstCount)\n    dst[dstParts++] = 0;\n}\n\n/* DST += RHS + C where C is zero or one.  Returns the carry flag.  */\nAPInt::WordType APInt::tcAdd(WordType *dst, const WordType *rhs,\n                             WordType c, unsigned parts) {\n  assert(c <= 1);\n\n  for (unsigned i = 0; i < parts; i++) {\n    WordType l = dst[i];\n    if (c) {\n      dst[i] += rhs[i] + 1;\n      c = (dst[i] <= l);\n    } else {\n      dst[i] += rhs[i];\n      c = (dst[i] < l);\n    }\n  }\n\n  return c;\n}\n\n/// This function adds a single \"word\" integer, src, to the multiple\n/// \"word\" integer array, dst[]. dst[] is modified to reflect the addition and\n/// 1 is returned if there is a carry out, otherwise 0 is returned.\n/// @returns the carry of the addition.\nAPInt::WordType APInt::tcAddPart(WordType *dst, WordType src,\n                                 unsigned parts) {\n  for (unsigned i = 0; i < parts; ++i) {\n    dst[i] += src;\n    if (dst[i] >= src)\n      return 0; // No need to carry so exit early.\n    src = 1; // Carry one to next digit.\n  }\n\n  return 1;\n}\n\n/* DST -= RHS + C where C is zero or one.  Returns the carry flag.  */\nAPInt::WordType APInt::tcSubtract(WordType *dst, const WordType *rhs,\n                                  WordType c, unsigned parts) {\n  assert(c <= 1);\n\n  for (unsigned i = 0; i < parts; i++) {\n    WordType l = dst[i];\n    if (c) {\n      dst[i] -= rhs[i] + 1;\n      c = (dst[i] >= l);\n    } else {\n      dst[i] -= rhs[i];\n      c = (dst[i] > l);\n    }\n  }\n\n  return c;\n}\n\n/// This function subtracts a single \"word\" (64-bit word), src, from\n/// the multi-word integer array, dst[], propagating the borrowed 1 value until\n/// no further borrowing is needed or it runs out of \"words\" in dst.  The result\n/// is 1 if \"borrowing\" exhausted the digits in dst, or 0 if dst was not\n/// exhausted. In other words, if src > dst then this function returns 1,\n/// otherwise 0.\n/// @returns the borrow out of the subtraction\nAPInt::WordType APInt::tcSubtractPart(WordType *dst, WordType src,\n                                      unsigned parts) {\n  for (unsigned i = 0; i < parts; ++i) {\n    WordType Dst = dst[i];\n    dst[i] -= src;\n    if (src <= Dst)\n      return 0; // No need to borrow so exit early.\n    src = 1; // We have to \"borrow 1\" from next \"word\"\n  }\n\n  return 1;\n}\n\n/* Negate a bignum in-place.  */\nvoid APInt::tcNegate(WordType *dst, unsigned parts) {\n  tcComplement(dst, parts);\n  tcIncrement(dst, parts);\n}\n\n/*  DST += SRC * MULTIPLIER + CARRY   if add is true\n    DST  = SRC * MULTIPLIER + CARRY   if add is false\n\n    Requires 0 <= DSTPARTS <= SRCPARTS + 1.  If DST overlaps SRC\n    they must start at the same point, i.e. DST == SRC.\n\n    If DSTPARTS == SRCPARTS + 1 no overflow occurs and zero is\n    returned.  Otherwise DST is filled with the least significant\n    DSTPARTS parts of the result, and if all of the omitted higher\n    parts were zero return zero, otherwise overflow occurred and\n    return one.  */\nint APInt::tcMultiplyPart(WordType *dst, const WordType *src,\n                          WordType multiplier, WordType carry,\n                          unsigned srcParts, unsigned dstParts,\n                          bool add) {\n  /* Otherwise our writes of DST kill our later reads of SRC.  */\n  assert(dst <= src || dst >= src + srcParts);\n  assert(dstParts <= srcParts + 1);\n\n  /* N loops; minimum of dstParts and srcParts.  */\n  unsigned n = std::min(dstParts, srcParts);\n\n  for (unsigned i = 0; i < n; i++) {\n    WordType low, mid, high, srcPart;\n\n      /* [ LOW, HIGH ] = MULTIPLIER * SRC[i] + DST[i] + CARRY.\n\n         This cannot overflow, because\n\n         (n - 1) * (n - 1) + 2 (n - 1) = (n - 1) * (n + 1)\n\n         which is less than n^2.  */\n\n    srcPart = src[i];\n\n    if (multiplier == 0 || srcPart == 0) {\n      low = carry;\n      high = 0;\n    } else {\n      low = lowHalf(srcPart) * lowHalf(multiplier);\n      high = highHalf(srcPart) * highHalf(multiplier);\n\n      mid = lowHalf(srcPart) * highHalf(multiplier);\n      high += highHalf(mid);\n      mid <<= APINT_BITS_PER_WORD / 2;\n      if (low + mid < low)\n        high++;\n      low += mid;\n\n      mid = highHalf(srcPart) * lowHalf(multiplier);\n      high += highHalf(mid);\n      mid <<= APINT_BITS_PER_WORD / 2;\n      if (low + mid < low)\n        high++;\n      low += mid;\n\n      /* Now add carry.  */\n      if (low + carry < low)\n        high++;\n      low += carry;\n    }\n\n    if (add) {\n      /* And now DST[i], and store the new low part there.  */\n      if (low + dst[i] < low)\n        high++;\n      dst[i] += low;\n    } else\n      dst[i] = low;\n\n    carry = high;\n  }\n\n  if (srcParts < dstParts) {\n    /* Full multiplication, there is no overflow.  */\n    assert(srcParts + 1 == dstParts);\n    dst[srcParts] = carry;\n    return 0;\n  }\n\n  /* We overflowed if there is carry.  */\n  if (carry)\n    return 1;\n\n  /* We would overflow if any significant unwritten parts would be\n     non-zero.  This is true if any remaining src parts are non-zero\n     and the multiplier is non-zero.  */\n  if (multiplier)\n    for (unsigned i = dstParts; i < srcParts; i++)\n      if (src[i])\n        return 1;\n\n  /* We fitted in the narrow destination.  */\n  return 0;\n}\n\n/* DST = LHS * RHS, where DST has the same width as the operands and\n   is filled with the least significant parts of the result.  Returns\n   one if overflow occurred, otherwise zero.  DST must be disjoint\n   from both operands.  */\nint APInt::tcMultiply(WordType *dst, const WordType *lhs,\n                      const WordType *rhs, unsigned parts) {\n  assert(dst != lhs && dst != rhs);\n\n  int overflow = 0;\n  tcSet(dst, 0, parts);\n\n  for (unsigned i = 0; i < parts; i++)\n    overflow |= tcMultiplyPart(&dst[i], lhs, rhs[i], 0, parts,\n                               parts - i, true);\n\n  return overflow;\n}\n\n/// DST = LHS * RHS, where DST has width the sum of the widths of the\n/// operands. No overflow occurs. DST must be disjoint from both operands.\nvoid APInt::tcFullMultiply(WordType *dst, const WordType *lhs,\n                           const WordType *rhs, unsigned lhsParts,\n                           unsigned rhsParts) {\n  /* Put the narrower number on the LHS for less loops below.  */\n  if (lhsParts > rhsParts)\n    return tcFullMultiply (dst, rhs, lhs, rhsParts, lhsParts);\n\n  assert(dst != lhs && dst != rhs);\n\n  tcSet(dst, 0, rhsParts);\n\n  for (unsigned i = 0; i < lhsParts; i++)\n    tcMultiplyPart(&dst[i], rhs, lhs[i], 0, rhsParts, rhsParts + 1, true);\n}\n\n/* If RHS is zero LHS and REMAINDER are left unchanged, return one.\n   Otherwise set LHS to LHS / RHS with the fractional part discarded,\n   set REMAINDER to the remainder, return zero.  i.e.\n\n   OLD_LHS = RHS * LHS + REMAINDER\n\n   SCRATCH is a bignum of the same size as the operands and result for\n   use by the routine; its contents need not be initialized and are\n   destroyed.  LHS, REMAINDER and SCRATCH must be distinct.\n*/\nint APInt::tcDivide(WordType *lhs, const WordType *rhs,\n                    WordType *remainder, WordType *srhs,\n                    unsigned parts) {\n  assert(lhs != remainder && lhs != srhs && remainder != srhs);\n\n  unsigned shiftCount = tcMSB(rhs, parts) + 1;\n  if (shiftCount == 0)\n    return true;\n\n  shiftCount = parts * APINT_BITS_PER_WORD - shiftCount;\n  unsigned n = shiftCount / APINT_BITS_PER_WORD;\n  WordType mask = (WordType) 1 << (shiftCount % APINT_BITS_PER_WORD);\n\n  tcAssign(srhs, rhs, parts);\n  tcShiftLeft(srhs, parts, shiftCount);\n  tcAssign(remainder, lhs, parts);\n  tcSet(lhs, 0, parts);\n\n  /* Loop, subtracting SRHS if REMAINDER is greater and adding that to\n     the total.  */\n  for (;;) {\n    int compare = tcCompare(remainder, srhs, parts);\n    if (compare >= 0) {\n      tcSubtract(remainder, srhs, 0, parts);\n      lhs[n] |= mask;\n    }\n\n    if (shiftCount == 0)\n      break;\n    shiftCount--;\n    tcShiftRight(srhs, parts, 1);\n    if ((mask >>= 1) == 0) {\n      mask = (WordType) 1 << (APINT_BITS_PER_WORD - 1);\n      n--;\n    }\n  }\n\n  return false;\n}\n\n/// Shift a bignum left Cound bits in-place. Shifted in bits are zero. There are\n/// no restrictions on Count.\nvoid APInt::tcShiftLeft(WordType *Dst, unsigned Words, unsigned Count) {\n  // Don't bother performing a no-op shift.\n  if (!Count)\n    return;\n\n  // WordShift is the inter-part shift; BitShift is the intra-part shift.\n  unsigned WordShift = std::min(Count / APINT_BITS_PER_WORD, Words);\n  unsigned BitShift = Count % APINT_BITS_PER_WORD;\n\n  // Fastpath for moving by whole words.\n  if (BitShift == 0) {\n    std::memmove(Dst + WordShift, Dst, (Words - WordShift) * APINT_WORD_SIZE);\n  } else {\n    while (Words-- > WordShift) {\n      Dst[Words] = Dst[Words - WordShift] << BitShift;\n      if (Words > WordShift)\n        Dst[Words] |=\n          Dst[Words - WordShift - 1] >> (APINT_BITS_PER_WORD - BitShift);\n    }\n  }\n\n  // Fill in the remainder with 0s.\n  std::memset(Dst, 0, WordShift * APINT_WORD_SIZE);\n}\n\n/// Shift a bignum right Count bits in-place. Shifted in bits are zero. There\n/// are no restrictions on Count.\nvoid APInt::tcShiftRight(WordType *Dst, unsigned Words, unsigned Count) {\n  // Don't bother performing a no-op shift.\n  if (!Count)\n    return;\n\n  // WordShift is the inter-part shift; BitShift is the intra-part shift.\n  unsigned WordShift = std::min(Count / APINT_BITS_PER_WORD, Words);\n  unsigned BitShift = Count % APINT_BITS_PER_WORD;\n\n  unsigned WordsToMove = Words - WordShift;\n  // Fastpath for moving by whole words.\n  if (BitShift == 0) {\n    std::memmove(Dst, Dst + WordShift, WordsToMove * APINT_WORD_SIZE);\n  } else {\n    for (unsigned i = 0; i != WordsToMove; ++i) {\n      Dst[i] = Dst[i + WordShift] >> BitShift;\n      if (i + 1 != WordsToMove)\n        Dst[i] |= Dst[i + WordShift + 1] << (APINT_BITS_PER_WORD - BitShift);\n    }\n  }\n\n  // Fill in the remainder with 0s.\n  std::memset(Dst + WordsToMove, 0, WordShift * APINT_WORD_SIZE);\n}\n\n/* Bitwise and of two bignums.  */\nvoid APInt::tcAnd(WordType *dst, const WordType *rhs, unsigned parts) {\n  for (unsigned i = 0; i < parts; i++)\n    dst[i] &= rhs[i];\n}\n\n/* Bitwise inclusive or of two bignums.  */\nvoid APInt::tcOr(WordType *dst, const WordType *rhs, unsigned parts) {\n  for (unsigned i = 0; i < parts; i++)\n    dst[i] |= rhs[i];\n}\n\n/* Bitwise exclusive or of two bignums.  */\nvoid APInt::tcXor(WordType *dst, const WordType *rhs, unsigned parts) {\n  for (unsigned i = 0; i < parts; i++)\n    dst[i] ^= rhs[i];\n}\n\n/* Complement a bignum in-place.  */\nvoid APInt::tcComplement(WordType *dst, unsigned parts) {\n  for (unsigned i = 0; i < parts; i++)\n    dst[i] = ~dst[i];\n}\n\n/* Comparison (unsigned) of two bignums.  */\nint APInt::tcCompare(const WordType *lhs, const WordType *rhs,\n                     unsigned parts) {\n  while (parts) {\n    parts--;\n    if (lhs[parts] != rhs[parts])\n      return (lhs[parts] > rhs[parts]) ? 1 : -1;\n  }\n\n  return 0;\n}\n\n/* Set the least significant BITS bits of a bignum, clear the\n   rest.  */\nvoid APInt::tcSetLeastSignificantBits(WordType *dst, unsigned parts,\n                                      unsigned bits) {\n  unsigned i = 0;\n  while (bits > APINT_BITS_PER_WORD) {\n    dst[i++] = ~(WordType) 0;\n    bits -= APINT_BITS_PER_WORD;\n  }\n\n  if (bits)\n    dst[i++] = ~(WordType) 0 >> (APINT_BITS_PER_WORD - bits);\n\n  while (i < parts)\n    dst[i++] = 0;\n}\n\nAPInt llvm::APIntOps::RoundingUDiv(const APInt &A, const APInt &B,\n                                   APInt::Rounding RM) {\n  // Currently udivrem always rounds down.\n  switch (RM) {\n  case APInt::Rounding::DOWN:\n  case APInt::Rounding::TOWARD_ZERO:\n    return A.udiv(B);\n  case APInt::Rounding::UP: {\n    APInt Quo, Rem;\n    APInt::udivrem(A, B, Quo, Rem);\n    if (Rem == 0)\n      return Quo;\n    return Quo + 1;\n  }\n  }\n  llvm_unreachable(\"Unknown APInt::Rounding enum\");\n}\n\nAPInt llvm::APIntOps::RoundingSDiv(const APInt &A, const APInt &B,\n                                   APInt::Rounding RM) {\n  switch (RM) {\n  case APInt::Rounding::DOWN:\n  case APInt::Rounding::UP: {\n    APInt Quo, Rem;\n    APInt::sdivrem(A, B, Quo, Rem);\n    if (Rem == 0)\n      return Quo;\n    // This algorithm deals with arbitrary rounding mode used by sdivrem.\n    // We want to check whether the non-integer part of the mathematical value\n    // is negative or not. If the non-integer part is negative, we need to round\n    // down from Quo; otherwise, if it's positive or 0, we return Quo, as it's\n    // already rounded down.\n    if (RM == APInt::Rounding::DOWN) {\n      if (Rem.isNegative() != B.isNegative())\n        return Quo - 1;\n      return Quo;\n    }\n    if (Rem.isNegative() != B.isNegative())\n      return Quo;\n    return Quo + 1;\n  }\n  // Currently sdiv rounds towards zero.\n  case APInt::Rounding::TOWARD_ZERO:\n    return A.sdiv(B);\n  }\n  llvm_unreachable(\"Unknown APInt::Rounding enum\");\n}\n\nOptional<APInt>\nllvm::APIntOps::SolveQuadraticEquationWrap(APInt A, APInt B, APInt C,\n                                           unsigned RangeWidth) {\n  unsigned CoeffWidth = A.getBitWidth();\n  assert(CoeffWidth == B.getBitWidth() && CoeffWidth == C.getBitWidth());\n  assert(RangeWidth <= CoeffWidth &&\n         \"Value range width should be less than coefficient width\");\n  assert(RangeWidth > 1 && \"Value range bit width should be > 1\");\n\n  LLVM_DEBUG(dbgs() << __func__ << \": solving \" << A << \"x^2 + \" << B\n                    << \"x + \" << C << \", rw:\" << RangeWidth << '\\n');\n\n  // Identify 0 as a (non)solution immediately.\n  if (C.sextOrTrunc(RangeWidth).isNullValue() ) {\n    LLVM_DEBUG(dbgs() << __func__ << \": zero solution\\n\");\n    return APInt(CoeffWidth, 0);\n  }\n\n  // The result of APInt arithmetic has the same bit width as the operands,\n  // so it can actually lose high bits. A product of two n-bit integers needs\n  // 2n-1 bits to represent the full value.\n  // The operation done below (on quadratic coefficients) that can produce\n  // the largest value is the evaluation of the equation during bisection,\n  // which needs 3 times the bitwidth of the coefficient, so the total number\n  // of required bits is 3n.\n  //\n  // The purpose of this extension is to simulate the set Z of all integers,\n  // where n+1 > n for all n in Z. In Z it makes sense to talk about positive\n  // and negative numbers (not so much in a modulo arithmetic). The method\n  // used to solve the equation is based on the standard formula for real\n  // numbers, and uses the concepts of \"positive\" and \"negative\" with their\n  // usual meanings.\n  CoeffWidth *= 3;\n  A = A.sext(CoeffWidth);\n  B = B.sext(CoeffWidth);\n  C = C.sext(CoeffWidth);\n\n  // Make A > 0 for simplicity. Negate cannot overflow at this point because\n  // the bit width has increased.\n  if (A.isNegative()) {\n    A.negate();\n    B.negate();\n    C.negate();\n  }\n\n  // Solving an equation q(x) = 0 with coefficients in modular arithmetic\n  // is really solving a set of equations q(x) = kR for k = 0, 1, 2, ...,\n  // and R = 2^BitWidth.\n  // Since we're trying not only to find exact solutions, but also values\n  // that \"wrap around\", such a set will always have a solution, i.e. an x\n  // that satisfies at least one of the equations, or such that |q(x)|\n  // exceeds kR, while |q(x-1)| for the same k does not.\n  //\n  // We need to find a value k, such that Ax^2 + Bx + C = kR will have a\n  // positive solution n (in the above sense), and also such that the n\n  // will be the least among all solutions corresponding to k = 0, 1, ...\n  // (more precisely, the least element in the set\n  //   { n(k) | k is such that a solution n(k) exists }).\n  //\n  // Consider the parabola (over real numbers) that corresponds to the\n  // quadratic equation. Since A > 0, the arms of the parabola will point\n  // up. Picking different values of k will shift it up and down by R.\n  //\n  // We want to shift the parabola in such a way as to reduce the problem\n  // of solving q(x) = kR to solving shifted_q(x) = 0.\n  // (The interesting solutions are the ceilings of the real number\n  // solutions.)\n  APInt R = APInt::getOneBitSet(CoeffWidth, RangeWidth);\n  APInt TwoA = 2 * A;\n  APInt SqrB = B * B;\n  bool PickLow;\n\n  auto RoundUp = [] (const APInt &V, const APInt &A) -> APInt {\n    assert(A.isStrictlyPositive());\n    APInt T = V.abs().urem(A);\n    if (T.isNullValue())\n      return V;\n    return V.isNegative() ? V+T : V+(A-T);\n  };\n\n  // The vertex of the parabola is at -B/2A, but since A > 0, it's negative\n  // iff B is positive.\n  if (B.isNonNegative()) {\n    // If B >= 0, the vertex it at a negative location (or at 0), so in\n    // order to have a non-negative solution we need to pick k that makes\n    // C-kR negative. To satisfy all the requirements for the solution\n    // that we are looking for, it needs to be closest to 0 of all k.\n    C = C.srem(R);\n    if (C.isStrictlyPositive())\n      C -= R;\n    // Pick the greater solution.\n    PickLow = false;\n  } else {\n    // If B < 0, the vertex is at a positive location. For any solution\n    // to exist, the discriminant must be non-negative. This means that\n    // C-kR <= B^2/4A is a necessary condition for k, i.e. there is a\n    // lower bound on values of k: kR >= C - B^2/4A.\n    APInt LowkR = C - SqrB.udiv(2*TwoA); // udiv because all values > 0.\n    // Round LowkR up (towards +inf) to the nearest kR.\n    LowkR = RoundUp(LowkR, R);\n\n    // If there exists k meeting the condition above, and such that\n    // C-kR > 0, there will be two positive real number solutions of\n    // q(x) = kR. Out of all such values of k, pick the one that makes\n    // C-kR closest to 0, (i.e. pick maximum k such that C-kR > 0).\n    // In other words, find maximum k such that LowkR <= kR < C.\n    if (C.sgt(LowkR)) {\n      // If LowkR < C, then such a k is guaranteed to exist because\n      // LowkR itself is a multiple of R.\n      C -= -RoundUp(-C, R);      // C = C - RoundDown(C, R)\n      // Pick the smaller solution.\n      PickLow = true;\n    } else {\n      // If C-kR < 0 for all potential k's, it means that one solution\n      // will be negative, while the other will be positive. The positive\n      // solution will shift towards 0 if the parabola is moved up.\n      // Pick the kR closest to the lower bound (i.e. make C-kR closest\n      // to 0, or in other words, out of all parabolas that have solutions,\n      // pick the one that is the farthest \"up\").\n      // Since LowkR is itself a multiple of R, simply take C-LowkR.\n      C -= LowkR;\n      // Pick the greater solution.\n      PickLow = false;\n    }\n  }\n\n  LLVM_DEBUG(dbgs() << __func__ << \": updated coefficients \" << A << \"x^2 + \"\n                    << B << \"x + \" << C << \", rw:\" << RangeWidth << '\\n');\n\n  APInt D = SqrB - 4*A*C;\n  assert(D.isNonNegative() && \"Negative discriminant\");\n  APInt SQ = D.sqrt();\n\n  APInt Q = SQ * SQ;\n  bool InexactSQ = Q != D;\n  // The calculated SQ may actually be greater than the exact (non-integer)\n  // value. If that's the case, decrement SQ to get a value that is lower.\n  if (Q.sgt(D))\n    SQ -= 1;\n\n  APInt X;\n  APInt Rem;\n\n  // SQ is rounded down (i.e SQ * SQ <= D), so the roots may be inexact.\n  // When using the quadratic formula directly, the calculated low root\n  // may be greater than the exact one, since we would be subtracting SQ.\n  // To make sure that the calculated root is not greater than the exact\n  // one, subtract SQ+1 when calculating the low root (for inexact value\n  // of SQ).\n  if (PickLow)\n    APInt::sdivrem(-B - (SQ+InexactSQ), TwoA, X, Rem);\n  else\n    APInt::sdivrem(-B + SQ, TwoA, X, Rem);\n\n  // The updated coefficients should be such that the (exact) solution is\n  // positive. Since APInt division rounds towards 0, the calculated one\n  // can be 0, but cannot be negative.\n  assert(X.isNonNegative() && \"Solution should be non-negative\");\n\n  if (!InexactSQ && Rem.isNullValue()) {\n    LLVM_DEBUG(dbgs() << __func__ << \": solution (root): \" << X << '\\n');\n    return X;\n  }\n\n  assert((SQ*SQ).sle(D) && \"SQ = |_sqrt(D)_|, so SQ*SQ <= D\");\n  // The exact value of the square root of D should be between SQ and SQ+1.\n  // This implies that the solution should be between that corresponding to\n  // SQ (i.e. X) and that corresponding to SQ+1.\n  //\n  // The calculated X cannot be greater than the exact (real) solution.\n  // Actually it must be strictly less than the exact solution, while\n  // X+1 will be greater than or equal to it.\n\n  APInt VX = (A*X + B)*X + C;\n  APInt VY = VX + TwoA*X + A + B;\n  bool SignChange = VX.isNegative() != VY.isNegative() ||\n                    VX.isNullValue() != VY.isNullValue();\n  // If the sign did not change between X and X+1, X is not a valid solution.\n  // This could happen when the actual (exact) roots don't have an integer\n  // between them, so they would both be contained between X and X+1.\n  if (!SignChange) {\n    LLVM_DEBUG(dbgs() << __func__ << \": no valid solution\\n\");\n    return None;\n  }\n\n  X += 1;\n  LLVM_DEBUG(dbgs() << __func__ << \": solution (wrap): \" << X << '\\n');\n  return X;\n}\n\nOptional<unsigned>\nllvm::APIntOps::GetMostSignificantDifferentBit(const APInt &A, const APInt &B) {\n  assert(A.getBitWidth() == B.getBitWidth() && \"Must have the same bitwidth\");\n  if (A == B)\n    return llvm::None;\n  return A.getBitWidth() - ((A ^ B).countLeadingZeros() + 1);\n}\n\n/// StoreIntToMemory - Fills the StoreBytes bytes of memory starting from Dst\n/// with the integer held in IntVal.\nvoid llvm::StoreIntToMemory(const APInt &IntVal, uint8_t *Dst,\n                            unsigned StoreBytes) {\n  assert((IntVal.getBitWidth()+7)/8 >= StoreBytes && \"Integer too small!\");\n  const uint8_t *Src = (const uint8_t *)IntVal.getRawData();\n\n  if (sys::IsLittleEndianHost) {\n    // Little-endian host - the source is ordered from LSB to MSB.  Order the\n    // destination from LSB to MSB: Do a straight copy.\n    memcpy(Dst, Src, StoreBytes);\n  } else {\n    // Big-endian host - the source is an array of 64 bit words ordered from\n    // LSW to MSW.  Each word is ordered from MSB to LSB.  Order the destination\n    // from MSB to LSB: Reverse the word order, but not the bytes in a word.\n    while (StoreBytes > sizeof(uint64_t)) {\n      StoreBytes -= sizeof(uint64_t);\n      // May not be aligned so use memcpy.\n      memcpy(Dst + StoreBytes, Src, sizeof(uint64_t));\n      Src += sizeof(uint64_t);\n    }\n\n    memcpy(Dst, Src + sizeof(uint64_t) - StoreBytes, StoreBytes);\n  }\n}\n\n/// LoadIntFromMemory - Loads the integer stored in the LoadBytes bytes starting\n/// from Src into IntVal, which is assumed to be wide enough and to hold zero.\nvoid llvm::LoadIntFromMemory(APInt &IntVal, const uint8_t *Src,\n                             unsigned LoadBytes) {\n  assert((IntVal.getBitWidth()+7)/8 >= LoadBytes && \"Integer too small!\");\n  uint8_t *Dst = reinterpret_cast<uint8_t *>(\n                   const_cast<uint64_t *>(IntVal.getRawData()));\n\n  if (sys::IsLittleEndianHost)\n    // Little-endian host - the destination must be ordered from LSB to MSB.\n    // The source is ordered from LSB to MSB: Do a straight copy.\n    memcpy(Dst, Src, LoadBytes);\n  else {\n    // Big-endian - the destination is an array of 64 bit words ordered from\n    // LSW to MSW.  Each word must be ordered from MSB to LSB.  The source is\n    // ordered from MSB to LSB: Reverse the word order, but not the bytes in\n    // a word.\n    while (LoadBytes > sizeof(uint64_t)) {\n      LoadBytes -= sizeof(uint64_t);\n      // May not be aligned so use memcpy.\n      memcpy(Dst, Src + LoadBytes, sizeof(uint64_t));\n      Dst += sizeof(uint64_t);\n    }\n\n    memcpy(Dst + sizeof(uint64_t) - LoadBytes, Src, LoadBytes);\n  }\n}\n"}, "0": {"id": 0, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APInt.h", "content": "//===-- llvm/ADT/APInt.h - For Arbitrary Precision Integer -----*- C++ -*--===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n///\n/// \\file\n/// This file implements a class to represent arbitrary precision\n/// integral constant values and operations on them.\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_APINT_H\n#define LLVM_ADT_APINT_H\n\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include <cassert>\n#include <climits>\n#include <cstring>\n#include <string>\n\nnamespace llvm {\nclass FoldingSetNodeID;\nclass StringRef;\nclass hash_code;\nclass raw_ostream;\n\ntemplate <typename T> class SmallVectorImpl;\ntemplate <typename T> class ArrayRef;\ntemplate <typename T> class Optional;\ntemplate <typename T> struct DenseMapInfo;\n\nclass APInt;\n\ninline APInt operator-(APInt);\n\n//===----------------------------------------------------------------------===//\n//                              APInt Class\n//===----------------------------------------------------------------------===//\n\n/// Class for arbitrary precision integers.\n///\n/// APInt is a functional replacement for common case unsigned integer type like\n/// \"unsigned\", \"unsigned long\" or \"uint64_t\", but also allows non-byte-width\n/// integer sizes and large integer value types such as 3-bits, 15-bits, or more\n/// than 64-bits of precision. APInt provides a variety of arithmetic operators\n/// and methods to manipulate integer values of any bit-width. It supports both\n/// the typical integer arithmetic and comparison operations as well as bitwise\n/// manipulation.\n///\n/// The class has several invariants worth noting:\n///   * All bit, byte, and word positions are zero-based.\n///   * Once the bit width is set, it doesn't change except by the Truncate,\n///     SignExtend, or ZeroExtend operations.\n///   * All binary operators must be on APInt instances of the same bit width.\n///     Attempting to use these operators on instances with different bit\n///     widths will yield an assertion.\n///   * The value is stored canonically as an unsigned value. For operations\n///     where it makes a difference, there are both signed and unsigned variants\n///     of the operation. For example, sdiv and udiv. However, because the bit\n///     widths must be the same, operations such as Mul and Add produce the same\n///     results regardless of whether the values are interpreted as signed or\n///     not.\n///   * In general, the class tries to follow the style of computation that LLVM\n///     uses in its IR. This simplifies its use for LLVM.\n///\nclass LLVM_NODISCARD APInt {\npublic:\n  typedef uint64_t WordType;\n\n  /// This enum is used to hold the constants we needed for APInt.\n  enum : unsigned {\n    /// Byte size of a word.\n    APINT_WORD_SIZE = sizeof(WordType),\n    /// Bits in a word.\n    APINT_BITS_PER_WORD = APINT_WORD_SIZE * CHAR_BIT\n  };\n\n  enum class Rounding {\n    DOWN,\n    TOWARD_ZERO,\n    UP,\n  };\n\n  static constexpr WordType WORDTYPE_MAX = ~WordType(0);\n\nprivate:\n  /// This union is used to store the integer value. When the\n  /// integer bit-width <= 64, it uses VAL, otherwise it uses pVal.\n  union {\n    uint64_t VAL;   ///< Used to store the <= 64 bits integer value.\n    uint64_t *pVal; ///< Used to store the >64 bits integer value.\n  } U;\n\n  unsigned BitWidth; ///< The number of bits in this APInt.\n\n  friend struct DenseMapInfo<APInt>;\n\n  friend class APSInt;\n\n  /// Fast internal constructor\n  ///\n  /// This constructor is used only internally for speed of construction of\n  /// temporaries. It is unsafe for general use so it is not public.\n  APInt(uint64_t *val, unsigned bits) : BitWidth(bits) {\n    U.pVal = val;\n  }\n\n  /// Determine if this APInt just has one word to store value.\n  ///\n  /// \\returns true if the number of bits <= 64, false otherwise.\n  bool isSingleWord() const { return BitWidth <= APINT_BITS_PER_WORD; }\n\n  /// Determine which word a bit is in.\n  ///\n  /// \\returns the word position for the specified bit position.\n  static unsigned whichWord(unsigned bitPosition) {\n    return bitPosition / APINT_BITS_PER_WORD;\n  }\n\n  /// Determine which bit in a word a bit is in.\n  ///\n  /// \\returns the bit position in a word for the specified bit position\n  /// in the APInt.\n  static unsigned whichBit(unsigned bitPosition) {\n    return bitPosition % APINT_BITS_PER_WORD;\n  }\n\n  /// Get a single bit mask.\n  ///\n  /// \\returns a uint64_t with only bit at \"whichBit(bitPosition)\" set\n  /// This method generates and returns a uint64_t (word) mask for a single\n  /// bit at a specific bit position. This is used to mask the bit in the\n  /// corresponding word.\n  static uint64_t maskBit(unsigned bitPosition) {\n    return 1ULL << whichBit(bitPosition);\n  }\n\n  /// Clear unused high order bits\n  ///\n  /// This method is used internally to clear the top \"N\" bits in the high order\n  /// word that are not used by the APInt. This is needed after the most\n  /// significant word is assigned a value to ensure that those bits are\n  /// zero'd out.\n  APInt &clearUnusedBits() {\n    // Compute how many bits are used in the final word\n    unsigned WordBits = ((BitWidth-1) % APINT_BITS_PER_WORD) + 1;\n\n    // Mask out the high bits.\n    uint64_t mask = WORDTYPE_MAX >> (APINT_BITS_PER_WORD - WordBits);\n    if (isSingleWord())\n      U.VAL &= mask;\n    else\n      U.pVal[getNumWords() - 1] &= mask;\n    return *this;\n  }\n\n  /// Get the word corresponding to a bit position\n  /// \\returns the corresponding word for the specified bit position.\n  uint64_t getWord(unsigned bitPosition) const {\n    return isSingleWord() ? U.VAL : U.pVal[whichWord(bitPosition)];\n  }\n\n  /// Utility method to change the bit width of this APInt to new bit width,\n  /// allocating and/or deallocating as necessary. There is no guarantee on the\n  /// value of any bits upon return. Caller should populate the bits after.\n  void reallocate(unsigned NewBitWidth);\n\n  /// Convert a char array into an APInt\n  ///\n  /// \\param radix 2, 8, 10, 16, or 36\n  /// Converts a string into a number.  The string must be non-empty\n  /// and well-formed as a number of the given base. The bit-width\n  /// must be sufficient to hold the result.\n  ///\n  /// This is used by the constructors that take string arguments.\n  ///\n  /// StringRef::getAsInteger is superficially similar but (1) does\n  /// not assume that the string is well-formed and (2) grows the\n  /// result to hold the input.\n  void fromString(unsigned numBits, StringRef str, uint8_t radix);\n\n  /// An internal division function for dividing APInts.\n  ///\n  /// This is used by the toString method to divide by the radix. It simply\n  /// provides a more convenient form of divide for internal use since KnuthDiv\n  /// has specific constraints on its inputs. If those constraints are not met\n  /// then it provides a simpler form of divide.\n  static void divide(const WordType *LHS, unsigned lhsWords,\n                     const WordType *RHS, unsigned rhsWords, WordType *Quotient,\n                     WordType *Remainder);\n\n  /// out-of-line slow case for inline constructor\n  void initSlowCase(uint64_t val, bool isSigned);\n\n  /// shared code between two array constructors\n  void initFromArray(ArrayRef<uint64_t> array);\n\n  /// out-of-line slow case for inline copy constructor\n  void initSlowCase(const APInt &that);\n\n  /// out-of-line slow case for shl\n  void shlSlowCase(unsigned ShiftAmt);\n\n  /// out-of-line slow case for lshr.\n  void lshrSlowCase(unsigned ShiftAmt);\n\n  /// out-of-line slow case for ashr.\n  void ashrSlowCase(unsigned ShiftAmt);\n\n  /// out-of-line slow case for operator=\n  void AssignSlowCase(const APInt &RHS);\n\n  /// out-of-line slow case for operator==\n  bool EqualSlowCase(const APInt &RHS) const LLVM_READONLY;\n\n  /// out-of-line slow case for countLeadingZeros\n  unsigned countLeadingZerosSlowCase() const LLVM_READONLY;\n\n  /// out-of-line slow case for countLeadingOnes.\n  unsigned countLeadingOnesSlowCase() const LLVM_READONLY;\n\n  /// out-of-line slow case for countTrailingZeros.\n  unsigned countTrailingZerosSlowCase() const LLVM_READONLY;\n\n  /// out-of-line slow case for countTrailingOnes\n  unsigned countTrailingOnesSlowCase() const LLVM_READONLY;\n\n  /// out-of-line slow case for countPopulation\n  unsigned countPopulationSlowCase() const LLVM_READONLY;\n\n  /// out-of-line slow case for intersects.\n  bool intersectsSlowCase(const APInt &RHS) const LLVM_READONLY;\n\n  /// out-of-line slow case for isSubsetOf.\n  bool isSubsetOfSlowCase(const APInt &RHS) const LLVM_READONLY;\n\n  /// out-of-line slow case for setBits.\n  void setBitsSlowCase(unsigned loBit, unsigned hiBit);\n\n  /// out-of-line slow case for flipAllBits.\n  void flipAllBitsSlowCase();\n\n  /// out-of-line slow case for operator&=.\n  void AndAssignSlowCase(const APInt& RHS);\n\n  /// out-of-line slow case for operator|=.\n  void OrAssignSlowCase(const APInt& RHS);\n\n  /// out-of-line slow case for operator^=.\n  void XorAssignSlowCase(const APInt& RHS);\n\n  /// Unsigned comparison. Returns -1, 0, or 1 if this APInt is less than, equal\n  /// to, or greater than RHS.\n  int compare(const APInt &RHS) const LLVM_READONLY;\n\n  /// Signed comparison. Returns -1, 0, or 1 if this APInt is less than, equal\n  /// to, or greater than RHS.\n  int compareSigned(const APInt &RHS) const LLVM_READONLY;\n\npublic:\n  /// \\name Constructors\n  /// @{\n\n  /// Create a new APInt of numBits width, initialized as val.\n  ///\n  /// If isSigned is true then val is treated as if it were a signed value\n  /// (i.e. as an int64_t) and the appropriate sign extension to the bit width\n  /// will be done. Otherwise, no sign extension occurs (high order bits beyond\n  /// the range of val are zero filled).\n  ///\n  /// \\param numBits the bit width of the constructed APInt\n  /// \\param val the initial value of the APInt\n  /// \\param isSigned how to treat signedness of val\n  APInt(unsigned numBits, uint64_t val, bool isSigned = false)\n      : BitWidth(numBits) {\n    assert(BitWidth && \"bitwidth too small\");\n    if (isSingleWord()) {\n      U.VAL = val;\n      clearUnusedBits();\n    } else {\n      initSlowCase(val, isSigned);\n    }\n  }\n\n  /// Construct an APInt of numBits width, initialized as bigVal[].\n  ///\n  /// Note that bigVal.size() can be smaller or larger than the corresponding\n  /// bit width but any extraneous bits will be dropped.\n  ///\n  /// \\param numBits the bit width of the constructed APInt\n  /// \\param bigVal a sequence of words to form the initial value of the APInt\n  APInt(unsigned numBits, ArrayRef<uint64_t> bigVal);\n\n  /// Equivalent to APInt(numBits, ArrayRef<uint64_t>(bigVal, numWords)), but\n  /// deprecated because this constructor is prone to ambiguity with the\n  /// APInt(unsigned, uint64_t, bool) constructor.\n  ///\n  /// If this overload is ever deleted, care should be taken to prevent calls\n  /// from being incorrectly captured by the APInt(unsigned, uint64_t, bool)\n  /// constructor.\n  APInt(unsigned numBits, unsigned numWords, const uint64_t bigVal[]);\n\n  /// Construct an APInt from a string representation.\n  ///\n  /// This constructor interprets the string \\p str in the given radix. The\n  /// interpretation stops when the first character that is not suitable for the\n  /// radix is encountered, or the end of the string. Acceptable radix values\n  /// are 2, 8, 10, 16, and 36. It is an error for the value implied by the\n  /// string to require more bits than numBits.\n  ///\n  /// \\param numBits the bit width of the constructed APInt\n  /// \\param str the string to be interpreted\n  /// \\param radix the radix to use for the conversion\n  APInt(unsigned numBits, StringRef str, uint8_t radix);\n\n  /// Simply makes *this a copy of that.\n  /// Copy Constructor.\n  APInt(const APInt &that) : BitWidth(that.BitWidth) {\n    if (isSingleWord())\n      U.VAL = that.U.VAL;\n    else\n      initSlowCase(that);\n  }\n\n  /// Move Constructor.\n  APInt(APInt &&that) : BitWidth(that.BitWidth) {\n    memcpy(&U, &that.U, sizeof(U));\n    that.BitWidth = 0;\n  }\n\n  /// Destructor.\n  ~APInt() {\n    if (needsCleanup())\n      delete[] U.pVal;\n  }\n\n  /// Default constructor that creates an uninteresting APInt\n  /// representing a 1-bit zero value.\n  ///\n  /// This is useful for object deserialization (pair this with the static\n  ///  method Read).\n  explicit APInt() : BitWidth(1) { U.VAL = 0; }\n\n  /// Returns whether this instance allocated memory.\n  bool needsCleanup() const { return !isSingleWord(); }\n\n  /// Used to insert APInt objects, or objects that contain APInt objects, into\n  ///  FoldingSets.\n  void Profile(FoldingSetNodeID &id) const;\n\n  /// @}\n  /// \\name Value Tests\n  /// @{\n\n  /// Determine sign of this APInt.\n  ///\n  /// This tests the high bit of this APInt to determine if it is set.\n  ///\n  /// \\returns true if this APInt is negative, false otherwise\n  bool isNegative() const { return (*this)[BitWidth - 1]; }\n\n  /// Determine if this APInt Value is non-negative (>= 0)\n  ///\n  /// This tests the high bit of the APInt to determine if it is unset.\n  bool isNonNegative() const { return !isNegative(); }\n\n  /// Determine if sign bit of this APInt is set.\n  ///\n  /// This tests the high bit of this APInt to determine if it is set.\n  ///\n  /// \\returns true if this APInt has its sign bit set, false otherwise.\n  bool isSignBitSet() const { return (*this)[BitWidth-1]; }\n\n  /// Determine if sign bit of this APInt is clear.\n  ///\n  /// This tests the high bit of this APInt to determine if it is clear.\n  ///\n  /// \\returns true if this APInt has its sign bit clear, false otherwise.\n  bool isSignBitClear() const { return !isSignBitSet(); }\n\n  /// Determine if this APInt Value is positive.\n  ///\n  /// This tests if the value of this APInt is positive (> 0). Note\n  /// that 0 is not a positive value.\n  ///\n  /// \\returns true if this APInt is positive.\n  bool isStrictlyPositive() const { return isNonNegative() && !isNullValue(); }\n\n  /// Determine if this APInt Value is non-positive (<= 0).\n  ///\n  /// \\returns true if this APInt is non-positive.\n  bool isNonPositive() const { return !isStrictlyPositive(); }\n\n  /// Determine if all bits are set\n  ///\n  /// This checks to see if the value has all bits of the APInt are set or not.\n  bool isAllOnesValue() const {\n    if (isSingleWord())\n      return U.VAL == WORDTYPE_MAX >> (APINT_BITS_PER_WORD - BitWidth);\n    return countTrailingOnesSlowCase() == BitWidth;\n  }\n\n  /// Determine if all bits are clear\n  ///\n  /// This checks to see if the value has all bits of the APInt are clear or\n  /// not.\n  bool isNullValue() const { return !*this; }\n\n  /// Determine if this is a value of 1.\n  ///\n  /// This checks to see if the value of this APInt is one.\n  bool isOneValue() const {\n    if (isSingleWord())\n      return U.VAL == 1;\n    return countLeadingZerosSlowCase() == BitWidth - 1;\n  }\n\n  /// Determine if this is the largest unsigned value.\n  ///\n  /// This checks to see if the value of this APInt is the maximum unsigned\n  /// value for the APInt's bit width.\n  bool isMaxValue() const { return isAllOnesValue(); }\n\n  /// Determine if this is the largest signed value.\n  ///\n  /// This checks to see if the value of this APInt is the maximum signed\n  /// value for the APInt's bit width.\n  bool isMaxSignedValue() const {\n    if (isSingleWord())\n      return U.VAL == ((WordType(1) << (BitWidth - 1)) - 1);\n    return !isNegative() && countTrailingOnesSlowCase() == BitWidth - 1;\n  }\n\n  /// Determine if this is the smallest unsigned value.\n  ///\n  /// This checks to see if the value of this APInt is the minimum unsigned\n  /// value for the APInt's bit width.\n  bool isMinValue() const { return isNullValue(); }\n\n  /// Determine if this is the smallest signed value.\n  ///\n  /// This checks to see if the value of this APInt is the minimum signed\n  /// value for the APInt's bit width.\n  bool isMinSignedValue() const {\n    if (isSingleWord())\n      return U.VAL == (WordType(1) << (BitWidth - 1));\n    return isNegative() && countTrailingZerosSlowCase() == BitWidth - 1;\n  }\n\n  /// Check if this APInt has an N-bits unsigned integer value.\n  bool isIntN(unsigned N) const {\n    assert(N && \"N == 0 ???\");\n    return getActiveBits() <= N;\n  }\n\n  /// Check if this APInt has an N-bits signed integer value.\n  bool isSignedIntN(unsigned N) const {\n    assert(N && \"N == 0 ???\");\n    return getMinSignedBits() <= N;\n  }\n\n  /// Check if this APInt's value is a power of two greater than zero.\n  ///\n  /// \\returns true if the argument APInt value is a power of two > 0.\n  bool isPowerOf2() const {\n    if (isSingleWord())\n      return isPowerOf2_64(U.VAL);\n    return countPopulationSlowCase() == 1;\n  }\n\n  /// Check if the APInt's value is returned by getSignMask.\n  ///\n  /// \\returns true if this is the value returned by getSignMask.\n  bool isSignMask() const { return isMinSignedValue(); }\n\n  /// Convert APInt to a boolean value.\n  ///\n  /// This converts the APInt to a boolean value as a test against zero.\n  bool getBoolValue() const { return !!*this; }\n\n  /// If this value is smaller than the specified limit, return it, otherwise\n  /// return the limit value.  This causes the value to saturate to the limit.\n  uint64_t getLimitedValue(uint64_t Limit = UINT64_MAX) const {\n    return ugt(Limit) ? Limit : getZExtValue();\n  }\n\n  /// Check if the APInt consists of a repeated bit pattern.\n  ///\n  /// e.g. 0x01010101 satisfies isSplat(8).\n  /// \\param SplatSizeInBits The size of the pattern in bits. Must divide bit\n  /// width without remainder.\n  bool isSplat(unsigned SplatSizeInBits) const;\n\n  /// \\returns true if this APInt value is a sequence of \\param numBits ones\n  /// starting at the least significant bit with the remainder zero.\n  bool isMask(unsigned numBits) const {\n    assert(numBits != 0 && \"numBits must be non-zero\");\n    assert(numBits <= BitWidth && \"numBits out of range\");\n    if (isSingleWord())\n      return U.VAL == (WORDTYPE_MAX >> (APINT_BITS_PER_WORD - numBits));\n    unsigned Ones = countTrailingOnesSlowCase();\n    return (numBits == Ones) &&\n           ((Ones + countLeadingZerosSlowCase()) == BitWidth);\n  }\n\n  /// \\returns true if this APInt is a non-empty sequence of ones starting at\n  /// the least significant bit with the remainder zero.\n  /// Ex. isMask(0x0000FFFFU) == true.\n  bool isMask() const {\n    if (isSingleWord())\n      return isMask_64(U.VAL);\n    unsigned Ones = countTrailingOnesSlowCase();\n    return (Ones > 0) && ((Ones + countLeadingZerosSlowCase()) == BitWidth);\n  }\n\n  /// Return true if this APInt value contains a sequence of ones with\n  /// the remainder zero.\n  bool isShiftedMask() const {\n    if (isSingleWord())\n      return isShiftedMask_64(U.VAL);\n    unsigned Ones = countPopulationSlowCase();\n    unsigned LeadZ = countLeadingZerosSlowCase();\n    return (Ones + LeadZ + countTrailingZeros()) == BitWidth;\n  }\n\n  /// @}\n  /// \\name Value Generators\n  /// @{\n\n  /// Gets maximum unsigned value of APInt for specific bit width.\n  static APInt getMaxValue(unsigned numBits) {\n    return getAllOnesValue(numBits);\n  }\n\n  /// Gets maximum signed value of APInt for a specific bit width.\n  static APInt getSignedMaxValue(unsigned numBits) {\n    APInt API = getAllOnesValue(numBits);\n    API.clearBit(numBits - 1);\n    return API;\n  }\n\n  /// Gets minimum unsigned value of APInt for a specific bit width.\n  static APInt getMinValue(unsigned numBits) { return APInt(numBits, 0); }\n\n  /// Gets minimum signed value of APInt for a specific bit width.\n  static APInt getSignedMinValue(unsigned numBits) {\n    APInt API(numBits, 0);\n    API.setBit(numBits - 1);\n    return API;\n  }\n\n  /// Get the SignMask for a specific bit width.\n  ///\n  /// This is just a wrapper function of getSignedMinValue(), and it helps code\n  /// readability when we want to get a SignMask.\n  static APInt getSignMask(unsigned BitWidth) {\n    return getSignedMinValue(BitWidth);\n  }\n\n  /// Get the all-ones value.\n  ///\n  /// \\returns the all-ones value for an APInt of the specified bit-width.\n  static APInt getAllOnesValue(unsigned numBits) {\n    return APInt(numBits, WORDTYPE_MAX, true);\n  }\n\n  /// Get the '0' value.\n  ///\n  /// \\returns the '0' value for an APInt of the specified bit-width.\n  static APInt getNullValue(unsigned numBits) { return APInt(numBits, 0); }\n\n  /// Compute an APInt containing numBits highbits from this APInt.\n  ///\n  /// Get an APInt with the same BitWidth as this APInt, just zero mask\n  /// the low bits and right shift to the least significant bit.\n  ///\n  /// \\returns the high \"numBits\" bits of this APInt.\n  APInt getHiBits(unsigned numBits) const;\n\n  /// Compute an APInt containing numBits lowbits from this APInt.\n  ///\n  /// Get an APInt with the same BitWidth as this APInt, just zero mask\n  /// the high bits.\n  ///\n  /// \\returns the low \"numBits\" bits of this APInt.\n  APInt getLoBits(unsigned numBits) const;\n\n  /// Return an APInt with exactly one bit set in the result.\n  static APInt getOneBitSet(unsigned numBits, unsigned BitNo) {\n    APInt Res(numBits, 0);\n    Res.setBit(BitNo);\n    return Res;\n  }\n\n  /// Get a value with a block of bits set.\n  ///\n  /// Constructs an APInt value that has a contiguous range of bits set. The\n  /// bits from loBit (inclusive) to hiBit (exclusive) will be set. All other\n  /// bits will be zero. For example, with parameters(32, 0, 16) you would get\n  /// 0x0000FFFF. Please call getBitsSetWithWrap if \\p loBit may be greater than\n  /// \\p hiBit.\n  ///\n  /// \\param numBits the intended bit width of the result\n  /// \\param loBit the index of the lowest bit set.\n  /// \\param hiBit the index of the highest bit set.\n  ///\n  /// \\returns An APInt value with the requested bits set.\n  static APInt getBitsSet(unsigned numBits, unsigned loBit, unsigned hiBit) {\n    assert(loBit <= hiBit && \"loBit greater than hiBit\");\n    APInt Res(numBits, 0);\n    Res.setBits(loBit, hiBit);\n    return Res;\n  }\n\n  /// Wrap version of getBitsSet.\n  /// If \\p hiBit is bigger than \\p loBit, this is same with getBitsSet.\n  /// If \\p hiBit is not bigger than \\p loBit, the set bits \"wrap\". For example,\n  /// with parameters (32, 28, 4), you would get 0xF000000F.\n  /// If \\p hiBit is equal to \\p loBit, you would get a result with all bits\n  /// set.\n  static APInt getBitsSetWithWrap(unsigned numBits, unsigned loBit,\n                                  unsigned hiBit) {\n    APInt Res(numBits, 0);\n    Res.setBitsWithWrap(loBit, hiBit);\n    return Res;\n  }\n\n  /// Get a value with upper bits starting at loBit set.\n  ///\n  /// Constructs an APInt value that has a contiguous range of bits set. The\n  /// bits from loBit (inclusive) to numBits (exclusive) will be set. All other\n  /// bits will be zero. For example, with parameters(32, 12) you would get\n  /// 0xFFFFF000.\n  ///\n  /// \\param numBits the intended bit width of the result\n  /// \\param loBit the index of the lowest bit to set.\n  ///\n  /// \\returns An APInt value with the requested bits set.\n  static APInt getBitsSetFrom(unsigned numBits, unsigned loBit) {\n    APInt Res(numBits, 0);\n    Res.setBitsFrom(loBit);\n    return Res;\n  }\n\n  /// Get a value with high bits set\n  ///\n  /// Constructs an APInt value that has the top hiBitsSet bits set.\n  ///\n  /// \\param numBits the bitwidth of the result\n  /// \\param hiBitsSet the number of high-order bits set in the result.\n  static APInt getHighBitsSet(unsigned numBits, unsigned hiBitsSet) {\n    APInt Res(numBits, 0);\n    Res.setHighBits(hiBitsSet);\n    return Res;\n  }\n\n  /// Get a value with low bits set\n  ///\n  /// Constructs an APInt value that has the bottom loBitsSet bits set.\n  ///\n  /// \\param numBits the bitwidth of the result\n  /// \\param loBitsSet the number of low-order bits set in the result.\n  static APInt getLowBitsSet(unsigned numBits, unsigned loBitsSet) {\n    APInt Res(numBits, 0);\n    Res.setLowBits(loBitsSet);\n    return Res;\n  }\n\n  /// Return a value containing V broadcasted over NewLen bits.\n  static APInt getSplat(unsigned NewLen, const APInt &V);\n\n  /// Determine if two APInts have the same value, after zero-extending\n  /// one of them (if needed!) to ensure that the bit-widths match.\n  static bool isSameValue(const APInt &I1, const APInt &I2) {\n    if (I1.getBitWidth() == I2.getBitWidth())\n      return I1 == I2;\n\n    if (I1.getBitWidth() > I2.getBitWidth())\n      return I1 == I2.zext(I1.getBitWidth());\n\n    return I1.zext(I2.getBitWidth()) == I2;\n  }\n\n  /// Overload to compute a hash_code for an APInt value.\n  friend hash_code hash_value(const APInt &Arg);\n\n  /// This function returns a pointer to the internal storage of the APInt.\n  /// This is useful for writing out the APInt in binary form without any\n  /// conversions.\n  const uint64_t *getRawData() const {\n    if (isSingleWord())\n      return &U.VAL;\n    return &U.pVal[0];\n  }\n\n  /// @}\n  /// \\name Unary Operators\n  /// @{\n\n  /// Postfix increment operator.\n  ///\n  /// Increments *this by 1.\n  ///\n  /// \\returns a new APInt value representing the original value of *this.\n  const APInt operator++(int) {\n    APInt API(*this);\n    ++(*this);\n    return API;\n  }\n\n  /// Prefix increment operator.\n  ///\n  /// \\returns *this incremented by one\n  APInt &operator++();\n\n  /// Postfix decrement operator.\n  ///\n  /// Decrements *this by 1.\n  ///\n  /// \\returns a new APInt value representing the original value of *this.\n  const APInt operator--(int) {\n    APInt API(*this);\n    --(*this);\n    return API;\n  }\n\n  /// Prefix decrement operator.\n  ///\n  /// \\returns *this decremented by one.\n  APInt &operator--();\n\n  /// Logical negation operator.\n  ///\n  /// Performs logical negation operation on this APInt.\n  ///\n  /// \\returns true if *this is zero, false otherwise.\n  bool operator!() const {\n    if (isSingleWord())\n      return U.VAL == 0;\n    return countLeadingZerosSlowCase() == BitWidth;\n  }\n\n  /// @}\n  /// \\name Assignment Operators\n  /// @{\n\n  /// Copy assignment operator.\n  ///\n  /// \\returns *this after assignment of RHS.\n  APInt &operator=(const APInt &RHS) {\n    // If the bitwidths are the same, we can avoid mucking with memory\n    if (isSingleWord() && RHS.isSingleWord()) {\n      U.VAL = RHS.U.VAL;\n      BitWidth = RHS.BitWidth;\n      return clearUnusedBits();\n    }\n\n    AssignSlowCase(RHS);\n    return *this;\n  }\n\n  /// Move assignment operator.\n  APInt &operator=(APInt &&that) {\n#ifdef EXPENSIVE_CHECKS\n    // Some std::shuffle implementations still do self-assignment.\n    if (this == &that)\n      return *this;\n#endif\n    assert(this != &that && \"Self-move not supported\");\n    if (!isSingleWord())\n      delete[] U.pVal;\n\n    // Use memcpy so that type based alias analysis sees both VAL and pVal\n    // as modified.\n    memcpy(&U, &that.U, sizeof(U));\n\n    BitWidth = that.BitWidth;\n    that.BitWidth = 0;\n\n    return *this;\n  }\n\n  /// Assignment operator.\n  ///\n  /// The RHS value is assigned to *this. If the significant bits in RHS exceed\n  /// the bit width, the excess bits are truncated. If the bit width is larger\n  /// than 64, the value is zero filled in the unspecified high order bits.\n  ///\n  /// \\returns *this after assignment of RHS value.\n  APInt &operator=(uint64_t RHS) {\n    if (isSingleWord()) {\n      U.VAL = RHS;\n      return clearUnusedBits();\n    }\n    U.pVal[0] = RHS;\n    memset(U.pVal + 1, 0, (getNumWords() - 1) * APINT_WORD_SIZE);\n    return *this;\n  }\n\n  /// Bitwise AND assignment operator.\n  ///\n  /// Performs a bitwise AND operation on this APInt and RHS. The result is\n  /// assigned to *this.\n  ///\n  /// \\returns *this after ANDing with RHS.\n  APInt &operator&=(const APInt &RHS) {\n    assert(BitWidth == RHS.BitWidth && \"Bit widths must be the same\");\n    if (isSingleWord())\n      U.VAL &= RHS.U.VAL;\n    else\n      AndAssignSlowCase(RHS);\n    return *this;\n  }\n\n  /// Bitwise AND assignment operator.\n  ///\n  /// Performs a bitwise AND operation on this APInt and RHS. RHS is\n  /// logically zero-extended or truncated to match the bit-width of\n  /// the LHS.\n  APInt &operator&=(uint64_t RHS) {\n    if (isSingleWord()) {\n      U.VAL &= RHS;\n      return *this;\n    }\n    U.pVal[0] &= RHS;\n    memset(U.pVal+1, 0, (getNumWords() - 1) * APINT_WORD_SIZE);\n    return *this;\n  }\n\n  /// Bitwise OR assignment operator.\n  ///\n  /// Performs a bitwise OR operation on this APInt and RHS. The result is\n  /// assigned *this;\n  ///\n  /// \\returns *this after ORing with RHS.\n  APInt &operator|=(const APInt &RHS) {\n    assert(BitWidth == RHS.BitWidth && \"Bit widths must be the same\");\n    if (isSingleWord())\n      U.VAL |= RHS.U.VAL;\n    else\n      OrAssignSlowCase(RHS);\n    return *this;\n  }\n\n  /// Bitwise OR assignment operator.\n  ///\n  /// Performs a bitwise OR operation on this APInt and RHS. RHS is\n  /// logically zero-extended or truncated to match the bit-width of\n  /// the LHS.\n  APInt &operator|=(uint64_t RHS) {\n    if (isSingleWord()) {\n      U.VAL |= RHS;\n      return clearUnusedBits();\n    }\n    U.pVal[0] |= RHS;\n    return *this;\n  }\n\n  /// Bitwise XOR assignment operator.\n  ///\n  /// Performs a bitwise XOR operation on this APInt and RHS. The result is\n  /// assigned to *this.\n  ///\n  /// \\returns *this after XORing with RHS.\n  APInt &operator^=(const APInt &RHS) {\n    assert(BitWidth == RHS.BitWidth && \"Bit widths must be the same\");\n    if (isSingleWord())\n      U.VAL ^= RHS.U.VAL;\n    else\n      XorAssignSlowCase(RHS);\n    return *this;\n  }\n\n  /// Bitwise XOR assignment operator.\n  ///\n  /// Performs a bitwise XOR operation on this APInt and RHS. RHS is\n  /// logically zero-extended or truncated to match the bit-width of\n  /// the LHS.\n  APInt &operator^=(uint64_t RHS) {\n    if (isSingleWord()) {\n      U.VAL ^= RHS;\n      return clearUnusedBits();\n    }\n    U.pVal[0] ^= RHS;\n    return *this;\n  }\n\n  /// Multiplication assignment operator.\n  ///\n  /// Multiplies this APInt by RHS and assigns the result to *this.\n  ///\n  /// \\returns *this\n  APInt &operator*=(const APInt &RHS);\n  APInt &operator*=(uint64_t RHS);\n\n  /// Addition assignment operator.\n  ///\n  /// Adds RHS to *this and assigns the result to *this.\n  ///\n  /// \\returns *this\n  APInt &operator+=(const APInt &RHS);\n  APInt &operator+=(uint64_t RHS);\n\n  /// Subtraction assignment operator.\n  ///\n  /// Subtracts RHS from *this and assigns the result to *this.\n  ///\n  /// \\returns *this\n  APInt &operator-=(const APInt &RHS);\n  APInt &operator-=(uint64_t RHS);\n\n  /// Left-shift assignment function.\n  ///\n  /// Shifts *this left by shiftAmt and assigns the result to *this.\n  ///\n  /// \\returns *this after shifting left by ShiftAmt\n  APInt &operator<<=(unsigned ShiftAmt) {\n    assert(ShiftAmt <= BitWidth && \"Invalid shift amount\");\n    if (isSingleWord()) {\n      if (ShiftAmt == BitWidth)\n        U.VAL = 0;\n      else\n        U.VAL <<= ShiftAmt;\n      return clearUnusedBits();\n    }\n    shlSlowCase(ShiftAmt);\n    return *this;\n  }\n\n  /// Left-shift assignment function.\n  ///\n  /// Shifts *this left by shiftAmt and assigns the result to *this.\n  ///\n  /// \\returns *this after shifting left by ShiftAmt\n  APInt &operator<<=(const APInt &ShiftAmt);\n\n  /// @}\n  /// \\name Binary Operators\n  /// @{\n\n  /// Multiplication operator.\n  ///\n  /// Multiplies this APInt by RHS and returns the result.\n  APInt operator*(const APInt &RHS) const;\n\n  /// Left logical shift operator.\n  ///\n  /// Shifts this APInt left by \\p Bits and returns the result.\n  APInt operator<<(unsigned Bits) const { return shl(Bits); }\n\n  /// Left logical shift operator.\n  ///\n  /// Shifts this APInt left by \\p Bits and returns the result.\n  APInt operator<<(const APInt &Bits) const { return shl(Bits); }\n\n  /// Arithmetic right-shift function.\n  ///\n  /// Arithmetic right-shift this APInt by shiftAmt.\n  APInt ashr(unsigned ShiftAmt) const {\n    APInt R(*this);\n    R.ashrInPlace(ShiftAmt);\n    return R;\n  }\n\n  /// Arithmetic right-shift this APInt by ShiftAmt in place.\n  void ashrInPlace(unsigned ShiftAmt) {\n    assert(ShiftAmt <= BitWidth && \"Invalid shift amount\");\n    if (isSingleWord()) {\n      int64_t SExtVAL = SignExtend64(U.VAL, BitWidth);\n      if (ShiftAmt == BitWidth)\n        U.VAL = SExtVAL >> (APINT_BITS_PER_WORD - 1); // Fill with sign bit.\n      else\n        U.VAL = SExtVAL >> ShiftAmt;\n      clearUnusedBits();\n      return;\n    }\n    ashrSlowCase(ShiftAmt);\n  }\n\n  /// Logical right-shift function.\n  ///\n  /// Logical right-shift this APInt by shiftAmt.\n  APInt lshr(unsigned shiftAmt) const {\n    APInt R(*this);\n    R.lshrInPlace(shiftAmt);\n    return R;\n  }\n\n  /// Logical right-shift this APInt by ShiftAmt in place.\n  void lshrInPlace(unsigned ShiftAmt) {\n    assert(ShiftAmt <= BitWidth && \"Invalid shift amount\");\n    if (isSingleWord()) {\n      if (ShiftAmt == BitWidth)\n        U.VAL = 0;\n      else\n        U.VAL >>= ShiftAmt;\n      return;\n    }\n    lshrSlowCase(ShiftAmt);\n  }\n\n  /// Left-shift function.\n  ///\n  /// Left-shift this APInt by shiftAmt.\n  APInt shl(unsigned shiftAmt) const {\n    APInt R(*this);\n    R <<= shiftAmt;\n    return R;\n  }\n\n  /// Rotate left by rotateAmt.\n  APInt rotl(unsigned rotateAmt) const;\n\n  /// Rotate right by rotateAmt.\n  APInt rotr(unsigned rotateAmt) const;\n\n  /// Arithmetic right-shift function.\n  ///\n  /// Arithmetic right-shift this APInt by shiftAmt.\n  APInt ashr(const APInt &ShiftAmt) const {\n    APInt R(*this);\n    R.ashrInPlace(ShiftAmt);\n    return R;\n  }\n\n  /// Arithmetic right-shift this APInt by shiftAmt in place.\n  void ashrInPlace(const APInt &shiftAmt);\n\n  /// Logical right-shift function.\n  ///\n  /// Logical right-shift this APInt by shiftAmt.\n  APInt lshr(const APInt &ShiftAmt) const {\n    APInt R(*this);\n    R.lshrInPlace(ShiftAmt);\n    return R;\n  }\n\n  /// Logical right-shift this APInt by ShiftAmt in place.\n  void lshrInPlace(const APInt &ShiftAmt);\n\n  /// Left-shift function.\n  ///\n  /// Left-shift this APInt by shiftAmt.\n  APInt shl(const APInt &ShiftAmt) const {\n    APInt R(*this);\n    R <<= ShiftAmt;\n    return R;\n  }\n\n  /// Rotate left by rotateAmt.\n  APInt rotl(const APInt &rotateAmt) const;\n\n  /// Rotate right by rotateAmt.\n  APInt rotr(const APInt &rotateAmt) const;\n\n  /// Unsigned division operation.\n  ///\n  /// Perform an unsigned divide operation on this APInt by RHS. Both this and\n  /// RHS are treated as unsigned quantities for purposes of this division.\n  ///\n  /// \\returns a new APInt value containing the division result, rounded towards\n  /// zero.\n  APInt udiv(const APInt &RHS) const;\n  APInt udiv(uint64_t RHS) const;\n\n  /// Signed division function for APInt.\n  ///\n  /// Signed divide this APInt by APInt RHS.\n  ///\n  /// The result is rounded towards zero.\n  APInt sdiv(const APInt &RHS) const;\n  APInt sdiv(int64_t RHS) const;\n\n  /// Unsigned remainder operation.\n  ///\n  /// Perform an unsigned remainder operation on this APInt with RHS being the\n  /// divisor. Both this and RHS are treated as unsigned quantities for purposes\n  /// of this operation. Note that this is a true remainder operation and not a\n  /// modulo operation because the sign follows the sign of the dividend which\n  /// is *this.\n  ///\n  /// \\returns a new APInt value containing the remainder result\n  APInt urem(const APInt &RHS) const;\n  uint64_t urem(uint64_t RHS) const;\n\n  /// Function for signed remainder operation.\n  ///\n  /// Signed remainder operation on APInt.\n  APInt srem(const APInt &RHS) const;\n  int64_t srem(int64_t RHS) const;\n\n  /// Dual division/remainder interface.\n  ///\n  /// Sometimes it is convenient to divide two APInt values and obtain both the\n  /// quotient and remainder. This function does both operations in the same\n  /// computation making it a little more efficient. The pair of input arguments\n  /// may overlap with the pair of output arguments. It is safe to call\n  /// udivrem(X, Y, X, Y), for example.\n  static void udivrem(const APInt &LHS, const APInt &RHS, APInt &Quotient,\n                      APInt &Remainder);\n  static void udivrem(const APInt &LHS, uint64_t RHS, APInt &Quotient,\n                      uint64_t &Remainder);\n\n  static void sdivrem(const APInt &LHS, const APInt &RHS, APInt &Quotient,\n                      APInt &Remainder);\n  static void sdivrem(const APInt &LHS, int64_t RHS, APInt &Quotient,\n                      int64_t &Remainder);\n\n  // Operations that return overflow indicators.\n  APInt sadd_ov(const APInt &RHS, bool &Overflow) const;\n  APInt uadd_ov(const APInt &RHS, bool &Overflow) const;\n  APInt ssub_ov(const APInt &RHS, bool &Overflow) const;\n  APInt usub_ov(const APInt &RHS, bool &Overflow) const;\n  APInt sdiv_ov(const APInt &RHS, bool &Overflow) const;\n  APInt smul_ov(const APInt &RHS, bool &Overflow) const;\n  APInt umul_ov(const APInt &RHS, bool &Overflow) const;\n  APInt sshl_ov(const APInt &Amt, bool &Overflow) const;\n  APInt ushl_ov(const APInt &Amt, bool &Overflow) const;\n\n  // Operations that saturate\n  APInt sadd_sat(const APInt &RHS) const;\n  APInt uadd_sat(const APInt &RHS) const;\n  APInt ssub_sat(const APInt &RHS) const;\n  APInt usub_sat(const APInt &RHS) const;\n  APInt smul_sat(const APInt &RHS) const;\n  APInt umul_sat(const APInt &RHS) const;\n  APInt sshl_sat(const APInt &RHS) const;\n  APInt ushl_sat(const APInt &RHS) const;\n\n  /// Array-indexing support.\n  ///\n  /// \\returns the bit value at bitPosition\n  bool operator[](unsigned bitPosition) const {\n    assert(bitPosition < getBitWidth() && \"Bit position out of bounds!\");\n    return (maskBit(bitPosition) & getWord(bitPosition)) != 0;\n  }\n\n  /// @}\n  /// \\name Comparison Operators\n  /// @{\n\n  /// Equality operator.\n  ///\n  /// Compares this APInt with RHS for the validity of the equality\n  /// relationship.\n  bool operator==(const APInt &RHS) const {\n    assert(BitWidth == RHS.BitWidth && \"Comparison requires equal bit widths\");\n    if (isSingleWord())\n      return U.VAL == RHS.U.VAL;\n    return EqualSlowCase(RHS);\n  }\n\n  /// Equality operator.\n  ///\n  /// Compares this APInt with a uint64_t for the validity of the equality\n  /// relationship.\n  ///\n  /// \\returns true if *this == Val\n  bool operator==(uint64_t Val) const {\n    return (isSingleWord() || getActiveBits() <= 64) && getZExtValue() == Val;\n  }\n\n  /// Equality comparison.\n  ///\n  /// Compares this APInt with RHS for the validity of the equality\n  /// relationship.\n  ///\n  /// \\returns true if *this == Val\n  bool eq(const APInt &RHS) const { return (*this) == RHS; }\n\n  /// Inequality operator.\n  ///\n  /// Compares this APInt with RHS for the validity of the inequality\n  /// relationship.\n  ///\n  /// \\returns true if *this != Val\n  bool operator!=(const APInt &RHS) const { return !((*this) == RHS); }\n\n  /// Inequality operator.\n  ///\n  /// Compares this APInt with a uint64_t for the validity of the inequality\n  /// relationship.\n  ///\n  /// \\returns true if *this != Val\n  bool operator!=(uint64_t Val) const { return !((*this) == Val); }\n\n  /// Inequality comparison\n  ///\n  /// Compares this APInt with RHS for the validity of the inequality\n  /// relationship.\n  ///\n  /// \\returns true if *this != Val\n  bool ne(const APInt &RHS) const { return !((*this) == RHS); }\n\n  /// Unsigned less than comparison\n  ///\n  /// Regards both *this and RHS as unsigned quantities and compares them for\n  /// the validity of the less-than relationship.\n  ///\n  /// \\returns true if *this < RHS when both are considered unsigned.\n  bool ult(const APInt &RHS) const { return compare(RHS) < 0; }\n\n  /// Unsigned less than comparison\n  ///\n  /// Regards both *this as an unsigned quantity and compares it with RHS for\n  /// the validity of the less-than relationship.\n  ///\n  /// \\returns true if *this < RHS when considered unsigned.\n  bool ult(uint64_t RHS) const {\n    // Only need to check active bits if not a single word.\n    return (isSingleWord() || getActiveBits() <= 64) && getZExtValue() < RHS;\n  }\n\n  /// Signed less than comparison\n  ///\n  /// Regards both *this and RHS as signed quantities and compares them for\n  /// validity of the less-than relationship.\n  ///\n  /// \\returns true if *this < RHS when both are considered signed.\n  bool slt(const APInt &RHS) const { return compareSigned(RHS) < 0; }\n\n  /// Signed less than comparison\n  ///\n  /// Regards both *this as a signed quantity and compares it with RHS for\n  /// the validity of the less-than relationship.\n  ///\n  /// \\returns true if *this < RHS when considered signed.\n  bool slt(int64_t RHS) const {\n    return (!isSingleWord() && getMinSignedBits() > 64) ? isNegative()\n                                                        : getSExtValue() < RHS;\n  }\n\n  /// Unsigned less or equal comparison\n  ///\n  /// Regards both *this and RHS as unsigned quantities and compares them for\n  /// validity of the less-or-equal relationship.\n  ///\n  /// \\returns true if *this <= RHS when both are considered unsigned.\n  bool ule(const APInt &RHS) const { return compare(RHS) <= 0; }\n\n  /// Unsigned less or equal comparison\n  ///\n  /// Regards both *this as an unsigned quantity and compares it with RHS for\n  /// the validity of the less-or-equal relationship.\n  ///\n  /// \\returns true if *this <= RHS when considered unsigned.\n  bool ule(uint64_t RHS) const { return !ugt(RHS); }\n\n  /// Signed less or equal comparison\n  ///\n  /// Regards both *this and RHS as signed quantities and compares them for\n  /// validity of the less-or-equal relationship.\n  ///\n  /// \\returns true if *this <= RHS when both are considered signed.\n  bool sle(const APInt &RHS) const { return compareSigned(RHS) <= 0; }\n\n  /// Signed less or equal comparison\n  ///\n  /// Regards both *this as a signed quantity and compares it with RHS for the\n  /// validity of the less-or-equal relationship.\n  ///\n  /// \\returns true if *this <= RHS when considered signed.\n  bool sle(uint64_t RHS) const { return !sgt(RHS); }\n\n  /// Unsigned greater than comparison\n  ///\n  /// Regards both *this and RHS as unsigned quantities and compares them for\n  /// the validity of the greater-than relationship.\n  ///\n  /// \\returns true if *this > RHS when both are considered unsigned.\n  bool ugt(const APInt &RHS) const { return !ule(RHS); }\n\n  /// Unsigned greater than comparison\n  ///\n  /// Regards both *this as an unsigned quantity and compares it with RHS for\n  /// the validity of the greater-than relationship.\n  ///\n  /// \\returns true if *this > RHS when considered unsigned.\n  bool ugt(uint64_t RHS) const {\n    // Only need to check active bits if not a single word.\n    return (!isSingleWord() && getActiveBits() > 64) || getZExtValue() > RHS;\n  }\n\n  /// Signed greater than comparison\n  ///\n  /// Regards both *this and RHS as signed quantities and compares them for the\n  /// validity of the greater-than relationship.\n  ///\n  /// \\returns true if *this > RHS when both are considered signed.\n  bool sgt(const APInt &RHS) const { return !sle(RHS); }\n\n  /// Signed greater than comparison\n  ///\n  /// Regards both *this as a signed quantity and compares it with RHS for\n  /// the validity of the greater-than relationship.\n  ///\n  /// \\returns true if *this > RHS when considered signed.\n  bool sgt(int64_t RHS) const {\n    return (!isSingleWord() && getMinSignedBits() > 64) ? !isNegative()\n                                                        : getSExtValue() > RHS;\n  }\n\n  /// Unsigned greater or equal comparison\n  ///\n  /// Regards both *this and RHS as unsigned quantities and compares them for\n  /// validity of the greater-or-equal relationship.\n  ///\n  /// \\returns true if *this >= RHS when both are considered unsigned.\n  bool uge(const APInt &RHS) const { return !ult(RHS); }\n\n  /// Unsigned greater or equal comparison\n  ///\n  /// Regards both *this as an unsigned quantity and compares it with RHS for\n  /// the validity of the greater-or-equal relationship.\n  ///\n  /// \\returns true if *this >= RHS when considered unsigned.\n  bool uge(uint64_t RHS) const { return !ult(RHS); }\n\n  /// Signed greater or equal comparison\n  ///\n  /// Regards both *this and RHS as signed quantities and compares them for\n  /// validity of the greater-or-equal relationship.\n  ///\n  /// \\returns true if *this >= RHS when both are considered signed.\n  bool sge(const APInt &RHS) const { return !slt(RHS); }\n\n  /// Signed greater or equal comparison\n  ///\n  /// Regards both *this as a signed quantity and compares it with RHS for\n  /// the validity of the greater-or-equal relationship.\n  ///\n  /// \\returns true if *this >= RHS when considered signed.\n  bool sge(int64_t RHS) const { return !slt(RHS); }\n\n  /// This operation tests if there are any pairs of corresponding bits\n  /// between this APInt and RHS that are both set.\n  bool intersects(const APInt &RHS) const {\n    assert(BitWidth == RHS.BitWidth && \"Bit widths must be the same\");\n    if (isSingleWord())\n      return (U.VAL & RHS.U.VAL) != 0;\n    return intersectsSlowCase(RHS);\n  }\n\n  /// This operation checks that all bits set in this APInt are also set in RHS.\n  bool isSubsetOf(const APInt &RHS) const {\n    assert(BitWidth == RHS.BitWidth && \"Bit widths must be the same\");\n    if (isSingleWord())\n      return (U.VAL & ~RHS.U.VAL) == 0;\n    return isSubsetOfSlowCase(RHS);\n  }\n\n  /// @}\n  /// \\name Resizing Operators\n  /// @{\n\n  /// Truncate to new width.\n  ///\n  /// Truncate the APInt to a specified width. It is an error to specify a width\n  /// that is greater than or equal to the current width.\n  APInt trunc(unsigned width) const;\n\n  /// Truncate to new width with unsigned saturation.\n  ///\n  /// If the APInt, treated as unsigned integer, can be losslessly truncated to\n  /// the new bitwidth, then return truncated APInt. Else, return max value.\n  APInt truncUSat(unsigned width) const;\n\n  /// Truncate to new width with signed saturation.\n  ///\n  /// If this APInt, treated as signed integer, can be losslessly truncated to\n  /// the new bitwidth, then return truncated APInt. Else, return either\n  /// signed min value if the APInt was negative, or signed max value.\n  APInt truncSSat(unsigned width) const;\n\n  /// Sign extend to a new width.\n  ///\n  /// This operation sign extends the APInt to a new width. If the high order\n  /// bit is set, the fill on the left will be done with 1 bits, otherwise zero.\n  /// It is an error to specify a width that is less than or equal to the\n  /// current width.\n  APInt sext(unsigned width) const;\n\n  /// Zero extend to a new width.\n  ///\n  /// This operation zero extends the APInt to a new width. The high order bits\n  /// are filled with 0 bits.  It is an error to specify a width that is less\n  /// than or equal to the current width.\n  APInt zext(unsigned width) const;\n\n  /// Sign extend or truncate to width\n  ///\n  /// Make this APInt have the bit width given by \\p width. The value is sign\n  /// extended, truncated, or left alone to make it that width.\n  APInt sextOrTrunc(unsigned width) const;\n\n  /// Zero extend or truncate to width\n  ///\n  /// Make this APInt have the bit width given by \\p width. The value is zero\n  /// extended, truncated, or left alone to make it that width.\n  APInt zextOrTrunc(unsigned width) const;\n\n  /// Truncate to width\n  ///\n  /// Make this APInt have the bit width given by \\p width. The value is\n  /// truncated or left alone to make it that width.\n  APInt truncOrSelf(unsigned width) const;\n\n  /// Sign extend or truncate to width\n  ///\n  /// Make this APInt have the bit width given by \\p width. The value is sign\n  /// extended, or left alone to make it that width.\n  APInt sextOrSelf(unsigned width) const;\n\n  /// Zero extend or truncate to width\n  ///\n  /// Make this APInt have the bit width given by \\p width. The value is zero\n  /// extended, or left alone to make it that width.\n  APInt zextOrSelf(unsigned width) const;\n\n  /// @}\n  /// \\name Bit Manipulation Operators\n  /// @{\n\n  /// Set every bit to 1.\n  void setAllBits() {\n    if (isSingleWord())\n      U.VAL = WORDTYPE_MAX;\n    else\n      // Set all the bits in all the words.\n      memset(U.pVal, -1, getNumWords() * APINT_WORD_SIZE);\n    // Clear the unused ones\n    clearUnusedBits();\n  }\n\n  /// Set a given bit to 1.\n  ///\n  /// Set the given bit to 1 whose position is given as \"bitPosition\".\n  void setBit(unsigned BitPosition) {\n    assert(BitPosition < BitWidth && \"BitPosition out of range\");\n    WordType Mask = maskBit(BitPosition);\n    if (isSingleWord())\n      U.VAL |= Mask;\n    else\n      U.pVal[whichWord(BitPosition)] |= Mask;\n  }\n\n  /// Set the sign bit to 1.\n  void setSignBit() {\n    setBit(BitWidth - 1);\n  }\n\n  /// Set a given bit to a given value.\n  void setBitVal(unsigned BitPosition, bool BitValue) {\n    if (BitValue)\n      setBit(BitPosition);\n    else\n      clearBit(BitPosition);\n  }\n\n  /// Set the bits from loBit (inclusive) to hiBit (exclusive) to 1.\n  /// This function handles \"wrap\" case when \\p loBit >= \\p hiBit, and calls\n  /// setBits when \\p loBit < \\p hiBit.\n  /// For \\p loBit == \\p hiBit wrap case, set every bit to 1.\n  void setBitsWithWrap(unsigned loBit, unsigned hiBit) {\n    assert(hiBit <= BitWidth && \"hiBit out of range\");\n    assert(loBit <= BitWidth && \"loBit out of range\");\n    if (loBit < hiBit) {\n      setBits(loBit, hiBit);\n      return;\n    }\n    setLowBits(hiBit);\n    setHighBits(BitWidth - loBit);\n  }\n\n  /// Set the bits from loBit (inclusive) to hiBit (exclusive) to 1.\n  /// This function handles case when \\p loBit <= \\p hiBit.\n  void setBits(unsigned loBit, unsigned hiBit) {\n    assert(hiBit <= BitWidth && \"hiBit out of range\");\n    assert(loBit <= BitWidth && \"loBit out of range\");\n    assert(loBit <= hiBit && \"loBit greater than hiBit\");\n    if (loBit == hiBit)\n      return;\n    if (loBit < APINT_BITS_PER_WORD && hiBit <= APINT_BITS_PER_WORD) {\n      uint64_t mask = WORDTYPE_MAX >> (APINT_BITS_PER_WORD - (hiBit - loBit));\n      mask <<= loBit;\n      if (isSingleWord())\n        U.VAL |= mask;\n      else\n        U.pVal[0] |= mask;\n    } else {\n      setBitsSlowCase(loBit, hiBit);\n    }\n  }\n\n  /// Set the top bits starting from loBit.\n  void setBitsFrom(unsigned loBit) {\n    return setBits(loBit, BitWidth);\n  }\n\n  /// Set the bottom loBits bits.\n  void setLowBits(unsigned loBits) {\n    return setBits(0, loBits);\n  }\n\n  /// Set the top hiBits bits.\n  void setHighBits(unsigned hiBits) {\n    return setBits(BitWidth - hiBits, BitWidth);\n  }\n\n  /// Set every bit to 0.\n  void clearAllBits() {\n    if (isSingleWord())\n      U.VAL = 0;\n    else\n      memset(U.pVal, 0, getNumWords() * APINT_WORD_SIZE);\n  }\n\n  /// Set a given bit to 0.\n  ///\n  /// Set the given bit to 0 whose position is given as \"bitPosition\".\n  void clearBit(unsigned BitPosition) {\n    assert(BitPosition < BitWidth && \"BitPosition out of range\");\n    WordType Mask = ~maskBit(BitPosition);\n    if (isSingleWord())\n      U.VAL &= Mask;\n    else\n      U.pVal[whichWord(BitPosition)] &= Mask;\n  }\n\n  /// Set bottom loBits bits to 0.\n  void clearLowBits(unsigned loBits) {\n    assert(loBits <= BitWidth && \"More bits than bitwidth\");\n    APInt Keep = getHighBitsSet(BitWidth, BitWidth - loBits);\n    *this &= Keep;\n  }\n\n  /// Set the sign bit to 0.\n  void clearSignBit() {\n    clearBit(BitWidth - 1);\n  }\n\n  /// Toggle every bit to its opposite value.\n  void flipAllBits() {\n    if (isSingleWord()) {\n      U.VAL ^= WORDTYPE_MAX;\n      clearUnusedBits();\n    } else {\n      flipAllBitsSlowCase();\n    }\n  }\n\n  /// Toggles a given bit to its opposite value.\n  ///\n  /// Toggle a given bit to its opposite value whose position is given\n  /// as \"bitPosition\".\n  void flipBit(unsigned bitPosition);\n\n  /// Negate this APInt in place.\n  void negate() {\n    flipAllBits();\n    ++(*this);\n  }\n\n  /// Insert the bits from a smaller APInt starting at bitPosition.\n  void insertBits(const APInt &SubBits, unsigned bitPosition);\n  void insertBits(uint64_t SubBits, unsigned bitPosition, unsigned numBits);\n\n  /// Return an APInt with the extracted bits [bitPosition,bitPosition+numBits).\n  APInt extractBits(unsigned numBits, unsigned bitPosition) const;\n  uint64_t extractBitsAsZExtValue(unsigned numBits, unsigned bitPosition) const;\n\n  /// @}\n  /// \\name Value Characterization Functions\n  /// @{\n\n  /// Return the number of bits in the APInt.\n  unsigned getBitWidth() const { return BitWidth; }\n\n  /// Get the number of words.\n  ///\n  /// Here one word's bitwidth equals to that of uint64_t.\n  ///\n  /// \\returns the number of words to hold the integer value of this APInt.\n  unsigned getNumWords() const { return getNumWords(BitWidth); }\n\n  /// Get the number of words.\n  ///\n  /// *NOTE* Here one word's bitwidth equals to that of uint64_t.\n  ///\n  /// \\returns the number of words to hold the integer value with a given bit\n  /// width.\n  static unsigned getNumWords(unsigned BitWidth) {\n    return ((uint64_t)BitWidth + APINT_BITS_PER_WORD - 1) / APINT_BITS_PER_WORD;\n  }\n\n  /// Compute the number of active bits in the value\n  ///\n  /// This function returns the number of active bits which is defined as the\n  /// bit width minus the number of leading zeros. This is used in several\n  /// computations to see how \"wide\" the value is.\n  unsigned getActiveBits() const { return BitWidth - countLeadingZeros(); }\n\n  /// Compute the number of active words in the value of this APInt.\n  ///\n  /// This is used in conjunction with getActiveData to extract the raw value of\n  /// the APInt.\n  unsigned getActiveWords() const {\n    unsigned numActiveBits = getActiveBits();\n    return numActiveBits ? whichWord(numActiveBits - 1) + 1 : 1;\n  }\n\n  /// Get the minimum bit size for this signed APInt\n  ///\n  /// Computes the minimum bit width for this APInt while considering it to be a\n  /// signed (and probably negative) value. If the value is not negative, this\n  /// function returns the same value as getActiveBits()+1. Otherwise, it\n  /// returns the smallest bit width that will retain the negative value. For\n  /// example, -1 can be written as 0b1 or 0xFFFFFFFFFF. 0b1 is shorter and so\n  /// for -1, this function will always return 1.\n  unsigned getMinSignedBits() const { return BitWidth - getNumSignBits() + 1; }\n\n  /// Get zero extended value\n  ///\n  /// This method attempts to return the value of this APInt as a zero extended\n  /// uint64_t. The bitwidth must be <= 64 or the value must fit within a\n  /// uint64_t. Otherwise an assertion will result.\n  uint64_t getZExtValue() const {\n    if (isSingleWord())\n      return U.VAL;\n    assert(getActiveBits() <= 64 && \"Too many bits for uint64_t\");\n    return U.pVal[0];\n  }\n\n  /// Get sign extended value\n  ///\n  /// This method attempts to return the value of this APInt as a sign extended\n  /// int64_t. The bit width must be <= 64 or the value must fit within an\n  /// int64_t. Otherwise an assertion will result.\n  int64_t getSExtValue() const {\n    if (isSingleWord())\n      return SignExtend64(U.VAL, BitWidth);\n    assert(getMinSignedBits() <= 64 && \"Too many bits for int64_t\");\n    return int64_t(U.pVal[0]);\n  }\n\n  /// Get bits required for string value.\n  ///\n  /// This method determines how many bits are required to hold the APInt\n  /// equivalent of the string given by \\p str.\n  static unsigned getBitsNeeded(StringRef str, uint8_t radix);\n\n  /// The APInt version of the countLeadingZeros functions in\n  ///   MathExtras.h.\n  ///\n  /// It counts the number of zeros from the most significant bit to the first\n  /// one bit.\n  ///\n  /// \\returns BitWidth if the value is zero, otherwise returns the number of\n  ///   zeros from the most significant bit to the first one bits.\n  unsigned countLeadingZeros() const {\n    if (isSingleWord()) {\n      unsigned unusedBits = APINT_BITS_PER_WORD - BitWidth;\n      return llvm::countLeadingZeros(U.VAL) - unusedBits;\n    }\n    return countLeadingZerosSlowCase();\n  }\n\n  /// Count the number of leading one bits.\n  ///\n  /// This function is an APInt version of the countLeadingOnes\n  /// functions in MathExtras.h. It counts the number of ones from the most\n  /// significant bit to the first zero bit.\n  ///\n  /// \\returns 0 if the high order bit is not set, otherwise returns the number\n  /// of 1 bits from the most significant to the least\n  unsigned countLeadingOnes() const {\n    if (isSingleWord())\n      return llvm::countLeadingOnes(U.VAL << (APINT_BITS_PER_WORD - BitWidth));\n    return countLeadingOnesSlowCase();\n  }\n\n  /// Computes the number of leading bits of this APInt that are equal to its\n  /// sign bit.\n  unsigned getNumSignBits() const {\n    return isNegative() ? countLeadingOnes() : countLeadingZeros();\n  }\n\n  /// Count the number of trailing zero bits.\n  ///\n  /// This function is an APInt version of the countTrailingZeros\n  /// functions in MathExtras.h. It counts the number of zeros from the least\n  /// significant bit to the first set bit.\n  ///\n  /// \\returns BitWidth if the value is zero, otherwise returns the number of\n  /// zeros from the least significant bit to the first one bit.\n  unsigned countTrailingZeros() const {\n    if (isSingleWord())\n      return std::min(unsigned(llvm::countTrailingZeros(U.VAL)), BitWidth);\n    return countTrailingZerosSlowCase();\n  }\n\n  /// Count the number of trailing one bits.\n  ///\n  /// This function is an APInt version of the countTrailingOnes\n  /// functions in MathExtras.h. It counts the number of ones from the least\n  /// significant bit to the first zero bit.\n  ///\n  /// \\returns BitWidth if the value is all ones, otherwise returns the number\n  /// of ones from the least significant bit to the first zero bit.\n  unsigned countTrailingOnes() const {\n    if (isSingleWord())\n      return llvm::countTrailingOnes(U.VAL);\n    return countTrailingOnesSlowCase();\n  }\n\n  /// Count the number of bits set.\n  ///\n  /// This function is an APInt version of the countPopulation functions\n  /// in MathExtras.h. It counts the number of 1 bits in the APInt value.\n  ///\n  /// \\returns 0 if the value is zero, otherwise returns the number of set bits.\n  unsigned countPopulation() const {\n    if (isSingleWord())\n      return llvm::countPopulation(U.VAL);\n    return countPopulationSlowCase();\n  }\n\n  /// @}\n  /// \\name Conversion Functions\n  /// @{\n  void print(raw_ostream &OS, bool isSigned) const;\n\n  /// Converts an APInt to a string and append it to Str.  Str is commonly a\n  /// SmallString.\n  void toString(SmallVectorImpl<char> &Str, unsigned Radix, bool Signed,\n                bool formatAsCLiteral = false) const;\n\n  /// Considers the APInt to be unsigned and converts it into a string in the\n  /// radix given. The radix can be 2, 8, 10 16, or 36.\n  void toStringUnsigned(SmallVectorImpl<char> &Str, unsigned Radix = 10) const {\n    toString(Str, Radix, false, false);\n  }\n\n  /// Considers the APInt to be signed and converts it into a string in the\n  /// radix given. The radix can be 2, 8, 10, 16, or 36.\n  void toStringSigned(SmallVectorImpl<char> &Str, unsigned Radix = 10) const {\n    toString(Str, Radix, true, false);\n  }\n\n  /// Return the APInt as a std::string.\n  ///\n  /// Note that this is an inefficient method.  It is better to pass in a\n  /// SmallVector/SmallString to the methods above to avoid thrashing the heap\n  /// for the string.\n  std::string toString(unsigned Radix, bool Signed) const;\n\n  /// \\returns a byte-swapped representation of this APInt Value.\n  APInt byteSwap() const;\n\n  /// \\returns the value with the bit representation reversed of this APInt\n  /// Value.\n  APInt reverseBits() const;\n\n  /// Converts this APInt to a double value.\n  double roundToDouble(bool isSigned) const;\n\n  /// Converts this unsigned APInt to a double value.\n  double roundToDouble() const { return roundToDouble(false); }\n\n  /// Converts this signed APInt to a double value.\n  double signedRoundToDouble() const { return roundToDouble(true); }\n\n  /// Converts APInt bits to a double\n  ///\n  /// The conversion does not do a translation from integer to double, it just\n  /// re-interprets the bits as a double. Note that it is valid to do this on\n  /// any bit width. Exactly 64 bits will be translated.\n  double bitsToDouble() const {\n    return BitsToDouble(getWord(0));\n  }\n\n  /// Converts APInt bits to a float\n  ///\n  /// The conversion does not do a translation from integer to float, it just\n  /// re-interprets the bits as a float. Note that it is valid to do this on\n  /// any bit width. Exactly 32 bits will be translated.\n  float bitsToFloat() const {\n    return BitsToFloat(static_cast<uint32_t>(getWord(0)));\n  }\n\n  /// Converts a double to APInt bits.\n  ///\n  /// The conversion does not do a translation from double to integer, it just\n  /// re-interprets the bits of the double.\n  static APInt doubleToBits(double V) {\n    return APInt(sizeof(double) * CHAR_BIT, DoubleToBits(V));\n  }\n\n  /// Converts a float to APInt bits.\n  ///\n  /// The conversion does not do a translation from float to integer, it just\n  /// re-interprets the bits of the float.\n  static APInt floatToBits(float V) {\n    return APInt(sizeof(float) * CHAR_BIT, FloatToBits(V));\n  }\n\n  /// @}\n  /// \\name Mathematics Operations\n  /// @{\n\n  /// \\returns the floor log base 2 of this APInt.\n  unsigned logBase2() const { return getActiveBits() -  1; }\n\n  /// \\returns the ceil log base 2 of this APInt.\n  unsigned ceilLogBase2() const {\n    APInt temp(*this);\n    --temp;\n    return temp.getActiveBits();\n  }\n\n  /// \\returns the nearest log base 2 of this APInt. Ties round up.\n  ///\n  /// NOTE: When we have a BitWidth of 1, we define:\n  ///\n  ///   log2(0) = UINT32_MAX\n  ///   log2(1) = 0\n  ///\n  /// to get around any mathematical concerns resulting from\n  /// referencing 2 in a space where 2 does no exist.\n  unsigned nearestLogBase2() const {\n    // Special case when we have a bitwidth of 1. If VAL is 1, then we\n    // get 0. If VAL is 0, we get WORDTYPE_MAX which gets truncated to\n    // UINT32_MAX.\n    if (BitWidth == 1)\n      return U.VAL - 1;\n\n    // Handle the zero case.\n    if (isNullValue())\n      return UINT32_MAX;\n\n    // The non-zero case is handled by computing:\n    //\n    //   nearestLogBase2(x) = logBase2(x) + x[logBase2(x)-1].\n    //\n    // where x[i] is referring to the value of the ith bit of x.\n    unsigned lg = logBase2();\n    return lg + unsigned((*this)[lg - 1]);\n  }\n\n  /// \\returns the log base 2 of this APInt if its an exact power of two, -1\n  /// otherwise\n  int32_t exactLogBase2() const {\n    if (!isPowerOf2())\n      return -1;\n    return logBase2();\n  }\n\n  /// Compute the square root\n  APInt sqrt() const;\n\n  /// Get the absolute value;\n  ///\n  /// If *this is < 0 then return -(*this), otherwise *this;\n  APInt abs() const {\n    if (isNegative())\n      return -(*this);\n    return *this;\n  }\n\n  /// \\returns the multiplicative inverse for a given modulo.\n  APInt multiplicativeInverse(const APInt &modulo) const;\n\n  /// @}\n  /// \\name Support for division by constant\n  /// @{\n\n  /// Calculate the magic number for signed division by a constant.\n  struct ms;\n  ms magic() const;\n\n  /// Calculate the magic number for unsigned division by a constant.\n  struct mu;\n  mu magicu(unsigned LeadingZeros = 0) const;\n\n  /// @}\n  /// \\name Building-block Operations for APInt and APFloat\n  /// @{\n\n  // These building block operations operate on a representation of arbitrary\n  // precision, two's-complement, bignum integer values. They should be\n  // sufficient to implement APInt and APFloat bignum requirements. Inputs are\n  // generally a pointer to the base of an array of integer parts, representing\n  // an unsigned bignum, and a count of how many parts there are.\n\n  /// Sets the least significant part of a bignum to the input value, and zeroes\n  /// out higher parts.\n  static void tcSet(WordType *, WordType, unsigned);\n\n  /// Assign one bignum to another.\n  static void tcAssign(WordType *, const WordType *, unsigned);\n\n  /// Returns true if a bignum is zero, false otherwise.\n  static bool tcIsZero(const WordType *, unsigned);\n\n  /// Extract the given bit of a bignum; returns 0 or 1.  Zero-based.\n  static int tcExtractBit(const WordType *, unsigned bit);\n\n  /// Copy the bit vector of width srcBITS from SRC, starting at bit srcLSB, to\n  /// DST, of dstCOUNT parts, such that the bit srcLSB becomes the least\n  /// significant bit of DST.  All high bits above srcBITS in DST are\n  /// zero-filled.\n  static void tcExtract(WordType *, unsigned dstCount,\n                        const WordType *, unsigned srcBits,\n                        unsigned srcLSB);\n\n  /// Set the given bit of a bignum.  Zero-based.\n  static void tcSetBit(WordType *, unsigned bit);\n\n  /// Clear the given bit of a bignum.  Zero-based.\n  static void tcClearBit(WordType *, unsigned bit);\n\n  /// Returns the bit number of the least or most significant set bit of a\n  /// number.  If the input number has no bits set -1U is returned.\n  static unsigned tcLSB(const WordType *, unsigned n);\n  static unsigned tcMSB(const WordType *parts, unsigned n);\n\n  /// Negate a bignum in-place.\n  static void tcNegate(WordType *, unsigned);\n\n  /// DST += RHS + CARRY where CARRY is zero or one.  Returns the carry flag.\n  static WordType tcAdd(WordType *, const WordType *,\n                        WordType carry, unsigned);\n  /// DST += RHS.  Returns the carry flag.\n  static WordType tcAddPart(WordType *, WordType, unsigned);\n\n  /// DST -= RHS + CARRY where CARRY is zero or one. Returns the carry flag.\n  static WordType tcSubtract(WordType *, const WordType *,\n                             WordType carry, unsigned);\n  /// DST -= RHS.  Returns the carry flag.\n  static WordType tcSubtractPart(WordType *, WordType, unsigned);\n\n  /// DST += SRC * MULTIPLIER + PART   if add is true\n  /// DST  = SRC * MULTIPLIER + PART   if add is false\n  ///\n  /// Requires 0 <= DSTPARTS <= SRCPARTS + 1.  If DST overlaps SRC they must\n  /// start at the same point, i.e. DST == SRC.\n  ///\n  /// If DSTPARTS == SRC_PARTS + 1 no overflow occurs and zero is returned.\n  /// Otherwise DST is filled with the least significant DSTPARTS parts of the\n  /// result, and if all of the omitted higher parts were zero return zero,\n  /// otherwise overflow occurred and return one.\n  static int tcMultiplyPart(WordType *dst, const WordType *src,\n                            WordType multiplier, WordType carry,\n                            unsigned srcParts, unsigned dstParts,\n                            bool add);\n\n  /// DST = LHS * RHS, where DST has the same width as the operands and is\n  /// filled with the least significant parts of the result.  Returns one if\n  /// overflow occurred, otherwise zero.  DST must be disjoint from both\n  /// operands.\n  static int tcMultiply(WordType *, const WordType *, const WordType *,\n                        unsigned);\n\n  /// DST = LHS * RHS, where DST has width the sum of the widths of the\n  /// operands. No overflow occurs. DST must be disjoint from both operands.\n  static void tcFullMultiply(WordType *, const WordType *,\n                             const WordType *, unsigned, unsigned);\n\n  /// If RHS is zero LHS and REMAINDER are left unchanged, return one.\n  /// Otherwise set LHS to LHS / RHS with the fractional part discarded, set\n  /// REMAINDER to the remainder, return zero.  i.e.\n  ///\n  ///  OLD_LHS = RHS * LHS + REMAINDER\n  ///\n  /// SCRATCH is a bignum of the same size as the operands and result for use by\n  /// the routine; its contents need not be initialized and are destroyed.  LHS,\n  /// REMAINDER and SCRATCH must be distinct.\n  static int tcDivide(WordType *lhs, const WordType *rhs,\n                      WordType *remainder, WordType *scratch,\n                      unsigned parts);\n\n  /// Shift a bignum left Count bits. Shifted in bits are zero. There are no\n  /// restrictions on Count.\n  static void tcShiftLeft(WordType *, unsigned Words, unsigned Count);\n\n  /// Shift a bignum right Count bits.  Shifted in bits are zero.  There are no\n  /// restrictions on Count.\n  static void tcShiftRight(WordType *, unsigned Words, unsigned Count);\n\n  /// The obvious AND, OR and XOR and complement operations.\n  static void tcAnd(WordType *, const WordType *, unsigned);\n  static void tcOr(WordType *, const WordType *, unsigned);\n  static void tcXor(WordType *, const WordType *, unsigned);\n  static void tcComplement(WordType *, unsigned);\n\n  /// Comparison (unsigned) of two bignums.\n  static int tcCompare(const WordType *, const WordType *, unsigned);\n\n  /// Increment a bignum in-place.  Return the carry flag.\n  static WordType tcIncrement(WordType *dst, unsigned parts) {\n    return tcAddPart(dst, 1, parts);\n  }\n\n  /// Decrement a bignum in-place.  Return the borrow flag.\n  static WordType tcDecrement(WordType *dst, unsigned parts) {\n    return tcSubtractPart(dst, 1, parts);\n  }\n\n  /// Set the least significant BITS and clear the rest.\n  static void tcSetLeastSignificantBits(WordType *, unsigned, unsigned bits);\n\n  /// debug method\n  void dump() const;\n\n  /// @}\n};\n\n/// Magic data for optimising signed division by a constant.\nstruct APInt::ms {\n  APInt m;    ///< magic number\n  unsigned s; ///< shift amount\n};\n\n/// Magic data for optimising unsigned division by a constant.\nstruct APInt::mu {\n  APInt m;    ///< magic number\n  bool a;     ///< add indicator\n  unsigned s; ///< shift amount\n};\n\ninline bool operator==(uint64_t V1, const APInt &V2) { return V2 == V1; }\n\ninline bool operator!=(uint64_t V1, const APInt &V2) { return V2 != V1; }\n\n/// Unary bitwise complement operator.\n///\n/// \\returns an APInt that is the bitwise complement of \\p v.\ninline APInt operator~(APInt v) {\n  v.flipAllBits();\n  return v;\n}\n\ninline APInt operator&(APInt a, const APInt &b) {\n  a &= b;\n  return a;\n}\n\ninline APInt operator&(const APInt &a, APInt &&b) {\n  b &= a;\n  return std::move(b);\n}\n\ninline APInt operator&(APInt a, uint64_t RHS) {\n  a &= RHS;\n  return a;\n}\n\ninline APInt operator&(uint64_t LHS, APInt b) {\n  b &= LHS;\n  return b;\n}\n\ninline APInt operator|(APInt a, const APInt &b) {\n  a |= b;\n  return a;\n}\n\ninline APInt operator|(const APInt &a, APInt &&b) {\n  b |= a;\n  return std::move(b);\n}\n\ninline APInt operator|(APInt a, uint64_t RHS) {\n  a |= RHS;\n  return a;\n}\n\ninline APInt operator|(uint64_t LHS, APInt b) {\n  b |= LHS;\n  return b;\n}\n\ninline APInt operator^(APInt a, const APInt &b) {\n  a ^= b;\n  return a;\n}\n\ninline APInt operator^(const APInt &a, APInt &&b) {\n  b ^= a;\n  return std::move(b);\n}\n\ninline APInt operator^(APInt a, uint64_t RHS) {\n  a ^= RHS;\n  return a;\n}\n\ninline APInt operator^(uint64_t LHS, APInt b) {\n  b ^= LHS;\n  return b;\n}\n\ninline raw_ostream &operator<<(raw_ostream &OS, const APInt &I) {\n  I.print(OS, true);\n  return OS;\n}\n\ninline APInt operator-(APInt v) {\n  v.negate();\n  return v;\n}\n\ninline APInt operator+(APInt a, const APInt &b) {\n  a += b;\n  return a;\n}\n\ninline APInt operator+(const APInt &a, APInt &&b) {\n  b += a;\n  return std::move(b);\n}\n\ninline APInt operator+(APInt a, uint64_t RHS) {\n  a += RHS;\n  return a;\n}\n\ninline APInt operator+(uint64_t LHS, APInt b) {\n  b += LHS;\n  return b;\n}\n\ninline APInt operator-(APInt a, const APInt &b) {\n  a -= b;\n  return a;\n}\n\ninline APInt operator-(const APInt &a, APInt &&b) {\n  b.negate();\n  b += a;\n  return std::move(b);\n}\n\ninline APInt operator-(APInt a, uint64_t RHS) {\n  a -= RHS;\n  return a;\n}\n\ninline APInt operator-(uint64_t LHS, APInt b) {\n  b.negate();\n  b += LHS;\n  return b;\n}\n\ninline APInt operator*(APInt a, uint64_t RHS) {\n  a *= RHS;\n  return a;\n}\n\ninline APInt operator*(uint64_t LHS, APInt b) {\n  b *= LHS;\n  return b;\n}\n\n\nnamespace APIntOps {\n\n/// Determine the smaller of two APInts considered to be signed.\ninline const APInt &smin(const APInt &A, const APInt &B) {\n  return A.slt(B) ? A : B;\n}\n\n/// Determine the larger of two APInts considered to be signed.\ninline const APInt &smax(const APInt &A, const APInt &B) {\n  return A.sgt(B) ? A : B;\n}\n\n/// Determine the smaller of two APInts considered to be signed.\ninline const APInt &umin(const APInt &A, const APInt &B) {\n  return A.ult(B) ? A : B;\n}\n\n/// Determine the larger of two APInts considered to be unsigned.\ninline const APInt &umax(const APInt &A, const APInt &B) {\n  return A.ugt(B) ? A : B;\n}\n\n/// Compute GCD of two unsigned APInt values.\n///\n/// This function returns the greatest common divisor of the two APInt values\n/// using Stein's algorithm.\n///\n/// \\returns the greatest common divisor of A and B.\nAPInt GreatestCommonDivisor(APInt A, APInt B);\n\n/// Converts the given APInt to a double value.\n///\n/// Treats the APInt as an unsigned value for conversion purposes.\ninline double RoundAPIntToDouble(const APInt &APIVal) {\n  return APIVal.roundToDouble();\n}\n\n/// Converts the given APInt to a double value.\n///\n/// Treats the APInt as a signed value for conversion purposes.\ninline double RoundSignedAPIntToDouble(const APInt &APIVal) {\n  return APIVal.signedRoundToDouble();\n}\n\n/// Converts the given APInt to a float vlalue.\ninline float RoundAPIntToFloat(const APInt &APIVal) {\n  return float(RoundAPIntToDouble(APIVal));\n}\n\n/// Converts the given APInt to a float value.\n///\n/// Treats the APInt as a signed value for conversion purposes.\ninline float RoundSignedAPIntToFloat(const APInt &APIVal) {\n  return float(APIVal.signedRoundToDouble());\n}\n\n/// Converts the given double value into a APInt.\n///\n/// This function convert a double value to an APInt value.\nAPInt RoundDoubleToAPInt(double Double, unsigned width);\n\n/// Converts a float value into a APInt.\n///\n/// Converts a float value into an APInt value.\ninline APInt RoundFloatToAPInt(float Float, unsigned width) {\n  return RoundDoubleToAPInt(double(Float), width);\n}\n\n/// Return A unsign-divided by B, rounded by the given rounding mode.\nAPInt RoundingUDiv(const APInt &A, const APInt &B, APInt::Rounding RM);\n\n/// Return A sign-divided by B, rounded by the given rounding mode.\nAPInt RoundingSDiv(const APInt &A, const APInt &B, APInt::Rounding RM);\n\n/// Let q(n) = An^2 + Bn + C, and BW = bit width of the value range\n/// (e.g. 32 for i32).\n/// This function finds the smallest number n, such that\n/// (a) n >= 0 and q(n) = 0, or\n/// (b) n >= 1 and q(n-1) and q(n), when evaluated in the set of all\n///     integers, belong to two different intervals [Rk, Rk+R),\n///     where R = 2^BW, and k is an integer.\n/// The idea here is to find when q(n) \"overflows\" 2^BW, while at the\n/// same time \"allowing\" subtraction. In unsigned modulo arithmetic a\n/// subtraction (treated as addition of negated numbers) would always\n/// count as an overflow, but here we want to allow values to decrease\n/// and increase as long as they are within the same interval.\n/// Specifically, adding of two negative numbers should not cause an\n/// overflow (as long as the magnitude does not exceed the bit width).\n/// On the other hand, given a positive number, adding a negative\n/// number to it can give a negative result, which would cause the\n/// value to go from [-2^BW, 0) to [0, 2^BW). In that sense, zero is\n/// treated as a special case of an overflow.\n///\n/// This function returns None if after finding k that minimizes the\n/// positive solution to q(n) = kR, both solutions are contained between\n/// two consecutive integers.\n///\n/// There are cases where q(n) > T, and q(n+1) < T (assuming evaluation\n/// in arithmetic modulo 2^BW, and treating the values as signed) by the\n/// virtue of *signed* overflow. This function will *not* find such an n,\n/// however it may find a value of n satisfying the inequalities due to\n/// an *unsigned* overflow (if the values are treated as unsigned).\n/// To find a solution for a signed overflow, treat it as a problem of\n/// finding an unsigned overflow with a range with of BW-1.\n///\n/// The returned value may have a different bit width from the input\n/// coefficients.\nOptional<APInt> SolveQuadraticEquationWrap(APInt A, APInt B, APInt C,\n                                           unsigned RangeWidth);\n\n/// Compare two values, and if they are different, return the position of the\n/// most significant bit that is different in the values.\nOptional<unsigned> GetMostSignificantDifferentBit(const APInt &A,\n                                                  const APInt &B);\n\n} // End of APIntOps namespace\n\n// See friend declaration above. This additional declaration is required in\n// order to compile LLVM with IBM xlC compiler.\nhash_code hash_value(const APInt &Arg);\n\n/// StoreIntToMemory - Fills the StoreBytes bytes of memory starting from Dst\n/// with the integer held in IntVal.\nvoid StoreIntToMemory(const APInt &IntVal, uint8_t *Dst, unsigned StoreBytes);\n\n/// LoadIntFromMemory - Loads the integer stored in the LoadBytes bytes starting\n/// from Src into IntVal, which is assumed to be wide enough and to hold zero.\nvoid LoadIntFromMemory(APInt &IntVal, const uint8_t *Src, unsigned LoadBytes);\n\n} // namespace llvm\n\n#endif\n"}}, "reports": [{"events": [{"location": {"col": 13, "file": 1, "line": 91}, "message": "the definition seen here"}, {"location": {"col": 8, "file": 0, "line": 200}, "message": "differing parameters are named here: ('array'), in definition: ('bigVal')"}, {"location": {"col": 8, "file": 0, "line": 200}, "message": "function 'llvm::APInt::initFromArray' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APInt.h", "reportHash": "712a05ee67b5a9d9b5fb0e2b7fe89857", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 12, "file": 1, "line": 2669}, "message": "the definition seen here"}, {"location": {"col": 14, "file": 0, "line": 1982}, "message": "differing parameters are named here: ('scratch'), in definition: ('srhs')"}, {"location": {"col": 14, "file": 0, "line": 1982}, "message": "function 'llvm::APInt::tcDivide' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APInt.h", "reportHash": "cbd7fcaae41398eb9f0cdb19cf36a1b8", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
