<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"4": {"id": 4, "path": "/home/vsts/work/1/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp", "content": "//===- ScalarEvolutionExpander.cpp - Scalar Evolution Analysis ------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file contains the implementation of the scalar evolution expander,\n// which is used to generate the code corresponding to a given scalar evolution\n// expression.\n//\n//===----------------------------------------------------------------------===//\n\n#include \"llvm/Transforms/Utils/ScalarEvolutionExpander.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallSet.h\"\n#include \"llvm/Analysis/InstructionSimplify.h\"\n#include \"llvm/Analysis/LoopInfo.h\"\n#include \"llvm/Analysis/TargetTransformInfo.h\"\n#include \"llvm/IR/DataLayout.h\"\n#include \"llvm/IR/Dominators.h\"\n#include \"llvm/IR/IntrinsicInst.h\"\n#include \"llvm/IR/LLVMContext.h\"\n#include \"llvm/IR/Module.h\"\n#include \"llvm/IR/PatternMatch.h\"\n#include \"llvm/Support/CommandLine.h\"\n#include \"llvm/Support/Debug.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include \"llvm/Transforms/Utils/LoopUtils.h\"\n\nusing namespace llvm;\n\ncl::opt<unsigned> llvm::SCEVCheapExpansionBudget(\n    \"scev-cheap-expansion-budget\", cl::Hidden, cl::init(4),\n    cl::desc(\"When performing SCEV expansion only if it is cheap to do, this \"\n             \"controls the budget that is considered cheap (default = 4)\"));\n\nusing namespace PatternMatch;\n\n/// ReuseOrCreateCast - Arrange for there to be a cast of V to Ty at IP,\n/// reusing an existing cast if a suitable one (= dominating IP) exists, or\n/// creating a new one.\nValue *SCEVExpander::ReuseOrCreateCast(Value *V, Type *Ty,\n                                       Instruction::CastOps Op,\n                                       BasicBlock::iterator IP) {\n  // This function must be called with the builder having a valid insertion\n  // point. It doesn't need to be the actual IP where the uses of the returned\n  // cast will be added, but it must dominate such IP.\n  // We use this precondition to produce a cast that will dominate all its\n  // uses. In particular, this is crucial for the case where the builder's\n  // insertion point *is* the point where we were asked to put the cast.\n  // Since we don't know the builder's insertion point is actually\n  // where the uses will be added (only that it dominates it), we are\n  // not allowed to move it.\n  BasicBlock::iterator BIP = Builder.GetInsertPoint();\n\n  Instruction *Ret = nullptr;\n\n  // Check to see if there is already a cast!\n  for (User *U : V->users()) {\n    if (U->getType() != Ty)\n      continue;\n    CastInst *CI = dyn_cast<CastInst>(U);\n    if (!CI || CI->getOpcode() != Op)\n      continue;\n\n    // Found a suitable cast that is at IP or comes before IP. Use it. Note that\n    // the cast must also properly dominate the Builder's insertion point.\n    if (IP->getParent() == CI->getParent() && &*BIP != CI &&\n        (&*IP == CI || CI->comesBefore(&*IP))) {\n      Ret = CI;\n      break;\n    }\n  }\n\n  // Create a new cast.\n  if (!Ret) {\n    Ret = CastInst::Create(Op, V, Ty, V->getName(), &*IP);\n    rememberInstruction(Ret);\n  }\n\n  // We assert at the end of the function since IP might point to an\n  // instruction with different dominance properties than a cast\n  // (an invoke for example) and not dominate BIP (but the cast does).\n  assert(SE.DT.dominates(Ret, &*BIP));\n\n  return Ret;\n}\n\nBasicBlock::iterator\nSCEVExpander::findInsertPointAfter(Instruction *I, Instruction *MustDominate) {\n  BasicBlock::iterator IP = ++I->getIterator();\n  if (auto *II = dyn_cast<InvokeInst>(I))\n    IP = II->getNormalDest()->begin();\n\n  while (isa<PHINode>(IP))\n    ++IP;\n\n  if (isa<FuncletPadInst>(IP) || isa<LandingPadInst>(IP)) {\n    ++IP;\n  } else if (isa<CatchSwitchInst>(IP)) {\n    IP = MustDominate->getParent()->getFirstInsertionPt();\n  } else {\n    assert(!IP->isEHPad() && \"unexpected eh pad!\");\n  }\n\n  // Adjust insert point to be after instructions inserted by the expander, so\n  // we can re-use already inserted instructions. Avoid skipping past the\n  // original \\p MustDominate, in case it is an inserted instruction.\n  while (isInsertedInstruction(&*IP) && &*IP != MustDominate)\n    ++IP;\n\n  return IP;\n}\n\n/// InsertNoopCastOfTo - Insert a cast of V to the specified type,\n/// which must be possible with a noop cast, doing what we can to share\n/// the casts.\nValue *SCEVExpander::InsertNoopCastOfTo(Value *V, Type *Ty) {\n  Instruction::CastOps Op = CastInst::getCastOpcode(V, false, Ty, false);\n  assert((Op == Instruction::BitCast ||\n          Op == Instruction::PtrToInt ||\n          Op == Instruction::IntToPtr) &&\n         \"InsertNoopCastOfTo cannot perform non-noop casts!\");\n  assert(SE.getTypeSizeInBits(V->getType()) == SE.getTypeSizeInBits(Ty) &&\n         \"InsertNoopCastOfTo cannot change sizes!\");\n\n  // inttoptr only works for integral pointers. For non-integral pointers, we\n  // can create a GEP on i8* null  with the integral value as index. Note that\n  // it is safe to use GEP of null instead of inttoptr here, because only\n  // expressions already based on a GEP of null should be converted to pointers\n  // during expansion.\n  if (Op == Instruction::IntToPtr) {\n    auto *PtrTy = cast<PointerType>(Ty);\n    if (DL.isNonIntegralPointerType(PtrTy)) {\n      auto *Int8PtrTy = Builder.getInt8PtrTy(PtrTy->getAddressSpace());\n      assert(DL.getTypeAllocSize(Int8PtrTy->getElementType()) == 1 &&\n             \"alloc size of i8 must by 1 byte for the GEP to be correct\");\n      auto *GEP = Builder.CreateGEP(\n          Builder.getInt8Ty(), Constant::getNullValue(Int8PtrTy), V, \"uglygep\");\n      return Builder.CreateBitCast(GEP, Ty);\n    }\n  }\n  // Short-circuit unnecessary bitcasts.\n  if (Op == Instruction::BitCast) {\n    if (V->getType() == Ty)\n      return V;\n    if (CastInst *CI = dyn_cast<CastInst>(V)) {\n      if (CI->getOperand(0)->getType() == Ty)\n        return CI->getOperand(0);\n    }\n  }\n  // Short-circuit unnecessary inttoptr<->ptrtoint casts.\n  if ((Op == Instruction::PtrToInt || Op == Instruction::IntToPtr) &&\n      SE.getTypeSizeInBits(Ty) == SE.getTypeSizeInBits(V->getType())) {\n    if (CastInst *CI = dyn_cast<CastInst>(V))\n      if ((CI->getOpcode() == Instruction::PtrToInt ||\n           CI->getOpcode() == Instruction::IntToPtr) &&\n          SE.getTypeSizeInBits(CI->getType()) ==\n          SE.getTypeSizeInBits(CI->getOperand(0)->getType()))\n        return CI->getOperand(0);\n    if (ConstantExpr *CE = dyn_cast<ConstantExpr>(V))\n      if ((CE->getOpcode() == Instruction::PtrToInt ||\n           CE->getOpcode() == Instruction::IntToPtr) &&\n          SE.getTypeSizeInBits(CE->getType()) ==\n          SE.getTypeSizeInBits(CE->getOperand(0)->getType()))\n        return CE->getOperand(0);\n  }\n\n  // Fold a cast of a constant.\n  if (Constant *C = dyn_cast<Constant>(V))\n    return ConstantExpr::getCast(Op, C, Ty);\n\n  // Cast the argument at the beginning of the entry block, after\n  // any bitcasts of other arguments.\n  if (Argument *A = dyn_cast<Argument>(V)) {\n    BasicBlock::iterator IP = A->getParent()->getEntryBlock().begin();\n    while ((isa<BitCastInst>(IP) &&\n            isa<Argument>(cast<BitCastInst>(IP)->getOperand(0)) &&\n            cast<BitCastInst>(IP)->getOperand(0) != A) ||\n           isa<DbgInfoIntrinsic>(IP))\n      ++IP;\n    return ReuseOrCreateCast(A, Ty, Op, IP);\n  }\n\n  // Cast the instruction immediately after the instruction.\n  Instruction *I = cast<Instruction>(V);\n  BasicBlock::iterator IP = findInsertPointAfter(I, &*Builder.GetInsertPoint());\n  return ReuseOrCreateCast(I, Ty, Op, IP);\n}\n\n/// InsertBinop - Insert the specified binary operator, doing a small amount\n/// of work to avoid inserting an obviously redundant operation, and hoisting\n/// to an outer loop when the opportunity is there and it is safe.\nValue *SCEVExpander::InsertBinop(Instruction::BinaryOps Opcode,\n                                 Value *LHS, Value *RHS,\n                                 SCEV::NoWrapFlags Flags, bool IsSafeToHoist) {\n  // Fold a binop with constant operands.\n  if (Constant *CLHS = dyn_cast<Constant>(LHS))\n    if (Constant *CRHS = dyn_cast<Constant>(RHS))\n      return ConstantExpr::get(Opcode, CLHS, CRHS);\n\n  // Do a quick scan to see if we have this binop nearby.  If so, reuse it.\n  unsigned ScanLimit = 6;\n  BasicBlock::iterator BlockBegin = Builder.GetInsertBlock()->begin();\n  // Scanning starts from the last instruction before the insertion point.\n  BasicBlock::iterator IP = Builder.GetInsertPoint();\n  if (IP != BlockBegin) {\n    --IP;\n    for (; ScanLimit; --IP, --ScanLimit) {\n      // Don't count dbg.value against the ScanLimit, to avoid perturbing the\n      // generated code.\n      if (isa<DbgInfoIntrinsic>(IP))\n        ScanLimit++;\n\n      auto canGenerateIncompatiblePoison = [&Flags](Instruction *I) {\n        // Ensure that no-wrap flags match.\n        if (isa<OverflowingBinaryOperator>(I)) {\n          if (I->hasNoSignedWrap() != (Flags & SCEV::FlagNSW))\n            return true;\n          if (I->hasNoUnsignedWrap() != (Flags & SCEV::FlagNUW))\n            return true;\n        }\n        // Conservatively, do not use any instruction which has any of exact\n        // flags installed.\n        if (isa<PossiblyExactOperator>(I) && I->isExact())\n          return true;\n        return false;\n      };\n      if (IP->getOpcode() == (unsigned)Opcode && IP->getOperand(0) == LHS &&\n          IP->getOperand(1) == RHS && !canGenerateIncompatiblePoison(&*IP))\n        return &*IP;\n      if (IP == BlockBegin) break;\n    }\n  }\n\n  // Save the original insertion point so we can restore it when we're done.\n  DebugLoc Loc = Builder.GetInsertPoint()->getDebugLoc();\n  SCEVInsertPointGuard Guard(Builder, this);\n\n  if (IsSafeToHoist) {\n    // Move the insertion point out of as many loops as we can.\n    while (const Loop *L = SE.LI.getLoopFor(Builder.GetInsertBlock())) {\n      if (!L->isLoopInvariant(LHS) || !L->isLoopInvariant(RHS)) break;\n      BasicBlock *Preheader = L->getLoopPreheader();\n      if (!Preheader) break;\n\n      // Ok, move up a level.\n      Builder.SetInsertPoint(Preheader->getTerminator());\n    }\n  }\n\n  // If we haven't found this binop, insert it.\n  Instruction *BO = cast<Instruction>(Builder.CreateBinOp(Opcode, LHS, RHS));\n  BO->setDebugLoc(Loc);\n  if (Flags & SCEV::FlagNUW)\n    BO->setHasNoUnsignedWrap();\n  if (Flags & SCEV::FlagNSW)\n    BO->setHasNoSignedWrap();\n\n  return BO;\n}\n\n/// FactorOutConstant - Test if S is divisible by Factor, using signed\n/// division. If so, update S with Factor divided out and return true.\n/// S need not be evenly divisible if a reasonable remainder can be\n/// computed.\nstatic bool FactorOutConstant(const SCEV *&S, const SCEV *&Remainder,\n                              const SCEV *Factor, ScalarEvolution &SE,\n                              const DataLayout &DL) {\n  // Everything is divisible by one.\n  if (Factor->isOne())\n    return true;\n\n  // x/x == 1.\n  if (S == Factor) {\n    S = SE.getConstant(S->getType(), 1);\n    return true;\n  }\n\n  // For a Constant, check for a multiple of the given factor.\n  if (const SCEVConstant *C = dyn_cast<SCEVConstant>(S)) {\n    // 0/x == 0.\n    if (C->isZero())\n      return true;\n    // Check for divisibility.\n    if (const SCEVConstant *FC = dyn_cast<SCEVConstant>(Factor)) {\n      ConstantInt *CI =\n          ConstantInt::get(SE.getContext(), C->getAPInt().sdiv(FC->getAPInt()));\n      // If the quotient is zero and the remainder is non-zero, reject\n      // the value at this scale. It will be considered for subsequent\n      // smaller scales.\n      if (!CI->isZero()) {\n        const SCEV *Div = SE.getConstant(CI);\n        S = Div;\n        Remainder = SE.getAddExpr(\n            Remainder, SE.getConstant(C->getAPInt().srem(FC->getAPInt())));\n        return true;\n      }\n    }\n  }\n\n  // In a Mul, check if there is a constant operand which is a multiple\n  // of the given factor.\n  if (const SCEVMulExpr *M = dyn_cast<SCEVMulExpr>(S)) {\n    // Size is known, check if there is a constant operand which is a multiple\n    // of the given factor. If so, we can factor it.\n    if (const SCEVConstant *FC = dyn_cast<SCEVConstant>(Factor))\n      if (const SCEVConstant *C = dyn_cast<SCEVConstant>(M->getOperand(0)))\n        if (!C->getAPInt().srem(FC->getAPInt())) {\n          SmallVector<const SCEV *, 4> NewMulOps(M->operands());\n          NewMulOps[0] = SE.getConstant(C->getAPInt().sdiv(FC->getAPInt()));\n          S = SE.getMulExpr(NewMulOps);\n          return true;\n        }\n  }\n\n  // In an AddRec, check if both start and step are divisible.\n  if (const SCEVAddRecExpr *A = dyn_cast<SCEVAddRecExpr>(S)) {\n    const SCEV *Step = A->getStepRecurrence(SE);\n    const SCEV *StepRem = SE.getConstant(Step->getType(), 0);\n    if (!FactorOutConstant(Step, StepRem, Factor, SE, DL))\n      return false;\n    if (!StepRem->isZero())\n      return false;\n    const SCEV *Start = A->getStart();\n    if (!FactorOutConstant(Start, Remainder, Factor, SE, DL))\n      return false;\n    S = SE.getAddRecExpr(Start, Step, A->getLoop(),\n                         A->getNoWrapFlags(SCEV::FlagNW));\n    return true;\n  }\n\n  return false;\n}\n\n/// SimplifyAddOperands - Sort and simplify a list of add operands. NumAddRecs\n/// is the number of SCEVAddRecExprs present, which are kept at the end of\n/// the list.\n///\nstatic void SimplifyAddOperands(SmallVectorImpl<const SCEV *> &Ops,\n                                Type *Ty,\n                                ScalarEvolution &SE) {\n  unsigned NumAddRecs = 0;\n  for (unsigned i = Ops.size(); i > 0 && isa<SCEVAddRecExpr>(Ops[i-1]); --i)\n    ++NumAddRecs;\n  // Group Ops into non-addrecs and addrecs.\n  SmallVector<const SCEV *, 8> NoAddRecs(Ops.begin(), Ops.end() - NumAddRecs);\n  SmallVector<const SCEV *, 8> AddRecs(Ops.end() - NumAddRecs, Ops.end());\n  // Let ScalarEvolution sort and simplify the non-addrecs list.\n  const SCEV *Sum = NoAddRecs.empty() ?\n                    SE.getConstant(Ty, 0) :\n                    SE.getAddExpr(NoAddRecs);\n  // If it returned an add, use the operands. Otherwise it simplified\n  // the sum into a single value, so just use that.\n  Ops.clear();\n  if (const SCEVAddExpr *Add = dyn_cast<SCEVAddExpr>(Sum))\n    Ops.append(Add->op_begin(), Add->op_end());\n  else if (!Sum->isZero())\n    Ops.push_back(Sum);\n  // Then append the addrecs.\n  Ops.append(AddRecs.begin(), AddRecs.end());\n}\n\n/// SplitAddRecs - Flatten a list of add operands, moving addrec start values\n/// out to the top level. For example, convert {a + b,+,c} to a, b, {0,+,d}.\n/// This helps expose more opportunities for folding parts of the expressions\n/// into GEP indices.\n///\nstatic void SplitAddRecs(SmallVectorImpl<const SCEV *> &Ops,\n                         Type *Ty,\n                         ScalarEvolution &SE) {\n  // Find the addrecs.\n  SmallVector<const SCEV *, 8> AddRecs;\n  for (unsigned i = 0, e = Ops.size(); i != e; ++i)\n    while (const SCEVAddRecExpr *A = dyn_cast<SCEVAddRecExpr>(Ops[i])) {\n      const SCEV *Start = A->getStart();\n      if (Start->isZero()) break;\n      const SCEV *Zero = SE.getConstant(Ty, 0);\n      AddRecs.push_back(SE.getAddRecExpr(Zero,\n                                         A->getStepRecurrence(SE),\n                                         A->getLoop(),\n                                         A->getNoWrapFlags(SCEV::FlagNW)));\n      if (const SCEVAddExpr *Add = dyn_cast<SCEVAddExpr>(Start)) {\n        Ops[i] = Zero;\n        Ops.append(Add->op_begin(), Add->op_end());\n        e += Add->getNumOperands();\n      } else {\n        Ops[i] = Start;\n      }\n    }\n  if (!AddRecs.empty()) {\n    // Add the addrecs onto the end of the list.\n    Ops.append(AddRecs.begin(), AddRecs.end());\n    // Resort the operand list, moving any constants to the front.\n    SimplifyAddOperands(Ops, Ty, SE);\n  }\n}\n\n/// expandAddToGEP - Expand an addition expression with a pointer type into\n/// a GEP instead of using ptrtoint+arithmetic+inttoptr. This helps\n/// BasicAliasAnalysis and other passes analyze the result. See the rules\n/// for getelementptr vs. inttoptr in\n/// http://llvm.org/docs/LangRef.html#pointeraliasing\n/// for details.\n///\n/// Design note: The correctness of using getelementptr here depends on\n/// ScalarEvolution not recognizing inttoptr and ptrtoint operators, as\n/// they may introduce pointer arithmetic which may not be safely converted\n/// into getelementptr.\n///\n/// Design note: It might seem desirable for this function to be more\n/// loop-aware. If some of the indices are loop-invariant while others\n/// aren't, it might seem desirable to emit multiple GEPs, keeping the\n/// loop-invariant portions of the overall computation outside the loop.\n/// However, there are a few reasons this is not done here. Hoisting simple\n/// arithmetic is a low-level optimization that often isn't very\n/// important until late in the optimization process. In fact, passes\n/// like InstructionCombining will combine GEPs, even if it means\n/// pushing loop-invariant computation down into loops, so even if the\n/// GEPs were split here, the work would quickly be undone. The\n/// LoopStrengthReduction pass, which is usually run quite late (and\n/// after the last InstructionCombining pass), takes care of hoisting\n/// loop-invariant portions of expressions, after considering what\n/// can be folded using target addressing modes.\n///\nValue *SCEVExpander::expandAddToGEP(const SCEV *const *op_begin,\n                                    const SCEV *const *op_end,\n                                    PointerType *PTy,\n                                    Type *Ty,\n                                    Value *V) {\n  Type *OriginalElTy = PTy->getElementType();\n  Type *ElTy = OriginalElTy;\n  SmallVector<Value *, 4> GepIndices;\n  SmallVector<const SCEV *, 8> Ops(op_begin, op_end);\n  bool AnyNonZeroIndices = false;\n\n  // Split AddRecs up into parts as either of the parts may be usable\n  // without the other.\n  SplitAddRecs(Ops, Ty, SE);\n\n  Type *IntIdxTy = DL.getIndexType(PTy);\n\n  // Descend down the pointer's type and attempt to convert the other\n  // operands into GEP indices, at each level. The first index in a GEP\n  // indexes into the array implied by the pointer operand; the rest of\n  // the indices index into the element or field type selected by the\n  // preceding index.\n  for (;;) {\n    // If the scale size is not 0, attempt to factor out a scale for\n    // array indexing.\n    SmallVector<const SCEV *, 8> ScaledOps;\n    if (ElTy->isSized()) {\n      const SCEV *ElSize = SE.getSizeOfExpr(IntIdxTy, ElTy);\n      if (!ElSize->isZero()) {\n        SmallVector<const SCEV *, 8> NewOps;\n        for (const SCEV *Op : Ops) {\n          const SCEV *Remainder = SE.getConstant(Ty, 0);\n          if (FactorOutConstant(Op, Remainder, ElSize, SE, DL)) {\n            // Op now has ElSize factored out.\n            ScaledOps.push_back(Op);\n            if (!Remainder->isZero())\n              NewOps.push_back(Remainder);\n            AnyNonZeroIndices = true;\n          } else {\n            // The operand was not divisible, so add it to the list of operands\n            // we'll scan next iteration.\n            NewOps.push_back(Op);\n          }\n        }\n        // If we made any changes, update Ops.\n        if (!ScaledOps.empty()) {\n          Ops = NewOps;\n          SimplifyAddOperands(Ops, Ty, SE);\n        }\n      }\n    }\n\n    // Record the scaled array index for this level of the type. If\n    // we didn't find any operands that could be factored, tentatively\n    // assume that element zero was selected (since the zero offset\n    // would obviously be folded away).\n    Value *Scaled =\n        ScaledOps.empty()\n            ? Constant::getNullValue(Ty)\n            : expandCodeForImpl(SE.getAddExpr(ScaledOps), Ty, false);\n    GepIndices.push_back(Scaled);\n\n    // Collect struct field index operands.\n    while (StructType *STy = dyn_cast<StructType>(ElTy)) {\n      bool FoundFieldNo = false;\n      // An empty struct has no fields.\n      if (STy->getNumElements() == 0) break;\n      // Field offsets are known. See if a constant offset falls within any of\n      // the struct fields.\n      if (Ops.empty())\n        break;\n      if (const SCEVConstant *C = dyn_cast<SCEVConstant>(Ops[0]))\n        if (SE.getTypeSizeInBits(C->getType()) <= 64) {\n          const StructLayout &SL = *DL.getStructLayout(STy);\n          uint64_t FullOffset = C->getValue()->getZExtValue();\n          if (FullOffset < SL.getSizeInBytes()) {\n            unsigned ElIdx = SL.getElementContainingOffset(FullOffset);\n            GepIndices.push_back(\n                ConstantInt::get(Type::getInt32Ty(Ty->getContext()), ElIdx));\n            ElTy = STy->getTypeAtIndex(ElIdx);\n            Ops[0] =\n                SE.getConstant(Ty, FullOffset - SL.getElementOffset(ElIdx));\n            AnyNonZeroIndices = true;\n            FoundFieldNo = true;\n          }\n        }\n      // If no struct field offsets were found, tentatively assume that\n      // field zero was selected (since the zero offset would obviously\n      // be folded away).\n      if (!FoundFieldNo) {\n        ElTy = STy->getTypeAtIndex(0u);\n        GepIndices.push_back(\n          Constant::getNullValue(Type::getInt32Ty(Ty->getContext())));\n      }\n    }\n\n    if (ArrayType *ATy = dyn_cast<ArrayType>(ElTy))\n      ElTy = ATy->getElementType();\n    else\n      // FIXME: Handle VectorType.\n      // E.g., If ElTy is scalable vector, then ElSize is not a compile-time\n      // constant, therefore can not be factored out. The generated IR is less\n      // ideal with base 'V' cast to i8* and do ugly getelementptr over that.\n      break;\n  }\n\n  // If none of the operands were convertible to proper GEP indices, cast\n  // the base to i8* and do an ugly getelementptr with that. It's still\n  // better than ptrtoint+arithmetic+inttoptr at least.\n  if (!AnyNonZeroIndices) {\n    // Cast the base to i8*.\n    V = InsertNoopCastOfTo(V,\n       Type::getInt8PtrTy(Ty->getContext(), PTy->getAddressSpace()));\n\n    assert(!isa<Instruction>(V) ||\n           SE.DT.dominates(cast<Instruction>(V), &*Builder.GetInsertPoint()));\n\n    // Expand the operands for a plain byte offset.\n    Value *Idx = expandCodeForImpl(SE.getAddExpr(Ops), Ty, false);\n\n    // Fold a GEP with constant operands.\n    if (Constant *CLHS = dyn_cast<Constant>(V))\n      if (Constant *CRHS = dyn_cast<Constant>(Idx))\n        return ConstantExpr::getGetElementPtr(Type::getInt8Ty(Ty->getContext()),\n                                              CLHS, CRHS);\n\n    // Do a quick scan to see if we have this GEP nearby.  If so, reuse it.\n    unsigned ScanLimit = 6;\n    BasicBlock::iterator BlockBegin = Builder.GetInsertBlock()->begin();\n    // Scanning starts from the last instruction before the insertion point.\n    BasicBlock::iterator IP = Builder.GetInsertPoint();\n    if (IP != BlockBegin) {\n      --IP;\n      for (; ScanLimit; --IP, --ScanLimit) {\n        // Don't count dbg.value against the ScanLimit, to avoid perturbing the\n        // generated code.\n        if (isa<DbgInfoIntrinsic>(IP))\n          ScanLimit++;\n        if (IP->getOpcode() == Instruction::GetElementPtr &&\n            IP->getOperand(0) == V && IP->getOperand(1) == Idx)\n          return &*IP;\n        if (IP == BlockBegin) break;\n      }\n    }\n\n    // Save the original insertion point so we can restore it when we're done.\n    SCEVInsertPointGuard Guard(Builder, this);\n\n    // Move the insertion point out of as many loops as we can.\n    while (const Loop *L = SE.LI.getLoopFor(Builder.GetInsertBlock())) {\n      if (!L->isLoopInvariant(V) || !L->isLoopInvariant(Idx)) break;\n      BasicBlock *Preheader = L->getLoopPreheader();\n      if (!Preheader) break;\n\n      // Ok, move up a level.\n      Builder.SetInsertPoint(Preheader->getTerminator());\n    }\n\n    // Emit a GEP.\n    return Builder.CreateGEP(Builder.getInt8Ty(), V, Idx, \"uglygep\");\n  }\n\n  {\n    SCEVInsertPointGuard Guard(Builder, this);\n\n    // Move the insertion point out of as many loops as we can.\n    while (const Loop *L = SE.LI.getLoopFor(Builder.GetInsertBlock())) {\n      if (!L->isLoopInvariant(V)) break;\n\n      bool AnyIndexNotLoopInvariant = any_of(\n          GepIndices, [L](Value *Op) { return !L->isLoopInvariant(Op); });\n\n      if (AnyIndexNotLoopInvariant)\n        break;\n\n      BasicBlock *Preheader = L->getLoopPreheader();\n      if (!Preheader) break;\n\n      // Ok, move up a level.\n      Builder.SetInsertPoint(Preheader->getTerminator());\n    }\n\n    // Insert a pretty getelementptr. Note that this GEP is not marked inbounds,\n    // because ScalarEvolution may have changed the address arithmetic to\n    // compute a value which is beyond the end of the allocated object.\n    Value *Casted = V;\n    if (V->getType() != PTy)\n      Casted = InsertNoopCastOfTo(Casted, PTy);\n    Value *GEP = Builder.CreateGEP(OriginalElTy, Casted, GepIndices, \"scevgep\");\n    Ops.push_back(SE.getUnknown(GEP));\n  }\n\n  return expand(SE.getAddExpr(Ops));\n}\n\nValue *SCEVExpander::expandAddToGEP(const SCEV *Op, PointerType *PTy, Type *Ty,\n                                    Value *V) {\n  const SCEV *const Ops[1] = {Op};\n  return expandAddToGEP(Ops, Ops + 1, PTy, Ty, V);\n}\n\n/// PickMostRelevantLoop - Given two loops pick the one that's most relevant for\n/// SCEV expansion. If they are nested, this is the most nested. If they are\n/// neighboring, pick the later.\nstatic const Loop *PickMostRelevantLoop(const Loop *A, const Loop *B,\n                                        DominatorTree &DT) {\n  if (!A) return B;\n  if (!B) return A;\n  if (A->contains(B)) return B;\n  if (B->contains(A)) return A;\n  if (DT.dominates(A->getHeader(), B->getHeader())) return B;\n  if (DT.dominates(B->getHeader(), A->getHeader())) return A;\n  return A; // Arbitrarily break the tie.\n}\n\n/// getRelevantLoop - Get the most relevant loop associated with the given\n/// expression, according to PickMostRelevantLoop.\nconst Loop *SCEVExpander::getRelevantLoop(const SCEV *S) {\n  // Test whether we've already computed the most relevant loop for this SCEV.\n  auto Pair = RelevantLoops.insert(std::make_pair(S, nullptr));\n  if (!Pair.second)\n    return Pair.first->second;\n\n  if (isa<SCEVConstant>(S))\n    // A constant has no relevant loops.\n    return nullptr;\n  if (const SCEVUnknown *U = dyn_cast<SCEVUnknown>(S)) {\n    if (const Instruction *I = dyn_cast<Instruction>(U->getValue()))\n      return Pair.first->second = SE.LI.getLoopFor(I->getParent());\n    // A non-instruction has no relevant loops.\n    return nullptr;\n  }\n  if (const SCEVNAryExpr *N = dyn_cast<SCEVNAryExpr>(S)) {\n    const Loop *L = nullptr;\n    if (const SCEVAddRecExpr *AR = dyn_cast<SCEVAddRecExpr>(S))\n      L = AR->getLoop();\n    for (const SCEV *Op : N->operands())\n      L = PickMostRelevantLoop(L, getRelevantLoop(Op), SE.DT);\n    return RelevantLoops[N] = L;\n  }\n  if (const SCEVCastExpr *C = dyn_cast<SCEVCastExpr>(S)) {\n    const Loop *Result = getRelevantLoop(C->getOperand());\n    return RelevantLoops[C] = Result;\n  }\n  if (const SCEVUDivExpr *D = dyn_cast<SCEVUDivExpr>(S)) {\n    const Loop *Result = PickMostRelevantLoop(\n        getRelevantLoop(D->getLHS()), getRelevantLoop(D->getRHS()), SE.DT);\n    return RelevantLoops[D] = Result;\n  }\n  llvm_unreachable(\"Unexpected SCEV type!\");\n}\n\nnamespace {\n\n/// LoopCompare - Compare loops by PickMostRelevantLoop.\nclass LoopCompare {\n  DominatorTree &DT;\npublic:\n  explicit LoopCompare(DominatorTree &dt) : DT(dt) {}\n\n  bool operator()(std::pair<const Loop *, const SCEV *> LHS,\n                  std::pair<const Loop *, const SCEV *> RHS) const {\n    // Keep pointer operands sorted at the end.\n    if (LHS.second->getType()->isPointerTy() !=\n        RHS.second->getType()->isPointerTy())\n      return LHS.second->getType()->isPointerTy();\n\n    // Compare loops with PickMostRelevantLoop.\n    if (LHS.first != RHS.first)\n      return PickMostRelevantLoop(LHS.first, RHS.first, DT) != LHS.first;\n\n    // If one operand is a non-constant negative and the other is not,\n    // put the non-constant negative on the right so that a sub can\n    // be used instead of a negate and add.\n    if (LHS.second->isNonConstantNegative()) {\n      if (!RHS.second->isNonConstantNegative())\n        return false;\n    } else if (RHS.second->isNonConstantNegative())\n      return true;\n\n    // Otherwise they are equivalent according to this comparison.\n    return false;\n  }\n};\n\n}\n\nValue *SCEVExpander::visitAddExpr(const SCEVAddExpr *S) {\n  Type *Ty = SE.getEffectiveSCEVType(S->getType());\n\n  // Collect all the add operands in a loop, along with their associated loops.\n  // Iterate in reverse so that constants are emitted last, all else equal, and\n  // so that pointer operands are inserted first, which the code below relies on\n  // to form more involved GEPs.\n  SmallVector<std::pair<const Loop *, const SCEV *>, 8> OpsAndLoops;\n  for (std::reverse_iterator<SCEVAddExpr::op_iterator> I(S->op_end()),\n       E(S->op_begin()); I != E; ++I)\n    OpsAndLoops.push_back(std::make_pair(getRelevantLoop(*I), *I));\n\n  // Sort by loop. Use a stable sort so that constants follow non-constants and\n  // pointer operands precede non-pointer operands.\n  llvm::stable_sort(OpsAndLoops, LoopCompare(SE.DT));\n\n  // Emit instructions to add all the operands. Hoist as much as possible\n  // out of loops, and form meaningful getelementptrs where possible.\n  Value *Sum = nullptr;\n  for (auto I = OpsAndLoops.begin(), E = OpsAndLoops.end(); I != E;) {\n    const Loop *CurLoop = I->first;\n    const SCEV *Op = I->second;\n    if (!Sum) {\n      // This is the first operand. Just expand it.\n      Sum = expand(Op);\n      ++I;\n    } else if (PointerType *PTy = dyn_cast<PointerType>(Sum->getType())) {\n      // The running sum expression is a pointer. Try to form a getelementptr\n      // at this level with that as the base.\n      SmallVector<const SCEV *, 4> NewOps;\n      for (; I != E && I->first == CurLoop; ++I) {\n        // If the operand is SCEVUnknown and not instructions, peek through\n        // it, to enable more of it to be folded into the GEP.\n        const SCEV *X = I->second;\n        if (const SCEVUnknown *U = dyn_cast<SCEVUnknown>(X))\n          if (!isa<Instruction>(U->getValue()))\n            X = SE.getSCEV(U->getValue());\n        NewOps.push_back(X);\n      }\n      Sum = expandAddToGEP(NewOps.begin(), NewOps.end(), PTy, Ty, Sum);\n    } else if (PointerType *PTy = dyn_cast<PointerType>(Op->getType())) {\n      // The running sum is an integer, and there's a pointer at this level.\n      // Try to form a getelementptr. If the running sum is instructions,\n      // use a SCEVUnknown to avoid re-analyzing them.\n      SmallVector<const SCEV *, 4> NewOps;\n      NewOps.push_back(isa<Instruction>(Sum) ? SE.getUnknown(Sum) :\n                                               SE.getSCEV(Sum));\n      for (++I; I != E && I->first == CurLoop; ++I)\n        NewOps.push_back(I->second);\n      Sum = expandAddToGEP(NewOps.begin(), NewOps.end(), PTy, Ty, expand(Op));\n    } else if (Op->isNonConstantNegative()) {\n      // Instead of doing a negate and add, just do a subtract.\n      Value *W = expandCodeForImpl(SE.getNegativeSCEV(Op), Ty, false);\n      Sum = InsertNoopCastOfTo(Sum, Ty);\n      Sum = InsertBinop(Instruction::Sub, Sum, W, SCEV::FlagAnyWrap,\n                        /*IsSafeToHoist*/ true);\n      ++I;\n    } else {\n      // A simple add.\n      Value *W = expandCodeForImpl(Op, Ty, false);\n      Sum = InsertNoopCastOfTo(Sum, Ty);\n      // Canonicalize a constant to the RHS.\n      if (isa<Constant>(Sum)) std::swap(Sum, W);\n      Sum = InsertBinop(Instruction::Add, Sum, W, S->getNoWrapFlags(),\n                        /*IsSafeToHoist*/ true);\n      ++I;\n    }\n  }\n\n  return Sum;\n}\n\nValue *SCEVExpander::visitMulExpr(const SCEVMulExpr *S) {\n  Type *Ty = SE.getEffectiveSCEVType(S->getType());\n\n  // Collect all the mul operands in a loop, along with their associated loops.\n  // Iterate in reverse so that constants are emitted last, all else equal.\n  SmallVector<std::pair<const Loop *, const SCEV *>, 8> OpsAndLoops;\n  for (std::reverse_iterator<SCEVMulExpr::op_iterator> I(S->op_end()),\n       E(S->op_begin()); I != E; ++I)\n    OpsAndLoops.push_back(std::make_pair(getRelevantLoop(*I), *I));\n\n  // Sort by loop. Use a stable sort so that constants follow non-constants.\n  llvm::stable_sort(OpsAndLoops, LoopCompare(SE.DT));\n\n  // Emit instructions to mul all the operands. Hoist as much as possible\n  // out of loops.\n  Value *Prod = nullptr;\n  auto I = OpsAndLoops.begin();\n\n  // Expand the calculation of X pow N in the following manner:\n  // Let N = P1 + P2 + ... + PK, where all P are powers of 2. Then:\n  // X pow N = (X pow P1) * (X pow P2) * ... * (X pow PK).\n  const auto ExpandOpBinPowN = [this, &I, &OpsAndLoops, &Ty]() {\n    auto E = I;\n    // Calculate how many times the same operand from the same loop is included\n    // into this power.\n    uint64_t Exponent = 0;\n    const uint64_t MaxExponent = UINT64_MAX >> 1;\n    // No one sane will ever try to calculate such huge exponents, but if we\n    // need this, we stop on UINT64_MAX / 2 because we need to exit the loop\n    // below when the power of 2 exceeds our Exponent, and we want it to be\n    // 1u << 31 at most to not deal with unsigned overflow.\n    while (E != OpsAndLoops.end() && *I == *E && Exponent != MaxExponent) {\n      ++Exponent;\n      ++E;\n    }\n    assert(Exponent > 0 && \"Trying to calculate a zeroth exponent of operand?\");\n\n    // Calculate powers with exponents 1, 2, 4, 8 etc. and include those of them\n    // that are needed into the result.\n    Value *P = expandCodeForImpl(I->second, Ty, false);\n    Value *Result = nullptr;\n    if (Exponent & 1)\n      Result = P;\n    for (uint64_t BinExp = 2; BinExp <= Exponent; BinExp <<= 1) {\n      P = InsertBinop(Instruction::Mul, P, P, SCEV::FlagAnyWrap,\n                      /*IsSafeToHoist*/ true);\n      if (Exponent & BinExp)\n        Result = Result ? InsertBinop(Instruction::Mul, Result, P,\n                                      SCEV::FlagAnyWrap,\n                                      /*IsSafeToHoist*/ true)\n                        : P;\n    }\n\n    I = E;\n    assert(Result && \"Nothing was expanded?\");\n    return Result;\n  };\n\n  while (I != OpsAndLoops.end()) {\n    if (!Prod) {\n      // This is the first operand. Just expand it.\n      Prod = ExpandOpBinPowN();\n    } else if (I->second->isAllOnesValue()) {\n      // Instead of doing a multiply by negative one, just do a negate.\n      Prod = InsertNoopCastOfTo(Prod, Ty);\n      Prod = InsertBinop(Instruction::Sub, Constant::getNullValue(Ty), Prod,\n                         SCEV::FlagAnyWrap, /*IsSafeToHoist*/ true);\n      ++I;\n    } else {\n      // A simple mul.\n      Value *W = ExpandOpBinPowN();\n      Prod = InsertNoopCastOfTo(Prod, Ty);\n      // Canonicalize a constant to the RHS.\n      if (isa<Constant>(Prod)) std::swap(Prod, W);\n      const APInt *RHS;\n      if (match(W, m_Power2(RHS))) {\n        // Canonicalize Prod*(1<<C) to Prod<<C.\n        assert(!Ty->isVectorTy() && \"vector types are not SCEVable\");\n        auto NWFlags = S->getNoWrapFlags();\n        // clear nsw flag if shl will produce poison value.\n        if (RHS->logBase2() == RHS->getBitWidth() - 1)\n          NWFlags = ScalarEvolution::clearFlags(NWFlags, SCEV::FlagNSW);\n        Prod = InsertBinop(Instruction::Shl, Prod,\n                           ConstantInt::get(Ty, RHS->logBase2()), NWFlags,\n                           /*IsSafeToHoist*/ true);\n      } else {\n        Prod = InsertBinop(Instruction::Mul, Prod, W, S->getNoWrapFlags(),\n                           /*IsSafeToHoist*/ true);\n      }\n    }\n  }\n\n  return Prod;\n}\n\nValue *SCEVExpander::visitUDivExpr(const SCEVUDivExpr *S) {\n  Type *Ty = SE.getEffectiveSCEVType(S->getType());\n\n  Value *LHS = expandCodeForImpl(S->getLHS(), Ty, false);\n  if (const SCEVConstant *SC = dyn_cast<SCEVConstant>(S->getRHS())) {\n    const APInt &RHS = SC->getAPInt();\n    if (RHS.isPowerOf2())\n      return InsertBinop(Instruction::LShr, LHS,\n                         ConstantInt::get(Ty, RHS.logBase2()),\n                         SCEV::FlagAnyWrap, /*IsSafeToHoist*/ true);\n  }\n\n  Value *RHS = expandCodeForImpl(S->getRHS(), Ty, false);\n  return InsertBinop(Instruction::UDiv, LHS, RHS, SCEV::FlagAnyWrap,\n                     /*IsSafeToHoist*/ SE.isKnownNonZero(S->getRHS()));\n}\n\n/// Move parts of Base into Rest to leave Base with the minimal\n/// expression that provides a pointer operand suitable for a\n/// GEP expansion.\nstatic void ExposePointerBase(const SCEV *&Base, const SCEV *&Rest,\n                              ScalarEvolution &SE) {\n  while (const SCEVAddRecExpr *A = dyn_cast<SCEVAddRecExpr>(Base)) {\n    Base = A->getStart();\n    Rest = SE.getAddExpr(Rest,\n                         SE.getAddRecExpr(SE.getConstant(A->getType(), 0),\n                                          A->getStepRecurrence(SE),\n                                          A->getLoop(),\n                                          A->getNoWrapFlags(SCEV::FlagNW)));\n  }\n  if (const SCEVAddExpr *A = dyn_cast<SCEVAddExpr>(Base)) {\n    Base = A->getOperand(A->getNumOperands()-1);\n    SmallVector<const SCEV *, 8> NewAddOps(A->operands());\n    NewAddOps.back() = Rest;\n    Rest = SE.getAddExpr(NewAddOps);\n    ExposePointerBase(Base, Rest, SE);\n  }\n}\n\n/// Determine if this is a well-behaved chain of instructions leading back to\n/// the PHI. If so, it may be reused by expanded expressions.\nbool SCEVExpander::isNormalAddRecExprPHI(PHINode *PN, Instruction *IncV,\n                                         const Loop *L) {\n  if (IncV->getNumOperands() == 0 || isa<PHINode>(IncV) ||\n      (isa<CastInst>(IncV) && !isa<BitCastInst>(IncV)))\n    return false;\n  // If any of the operands don't dominate the insert position, bail.\n  // Addrec operands are always loop-invariant, so this can only happen\n  // if there are instructions which haven't been hoisted.\n  if (L == IVIncInsertLoop) {\n    for (User::op_iterator OI = IncV->op_begin()+1,\n           OE = IncV->op_end(); OI != OE; ++OI)\n      if (Instruction *OInst = dyn_cast<Instruction>(OI))\n        if (!SE.DT.dominates(OInst, IVIncInsertPos))\n          return false;\n  }\n  // Advance to the next instruction.\n  IncV = dyn_cast<Instruction>(IncV->getOperand(0));\n  if (!IncV)\n    return false;\n\n  if (IncV->mayHaveSideEffects())\n    return false;\n\n  if (IncV == PN)\n    return true;\n\n  return isNormalAddRecExprPHI(PN, IncV, L);\n}\n\n/// getIVIncOperand returns an induction variable increment's induction\n/// variable operand.\n///\n/// If allowScale is set, any type of GEP is allowed as long as the nonIV\n/// operands dominate InsertPos.\n///\n/// If allowScale is not set, ensure that a GEP increment conforms to one of the\n/// simple patterns generated by getAddRecExprPHILiterally and\n/// expandAddtoGEP. If the pattern isn't recognized, return NULL.\nInstruction *SCEVExpander::getIVIncOperand(Instruction *IncV,\n                                           Instruction *InsertPos,\n                                           bool allowScale) {\n  if (IncV == InsertPos)\n    return nullptr;\n\n  switch (IncV->getOpcode()) {\n  default:\n    return nullptr;\n  // Check for a simple Add/Sub or GEP of a loop invariant step.\n  case Instruction::Add:\n  case Instruction::Sub: {\n    Instruction *OInst = dyn_cast<Instruction>(IncV->getOperand(1));\n    if (!OInst || SE.DT.dominates(OInst, InsertPos))\n      return dyn_cast<Instruction>(IncV->getOperand(0));\n    return nullptr;\n  }\n  case Instruction::BitCast:\n    return dyn_cast<Instruction>(IncV->getOperand(0));\n  case Instruction::GetElementPtr:\n    for (auto I = IncV->op_begin() + 1, E = IncV->op_end(); I != E; ++I) {\n      if (isa<Constant>(*I))\n        continue;\n      if (Instruction *OInst = dyn_cast<Instruction>(*I)) {\n        if (!SE.DT.dominates(OInst, InsertPos))\n          return nullptr;\n      }\n      if (allowScale) {\n        // allow any kind of GEP as long as it can be hoisted.\n        continue;\n      }\n      // This must be a pointer addition of constants (pretty), which is already\n      // handled, or some number of address-size elements (ugly). Ugly geps\n      // have 2 operands. i1* is used by the expander to represent an\n      // address-size element.\n      if (IncV->getNumOperands() != 2)\n        return nullptr;\n      unsigned AS = cast<PointerType>(IncV->getType())->getAddressSpace();\n      if (IncV->getType() != Type::getInt1PtrTy(SE.getContext(), AS)\n          && IncV->getType() != Type::getInt8PtrTy(SE.getContext(), AS))\n        return nullptr;\n      break;\n    }\n    return dyn_cast<Instruction>(IncV->getOperand(0));\n  }\n}\n\n/// If the insert point of the current builder or any of the builders on the\n/// stack of saved builders has 'I' as its insert point, update it to point to\n/// the instruction after 'I'.  This is intended to be used when the instruction\n/// 'I' is being moved.  If this fixup is not done and 'I' is moved to a\n/// different block, the inconsistent insert point (with a mismatched\n/// Instruction and Block) can lead to an instruction being inserted in a block\n/// other than its parent.\nvoid SCEVExpander::fixupInsertPoints(Instruction *I) {\n  BasicBlock::iterator It(*I);\n  BasicBlock::iterator NewInsertPt = std::next(It);\n  if (Builder.GetInsertPoint() == It)\n    Builder.SetInsertPoint(&*NewInsertPt);\n  for (auto *InsertPtGuard : InsertPointGuards)\n    if (InsertPtGuard->GetInsertPoint() == It)\n      InsertPtGuard->SetInsertPoint(NewInsertPt);\n}\n\n/// hoistStep - Attempt to hoist a simple IV increment above InsertPos to make\n/// it available to other uses in this loop. Recursively hoist any operands,\n/// until we reach a value that dominates InsertPos.\nbool SCEVExpander::hoistIVInc(Instruction *IncV, Instruction *InsertPos) {\n  if (SE.DT.dominates(IncV, InsertPos))\n      return true;\n\n  // InsertPos must itself dominate IncV so that IncV's new position satisfies\n  // its existing users.\n  if (isa<PHINode>(InsertPos) ||\n      !SE.DT.dominates(InsertPos->getParent(), IncV->getParent()))\n    return false;\n\n  if (!SE.LI.movementPreservesLCSSAForm(IncV, InsertPos))\n    return false;\n\n  // Check that the chain of IV operands leading back to Phi can be hoisted.\n  SmallVector<Instruction*, 4> IVIncs;\n  for(;;) {\n    Instruction *Oper = getIVIncOperand(IncV, InsertPos, /*allowScale*/true);\n    if (!Oper)\n      return false;\n    // IncV is safe to hoist.\n    IVIncs.push_back(IncV);\n    IncV = Oper;\n    if (SE.DT.dominates(IncV, InsertPos))\n      break;\n  }\n  for (auto I = IVIncs.rbegin(), E = IVIncs.rend(); I != E; ++I) {\n    fixupInsertPoints(*I);\n    (*I)->moveBefore(InsertPos);\n  }\n  return true;\n}\n\n/// Determine if this cyclic phi is in a form that would have been generated by\n/// LSR. We don't care if the phi was actually expanded in this pass, as long\n/// as it is in a low-cost form, for example, no implied multiplication. This\n/// should match any patterns generated by getAddRecExprPHILiterally and\n/// expandAddtoGEP.\nbool SCEVExpander::isExpandedAddRecExprPHI(PHINode *PN, Instruction *IncV,\n                                           const Loop *L) {\n  for(Instruction *IVOper = IncV;\n      (IVOper = getIVIncOperand(IVOper, L->getLoopPreheader()->getTerminator(),\n                                /*allowScale=*/false));) {\n    if (IVOper == PN)\n      return true;\n  }\n  return false;\n}\n\n/// expandIVInc - Expand an IV increment at Builder's current InsertPos.\n/// Typically this is the LatchBlock terminator or IVIncInsertPos, but we may\n/// need to materialize IV increments elsewhere to handle difficult situations.\nValue *SCEVExpander::expandIVInc(PHINode *PN, Value *StepV, const Loop *L,\n                                 Type *ExpandTy, Type *IntTy,\n                                 bool useSubtract) {\n  Value *IncV;\n  // If the PHI is a pointer, use a GEP, otherwise use an add or sub.\n  if (ExpandTy->isPointerTy()) {\n    PointerType *GEPPtrTy = cast<PointerType>(ExpandTy);\n    // If the step isn't constant, don't use an implicitly scaled GEP, because\n    // that would require a multiply inside the loop.\n    if (!isa<ConstantInt>(StepV))\n      GEPPtrTy = PointerType::get(Type::getInt1Ty(SE.getContext()),\n                                  GEPPtrTy->getAddressSpace());\n    IncV = expandAddToGEP(SE.getSCEV(StepV), GEPPtrTy, IntTy, PN);\n    if (IncV->getType() != PN->getType())\n      IncV = Builder.CreateBitCast(IncV, PN->getType());\n  } else {\n    IncV = useSubtract ?\n      Builder.CreateSub(PN, StepV, Twine(IVName) + \".iv.next\") :\n      Builder.CreateAdd(PN, StepV, Twine(IVName) + \".iv.next\");\n  }\n  return IncV;\n}\n\n/// Hoist the addrec instruction chain rooted in the loop phi above the\n/// position. This routine assumes that this is possible (has been checked).\nvoid SCEVExpander::hoistBeforePos(DominatorTree *DT, Instruction *InstToHoist,\n                                  Instruction *Pos, PHINode *LoopPhi) {\n  do {\n    if (DT->dominates(InstToHoist, Pos))\n      break;\n    // Make sure the increment is where we want it. But don't move it\n    // down past a potential existing post-inc user.\n    fixupInsertPoints(InstToHoist);\n    InstToHoist->moveBefore(Pos);\n    Pos = InstToHoist;\n    InstToHoist = cast<Instruction>(InstToHoist->getOperand(0));\n  } while (InstToHoist != LoopPhi);\n}\n\n/// Check whether we can cheaply express the requested SCEV in terms of\n/// the available PHI SCEV by truncation and/or inversion of the step.\nstatic bool canBeCheaplyTransformed(ScalarEvolution &SE,\n                                    const SCEVAddRecExpr *Phi,\n                                    const SCEVAddRecExpr *Requested,\n                                    bool &InvertStep) {\n  Type *PhiTy = SE.getEffectiveSCEVType(Phi->getType());\n  Type *RequestedTy = SE.getEffectiveSCEVType(Requested->getType());\n\n  if (RequestedTy->getIntegerBitWidth() > PhiTy->getIntegerBitWidth())\n    return false;\n\n  // Try truncate it if necessary.\n  Phi = dyn_cast<SCEVAddRecExpr>(SE.getTruncateOrNoop(Phi, RequestedTy));\n  if (!Phi)\n    return false;\n\n  // Check whether truncation will help.\n  if (Phi == Requested) {\n    InvertStep = false;\n    return true;\n  }\n\n  // Check whether inverting will help: {R,+,-1} == R - {0,+,1}.\n  if (SE.getAddExpr(Requested->getStart(),\n                    SE.getNegativeSCEV(Requested)) == Phi) {\n    InvertStep = true;\n    return true;\n  }\n\n  return false;\n}\n\nstatic bool IsIncrementNSW(ScalarEvolution &SE, const SCEVAddRecExpr *AR) {\n  if (!isa<IntegerType>(AR->getType()))\n    return false;\n\n  unsigned BitWidth = cast<IntegerType>(AR->getType())->getBitWidth();\n  Type *WideTy = IntegerType::get(AR->getType()->getContext(), BitWidth * 2);\n  const SCEV *Step = AR->getStepRecurrence(SE);\n  const SCEV *OpAfterExtend = SE.getAddExpr(SE.getSignExtendExpr(Step, WideTy),\n                                            SE.getSignExtendExpr(AR, WideTy));\n  const SCEV *ExtendAfterOp =\n    SE.getSignExtendExpr(SE.getAddExpr(AR, Step), WideTy);\n  return ExtendAfterOp == OpAfterExtend;\n}\n\nstatic bool IsIncrementNUW(ScalarEvolution &SE, const SCEVAddRecExpr *AR) {\n  if (!isa<IntegerType>(AR->getType()))\n    return false;\n\n  unsigned BitWidth = cast<IntegerType>(AR->getType())->getBitWidth();\n  Type *WideTy = IntegerType::get(AR->getType()->getContext(), BitWidth * 2);\n  const SCEV *Step = AR->getStepRecurrence(SE);\n  const SCEV *OpAfterExtend = SE.getAddExpr(SE.getZeroExtendExpr(Step, WideTy),\n                                            SE.getZeroExtendExpr(AR, WideTy));\n  const SCEV *ExtendAfterOp =\n    SE.getZeroExtendExpr(SE.getAddExpr(AR, Step), WideTy);\n  return ExtendAfterOp == OpAfterExtend;\n}\n\n/// getAddRecExprPHILiterally - Helper for expandAddRecExprLiterally. Expand\n/// the base addrec, which is the addrec without any non-loop-dominating\n/// values, and return the PHI.\nPHINode *\nSCEVExpander::getAddRecExprPHILiterally(const SCEVAddRecExpr *Normalized,\n                                        const Loop *L,\n                                        Type *ExpandTy,\n                                        Type *IntTy,\n                                        Type *&TruncTy,\n                                        bool &InvertStep) {\n  assert((!IVIncInsertLoop||IVIncInsertPos) && \"Uninitialized insert position\");\n\n  // Reuse a previously-inserted PHI, if present.\n  BasicBlock *LatchBlock = L->getLoopLatch();\n  if (LatchBlock) {\n    PHINode *AddRecPhiMatch = nullptr;\n    Instruction *IncV = nullptr;\n    TruncTy = nullptr;\n    InvertStep = false;\n\n    // Only try partially matching scevs that need truncation and/or\n    // step-inversion if we know this loop is outside the current loop.\n    bool TryNonMatchingSCEV =\n        IVIncInsertLoop &&\n        SE.DT.properlyDominates(LatchBlock, IVIncInsertLoop->getHeader());\n\n    for (PHINode &PN : L->getHeader()->phis()) {\n      if (!SE.isSCEVable(PN.getType()))\n        continue;\n\n      // We should not look for a incomplete PHI. Getting SCEV for a incomplete\n      // PHI has no meaning at all.\n      if (!PN.isComplete()) {\n        DEBUG_WITH_TYPE(\n            DebugType, dbgs() << \"One incomplete PHI is found: \" << PN << \"\\n\");\n        continue;\n      }\n\n      const SCEVAddRecExpr *PhiSCEV = dyn_cast<SCEVAddRecExpr>(SE.getSCEV(&PN));\n      if (!PhiSCEV)\n        continue;\n\n      bool IsMatchingSCEV = PhiSCEV == Normalized;\n      // We only handle truncation and inversion of phi recurrences for the\n      // expanded expression if the expanded expression's loop dominates the\n      // loop we insert to. Check now, so we can bail out early.\n      if (!IsMatchingSCEV && !TryNonMatchingSCEV)\n          continue;\n\n      // TODO: this possibly can be reworked to avoid this cast at all.\n      Instruction *TempIncV =\n          dyn_cast<Instruction>(PN.getIncomingValueForBlock(LatchBlock));\n      if (!TempIncV)\n        continue;\n\n      // Check whether we can reuse this PHI node.\n      if (LSRMode) {\n        if (!isExpandedAddRecExprPHI(&PN, TempIncV, L))\n          continue;\n        if (L == IVIncInsertLoop && !hoistIVInc(TempIncV, IVIncInsertPos))\n          continue;\n      } else {\n        if (!isNormalAddRecExprPHI(&PN, TempIncV, L))\n          continue;\n      }\n\n      // Stop if we have found an exact match SCEV.\n      if (IsMatchingSCEV) {\n        IncV = TempIncV;\n        TruncTy = nullptr;\n        InvertStep = false;\n        AddRecPhiMatch = &PN;\n        break;\n      }\n\n      // Try whether the phi can be translated into the requested form\n      // (truncated and/or offset by a constant).\n      if ((!TruncTy || InvertStep) &&\n          canBeCheaplyTransformed(SE, PhiSCEV, Normalized, InvertStep)) {\n        // Record the phi node. But don't stop we might find an exact match\n        // later.\n        AddRecPhiMatch = &PN;\n        IncV = TempIncV;\n        TruncTy = SE.getEffectiveSCEVType(Normalized->getType());\n      }\n    }\n\n    if (AddRecPhiMatch) {\n      // Potentially, move the increment. We have made sure in\n      // isExpandedAddRecExprPHI or hoistIVInc that this is possible.\n      if (L == IVIncInsertLoop)\n        hoistBeforePos(&SE.DT, IncV, IVIncInsertPos, AddRecPhiMatch);\n\n      // Ok, the add recurrence looks usable.\n      // Remember this PHI, even in post-inc mode.\n      InsertedValues.insert(AddRecPhiMatch);\n      // Remember the increment.\n      rememberInstruction(IncV);\n      // Those values were not actually inserted but re-used.\n      ReusedValues.insert(AddRecPhiMatch);\n      ReusedValues.insert(IncV);\n      return AddRecPhiMatch;\n    }\n  }\n\n  // Save the original insertion point so we can restore it when we're done.\n  SCEVInsertPointGuard Guard(Builder, this);\n\n  // Another AddRec may need to be recursively expanded below. For example, if\n  // this AddRec is quadratic, the StepV may itself be an AddRec in this\n  // loop. Remove this loop from the PostIncLoops set before expanding such\n  // AddRecs. Otherwise, we cannot find a valid position for the step\n  // (i.e. StepV can never dominate its loop header).  Ideally, we could do\n  // SavedIncLoops.swap(PostIncLoops), but we generally have a single element,\n  // so it's not worth implementing SmallPtrSet::swap.\n  PostIncLoopSet SavedPostIncLoops = PostIncLoops;\n  PostIncLoops.clear();\n\n  // Expand code for the start value into the loop preheader.\n  assert(L->getLoopPreheader() &&\n         \"Can't expand add recurrences without a loop preheader!\");\n  Value *StartV =\n      expandCodeForImpl(Normalized->getStart(), ExpandTy,\n                        L->getLoopPreheader()->getTerminator(), false);\n\n  // StartV must have been be inserted into L's preheader to dominate the new\n  // phi.\n  assert(!isa<Instruction>(StartV) ||\n         SE.DT.properlyDominates(cast<Instruction>(StartV)->getParent(),\n                                 L->getHeader()));\n\n  // Expand code for the step value. Do this before creating the PHI so that PHI\n  // reuse code doesn't see an incomplete PHI.\n  const SCEV *Step = Normalized->getStepRecurrence(SE);\n  // If the stride is negative, insert a sub instead of an add for the increment\n  // (unless it's a constant, because subtracts of constants are canonicalized\n  // to adds).\n  bool useSubtract = !ExpandTy->isPointerTy() && Step->isNonConstantNegative();\n  if (useSubtract)\n    Step = SE.getNegativeSCEV(Step);\n  // Expand the step somewhere that dominates the loop header.\n  Value *StepV = expandCodeForImpl(\n      Step, IntTy, &*L->getHeader()->getFirstInsertionPt(), false);\n\n  // The no-wrap behavior proved by IsIncrement(NUW|NSW) is only applicable if\n  // we actually do emit an addition.  It does not apply if we emit a\n  // subtraction.\n  bool IncrementIsNUW = !useSubtract && IsIncrementNUW(SE, Normalized);\n  bool IncrementIsNSW = !useSubtract && IsIncrementNSW(SE, Normalized);\n\n  // Create the PHI.\n  BasicBlock *Header = L->getHeader();\n  Builder.SetInsertPoint(Header, Header->begin());\n  pred_iterator HPB = pred_begin(Header), HPE = pred_end(Header);\n  PHINode *PN = Builder.CreatePHI(ExpandTy, std::distance(HPB, HPE),\n                                  Twine(IVName) + \".iv\");\n\n  // Create the step instructions and populate the PHI.\n  for (pred_iterator HPI = HPB; HPI != HPE; ++HPI) {\n    BasicBlock *Pred = *HPI;\n\n    // Add a start value.\n    if (!L->contains(Pred)) {\n      PN->addIncoming(StartV, Pred);\n      continue;\n    }\n\n    // Create a step value and add it to the PHI.\n    // If IVIncInsertLoop is non-null and equal to the addrec's loop, insert the\n    // instructions at IVIncInsertPos.\n    Instruction *InsertPos = L == IVIncInsertLoop ?\n      IVIncInsertPos : Pred->getTerminator();\n    Builder.SetInsertPoint(InsertPos);\n    Value *IncV = expandIVInc(PN, StepV, L, ExpandTy, IntTy, useSubtract);\n\n    if (isa<OverflowingBinaryOperator>(IncV)) {\n      if (IncrementIsNUW)\n        cast<BinaryOperator>(IncV)->setHasNoUnsignedWrap();\n      if (IncrementIsNSW)\n        cast<BinaryOperator>(IncV)->setHasNoSignedWrap();\n    }\n    PN->addIncoming(IncV, Pred);\n  }\n\n  // After expanding subexpressions, restore the PostIncLoops set so the caller\n  // can ensure that IVIncrement dominates the current uses.\n  PostIncLoops = SavedPostIncLoops;\n\n  // Remember this PHI, even in post-inc mode.\n  InsertedValues.insert(PN);\n\n  return PN;\n}\n\nValue *SCEVExpander::expandAddRecExprLiterally(const SCEVAddRecExpr *S) {\n  Type *STy = S->getType();\n  Type *IntTy = SE.getEffectiveSCEVType(STy);\n  const Loop *L = S->getLoop();\n\n  // Determine a normalized form of this expression, which is the expression\n  // before any post-inc adjustment is made.\n  const SCEVAddRecExpr *Normalized = S;\n  if (PostIncLoops.count(L)) {\n    PostIncLoopSet Loops;\n    Loops.insert(L);\n    Normalized = cast<SCEVAddRecExpr>(normalizeForPostIncUse(S, Loops, SE));\n  }\n\n  // Strip off any non-loop-dominating component from the addrec start.\n  const SCEV *Start = Normalized->getStart();\n  const SCEV *PostLoopOffset = nullptr;\n  if (!SE.properlyDominates(Start, L->getHeader())) {\n    PostLoopOffset = Start;\n    Start = SE.getConstant(Normalized->getType(), 0);\n    Normalized = cast<SCEVAddRecExpr>(\n      SE.getAddRecExpr(Start, Normalized->getStepRecurrence(SE),\n                       Normalized->getLoop(),\n                       Normalized->getNoWrapFlags(SCEV::FlagNW)));\n  }\n\n  // Strip off any non-loop-dominating component from the addrec step.\n  const SCEV *Step = Normalized->getStepRecurrence(SE);\n  const SCEV *PostLoopScale = nullptr;\n  if (!SE.dominates(Step, L->getHeader())) {\n    PostLoopScale = Step;\n    Step = SE.getConstant(Normalized->getType(), 1);\n    if (!Start->isZero()) {\n        // The normalization below assumes that Start is constant zero, so if\n        // it isn't re-associate Start to PostLoopOffset.\n        assert(!PostLoopOffset && \"Start not-null but PostLoopOffset set?\");\n        PostLoopOffset = Start;\n        Start = SE.getConstant(Normalized->getType(), 0);\n    }\n    Normalized =\n      cast<SCEVAddRecExpr>(SE.getAddRecExpr(\n                             Start, Step, Normalized->getLoop(),\n                             Normalized->getNoWrapFlags(SCEV::FlagNW)));\n  }\n\n  // Expand the core addrec. If we need post-loop scaling, force it to\n  // expand to an integer type to avoid the need for additional casting.\n  Type *ExpandTy = PostLoopScale ? IntTy : STy;\n  // We can't use a pointer type for the addrec if the pointer type is\n  // non-integral.\n  Type *AddRecPHIExpandTy =\n      DL.isNonIntegralPointerType(STy) ? Normalized->getType() : ExpandTy;\n\n  // In some cases, we decide to reuse an existing phi node but need to truncate\n  // it and/or invert the step.\n  Type *TruncTy = nullptr;\n  bool InvertStep = false;\n  PHINode *PN = getAddRecExprPHILiterally(Normalized, L, AddRecPHIExpandTy,\n                                          IntTy, TruncTy, InvertStep);\n\n  // Accommodate post-inc mode, if necessary.\n  Value *Result;\n  if (!PostIncLoops.count(L))\n    Result = PN;\n  else {\n    // In PostInc mode, use the post-incremented value.\n    BasicBlock *LatchBlock = L->getLoopLatch();\n    assert(LatchBlock && \"PostInc mode requires a unique loop latch!\");\n    Result = PN->getIncomingValueForBlock(LatchBlock);\n\n    // We might be introducing a new use of the post-inc IV that is not poison\n    // safe, in which case we should drop poison generating flags. Only keep\n    // those flags for which SCEV has proven that they always hold.\n    if (isa<OverflowingBinaryOperator>(Result)) {\n      auto *I = cast<Instruction>(Result);\n      if (!S->hasNoUnsignedWrap())\n        I->setHasNoUnsignedWrap(false);\n      if (!S->hasNoSignedWrap())\n        I->setHasNoSignedWrap(false);\n    }\n\n    // For an expansion to use the postinc form, the client must call\n    // expandCodeFor with an InsertPoint that is either outside the PostIncLoop\n    // or dominated by IVIncInsertPos.\n    if (isa<Instruction>(Result) &&\n        !SE.DT.dominates(cast<Instruction>(Result),\n                         &*Builder.GetInsertPoint())) {\n      // The induction variable's postinc expansion does not dominate this use.\n      // IVUsers tries to prevent this case, so it is rare. However, it can\n      // happen when an IVUser outside the loop is not dominated by the latch\n      // block. Adjusting IVIncInsertPos before expansion begins cannot handle\n      // all cases. Consider a phi outside whose operand is replaced during\n      // expansion with the value of the postinc user. Without fundamentally\n      // changing the way postinc users are tracked, the only remedy is\n      // inserting an extra IV increment. StepV might fold into PostLoopOffset,\n      // but hopefully expandCodeFor handles that.\n      bool useSubtract =\n        !ExpandTy->isPointerTy() && Step->isNonConstantNegative();\n      if (useSubtract)\n        Step = SE.getNegativeSCEV(Step);\n      Value *StepV;\n      {\n        // Expand the step somewhere that dominates the loop header.\n        SCEVInsertPointGuard Guard(Builder, this);\n        StepV = expandCodeForImpl(\n            Step, IntTy, &*L->getHeader()->getFirstInsertionPt(), false);\n      }\n      Result = expandIVInc(PN, StepV, L, ExpandTy, IntTy, useSubtract);\n    }\n  }\n\n  // We have decided to reuse an induction variable of a dominating loop. Apply\n  // truncation and/or inversion of the step.\n  if (TruncTy) {\n    Type *ResTy = Result->getType();\n    // Normalize the result type.\n    if (ResTy != SE.getEffectiveSCEVType(ResTy))\n      Result = InsertNoopCastOfTo(Result, SE.getEffectiveSCEVType(ResTy));\n    // Truncate the result.\n    if (TruncTy != Result->getType())\n      Result = Builder.CreateTrunc(Result, TruncTy);\n\n    // Invert the result.\n    if (InvertStep)\n      Result = Builder.CreateSub(\n          expandCodeForImpl(Normalized->getStart(), TruncTy, false), Result);\n  }\n\n  // Re-apply any non-loop-dominating scale.\n  if (PostLoopScale) {\n    assert(S->isAffine() && \"Can't linearly scale non-affine recurrences.\");\n    Result = InsertNoopCastOfTo(Result, IntTy);\n    Result = Builder.CreateMul(Result,\n                               expandCodeForImpl(PostLoopScale, IntTy, false));\n  }\n\n  // Re-apply any non-loop-dominating offset.\n  if (PostLoopOffset) {\n    if (PointerType *PTy = dyn_cast<PointerType>(ExpandTy)) {\n      if (Result->getType()->isIntegerTy()) {\n        Value *Base = expandCodeForImpl(PostLoopOffset, ExpandTy, false);\n        Result = expandAddToGEP(SE.getUnknown(Result), PTy, IntTy, Base);\n      } else {\n        Result = expandAddToGEP(PostLoopOffset, PTy, IntTy, Result);\n      }\n    } else {\n      Result = InsertNoopCastOfTo(Result, IntTy);\n      Result = Builder.CreateAdd(\n          Result, expandCodeForImpl(PostLoopOffset, IntTy, false));\n    }\n  }\n\n  return Result;\n}\n\nValue *SCEVExpander::visitAddRecExpr(const SCEVAddRecExpr *S) {\n  // In canonical mode we compute the addrec as an expression of a canonical IV\n  // using evaluateAtIteration and expand the resulting SCEV expression. This\n  // way we avoid introducing new IVs to carry on the comutation of the addrec\n  // throughout the loop.\n  //\n  // For nested addrecs evaluateAtIteration might need a canonical IV of a\n  // type wider than the addrec itself. Emitting a canonical IV of the\n  // proper type might produce non-legal types, for example expanding an i64\n  // {0,+,2,+,1} addrec would need an i65 canonical IV. To avoid this just fall\n  // back to non-canonical mode for nested addrecs.\n  if (!CanonicalMode || (S->getNumOperands() > 2))\n    return expandAddRecExprLiterally(S);\n\n  Type *Ty = SE.getEffectiveSCEVType(S->getType());\n  const Loop *L = S->getLoop();\n\n  // First check for an existing canonical IV in a suitable type.\n  PHINode *CanonicalIV = nullptr;\n  if (PHINode *PN = L->getCanonicalInductionVariable())\n    if (SE.getTypeSizeInBits(PN->getType()) >= SE.getTypeSizeInBits(Ty))\n      CanonicalIV = PN;\n\n  // Rewrite an AddRec in terms of the canonical induction variable, if\n  // its type is more narrow.\n  if (CanonicalIV &&\n      SE.getTypeSizeInBits(CanonicalIV->getType()) >\n      SE.getTypeSizeInBits(Ty)) {\n    SmallVector<const SCEV *, 4> NewOps(S->getNumOperands());\n    for (unsigned i = 0, e = S->getNumOperands(); i != e; ++i)\n      NewOps[i] = SE.getAnyExtendExpr(S->op_begin()[i], CanonicalIV->getType());\n    Value *V = expand(SE.getAddRecExpr(NewOps, S->getLoop(),\n                                       S->getNoWrapFlags(SCEV::FlagNW)));\n    BasicBlock::iterator NewInsertPt =\n        findInsertPointAfter(cast<Instruction>(V), &*Builder.GetInsertPoint());\n    V = expandCodeForImpl(SE.getTruncateExpr(SE.getUnknown(V), Ty), nullptr,\n                          &*NewInsertPt, false);\n    return V;\n  }\n\n  // {X,+,F} --> X + {0,+,F}\n  if (!S->getStart()->isZero()) {\n    SmallVector<const SCEV *, 4> NewOps(S->operands());\n    NewOps[0] = SE.getConstant(Ty, 0);\n    const SCEV *Rest = SE.getAddRecExpr(NewOps, L,\n                                        S->getNoWrapFlags(SCEV::FlagNW));\n\n    // Turn things like ptrtoint+arithmetic+inttoptr into GEP. See the\n    // comments on expandAddToGEP for details.\n    const SCEV *Base = S->getStart();\n    // Dig into the expression to find the pointer base for a GEP.\n    const SCEV *ExposedRest = Rest;\n    ExposePointerBase(Base, ExposedRest, SE);\n    // If we found a pointer, expand the AddRec with a GEP.\n    if (PointerType *PTy = dyn_cast<PointerType>(Base->getType())) {\n      // Make sure the Base isn't something exotic, such as a multiplied\n      // or divided pointer value. In those cases, the result type isn't\n      // actually a pointer type.\n      if (!isa<SCEVMulExpr>(Base) && !isa<SCEVUDivExpr>(Base)) {\n        Value *StartV = expand(Base);\n        assert(StartV->getType() == PTy && \"Pointer type mismatch for GEP!\");\n        return expandAddToGEP(ExposedRest, PTy, Ty, StartV);\n      }\n    }\n\n    // Just do a normal add. Pre-expand the operands to suppress folding.\n    //\n    // The LHS and RHS values are factored out of the expand call to make the\n    // output independent of the argument evaluation order.\n    const SCEV *AddExprLHS = SE.getUnknown(expand(S->getStart()));\n    const SCEV *AddExprRHS = SE.getUnknown(expand(Rest));\n    return expand(SE.getAddExpr(AddExprLHS, AddExprRHS));\n  }\n\n  // If we don't yet have a canonical IV, create one.\n  if (!CanonicalIV) {\n    // Create and insert the PHI node for the induction variable in the\n    // specified loop.\n    BasicBlock *Header = L->getHeader();\n    pred_iterator HPB = pred_begin(Header), HPE = pred_end(Header);\n    CanonicalIV = PHINode::Create(Ty, std::distance(HPB, HPE), \"indvar\",\n                                  &Header->front());\n    rememberInstruction(CanonicalIV);\n\n    SmallSet<BasicBlock *, 4> PredSeen;\n    Constant *One = ConstantInt::get(Ty, 1);\n    for (pred_iterator HPI = HPB; HPI != HPE; ++HPI) {\n      BasicBlock *HP = *HPI;\n      if (!PredSeen.insert(HP).second) {\n        // There must be an incoming value for each predecessor, even the\n        // duplicates!\n        CanonicalIV->addIncoming(CanonicalIV->getIncomingValueForBlock(HP), HP);\n        continue;\n      }\n\n      if (L->contains(HP)) {\n        // Insert a unit add instruction right before the terminator\n        // corresponding to the back-edge.\n        Instruction *Add = BinaryOperator::CreateAdd(CanonicalIV, One,\n                                                     \"indvar.next\",\n                                                     HP->getTerminator());\n        Add->setDebugLoc(HP->getTerminator()->getDebugLoc());\n        rememberInstruction(Add);\n        CanonicalIV->addIncoming(Add, HP);\n      } else {\n        CanonicalIV->addIncoming(Constant::getNullValue(Ty), HP);\n      }\n    }\n  }\n\n  // {0,+,1} --> Insert a canonical induction variable into the loop!\n  if (S->isAffine() && S->getOperand(1)->isOne()) {\n    assert(Ty == SE.getEffectiveSCEVType(CanonicalIV->getType()) &&\n           \"IVs with types different from the canonical IV should \"\n           \"already have been handled!\");\n    return CanonicalIV;\n  }\n\n  // {0,+,F} --> {0,+,1} * F\n\n  // If this is a simple linear addrec, emit it now as a special case.\n  if (S->isAffine())    // {0,+,F} --> i*F\n    return\n      expand(SE.getTruncateOrNoop(\n        SE.getMulExpr(SE.getUnknown(CanonicalIV),\n                      SE.getNoopOrAnyExtend(S->getOperand(1),\n                                            CanonicalIV->getType())),\n        Ty));\n\n  // If this is a chain of recurrences, turn it into a closed form, using the\n  // folders, then expandCodeFor the closed form.  This allows the folders to\n  // simplify the expression without having to build a bunch of special code\n  // into this folder.\n  const SCEV *IH = SE.getUnknown(CanonicalIV);   // Get I as a \"symbolic\" SCEV.\n\n  // Promote S up to the canonical IV type, if the cast is foldable.\n  const SCEV *NewS = S;\n  const SCEV *Ext = SE.getNoopOrAnyExtend(S, CanonicalIV->getType());\n  if (isa<SCEVAddRecExpr>(Ext))\n    NewS = Ext;\n\n  const SCEV *V = cast<SCEVAddRecExpr>(NewS)->evaluateAtIteration(IH, SE);\n  //cerr << \"Evaluated: \" << *this << \"\\n     to: \" << *V << \"\\n\";\n\n  // Truncate the result down to the original type, if needed.\n  const SCEV *T = SE.getTruncateOrNoop(V, Ty);\n  return expand(T);\n}\n\nValue *SCEVExpander::visitPtrToIntExpr(const SCEVPtrToIntExpr *S) {\n  Value *V =\n      expandCodeForImpl(S->getOperand(), S->getOperand()->getType(), false);\n  return Builder.CreatePtrToInt(V, S->getType());\n}\n\nValue *SCEVExpander::visitTruncateExpr(const SCEVTruncateExpr *S) {\n  Type *Ty = SE.getEffectiveSCEVType(S->getType());\n  Value *V = expandCodeForImpl(\n      S->getOperand(), SE.getEffectiveSCEVType(S->getOperand()->getType()),\n      false);\n  return Builder.CreateTrunc(V, Ty);\n}\n\nValue *SCEVExpander::visitZeroExtendExpr(const SCEVZeroExtendExpr *S) {\n  Type *Ty = SE.getEffectiveSCEVType(S->getType());\n  Value *V = expandCodeForImpl(\n      S->getOperand(), SE.getEffectiveSCEVType(S->getOperand()->getType()),\n      false);\n  return Builder.CreateZExt(V, Ty);\n}\n\nValue *SCEVExpander::visitSignExtendExpr(const SCEVSignExtendExpr *S) {\n  Type *Ty = SE.getEffectiveSCEVType(S->getType());\n  Value *V = expandCodeForImpl(\n      S->getOperand(), SE.getEffectiveSCEVType(S->getOperand()->getType()),\n      false);\n  return Builder.CreateSExt(V, Ty);\n}\n\nValue *SCEVExpander::visitSMaxExpr(const SCEVSMaxExpr *S) {\n  Value *LHS = expand(S->getOperand(S->getNumOperands()-1));\n  Type *Ty = LHS->getType();\n  for (int i = S->getNumOperands()-2; i >= 0; --i) {\n    // In the case of mixed integer and pointer types, do the\n    // rest of the comparisons as integer.\n    Type *OpTy = S->getOperand(i)->getType();\n    if (OpTy->isIntegerTy() != Ty->isIntegerTy()) {\n      Ty = SE.getEffectiveSCEVType(Ty);\n      LHS = InsertNoopCastOfTo(LHS, Ty);\n    }\n    Value *RHS = expandCodeForImpl(S->getOperand(i), Ty, false);\n    Value *ICmp = Builder.CreateICmpSGT(LHS, RHS);\n    Value *Sel = Builder.CreateSelect(ICmp, LHS, RHS, \"smax\");\n    LHS = Sel;\n  }\n  // In the case of mixed integer and pointer types, cast the\n  // final result back to the pointer type.\n  if (LHS->getType() != S->getType())\n    LHS = InsertNoopCastOfTo(LHS, S->getType());\n  return LHS;\n}\n\nValue *SCEVExpander::visitUMaxExpr(const SCEVUMaxExpr *S) {\n  Value *LHS = expand(S->getOperand(S->getNumOperands()-1));\n  Type *Ty = LHS->getType();\n  for (int i = S->getNumOperands()-2; i >= 0; --i) {\n    // In the case of mixed integer and pointer types, do the\n    // rest of the comparisons as integer.\n    Type *OpTy = S->getOperand(i)->getType();\n    if (OpTy->isIntegerTy() != Ty->isIntegerTy()) {\n      Ty = SE.getEffectiveSCEVType(Ty);\n      LHS = InsertNoopCastOfTo(LHS, Ty);\n    }\n    Value *RHS = expandCodeForImpl(S->getOperand(i), Ty, false);\n    Value *ICmp = Builder.CreateICmpUGT(LHS, RHS);\n    Value *Sel = Builder.CreateSelect(ICmp, LHS, RHS, \"umax\");\n    LHS = Sel;\n  }\n  // In the case of mixed integer and pointer types, cast the\n  // final result back to the pointer type.\n  if (LHS->getType() != S->getType())\n    LHS = InsertNoopCastOfTo(LHS, S->getType());\n  return LHS;\n}\n\nValue *SCEVExpander::visitSMinExpr(const SCEVSMinExpr *S) {\n  Value *LHS = expand(S->getOperand(S->getNumOperands() - 1));\n  Type *Ty = LHS->getType();\n  for (int i = S->getNumOperands() - 2; i >= 0; --i) {\n    // In the case of mixed integer and pointer types, do the\n    // rest of the comparisons as integer.\n    Type *OpTy = S->getOperand(i)->getType();\n    if (OpTy->isIntegerTy() != Ty->isIntegerTy()) {\n      Ty = SE.getEffectiveSCEVType(Ty);\n      LHS = InsertNoopCastOfTo(LHS, Ty);\n    }\n    Value *RHS = expandCodeForImpl(S->getOperand(i), Ty, false);\n    Value *ICmp = Builder.CreateICmpSLT(LHS, RHS);\n    Value *Sel = Builder.CreateSelect(ICmp, LHS, RHS, \"smin\");\n    LHS = Sel;\n  }\n  // In the case of mixed integer and pointer types, cast the\n  // final result back to the pointer type.\n  if (LHS->getType() != S->getType())\n    LHS = InsertNoopCastOfTo(LHS, S->getType());\n  return LHS;\n}\n\nValue *SCEVExpander::visitUMinExpr(const SCEVUMinExpr *S) {\n  Value *LHS = expand(S->getOperand(S->getNumOperands() - 1));\n  Type *Ty = LHS->getType();\n  for (int i = S->getNumOperands() - 2; i >= 0; --i) {\n    // In the case of mixed integer and pointer types, do the\n    // rest of the comparisons as integer.\n    Type *OpTy = S->getOperand(i)->getType();\n    if (OpTy->isIntegerTy() != Ty->isIntegerTy()) {\n      Ty = SE.getEffectiveSCEVType(Ty);\n      LHS = InsertNoopCastOfTo(LHS, Ty);\n    }\n    Value *RHS = expandCodeForImpl(S->getOperand(i), Ty, false);\n    Value *ICmp = Builder.CreateICmpULT(LHS, RHS);\n    Value *Sel = Builder.CreateSelect(ICmp, LHS, RHS, \"umin\");\n    LHS = Sel;\n  }\n  // In the case of mixed integer and pointer types, cast the\n  // final result back to the pointer type.\n  if (LHS->getType() != S->getType())\n    LHS = InsertNoopCastOfTo(LHS, S->getType());\n  return LHS;\n}\n\nValue *SCEVExpander::expandCodeForImpl(const SCEV *SH, Type *Ty,\n                                       Instruction *IP, bool Root) {\n  setInsertPoint(IP);\n  Value *V = expandCodeForImpl(SH, Ty, Root);\n  return V;\n}\n\nValue *SCEVExpander::expandCodeForImpl(const SCEV *SH, Type *Ty, bool Root) {\n  // Expand the code for this SCEV.\n  Value *V = expand(SH);\n\n  if (PreserveLCSSA) {\n    if (auto *Inst = dyn_cast<Instruction>(V)) {\n      // Create a temporary instruction to at the current insertion point, so we\n      // can hand it off to the helper to create LCSSA PHIs if required for the\n      // new use.\n      // FIXME: Ideally formLCSSAForInstructions (used in fixupLCSSAFormFor)\n      // would accept a insertion point and return an LCSSA phi for that\n      // insertion point, so there is no need to insert & remove the temporary\n      // instruction.\n      Instruction *Tmp;\n      if (Inst->getType()->isIntegerTy())\n        Tmp =\n            cast<Instruction>(Builder.CreateAdd(Inst, Inst, \"tmp.lcssa.user\"));\n      else {\n        assert(Inst->getType()->isPointerTy());\n        Tmp = cast<Instruction>(\n            Builder.CreateGEP(Inst, Builder.getInt32(1), \"tmp.lcssa.user\"));\n      }\n      V = fixupLCSSAFormFor(Tmp, 0);\n\n      // Clean up temporary instruction.\n      InsertedValues.erase(Tmp);\n      InsertedPostIncValues.erase(Tmp);\n      Tmp->eraseFromParent();\n    }\n  }\n\n  InsertedExpressions[std::make_pair(SH, &*Builder.GetInsertPoint())] = V;\n  if (Ty) {\n    assert(SE.getTypeSizeInBits(Ty) == SE.getTypeSizeInBits(SH->getType()) &&\n           \"non-trivial casts should be done with the SCEVs directly!\");\n    V = InsertNoopCastOfTo(V, Ty);\n  }\n  return V;\n}\n\nScalarEvolution::ValueOffsetPair\nSCEVExpander::FindValueInExprValueMap(const SCEV *S,\n                                      const Instruction *InsertPt) {\n  SetVector<ScalarEvolution::ValueOffsetPair> *Set = SE.getSCEVValues(S);\n  // If the expansion is not in CanonicalMode, and the SCEV contains any\n  // sub scAddRecExpr type SCEV, it is required to expand the SCEV literally.\n  if (CanonicalMode || !SE.containsAddRecurrence(S)) {\n    // If S is scConstant, it may be worse to reuse an existing Value.\n    if (S->getSCEVType() != scConstant && Set) {\n      // Choose a Value from the set which dominates the insertPt.\n      // insertPt should be inside the Value's parent loop so as not to break\n      // the LCSSA form.\n      for (auto const &VOPair : *Set) {\n        Value *V = VOPair.first;\n        ConstantInt *Offset = VOPair.second;\n        Instruction *EntInst = nullptr;\n        if (V && isa<Instruction>(V) && (EntInst = cast<Instruction>(V)) &&\n            S->getType() == V->getType() &&\n            EntInst->getFunction() == InsertPt->getFunction() &&\n            SE.DT.dominates(EntInst, InsertPt) &&\n            (SE.LI.getLoopFor(EntInst->getParent()) == nullptr ||\n             SE.LI.getLoopFor(EntInst->getParent())->contains(InsertPt)))\n          return {V, Offset};\n      }\n    }\n  }\n  return {nullptr, nullptr};\n}\n\n// The expansion of SCEV will either reuse a previous Value in ExprValueMap,\n// or expand the SCEV literally. Specifically, if the expansion is in LSRMode,\n// and the SCEV contains any sub scAddRecExpr type SCEV, it will be expanded\n// literally, to prevent LSR's transformed SCEV from being reverted. Otherwise,\n// the expansion will try to reuse Value from ExprValueMap, and only when it\n// fails, expand the SCEV literally.\nValue *SCEVExpander::expand(const SCEV *S) {\n  // Compute an insertion point for this SCEV object. Hoist the instructions\n  // as far out in the loop nest as possible.\n  Instruction *InsertPt = &*Builder.GetInsertPoint();\n\n  // We can move insertion point only if there is no div or rem operations\n  // otherwise we are risky to move it over the check for zero denominator.\n  auto SafeToHoist = [](const SCEV *S) {\n    return !SCEVExprContains(S, [](const SCEV *S) {\n              if (const auto *D = dyn_cast<SCEVUDivExpr>(S)) {\n                if (const auto *SC = dyn_cast<SCEVConstant>(D->getRHS()))\n                  // Division by non-zero constants can be hoisted.\n                  return SC->getValue()->isZero();\n                // All other divisions should not be moved as they may be\n                // divisions by zero and should be kept within the\n                // conditions of the surrounding loops that guard their\n                // execution (see PR35406).\n                return true;\n              }\n              return false;\n            });\n  };\n  if (SafeToHoist(S)) {\n    for (Loop *L = SE.LI.getLoopFor(Builder.GetInsertBlock());;\n         L = L->getParentLoop()) {\n      if (SE.isLoopInvariant(S, L)) {\n        if (!L) break;\n        if (BasicBlock *Preheader = L->getLoopPreheader())\n          InsertPt = Preheader->getTerminator();\n        else\n          // LSR sets the insertion point for AddRec start/step values to the\n          // block start to simplify value reuse, even though it's an invalid\n          // position. SCEVExpander must correct for this in all cases.\n          InsertPt = &*L->getHeader()->getFirstInsertionPt();\n      } else {\n        // If the SCEV is computable at this level, insert it into the header\n        // after the PHIs (and after any other instructions that we've inserted\n        // there) so that it is guaranteed to dominate any user inside the loop.\n        if (L && SE.hasComputableLoopEvolution(S, L) && !PostIncLoops.count(L))\n          InsertPt = &*L->getHeader()->getFirstInsertionPt();\n\n        while (InsertPt->getIterator() != Builder.GetInsertPoint() &&\n               (isInsertedInstruction(InsertPt) ||\n                isa<DbgInfoIntrinsic>(InsertPt))) {\n          InsertPt = &*std::next(InsertPt->getIterator());\n        }\n        break;\n      }\n    }\n  }\n\n  // Check to see if we already expanded this here.\n  auto I = InsertedExpressions.find(std::make_pair(S, InsertPt));\n  if (I != InsertedExpressions.end())\n    return I->second;\n\n  SCEVInsertPointGuard Guard(Builder, this);\n  Builder.SetInsertPoint(InsertPt);\n\n  // Expand the expression into instructions.\n  ScalarEvolution::ValueOffsetPair VO = FindValueInExprValueMap(S, InsertPt);\n  Value *V = VO.first;\n\n  if (!V)\n    V = visit(S);\n  else if (VO.second) {\n    if (PointerType *Vty = dyn_cast<PointerType>(V->getType())) {\n      Type *Ety = Vty->getPointerElementType();\n      int64_t Offset = VO.second->getSExtValue();\n      int64_t ESize = SE.getTypeSizeInBits(Ety);\n      if ((Offset * 8) % ESize == 0) {\n        ConstantInt *Idx =\n            ConstantInt::getSigned(VO.second->getType(), -(Offset * 8) / ESize);\n        V = Builder.CreateGEP(Ety, V, Idx, \"scevgep\");\n      } else {\n        ConstantInt *Idx =\n            ConstantInt::getSigned(VO.second->getType(), -Offset);\n        unsigned AS = Vty->getAddressSpace();\n        V = Builder.CreateBitCast(V, Type::getInt8PtrTy(SE.getContext(), AS));\n        V = Builder.CreateGEP(Type::getInt8Ty(SE.getContext()), V, Idx,\n                              \"uglygep\");\n        V = Builder.CreateBitCast(V, Vty);\n      }\n    } else {\n      V = Builder.CreateSub(V, VO.second);\n    }\n  }\n  // Remember the expanded value for this SCEV at this location.\n  //\n  // This is independent of PostIncLoops. The mapped value simply materializes\n  // the expression at this insertion point. If the mapped value happened to be\n  // a postinc expansion, it could be reused by a non-postinc user, but only if\n  // its insertion point was already at the head of the loop.\n  InsertedExpressions[std::make_pair(S, InsertPt)] = V;\n  return V;\n}\n\nvoid SCEVExpander::rememberInstruction(Value *I) {\n  auto DoInsert = [this](Value *V) {\n    if (!PostIncLoops.empty())\n      InsertedPostIncValues.insert(V);\n    else\n      InsertedValues.insert(V);\n  };\n  DoInsert(I);\n\n  if (!PreserveLCSSA)\n    return;\n\n  if (auto *Inst = dyn_cast<Instruction>(I)) {\n    // A new instruction has been added, which might introduce new uses outside\n    // a defining loop. Fix LCSSA from for each operand of the new instruction,\n    // if required.\n    for (unsigned OpIdx = 0, OpEnd = Inst->getNumOperands(); OpIdx != OpEnd;\n         OpIdx++)\n      fixupLCSSAFormFor(Inst, OpIdx);\n  }\n}\n\n/// replaceCongruentIVs - Check for congruent phis in this loop header and\n/// replace them with their most canonical representative. Return the number of\n/// phis eliminated.\n///\n/// This does not depend on any SCEVExpander state but should be used in\n/// the same context that SCEVExpander is used.\nunsigned\nSCEVExpander::replaceCongruentIVs(Loop *L, const DominatorTree *DT,\n                                  SmallVectorImpl<WeakTrackingVH> &DeadInsts,\n                                  const TargetTransformInfo *TTI) {\n  // Find integer phis in order of increasing width.\n  SmallVector<PHINode*, 8> Phis;\n  for (PHINode &PN : L->getHeader()->phis())\n    Phis.push_back(&PN);\n\n  if (TTI)\n    llvm::sort(Phis, [](Value *LHS, Value *RHS) {\n      // Put pointers at the back and make sure pointer < pointer = false.\n      if (!LHS->getType()->isIntegerTy() || !RHS->getType()->isIntegerTy())\n        return RHS->getType()->isIntegerTy() && !LHS->getType()->isIntegerTy();\n      return RHS->getType()->getPrimitiveSizeInBits().getFixedSize() <\n             LHS->getType()->getPrimitiveSizeInBits().getFixedSize();\n    });\n\n  unsigned NumElim = 0;\n  DenseMap<const SCEV *, PHINode *> ExprToIVMap;\n  // Process phis from wide to narrow. Map wide phis to their truncation\n  // so narrow phis can reuse them.\n  for (PHINode *Phi : Phis) {\n    auto SimplifyPHINode = [&](PHINode *PN) -> Value * {\n      if (Value *V = SimplifyInstruction(PN, {DL, &SE.TLI, &SE.DT, &SE.AC}))\n        return V;\n      if (!SE.isSCEVable(PN->getType()))\n        return nullptr;\n      auto *Const = dyn_cast<SCEVConstant>(SE.getSCEV(PN));\n      if (!Const)\n        return nullptr;\n      return Const->getValue();\n    };\n\n    // Fold constant phis. They may be congruent to other constant phis and\n    // would confuse the logic below that expects proper IVs.\n    if (Value *V = SimplifyPHINode(Phi)) {\n      if (V->getType() != Phi->getType())\n        continue;\n      Phi->replaceAllUsesWith(V);\n      DeadInsts.emplace_back(Phi);\n      ++NumElim;\n      DEBUG_WITH_TYPE(DebugType, dbgs()\n                      << \"INDVARS: Eliminated constant iv: \" << *Phi << '\\n');\n      continue;\n    }\n\n    if (!SE.isSCEVable(Phi->getType()))\n      continue;\n\n    PHINode *&OrigPhiRef = ExprToIVMap[SE.getSCEV(Phi)];\n    if (!OrigPhiRef) {\n      OrigPhiRef = Phi;\n      if (Phi->getType()->isIntegerTy() && TTI &&\n          TTI->isTruncateFree(Phi->getType(), Phis.back()->getType())) {\n        // This phi can be freely truncated to the narrowest phi type. Map the\n        // truncated expression to it so it will be reused for narrow types.\n        const SCEV *TruncExpr =\n          SE.getTruncateExpr(SE.getSCEV(Phi), Phis.back()->getType());\n        ExprToIVMap[TruncExpr] = Phi;\n      }\n      continue;\n    }\n\n    // Replacing a pointer phi with an integer phi or vice-versa doesn't make\n    // sense.\n    if (OrigPhiRef->getType()->isPointerTy() != Phi->getType()->isPointerTy())\n      continue;\n\n    if (BasicBlock *LatchBlock = L->getLoopLatch()) {\n      Instruction *OrigInc = dyn_cast<Instruction>(\n          OrigPhiRef->getIncomingValueForBlock(LatchBlock));\n      Instruction *IsomorphicInc =\n          dyn_cast<Instruction>(Phi->getIncomingValueForBlock(LatchBlock));\n\n      if (OrigInc && IsomorphicInc) {\n        // If this phi has the same width but is more canonical, replace the\n        // original with it. As part of the \"more canonical\" determination,\n        // respect a prior decision to use an IV chain.\n        if (OrigPhiRef->getType() == Phi->getType() &&\n            !(ChainedPhis.count(Phi) ||\n              isExpandedAddRecExprPHI(OrigPhiRef, OrigInc, L)) &&\n            (ChainedPhis.count(Phi) ||\n             isExpandedAddRecExprPHI(Phi, IsomorphicInc, L))) {\n          std::swap(OrigPhiRef, Phi);\n          std::swap(OrigInc, IsomorphicInc);\n        }\n        // Replacing the congruent phi is sufficient because acyclic\n        // redundancy elimination, CSE/GVN, should handle the\n        // rest. However, once SCEV proves that a phi is congruent,\n        // it's often the head of an IV user cycle that is isomorphic\n        // with the original phi. It's worth eagerly cleaning up the\n        // common case of a single IV increment so that DeleteDeadPHIs\n        // can remove cycles that had postinc uses.\n        const SCEV *TruncExpr =\n            SE.getTruncateOrNoop(SE.getSCEV(OrigInc), IsomorphicInc->getType());\n        if (OrigInc != IsomorphicInc &&\n            TruncExpr == SE.getSCEV(IsomorphicInc) &&\n            SE.LI.replacementPreservesLCSSAForm(IsomorphicInc, OrigInc) &&\n            hoistIVInc(OrigInc, IsomorphicInc)) {\n          DEBUG_WITH_TYPE(DebugType,\n                          dbgs() << \"INDVARS: Eliminated congruent iv.inc: \"\n                                 << *IsomorphicInc << '\\n');\n          Value *NewInc = OrigInc;\n          if (OrigInc->getType() != IsomorphicInc->getType()) {\n            Instruction *IP = nullptr;\n            if (PHINode *PN = dyn_cast<PHINode>(OrigInc))\n              IP = &*PN->getParent()->getFirstInsertionPt();\n            else\n              IP = OrigInc->getNextNode();\n\n            IRBuilder<> Builder(IP);\n            Builder.SetCurrentDebugLocation(IsomorphicInc->getDebugLoc());\n            NewInc = Builder.CreateTruncOrBitCast(\n                OrigInc, IsomorphicInc->getType(), IVName);\n          }\n          IsomorphicInc->replaceAllUsesWith(NewInc);\n          DeadInsts.emplace_back(IsomorphicInc);\n        }\n      }\n    }\n    DEBUG_WITH_TYPE(DebugType, dbgs() << \"INDVARS: Eliminated congruent iv: \"\n                                      << *Phi << '\\n');\n    DEBUG_WITH_TYPE(DebugType, dbgs() << \"INDVARS: Original iv: \"\n                                      << *OrigPhiRef << '\\n');\n    ++NumElim;\n    Value *NewIV = OrigPhiRef;\n    if (OrigPhiRef->getType() != Phi->getType()) {\n      IRBuilder<> Builder(&*L->getHeader()->getFirstInsertionPt());\n      Builder.SetCurrentDebugLocation(Phi->getDebugLoc());\n      NewIV = Builder.CreateTruncOrBitCast(OrigPhiRef, Phi->getType(), IVName);\n    }\n    Phi->replaceAllUsesWith(NewIV);\n    DeadInsts.emplace_back(Phi);\n  }\n  return NumElim;\n}\n\nOptional<ScalarEvolution::ValueOffsetPair>\nSCEVExpander::getRelatedExistingExpansion(const SCEV *S, const Instruction *At,\n                                          Loop *L) {\n  using namespace llvm::PatternMatch;\n\n  SmallVector<BasicBlock *, 4> ExitingBlocks;\n  L->getExitingBlocks(ExitingBlocks);\n\n  // Look for suitable value in simple conditions at the loop exits.\n  for (BasicBlock *BB : ExitingBlocks) {\n    ICmpInst::Predicate Pred;\n    Instruction *LHS, *RHS;\n\n    if (!match(BB->getTerminator(),\n               m_Br(m_ICmp(Pred, m_Instruction(LHS), m_Instruction(RHS)),\n                    m_BasicBlock(), m_BasicBlock())))\n      continue;\n\n    if (SE.getSCEV(LHS) == S && SE.DT.dominates(LHS, At))\n      return ScalarEvolution::ValueOffsetPair(LHS, nullptr);\n\n    if (SE.getSCEV(RHS) == S && SE.DT.dominates(RHS, At))\n      return ScalarEvolution::ValueOffsetPair(RHS, nullptr);\n  }\n\n  // Use expand's logic which is used for reusing a previous Value in\n  // ExprValueMap.\n  ScalarEvolution::ValueOffsetPair VO = FindValueInExprValueMap(S, At);\n  if (VO.first)\n    return VO;\n\n  // There is potential to make this significantly smarter, but this simple\n  // heuristic already gets some interesting cases.\n\n  // Can not find suitable value.\n  return None;\n}\n\ntemplate<typename T> static int costAndCollectOperands(\n  const SCEVOperand &WorkItem, const TargetTransformInfo &TTI,\n  TargetTransformInfo::TargetCostKind CostKind,\n  SmallVectorImpl<SCEVOperand> &Worklist) {\n\n  const T *S = cast<T>(WorkItem.S);\n  int Cost = 0;\n  // Object to help map SCEV operands to expanded IR instructions.\n  struct OperationIndices {\n    OperationIndices(unsigned Opc, size_t min, size_t max) :\n      Opcode(Opc), MinIdx(min), MaxIdx(max) { }\n    unsigned Opcode;\n    size_t MinIdx;\n    size_t MaxIdx;\n  };\n\n  // Collect the operations of all the instructions that will be needed to\n  // expand the SCEVExpr. This is so that when we come to cost the operands,\n  // we know what the generated user(s) will be.\n  SmallVector<OperationIndices, 2> Operations;\n\n  auto CastCost = [&](unsigned Opcode) {\n    Operations.emplace_back(Opcode, 0, 0);\n    return TTI.getCastInstrCost(Opcode, S->getType(),\n                                S->getOperand(0)->getType(),\n                                TTI::CastContextHint::None, CostKind);\n  };\n\n  auto ArithCost = [&](unsigned Opcode, unsigned NumRequired,\n                       unsigned MinIdx = 0, unsigned MaxIdx = 1) {\n    Operations.emplace_back(Opcode, MinIdx, MaxIdx);\n    return NumRequired *\n      TTI.getArithmeticInstrCost(Opcode, S->getType(), CostKind);\n  };\n\n  auto CmpSelCost = [&](unsigned Opcode, unsigned NumRequired,\n                        unsigned MinIdx, unsigned MaxIdx) {\n    Operations.emplace_back(Opcode, MinIdx, MaxIdx);\n    Type *OpType = S->getOperand(0)->getType();\n    return NumRequired * TTI.getCmpSelInstrCost(\n                             Opcode, OpType, CmpInst::makeCmpResultType(OpType),\n                             CmpInst::BAD_ICMP_PREDICATE, CostKind);\n  };\n\n  switch (S->getSCEVType()) {\n  case scCouldNotCompute:\n    llvm_unreachable(\"Attempt to use a SCEVCouldNotCompute object!\");\n  case scUnknown:\n  case scConstant:\n    return 0;\n  case scPtrToInt:\n    Cost = CastCost(Instruction::PtrToInt);\n    break;\n  case scTruncate:\n    Cost = CastCost(Instruction::Trunc);\n    break;\n  case scZeroExtend:\n    Cost = CastCost(Instruction::ZExt);\n    break;\n  case scSignExtend:\n    Cost = CastCost(Instruction::SExt);\n    break;\n  case scUDivExpr: {\n    unsigned Opcode = Instruction::UDiv;\n    if (auto *SC = dyn_cast<SCEVConstant>(S->getOperand(1)))\n      if (SC->getAPInt().isPowerOf2())\n        Opcode = Instruction::LShr;\n    Cost = ArithCost(Opcode, 1);\n    break;\n  }\n  case scAddExpr:\n    Cost = ArithCost(Instruction::Add, S->getNumOperands() - 1);\n    break;\n  case scMulExpr:\n    // TODO: this is a very pessimistic cost modelling for Mul,\n    // because of Bin Pow algorithm actually used by the expander,\n    // see SCEVExpander::visitMulExpr(), ExpandOpBinPowN().\n    Cost = ArithCost(Instruction::Mul, S->getNumOperands() - 1);\n    break;\n  case scSMaxExpr:\n  case scUMaxExpr:\n  case scSMinExpr:\n  case scUMinExpr: {\n    Cost += CmpSelCost(Instruction::ICmp, S->getNumOperands() - 1, 0, 1);\n    Cost += CmpSelCost(Instruction::Select, S->getNumOperands() - 1, 0, 2);\n    break;\n  }\n  case scAddRecExpr: {\n    // In this polynominal, we may have some zero operands, and we shouldn't\n    // really charge for those. So how many non-zero coeffients are there?\n    int NumTerms = llvm::count_if(S->operands(), [](const SCEV *Op) {\n                                    return !Op->isZero();\n                                  });\n\n    assert(NumTerms >= 1 && \"Polynominal should have at least one term.\");\n    assert(!(*std::prev(S->operands().end()))->isZero() &&\n           \"Last operand should not be zero\");\n\n    // Ignoring constant term (operand 0), how many of the coeffients are u> 1?\n    int NumNonZeroDegreeNonOneTerms =\n      llvm::count_if(S->operands(), [](const SCEV *Op) {\n                      auto *SConst = dyn_cast<SCEVConstant>(Op);\n                      return !SConst || SConst->getAPInt().ugt(1);\n                    });\n\n    // Much like with normal add expr, the polynominal will require\n    // one less addition than the number of it's terms.\n    int AddCost = ArithCost(Instruction::Add, NumTerms - 1,\n                            /*MinIdx*/1, /*MaxIdx*/1);\n    // Here, *each* one of those will require a multiplication.\n    int MulCost = ArithCost(Instruction::Mul, NumNonZeroDegreeNonOneTerms);\n    Cost = AddCost + MulCost;\n\n    // What is the degree of this polynominal?\n    int PolyDegree = S->getNumOperands() - 1;\n    assert(PolyDegree >= 1 && \"Should be at least affine.\");\n\n    // The final term will be:\n    //   Op_{PolyDegree} * x ^ {PolyDegree}\n    // Where  x ^ {PolyDegree}  will again require PolyDegree-1 mul operations.\n    // Note that  x ^ {PolyDegree} = x * x ^ {PolyDegree-1}  so charging for\n    // x ^ {PolyDegree}  will give us  x ^ {2} .. x ^ {PolyDegree-1}  for free.\n    // FIXME: this is conservatively correct, but might be overly pessimistic.\n    Cost += MulCost * (PolyDegree - 1);\n    break;\n  }\n  }\n\n  for (auto &CostOp : Operations) {\n    for (auto SCEVOp : enumerate(S->operands())) {\n      // Clamp the index to account for multiple IR operations being chained.\n      size_t MinIdx = std::max(SCEVOp.index(), CostOp.MinIdx);\n      size_t OpIdx = std::min(MinIdx, CostOp.MaxIdx);\n      Worklist.emplace_back(CostOp.Opcode, OpIdx, SCEVOp.value());\n    }\n  }\n  return Cost;\n}\n\nbool SCEVExpander::isHighCostExpansionHelper(\n    const SCEVOperand &WorkItem, Loop *L, const Instruction &At,\n    int &BudgetRemaining, const TargetTransformInfo &TTI,\n    SmallPtrSetImpl<const SCEV *> &Processed,\n    SmallVectorImpl<SCEVOperand> &Worklist) {\n  if (BudgetRemaining < 0)\n    return true; // Already run out of budget, give up.\n\n  const SCEV *S = WorkItem.S;\n  // Was the cost of expansion of this expression already accounted for?\n  if (!isa<SCEVConstant>(S) && !Processed.insert(S).second)\n    return false; // We have already accounted for this expression.\n\n  // If we can find an existing value for this scev available at the point \"At\"\n  // then consider the expression cheap.\n  if (getRelatedExistingExpansion(S, &At, L))\n    return false; // Consider the expression to be free.\n\n  TargetTransformInfo::TargetCostKind CostKind =\n      L->getHeader()->getParent()->hasMinSize()\n          ? TargetTransformInfo::TCK_CodeSize\n          : TargetTransformInfo::TCK_RecipThroughput;\n\n  switch (S->getSCEVType()) {\n  case scCouldNotCompute:\n    llvm_unreachable(\"Attempt to use a SCEVCouldNotCompute object!\");\n  case scUnknown:\n    // Assume to be zero-cost.\n    return false;\n  case scConstant: {\n    // Only evalulate the costs of constants when optimizing for size.\n    if (CostKind != TargetTransformInfo::TCK_CodeSize)\n      return 0;\n    const APInt &Imm = cast<SCEVConstant>(S)->getAPInt();\n    Type *Ty = S->getType();\n    BudgetRemaining -= TTI.getIntImmCostInst(\n        WorkItem.ParentOpcode, WorkItem.OperandIdx, Imm, Ty, CostKind);\n    return BudgetRemaining < 0;\n  }\n  case scTruncate:\n  case scPtrToInt:\n  case scZeroExtend:\n  case scSignExtend: {\n    int Cost =\n        costAndCollectOperands<SCEVCastExpr>(WorkItem, TTI, CostKind, Worklist);\n    BudgetRemaining -= Cost;\n    return false; // Will answer upon next entry into this function.\n  }\n  case scUDivExpr: {\n    // UDivExpr is very likely a UDiv that ScalarEvolution's HowFarToZero or\n    // HowManyLessThans produced to compute a precise expression, rather than a\n    // UDiv from the user's code. If we can't find a UDiv in the code with some\n    // simple searching, we need to account for it's cost.\n\n    // At the beginning of this function we already tried to find existing\n    // value for plain 'S'. Now try to lookup 'S + 1' since it is common\n    // pattern involving division. This is just a simple search heuristic.\n    if (getRelatedExistingExpansion(\n            SE.getAddExpr(S, SE.getConstant(S->getType(), 1)), &At, L))\n      return false; // Consider it to be free.\n\n    int Cost =\n        costAndCollectOperands<SCEVUDivExpr>(WorkItem, TTI, CostKind, Worklist);\n    // Need to count the cost of this UDiv.\n    BudgetRemaining -= Cost;\n    return false; // Will answer upon next entry into this function.\n  }\n  case scAddExpr:\n  case scMulExpr:\n  case scUMaxExpr:\n  case scSMaxExpr:\n  case scUMinExpr:\n  case scSMinExpr: {\n    assert(cast<SCEVNAryExpr>(S)->getNumOperands() > 1 &&\n           \"Nary expr should have more than 1 operand.\");\n    // The simple nary expr will require one less op (or pair of ops)\n    // than the number of it's terms.\n    int Cost =\n        costAndCollectOperands<SCEVNAryExpr>(WorkItem, TTI, CostKind, Worklist);\n    BudgetRemaining -= Cost;\n    return BudgetRemaining < 0;\n  }\n  case scAddRecExpr: {\n    assert(cast<SCEVAddRecExpr>(S)->getNumOperands() >= 2 &&\n           \"Polynomial should be at least linear\");\n    BudgetRemaining -= costAndCollectOperands<SCEVAddRecExpr>(\n        WorkItem, TTI, CostKind, Worklist);\n    return BudgetRemaining < 0;\n  }\n  }\n  llvm_unreachable(\"Unknown SCEV kind!\");\n}\n\nValue *SCEVExpander::expandCodeForPredicate(const SCEVPredicate *Pred,\n                                            Instruction *IP) {\n  assert(IP);\n  switch (Pred->getKind()) {\n  case SCEVPredicate::P_Union:\n    return expandUnionPredicate(cast<SCEVUnionPredicate>(Pred), IP);\n  case SCEVPredicate::P_Equal:\n    return expandEqualPredicate(cast<SCEVEqualPredicate>(Pred), IP);\n  case SCEVPredicate::P_Wrap: {\n    auto *AddRecPred = cast<SCEVWrapPredicate>(Pred);\n    return expandWrapPredicate(AddRecPred, IP);\n  }\n  }\n  llvm_unreachable(\"Unknown SCEV predicate type\");\n}\n\nValue *SCEVExpander::expandEqualPredicate(const SCEVEqualPredicate *Pred,\n                                          Instruction *IP) {\n  Value *Expr0 =\n      expandCodeForImpl(Pred->getLHS(), Pred->getLHS()->getType(), IP, false);\n  Value *Expr1 =\n      expandCodeForImpl(Pred->getRHS(), Pred->getRHS()->getType(), IP, false);\n\n  Builder.SetInsertPoint(IP);\n  auto *I = Builder.CreateICmpNE(Expr0, Expr1, \"ident.check\");\n  return I;\n}\n\nValue *SCEVExpander::generateOverflowCheck(const SCEVAddRecExpr *AR,\n                                           Instruction *Loc, bool Signed) {\n  assert(AR->isAffine() && \"Cannot generate RT check for \"\n                           \"non-affine expression\");\n\n  SCEVUnionPredicate Pred;\n  const SCEV *ExitCount =\n      SE.getPredicatedBackedgeTakenCount(AR->getLoop(), Pred);\n\n  assert(!isa<SCEVCouldNotCompute>(ExitCount) && \"Invalid loop count\");\n\n  const SCEV *Step = AR->getStepRecurrence(SE);\n  const SCEV *Start = AR->getStart();\n\n  Type *ARTy = AR->getType();\n  unsigned SrcBits = SE.getTypeSizeInBits(ExitCount->getType());\n  unsigned DstBits = SE.getTypeSizeInBits(ARTy);\n\n  // The expression {Start,+,Step} has nusw/nssw if\n  //   Step < 0, Start - |Step| * Backedge <= Start\n  //   Step >= 0, Start + |Step| * Backedge > Start\n  // and |Step| * Backedge doesn't unsigned overflow.\n\n  IntegerType *CountTy = IntegerType::get(Loc->getContext(), SrcBits);\n  Builder.SetInsertPoint(Loc);\n  Value *TripCountVal = expandCodeForImpl(ExitCount, CountTy, Loc, false);\n\n  IntegerType *Ty =\n      IntegerType::get(Loc->getContext(), SE.getTypeSizeInBits(ARTy));\n  Type *ARExpandTy = DL.isNonIntegralPointerType(ARTy) ? ARTy : Ty;\n\n  Value *StepValue = expandCodeForImpl(Step, Ty, Loc, false);\n  Value *NegStepValue =\n      expandCodeForImpl(SE.getNegativeSCEV(Step), Ty, Loc, false);\n  Value *StartValue = expandCodeForImpl(Start, ARExpandTy, Loc, false);\n\n  ConstantInt *Zero =\n      ConstantInt::get(Loc->getContext(), APInt::getNullValue(DstBits));\n\n  Builder.SetInsertPoint(Loc);\n  // Compute |Step|\n  Value *StepCompare = Builder.CreateICmp(ICmpInst::ICMP_SLT, StepValue, Zero);\n  Value *AbsStep = Builder.CreateSelect(StepCompare, NegStepValue, StepValue);\n\n  // Get the backedge taken count and truncate or extended to the AR type.\n  Value *TruncTripCount = Builder.CreateZExtOrTrunc(TripCountVal, Ty);\n  auto *MulF = Intrinsic::getDeclaration(Loc->getModule(),\n                                         Intrinsic::umul_with_overflow, Ty);\n\n  // Compute |Step| * Backedge\n  CallInst *Mul = Builder.CreateCall(MulF, {AbsStep, TruncTripCount}, \"mul\");\n  Value *MulV = Builder.CreateExtractValue(Mul, 0, \"mul.result\");\n  Value *OfMul = Builder.CreateExtractValue(Mul, 1, \"mul.overflow\");\n\n  // Compute:\n  //   Start + |Step| * Backedge < Start\n  //   Start - |Step| * Backedge > Start\n  Value *Add = nullptr, *Sub = nullptr;\n  if (PointerType *ARPtrTy = dyn_cast<PointerType>(ARExpandTy)) {\n    const SCEV *MulS = SE.getSCEV(MulV);\n    const SCEV *NegMulS = SE.getNegativeSCEV(MulS);\n    Add = Builder.CreateBitCast(expandAddToGEP(MulS, ARPtrTy, Ty, StartValue),\n                                ARPtrTy);\n    Sub = Builder.CreateBitCast(\n        expandAddToGEP(NegMulS, ARPtrTy, Ty, StartValue), ARPtrTy);\n  } else {\n    Add = Builder.CreateAdd(StartValue, MulV);\n    Sub = Builder.CreateSub(StartValue, MulV);\n  }\n\n  Value *EndCompareGT = Builder.CreateICmp(\n      Signed ? ICmpInst::ICMP_SGT : ICmpInst::ICMP_UGT, Sub, StartValue);\n\n  Value *EndCompareLT = Builder.CreateICmp(\n      Signed ? ICmpInst::ICMP_SLT : ICmpInst::ICMP_ULT, Add, StartValue);\n\n  // Select the answer based on the sign of Step.\n  Value *EndCheck =\n      Builder.CreateSelect(StepCompare, EndCompareGT, EndCompareLT);\n\n  // If the backedge taken count type is larger than the AR type,\n  // check that we don't drop any bits by truncating it. If we are\n  // dropping bits, then we have overflow (unless the step is zero).\n  if (SE.getTypeSizeInBits(CountTy) > SE.getTypeSizeInBits(Ty)) {\n    auto MaxVal = APInt::getMaxValue(DstBits).zext(SrcBits);\n    auto *BackedgeCheck =\n        Builder.CreateICmp(ICmpInst::ICMP_UGT, TripCountVal,\n                           ConstantInt::get(Loc->getContext(), MaxVal));\n    BackedgeCheck = Builder.CreateAnd(\n        BackedgeCheck, Builder.CreateICmp(ICmpInst::ICMP_NE, StepValue, Zero));\n\n    EndCheck = Builder.CreateOr(EndCheck, BackedgeCheck);\n  }\n\n  return Builder.CreateOr(EndCheck, OfMul);\n}\n\nValue *SCEVExpander::expandWrapPredicate(const SCEVWrapPredicate *Pred,\n                                         Instruction *IP) {\n  const auto *A = cast<SCEVAddRecExpr>(Pred->getExpr());\n  Value *NSSWCheck = nullptr, *NUSWCheck = nullptr;\n\n  // Add a check for NUSW\n  if (Pred->getFlags() & SCEVWrapPredicate::IncrementNUSW)\n    NUSWCheck = generateOverflowCheck(A, IP, false);\n\n  // Add a check for NSSW\n  if (Pred->getFlags() & SCEVWrapPredicate::IncrementNSSW)\n    NSSWCheck = generateOverflowCheck(A, IP, true);\n\n  if (NUSWCheck && NSSWCheck)\n    return Builder.CreateOr(NUSWCheck, NSSWCheck);\n\n  if (NUSWCheck)\n    return NUSWCheck;\n\n  if (NSSWCheck)\n    return NSSWCheck;\n\n  return ConstantInt::getFalse(IP->getContext());\n}\n\nValue *SCEVExpander::expandUnionPredicate(const SCEVUnionPredicate *Union,\n                                          Instruction *IP) {\n  auto *BoolType = IntegerType::get(IP->getContext(), 1);\n  Value *Check = ConstantInt::getNullValue(BoolType);\n\n  // Loop over all checks in this set.\n  for (auto Pred : Union->getPredicates()) {\n    auto *NextCheck = expandCodeForPredicate(Pred, IP);\n    Builder.SetInsertPoint(IP);\n    Check = Builder.CreateOr(Check, NextCheck);\n  }\n\n  return Check;\n}\n\nValue *SCEVExpander::fixupLCSSAFormFor(Instruction *User, unsigned OpIdx) {\n  assert(PreserveLCSSA);\n  SmallVector<Instruction *, 1> ToUpdate;\n\n  auto *OpV = User->getOperand(OpIdx);\n  auto *OpI = dyn_cast<Instruction>(OpV);\n  if (!OpI)\n    return OpV;\n\n  Loop *DefLoop = SE.LI.getLoopFor(OpI->getParent());\n  Loop *UseLoop = SE.LI.getLoopFor(User->getParent());\n  if (!DefLoop || UseLoop == DefLoop || DefLoop->contains(UseLoop))\n    return OpV;\n\n  ToUpdate.push_back(OpI);\n  SmallVector<PHINode *, 16> PHIsToRemove;\n  formLCSSAForInstructions(ToUpdate, SE.DT, SE.LI, &SE, Builder, &PHIsToRemove);\n  for (PHINode *PN : PHIsToRemove) {\n    if (!PN->use_empty())\n      continue;\n    InsertedValues.erase(PN);\n    InsertedPostIncValues.erase(PN);\n    PN->eraseFromParent();\n  }\n\n  return User->getOperand(OpIdx);\n}\n\nnamespace {\n// Search for a SCEV subexpression that is not safe to expand.  Any expression\n// that may expand to a !isSafeToSpeculativelyExecute value is unsafe, namely\n// UDiv expressions. We don't know if the UDiv is derived from an IR divide\n// instruction, but the important thing is that we prove the denominator is\n// nonzero before expansion.\n//\n// IVUsers already checks that IV-derived expressions are safe. So this check is\n// only needed when the expression includes some subexpression that is not IV\n// derived.\n//\n// Currently, we only allow division by a nonzero constant here. If this is\n// inadequate, we could easily allow division by SCEVUnknown by using\n// ValueTracking to check isKnownNonZero().\n//\n// We cannot generally expand recurrences unless the step dominates the loop\n// header. The expander handles the special case of affine recurrences by\n// scaling the recurrence outside the loop, but this technique isn't generally\n// applicable. Expanding a nested recurrence outside a loop requires computing\n// binomial coefficients. This could be done, but the recurrence has to be in a\n// perfectly reduced form, which can't be guaranteed.\nstruct SCEVFindUnsafe {\n  ScalarEvolution &SE;\n  bool IsUnsafe;\n\n  SCEVFindUnsafe(ScalarEvolution &se): SE(se), IsUnsafe(false) {}\n\n  bool follow(const SCEV *S) {\n    if (const SCEVUDivExpr *D = dyn_cast<SCEVUDivExpr>(S)) {\n      const SCEVConstant *SC = dyn_cast<SCEVConstant>(D->getRHS());\n      if (!SC || SC->getValue()->isZero()) {\n        IsUnsafe = true;\n        return false;\n      }\n    }\n    if (const SCEVAddRecExpr *AR = dyn_cast<SCEVAddRecExpr>(S)) {\n      const SCEV *Step = AR->getStepRecurrence(SE);\n      if (!AR->isAffine() && !SE.dominates(Step, AR->getLoop()->getHeader())) {\n        IsUnsafe = true;\n        return false;\n      }\n    }\n    return true;\n  }\n  bool isDone() const { return IsUnsafe; }\n};\n}\n\nnamespace llvm {\nbool isSafeToExpand(const SCEV *S, ScalarEvolution &SE) {\n  SCEVFindUnsafe Search(SE);\n  visitAll(S, Search);\n  return !Search.IsUnsafe;\n}\n\nbool isSafeToExpandAt(const SCEV *S, const Instruction *InsertionPoint,\n                      ScalarEvolution &SE) {\n  if (!isSafeToExpand(S, SE))\n    return false;\n  // We have to prove that the expanded site of S dominates InsertionPoint.\n  // This is easy when not in the same block, but hard when S is an instruction\n  // to be expanded somewhere inside the same block as our insertion point.\n  // What we really need here is something analogous to an OrderedBasicBlock,\n  // but for the moment, we paper over the problem by handling two common and\n  // cheap to check cases.\n  if (SE.properlyDominates(S, InsertionPoint->getParent()))\n    return true;\n  if (SE.dominates(S, InsertionPoint->getParent())) {\n    if (InsertionPoint->getParent()->getTerminator() == InsertionPoint)\n      return true;\n    if (const SCEVUnknown *U = dyn_cast<SCEVUnknown>(S))\n      for (const Value *V : InsertionPoint->operand_values())\n        if (V == U->getValue())\n          return true;\n  }\n  return false;\n}\n\nSCEVExpanderCleaner::~SCEVExpanderCleaner() {\n  // Result is used, nothing to remove.\n  if (ResultUsed)\n    return;\n\n  auto InsertedInstructions = Expander.getAllInsertedInstructions();\n#ifndef NDEBUG\n  SmallPtrSet<Instruction *, 8> InsertedSet(InsertedInstructions.begin(),\n                                            InsertedInstructions.end());\n  (void)InsertedSet;\n#endif\n  // Remove sets with value handles.\n  Expander.clear();\n\n  // Sort so that earlier instructions do not dominate later instructions.\n  stable_sort(InsertedInstructions, [this](Instruction *A, Instruction *B) {\n    return DT.dominates(B, A);\n  });\n  // Remove all inserted instructions.\n  for (Instruction *I : InsertedInstructions) {\n\n#ifndef NDEBUG\n    assert(all_of(I->users(),\n                  [&InsertedSet](Value *U) {\n                    return InsertedSet.contains(cast<Instruction>(U));\n                  }) &&\n           \"removed instruction should only be used by instructions inserted \"\n           \"during expansion\");\n#endif\n    assert(!I->getType()->isVoidTy() &&\n           \"inserted instruction should have non-void types\");\n    I->replaceAllUsesWith(UndefValue::get(I->getType()));\n    I->eraseFromParent();\n  }\n}\n}\n"}, "3": {"id": 3, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h", "content": "//===---- llvm/Analysis/ScalarEvolutionExpander.h - SCEV Exprs --*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the classes used to generate code from scalar expressions.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ANALYSIS_SCALAREVOLUTIONEXPANDER_H\n#define LLVM_ANALYSIS_SCALAREVOLUTIONEXPANDER_H\n\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/DenseSet.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/Analysis/ScalarEvolutionExpressions.h\"\n#include \"llvm/Analysis/ScalarEvolutionNormalization.h\"\n#include \"llvm/Analysis/TargetFolder.h\"\n#include \"llvm/Analysis/TargetTransformInfo.h\"\n#include \"llvm/IR/IRBuilder.h\"\n#include \"llvm/IR/ValueHandle.h\"\n#include \"llvm/Support/CommandLine.h\"\n\nnamespace llvm {\nextern cl::opt<unsigned> SCEVCheapExpansionBudget;\n\n/// Return true if the given expression is safe to expand in the sense that\n/// all materialized values are safe to speculate anywhere their operands are\n/// defined.\nbool isSafeToExpand(const SCEV *S, ScalarEvolution &SE);\n\n/// Return true if the given expression is safe to expand in the sense that\n/// all materialized values are defined and safe to speculate at the specified\n/// location and their operands are defined at this location.\nbool isSafeToExpandAt(const SCEV *S, const Instruction *InsertionPoint,\n                      ScalarEvolution &SE);\n\n/// struct for holding enough information to help calculate the cost of the\n/// given SCEV when expanded into IR.\nstruct SCEVOperand {\n  explicit SCEVOperand(unsigned Opc, int Idx, const SCEV *S) :\n    ParentOpcode(Opc), OperandIdx(Idx), S(S) { }\n  /// LLVM instruction opcode that uses the operand.\n  unsigned ParentOpcode;\n  /// The use index of an expanded instruction.\n  int OperandIdx;\n  /// The SCEV operand to be costed.\n  const SCEV* S;\n};\n\n/// This class uses information about analyze scalars to rewrite expressions\n/// in canonical form.\n///\n/// Clients should create an instance of this class when rewriting is needed,\n/// and destroy it when finished to allow the release of the associated\n/// memory.\nclass SCEVExpander : public SCEVVisitor<SCEVExpander, Value *> {\n  ScalarEvolution &SE;\n  const DataLayout &DL;\n\n  // New instructions receive a name to identify them with the current pass.\n  const char *IVName;\n\n  /// Indicates whether LCSSA phis should be created for inserted values.\n  bool PreserveLCSSA;\n\n  // InsertedExpressions caches Values for reuse, so must track RAUW.\n  DenseMap<std::pair<const SCEV *, Instruction *>, TrackingVH<Value>>\n      InsertedExpressions;\n\n  // InsertedValues only flags inserted instructions so needs no RAUW.\n  DenseSet<AssertingVH<Value>> InsertedValues;\n  DenseSet<AssertingVH<Value>> InsertedPostIncValues;\n\n  /// Keep track of the existing IR values re-used during expansion.\n  /// FIXME: Ideally re-used instructions would not be added to\n  /// InsertedValues/InsertedPostIncValues.\n  SmallPtrSet<Value *, 16> ReusedValues;\n\n  /// A memoization of the \"relevant\" loop for a given SCEV.\n  DenseMap<const SCEV *, const Loop *> RelevantLoops;\n\n  /// Addrecs referring to any of the given loops are expanded in post-inc\n  /// mode. For example, expanding {1,+,1}<L> in post-inc mode returns the add\n  /// instruction that adds one to the phi for {0,+,1}<L>, as opposed to a new\n  /// phi starting at 1. This is only supported in non-canonical mode.\n  PostIncLoopSet PostIncLoops;\n\n  /// When this is non-null, addrecs expanded in the loop it indicates should\n  /// be inserted with increments at IVIncInsertPos.\n  const Loop *IVIncInsertLoop;\n\n  /// When expanding addrecs in the IVIncInsertLoop loop, insert the IV\n  /// increment at this position.\n  Instruction *IVIncInsertPos;\n\n  /// Phis that complete an IV chain. Reuse\n  DenseSet<AssertingVH<PHINode>> ChainedPhis;\n\n  /// When true, SCEVExpander tries to expand expressions in \"canonical\" form.\n  /// When false, expressions are expanded in a more literal form.\n  ///\n  /// In \"canonical\" form addrecs are expanded as arithmetic based on a\n  /// canonical induction variable. Note that CanonicalMode doesn't guarantee\n  /// that all expressions are expanded in \"canonical\" form. For some\n  /// expressions literal mode can be preferred.\n  bool CanonicalMode;\n\n  /// When invoked from LSR, the expander is in \"strength reduction\" mode. The\n  /// only difference is that phi's are only reused if they are already in\n  /// \"expanded\" form.\n  bool LSRMode;\n\n  typedef IRBuilder<TargetFolder, IRBuilderCallbackInserter> BuilderType;\n  BuilderType Builder;\n\n  // RAII object that stores the current insertion point and restores it when\n  // the object is destroyed. This includes the debug location.  Duplicated\n  // from InsertPointGuard to add SetInsertPoint() which is used to updated\n  // InsertPointGuards stack when insert points are moved during SCEV\n  // expansion.\n  class SCEVInsertPointGuard {\n    IRBuilderBase &Builder;\n    AssertingVH<BasicBlock> Block;\n    BasicBlock::iterator Point;\n    DebugLoc DbgLoc;\n    SCEVExpander *SE;\n\n    SCEVInsertPointGuard(const SCEVInsertPointGuard &) = delete;\n    SCEVInsertPointGuard &operator=(const SCEVInsertPointGuard &) = delete;\n\n  public:\n    SCEVInsertPointGuard(IRBuilderBase &B, SCEVExpander *SE)\n        : Builder(B), Block(B.GetInsertBlock()), Point(B.GetInsertPoint()),\n          DbgLoc(B.getCurrentDebugLocation()), SE(SE) {\n      SE->InsertPointGuards.push_back(this);\n    }\n\n    ~SCEVInsertPointGuard() {\n      // These guards should always created/destroyed in FIFO order since they\n      // are used to guard lexically scoped blocks of code in\n      // ScalarEvolutionExpander.\n      assert(SE->InsertPointGuards.back() == this);\n      SE->InsertPointGuards.pop_back();\n      Builder.restoreIP(IRBuilderBase::InsertPoint(Block, Point));\n      Builder.SetCurrentDebugLocation(DbgLoc);\n    }\n\n    BasicBlock::iterator GetInsertPoint() const { return Point; }\n    void SetInsertPoint(BasicBlock::iterator I) { Point = I; }\n  };\n\n  /// Stack of pointers to saved insert points, used to keep insert points\n  /// consistent when instructions are moved.\n  SmallVector<SCEVInsertPointGuard *, 8> InsertPointGuards;\n\n#ifndef NDEBUG\n  const char *DebugType;\n#endif\n\n  friend struct SCEVVisitor<SCEVExpander, Value *>;\n\npublic:\n  /// Construct a SCEVExpander in \"canonical\" mode.\n  explicit SCEVExpander(ScalarEvolution &se, const DataLayout &DL,\n                        const char *name, bool PreserveLCSSA = true)\n      : SE(se), DL(DL), IVName(name), PreserveLCSSA(PreserveLCSSA),\n        IVIncInsertLoop(nullptr), IVIncInsertPos(nullptr), CanonicalMode(true),\n        LSRMode(false),\n        Builder(se.getContext(), TargetFolder(DL),\n                IRBuilderCallbackInserter(\n                    [this](Instruction *I) { rememberInstruction(I); })) {\n#ifndef NDEBUG\n    DebugType = \"\";\n#endif\n  }\n\n  ~SCEVExpander() {\n    // Make sure the insert point guard stack is consistent.\n    assert(InsertPointGuards.empty());\n  }\n\n#ifndef NDEBUG\n  void setDebugType(const char *s) { DebugType = s; }\n#endif\n\n  /// Erase the contents of the InsertedExpressions map so that users trying\n  /// to expand the same expression into multiple BasicBlocks or different\n  /// places within the same BasicBlock can do so.\n  void clear() {\n    InsertedExpressions.clear();\n    InsertedValues.clear();\n    InsertedPostIncValues.clear();\n    ReusedValues.clear();\n    ChainedPhis.clear();\n  }\n\n  ScalarEvolution *getSE() { return &SE; }\n\n  /// Return a vector containing all instructions inserted during expansion.\n  SmallVector<Instruction *, 32> getAllInsertedInstructions() const {\n    SmallVector<Instruction *, 32> Result;\n    for (auto &VH : InsertedValues) {\n      Value *V = VH;\n      if (ReusedValues.contains(V))\n        continue;\n      if (auto *Inst = dyn_cast<Instruction>(V))\n        Result.push_back(Inst);\n    }\n    for (auto &VH : InsertedPostIncValues) {\n      Value *V = VH;\n      if (ReusedValues.contains(V))\n        continue;\n      if (auto *Inst = dyn_cast<Instruction>(V))\n        Result.push_back(Inst);\n    }\n\n    return Result;\n  }\n\n  /// Return true for expressions that can't be evaluated at runtime\n  /// within given \\b Budget.\n  ///\n  /// At is a parameter which specifies point in code where user is going to\n  /// expand this expression. Sometimes this knowledge can lead to\n  /// a less pessimistic cost estimation.\n  bool isHighCostExpansion(const SCEV *Expr, Loop *L, unsigned Budget,\n                           const TargetTransformInfo *TTI,\n                           const Instruction *At) {\n    assert(TTI && \"This function requires TTI to be provided.\");\n    assert(At && \"This function requires At instruction to be provided.\");\n    if (!TTI)      // In assert-less builds, avoid crashing\n      return true; // by always claiming to be high-cost.\n    SmallVector<SCEVOperand, 8> Worklist;\n    SmallPtrSet<const SCEV *, 8> Processed;\n    int BudgetRemaining = Budget * TargetTransformInfo::TCC_Basic;\n    Worklist.emplace_back(-1, -1, Expr);\n    while (!Worklist.empty()) {\n      const SCEVOperand WorkItem = Worklist.pop_back_val();\n      if (isHighCostExpansionHelper(WorkItem, L, *At, BudgetRemaining,\n                                    *TTI, Processed, Worklist))\n        return true;\n    }\n    assert(BudgetRemaining >= 0 && \"Should have returned from inner loop.\");\n    return false;\n  }\n\n  /// Return the induction variable increment's IV operand.\n  Instruction *getIVIncOperand(Instruction *IncV, Instruction *InsertPos,\n                               bool allowScale);\n\n  /// Utility for hoisting an IV increment.\n  bool hoistIVInc(Instruction *IncV, Instruction *InsertPos);\n\n  /// replace congruent phis with their most canonical representative. Return\n  /// the number of phis eliminated.\n  unsigned replaceCongruentIVs(Loop *L, const DominatorTree *DT,\n                               SmallVectorImpl<WeakTrackingVH> &DeadInsts,\n                               const TargetTransformInfo *TTI = nullptr);\n\n  /// Insert code to directly compute the specified SCEV expression into the\n  /// program.  The code is inserted into the specified block.\n  Value *expandCodeFor(const SCEV *SH, Type *Ty, Instruction *I) {\n    return expandCodeForImpl(SH, Ty, I, true);\n  }\n\n  /// Insert code to directly compute the specified SCEV expression into the\n  /// program.  The code is inserted into the SCEVExpander's current\n  /// insertion point. If a type is specified, the result will be expanded to\n  /// have that type, with a cast if necessary.\n  Value *expandCodeFor(const SCEV *SH, Type *Ty = nullptr) {\n    return expandCodeForImpl(SH, Ty, true);\n  }\n\n  /// Generates a code sequence that evaluates this predicate.  The inserted\n  /// instructions will be at position \\p Loc.  The result will be of type i1\n  /// and will have a value of 0 when the predicate is false and 1 otherwise.\n  Value *expandCodeForPredicate(const SCEVPredicate *Pred, Instruction *Loc);\n\n  /// A specialized variant of expandCodeForPredicate, handling the case when\n  /// we are expanding code for a SCEVEqualPredicate.\n  Value *expandEqualPredicate(const SCEVEqualPredicate *Pred, Instruction *Loc);\n\n  /// Generates code that evaluates if the \\p AR expression will overflow.\n  Value *generateOverflowCheck(const SCEVAddRecExpr *AR, Instruction *Loc,\n                               bool Signed);\n\n  /// A specialized variant of expandCodeForPredicate, handling the case when\n  /// we are expanding code for a SCEVWrapPredicate.\n  Value *expandWrapPredicate(const SCEVWrapPredicate *P, Instruction *Loc);\n\n  /// A specialized variant of expandCodeForPredicate, handling the case when\n  /// we are expanding code for a SCEVUnionPredicate.\n  Value *expandUnionPredicate(const SCEVUnionPredicate *Pred, Instruction *Loc);\n\n  /// Set the current IV increment loop and position.\n  void setIVIncInsertPos(const Loop *L, Instruction *Pos) {\n    assert(!CanonicalMode &&\n           \"IV increment positions are not supported in CanonicalMode\");\n    IVIncInsertLoop = L;\n    IVIncInsertPos = Pos;\n  }\n\n  /// Enable post-inc expansion for addrecs referring to the given\n  /// loops. Post-inc expansion is only supported in non-canonical mode.\n  void setPostInc(const PostIncLoopSet &L) {\n    assert(!CanonicalMode &&\n           \"Post-inc expansion is not supported in CanonicalMode\");\n    PostIncLoops = L;\n  }\n\n  /// Disable all post-inc expansion.\n  void clearPostInc() {\n    PostIncLoops.clear();\n\n    // When we change the post-inc loop set, cached expansions may no\n    // longer be valid.\n    InsertedPostIncValues.clear();\n  }\n\n  /// Disable the behavior of expanding expressions in canonical form rather\n  /// than in a more literal form. Non-canonical mode is useful for late\n  /// optimization passes.\n  void disableCanonicalMode() { CanonicalMode = false; }\n\n  void enableLSRMode() { LSRMode = true; }\n\n  /// Set the current insertion point. This is useful if multiple calls to\n  /// expandCodeFor() are going to be made with the same insert point and the\n  /// insert point may be moved during one of the expansions (e.g. if the\n  /// insert point is not a block terminator).\n  void setInsertPoint(Instruction *IP) {\n    assert(IP);\n    Builder.SetInsertPoint(IP);\n  }\n\n  /// Clear the current insertion point. This is useful if the instruction\n  /// that had been serving as the insertion point may have been deleted.\n  void clearInsertPoint() { Builder.ClearInsertionPoint(); }\n\n  /// Set location information used by debugging information.\n  void SetCurrentDebugLocation(DebugLoc L) {\n    Builder.SetCurrentDebugLocation(std::move(L));\n  }\n\n  /// Get location information used by debugging information.\n  DebugLoc getCurrentDebugLocation() const {\n    return Builder.getCurrentDebugLocation();\n  }\n\n  /// Return true if the specified instruction was inserted by the code\n  /// rewriter.  If so, the client should not modify the instruction. Note that\n  /// this also includes instructions re-used during expansion.\n  bool isInsertedInstruction(Instruction *I) const {\n    return InsertedValues.count(I) || InsertedPostIncValues.count(I);\n  }\n\n  void setChainedPhi(PHINode *PN) { ChainedPhis.insert(PN); }\n\n  /// Try to find the ValueOffsetPair for S. The function is mainly used to\n  /// check whether S can be expanded cheaply.  If this returns a non-None\n  /// value, we know we can codegen the `ValueOffsetPair` into a suitable\n  /// expansion identical with S so that S can be expanded cheaply.\n  ///\n  /// L is a hint which tells in which loop to look for the suitable value.\n  /// On success return value which is equivalent to the expanded S at point\n  /// At. Return nullptr if value was not found.\n  ///\n  /// Note that this function does not perform an exhaustive search. I.e if it\n  /// didn't find any value it does not mean that there is no such value.\n  ///\n  Optional<ScalarEvolution::ValueOffsetPair>\n  getRelatedExistingExpansion(const SCEV *S, const Instruction *At, Loop *L);\n\n  /// Returns a suitable insert point after \\p I, that dominates \\p\n  /// MustDominate. Skips instructions inserted by the expander.\n  BasicBlock::iterator findInsertPointAfter(Instruction *I,\n                                            Instruction *MustDominate);\n\nprivate:\n  LLVMContext &getContext() const { return SE.getContext(); }\n\n  /// Insert code to directly compute the specified SCEV expression into the\n  /// program. The code is inserted into the SCEVExpander's current\n  /// insertion point. If a type is specified, the result will be expanded to\n  /// have that type, with a cast if necessary. If \\p Root is true, this\n  /// indicates that \\p SH is the top-level expression to expand passed from\n  /// an external client call.\n  Value *expandCodeForImpl(const SCEV *SH, Type *Ty, bool Root);\n\n  /// Insert code to directly compute the specified SCEV expression into the\n  /// program. The code is inserted into the specified block. If \\p\n  /// Root is true, this indicates that \\p SH is the top-level expression to\n  /// expand passed from an external client call.\n  Value *expandCodeForImpl(const SCEV *SH, Type *Ty, Instruction *I, bool Root);\n\n  /// Recursive helper function for isHighCostExpansion.\n  bool isHighCostExpansionHelper(\n    const SCEVOperand &WorkItem, Loop *L, const Instruction &At,\n    int &BudgetRemaining, const TargetTransformInfo &TTI,\n    SmallPtrSetImpl<const SCEV *> &Processed,\n    SmallVectorImpl<SCEVOperand> &Worklist);\n\n  /// Insert the specified binary operator, doing a small amount of work to\n  /// avoid inserting an obviously redundant operation, and hoisting to an\n  /// outer loop when the opportunity is there and it is safe.\n  Value *InsertBinop(Instruction::BinaryOps Opcode, Value *LHS, Value *RHS,\n                     SCEV::NoWrapFlags Flags, bool IsSafeToHoist);\n\n  /// Arrange for there to be a cast of V to Ty at IP, reusing an existing\n  /// cast if a suitable one exists, moving an existing cast if a suitable one\n  /// exists but isn't in the right place, or creating a new one.\n  Value *ReuseOrCreateCast(Value *V, Type *Ty, Instruction::CastOps Op,\n                           BasicBlock::iterator IP);\n\n  /// Insert a cast of V to the specified type, which must be possible with a\n  /// noop cast, doing what we can to share the casts.\n  Value *InsertNoopCastOfTo(Value *V, Type *Ty);\n\n  /// Expand a SCEVAddExpr with a pointer type into a GEP instead of using\n  /// ptrtoint+arithmetic+inttoptr.\n  Value *expandAddToGEP(const SCEV *const *op_begin, const SCEV *const *op_end,\n                        PointerType *PTy, Type *Ty, Value *V);\n  Value *expandAddToGEP(const SCEV *Op, PointerType *PTy, Type *Ty, Value *V);\n\n  /// Find a previous Value in ExprValueMap for expand.\n  ScalarEvolution::ValueOffsetPair\n  FindValueInExprValueMap(const SCEV *S, const Instruction *InsertPt);\n\n  Value *expand(const SCEV *S);\n\n  /// Determine the most \"relevant\" loop for the given SCEV.\n  const Loop *getRelevantLoop(const SCEV *);\n\n  Value *visitConstant(const SCEVConstant *S) { return S->getValue(); }\n\n  Value *visitPtrToIntExpr(const SCEVPtrToIntExpr *S);\n\n  Value *visitTruncateExpr(const SCEVTruncateExpr *S);\n\n  Value *visitZeroExtendExpr(const SCEVZeroExtendExpr *S);\n\n  Value *visitSignExtendExpr(const SCEVSignExtendExpr *S);\n\n  Value *visitAddExpr(const SCEVAddExpr *S);\n\n  Value *visitMulExpr(const SCEVMulExpr *S);\n\n  Value *visitUDivExpr(const SCEVUDivExpr *S);\n\n  Value *visitAddRecExpr(const SCEVAddRecExpr *S);\n\n  Value *visitSMaxExpr(const SCEVSMaxExpr *S);\n\n  Value *visitUMaxExpr(const SCEVUMaxExpr *S);\n\n  Value *visitSMinExpr(const SCEVSMinExpr *S);\n\n  Value *visitUMinExpr(const SCEVUMinExpr *S);\n\n  Value *visitUnknown(const SCEVUnknown *S) { return S->getValue(); }\n\n  void rememberInstruction(Value *I);\n\n  bool isNormalAddRecExprPHI(PHINode *PN, Instruction *IncV, const Loop *L);\n\n  bool isExpandedAddRecExprPHI(PHINode *PN, Instruction *IncV, const Loop *L);\n\n  Value *expandAddRecExprLiterally(const SCEVAddRecExpr *);\n  PHINode *getAddRecExprPHILiterally(const SCEVAddRecExpr *Normalized,\n                                     const Loop *L, Type *ExpandTy, Type *IntTy,\n                                     Type *&TruncTy, bool &InvertStep);\n  Value *expandIVInc(PHINode *PN, Value *StepV, const Loop *L, Type *ExpandTy,\n                     Type *IntTy, bool useSubtract);\n\n  void hoistBeforePos(DominatorTree *DT, Instruction *InstToHoist,\n                      Instruction *Pos, PHINode *LoopPhi);\n\n  void fixupInsertPoints(Instruction *I);\n\n  /// If required, create LCSSA PHIs for \\p Users' operand \\p OpIdx. If new\n  /// LCSSA PHIs have been created, return the LCSSA PHI available at \\p User.\n  /// If no PHIs have been created, return the unchanged operand \\p OpIdx.\n  Value *fixupLCSSAFormFor(Instruction *User, unsigned OpIdx);\n};\n\n/// Helper to remove instructions inserted during SCEV expansion, unless they\n/// are marked as used.\nclass SCEVExpanderCleaner {\n  SCEVExpander &Expander;\n\n  DominatorTree &DT;\n\n  /// Indicates whether the result of the expansion is used. If false, the\n  /// instructions added during expansion are removed.\n  bool ResultUsed;\n\npublic:\n  SCEVExpanderCleaner(SCEVExpander &Expander, DominatorTree &DT)\n      : Expander(Expander), DT(DT), ResultUsed(false) {}\n\n  ~SCEVExpanderCleaner();\n\n  /// Indicate that the result of the expansion is used.\n  void markResultUsed() { ResultUsed = true; }\n};\n} // namespace llvm\n\n#endif\n"}}, "reports": [{"events": [{"location": {"col": 22, "file": 4, "line": 2414}, "message": "the definition seen here"}, {"location": {"col": 10, "file": 3, "line": 282}, "message": "differing parameters are named here: ('Loc'), in definition: ('IP')"}, {"location": {"col": 10, "file": 3, "line": 282}, "message": "function 'llvm::SCEVExpander::expandCodeForPredicate' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h", "reportHash": "ae5759c1d4bcd242bcf95634c60f8643", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 4, "line": 2430}, "message": "the definition seen here"}, {"location": {"col": 10, "file": 3, "line": 286}, "message": "differing parameters are named here: ('Loc'), in definition: ('IP')"}, {"location": {"col": 10, "file": 3, "line": 286}, "message": "function 'llvm::SCEVExpander::expandEqualPredicate' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h", "reportHash": "15dfa4fc49f7212cf3e4e3189a5f51c7", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 4, "line": 2539}, "message": "the definition seen here"}, {"location": {"col": 10, "file": 3, "line": 294}, "message": "differing parameters are named here: ('Loc'), in definition: ('IP')"}, {"location": {"col": 10, "file": 3, "line": 294}, "message": "function 'llvm::SCEVExpander::expandWrapPredicate' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h", "reportHash": "6b0bcb987ff34507f35624c72a24d1cb", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 4, "line": 2564}, "message": "the definition seen here"}, {"location": {"col": 10, "file": 3, "line": 298}, "message": "differing parameters are named here: ('Pred', 'Loc'), in definition: ('Union', 'IP')"}, {"location": {"col": 10, "file": 3, "line": 298}, "message": "function 'llvm::SCEVExpander::expandUnionPredicate' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h", "reportHash": "36191815a5e3c7bafa07e5c9e30bcd1e", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
