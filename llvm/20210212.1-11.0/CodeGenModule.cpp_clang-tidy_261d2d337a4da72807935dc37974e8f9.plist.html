<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"2": {"id": 2, "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp", "content": "//===--- CodeGenModule.cpp - Emit LLVM Code from ASTs for a Module --------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This coordinates the per-module state used while generating code.\n//\n//===----------------------------------------------------------------------===//\n\n#include \"CodeGenModule.h\"\n#include \"CGBlocks.h\"\n#include \"CGCUDARuntime.h\"\n#include \"CGCXXABI.h\"\n#include \"CGCall.h\"\n#include \"CGDebugInfo.h\"\n#include \"CGObjCRuntime.h\"\n#include \"CGOpenCLRuntime.h\"\n#include \"CGOpenMPRuntime.h\"\n#include \"CGOpenMPRuntimeAMDGCN.h\"\n#include \"CGOpenMPRuntimeNVPTX.h\"\n#include \"CodeGenFunction.h\"\n#include \"CodeGenPGO.h\"\n#include \"ConstantEmitter.h\"\n#include \"CoverageMappingGen.h\"\n#include \"TargetInfo.h\"\n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/CharUnits.h\"\n#include \"clang/AST/DeclCXX.h\"\n#include \"clang/AST/DeclObjC.h\"\n#include \"clang/AST/DeclTemplate.h\"\n#include \"clang/AST/Mangle.h\"\n#include \"clang/AST/RecordLayout.h\"\n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/StmtVisitor.h\"\n#include \"clang/Basic/Builtins.h\"\n#include \"clang/Basic/CharInfo.h\"\n#include \"clang/Basic/CodeGenOptions.h\"\n#include \"clang/Basic/Diagnostic.h\"\n#include \"clang/Basic/FileManager.h\"\n#include \"clang/Basic/Module.h\"\n#include \"clang/Basic/SourceManager.h\"\n#include \"clang/Basic/TargetInfo.h\"\n#include \"clang/Basic/Version.h\"\n#include \"clang/CodeGen/ConstantInitBuilder.h\"\n#include \"clang/Frontend/FrontendDiagnostic.h\"\n#include \"llvm/ADT/StringSwitch.h\"\n#include \"llvm/ADT/Triple.h\"\n#include \"llvm/Analysis/TargetLibraryInfo.h\"\n#include \"llvm/Frontend/OpenMP/OMPIRBuilder.h\"\n#include \"llvm/IR/CallingConv.h\"\n#include \"llvm/IR/DataLayout.h\"\n#include \"llvm/IR/Intrinsics.h\"\n#include \"llvm/IR/LLVMContext.h\"\n#include \"llvm/IR/Module.h\"\n#include \"llvm/IR/ProfileSummary.h\"\n#include \"llvm/ProfileData/InstrProfReader.h\"\n#include \"llvm/Support/CodeGen.h\"\n#include \"llvm/Support/CommandLine.h\"\n#include \"llvm/Support/ConvertUTF.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/MD5.h\"\n#include \"llvm/Support/TimeProfiler.h\"\n\nusing namespace clang;\nusing namespace CodeGen;\n\nstatic llvm::cl::opt<bool> LimitedCoverage(\n    \"limited-coverage-experimental\", llvm::cl::ZeroOrMore, llvm::cl::Hidden,\n    llvm::cl::desc(\"Emit limited coverage mapping information (experimental)\"),\n    llvm::cl::init(false));\n\nstatic const char AnnotationSection[] = \"llvm.metadata\";\n\nstatic CGCXXABI *createCXXABI(CodeGenModule &CGM) {\n  switch (CGM.getTarget().getCXXABI().getKind()) {\n  case TargetCXXABI::AppleARM64:\n  case TargetCXXABI::Fuchsia:\n  case TargetCXXABI::GenericAArch64:\n  case TargetCXXABI::GenericARM:\n  case TargetCXXABI::iOS:\n  case TargetCXXABI::WatchOS:\n  case TargetCXXABI::GenericMIPS:\n  case TargetCXXABI::GenericItanium:\n  case TargetCXXABI::WebAssembly:\n  case TargetCXXABI::XL:\n    return CreateItaniumCXXABI(CGM);\n  case TargetCXXABI::Microsoft:\n    return CreateMicrosoftCXXABI(CGM);\n  }\n\n  llvm_unreachable(\"invalid C++ ABI kind\");\n}\n\nCodeGenModule::CodeGenModule(ASTContext &C, const HeaderSearchOptions &HSO,\n                             const PreprocessorOptions &PPO,\n                             const CodeGenOptions &CGO, llvm::Module &M,\n                             DiagnosticsEngine &diags,\n                             CoverageSourceInfo *CoverageInfo)\n    : Context(C), LangOpts(C.getLangOpts()), HeaderSearchOpts(HSO),\n      PreprocessorOpts(PPO), CodeGenOpts(CGO), TheModule(M), Diags(diags),\n      Target(C.getTargetInfo()), ABI(createCXXABI(*this)),\n      VMContext(M.getContext()), Types(*this), VTables(*this),\n      SanitizerMD(new SanitizerMetadata(*this)) {\n\n  // Initialize the type cache.\n  llvm::LLVMContext &LLVMContext = M.getContext();\n  VoidTy = llvm::Type::getVoidTy(LLVMContext);\n  Int8Ty = llvm::Type::getInt8Ty(LLVMContext);\n  Int16Ty = llvm::Type::getInt16Ty(LLVMContext);\n  Int32Ty = llvm::Type::getInt32Ty(LLVMContext);\n  Int64Ty = llvm::Type::getInt64Ty(LLVMContext);\n  HalfTy = llvm::Type::getHalfTy(LLVMContext);\n  BFloatTy = llvm::Type::getBFloatTy(LLVMContext);\n  FloatTy = llvm::Type::getFloatTy(LLVMContext);\n  DoubleTy = llvm::Type::getDoubleTy(LLVMContext);\n  PointerWidthInBits = C.getTargetInfo().getPointerWidth(0);\n  PointerAlignInBytes =\n    C.toCharUnitsFromBits(C.getTargetInfo().getPointerAlign(0)).getQuantity();\n  SizeSizeInBytes =\n    C.toCharUnitsFromBits(C.getTargetInfo().getMaxPointerWidth()).getQuantity();\n  IntAlignInBytes =\n    C.toCharUnitsFromBits(C.getTargetInfo().getIntAlign()).getQuantity();\n  CharTy =\n    llvm::IntegerType::get(LLVMContext, C.getTargetInfo().getCharWidth());\n  IntTy = llvm::IntegerType::get(LLVMContext, C.getTargetInfo().getIntWidth());\n  IntPtrTy = llvm::IntegerType::get(LLVMContext,\n    C.getTargetInfo().getMaxPointerWidth());\n  Int8PtrTy = Int8Ty->getPointerTo(0);\n  Int8PtrPtrTy = Int8PtrTy->getPointerTo(0);\n  AllocaInt8PtrTy = Int8Ty->getPointerTo(\n      M.getDataLayout().getAllocaAddrSpace());\n  ASTAllocaAddressSpace = getTargetCodeGenInfo().getASTAllocaAddressSpace();\n\n  RuntimeCC = getTargetCodeGenInfo().getABIInfo().getRuntimeCC();\n\n  if (LangOpts.ObjC)\n    createObjCRuntime();\n  if (LangOpts.OpenCL)\n    createOpenCLRuntime();\n  if (LangOpts.OpenMP)\n    createOpenMPRuntime();\n  if (LangOpts.CUDA)\n    createCUDARuntime();\n\n  // Enable TBAA unless it's suppressed. ThreadSanitizer needs TBAA even at O0.\n  if (LangOpts.Sanitize.has(SanitizerKind::Thread) ||\n      (!CodeGenOpts.RelaxedAliasing && CodeGenOpts.OptimizationLevel > 0))\n    TBAA.reset(new CodeGenTBAA(Context, TheModule, CodeGenOpts, getLangOpts(),\n                               getCXXABI().getMangleContext()));\n\n  // If debug info or coverage generation is enabled, create the CGDebugInfo\n  // object.\n  if (CodeGenOpts.getDebugInfo() != codegenoptions::NoDebugInfo ||\n      CodeGenOpts.EmitGcovArcs || CodeGenOpts.EmitGcovNotes)\n    DebugInfo.reset(new CGDebugInfo(*this));\n\n  Block.GlobalUniqueCount = 0;\n\n  if (C.getLangOpts().ObjC)\n    ObjCData.reset(new ObjCEntrypoints());\n\n  if (CodeGenOpts.hasProfileClangUse()) {\n    auto ReaderOrErr = llvm::IndexedInstrProfReader::create(\n        CodeGenOpts.ProfileInstrumentUsePath, CodeGenOpts.ProfileRemappingFile);\n    if (auto E = ReaderOrErr.takeError()) {\n      unsigned DiagID = Diags.getCustomDiagID(DiagnosticsEngine::Error,\n                                              \"Could not read profile %0: %1\");\n      llvm::handleAllErrors(std::move(E), [&](const llvm::ErrorInfoBase &EI) {\n        getDiags().Report(DiagID) << CodeGenOpts.ProfileInstrumentUsePath\n                                  << EI.message();\n      });\n    } else\n      PGOReader = std::move(ReaderOrErr.get());\n  }\n\n  // If coverage mapping generation is enabled, create the\n  // CoverageMappingModuleGen object.\n  if (CodeGenOpts.CoverageMapping)\n    CoverageMapping.reset(new CoverageMappingModuleGen(*this, *CoverageInfo));\n}\n\nCodeGenModule::~CodeGenModule() {}\n\nvoid CodeGenModule::createObjCRuntime() {\n  // This is just isGNUFamily(), but we want to force implementors of\n  // new ABIs to decide how best to do this.\n  switch (LangOpts.ObjCRuntime.getKind()) {\n  case ObjCRuntime::GNUstep:\n  case ObjCRuntime::GCC:\n  case ObjCRuntime::ObjFW:\n    ObjCRuntime.reset(CreateGNUObjCRuntime(*this));\n    return;\n\n  case ObjCRuntime::FragileMacOSX:\n  case ObjCRuntime::MacOSX:\n  case ObjCRuntime::iOS:\n  case ObjCRuntime::WatchOS:\n    ObjCRuntime.reset(CreateMacObjCRuntime(*this));\n    return;\n  }\n  llvm_unreachable(\"bad runtime kind\");\n}\n\nvoid CodeGenModule::createOpenCLRuntime() {\n  OpenCLRuntime.reset(new CGOpenCLRuntime(*this));\n}\n\nvoid CodeGenModule::createOpenMPRuntime() {\n  // Select a specialized code generation class based on the target, if any.\n  // If it does not exist use the default implementation.\n  switch (getTriple().getArch()) {\n  case llvm::Triple::nvptx:\n  case llvm::Triple::nvptx64:\n    assert(getLangOpts().OpenMPIsDevice &&\n           \"OpenMP NVPTX is only prepared to deal with device code.\");\n    OpenMPRuntime.reset(new CGOpenMPRuntimeNVPTX(*this));\n    break;\n  case llvm::Triple::amdgcn:\n    assert(getLangOpts().OpenMPIsDevice &&\n           \"OpenMP AMDGCN is only prepared to deal with device code.\");\n    OpenMPRuntime.reset(new CGOpenMPRuntimeAMDGCN(*this));\n    break;\n  default:\n    if (LangOpts.OpenMPSimd)\n      OpenMPRuntime.reset(new CGOpenMPSIMDRuntime(*this));\n    else\n      OpenMPRuntime.reset(new CGOpenMPRuntime(*this));\n    break;\n  }\n}\n\nvoid CodeGenModule::createCUDARuntime() {\n  CUDARuntime.reset(CreateNVCUDARuntime(*this));\n}\n\nvoid CodeGenModule::addReplacement(StringRef Name, llvm::Constant *C) {\n  Replacements[Name] = C;\n}\n\nvoid CodeGenModule::applyReplacements() {\n  for (auto &I : Replacements) {\n    StringRef MangledName = I.first();\n    llvm::Constant *Replacement = I.second;\n    llvm::GlobalValue *Entry = GetGlobalValue(MangledName);\n    if (!Entry)\n      continue;\n    auto *OldF = cast<llvm::Function>(Entry);\n    auto *NewF = dyn_cast<llvm::Function>(Replacement);\n    if (!NewF) {\n      if (auto *Alias = dyn_cast<llvm::GlobalAlias>(Replacement)) {\n        NewF = dyn_cast<llvm::Function>(Alias->getAliasee());\n      } else {\n        auto *CE = cast<llvm::ConstantExpr>(Replacement);\n        assert(CE->getOpcode() == llvm::Instruction::BitCast ||\n               CE->getOpcode() == llvm::Instruction::GetElementPtr);\n        NewF = dyn_cast<llvm::Function>(CE->getOperand(0));\n      }\n    }\n\n    // Replace old with new, but keep the old order.\n    OldF->replaceAllUsesWith(Replacement);\n    if (NewF) {\n      NewF->removeFromParent();\n      OldF->getParent()->getFunctionList().insertAfter(OldF->getIterator(),\n                                                       NewF);\n    }\n    OldF->eraseFromParent();\n  }\n}\n\nvoid CodeGenModule::addGlobalValReplacement(llvm::GlobalValue *GV, llvm::Constant *C) {\n  GlobalValReplacements.push_back(std::make_pair(GV, C));\n}\n\nvoid CodeGenModule::applyGlobalValReplacements() {\n  for (auto &I : GlobalValReplacements) {\n    llvm::GlobalValue *GV = I.first;\n    llvm::Constant *C = I.second;\n\n    GV->replaceAllUsesWith(C);\n    GV->eraseFromParent();\n  }\n}\n\n// This is only used in aliases that we created and we know they have a\n// linear structure.\nstatic const llvm::GlobalObject *getAliasedGlobal(\n    const llvm::GlobalIndirectSymbol &GIS) {\n  llvm::SmallPtrSet<const llvm::GlobalIndirectSymbol*, 4> Visited;\n  const llvm::Constant *C = &GIS;\n  for (;;) {\n    C = C->stripPointerCasts();\n    if (auto *GO = dyn_cast<llvm::GlobalObject>(C))\n      return GO;\n    // stripPointerCasts will not walk over weak aliases.\n    auto *GIS2 = dyn_cast<llvm::GlobalIndirectSymbol>(C);\n    if (!GIS2)\n      return nullptr;\n    if (!Visited.insert(GIS2).second)\n      return nullptr;\n    C = GIS2->getIndirectSymbol();\n  }\n}\n\nvoid CodeGenModule::checkAliases() {\n  // Check if the constructed aliases are well formed. It is really unfortunate\n  // that we have to do this in CodeGen, but we only construct mangled names\n  // and aliases during codegen.\n  bool Error = false;\n  DiagnosticsEngine &Diags = getDiags();\n  for (const GlobalDecl &GD : Aliases) {\n    const auto *D = cast<ValueDecl>(GD.getDecl());\n    SourceLocation Location;\n    bool IsIFunc = D->hasAttr<IFuncAttr>();\n    if (const Attr *A = D->getDefiningAttr())\n      Location = A->getLocation();\n    else\n      llvm_unreachable(\"Not an alias or ifunc?\");\n    StringRef MangledName = getMangledName(GD);\n    llvm::GlobalValue *Entry = GetGlobalValue(MangledName);\n    auto *Alias  = cast<llvm::GlobalIndirectSymbol>(Entry);\n    const llvm::GlobalValue *GV = getAliasedGlobal(*Alias);\n    if (!GV) {\n      Error = true;\n      Diags.Report(Location, diag::err_cyclic_alias) << IsIFunc;\n    } else if (GV->isDeclaration()) {\n      Error = true;\n      Diags.Report(Location, diag::err_alias_to_undefined)\n          << IsIFunc << IsIFunc;\n    } else if (IsIFunc) {\n      // Check resolver function type.\n      llvm::FunctionType *FTy = dyn_cast<llvm::FunctionType>(\n          GV->getType()->getPointerElementType());\n      assert(FTy);\n      if (!FTy->getReturnType()->isPointerTy())\n        Diags.Report(Location, diag::err_ifunc_resolver_return);\n    }\n\n    llvm::Constant *Aliasee = Alias->getIndirectSymbol();\n    llvm::GlobalValue *AliaseeGV;\n    if (auto CE = dyn_cast<llvm::ConstantExpr>(Aliasee))\n      AliaseeGV = cast<llvm::GlobalValue>(CE->getOperand(0));\n    else\n      AliaseeGV = cast<llvm::GlobalValue>(Aliasee);\n\n    if (const SectionAttr *SA = D->getAttr<SectionAttr>()) {\n      StringRef AliasSection = SA->getName();\n      if (AliasSection != AliaseeGV->getSection())\n        Diags.Report(SA->getLocation(), diag::warn_alias_with_section)\n            << AliasSection << IsIFunc << IsIFunc;\n    }\n\n    // We have to handle alias to weak aliases in here. LLVM itself disallows\n    // this since the object semantics would not match the IL one. For\n    // compatibility with gcc we implement it by just pointing the alias\n    // to its aliasee's aliasee. We also warn, since the user is probably\n    // expecting the link to be weak.\n    if (auto GA = dyn_cast<llvm::GlobalIndirectSymbol>(AliaseeGV)) {\n      if (GA->isInterposable()) {\n        Diags.Report(Location, diag::warn_alias_to_weak_alias)\n            << GV->getName() << GA->getName() << IsIFunc;\n        Aliasee = llvm::ConstantExpr::getPointerBitCastOrAddrSpaceCast(\n            GA->getIndirectSymbol(), Alias->getType());\n        Alias->setIndirectSymbol(Aliasee);\n      }\n    }\n  }\n  if (!Error)\n    return;\n\n  for (const GlobalDecl &GD : Aliases) {\n    StringRef MangledName = getMangledName(GD);\n    llvm::GlobalValue *Entry = GetGlobalValue(MangledName);\n    auto *Alias = cast<llvm::GlobalIndirectSymbol>(Entry);\n    Alias->replaceAllUsesWith(llvm::UndefValue::get(Alias->getType()));\n    Alias->eraseFromParent();\n  }\n}\n\nvoid CodeGenModule::clear() {\n  DeferredDeclsToEmit.clear();\n  if (OpenMPRuntime)\n    OpenMPRuntime->clear();\n}\n\nvoid InstrProfStats::reportDiagnostics(DiagnosticsEngine &Diags,\n                                       StringRef MainFile) {\n  if (!hasDiagnostics())\n    return;\n  if (VisitedInMainFile > 0 && VisitedInMainFile == MissingInMainFile) {\n    if (MainFile.empty())\n      MainFile = \"<stdin>\";\n    Diags.Report(diag::warn_profile_data_unprofiled) << MainFile;\n  } else {\n    if (Mismatched > 0)\n      Diags.Report(diag::warn_profile_data_out_of_date) << Visited << Mismatched;\n\n    if (Missing > 0)\n      Diags.Report(diag::warn_profile_data_missing) << Visited << Missing;\n  }\n}\n\nstatic void setVisibilityFromDLLStorageClass(const clang::LangOptions &LO,\n                                             llvm::Module &M) {\n  if (!LO.VisibilityFromDLLStorageClass)\n    return;\n\n  llvm::GlobalValue::VisibilityTypes DLLExportVisibility =\n      CodeGenModule::GetLLVMVisibility(LO.getDLLExportVisibility());\n  llvm::GlobalValue::VisibilityTypes NoDLLStorageClassVisibility =\n      CodeGenModule::GetLLVMVisibility(LO.getNoDLLStorageClassVisibility());\n  llvm::GlobalValue::VisibilityTypes ExternDeclDLLImportVisibility =\n      CodeGenModule::GetLLVMVisibility(LO.getExternDeclDLLImportVisibility());\n  llvm::GlobalValue::VisibilityTypes ExternDeclNoDLLStorageClassVisibility =\n      CodeGenModule::GetLLVMVisibility(\n          LO.getExternDeclNoDLLStorageClassVisibility());\n\n  for (llvm::GlobalValue &GV : M.global_values()) {\n    if (GV.hasAppendingLinkage() || GV.hasLocalLinkage())\n      continue;\n\n    // Reset DSO locality before setting the visibility. This removes\n    // any effects that visibility options and annotations may have\n    // had on the DSO locality. Setting the visibility will implicitly set\n    // appropriate globals to DSO Local; however, this will be pessimistic\n    // w.r.t. to the normal compiler IRGen.\n    GV.setDSOLocal(false);\n\n    if (GV.isDeclarationForLinker()) {\n      GV.setVisibility(GV.getDLLStorageClass() ==\n                               llvm::GlobalValue::DLLImportStorageClass\n                           ? ExternDeclDLLImportVisibility\n                           : ExternDeclNoDLLStorageClassVisibility);\n    } else {\n      GV.setVisibility(GV.getDLLStorageClass() ==\n                               llvm::GlobalValue::DLLExportStorageClass\n                           ? DLLExportVisibility\n                           : NoDLLStorageClassVisibility);\n    }\n\n    GV.setDLLStorageClass(llvm::GlobalValue::DefaultStorageClass);\n  }\n}\n\nvoid CodeGenModule::Release() {\n  EmitDeferred();\n  EmitVTablesOpportunistically();\n  applyGlobalValReplacements();\n  applyReplacements();\n  checkAliases();\n  emitMultiVersionFunctions();\n  EmitCXXGlobalInitFunc();\n  EmitCXXGlobalCleanUpFunc();\n  registerGlobalDtorsWithAtExit();\n  EmitCXXThreadLocalInitFunc();\n  if (ObjCRuntime)\n    if (llvm::Function *ObjCInitFunction = ObjCRuntime->ModuleInitFunction())\n      AddGlobalCtor(ObjCInitFunction);\n  if (Context.getLangOpts().CUDA && !Context.getLangOpts().CUDAIsDevice &&\n      CUDARuntime) {\n    if (llvm::Function *CudaCtorFunction =\n            CUDARuntime->makeModuleCtorFunction())\n      AddGlobalCtor(CudaCtorFunction);\n  }\n  if (OpenMPRuntime) {\n    if (llvm::Function *OpenMPRequiresDirectiveRegFun =\n            OpenMPRuntime->emitRequiresDirectiveRegFun()) {\n      AddGlobalCtor(OpenMPRequiresDirectiveRegFun, 0);\n    }\n    OpenMPRuntime->createOffloadEntriesAndInfoMetadata();\n    OpenMPRuntime->clear();\n  }\n  if (PGOReader) {\n    getModule().setProfileSummary(\n        PGOReader->getSummary(/* UseCS */ false).getMD(VMContext),\n        llvm::ProfileSummary::PSK_Instr);\n    if (PGOStats.hasDiagnostics())\n      PGOStats.reportDiagnostics(getDiags(), getCodeGenOpts().MainFileName);\n  }\n  EmitCtorList(GlobalCtors, \"llvm.global_ctors\");\n  EmitCtorList(GlobalDtors, \"llvm.global_dtors\");\n  EmitGlobalAnnotations();\n  EmitStaticExternCAliases();\n  EmitDeferredUnusedCoverageMappings();\n  if (CoverageMapping)\n    CoverageMapping->emit();\n  if (CodeGenOpts.SanitizeCfiCrossDso) {\n    CodeGenFunction(*this).EmitCfiCheckFail();\n    CodeGenFunction(*this).EmitCfiCheckStub();\n  }\n  emitAtAvailableLinkGuard();\n  if (Context.getTargetInfo().getTriple().isWasm() &&\n      !Context.getTargetInfo().getTriple().isOSEmscripten()) {\n    EmitMainVoidAlias();\n  }\n  emitLLVMUsed();\n  if (SanStats)\n    SanStats->finish();\n\n  if (CodeGenOpts.Autolink &&\n      (Context.getLangOpts().Modules || !LinkerOptionsMetadata.empty())) {\n    EmitModuleLinkOptions();\n  }\n\n  // On ELF we pass the dependent library specifiers directly to the linker\n  // without manipulating them. This is in contrast to other platforms where\n  // they are mapped to a specific linker option by the compiler. This\n  // difference is a result of the greater variety of ELF linkers and the fact\n  // that ELF linkers tend to handle libraries in a more complicated fashion\n  // than on other platforms. This forces us to defer handling the dependent\n  // libs to the linker.\n  //\n  // CUDA/HIP device and host libraries are different. Currently there is no\n  // way to differentiate dependent libraries for host or device. Existing\n  // usage of #pragma comment(lib, *) is intended for host libraries on\n  // Windows. Therefore emit llvm.dependent-libraries only for host.\n  if (!ELFDependentLibraries.empty() && !Context.getLangOpts().CUDAIsDevice) {\n    auto *NMD = getModule().getOrInsertNamedMetadata(\"llvm.dependent-libraries\");\n    for (auto *MD : ELFDependentLibraries)\n      NMD->addOperand(MD);\n  }\n\n  // Record mregparm value now so it is visible through rest of codegen.\n  if (Context.getTargetInfo().getTriple().getArch() == llvm::Triple::x86)\n    getModule().addModuleFlag(llvm::Module::Error, \"NumRegisterParameters\",\n                              CodeGenOpts.NumRegisterParameters);\n\n  if (CodeGenOpts.DwarfVersion) {\n    getModule().addModuleFlag(llvm::Module::Max, \"Dwarf Version\",\n                              CodeGenOpts.DwarfVersion);\n  }\n\n  if (Context.getLangOpts().SemanticInterposition)\n    // Require various optimization to respect semantic interposition.\n    getModule().setSemanticInterposition(1);\n\n  if (CodeGenOpts.EmitCodeView) {\n    // Indicate that we want CodeView in the metadata.\n    getModule().addModuleFlag(llvm::Module::Warning, \"CodeView\", 1);\n  }\n  if (CodeGenOpts.CodeViewGHash) {\n    getModule().addModuleFlag(llvm::Module::Warning, \"CodeViewGHash\", 1);\n  }\n  if (CodeGenOpts.ControlFlowGuard) {\n    // Function ID tables and checks for Control Flow Guard (cfguard=2).\n    getModule().addModuleFlag(llvm::Module::Warning, \"cfguard\", 2);\n  } else if (CodeGenOpts.ControlFlowGuardNoChecks) {\n    // Function ID tables for Control Flow Guard (cfguard=1).\n    getModule().addModuleFlag(llvm::Module::Warning, \"cfguard\", 1);\n  }\n  if (CodeGenOpts.OptimizationLevel > 0 && CodeGenOpts.StrictVTablePointers) {\n    // We don't support LTO with 2 with different StrictVTablePointers\n    // FIXME: we could support it by stripping all the information introduced\n    // by StrictVTablePointers.\n\n    getModule().addModuleFlag(llvm::Module::Error, \"StrictVTablePointers\",1);\n\n    llvm::Metadata *Ops[2] = {\n              llvm::MDString::get(VMContext, \"StrictVTablePointers\"),\n              llvm::ConstantAsMetadata::get(llvm::ConstantInt::get(\n                  llvm::Type::getInt32Ty(VMContext), 1))};\n\n    getModule().addModuleFlag(llvm::Module::Require,\n                              \"StrictVTablePointersRequirement\",\n                              llvm::MDNode::get(VMContext, Ops));\n  }\n  if (getModuleDebugInfo())\n    // We support a single version in the linked module. The LLVM\n    // parser will drop debug info with a different version number\n    // (and warn about it, too).\n    getModule().addModuleFlag(llvm::Module::Warning, \"Debug Info Version\",\n                              llvm::DEBUG_METADATA_VERSION);\n\n  // We need to record the widths of enums and wchar_t, so that we can generate\n  // the correct build attributes in the ARM backend. wchar_size is also used by\n  // TargetLibraryInfo.\n  uint64_t WCharWidth =\n      Context.getTypeSizeInChars(Context.getWideCharType()).getQuantity();\n  getModule().addModuleFlag(llvm::Module::Error, \"wchar_size\", WCharWidth);\n\n  llvm::Triple::ArchType Arch = Context.getTargetInfo().getTriple().getArch();\n  if (   Arch == llvm::Triple::arm\n      || Arch == llvm::Triple::armeb\n      || Arch == llvm::Triple::thumb\n      || Arch == llvm::Triple::thumbeb) {\n    // The minimum width of an enum in bytes\n    uint64_t EnumWidth = Context.getLangOpts().ShortEnums ? 1 : 4;\n    getModule().addModuleFlag(llvm::Module::Error, \"min_enum_size\", EnumWidth);\n  }\n\n  if (Arch == llvm::Triple::riscv32 || Arch == llvm::Triple::riscv64) {\n    StringRef ABIStr = Target.getABI();\n    llvm::LLVMContext &Ctx = TheModule.getContext();\n    getModule().addModuleFlag(llvm::Module::Error, \"target-abi\",\n                              llvm::MDString::get(Ctx, ABIStr));\n  }\n\n  if (CodeGenOpts.SanitizeCfiCrossDso) {\n    // Indicate that we want cross-DSO control flow integrity checks.\n    getModule().addModuleFlag(llvm::Module::Override, \"Cross-DSO CFI\", 1);\n  }\n\n  if (CodeGenOpts.WholeProgramVTables) {\n    // Indicate whether VFE was enabled for this module, so that the\n    // vcall_visibility metadata added under whole program vtables is handled\n    // appropriately in the optimizer.\n    getModule().addModuleFlag(llvm::Module::Error, \"Virtual Function Elim\",\n                              CodeGenOpts.VirtualFunctionElimination);\n  }\n\n  if (LangOpts.Sanitize.has(SanitizerKind::CFIICall)) {\n    getModule().addModuleFlag(llvm::Module::Override,\n                              \"CFI Canonical Jump Tables\",\n                              CodeGenOpts.SanitizeCfiCanonicalJumpTables);\n  }\n\n  if (CodeGenOpts.CFProtectionReturn &&\n      Target.checkCFProtectionReturnSupported(getDiags())) {\n    // Indicate that we want to instrument return control flow protection.\n    getModule().addModuleFlag(llvm::Module::Override, \"cf-protection-return\",\n                              1);\n  }\n\n  if (CodeGenOpts.CFProtectionBranch &&\n      Target.checkCFProtectionBranchSupported(getDiags())) {\n    // Indicate that we want to instrument branch control flow protection.\n    getModule().addModuleFlag(llvm::Module::Override, \"cf-protection-branch\",\n                              1);\n  }\n\n  if (Arch == llvm::Triple::aarch64 || Arch == llvm::Triple::aarch64_32 ||\n      Arch == llvm::Triple::aarch64_be) {\n    getModule().addModuleFlag(llvm::Module::Error,\n                              \"branch-target-enforcement\",\n                              LangOpts.BranchTargetEnforcement);\n\n    getModule().addModuleFlag(llvm::Module::Error, \"sign-return-address\",\n                              LangOpts.hasSignReturnAddress());\n\n    getModule().addModuleFlag(llvm::Module::Error, \"sign-return-address-all\",\n                              LangOpts.isSignReturnAddressScopeAll());\n\n    getModule().addModuleFlag(llvm::Module::Error,\n                              \"sign-return-address-with-bkey\",\n                              !LangOpts.isSignReturnAddressWithAKey());\n  }\n\n  if (!CodeGenOpts.MemoryProfileOutput.empty()) {\n    llvm::LLVMContext &Ctx = TheModule.getContext();\n    getModule().addModuleFlag(\n        llvm::Module::Error, \"MemProfProfileFilename\",\n        llvm::MDString::get(Ctx, CodeGenOpts.MemoryProfileOutput));\n  }\n\n  if (LangOpts.CUDAIsDevice && getTriple().isNVPTX()) {\n    // Indicate whether __nvvm_reflect should be configured to flush denormal\n    // floating point values to 0.  (This corresponds to its \"__CUDA_FTZ\"\n    // property.)\n    getModule().addModuleFlag(llvm::Module::Override, \"nvvm-reflect-ftz\",\n                              CodeGenOpts.FP32DenormalMode.Output !=\n                                  llvm::DenormalMode::IEEE);\n  }\n\n  // Emit OpenCL specific module metadata: OpenCL/SPIR version.\n  if (LangOpts.OpenCL) {\n    EmitOpenCLMetadata();\n    // Emit SPIR version.\n    if (getTriple().isSPIR()) {\n      // SPIR v2.0 s2.12 - The SPIR version used by the module is stored in the\n      // opencl.spir.version named metadata.\n      // C++ is backwards compatible with OpenCL v2.0.\n      auto Version = LangOpts.OpenCLCPlusPlus ? 200 : LangOpts.OpenCLVersion;\n      llvm::Metadata *SPIRVerElts[] = {\n          llvm::ConstantAsMetadata::get(llvm::ConstantInt::get(\n              Int32Ty, Version / 100)),\n          llvm::ConstantAsMetadata::get(llvm::ConstantInt::get(\n              Int32Ty, (Version / 100 > 1) ? 0 : 2))};\n      llvm::NamedMDNode *SPIRVerMD =\n          TheModule.getOrInsertNamedMetadata(\"opencl.spir.version\");\n      llvm::LLVMContext &Ctx = TheModule.getContext();\n      SPIRVerMD->addOperand(llvm::MDNode::get(Ctx, SPIRVerElts));\n    }\n  }\n\n  if (uint32_t PLevel = Context.getLangOpts().PICLevel) {\n    assert(PLevel < 3 && \"Invalid PIC Level\");\n    getModule().setPICLevel(static_cast<llvm::PICLevel::Level>(PLevel));\n    if (Context.getLangOpts().PIE)\n      getModule().setPIELevel(static_cast<llvm::PIELevel::Level>(PLevel));\n  }\n\n  if (getCodeGenOpts().CodeModel.size() > 0) {\n    unsigned CM = llvm::StringSwitch<unsigned>(getCodeGenOpts().CodeModel)\n                  .Case(\"tiny\", llvm::CodeModel::Tiny)\n                  .Case(\"small\", llvm::CodeModel::Small)\n                  .Case(\"kernel\", llvm::CodeModel::Kernel)\n                  .Case(\"medium\", llvm::CodeModel::Medium)\n                  .Case(\"large\", llvm::CodeModel::Large)\n                  .Default(~0u);\n    if (CM != ~0u) {\n      llvm::CodeModel::Model codeModel = static_cast<llvm::CodeModel::Model>(CM);\n      getModule().setCodeModel(codeModel);\n    }\n  }\n\n  if (CodeGenOpts.NoPLT)\n    getModule().setRtLibUseGOT();\n\n  SimplifyPersonality();\n\n  if (getCodeGenOpts().EmitDeclMetadata)\n    EmitDeclMetadata();\n\n  if (getCodeGenOpts().EmitGcovArcs || getCodeGenOpts().EmitGcovNotes)\n    EmitCoverageFile();\n\n  if (CGDebugInfo *DI = getModuleDebugInfo())\n    DI->finalize();\n\n  if (getCodeGenOpts().EmitVersionIdentMetadata)\n    EmitVersionIdentMetadata();\n\n  if (!getCodeGenOpts().RecordCommandLine.empty())\n    EmitCommandLineMetadata();\n\n  getTargetCodeGenInfo().emitTargetMetadata(*this, MangledDeclNames);\n\n  EmitBackendOptionsMetadata(getCodeGenOpts());\n\n  // Set visibility from DLL storage class\n  // We do this at the end of LLVM IR generation; after any operation\n  // that might affect the DLL storage class or the visibility, and\n  // before anything that might act on these.\n  setVisibilityFromDLLStorageClass(LangOpts, getModule());\n}\n\nvoid CodeGenModule::EmitOpenCLMetadata() {\n  // SPIR v2.0 s2.13 - The OpenCL version used by the module is stored in the\n  // opencl.ocl.version named metadata node.\n  // C++ is backwards compatible with OpenCL v2.0.\n  // FIXME: We might need to add CXX version at some point too?\n  auto Version = LangOpts.OpenCLCPlusPlus ? 200 : LangOpts.OpenCLVersion;\n  llvm::Metadata *OCLVerElts[] = {\n      llvm::ConstantAsMetadata::get(llvm::ConstantInt::get(\n          Int32Ty, Version / 100)),\n      llvm::ConstantAsMetadata::get(llvm::ConstantInt::get(\n          Int32Ty, (Version % 100) / 10))};\n  llvm::NamedMDNode *OCLVerMD =\n      TheModule.getOrInsertNamedMetadata(\"opencl.ocl.version\");\n  llvm::LLVMContext &Ctx = TheModule.getContext();\n  OCLVerMD->addOperand(llvm::MDNode::get(Ctx, OCLVerElts));\n}\n\nvoid CodeGenModule::EmitBackendOptionsMetadata(\n    const CodeGenOptions CodeGenOpts) {\n  switch (getTriple().getArch()) {\n  default:\n    break;\n  case llvm::Triple::riscv32:\n  case llvm::Triple::riscv64:\n    getModule().addModuleFlag(llvm::Module::Error, \"SmallDataLimit\",\n                              CodeGenOpts.SmallDataLimit);\n    break;\n  }\n}\n\nvoid CodeGenModule::UpdateCompletedType(const TagDecl *TD) {\n  // Make sure that this type is translated.\n  Types.UpdateCompletedType(TD);\n}\n\nvoid CodeGenModule::RefreshTypeCacheForClass(const CXXRecordDecl *RD) {\n  // Make sure that this type is translated.\n  Types.RefreshTypeCacheForClass(RD);\n}\n\nllvm::MDNode *CodeGenModule::getTBAATypeInfo(QualType QTy) {\n  if (!TBAA)\n    return nullptr;\n  return TBAA->getTypeInfo(QTy);\n}\n\nTBAAAccessInfo CodeGenModule::getTBAAAccessInfo(QualType AccessType) {\n  if (!TBAA)\n    return TBAAAccessInfo();\n  if (getLangOpts().CUDAIsDevice) {\n    // As CUDA builtin surface/texture types are replaced, skip generating TBAA\n    // access info.\n    if (AccessType->isCUDADeviceBuiltinSurfaceType()) {\n      if (getTargetCodeGenInfo().getCUDADeviceBuiltinSurfaceDeviceType() !=\n          nullptr)\n        return TBAAAccessInfo();\n    } else if (AccessType->isCUDADeviceBuiltinTextureType()) {\n      if (getTargetCodeGenInfo().getCUDADeviceBuiltinTextureDeviceType() !=\n          nullptr)\n        return TBAAAccessInfo();\n    }\n  }\n  return TBAA->getAccessInfo(AccessType);\n}\n\nTBAAAccessInfo\nCodeGenModule::getTBAAVTablePtrAccessInfo(llvm::Type *VTablePtrType) {\n  if (!TBAA)\n    return TBAAAccessInfo();\n  return TBAA->getVTablePtrAccessInfo(VTablePtrType);\n}\n\nllvm::MDNode *CodeGenModule::getTBAAStructInfo(QualType QTy) {\n  if (!TBAA)\n    return nullptr;\n  return TBAA->getTBAAStructInfo(QTy);\n}\n\nllvm::MDNode *CodeGenModule::getTBAABaseTypeInfo(QualType QTy) {\n  if (!TBAA)\n    return nullptr;\n  return TBAA->getBaseTypeInfo(QTy);\n}\n\nllvm::MDNode *CodeGenModule::getTBAAAccessTagInfo(TBAAAccessInfo Info) {\n  if (!TBAA)\n    return nullptr;\n  return TBAA->getAccessTagInfo(Info);\n}\n\nTBAAAccessInfo CodeGenModule::mergeTBAAInfoForCast(TBAAAccessInfo SourceInfo,\n                                                   TBAAAccessInfo TargetInfo) {\n  if (!TBAA)\n    return TBAAAccessInfo();\n  return TBAA->mergeTBAAInfoForCast(SourceInfo, TargetInfo);\n}\n\nTBAAAccessInfo\nCodeGenModule::mergeTBAAInfoForConditionalOperator(TBAAAccessInfo InfoA,\n                                                   TBAAAccessInfo InfoB) {\n  if (!TBAA)\n    return TBAAAccessInfo();\n  return TBAA->mergeTBAAInfoForConditionalOperator(InfoA, InfoB);\n}\n\nTBAAAccessInfo\nCodeGenModule::mergeTBAAInfoForMemoryTransfer(TBAAAccessInfo DestInfo,\n                                              TBAAAccessInfo SrcInfo) {\n  if (!TBAA)\n    return TBAAAccessInfo();\n  return TBAA->mergeTBAAInfoForConditionalOperator(DestInfo, SrcInfo);\n}\n\nvoid CodeGenModule::DecorateInstructionWithTBAA(llvm::Instruction *Inst,\n                                                TBAAAccessInfo TBAAInfo) {\n  if (llvm::MDNode *Tag = getTBAAAccessTagInfo(TBAAInfo))\n    Inst->setMetadata(llvm::LLVMContext::MD_tbaa, Tag);\n}\n\nvoid CodeGenModule::DecorateInstructionWithInvariantGroup(\n    llvm::Instruction *I, const CXXRecordDecl *RD) {\n  I->setMetadata(llvm::LLVMContext::MD_invariant_group,\n                 llvm::MDNode::get(getLLVMContext(), {}));\n}\n\nvoid CodeGenModule::Error(SourceLocation loc, StringRef message) {\n  unsigned diagID = getDiags().getCustomDiagID(DiagnosticsEngine::Error, \"%0\");\n  getDiags().Report(Context.getFullLoc(loc), diagID) << message;\n}\n\n/// ErrorUnsupported - Print out an error that codegen doesn't support the\n/// specified stmt yet.\nvoid CodeGenModule::ErrorUnsupported(const Stmt *S, const char *Type) {\n  unsigned DiagID = getDiags().getCustomDiagID(DiagnosticsEngine::Error,\n                                               \"cannot compile this %0 yet\");\n  std::string Msg = Type;\n  getDiags().Report(Context.getFullLoc(S->getBeginLoc()), DiagID)\n      << Msg << S->getSourceRange();\n}\n\n/// ErrorUnsupported - Print out an error that codegen doesn't support the\n/// specified decl yet.\nvoid CodeGenModule::ErrorUnsupported(const Decl *D, const char *Type) {\n  unsigned DiagID = getDiags().getCustomDiagID(DiagnosticsEngine::Error,\n                                               \"cannot compile this %0 yet\");\n  std::string Msg = Type;\n  getDiags().Report(Context.getFullLoc(D->getLocation()), DiagID) << Msg;\n}\n\nllvm::ConstantInt *CodeGenModule::getSize(CharUnits size) {\n  return llvm::ConstantInt::get(SizeTy, size.getQuantity());\n}\n\nvoid CodeGenModule::setGlobalVisibility(llvm::GlobalValue *GV,\n                                        const NamedDecl *D) const {\n  if (GV->hasDLLImportStorageClass())\n    return;\n  // Internal definitions always have default visibility.\n  if (GV->hasLocalLinkage()) {\n    GV->setVisibility(llvm::GlobalValue::DefaultVisibility);\n    return;\n  }\n  if (!D)\n    return;\n  // Set visibility for definitions, and for declarations if requested globally\n  // or set explicitly.\n  LinkageInfo LV = D->getLinkageAndVisibility();\n  if (LV.isVisibilityExplicit() || getLangOpts().SetVisibilityForExternDecls ||\n      !GV->isDeclarationForLinker())\n    GV->setVisibility(GetLLVMVisibility(LV.getVisibility()));\n}\n\nstatic bool shouldAssumeDSOLocal(const CodeGenModule &CGM,\n                                 llvm::GlobalValue *GV) {\n  if (GV->hasLocalLinkage())\n    return true;\n\n  if (!GV->hasDefaultVisibility() && !GV->hasExternalWeakLinkage())\n    return true;\n\n  // DLLImport explicitly marks the GV as external.\n  if (GV->hasDLLImportStorageClass())\n    return false;\n\n  const llvm::Triple &TT = CGM.getTriple();\n  if (TT.isWindowsGNUEnvironment()) {\n    // In MinGW, variables without DLLImport can still be automatically\n    // imported from a DLL by the linker; don't mark variables that\n    // potentially could come from another DLL as DSO local.\n    if (GV->isDeclarationForLinker() && isa<llvm::GlobalVariable>(GV) &&\n        !GV->isThreadLocal())\n      return false;\n  }\n\n  // On COFF, don't mark 'extern_weak' symbols as DSO local. If these symbols\n  // remain unresolved in the link, they can be resolved to zero, which is\n  // outside the current DSO.\n  if (TT.isOSBinFormatCOFF() && GV->hasExternalWeakLinkage())\n    return false;\n\n  // Every other GV is local on COFF.\n  // Make an exception for windows OS in the triple: Some firmware builds use\n  // *-win32-macho triples. This (accidentally?) produced windows relocations\n  // without GOT tables in older clang versions; Keep this behaviour.\n  // FIXME: even thread local variables?\n  if (TT.isOSBinFormatCOFF() || (TT.isOSWindows() && TT.isOSBinFormatMachO()))\n    return true;\n\n  const auto &CGOpts = CGM.getCodeGenOpts();\n  llvm::Reloc::Model RM = CGOpts.RelocationModel;\n  const auto &LOpts = CGM.getLangOpts();\n\n  if (TT.isOSBinFormatMachO()) {\n    if (RM == llvm::Reloc::Static)\n      return true;\n    return GV->isStrongDefinitionForLinker();\n  }\n\n  // Only handle COFF and ELF for now.\n  if (!TT.isOSBinFormatELF())\n    return false;\n\n  if (RM != llvm::Reloc::Static && !LOpts.PIE) {\n    // On ELF, if -fno-semantic-interposition is specified and the target\n    // supports local aliases, there will be neither CC1\n    // -fsemantic-interposition nor -fhalf-no-semantic-interposition. Set\n    // dso_local if using a local alias is preferable (can avoid GOT\n    // indirection).\n    if (!GV->canBenefitFromLocalAlias())\n      return false;\n    return !(CGM.getLangOpts().SemanticInterposition ||\n             CGM.getLangOpts().HalfNoSemanticInterposition);\n  }\n\n  // A definition cannot be preempted from an executable.\n  if (!GV->isDeclarationForLinker())\n    return true;\n\n  // Most PIC code sequences that assume that a symbol is local cannot produce a\n  // 0 if it turns out the symbol is undefined. While this is ABI and relocation\n  // depended, it seems worth it to handle it here.\n  if (RM == llvm::Reloc::PIC_ && GV->hasExternalWeakLinkage())\n    return false;\n\n  // PowerPC64 prefers TOC indirection to avoid copy relocations.\n  if (TT.isPPC64())\n    return false;\n\n  if (CGOpts.DirectAccessExternalData) {\n    // If -fdirect-access-external-data (default for -fno-pic), set dso_local\n    // for non-thread-local variables. If the symbol is not defined in the\n    // executable, a copy relocation will be needed at link time. dso_local is\n    // excluded for thread-local variables because they generally don't support\n    // copy relocations.\n    if (auto *Var = dyn_cast<llvm::GlobalVariable>(GV))\n      if (!Var->isThreadLocal())\n        return true;\n\n    // -fno-pic sets dso_local on a function declaration to allow direct\n    // accesses when taking its address (similar to a data symbol). If the\n    // function is not defined in the executable, a canonical PLT entry will be\n    // needed at link time. -fno-direct-access-external-data can avoid the\n    // canonical PLT entry. We don't generalize this condition to -fpie/-fpic as\n    // it could just cause trouble without providing perceptible benefits.\n    if (isa<llvm::Function>(GV) && !CGOpts.NoPLT && RM == llvm::Reloc::Static)\n      return true;\n  }\n\n  // If we can use copy relocations we can assume it is local.\n\n  // Otherwise don't assume it is local.\n  return false;\n}\n\nvoid CodeGenModule::setDSOLocal(llvm::GlobalValue *GV) const {\n  GV->setDSOLocal(shouldAssumeDSOLocal(*this, GV));\n}\n\nvoid CodeGenModule::setDLLImportDLLExport(llvm::GlobalValue *GV,\n                                          GlobalDecl GD) const {\n  const auto *D = dyn_cast<NamedDecl>(GD.getDecl());\n  // C++ destructors have a few C++ ABI specific special cases.\n  if (const auto *Dtor = dyn_cast_or_null<CXXDestructorDecl>(D)) {\n    getCXXABI().setCXXDestructorDLLStorage(GV, Dtor, GD.getDtorType());\n    return;\n  }\n  setDLLImportDLLExport(GV, D);\n}\n\nvoid CodeGenModule::setDLLImportDLLExport(llvm::GlobalValue *GV,\n                                          const NamedDecl *D) const {\n  if (D && D->isExternallyVisible()) {\n    if (D->hasAttr<DLLImportAttr>())\n      GV->setDLLStorageClass(llvm::GlobalVariable::DLLImportStorageClass);\n    else if (D->hasAttr<DLLExportAttr>() && !GV->isDeclarationForLinker())\n      GV->setDLLStorageClass(llvm::GlobalVariable::DLLExportStorageClass);\n  }\n}\n\nvoid CodeGenModule::setGVProperties(llvm::GlobalValue *GV,\n                                    GlobalDecl GD) const {\n  setDLLImportDLLExport(GV, GD);\n  setGVPropertiesAux(GV, dyn_cast<NamedDecl>(GD.getDecl()));\n}\n\nvoid CodeGenModule::setGVProperties(llvm::GlobalValue *GV,\n                                    const NamedDecl *D) const {\n  setDLLImportDLLExport(GV, D);\n  setGVPropertiesAux(GV, D);\n}\n\nvoid CodeGenModule::setGVPropertiesAux(llvm::GlobalValue *GV,\n                                       const NamedDecl *D) const {\n  setGlobalVisibility(GV, D);\n  setDSOLocal(GV);\n  GV->setPartition(CodeGenOpts.SymbolPartition);\n}\n\nstatic llvm::GlobalVariable::ThreadLocalMode GetLLVMTLSModel(StringRef S) {\n  return llvm::StringSwitch<llvm::GlobalVariable::ThreadLocalMode>(S)\n      .Case(\"global-dynamic\", llvm::GlobalVariable::GeneralDynamicTLSModel)\n      .Case(\"local-dynamic\", llvm::GlobalVariable::LocalDynamicTLSModel)\n      .Case(\"initial-exec\", llvm::GlobalVariable::InitialExecTLSModel)\n      .Case(\"local-exec\", llvm::GlobalVariable::LocalExecTLSModel);\n}\n\nllvm::GlobalVariable::ThreadLocalMode\nCodeGenModule::GetDefaultLLVMTLSModel() const {\n  switch (CodeGenOpts.getDefaultTLSModel()) {\n  case CodeGenOptions::GeneralDynamicTLSModel:\n    return llvm::GlobalVariable::GeneralDynamicTLSModel;\n  case CodeGenOptions::LocalDynamicTLSModel:\n    return llvm::GlobalVariable::LocalDynamicTLSModel;\n  case CodeGenOptions::InitialExecTLSModel:\n    return llvm::GlobalVariable::InitialExecTLSModel;\n  case CodeGenOptions::LocalExecTLSModel:\n    return llvm::GlobalVariable::LocalExecTLSModel;\n  }\n  llvm_unreachable(\"Invalid TLS model!\");\n}\n\nvoid CodeGenModule::setTLSMode(llvm::GlobalValue *GV, const VarDecl &D) const {\n  assert(D.getTLSKind() && \"setting TLS mode on non-TLS var!\");\n\n  llvm::GlobalValue::ThreadLocalMode TLM;\n  TLM = GetDefaultLLVMTLSModel();\n\n  // Override the TLS model if it is explicitly specified.\n  if (const TLSModelAttr *Attr = D.getAttr<TLSModelAttr>()) {\n    TLM = GetLLVMTLSModel(Attr->getModel());\n  }\n\n  GV->setThreadLocalMode(TLM);\n}\n\nstatic std::string getCPUSpecificMangling(const CodeGenModule &CGM,\n                                          StringRef Name) {\n  const TargetInfo &Target = CGM.getTarget();\n  return (Twine('.') + Twine(Target.CPUSpecificManglingCharacter(Name))).str();\n}\n\nstatic void AppendCPUSpecificCPUDispatchMangling(const CodeGenModule &CGM,\n                                                 const CPUSpecificAttr *Attr,\n                                                 unsigned CPUIndex,\n                                                 raw_ostream &Out) {\n  // cpu_specific gets the current name, dispatch gets the resolver if IFunc is\n  // supported.\n  if (Attr)\n    Out << getCPUSpecificMangling(CGM, Attr->getCPUName(CPUIndex)->getName());\n  else if (CGM.getTarget().supportsIFunc())\n    Out << \".resolver\";\n}\n\nstatic void AppendTargetMangling(const CodeGenModule &CGM,\n                                 const TargetAttr *Attr, raw_ostream &Out) {\n  if (Attr->isDefaultVersion())\n    return;\n\n  Out << '.';\n  const TargetInfo &Target = CGM.getTarget();\n  ParsedTargetAttr Info =\n      Attr->parse([&Target](StringRef LHS, StringRef RHS) {\n        // Multiversioning doesn't allow \"no-${feature}\", so we can\n        // only have \"+\" prefixes here.\n        assert(LHS.startswith(\"+\") && RHS.startswith(\"+\") &&\n               \"Features should always have a prefix.\");\n        return Target.multiVersionSortPriority(LHS.substr(1)) >\n               Target.multiVersionSortPriority(RHS.substr(1));\n      });\n\n  bool IsFirst = true;\n\n  if (!Info.Architecture.empty()) {\n    IsFirst = false;\n    Out << \"arch_\" << Info.Architecture;\n  }\n\n  for (StringRef Feat : Info.Features) {\n    if (!IsFirst)\n      Out << '_';\n    IsFirst = false;\n    Out << Feat.substr(1);\n  }\n}\n\nstatic std::string getMangledNameImpl(const CodeGenModule &CGM, GlobalDecl GD,\n                                      const NamedDecl *ND,\n                                      bool OmitMultiVersionMangling = false) {\n  SmallString<256> Buffer;\n  llvm::raw_svector_ostream Out(Buffer);\n  MangleContext &MC = CGM.getCXXABI().getMangleContext();\n  if (MC.shouldMangleDeclName(ND))\n    MC.mangleName(GD.getWithDecl(ND), Out);\n  else {\n    IdentifierInfo *II = ND->getIdentifier();\n    assert(II && \"Attempt to mangle unnamed decl.\");\n    const auto *FD = dyn_cast<FunctionDecl>(ND);\n\n    if (FD &&\n        FD->getType()->castAs<FunctionType>()->getCallConv() == CC_X86RegCall) {\n      Out << \"__regcall3__\" << II->getName();\n    } else if (FD && FD->hasAttr<CUDAGlobalAttr>() &&\n               GD.getKernelReferenceKind() == KernelReferenceKind::Stub) {\n      Out << \"__device_stub__\" << II->getName();\n    } else {\n      Out << II->getName();\n    }\n  }\n\n  if (const auto *FD = dyn_cast<FunctionDecl>(ND))\n    if (FD->isMultiVersion() && !OmitMultiVersionMangling) {\n      switch (FD->getMultiVersionKind()) {\n      case MultiVersionKind::CPUDispatch:\n      case MultiVersionKind::CPUSpecific:\n        AppendCPUSpecificCPUDispatchMangling(CGM,\n                                             FD->getAttr<CPUSpecificAttr>(),\n                                             GD.getMultiVersionIndex(), Out);\n        break;\n      case MultiVersionKind::Target:\n        AppendTargetMangling(CGM, FD->getAttr<TargetAttr>(), Out);\n        break;\n      case MultiVersionKind::None:\n        llvm_unreachable(\"None multiversion type isn't valid here\");\n      }\n    }\n\n  return std::string(Out.str());\n}\n\nvoid CodeGenModule::UpdateMultiVersionNames(GlobalDecl GD,\n                                            const FunctionDecl *FD) {\n  if (!FD->isMultiVersion())\n    return;\n\n  // Get the name of what this would be without the 'target' attribute.  This\n  // allows us to lookup the version that was emitted when this wasn't a\n  // multiversion function.\n  std::string NonTargetName =\n      getMangledNameImpl(*this, GD, FD, /*OmitMultiVersionMangling=*/true);\n  GlobalDecl OtherGD;\n  if (lookupRepresentativeDecl(NonTargetName, OtherGD)) {\n    assert(OtherGD.getCanonicalDecl()\n               .getDecl()\n               ->getAsFunction()\n               ->isMultiVersion() &&\n           \"Other GD should now be a multiversioned function\");\n    // OtherFD is the version of this function that was mangled BEFORE\n    // becoming a MultiVersion function.  It potentially needs to be updated.\n    const FunctionDecl *OtherFD = OtherGD.getCanonicalDecl()\n                                      .getDecl()\n                                      ->getAsFunction()\n                                      ->getMostRecentDecl();\n    std::string OtherName = getMangledNameImpl(*this, OtherGD, OtherFD);\n    // This is so that if the initial version was already the 'default'\n    // version, we don't try to update it.\n    if (OtherName != NonTargetName) {\n      // Remove instead of erase, since others may have stored the StringRef\n      // to this.\n      const auto ExistingRecord = Manglings.find(NonTargetName);\n      if (ExistingRecord != std::end(Manglings))\n        Manglings.remove(&(*ExistingRecord));\n      auto Result = Manglings.insert(std::make_pair(OtherName, OtherGD));\n      MangledDeclNames[OtherGD.getCanonicalDecl()] = Result.first->first();\n      if (llvm::GlobalValue *Entry = GetGlobalValue(NonTargetName))\n        Entry->setName(OtherName);\n    }\n  }\n}\n\nStringRef CodeGenModule::getMangledName(GlobalDecl GD) {\n  GlobalDecl CanonicalGD = GD.getCanonicalDecl();\n\n  // Some ABIs don't have constructor variants.  Make sure that base and\n  // complete constructors get mangled the same.\n  if (const auto *CD = dyn_cast<CXXConstructorDecl>(CanonicalGD.getDecl())) {\n    if (!getTarget().getCXXABI().hasConstructorVariants()) {\n      CXXCtorType OrigCtorType = GD.getCtorType();\n      assert(OrigCtorType == Ctor_Base || OrigCtorType == Ctor_Complete);\n      if (OrigCtorType == Ctor_Base)\n        CanonicalGD = GlobalDecl(CD, Ctor_Complete);\n    }\n  }\n\n  auto FoundName = MangledDeclNames.find(CanonicalGD);\n  if (FoundName != MangledDeclNames.end())\n    return FoundName->second;\n\n  // Keep the first result in the case of a mangling collision.\n  const auto *ND = cast<NamedDecl>(GD.getDecl());\n  std::string MangledName = getMangledNameImpl(*this, GD, ND);\n\n  // Ensure either we have different ABIs between host and device compilations,\n  // says host compilation following MSVC ABI but device compilation follows\n  // Itanium C++ ABI or, if they follow the same ABI, kernel names after\n  // mangling should be the same after name stubbing. The later checking is\n  // very important as the device kernel name being mangled in host-compilation\n  // is used to resolve the device binaries to be executed. Inconsistent naming\n  // result in undefined behavior. Even though we cannot check that naming\n  // directly between host- and device-compilations, the host- and\n  // device-mangling in host compilation could help catching certain ones.\n  assert(!isa<FunctionDecl>(ND) || !ND->hasAttr<CUDAGlobalAttr>() ||\n         getLangOpts().CUDAIsDevice ||\n         (getContext().getAuxTargetInfo() &&\n          (getContext().getAuxTargetInfo()->getCXXABI() !=\n           getContext().getTargetInfo().getCXXABI())) ||\n         getCUDARuntime().getDeviceSideName(ND) ==\n             getMangledNameImpl(\n                 *this,\n                 GD.getWithKernelReferenceKind(KernelReferenceKind::Kernel),\n                 ND));\n\n  auto Result = Manglings.insert(std::make_pair(MangledName, GD));\n  return MangledDeclNames[CanonicalGD] = Result.first->first();\n}\n\nStringRef CodeGenModule::getBlockMangledName(GlobalDecl GD,\n                                             const BlockDecl *BD) {\n  MangleContext &MangleCtx = getCXXABI().getMangleContext();\n  const Decl *D = GD.getDecl();\n\n  SmallString<256> Buffer;\n  llvm::raw_svector_ostream Out(Buffer);\n  if (!D)\n    MangleCtx.mangleGlobalBlock(BD,\n      dyn_cast_or_null<VarDecl>(initializedGlobalDecl.getDecl()), Out);\n  else if (const auto *CD = dyn_cast<CXXConstructorDecl>(D))\n    MangleCtx.mangleCtorBlock(CD, GD.getCtorType(), BD, Out);\n  else if (const auto *DD = dyn_cast<CXXDestructorDecl>(D))\n    MangleCtx.mangleDtorBlock(DD, GD.getDtorType(), BD, Out);\n  else\n    MangleCtx.mangleBlock(cast<DeclContext>(D), BD, Out);\n\n  auto Result = Manglings.insert(std::make_pair(Out.str(), BD));\n  return Result.first->first();\n}\n\nllvm::GlobalValue *CodeGenModule::GetGlobalValue(StringRef Name) {\n  return getModule().getNamedValue(Name);\n}\n\n/// AddGlobalCtor - Add a function to the list that will be called before\n/// main() runs.\nvoid CodeGenModule::AddGlobalCtor(llvm::Function *Ctor, int Priority,\n                                  llvm::Constant *AssociatedData) {\n  // FIXME: Type coercion of void()* types.\n  GlobalCtors.push_back(Structor(Priority, Ctor, AssociatedData));\n}\n\n/// AddGlobalDtor - Add a function to the list that will be called\n/// when the module is unloaded.\nvoid CodeGenModule::AddGlobalDtor(llvm::Function *Dtor, int Priority,\n                                  bool IsDtorAttrFunc) {\n  if (CodeGenOpts.RegisterGlobalDtorsWithAtExit &&\n      (!getContext().getTargetInfo().getTriple().isOSAIX() || IsDtorAttrFunc)) {\n    DtorsUsingAtExit[Priority].push_back(Dtor);\n    return;\n  }\n\n  // FIXME: Type coercion of void()* types.\n  GlobalDtors.push_back(Structor(Priority, Dtor, nullptr));\n}\n\nvoid CodeGenModule::EmitCtorList(CtorList &Fns, const char *GlobalName) {\n  if (Fns.empty()) return;\n\n  // Ctor function type is void()*.\n  llvm::FunctionType* CtorFTy = llvm::FunctionType::get(VoidTy, false);\n  llvm::Type *CtorPFTy = llvm::PointerType::get(CtorFTy,\n      TheModule.getDataLayout().getProgramAddressSpace());\n\n  // Get the type of a ctor entry, { i32, void ()*, i8* }.\n  llvm::StructType *CtorStructTy = llvm::StructType::get(\n      Int32Ty, CtorPFTy, VoidPtrTy);\n\n  // Construct the constructor and destructor arrays.\n  ConstantInitBuilder builder(*this);\n  auto ctors = builder.beginArray(CtorStructTy);\n  for (const auto &I : Fns) {\n    auto ctor = ctors.beginStruct(CtorStructTy);\n    ctor.addInt(Int32Ty, I.Priority);\n    ctor.add(llvm::ConstantExpr::getBitCast(I.Initializer, CtorPFTy));\n    if (I.AssociatedData)\n      ctor.add(llvm::ConstantExpr::getBitCast(I.AssociatedData, VoidPtrTy));\n    else\n      ctor.addNullPointer(VoidPtrTy);\n    ctor.finishAndAddTo(ctors);\n  }\n\n  auto list =\n    ctors.finishAndCreateGlobal(GlobalName, getPointerAlign(),\n                                /*constant*/ false,\n                                llvm::GlobalValue::AppendingLinkage);\n\n  // The LTO linker doesn't seem to like it when we set an alignment\n  // on appending variables.  Take it off as a workaround.\n  list->setAlignment(llvm::None);\n\n  Fns.clear();\n}\n\nllvm::GlobalValue::LinkageTypes\nCodeGenModule::getFunctionLinkage(GlobalDecl GD) {\n  const auto *D = cast<FunctionDecl>(GD.getDecl());\n\n  GVALinkage Linkage = getContext().GetGVALinkageForFunction(D);\n\n  if (const auto *Dtor = dyn_cast<CXXDestructorDecl>(D))\n    return getCXXABI().getCXXDestructorLinkage(Linkage, Dtor, GD.getDtorType());\n\n  if (isa<CXXConstructorDecl>(D) &&\n      cast<CXXConstructorDecl>(D)->isInheritingConstructor() &&\n      Context.getTargetInfo().getCXXABI().isMicrosoft()) {\n    // Our approach to inheriting constructors is fundamentally different from\n    // that used by the MS ABI, so keep our inheriting constructor thunks\n    // internal rather than trying to pick an unambiguous mangling for them.\n    return llvm::GlobalValue::InternalLinkage;\n  }\n\n  return getLLVMLinkageForDeclarator(D, Linkage, /*IsConstantVariable=*/false);\n}\n\nllvm::ConstantInt *CodeGenModule::CreateCrossDsoCfiTypeId(llvm::Metadata *MD) {\n  llvm::MDString *MDS = dyn_cast<llvm::MDString>(MD);\n  if (!MDS) return nullptr;\n\n  return llvm::ConstantInt::get(Int64Ty, llvm::MD5Hash(MDS->getString()));\n}\n\nvoid CodeGenModule::SetLLVMFunctionAttributes(GlobalDecl GD,\n                                              const CGFunctionInfo &Info,\n                                              llvm::Function *F) {\n  unsigned CallingConv;\n  llvm::AttributeList PAL;\n  ConstructAttributeList(F->getName(), Info, GD, PAL, CallingConv, false);\n  F->setAttributes(PAL);\n  F->setCallingConv(static_cast<llvm::CallingConv::ID>(CallingConv));\n}\n\nstatic void removeImageAccessQualifier(std::string& TyName) {\n  std::string ReadOnlyQual(\"__read_only\");\n  std::string::size_type ReadOnlyPos = TyName.find(ReadOnlyQual);\n  if (ReadOnlyPos != std::string::npos)\n    // \"+ 1\" for the space after access qualifier.\n    TyName.erase(ReadOnlyPos, ReadOnlyQual.size() + 1);\n  else {\n    std::string WriteOnlyQual(\"__write_only\");\n    std::string::size_type WriteOnlyPos = TyName.find(WriteOnlyQual);\n    if (WriteOnlyPos != std::string::npos)\n      TyName.erase(WriteOnlyPos, WriteOnlyQual.size() + 1);\n    else {\n      std::string ReadWriteQual(\"__read_write\");\n      std::string::size_type ReadWritePos = TyName.find(ReadWriteQual);\n      if (ReadWritePos != std::string::npos)\n        TyName.erase(ReadWritePos, ReadWriteQual.size() + 1);\n    }\n  }\n}\n\n// Returns the address space id that should be produced to the\n// kernel_arg_addr_space metadata. This is always fixed to the ids\n// as specified in the SPIR 2.0 specification in order to differentiate\n// for example in clGetKernelArgInfo() implementation between the address\n// spaces with targets without unique mapping to the OpenCL address spaces\n// (basically all single AS CPUs).\nstatic unsigned ArgInfoAddressSpace(LangAS AS) {\n  switch (AS) {\n  case LangAS::opencl_global:\n    return 1;\n  case LangAS::opencl_constant:\n    return 2;\n  case LangAS::opencl_local:\n    return 3;\n  case LangAS::opencl_generic:\n    return 4; // Not in SPIR 2.0 specs.\n  case LangAS::opencl_global_device:\n    return 5;\n  case LangAS::opencl_global_host:\n    return 6;\n  default:\n    return 0; // Assume private.\n  }\n}\n\nvoid CodeGenModule::GenOpenCLArgMetadata(llvm::Function *Fn,\n                                         const FunctionDecl *FD,\n                                         CodeGenFunction *CGF) {\n  assert(((FD && CGF) || (!FD && !CGF)) &&\n         \"Incorrect use - FD and CGF should either be both null or not!\");\n  // Create MDNodes that represent the kernel arg metadata.\n  // Each MDNode is a list in the form of \"key\", N number of values which is\n  // the same number of values as their are kernel arguments.\n\n  const PrintingPolicy &Policy = Context.getPrintingPolicy();\n\n  // MDNode for the kernel argument address space qualifiers.\n  SmallVector<llvm::Metadata *, 8> addressQuals;\n\n  // MDNode for the kernel argument access qualifiers (images only).\n  SmallVector<llvm::Metadata *, 8> accessQuals;\n\n  // MDNode for the kernel argument type names.\n  SmallVector<llvm::Metadata *, 8> argTypeNames;\n\n  // MDNode for the kernel argument base type names.\n  SmallVector<llvm::Metadata *, 8> argBaseTypeNames;\n\n  // MDNode for the kernel argument type qualifiers.\n  SmallVector<llvm::Metadata *, 8> argTypeQuals;\n\n  // MDNode for the kernel argument names.\n  SmallVector<llvm::Metadata *, 8> argNames;\n\n  if (FD && CGF)\n    for (unsigned i = 0, e = FD->getNumParams(); i != e; ++i) {\n      const ParmVarDecl *parm = FD->getParamDecl(i);\n      QualType ty = parm->getType();\n      std::string typeQuals;\n\n      // Get image and pipe access qualifier:\n      if (ty->isImageType() || ty->isPipeType()) {\n        const Decl *PDecl = parm;\n        if (auto *TD = dyn_cast<TypedefType>(ty))\n          PDecl = TD->getDecl();\n        const OpenCLAccessAttr *A = PDecl->getAttr<OpenCLAccessAttr>();\n        if (A && A->isWriteOnly())\n          accessQuals.push_back(llvm::MDString::get(VMContext, \"write_only\"));\n        else if (A && A->isReadWrite())\n          accessQuals.push_back(llvm::MDString::get(VMContext, \"read_write\"));\n        else\n          accessQuals.push_back(llvm::MDString::get(VMContext, \"read_only\"));\n      } else\n        accessQuals.push_back(llvm::MDString::get(VMContext, \"none\"));\n\n      // Get argument name.\n      argNames.push_back(llvm::MDString::get(VMContext, parm->getName()));\n\n      auto getTypeSpelling = [&](QualType Ty) {\n        auto typeName = Ty.getUnqualifiedType().getAsString(Policy);\n\n        if (Ty.isCanonical()) {\n          StringRef typeNameRef = typeName;\n          // Turn \"unsigned type\" to \"utype\"\n          if (typeNameRef.consume_front(\"unsigned \"))\n            return std::string(\"u\") + typeNameRef.str();\n          if (typeNameRef.consume_front(\"signed \"))\n            return typeNameRef.str();\n        }\n\n        return typeName;\n      };\n\n      if (ty->isPointerType()) {\n        QualType pointeeTy = ty->getPointeeType();\n\n        // Get address qualifier.\n        addressQuals.push_back(\n            llvm::ConstantAsMetadata::get(CGF->Builder.getInt32(\n                ArgInfoAddressSpace(pointeeTy.getAddressSpace()))));\n\n        // Get argument type name.\n        std::string typeName = getTypeSpelling(pointeeTy) + \"*\";\n        std::string baseTypeName =\n            getTypeSpelling(pointeeTy.getCanonicalType()) + \"*\";\n        argTypeNames.push_back(llvm::MDString::get(VMContext, typeName));\n        argBaseTypeNames.push_back(\n            llvm::MDString::get(VMContext, baseTypeName));\n\n        // Get argument type qualifiers:\n        if (ty.isRestrictQualified())\n          typeQuals = \"restrict\";\n        if (pointeeTy.isConstQualified() ||\n            (pointeeTy.getAddressSpace() == LangAS::opencl_constant))\n          typeQuals += typeQuals.empty() ? \"const\" : \" const\";\n        if (pointeeTy.isVolatileQualified())\n          typeQuals += typeQuals.empty() ? \"volatile\" : \" volatile\";\n      } else {\n        uint32_t AddrSpc = 0;\n        bool isPipe = ty->isPipeType();\n        if (ty->isImageType() || isPipe)\n          AddrSpc = ArgInfoAddressSpace(LangAS::opencl_global);\n\n        addressQuals.push_back(\n            llvm::ConstantAsMetadata::get(CGF->Builder.getInt32(AddrSpc)));\n\n        // Get argument type name.\n        ty = isPipe ? ty->castAs<PipeType>()->getElementType() : ty;\n        std::string typeName = getTypeSpelling(ty);\n        std::string baseTypeName = getTypeSpelling(ty.getCanonicalType());\n\n        // Remove access qualifiers on images\n        // (as they are inseparable from type in clang implementation,\n        // but OpenCL spec provides a special query to get access qualifier\n        // via clGetKernelArgInfo with CL_KERNEL_ARG_ACCESS_QUALIFIER):\n        if (ty->isImageType()) {\n          removeImageAccessQualifier(typeName);\n          removeImageAccessQualifier(baseTypeName);\n        }\n\n        argTypeNames.push_back(llvm::MDString::get(VMContext, typeName));\n        argBaseTypeNames.push_back(\n            llvm::MDString::get(VMContext, baseTypeName));\n\n        if (isPipe)\n          typeQuals = \"pipe\";\n      }\n      argTypeQuals.push_back(llvm::MDString::get(VMContext, typeQuals));\n    }\n\n  Fn->setMetadata(\"kernel_arg_addr_space\",\n                  llvm::MDNode::get(VMContext, addressQuals));\n  Fn->setMetadata(\"kernel_arg_access_qual\",\n                  llvm::MDNode::get(VMContext, accessQuals));\n  Fn->setMetadata(\"kernel_arg_type\",\n                  llvm::MDNode::get(VMContext, argTypeNames));\n  Fn->setMetadata(\"kernel_arg_base_type\",\n                  llvm::MDNode::get(VMContext, argBaseTypeNames));\n  Fn->setMetadata(\"kernel_arg_type_qual\",\n                  llvm::MDNode::get(VMContext, argTypeQuals));\n  if (getCodeGenOpts().EmitOpenCLArgMetadata)\n    Fn->setMetadata(\"kernel_arg_name\",\n                    llvm::MDNode::get(VMContext, argNames));\n}\n\n/// Determines whether the language options require us to model\n/// unwind exceptions.  We treat -fexceptions as mandating this\n/// except under the fragile ObjC ABI with only ObjC exceptions\n/// enabled.  This means, for example, that C with -fexceptions\n/// enables this.\nstatic bool hasUnwindExceptions(const LangOptions &LangOpts) {\n  // If exceptions are completely disabled, obviously this is false.\n  if (!LangOpts.Exceptions) return false;\n\n  // If C++ exceptions are enabled, this is true.\n  if (LangOpts.CXXExceptions) return true;\n\n  // If ObjC exceptions are enabled, this depends on the ABI.\n  if (LangOpts.ObjCExceptions) {\n    return LangOpts.ObjCRuntime.hasUnwindExceptions();\n  }\n\n  return true;\n}\n\nstatic bool requiresMemberFunctionPointerTypeMetadata(CodeGenModule &CGM,\n                                                      const CXXMethodDecl *MD) {\n  // Check that the type metadata can ever actually be used by a call.\n  if (!CGM.getCodeGenOpts().LTOUnit ||\n      !CGM.HasHiddenLTOVisibility(MD->getParent()))\n    return false;\n\n  // Only functions whose address can be taken with a member function pointer\n  // need this sort of type metadata.\n  return !MD->isStatic() && !MD->isVirtual() && !isa<CXXConstructorDecl>(MD) &&\n         !isa<CXXDestructorDecl>(MD);\n}\n\nstd::vector<const CXXRecordDecl *>\nCodeGenModule::getMostBaseClasses(const CXXRecordDecl *RD) {\n  llvm::SetVector<const CXXRecordDecl *> MostBases;\n\n  std::function<void (const CXXRecordDecl *)> CollectMostBases;\n  CollectMostBases = [&](const CXXRecordDecl *RD) {\n    if (RD->getNumBases() == 0)\n      MostBases.insert(RD);\n    for (const CXXBaseSpecifier &B : RD->bases())\n      CollectMostBases(B.getType()->getAsCXXRecordDecl());\n  };\n  CollectMostBases(RD);\n  return MostBases.takeVector();\n}\n\nvoid CodeGenModule::SetLLVMFunctionAttributesForDefinition(const Decl *D,\n                                                           llvm::Function *F) {\n  llvm::AttrBuilder B;\n\n  if (CodeGenOpts.UnwindTables)\n    B.addAttribute(llvm::Attribute::UWTable);\n\n  if (CodeGenOpts.StackClashProtector)\n    B.addAttribute(\"probe-stack\", \"inline-asm\");\n\n  if (!hasUnwindExceptions(LangOpts))\n    B.addAttribute(llvm::Attribute::NoUnwind);\n\n  if (!D || !D->hasAttr<NoStackProtectorAttr>()) {\n    if (LangOpts.getStackProtector() == LangOptions::SSPOn)\n      B.addAttribute(llvm::Attribute::StackProtect);\n    else if (LangOpts.getStackProtector() == LangOptions::SSPStrong)\n      B.addAttribute(llvm::Attribute::StackProtectStrong);\n    else if (LangOpts.getStackProtector() == LangOptions::SSPReq)\n      B.addAttribute(llvm::Attribute::StackProtectReq);\n  }\n\n  if (!D) {\n    // If we don't have a declaration to control inlining, the function isn't\n    // explicitly marked as alwaysinline for semantic reasons, and inlining is\n    // disabled, mark the function as noinline.\n    if (!F->hasFnAttribute(llvm::Attribute::AlwaysInline) &&\n        CodeGenOpts.getInlining() == CodeGenOptions::OnlyAlwaysInlining)\n      B.addAttribute(llvm::Attribute::NoInline);\n\n    F->addAttributes(llvm::AttributeList::FunctionIndex, B);\n    return;\n  }\n\n  // Track whether we need to add the optnone LLVM attribute,\n  // starting with the default for this optimization level.\n  bool ShouldAddOptNone =\n      !CodeGenOpts.DisableO0ImplyOptNone && CodeGenOpts.OptimizationLevel == 0;\n  // We can't add optnone in the following cases, it won't pass the verifier.\n  ShouldAddOptNone &= !D->hasAttr<MinSizeAttr>();\n  ShouldAddOptNone &= !D->hasAttr<AlwaysInlineAttr>();\n\n  // Add optnone, but do so only if the function isn't always_inline.\n  if ((ShouldAddOptNone || D->hasAttr<OptimizeNoneAttr>()) &&\n      !F->hasFnAttribute(llvm::Attribute::AlwaysInline)) {\n    B.addAttribute(llvm::Attribute::OptimizeNone);\n\n    // OptimizeNone implies noinline; we should not be inlining such functions.\n    B.addAttribute(llvm::Attribute::NoInline);\n\n    // We still need to handle naked functions even though optnone subsumes\n    // much of their semantics.\n    if (D->hasAttr<NakedAttr>())\n      B.addAttribute(llvm::Attribute::Naked);\n\n    // OptimizeNone wins over OptimizeForSize and MinSize.\n    F->removeFnAttr(llvm::Attribute::OptimizeForSize);\n    F->removeFnAttr(llvm::Attribute::MinSize);\n  } else if (D->hasAttr<NakedAttr>()) {\n    // Naked implies noinline: we should not be inlining such functions.\n    B.addAttribute(llvm::Attribute::Naked);\n    B.addAttribute(llvm::Attribute::NoInline);\n  } else if (D->hasAttr<NoDuplicateAttr>()) {\n    B.addAttribute(llvm::Attribute::NoDuplicate);\n  } else if (D->hasAttr<NoInlineAttr>() && !F->hasFnAttribute(llvm::Attribute::AlwaysInline)) {\n    // Add noinline if the function isn't always_inline.\n    B.addAttribute(llvm::Attribute::NoInline);\n  } else if (D->hasAttr<AlwaysInlineAttr>() &&\n             !F->hasFnAttribute(llvm::Attribute::NoInline)) {\n    // (noinline wins over always_inline, and we can't specify both in IR)\n    B.addAttribute(llvm::Attribute::AlwaysInline);\n  } else if (CodeGenOpts.getInlining() == CodeGenOptions::OnlyAlwaysInlining) {\n    // If we're not inlining, then force everything that isn't always_inline to\n    // carry an explicit noinline attribute.\n    if (!F->hasFnAttribute(llvm::Attribute::AlwaysInline))\n      B.addAttribute(llvm::Attribute::NoInline);\n  } else {\n    // Otherwise, propagate the inline hint attribute and potentially use its\n    // absence to mark things as noinline.\n    if (auto *FD = dyn_cast<FunctionDecl>(D)) {\n      // Search function and template pattern redeclarations for inline.\n      auto CheckForInline = [](const FunctionDecl *FD) {\n        auto CheckRedeclForInline = [](const FunctionDecl *Redecl) {\n          return Redecl->isInlineSpecified();\n        };\n        if (any_of(FD->redecls(), CheckRedeclForInline))\n          return true;\n        const FunctionDecl *Pattern = FD->getTemplateInstantiationPattern();\n        if (!Pattern)\n          return false;\n        return any_of(Pattern->redecls(), CheckRedeclForInline);\n      };\n      if (CheckForInline(FD)) {\n        B.addAttribute(llvm::Attribute::InlineHint);\n      } else if (CodeGenOpts.getInlining() ==\n                     CodeGenOptions::OnlyHintInlining &&\n                 !FD->isInlined() &&\n                 !F->hasFnAttribute(llvm::Attribute::AlwaysInline)) {\n        B.addAttribute(llvm::Attribute::NoInline);\n      }\n    }\n  }\n\n  // Add other optimization related attributes if we are optimizing this\n  // function.\n  if (!D->hasAttr<OptimizeNoneAttr>()) {\n    if (D->hasAttr<ColdAttr>()) {\n      if (!ShouldAddOptNone)\n        B.addAttribute(llvm::Attribute::OptimizeForSize);\n      B.addAttribute(llvm::Attribute::Cold);\n    }\n    if (D->hasAttr<HotAttr>())\n      B.addAttribute(llvm::Attribute::Hot);\n    if (D->hasAttr<MinSizeAttr>())\n      B.addAttribute(llvm::Attribute::MinSize);\n  }\n\n  F->addAttributes(llvm::AttributeList::FunctionIndex, B);\n\n  unsigned alignment = D->getMaxAlignment() / Context.getCharWidth();\n  if (alignment)\n    F->setAlignment(llvm::Align(alignment));\n\n  if (!D->hasAttr<AlignedAttr>())\n    if (LangOpts.FunctionAlignment)\n      F->setAlignment(llvm::Align(1ull << LangOpts.FunctionAlignment));\n\n  // Some C++ ABIs require 2-byte alignment for member functions, in order to\n  // reserve a bit for differentiating between virtual and non-virtual member\n  // functions. If the current target's C++ ABI requires this and this is a\n  // member function, set its alignment accordingly.\n  if (getTarget().getCXXABI().areMemberFunctionsAligned()) {\n    if (F->getAlignment() < 2 && isa<CXXMethodDecl>(D))\n      F->setAlignment(llvm::Align(2));\n  }\n\n  // In the cross-dso CFI mode with canonical jump tables, we want !type\n  // attributes on definitions only.\n  if (CodeGenOpts.SanitizeCfiCrossDso &&\n      CodeGenOpts.SanitizeCfiCanonicalJumpTables) {\n    if (auto *FD = dyn_cast<FunctionDecl>(D)) {\n      // Skip available_externally functions. They won't be codegen'ed in the\n      // current module anyway.\n      if (getContext().GetGVALinkageForFunction(FD) != GVA_AvailableExternally)\n        CreateFunctionTypeMetadataForIcall(FD, F);\n    }\n  }\n\n  // Emit type metadata on member functions for member function pointer checks.\n  // These are only ever necessary on definitions; we're guaranteed that the\n  // definition will be present in the LTO unit as a result of LTO visibility.\n  auto *MD = dyn_cast<CXXMethodDecl>(D);\n  if (MD && requiresMemberFunctionPointerTypeMetadata(*this, MD)) {\n    for (const CXXRecordDecl *Base : getMostBaseClasses(MD->getParent())) {\n      llvm::Metadata *Id =\n          CreateMetadataIdentifierForType(Context.getMemberPointerType(\n              MD->getType(), Context.getRecordType(Base).getTypePtr()));\n      F->addTypeMetadata(0, Id);\n    }\n  }\n}\n\nvoid CodeGenModule::setLLVMFunctionFEnvAttributes(const FunctionDecl *D,\n                                                  llvm::Function *F) {\n  if (D->hasAttr<StrictFPAttr>()) {\n    llvm::AttrBuilder FuncAttrs;\n    FuncAttrs.addAttribute(\"strictfp\");\n    F->addAttributes(llvm::AttributeList::FunctionIndex, FuncAttrs);\n  }\n}\n\nvoid CodeGenModule::SetCommonAttributes(GlobalDecl GD, llvm::GlobalValue *GV) {\n  const Decl *D = GD.getDecl();\n  if (dyn_cast_or_null<NamedDecl>(D))\n    setGVProperties(GV, GD);\n  else\n    GV->setVisibility(llvm::GlobalValue::DefaultVisibility);\n\n  if (D && D->hasAttr<UsedAttr>())\n    addUsedGlobal(GV);\n\n  if (CodeGenOpts.KeepStaticConsts && D && isa<VarDecl>(D)) {\n    const auto *VD = cast<VarDecl>(D);\n    if (VD->getType().isConstQualified() &&\n        VD->getStorageDuration() == SD_Static)\n      addUsedGlobal(GV);\n  }\n}\n\nbool CodeGenModule::GetCPUAndFeaturesAttributes(GlobalDecl GD,\n                                                llvm::AttrBuilder &Attrs) {\n  // Add target-cpu and target-features attributes to functions. If\n  // we have a decl for the function and it has a target attribute then\n  // parse that and add it to the feature set.\n  StringRef TargetCPU = getTarget().getTargetOpts().CPU;\n  StringRef TuneCPU = getTarget().getTargetOpts().TuneCPU;\n  std::vector<std::string> Features;\n  const auto *FD = dyn_cast_or_null<FunctionDecl>(GD.getDecl());\n  FD = FD ? FD->getMostRecentDecl() : FD;\n  const auto *TD = FD ? FD->getAttr<TargetAttr>() : nullptr;\n  const auto *SD = FD ? FD->getAttr<CPUSpecificAttr>() : nullptr;\n  bool AddedAttr = false;\n  if (TD || SD) {\n    llvm::StringMap<bool> FeatureMap;\n    getContext().getFunctionFeatureMap(FeatureMap, GD);\n\n    // Produce the canonical string for this set of features.\n    for (const llvm::StringMap<bool>::value_type &Entry : FeatureMap)\n      Features.push_back((Entry.getValue() ? \"+\" : \"-\") + Entry.getKey().str());\n\n    // Now add the target-cpu and target-features to the function.\n    // While we populated the feature map above, we still need to\n    // get and parse the target attribute so we can get the cpu for\n    // the function.\n    if (TD) {\n      ParsedTargetAttr ParsedAttr = TD->parse();\n      if (!ParsedAttr.Architecture.empty() &&\n          getTarget().isValidCPUName(ParsedAttr.Architecture)) {\n        TargetCPU = ParsedAttr.Architecture;\n        TuneCPU = \"\"; // Clear the tune CPU.\n      }\n      if (!ParsedAttr.Tune.empty() &&\n          getTarget().isValidCPUName(ParsedAttr.Tune))\n        TuneCPU = ParsedAttr.Tune;\n    }\n  } else {\n    // Otherwise just add the existing target cpu and target features to the\n    // function.\n    Features = getTarget().getTargetOpts().Features;\n  }\n\n  if (!TargetCPU.empty()) {\n    Attrs.addAttribute(\"target-cpu\", TargetCPU);\n    AddedAttr = true;\n  }\n  if (!TuneCPU.empty()) {\n    Attrs.addAttribute(\"tune-cpu\", TuneCPU);\n    AddedAttr = true;\n  }\n  if (!Features.empty()) {\n    llvm::sort(Features);\n    Attrs.addAttribute(\"target-features\", llvm::join(Features, \",\"));\n    AddedAttr = true;\n  }\n\n  return AddedAttr;\n}\n\nvoid CodeGenModule::setNonAliasAttributes(GlobalDecl GD,\n                                          llvm::GlobalObject *GO) {\n  const Decl *D = GD.getDecl();\n  SetCommonAttributes(GD, GO);\n\n  if (D) {\n    if (auto *GV = dyn_cast<llvm::GlobalVariable>(GO)) {\n      if (auto *SA = D->getAttr<PragmaClangBSSSectionAttr>())\n        GV->addAttribute(\"bss-section\", SA->getName());\n      if (auto *SA = D->getAttr<PragmaClangDataSectionAttr>())\n        GV->addAttribute(\"data-section\", SA->getName());\n      if (auto *SA = D->getAttr<PragmaClangRodataSectionAttr>())\n        GV->addAttribute(\"rodata-section\", SA->getName());\n      if (auto *SA = D->getAttr<PragmaClangRelroSectionAttr>())\n        GV->addAttribute(\"relro-section\", SA->getName());\n    }\n\n    if (auto *F = dyn_cast<llvm::Function>(GO)) {\n      if (auto *SA = D->getAttr<PragmaClangTextSectionAttr>())\n        if (!D->getAttr<SectionAttr>())\n          F->addFnAttr(\"implicit-section-name\", SA->getName());\n\n      llvm::AttrBuilder Attrs;\n      if (GetCPUAndFeaturesAttributes(GD, Attrs)) {\n        // We know that GetCPUAndFeaturesAttributes will always have the\n        // newest set, since it has the newest possible FunctionDecl, so the\n        // new ones should replace the old.\n        llvm::AttrBuilder RemoveAttrs;\n        RemoveAttrs.addAttribute(\"target-cpu\");\n        RemoveAttrs.addAttribute(\"target-features\");\n        RemoveAttrs.addAttribute(\"tune-cpu\");\n        F->removeAttributes(llvm::AttributeList::FunctionIndex, RemoveAttrs);\n        F->addAttributes(llvm::AttributeList::FunctionIndex, Attrs);\n      }\n    }\n\n    if (const auto *CSA = D->getAttr<CodeSegAttr>())\n      GO->setSection(CSA->getName());\n    else if (const auto *SA = D->getAttr<SectionAttr>())\n      GO->setSection(SA->getName());\n  }\n\n  getTargetCodeGenInfo().setTargetAttributes(D, GO, *this);\n}\n\nvoid CodeGenModule::SetInternalFunctionAttributes(GlobalDecl GD,\n                                                  llvm::Function *F,\n                                                  const CGFunctionInfo &FI) {\n  const Decl *D = GD.getDecl();\n  SetLLVMFunctionAttributes(GD, FI, F);\n  SetLLVMFunctionAttributesForDefinition(D, F);\n\n  F->setLinkage(llvm::Function::InternalLinkage);\n\n  setNonAliasAttributes(GD, F);\n}\n\nstatic void setLinkageForGV(llvm::GlobalValue *GV, const NamedDecl *ND) {\n  // Set linkage and visibility in case we never see a definition.\n  LinkageInfo LV = ND->getLinkageAndVisibility();\n  // Don't set internal linkage on declarations.\n  // \"extern_weak\" is overloaded in LLVM; we probably should have\n  // separate linkage types for this.\n  if (isExternallyVisible(LV.getLinkage()) &&\n      (ND->hasAttr<WeakAttr>() || ND->isWeakImported()))\n    GV->setLinkage(llvm::GlobalValue::ExternalWeakLinkage);\n}\n\nvoid CodeGenModule::CreateFunctionTypeMetadataForIcall(const FunctionDecl *FD,\n                                                       llvm::Function *F) {\n  // Only if we are checking indirect calls.\n  if (!LangOpts.Sanitize.has(SanitizerKind::CFIICall))\n    return;\n\n  // Non-static class methods are handled via vtable or member function pointer\n  // checks elsewhere.\n  if (isa<CXXMethodDecl>(FD) && !cast<CXXMethodDecl>(FD)->isStatic())\n    return;\n\n  llvm::Metadata *MD = CreateMetadataIdentifierForType(FD->getType());\n  F->addTypeMetadata(0, MD);\n  F->addTypeMetadata(0, CreateMetadataIdentifierGeneralized(FD->getType()));\n\n  // Emit a hash-based bit set entry for cross-DSO calls.\n  if (CodeGenOpts.SanitizeCfiCrossDso)\n    if (auto CrossDsoTypeId = CreateCrossDsoCfiTypeId(MD))\n      F->addTypeMetadata(0, llvm::ConstantAsMetadata::get(CrossDsoTypeId));\n}\n\nvoid CodeGenModule::SetFunctionAttributes(GlobalDecl GD, llvm::Function *F,\n                                          bool IsIncompleteFunction,\n                                          bool IsThunk) {\n\n  if (llvm::Intrinsic::ID IID = F->getIntrinsicID()) {\n    // If this is an intrinsic function, set the function's attributes\n    // to the intrinsic's attributes.\n    F->setAttributes(llvm::Intrinsic::getAttributes(getLLVMContext(), IID));\n    return;\n  }\n\n  const auto *FD = cast<FunctionDecl>(GD.getDecl());\n\n  if (!IsIncompleteFunction)\n    SetLLVMFunctionAttributes(GD, getTypes().arrangeGlobalDeclaration(GD), F);\n\n  // Add the Returned attribute for \"this\", except for iOS 5 and earlier\n  // where substantial code, including the libstdc++ dylib, was compiled with\n  // GCC and does not actually return \"this\".\n  if (!IsThunk && getCXXABI().HasThisReturn(GD) &&\n      !(getTriple().isiOS() && getTriple().isOSVersionLT(6))) {\n    assert(!F->arg_empty() &&\n           F->arg_begin()->getType()\n             ->canLosslesslyBitCastTo(F->getReturnType()) &&\n           \"unexpected this return\");\n    F->addAttribute(1, llvm::Attribute::Returned);\n  }\n\n  // Only a few attributes are set on declarations; these may later be\n  // overridden by a definition.\n\n  setLinkageForGV(F, FD);\n  setGVProperties(F, FD);\n\n  // Setup target-specific attributes.\n  if (!IsIncompleteFunction && F->isDeclaration())\n    getTargetCodeGenInfo().setTargetAttributes(FD, F, *this);\n\n  if (const auto *CSA = FD->getAttr<CodeSegAttr>())\n    F->setSection(CSA->getName());\n  else if (const auto *SA = FD->getAttr<SectionAttr>())\n     F->setSection(SA->getName());\n\n  // If we plan on emitting this inline builtin, we can't treat it as a builtin.\n  if (FD->isInlineBuiltinDeclaration()) {\n    const FunctionDecl *FDBody;\n    bool HasBody = FD->hasBody(FDBody);\n    (void)HasBody;\n    assert(HasBody && \"Inline builtin declarations should always have an \"\n                      \"available body!\");\n    if (shouldEmitFunction(FDBody))\n      F->addAttribute(llvm::AttributeList::FunctionIndex,\n                      llvm::Attribute::NoBuiltin);\n  }\n\n  if (FD->isReplaceableGlobalAllocationFunction()) {\n    // A replaceable global allocation function does not act like a builtin by\n    // default, only if it is invoked by a new-expression or delete-expression.\n    F->addAttribute(llvm::AttributeList::FunctionIndex,\n                    llvm::Attribute::NoBuiltin);\n  }\n\n  if (isa<CXXConstructorDecl>(FD) || isa<CXXDestructorDecl>(FD))\n    F->setUnnamedAddr(llvm::GlobalValue::UnnamedAddr::Global);\n  else if (const auto *MD = dyn_cast<CXXMethodDecl>(FD))\n    if (MD->isVirtual())\n      F->setUnnamedAddr(llvm::GlobalValue::UnnamedAddr::Global);\n\n  // Don't emit entries for function declarations in the cross-DSO mode. This\n  // is handled with better precision by the receiving DSO. But if jump tables\n  // are non-canonical then we need type metadata in order to produce the local\n  // jump table.\n  if (!CodeGenOpts.SanitizeCfiCrossDso ||\n      !CodeGenOpts.SanitizeCfiCanonicalJumpTables)\n    CreateFunctionTypeMetadataForIcall(FD, F);\n\n  if (getLangOpts().OpenMP && FD->hasAttr<OMPDeclareSimdDeclAttr>())\n    getOpenMPRuntime().emitDeclareSimdFunction(FD, F);\n\n  if (const auto *CB = FD->getAttr<CallbackAttr>()) {\n    // Annotate the callback behavior as metadata:\n    //  - The callback callee (as argument number).\n    //  - The callback payloads (as argument numbers).\n    llvm::LLVMContext &Ctx = F->getContext();\n    llvm::MDBuilder MDB(Ctx);\n\n    // The payload indices are all but the first one in the encoding. The first\n    // identifies the callback callee.\n    int CalleeIdx = *CB->encoding_begin();\n    ArrayRef<int> PayloadIndices(CB->encoding_begin() + 1, CB->encoding_end());\n    F->addMetadata(llvm::LLVMContext::MD_callback,\n                   *llvm::MDNode::get(Ctx, {MDB.createCallbackEncoding(\n                                               CalleeIdx, PayloadIndices,\n                                               /* VarArgsArePassed */ false)}));\n  }\n}\n\nvoid CodeGenModule::addUsedGlobal(llvm::GlobalValue *GV) {\n  assert((isa<llvm::Function>(GV) || !GV->isDeclaration()) &&\n         \"Only globals with definition can force usage.\");\n  LLVMUsed.emplace_back(GV);\n}\n\nvoid CodeGenModule::addCompilerUsedGlobal(llvm::GlobalValue *GV) {\n  assert(!GV->isDeclaration() &&\n         \"Only globals with definition can force usage.\");\n  LLVMCompilerUsed.emplace_back(GV);\n}\n\nstatic void emitUsed(CodeGenModule &CGM, StringRef Name,\n                     std::vector<llvm::WeakTrackingVH> &List) {\n  // Don't create llvm.used if there is no need.\n  if (List.empty())\n    return;\n\n  // Convert List to what ConstantArray needs.\n  SmallVector<llvm::Constant*, 8> UsedArray;\n  UsedArray.resize(List.size());\n  for (unsigned i = 0, e = List.size(); i != e; ++i) {\n    UsedArray[i] =\n        llvm::ConstantExpr::getPointerBitCastOrAddrSpaceCast(\n            cast<llvm::Constant>(&*List[i]), CGM.Int8PtrTy);\n  }\n\n  if (UsedArray.empty())\n    return;\n  llvm::ArrayType *ATy = llvm::ArrayType::get(CGM.Int8PtrTy, UsedArray.size());\n\n  auto *GV = new llvm::GlobalVariable(\n      CGM.getModule(), ATy, false, llvm::GlobalValue::AppendingLinkage,\n      llvm::ConstantArray::get(ATy, UsedArray), Name);\n\n  GV->setSection(\"llvm.metadata\");\n}\n\nvoid CodeGenModule::emitLLVMUsed() {\n  emitUsed(*this, \"llvm.used\", LLVMUsed);\n  emitUsed(*this, \"llvm.compiler.used\", LLVMCompilerUsed);\n}\n\nvoid CodeGenModule::AppendLinkerOptions(StringRef Opts) {\n  auto *MDOpts = llvm::MDString::get(getLLVMContext(), Opts);\n  LinkerOptionsMetadata.push_back(llvm::MDNode::get(getLLVMContext(), MDOpts));\n}\n\nvoid CodeGenModule::AddDetectMismatch(StringRef Name, StringRef Value) {\n  llvm::SmallString<32> Opt;\n  getTargetCodeGenInfo().getDetectMismatchOption(Name, Value, Opt);\n  if (Opt.empty())\n    return;\n  auto *MDOpts = llvm::MDString::get(getLLVMContext(), Opt);\n  LinkerOptionsMetadata.push_back(llvm::MDNode::get(getLLVMContext(), MDOpts));\n}\n\nvoid CodeGenModule::AddDependentLib(StringRef Lib) {\n  auto &C = getLLVMContext();\n  if (getTarget().getTriple().isOSBinFormatELF()) {\n      ELFDependentLibraries.push_back(\n        llvm::MDNode::get(C, llvm::MDString::get(C, Lib)));\n    return;\n  }\n\n  llvm::SmallString<24> Opt;\n  getTargetCodeGenInfo().getDependentLibraryOption(Lib, Opt);\n  auto *MDOpts = llvm::MDString::get(getLLVMContext(), Opt);\n  LinkerOptionsMetadata.push_back(llvm::MDNode::get(C, MDOpts));\n}\n\n/// Add link options implied by the given module, including modules\n/// it depends on, using a postorder walk.\nstatic void addLinkOptionsPostorder(CodeGenModule &CGM, Module *Mod,\n                                    SmallVectorImpl<llvm::MDNode *> &Metadata,\n                                    llvm::SmallPtrSet<Module *, 16> &Visited) {\n  // Import this module's parent.\n  if (Mod->Parent && Visited.insert(Mod->Parent).second) {\n    addLinkOptionsPostorder(CGM, Mod->Parent, Metadata, Visited);\n  }\n\n  // Import this module's dependencies.\n  for (unsigned I = Mod->Imports.size(); I > 0; --I) {\n    if (Visited.insert(Mod->Imports[I - 1]).second)\n      addLinkOptionsPostorder(CGM, Mod->Imports[I-1], Metadata, Visited);\n  }\n\n  // Add linker options to link against the libraries/frameworks\n  // described by this module.\n  llvm::LLVMContext &Context = CGM.getLLVMContext();\n  bool IsELF = CGM.getTarget().getTriple().isOSBinFormatELF();\n\n  // For modules that use export_as for linking, use that module\n  // name instead.\n  if (Mod->UseExportAsModuleLinkName)\n    return;\n\n  for (unsigned I = Mod->LinkLibraries.size(); I > 0; --I) {\n    // Link against a framework.  Frameworks are currently Darwin only, so we\n    // don't to ask TargetCodeGenInfo for the spelling of the linker option.\n    if (Mod->LinkLibraries[I-1].IsFramework) {\n      llvm::Metadata *Args[2] = {\n          llvm::MDString::get(Context, \"-framework\"),\n          llvm::MDString::get(Context, Mod->LinkLibraries[I - 1].Library)};\n\n      Metadata.push_back(llvm::MDNode::get(Context, Args));\n      continue;\n    }\n\n    // Link against a library.\n    if (IsELF) {\n      llvm::Metadata *Args[2] = {\n          llvm::MDString::get(Context, \"lib\"),\n          llvm::MDString::get(Context, Mod->LinkLibraries[I - 1].Library),\n      };\n      Metadata.push_back(llvm::MDNode::get(Context, Args));\n    } else {\n      llvm::SmallString<24> Opt;\n      CGM.getTargetCodeGenInfo().getDependentLibraryOption(\n          Mod->LinkLibraries[I - 1].Library, Opt);\n      auto *OptString = llvm::MDString::get(Context, Opt);\n      Metadata.push_back(llvm::MDNode::get(Context, OptString));\n    }\n  }\n}\n\nvoid CodeGenModule::EmitModuleLinkOptions() {\n  // Collect the set of all of the modules we want to visit to emit link\n  // options, which is essentially the imported modules and all of their\n  // non-explicit child modules.\n  llvm::SetVector<clang::Module *> LinkModules;\n  llvm::SmallPtrSet<clang::Module *, 16> Visited;\n  SmallVector<clang::Module *, 16> Stack;\n\n  // Seed the stack with imported modules.\n  for (Module *M : ImportedModules) {\n    // Do not add any link flags when an implementation TU of a module imports\n    // a header of that same module.\n    if (M->getTopLevelModuleName() == getLangOpts().CurrentModule &&\n        !getLangOpts().isCompilingModule())\n      continue;\n    if (Visited.insert(M).second)\n      Stack.push_back(M);\n  }\n\n  // Find all of the modules to import, making a little effort to prune\n  // non-leaf modules.\n  while (!Stack.empty()) {\n    clang::Module *Mod = Stack.pop_back_val();\n\n    bool AnyChildren = false;\n\n    // Visit the submodules of this module.\n    for (const auto &SM : Mod->submodules()) {\n      // Skip explicit children; they need to be explicitly imported to be\n      // linked against.\n      if (SM->IsExplicit)\n        continue;\n\n      if (Visited.insert(SM).second) {\n        Stack.push_back(SM);\n        AnyChildren = true;\n      }\n    }\n\n    // We didn't find any children, so add this module to the list of\n    // modules to link against.\n    if (!AnyChildren) {\n      LinkModules.insert(Mod);\n    }\n  }\n\n  // Add link options for all of the imported modules in reverse topological\n  // order.  We don't do anything to try to order import link flags with respect\n  // to linker options inserted by things like #pragma comment().\n  SmallVector<llvm::MDNode *, 16> MetadataArgs;\n  Visited.clear();\n  for (Module *M : LinkModules)\n    if (Visited.insert(M).second)\n      addLinkOptionsPostorder(*this, M, MetadataArgs, Visited);\n  std::reverse(MetadataArgs.begin(), MetadataArgs.end());\n  LinkerOptionsMetadata.append(MetadataArgs.begin(), MetadataArgs.end());\n\n  // Add the linker options metadata flag.\n  auto *NMD = getModule().getOrInsertNamedMetadata(\"llvm.linker.options\");\n  for (auto *MD : LinkerOptionsMetadata)\n    NMD->addOperand(MD);\n}\n\nvoid CodeGenModule::EmitDeferred() {\n  // Emit deferred declare target declarations.\n  if (getLangOpts().OpenMP && !getLangOpts().OpenMPSimd)\n    getOpenMPRuntime().emitDeferredTargetDecls();\n\n  // Emit code for any potentially referenced deferred decls.  Since a\n  // previously unused static decl may become used during the generation of code\n  // for a static function, iterate until no changes are made.\n\n  if (!DeferredVTables.empty()) {\n    EmitDeferredVTables();\n\n    // Emitting a vtable doesn't directly cause more vtables to\n    // become deferred, although it can cause functions to be\n    // emitted that then need those vtables.\n    assert(DeferredVTables.empty());\n  }\n\n  // Emit CUDA/HIP static device variables referenced by host code only.\n  if (getLangOpts().CUDA)\n    for (auto V : getContext().CUDAStaticDeviceVarReferencedByHost)\n      DeferredDeclsToEmit.push_back(V);\n\n  // Stop if we're out of both deferred vtables and deferred declarations.\n  if (DeferredDeclsToEmit.empty())\n    return;\n\n  // Grab the list of decls to emit. If EmitGlobalDefinition schedules more\n  // work, it will not interfere with this.\n  std::vector<GlobalDecl> CurDeclsToEmit;\n  CurDeclsToEmit.swap(DeferredDeclsToEmit);\n\n  for (GlobalDecl &D : CurDeclsToEmit) {\n    // We should call GetAddrOfGlobal with IsForDefinition set to true in order\n    // to get GlobalValue with exactly the type we need, not something that\n    // might had been created for another decl with the same mangled name but\n    // different type.\n    llvm::GlobalValue *GV = dyn_cast<llvm::GlobalValue>(\n        GetAddrOfGlobal(D, ForDefinition));\n\n    // In case of different address spaces, we may still get a cast, even with\n    // IsForDefinition equal to true. Query mangled names table to get\n    // GlobalValue.\n    if (!GV)\n      GV = GetGlobalValue(getMangledName(D));\n\n    // Make sure GetGlobalValue returned non-null.\n    assert(GV);\n\n    // Check to see if we've already emitted this.  This is necessary\n    // for a couple of reasons: first, decls can end up in the\n    // deferred-decls queue multiple times, and second, decls can end\n    // up with definitions in unusual ways (e.g. by an extern inline\n    // function acquiring a strong function redefinition).  Just\n    // ignore these cases.\n    if (!GV->isDeclaration())\n      continue;\n\n    // If this is OpenMP, check if it is legal to emit this global normally.\n    if (LangOpts.OpenMP && OpenMPRuntime && OpenMPRuntime->emitTargetGlobal(D))\n      continue;\n\n    // Otherwise, emit the definition and move on to the next one.\n    EmitGlobalDefinition(D, GV);\n\n    // If we found out that we need to emit more decls, do that recursively.\n    // This has the advantage that the decls are emitted in a DFS and related\n    // ones are close together, which is convenient for testing.\n    if (!DeferredVTables.empty() || !DeferredDeclsToEmit.empty()) {\n      EmitDeferred();\n      assert(DeferredVTables.empty() && DeferredDeclsToEmit.empty());\n    }\n  }\n}\n\nvoid CodeGenModule::EmitVTablesOpportunistically() {\n  // Try to emit external vtables as available_externally if they have emitted\n  // all inlined virtual functions.  It runs after EmitDeferred() and therefore\n  // is not allowed to create new references to things that need to be emitted\n  // lazily. Note that it also uses fact that we eagerly emitting RTTI.\n\n  assert((OpportunisticVTables.empty() || shouldOpportunisticallyEmitVTables())\n         && \"Only emit opportunistic vtables with optimizations\");\n\n  for (const CXXRecordDecl *RD : OpportunisticVTables) {\n    assert(getVTables().isVTableExternal(RD) &&\n           \"This queue should only contain external vtables\");\n    if (getCXXABI().canSpeculativelyEmitVTable(RD))\n      VTables.GenerateClassData(RD);\n  }\n  OpportunisticVTables.clear();\n}\n\nvoid CodeGenModule::EmitGlobalAnnotations() {\n  if (Annotations.empty())\n    return;\n\n  // Create a new global variable for the ConstantStruct in the Module.\n  llvm::Constant *Array = llvm::ConstantArray::get(llvm::ArrayType::get(\n    Annotations[0]->getType(), Annotations.size()), Annotations);\n  auto *gv = new llvm::GlobalVariable(getModule(), Array->getType(), false,\n                                      llvm::GlobalValue::AppendingLinkage,\n                                      Array, \"llvm.global.annotations\");\n  gv->setSection(AnnotationSection);\n}\n\nllvm::Constant *CodeGenModule::EmitAnnotationString(StringRef Str) {\n  llvm::Constant *&AStr = AnnotationStrings[Str];\n  if (AStr)\n    return AStr;\n\n  // Not found yet, create a new global.\n  llvm::Constant *s = llvm::ConstantDataArray::getString(getLLVMContext(), Str);\n  auto *gv =\n      new llvm::GlobalVariable(getModule(), s->getType(), true,\n                               llvm::GlobalValue::PrivateLinkage, s, \".str\");\n  gv->setSection(AnnotationSection);\n  gv->setUnnamedAddr(llvm::GlobalValue::UnnamedAddr::Global);\n  AStr = gv;\n  return gv;\n}\n\nllvm::Constant *CodeGenModule::EmitAnnotationUnit(SourceLocation Loc) {\n  SourceManager &SM = getContext().getSourceManager();\n  PresumedLoc PLoc = SM.getPresumedLoc(Loc);\n  if (PLoc.isValid())\n    return EmitAnnotationString(PLoc.getFilename());\n  return EmitAnnotationString(SM.getBufferName(Loc));\n}\n\nllvm::Constant *CodeGenModule::EmitAnnotationLineNo(SourceLocation L) {\n  SourceManager &SM = getContext().getSourceManager();\n  PresumedLoc PLoc = SM.getPresumedLoc(L);\n  unsigned LineNo = PLoc.isValid() ? PLoc.getLine() :\n    SM.getExpansionLineNumber(L);\n  return llvm::ConstantInt::get(Int32Ty, LineNo);\n}\n\nllvm::Constant *CodeGenModule::EmitAnnotationArgs(const AnnotateAttr *Attr) {\n  ArrayRef<Expr *> Exprs = {Attr->args_begin(), Attr->args_size()};\n  if (Exprs.empty())\n    return llvm::ConstantPointerNull::get(Int8PtrTy);\n\n  llvm::FoldingSetNodeID ID;\n  for (Expr *E : Exprs) {\n    ID.Add(cast<clang::ConstantExpr>(E)->getAPValueResult());\n  }\n  llvm::Constant *&Lookup = AnnotationArgs[ID.ComputeHash()];\n  if (Lookup)\n    return Lookup;\n\n  llvm::SmallVector<llvm::Constant *, 4> LLVMArgs;\n  LLVMArgs.reserve(Exprs.size());\n  ConstantEmitter ConstEmiter(*this);\n  llvm::transform(Exprs, std::back_inserter(LLVMArgs), [&](const Expr *E) {\n    const auto *CE = cast<clang::ConstantExpr>(E);\n    return ConstEmiter.emitAbstract(CE->getBeginLoc(), CE->getAPValueResult(),\n                                    CE->getType());\n  });\n  auto *Struct = llvm::ConstantStruct::getAnon(LLVMArgs);\n  auto *GV = new llvm::GlobalVariable(getModule(), Struct->getType(), true,\n                                      llvm::GlobalValue::PrivateLinkage, Struct,\n                                      \".args\");\n  GV->setSection(AnnotationSection);\n  GV->setUnnamedAddr(llvm::GlobalValue::UnnamedAddr::Global);\n  auto *Bitcasted = llvm::ConstantExpr::getBitCast(GV, Int8PtrTy);\n\n  Lookup = Bitcasted;\n  return Bitcasted;\n}\n\nllvm::Constant *CodeGenModule::EmitAnnotateAttr(llvm::GlobalValue *GV,\n                                                const AnnotateAttr *AA,\n                                                SourceLocation L) {\n  // Get the globals for file name, annotation, and the line number.\n  llvm::Constant *AnnoGV = EmitAnnotationString(AA->getAnnotation()),\n                 *UnitGV = EmitAnnotationUnit(L),\n                 *LineNoCst = EmitAnnotationLineNo(L),\n                 *Args = EmitAnnotationArgs(AA);\n\n  llvm::Constant *ASZeroGV = GV;\n  if (GV->getAddressSpace() != 0) {\n    ASZeroGV = llvm::ConstantExpr::getAddrSpaceCast(\n                   GV, GV->getValueType()->getPointerTo(0));\n  }\n\n  // Create the ConstantStruct for the global annotation.\n  llvm::Constant *Fields[] = {\n      llvm::ConstantExpr::getBitCast(ASZeroGV, Int8PtrTy),\n      llvm::ConstantExpr::getBitCast(AnnoGV, Int8PtrTy),\n      llvm::ConstantExpr::getBitCast(UnitGV, Int8PtrTy),\n      LineNoCst,\n      Args,\n  };\n  return llvm::ConstantStruct::getAnon(Fields);\n}\n\nvoid CodeGenModule::AddGlobalAnnotations(const ValueDecl *D,\n                                         llvm::GlobalValue *GV) {\n  assert(D->hasAttr<AnnotateAttr>() && \"no annotate attribute\");\n  // Get the struct elements for these annotations.\n  for (const auto *I : D->specific_attrs<AnnotateAttr>())\n    Annotations.push_back(EmitAnnotateAttr(GV, I, D->getLocation()));\n}\n\nbool CodeGenModule::isInSanitizerBlacklist(SanitizerMask Kind,\n                                           llvm::Function *Fn,\n                                           SourceLocation Loc) const {\n  const auto &SanitizerBL = getContext().getSanitizerBlacklist();\n  // Blacklist by function name.\n  if (SanitizerBL.isBlacklistedFunction(Kind, Fn->getName()))\n    return true;\n  // Blacklist by location.\n  if (Loc.isValid())\n    return SanitizerBL.isBlacklistedLocation(Kind, Loc);\n  // If location is unknown, this may be a compiler-generated function. Assume\n  // it's located in the main file.\n  auto &SM = Context.getSourceManager();\n  if (const auto *MainFile = SM.getFileEntryForID(SM.getMainFileID())) {\n    return SanitizerBL.isBlacklistedFile(Kind, MainFile->getName());\n  }\n  return false;\n}\n\nbool CodeGenModule::isInSanitizerBlacklist(llvm::GlobalVariable *GV,\n                                           SourceLocation Loc, QualType Ty,\n                                           StringRef Category) const {\n  // For now globals can be blacklisted only in ASan and KASan.\n  const SanitizerMask EnabledAsanMask =\n      LangOpts.Sanitize.Mask &\n      (SanitizerKind::Address | SanitizerKind::KernelAddress |\n       SanitizerKind::HWAddress | SanitizerKind::KernelHWAddress |\n       SanitizerKind::MemTag);\n  if (!EnabledAsanMask)\n    return false;\n  const auto &SanitizerBL = getContext().getSanitizerBlacklist();\n  if (SanitizerBL.isBlacklistedGlobal(EnabledAsanMask, GV->getName(), Category))\n    return true;\n  if (SanitizerBL.isBlacklistedLocation(EnabledAsanMask, Loc, Category))\n    return true;\n  // Check global type.\n  if (!Ty.isNull()) {\n    // Drill down the array types: if global variable of a fixed type is\n    // blacklisted, we also don't instrument arrays of them.\n    while (auto AT = dyn_cast<ArrayType>(Ty.getTypePtr()))\n      Ty = AT->getElementType();\n    Ty = Ty.getCanonicalType().getUnqualifiedType();\n    // We allow to blacklist only record types (classes, structs etc.)\n    if (Ty->isRecordType()) {\n      std::string TypeStr = Ty.getAsString(getContext().getPrintingPolicy());\n      if (SanitizerBL.isBlacklistedType(EnabledAsanMask, TypeStr, Category))\n        return true;\n    }\n  }\n  return false;\n}\n\nbool CodeGenModule::imbueXRayAttrs(llvm::Function *Fn, SourceLocation Loc,\n                                   StringRef Category) const {\n  const auto &XRayFilter = getContext().getXRayFilter();\n  using ImbueAttr = XRayFunctionFilter::ImbueAttribute;\n  auto Attr = ImbueAttr::NONE;\n  if (Loc.isValid())\n    Attr = XRayFilter.shouldImbueLocation(Loc, Category);\n  if (Attr == ImbueAttr::NONE)\n    Attr = XRayFilter.shouldImbueFunction(Fn->getName());\n  switch (Attr) {\n  case ImbueAttr::NONE:\n    return false;\n  case ImbueAttr::ALWAYS:\n    Fn->addFnAttr(\"function-instrument\", \"xray-always\");\n    break;\n  case ImbueAttr::ALWAYS_ARG1:\n    Fn->addFnAttr(\"function-instrument\", \"xray-always\");\n    Fn->addFnAttr(\"xray-log-args\", \"1\");\n    break;\n  case ImbueAttr::NEVER:\n    Fn->addFnAttr(\"function-instrument\", \"xray-never\");\n    break;\n  }\n  return true;\n}\n\nbool CodeGenModule::isProfileInstrExcluded(llvm::Function *Fn,\n                                           SourceLocation Loc) const {\n  const auto &ProfileList = getContext().getProfileList();\n  // If the profile list is empty, then instrument everything.\n  if (ProfileList.isEmpty())\n    return false;\n  CodeGenOptions::ProfileInstrKind Kind = getCodeGenOpts().getProfileInstr();\n  // First, check the function name.\n  Optional<bool> V = ProfileList.isFunctionExcluded(Fn->getName(), Kind);\n  if (V.hasValue())\n    return *V;\n  // Next, check the source location.\n  if (Loc.isValid()) {\n    Optional<bool> V = ProfileList.isLocationExcluded(Loc, Kind);\n    if (V.hasValue())\n      return *V;\n  }\n  // If location is unknown, this may be a compiler-generated function. Assume\n  // it's located in the main file.\n  auto &SM = Context.getSourceManager();\n  if (const auto *MainFile = SM.getFileEntryForID(SM.getMainFileID())) {\n    Optional<bool> V = ProfileList.isFileExcluded(MainFile->getName(), Kind);\n    if (V.hasValue())\n      return *V;\n  }\n  return ProfileList.getDefault();\n}\n\nbool CodeGenModule::MustBeEmitted(const ValueDecl *Global) {\n  // Never defer when EmitAllDecls is specified.\n  if (LangOpts.EmitAllDecls)\n    return true;\n\n  if (CodeGenOpts.KeepStaticConsts) {\n    const auto *VD = dyn_cast<VarDecl>(Global);\n    if (VD && VD->getType().isConstQualified() &&\n        VD->getStorageDuration() == SD_Static)\n      return true;\n  }\n\n  return getContext().DeclMustBeEmitted(Global);\n}\n\nbool CodeGenModule::MayBeEmittedEagerly(const ValueDecl *Global) {\n  if (const auto *FD = dyn_cast<FunctionDecl>(Global)) {\n    if (FD->getTemplateSpecializationKind() == TSK_ImplicitInstantiation)\n      // Implicit template instantiations may change linkage if they are later\n      // explicitly instantiated, so they should not be emitted eagerly.\n      return false;\n    // In OpenMP 5.0 function may be marked as device_type(nohost) and we should\n    // not emit them eagerly unless we sure that the function must be emitted on\n    // the host.\n    if (LangOpts.OpenMP >= 50 && !LangOpts.OpenMPSimd &&\n        !LangOpts.OpenMPIsDevice &&\n        !OMPDeclareTargetDeclAttr::getDeviceType(FD) &&\n        !FD->isUsed(/*CheckUsedAttr=*/false) && !FD->isReferenced())\n      return false;\n  }\n  if (const auto *VD = dyn_cast<VarDecl>(Global))\n    if (Context.getInlineVariableDefinitionKind(VD) ==\n        ASTContext::InlineVariableDefinitionKind::WeakUnknown)\n      // A definition of an inline constexpr static data member may change\n      // linkage later if it's redeclared outside the class.\n      return false;\n  // If OpenMP is enabled and threadprivates must be generated like TLS, delay\n  // codegen for global variables, because they may be marked as threadprivate.\n  if (LangOpts.OpenMP && LangOpts.OpenMPUseTLS &&\n      getContext().getTargetInfo().isTLSSupported() && isa<VarDecl>(Global) &&\n      !isTypeConstant(Global->getType(), false) &&\n      !OMPDeclareTargetDeclAttr::isDeclareTargetDeclaration(Global))\n    return false;\n\n  return true;\n}\n\nConstantAddress CodeGenModule::GetAddrOfMSGuidDecl(const MSGuidDecl *GD) {\n  StringRef Name = getMangledName(GD);\n\n  // The UUID descriptor should be pointer aligned.\n  CharUnits Alignment = CharUnits::fromQuantity(PointerAlignInBytes);\n\n  // Look for an existing global.\n  if (llvm::GlobalVariable *GV = getModule().getNamedGlobal(Name))\n    return ConstantAddress(GV, Alignment);\n\n  ConstantEmitter Emitter(*this);\n  llvm::Constant *Init;\n\n  APValue &V = GD->getAsAPValue();\n  if (!V.isAbsent()) {\n    // If possible, emit the APValue version of the initializer. In particular,\n    // this gets the type of the constant right.\n    Init = Emitter.emitForInitializer(\n        GD->getAsAPValue(), GD->getType().getAddressSpace(), GD->getType());\n  } else {\n    // As a fallback, directly construct the constant.\n    // FIXME: This may get padding wrong under esoteric struct layout rules.\n    // MSVC appears to create a complete type 'struct __s_GUID' that it\n    // presumably uses to represent these constants.\n    MSGuidDecl::Parts Parts = GD->getParts();\n    llvm::Constant *Fields[4] = {\n        llvm::ConstantInt::get(Int32Ty, Parts.Part1),\n        llvm::ConstantInt::get(Int16Ty, Parts.Part2),\n        llvm::ConstantInt::get(Int16Ty, Parts.Part3),\n        llvm::ConstantDataArray::getRaw(\n            StringRef(reinterpret_cast<char *>(Parts.Part4And5), 8), 8,\n            Int8Ty)};\n    Init = llvm::ConstantStruct::getAnon(Fields);\n  }\n\n  auto *GV = new llvm::GlobalVariable(\n      getModule(), Init->getType(),\n      /*isConstant=*/true, llvm::GlobalValue::LinkOnceODRLinkage, Init, Name);\n  if (supportsCOMDAT())\n    GV->setComdat(TheModule.getOrInsertComdat(GV->getName()));\n  setDSOLocal(GV);\n\n  llvm::Constant *Addr = GV;\n  if (!V.isAbsent()) {\n    Emitter.finalize(GV);\n  } else {\n    llvm::Type *Ty = getTypes().ConvertTypeForMem(GD->getType());\n    Addr = llvm::ConstantExpr::getBitCast(\n        GV, Ty->getPointerTo(GV->getAddressSpace()));\n  }\n  return ConstantAddress(Addr, Alignment);\n}\n\nConstantAddress CodeGenModule::GetAddrOfTemplateParamObject(\n    const TemplateParamObjectDecl *TPO) {\n  StringRef Name = getMangledName(TPO);\n  CharUnits Alignment = getNaturalTypeAlignment(TPO->getType());\n\n  if (llvm::GlobalVariable *GV = getModule().getNamedGlobal(Name))\n    return ConstantAddress(GV, Alignment);\n\n  ConstantEmitter Emitter(*this);\n  llvm::Constant *Init = Emitter.emitForInitializer(\n        TPO->getValue(), TPO->getType().getAddressSpace(), TPO->getType());\n\n  if (!Init) {\n    ErrorUnsupported(TPO, \"template parameter object\");\n    return ConstantAddress::invalid();\n  }\n\n  auto *GV = new llvm::GlobalVariable(\n      getModule(), Init->getType(),\n      /*isConstant=*/true, llvm::GlobalValue::LinkOnceODRLinkage, Init, Name);\n  if (supportsCOMDAT())\n    GV->setComdat(TheModule.getOrInsertComdat(GV->getName()));\n  Emitter.finalize(GV);\n\n  return ConstantAddress(GV, Alignment);\n}\n\nConstantAddress CodeGenModule::GetWeakRefReference(const ValueDecl *VD) {\n  const AliasAttr *AA = VD->getAttr<AliasAttr>();\n  assert(AA && \"No alias?\");\n\n  CharUnits Alignment = getContext().getDeclAlign(VD);\n  llvm::Type *DeclTy = getTypes().ConvertTypeForMem(VD->getType());\n\n  // See if there is already something with the target's name in the module.\n  llvm::GlobalValue *Entry = GetGlobalValue(AA->getAliasee());\n  if (Entry) {\n    unsigned AS = getContext().getTargetAddressSpace(VD->getType());\n    auto Ptr = llvm::ConstantExpr::getBitCast(Entry, DeclTy->getPointerTo(AS));\n    return ConstantAddress(Ptr, Alignment);\n  }\n\n  llvm::Constant *Aliasee;\n  if (isa<llvm::FunctionType>(DeclTy))\n    Aliasee = GetOrCreateLLVMFunction(AA->getAliasee(), DeclTy,\n                                      GlobalDecl(cast<FunctionDecl>(VD)),\n                                      /*ForVTable=*/false);\n  else\n    Aliasee = GetOrCreateLLVMGlobal(AA->getAliasee(),\n                                    llvm::PointerType::getUnqual(DeclTy),\n                                    nullptr);\n\n  auto *F = cast<llvm::GlobalValue>(Aliasee);\n  F->setLinkage(llvm::Function::ExternalWeakLinkage);\n  WeakRefReferences.insert(F);\n\n  return ConstantAddress(Aliasee, Alignment);\n}\n\nvoid CodeGenModule::EmitGlobal(GlobalDecl GD) {\n  const auto *Global = cast<ValueDecl>(GD.getDecl());\n\n  // Weak references don't produce any output by themselves.\n  if (Global->hasAttr<WeakRefAttr>())\n    return;\n\n  // If this is an alias definition (which otherwise looks like a declaration)\n  // emit it now.\n  if (Global->hasAttr<AliasAttr>())\n    return EmitAliasDefinition(GD);\n\n  // IFunc like an alias whose value is resolved at runtime by calling resolver.\n  if (Global->hasAttr<IFuncAttr>())\n    return emitIFuncDefinition(GD);\n\n  // If this is a cpu_dispatch multiversion function, emit the resolver.\n  if (Global->hasAttr<CPUDispatchAttr>())\n    return emitCPUDispatchDefinition(GD);\n\n  // If this is CUDA, be selective about which declarations we emit.\n  if (LangOpts.CUDA) {\n    if (LangOpts.CUDAIsDevice) {\n      if (!Global->hasAttr<CUDADeviceAttr>() &&\n          !Global->hasAttr<CUDAGlobalAttr>() &&\n          !Global->hasAttr<CUDAConstantAttr>() &&\n          !Global->hasAttr<CUDASharedAttr>() &&\n          !Global->getType()->isCUDADeviceBuiltinSurfaceType() &&\n          !Global->getType()->isCUDADeviceBuiltinTextureType())\n        return;\n    } else {\n      // We need to emit host-side 'shadows' for all global\n      // device-side variables because the CUDA runtime needs their\n      // size and host-side address in order to provide access to\n      // their device-side incarnations.\n\n      // So device-only functions are the only things we skip.\n      if (isa<FunctionDecl>(Global) && !Global->hasAttr<CUDAHostAttr>() &&\n          Global->hasAttr<CUDADeviceAttr>())\n        return;\n\n      assert((isa<FunctionDecl>(Global) || isa<VarDecl>(Global)) &&\n             \"Expected Variable or Function\");\n    }\n  }\n\n  if (LangOpts.OpenMP) {\n    // If this is OpenMP, check if it is legal to emit this global normally.\n    if (OpenMPRuntime && OpenMPRuntime->emitTargetGlobal(GD))\n      return;\n    if (auto *DRD = dyn_cast<OMPDeclareReductionDecl>(Global)) {\n      if (MustBeEmitted(Global))\n        EmitOMPDeclareReduction(DRD);\n      return;\n    } else if (auto *DMD = dyn_cast<OMPDeclareMapperDecl>(Global)) {\n      if (MustBeEmitted(Global))\n        EmitOMPDeclareMapper(DMD);\n      return;\n    }\n  }\n\n  // Ignore declarations, they will be emitted on their first use.\n  if (const auto *FD = dyn_cast<FunctionDecl>(Global)) {\n    // Forward declarations are emitted lazily on first use.\n    if (!FD->doesThisDeclarationHaveABody()) {\n      if (!FD->doesDeclarationForceExternallyVisibleDefinition())\n        return;\n\n      StringRef MangledName = getMangledName(GD);\n\n      // Compute the function info and LLVM type.\n      const CGFunctionInfo &FI = getTypes().arrangeGlobalDeclaration(GD);\n      llvm::Type *Ty = getTypes().GetFunctionType(FI);\n\n      GetOrCreateLLVMFunction(MangledName, Ty, GD, /*ForVTable=*/false,\n                              /*DontDefer=*/false);\n      return;\n    }\n  } else {\n    const auto *VD = cast<VarDecl>(Global);\n    assert(VD->isFileVarDecl() && \"Cannot emit local var decl as global.\");\n    if (VD->isThisDeclarationADefinition() != VarDecl::Definition &&\n        !Context.isMSStaticDataMemberInlineDefinition(VD)) {\n      if (LangOpts.OpenMP) {\n        // Emit declaration of the must-be-emitted declare target variable.\n        if (llvm::Optional<OMPDeclareTargetDeclAttr::MapTypeTy> Res =\n                OMPDeclareTargetDeclAttr::isDeclareTargetDeclaration(VD)) {\n          bool UnifiedMemoryEnabled =\n              getOpenMPRuntime().hasRequiresUnifiedSharedMemory();\n          if (*Res == OMPDeclareTargetDeclAttr::MT_To &&\n              !UnifiedMemoryEnabled) {\n            (void)GetAddrOfGlobalVar(VD);\n          } else {\n            assert(((*Res == OMPDeclareTargetDeclAttr::MT_Link) ||\n                    (*Res == OMPDeclareTargetDeclAttr::MT_To &&\n                     UnifiedMemoryEnabled)) &&\n                   \"Link clause or to clause with unified memory expected.\");\n            (void)getOpenMPRuntime().getAddrOfDeclareTargetVar(VD);\n          }\n\n          return;\n        }\n      }\n      // If this declaration may have caused an inline variable definition to\n      // change linkage, make sure that it's emitted.\n      if (Context.getInlineVariableDefinitionKind(VD) ==\n          ASTContext::InlineVariableDefinitionKind::Strong)\n        GetAddrOfGlobalVar(VD);\n      return;\n    }\n  }\n\n  // Defer code generation to first use when possible, e.g. if this is an inline\n  // function. If the global must always be emitted, do it eagerly if possible\n  // to benefit from cache locality.\n  if (MustBeEmitted(Global) && MayBeEmittedEagerly(Global)) {\n    // Emit the definition if it can't be deferred.\n    EmitGlobalDefinition(GD);\n    return;\n  }\n\n  // If we're deferring emission of a C++ variable with an\n  // initializer, remember the order in which it appeared in the file.\n  if (getLangOpts().CPlusPlus && isa<VarDecl>(Global) &&\n      cast<VarDecl>(Global)->hasInit()) {\n    DelayedCXXInitPosition[Global] = CXXGlobalInits.size();\n    CXXGlobalInits.push_back(nullptr);\n  }\n\n  StringRef MangledName = getMangledName(GD);\n  if (GetGlobalValue(MangledName) != nullptr) {\n    // The value has already been used and should therefore be emitted.\n    addDeferredDeclToEmit(GD);\n  } else if (MustBeEmitted(Global)) {\n    // The value must be emitted, but cannot be emitted eagerly.\n    assert(!MayBeEmittedEagerly(Global));\n    addDeferredDeclToEmit(GD);\n  } else {\n    // Otherwise, remember that we saw a deferred decl with this name.  The\n    // first use of the mangled name will cause it to move into\n    // DeferredDeclsToEmit.\n    DeferredDecls[MangledName] = GD;\n  }\n}\n\n// Check if T is a class type with a destructor that's not dllimport.\nstatic bool HasNonDllImportDtor(QualType T) {\n  if (const auto *RT = T->getBaseElementTypeUnsafe()->getAs<RecordType>())\n    if (CXXRecordDecl *RD = dyn_cast<CXXRecordDecl>(RT->getDecl()))\n      if (RD->getDestructor() && !RD->getDestructor()->hasAttr<DLLImportAttr>())\n        return true;\n\n  return false;\n}\n\nnamespace {\n  struct FunctionIsDirectlyRecursive\n      : public ConstStmtVisitor<FunctionIsDirectlyRecursive, bool> {\n    const StringRef Name;\n    const Builtin::Context &BI;\n    FunctionIsDirectlyRecursive(StringRef N, const Builtin::Context &C)\n        : Name(N), BI(C) {}\n\n    bool VisitCallExpr(const CallExpr *E) {\n      const FunctionDecl *FD = E->getDirectCallee();\n      if (!FD)\n        return false;\n      AsmLabelAttr *Attr = FD->getAttr<AsmLabelAttr>();\n      if (Attr && Name == Attr->getLabel())\n        return true;\n      unsigned BuiltinID = FD->getBuiltinID();\n      if (!BuiltinID || !BI.isLibFunction(BuiltinID))\n        return false;\n      StringRef BuiltinName = BI.getName(BuiltinID);\n      if (BuiltinName.startswith(\"__builtin_\") &&\n          Name == BuiltinName.slice(strlen(\"__builtin_\"), StringRef::npos)) {\n        return true;\n      }\n      return false;\n    }\n\n    bool VisitStmt(const Stmt *S) {\n      for (const Stmt *Child : S->children())\n        if (Child && this->Visit(Child))\n          return true;\n      return false;\n    }\n  };\n\n  // Make sure we're not referencing non-imported vars or functions.\n  struct DLLImportFunctionVisitor\n      : public RecursiveASTVisitor<DLLImportFunctionVisitor> {\n    bool SafeToInline = true;\n\n    bool shouldVisitImplicitCode() const { return true; }\n\n    bool VisitVarDecl(VarDecl *VD) {\n      if (VD->getTLSKind()) {\n        // A thread-local variable cannot be imported.\n        SafeToInline = false;\n        return SafeToInline;\n      }\n\n      // A variable definition might imply a destructor call.\n      if (VD->isThisDeclarationADefinition())\n        SafeToInline = !HasNonDllImportDtor(VD->getType());\n\n      return SafeToInline;\n    }\n\n    bool VisitCXXBindTemporaryExpr(CXXBindTemporaryExpr *E) {\n      if (const auto *D = E->getTemporary()->getDestructor())\n        SafeToInline = D->hasAttr<DLLImportAttr>();\n      return SafeToInline;\n    }\n\n    bool VisitDeclRefExpr(DeclRefExpr *E) {\n      ValueDecl *VD = E->getDecl();\n      if (isa<FunctionDecl>(VD))\n        SafeToInline = VD->hasAttr<DLLImportAttr>();\n      else if (VarDecl *V = dyn_cast<VarDecl>(VD))\n        SafeToInline = !V->hasGlobalStorage() || V->hasAttr<DLLImportAttr>();\n      return SafeToInline;\n    }\n\n    bool VisitCXXConstructExpr(CXXConstructExpr *E) {\n      SafeToInline = E->getConstructor()->hasAttr<DLLImportAttr>();\n      return SafeToInline;\n    }\n\n    bool VisitCXXMemberCallExpr(CXXMemberCallExpr *E) {\n      CXXMethodDecl *M = E->getMethodDecl();\n      if (!M) {\n        // Call through a pointer to member function. This is safe to inline.\n        SafeToInline = true;\n      } else {\n        SafeToInline = M->hasAttr<DLLImportAttr>();\n      }\n      return SafeToInline;\n    }\n\n    bool VisitCXXDeleteExpr(CXXDeleteExpr *E) {\n      SafeToInline = E->getOperatorDelete()->hasAttr<DLLImportAttr>();\n      return SafeToInline;\n    }\n\n    bool VisitCXXNewExpr(CXXNewExpr *E) {\n      SafeToInline = E->getOperatorNew()->hasAttr<DLLImportAttr>();\n      return SafeToInline;\n    }\n  };\n}\n\n// isTriviallyRecursive - Check if this function calls another\n// decl that, because of the asm attribute or the other decl being a builtin,\n// ends up pointing to itself.\nbool\nCodeGenModule::isTriviallyRecursive(const FunctionDecl *FD) {\n  StringRef Name;\n  if (getCXXABI().getMangleContext().shouldMangleDeclName(FD)) {\n    // asm labels are a special kind of mangling we have to support.\n    AsmLabelAttr *Attr = FD->getAttr<AsmLabelAttr>();\n    if (!Attr)\n      return false;\n    Name = Attr->getLabel();\n  } else {\n    Name = FD->getName();\n  }\n\n  FunctionIsDirectlyRecursive Walker(Name, Context.BuiltinInfo);\n  const Stmt *Body = FD->getBody();\n  return Body ? Walker.Visit(Body) : false;\n}\n\nbool CodeGenModule::shouldEmitFunction(GlobalDecl GD) {\n  if (getFunctionLinkage(GD) != llvm::Function::AvailableExternallyLinkage)\n    return true;\n  const auto *F = cast<FunctionDecl>(GD.getDecl());\n  if (CodeGenOpts.OptimizationLevel == 0 && !F->hasAttr<AlwaysInlineAttr>())\n    return false;\n\n  if (F->hasAttr<DLLImportAttr>() && !F->hasAttr<AlwaysInlineAttr>()) {\n    // Check whether it would be safe to inline this dllimport function.\n    DLLImportFunctionVisitor Visitor;\n    Visitor.TraverseFunctionDecl(const_cast<FunctionDecl*>(F));\n    if (!Visitor.SafeToInline)\n      return false;\n\n    if (const CXXDestructorDecl *Dtor = dyn_cast<CXXDestructorDecl>(F)) {\n      // Implicit destructor invocations aren't captured in the AST, so the\n      // check above can't see them. Check for them manually here.\n      for (const Decl *Member : Dtor->getParent()->decls())\n        if (isa<FieldDecl>(Member))\n          if (HasNonDllImportDtor(cast<FieldDecl>(Member)->getType()))\n            return false;\n      for (const CXXBaseSpecifier &B : Dtor->getParent()->bases())\n        if (HasNonDllImportDtor(B.getType()))\n          return false;\n    }\n  }\n\n  // PR9614. Avoid cases where the source code is lying to us. An available\n  // externally function should have an equivalent function somewhere else,\n  // but a function that calls itself through asm label/`__builtin_` trickery is\n  // clearly not equivalent to the real implementation.\n  // This happens in glibc's btowc and in some configure checks.\n  return !isTriviallyRecursive(F);\n}\n\nbool CodeGenModule::shouldOpportunisticallyEmitVTables() {\n  return CodeGenOpts.OptimizationLevel > 0;\n}\n\nvoid CodeGenModule::EmitMultiVersionFunctionDefinition(GlobalDecl GD,\n                                                       llvm::GlobalValue *GV) {\n  const auto *FD = cast<FunctionDecl>(GD.getDecl());\n\n  if (FD->isCPUSpecificMultiVersion()) {\n    auto *Spec = FD->getAttr<CPUSpecificAttr>();\n    for (unsigned I = 0; I < Spec->cpus_size(); ++I)\n      EmitGlobalFunctionDefinition(GD.getWithMultiVersionIndex(I), nullptr);\n    // Requires multiple emits.\n  } else\n    EmitGlobalFunctionDefinition(GD, GV);\n}\n\nvoid CodeGenModule::EmitGlobalDefinition(GlobalDecl GD, llvm::GlobalValue *GV) {\n  const auto *D = cast<ValueDecl>(GD.getDecl());\n\n  PrettyStackTraceDecl CrashInfo(const_cast<ValueDecl *>(D), D->getLocation(),\n                                 Context.getSourceManager(),\n                                 \"Generating code for declaration\");\n\n  if (const auto *FD = dyn_cast<FunctionDecl>(D)) {\n    // At -O0, don't generate IR for functions with available_externally\n    // linkage.\n    if (!shouldEmitFunction(GD))\n      return;\n\n    llvm::TimeTraceScope TimeScope(\"CodeGen Function\", [&]() {\n      std::string Name;\n      llvm::raw_string_ostream OS(Name);\n      FD->getNameForDiagnostic(OS, getContext().getPrintingPolicy(),\n                               /*Qualified=*/true);\n      return Name;\n    });\n\n    if (const auto *Method = dyn_cast<CXXMethodDecl>(D)) {\n      // Make sure to emit the definition(s) before we emit the thunks.\n      // This is necessary for the generation of certain thunks.\n      if (isa<CXXConstructorDecl>(Method) || isa<CXXDestructorDecl>(Method))\n        ABI->emitCXXStructor(GD);\n      else if (FD->isMultiVersion())\n        EmitMultiVersionFunctionDefinition(GD, GV);\n      else\n        EmitGlobalFunctionDefinition(GD, GV);\n\n      if (Method->isVirtual())\n        getVTables().EmitThunks(GD);\n\n      return;\n    }\n\n    if (FD->isMultiVersion())\n      return EmitMultiVersionFunctionDefinition(GD, GV);\n    return EmitGlobalFunctionDefinition(GD, GV);\n  }\n\n  if (const auto *VD = dyn_cast<VarDecl>(D))\n    return EmitGlobalVarDefinition(VD, !VD->hasDefinition());\n\n  llvm_unreachable(\"Invalid argument to EmitGlobalDefinition()\");\n}\n\nstatic void ReplaceUsesOfNonProtoTypeWithRealFunction(llvm::GlobalValue *Old,\n                                                      llvm::Function *NewFn);\n\nstatic unsigned\nTargetMVPriority(const TargetInfo &TI,\n                 const CodeGenFunction::MultiVersionResolverOption &RO) {\n  unsigned Priority = 0;\n  for (StringRef Feat : RO.Conditions.Features)\n    Priority = std::max(Priority, TI.multiVersionSortPriority(Feat));\n\n  if (!RO.Conditions.Architecture.empty())\n    Priority = std::max(\n        Priority, TI.multiVersionSortPriority(RO.Conditions.Architecture));\n  return Priority;\n}\n\nvoid CodeGenModule::emitMultiVersionFunctions() {\n  for (GlobalDecl GD : MultiVersionFuncs) {\n    SmallVector<CodeGenFunction::MultiVersionResolverOption, 10> Options;\n    const FunctionDecl *FD = cast<FunctionDecl>(GD.getDecl());\n    getContext().forEachMultiversionedFunctionVersion(\n        FD, [this, &GD, &Options](const FunctionDecl *CurFD) {\n          GlobalDecl CurGD{\n              (CurFD->isDefined() ? CurFD->getDefinition() : CurFD)};\n          StringRef MangledName = getMangledName(CurGD);\n          llvm::Constant *Func = GetGlobalValue(MangledName);\n          if (!Func) {\n            if (CurFD->isDefined()) {\n              EmitGlobalFunctionDefinition(CurGD, nullptr);\n              Func = GetGlobalValue(MangledName);\n            } else {\n              const CGFunctionInfo &FI =\n                  getTypes().arrangeGlobalDeclaration(GD);\n              llvm::FunctionType *Ty = getTypes().GetFunctionType(FI);\n              Func = GetAddrOfFunction(CurGD, Ty, /*ForVTable=*/false,\n                                       /*DontDefer=*/false, ForDefinition);\n            }\n            assert(Func && \"This should have just been created\");\n          }\n\n          const auto *TA = CurFD->getAttr<TargetAttr>();\n          llvm::SmallVector<StringRef, 8> Feats;\n          TA->getAddedFeatures(Feats);\n\n          Options.emplace_back(cast<llvm::Function>(Func),\n                               TA->getArchitecture(), Feats);\n        });\n\n    llvm::Function *ResolverFunc;\n    const TargetInfo &TI = getTarget();\n\n    if (TI.supportsIFunc() || FD->isTargetMultiVersion()) {\n      ResolverFunc = cast<llvm::Function>(\n          GetGlobalValue((getMangledName(GD) + \".resolver\").str()));\n      ResolverFunc->setLinkage(llvm::Function::WeakODRLinkage);\n    } else {\n      ResolverFunc = cast<llvm::Function>(GetGlobalValue(getMangledName(GD)));\n    }\n\n    if (supportsCOMDAT())\n      ResolverFunc->setComdat(\n          getModule().getOrInsertComdat(ResolverFunc->getName()));\n\n    llvm::stable_sort(\n        Options, [&TI](const CodeGenFunction::MultiVersionResolverOption &LHS,\n                       const CodeGenFunction::MultiVersionResolverOption &RHS) {\n          return TargetMVPriority(TI, LHS) > TargetMVPriority(TI, RHS);\n        });\n    CodeGenFunction CGF(*this);\n    CGF.EmitMultiVersionResolver(ResolverFunc, Options);\n  }\n}\n\nvoid CodeGenModule::emitCPUDispatchDefinition(GlobalDecl GD) {\n  const auto *FD = cast<FunctionDecl>(GD.getDecl());\n  assert(FD && \"Not a FunctionDecl?\");\n  const auto *DD = FD->getAttr<CPUDispatchAttr>();\n  assert(DD && \"Not a cpu_dispatch Function?\");\n  llvm::Type *DeclTy = getTypes().ConvertType(FD->getType());\n\n  if (const auto *CXXFD = dyn_cast<CXXMethodDecl>(FD)) {\n    const CGFunctionInfo &FInfo = getTypes().arrangeCXXMethodDeclaration(CXXFD);\n    DeclTy = getTypes().GetFunctionType(FInfo);\n  }\n\n  StringRef ResolverName = getMangledName(GD);\n\n  llvm::Type *ResolverType;\n  GlobalDecl ResolverGD;\n  if (getTarget().supportsIFunc())\n    ResolverType = llvm::FunctionType::get(\n        llvm::PointerType::get(DeclTy,\n                               Context.getTargetAddressSpace(FD->getType())),\n        false);\n  else {\n    ResolverType = DeclTy;\n    ResolverGD = GD;\n  }\n\n  auto *ResolverFunc = cast<llvm::Function>(GetOrCreateLLVMFunction(\n      ResolverName, ResolverType, ResolverGD, /*ForVTable=*/false));\n  ResolverFunc->setLinkage(llvm::Function::WeakODRLinkage);\n  if (supportsCOMDAT())\n    ResolverFunc->setComdat(\n        getModule().getOrInsertComdat(ResolverFunc->getName()));\n\n  SmallVector<CodeGenFunction::MultiVersionResolverOption, 10> Options;\n  const TargetInfo &Target = getTarget();\n  unsigned Index = 0;\n  for (const IdentifierInfo *II : DD->cpus()) {\n    // Get the name of the target function so we can look it up/create it.\n    std::string MangledName = getMangledNameImpl(*this, GD, FD, true) +\n                              getCPUSpecificMangling(*this, II->getName());\n\n    llvm::Constant *Func = GetGlobalValue(MangledName);\n\n    if (!Func) {\n      GlobalDecl ExistingDecl = Manglings.lookup(MangledName);\n      if (ExistingDecl.getDecl() &&\n          ExistingDecl.getDecl()->getAsFunction()->isDefined()) {\n        EmitGlobalFunctionDefinition(ExistingDecl, nullptr);\n        Func = GetGlobalValue(MangledName);\n      } else {\n        if (!ExistingDecl.getDecl())\n          ExistingDecl = GD.getWithMultiVersionIndex(Index);\n\n      Func = GetOrCreateLLVMFunction(\n          MangledName, DeclTy, ExistingDecl,\n          /*ForVTable=*/false, /*DontDefer=*/true,\n          /*IsThunk=*/false, llvm::AttributeList(), ForDefinition);\n      }\n    }\n\n    llvm::SmallVector<StringRef, 32> Features;\n    Target.getCPUSpecificCPUDispatchFeatures(II->getName(), Features);\n    llvm::transform(Features, Features.begin(),\n                    [](StringRef Str) { return Str.substr(1); });\n    Features.erase(std::remove_if(\n        Features.begin(), Features.end(), [&Target](StringRef Feat) {\n          return !Target.validateCpuSupports(Feat);\n        }), Features.end());\n    Options.emplace_back(cast<llvm::Function>(Func), StringRef{}, Features);\n    ++Index;\n  }\n\n  llvm::sort(\n      Options, [](const CodeGenFunction::MultiVersionResolverOption &LHS,\n                  const CodeGenFunction::MultiVersionResolverOption &RHS) {\n        return CodeGenFunction::GetX86CpuSupportsMask(LHS.Conditions.Features) >\n               CodeGenFunction::GetX86CpuSupportsMask(RHS.Conditions.Features);\n      });\n\n  // If the list contains multiple 'default' versions, such as when it contains\n  // 'pentium' and 'generic', don't emit the call to the generic one (since we\n  // always run on at least a 'pentium'). We do this by deleting the 'least\n  // advanced' (read, lowest mangling letter).\n  while (Options.size() > 1 &&\n         CodeGenFunction::GetX86CpuSupportsMask(\n             (Options.end() - 2)->Conditions.Features) == 0) {\n    StringRef LHSName = (Options.end() - 2)->Function->getName();\n    StringRef RHSName = (Options.end() - 1)->Function->getName();\n    if (LHSName.compare(RHSName) < 0)\n      Options.erase(Options.end() - 2);\n    else\n      Options.erase(Options.end() - 1);\n  }\n\n  CodeGenFunction CGF(*this);\n  CGF.EmitMultiVersionResolver(ResolverFunc, Options);\n\n  if (getTarget().supportsIFunc()) {\n    std::string AliasName = getMangledNameImpl(\n        *this, GD, FD, /*OmitMultiVersionMangling=*/true);\n    llvm::Constant *AliasFunc = GetGlobalValue(AliasName);\n    if (!AliasFunc) {\n      auto *IFunc = cast<llvm::GlobalIFunc>(GetOrCreateLLVMFunction(\n          AliasName, DeclTy, GD, /*ForVTable=*/false, /*DontDefer=*/true,\n          /*IsThunk=*/false, llvm::AttributeList(), NotForDefinition));\n      auto *GA = llvm::GlobalAlias::create(\n         DeclTy, 0, getFunctionLinkage(GD), AliasName, IFunc, &getModule());\n      GA->setLinkage(llvm::Function::WeakODRLinkage);\n      SetCommonAttributes(GD, GA);\n    }\n  }\n}\n\n/// If a dispatcher for the specified mangled name is not in the module, create\n/// and return an llvm Function with the specified type.\nllvm::Constant *CodeGenModule::GetOrCreateMultiVersionResolver(\n    GlobalDecl GD, llvm::Type *DeclTy, const FunctionDecl *FD) {\n  std::string MangledName =\n      getMangledNameImpl(*this, GD, FD, /*OmitMultiVersionMangling=*/true);\n\n  // Holds the name of the resolver, in ifunc mode this is the ifunc (which has\n  // a separate resolver).\n  std::string ResolverName = MangledName;\n  if (getTarget().supportsIFunc())\n    ResolverName += \".ifunc\";\n  else if (FD->isTargetMultiVersion())\n    ResolverName += \".resolver\";\n\n  // If this already exists, just return that one.\n  if (llvm::GlobalValue *ResolverGV = GetGlobalValue(ResolverName))\n    return ResolverGV;\n\n  // Since this is the first time we've created this IFunc, make sure\n  // that we put this multiversioned function into the list to be\n  // replaced later if necessary (target multiversioning only).\n  if (!FD->isCPUDispatchMultiVersion() && !FD->isCPUSpecificMultiVersion())\n    MultiVersionFuncs.push_back(GD);\n\n  if (getTarget().supportsIFunc()) {\n    llvm::Type *ResolverType = llvm::FunctionType::get(\n        llvm::PointerType::get(\n            DeclTy, getContext().getTargetAddressSpace(FD->getType())),\n        false);\n    llvm::Constant *Resolver = GetOrCreateLLVMFunction(\n        MangledName + \".resolver\", ResolverType, GlobalDecl{},\n        /*ForVTable=*/false);\n    llvm::GlobalIFunc *GIF = llvm::GlobalIFunc::create(\n        DeclTy, 0, llvm::Function::WeakODRLinkage, \"\", Resolver, &getModule());\n    GIF->setName(ResolverName);\n    SetCommonAttributes(FD, GIF);\n\n    return GIF;\n  }\n\n  llvm::Constant *Resolver = GetOrCreateLLVMFunction(\n      ResolverName, DeclTy, GlobalDecl{}, /*ForVTable=*/false);\n  assert(isa<llvm::GlobalValue>(Resolver) &&\n         \"Resolver should be created for the first time\");\n  SetCommonAttributes(FD, cast<llvm::GlobalValue>(Resolver));\n  return Resolver;\n}\n\n/// GetOrCreateLLVMFunction - If the specified mangled name is not in the\n/// module, create and return an llvm Function with the specified type. If there\n/// is something in the module with the specified name, return it potentially\n/// bitcasted to the right type.\n///\n/// If D is non-null, it specifies a decl that correspond to this.  This is used\n/// to set the attributes on the function when it is first created.\nllvm::Constant *CodeGenModule::GetOrCreateLLVMFunction(\n    StringRef MangledName, llvm::Type *Ty, GlobalDecl GD, bool ForVTable,\n    bool DontDefer, bool IsThunk, llvm::AttributeList ExtraAttrs,\n    ForDefinition_t IsForDefinition) {\n  const Decl *D = GD.getDecl();\n\n  // Any attempts to use a MultiVersion function should result in retrieving\n  // the iFunc instead. Name Mangling will handle the rest of the changes.\n  if (const FunctionDecl *FD = cast_or_null<FunctionDecl>(D)) {\n    // For the device mark the function as one that should be emitted.\n    if (getLangOpts().OpenMPIsDevice && OpenMPRuntime &&\n        !OpenMPRuntime->markAsGlobalTarget(GD) && FD->isDefined() &&\n        !DontDefer && !IsForDefinition) {\n      if (const FunctionDecl *FDDef = FD->getDefinition()) {\n        GlobalDecl GDDef;\n        if (const auto *CD = dyn_cast<CXXConstructorDecl>(FDDef))\n          GDDef = GlobalDecl(CD, GD.getCtorType());\n        else if (const auto *DD = dyn_cast<CXXDestructorDecl>(FDDef))\n          GDDef = GlobalDecl(DD, GD.getDtorType());\n        else\n          GDDef = GlobalDecl(FDDef);\n        EmitGlobal(GDDef);\n      }\n    }\n\n    if (FD->isMultiVersion()) {\n      if (FD->hasAttr<TargetAttr>())\n        UpdateMultiVersionNames(GD, FD);\n      if (!IsForDefinition)\n        return GetOrCreateMultiVersionResolver(GD, Ty, FD);\n    }\n  }\n\n  // Lookup the entry, lazily creating it if necessary.\n  llvm::GlobalValue *Entry = GetGlobalValue(MangledName);\n  if (Entry) {\n    if (WeakRefReferences.erase(Entry)) {\n      const FunctionDecl *FD = cast_or_null<FunctionDecl>(D);\n      if (FD && !FD->hasAttr<WeakAttr>())\n        Entry->setLinkage(llvm::Function::ExternalLinkage);\n    }\n\n    // Handle dropped DLL attributes.\n    if (D && !D->hasAttr<DLLImportAttr>() && !D->hasAttr<DLLExportAttr>()) {\n      Entry->setDLLStorageClass(llvm::GlobalValue::DefaultStorageClass);\n      setDSOLocal(Entry);\n    }\n\n    // If there are two attempts to define the same mangled name, issue an\n    // error.\n    if (IsForDefinition && !Entry->isDeclaration()) {\n      GlobalDecl OtherGD;\n      // Check that GD is not yet in DiagnosedConflictingDefinitions is required\n      // to make sure that we issue an error only once.\n      if (lookupRepresentativeDecl(MangledName, OtherGD) &&\n          (GD.getCanonicalDecl().getDecl() !=\n           OtherGD.getCanonicalDecl().getDecl()) &&\n          DiagnosedConflictingDefinitions.insert(GD).second) {\n        getDiags().Report(D->getLocation(), diag::err_duplicate_mangled_name)\n            << MangledName;\n        getDiags().Report(OtherGD.getDecl()->getLocation(),\n                          diag::note_previous_definition);\n      }\n    }\n\n    if ((isa<llvm::Function>(Entry) || isa<llvm::GlobalAlias>(Entry)) &&\n        (Entry->getValueType() == Ty)) {\n      return Entry;\n    }\n\n    // Make sure the result is of the correct type.\n    // (If function is requested for a definition, we always need to create a new\n    // function, not just return a bitcast.)\n    if (!IsForDefinition)\n      return llvm::ConstantExpr::getBitCast(Entry, Ty->getPointerTo());\n  }\n\n  // This function doesn't have a complete type (for example, the return\n  // type is an incomplete struct). Use a fake type instead, and make\n  // sure not to try to set attributes.\n  bool IsIncompleteFunction = false;\n\n  llvm::FunctionType *FTy;\n  if (isa<llvm::FunctionType>(Ty)) {\n    FTy = cast<llvm::FunctionType>(Ty);\n  } else {\n    FTy = llvm::FunctionType::get(VoidTy, false);\n    IsIncompleteFunction = true;\n  }\n\n  llvm::Function *F =\n      llvm::Function::Create(FTy, llvm::Function::ExternalLinkage,\n                             Entry ? StringRef() : MangledName, &getModule());\n\n  // If we already created a function with the same mangled name (but different\n  // type) before, take its name and add it to the list of functions to be\n  // replaced with F at the end of CodeGen.\n  //\n  // This happens if there is a prototype for a function (e.g. \"int f()\") and\n  // then a definition of a different type (e.g. \"int f(int x)\").\n  if (Entry) {\n    F->takeName(Entry);\n\n    // This might be an implementation of a function without a prototype, in\n    // which case, try to do special replacement of calls which match the new\n    // prototype.  The really key thing here is that we also potentially drop\n    // arguments from the call site so as to make a direct call, which makes the\n    // inliner happier and suppresses a number of optimizer warnings (!) about\n    // dropping arguments.\n    if (!Entry->use_empty()) {\n      ReplaceUsesOfNonProtoTypeWithRealFunction(Entry, F);\n      Entry->removeDeadConstantUsers();\n    }\n\n    llvm::Constant *BC = llvm::ConstantExpr::getBitCast(\n        F, Entry->getValueType()->getPointerTo());\n    addGlobalValReplacement(Entry, BC);\n  }\n\n  assert(F->getName() == MangledName && \"name was uniqued!\");\n  if (D)\n    SetFunctionAttributes(GD, F, IsIncompleteFunction, IsThunk);\n  if (ExtraAttrs.hasAttributes(llvm::AttributeList::FunctionIndex)) {\n    llvm::AttrBuilder B(ExtraAttrs, llvm::AttributeList::FunctionIndex);\n    F->addAttributes(llvm::AttributeList::FunctionIndex, B);\n  }\n\n  if (!DontDefer) {\n    // All MSVC dtors other than the base dtor are linkonce_odr and delegate to\n    // each other bottoming out with the base dtor.  Therefore we emit non-base\n    // dtors on usage, even if there is no dtor definition in the TU.\n    if (D && isa<CXXDestructorDecl>(D) &&\n        getCXXABI().useThunkForDtorVariant(cast<CXXDestructorDecl>(D),\n                                           GD.getDtorType()))\n      addDeferredDeclToEmit(GD);\n\n    // This is the first use or definition of a mangled name.  If there is a\n    // deferred decl with this name, remember that we need to emit it at the end\n    // of the file.\n    auto DDI = DeferredDecls.find(MangledName);\n    if (DDI != DeferredDecls.end()) {\n      // Move the potentially referenced deferred decl to the\n      // DeferredDeclsToEmit list, and remove it from DeferredDecls (since we\n      // don't need it anymore).\n      addDeferredDeclToEmit(DDI->second);\n      DeferredDecls.erase(DDI);\n\n      // Otherwise, there are cases we have to worry about where we're\n      // using a declaration for which we must emit a definition but where\n      // we might not find a top-level definition:\n      //   - member functions defined inline in their classes\n      //   - friend functions defined inline in some class\n      //   - special member functions with implicit definitions\n      // If we ever change our AST traversal to walk into class methods,\n      // this will be unnecessary.\n      //\n      // We also don't emit a definition for a function if it's going to be an\n      // entry in a vtable, unless it's already marked as used.\n    } else if (getLangOpts().CPlusPlus && D) {\n      // Look for a declaration that's lexically in a record.\n      for (const auto *FD = cast<FunctionDecl>(D)->getMostRecentDecl(); FD;\n           FD = FD->getPreviousDecl()) {\n        if (isa<CXXRecordDecl>(FD->getLexicalDeclContext())) {\n          if (FD->doesThisDeclarationHaveABody()) {\n            addDeferredDeclToEmit(GD.getWithDecl(FD));\n            break;\n          }\n        }\n      }\n    }\n  }\n\n  // Make sure the result is of the requested type.\n  if (!IsIncompleteFunction) {\n    assert(F->getFunctionType() == Ty);\n    return F;\n  }\n\n  llvm::Type *PTy = llvm::PointerType::getUnqual(Ty);\n  return llvm::ConstantExpr::getBitCast(F, PTy);\n}\n\n/// GetAddrOfFunction - Return the address of the given function.  If Ty is\n/// non-null, then this function will use the specified type if it has to\n/// create it (this occurs when we see a definition of the function).\nllvm::Constant *CodeGenModule::GetAddrOfFunction(GlobalDecl GD,\n                                                 llvm::Type *Ty,\n                                                 bool ForVTable,\n                                                 bool DontDefer,\n                                              ForDefinition_t IsForDefinition) {\n  assert(!cast<FunctionDecl>(GD.getDecl())->isConsteval() &&\n         \"consteval function should never be emitted\");\n  // If there was no specific requested type, just convert it now.\n  if (!Ty) {\n    const auto *FD = cast<FunctionDecl>(GD.getDecl());\n    Ty = getTypes().ConvertType(FD->getType());\n  }\n\n  // Devirtualized destructor calls may come through here instead of via\n  // getAddrOfCXXStructor. Make sure we use the MS ABI base destructor instead\n  // of the complete destructor when necessary.\n  if (const auto *DD = dyn_cast<CXXDestructorDecl>(GD.getDecl())) {\n    if (getTarget().getCXXABI().isMicrosoft() &&\n        GD.getDtorType() == Dtor_Complete &&\n        DD->getParent()->getNumVBases() == 0)\n      GD = GlobalDecl(DD, Dtor_Base);\n  }\n\n  StringRef MangledName = getMangledName(GD);\n  return GetOrCreateLLVMFunction(MangledName, Ty, GD, ForVTable, DontDefer,\n                                 /*IsThunk=*/false, llvm::AttributeList(),\n                                 IsForDefinition);\n}\n\nstatic const FunctionDecl *\nGetRuntimeFunctionDecl(ASTContext &C, StringRef Name) {\n  TranslationUnitDecl *TUDecl = C.getTranslationUnitDecl();\n  DeclContext *DC = TranslationUnitDecl::castToDeclContext(TUDecl);\n\n  IdentifierInfo &CII = C.Idents.get(Name);\n  for (const auto &Result : DC->lookup(&CII))\n    if (const auto FD = dyn_cast<FunctionDecl>(Result))\n      return FD;\n\n  if (!C.getLangOpts().CPlusPlus)\n    return nullptr;\n\n  // Demangle the premangled name from getTerminateFn()\n  IdentifierInfo &CXXII =\n      (Name == \"_ZSt9terminatev\" || Name == \"?terminate@@YAXXZ\")\n          ? C.Idents.get(\"terminate\")\n          : C.Idents.get(Name);\n\n  for (const auto &N : {\"__cxxabiv1\", \"std\"}) {\n    IdentifierInfo &NS = C.Idents.get(N);\n    for (const auto &Result : DC->lookup(&NS)) {\n      NamespaceDecl *ND = dyn_cast<NamespaceDecl>(Result);\n      if (auto LSD = dyn_cast<LinkageSpecDecl>(Result))\n        for (const auto &Result : LSD->lookup(&NS))\n          if ((ND = dyn_cast<NamespaceDecl>(Result)))\n            break;\n\n      if (ND)\n        for (const auto &Result : ND->lookup(&CXXII))\n          if (const auto *FD = dyn_cast<FunctionDecl>(Result))\n            return FD;\n    }\n  }\n\n  return nullptr;\n}\n\n/// CreateRuntimeFunction - Create a new runtime function with the specified\n/// type and name.\nllvm::FunctionCallee\nCodeGenModule::CreateRuntimeFunction(llvm::FunctionType *FTy, StringRef Name,\n                                     llvm::AttributeList ExtraAttrs, bool Local,\n                                     bool AssumeConvergent) {\n  if (AssumeConvergent) {\n    ExtraAttrs =\n        ExtraAttrs.addAttribute(VMContext, llvm::AttributeList::FunctionIndex,\n                                llvm::Attribute::Convergent);\n  }\n\n  llvm::Constant *C =\n      GetOrCreateLLVMFunction(Name, FTy, GlobalDecl(), /*ForVTable=*/false,\n                              /*DontDefer=*/false, /*IsThunk=*/false,\n                              ExtraAttrs);\n\n  if (auto *F = dyn_cast<llvm::Function>(C)) {\n    if (F->empty()) {\n      F->setCallingConv(getRuntimeCC());\n\n      // In Windows Itanium environments, try to mark runtime functions\n      // dllimport. For Mingw and MSVC, don't. We don't really know if the user\n      // will link their standard library statically or dynamically. Marking\n      // functions imported when they are not imported can cause linker errors\n      // and warnings.\n      if (!Local && getTriple().isWindowsItaniumEnvironment() &&\n          !getCodeGenOpts().LTOVisibilityPublicStd) {\n        const FunctionDecl *FD = GetRuntimeFunctionDecl(Context, Name);\n        if (!FD || FD->hasAttr<DLLImportAttr>()) {\n          F->setDLLStorageClass(llvm::GlobalValue::DLLImportStorageClass);\n          F->setLinkage(llvm::GlobalValue::ExternalLinkage);\n        }\n      }\n      setDSOLocal(F);\n    }\n  }\n\n  return {FTy, C};\n}\n\n/// isTypeConstant - Determine whether an object of this type can be emitted\n/// as a constant.\n///\n/// If ExcludeCtor is true, the duration when the object's constructor runs\n/// will not be considered. The caller will need to verify that the object is\n/// not written to during its construction.\nbool CodeGenModule::isTypeConstant(QualType Ty, bool ExcludeCtor) {\n  if (!Ty.isConstant(Context) && !Ty->isReferenceType())\n    return false;\n\n  if (Context.getLangOpts().CPlusPlus) {\n    if (const CXXRecordDecl *Record\n          = Context.getBaseElementType(Ty)->getAsCXXRecordDecl())\n      return ExcludeCtor && !Record->hasMutableFields() &&\n             Record->hasTrivialDestructor();\n  }\n\n  return true;\n}\n\n/// GetOrCreateLLVMGlobal - If the specified mangled name is not in the module,\n/// create and return an llvm GlobalVariable with the specified type.  If there\n/// is something in the module with the specified name, return it potentially\n/// bitcasted to the right type.\n///\n/// If D is non-null, it specifies a decl that correspond to this.  This is used\n/// to set the attributes on the global when it is first created.\n///\n/// If IsForDefinition is true, it is guaranteed that an actual global with\n/// type Ty will be returned, not conversion of a variable with the same\n/// mangled name but some other type.\nllvm::Constant *\nCodeGenModule::GetOrCreateLLVMGlobal(StringRef MangledName,\n                                     llvm::PointerType *Ty,\n                                     const VarDecl *D,\n                                     ForDefinition_t IsForDefinition) {\n  // Lookup the entry, lazily creating it if necessary.\n  llvm::GlobalValue *Entry = GetGlobalValue(MangledName);\n  if (Entry) {\n    if (WeakRefReferences.erase(Entry)) {\n      if (D && !D->hasAttr<WeakAttr>())\n        Entry->setLinkage(llvm::Function::ExternalLinkage);\n    }\n\n    // Handle dropped DLL attributes.\n    if (D && !D->hasAttr<DLLImportAttr>() && !D->hasAttr<DLLExportAttr>())\n      Entry->setDLLStorageClass(llvm::GlobalValue::DefaultStorageClass);\n\n    if (LangOpts.OpenMP && !LangOpts.OpenMPSimd && D)\n      getOpenMPRuntime().registerTargetGlobalVariable(D, Entry);\n\n    if (Entry->getType() == Ty)\n      return Entry;\n\n    // If there are two attempts to define the same mangled name, issue an\n    // error.\n    if (IsForDefinition && !Entry->isDeclaration()) {\n      GlobalDecl OtherGD;\n      const VarDecl *OtherD;\n\n      // Check that D is not yet in DiagnosedConflictingDefinitions is required\n      // to make sure that we issue an error only once.\n      if (D && lookupRepresentativeDecl(MangledName, OtherGD) &&\n          (D->getCanonicalDecl() != OtherGD.getCanonicalDecl().getDecl()) &&\n          (OtherD = dyn_cast<VarDecl>(OtherGD.getDecl())) &&\n          OtherD->hasInit() &&\n          DiagnosedConflictingDefinitions.insert(D).second) {\n        getDiags().Report(D->getLocation(), diag::err_duplicate_mangled_name)\n            << MangledName;\n        getDiags().Report(OtherGD.getDecl()->getLocation(),\n                          diag::note_previous_definition);\n      }\n    }\n\n    // Make sure the result is of the correct type.\n    if (Entry->getType()->getAddressSpace() != Ty->getAddressSpace())\n      return llvm::ConstantExpr::getAddrSpaceCast(Entry, Ty);\n\n    // (If global is requested for a definition, we always need to create a new\n    // global, not just return a bitcast.)\n    if (!IsForDefinition)\n      return llvm::ConstantExpr::getBitCast(Entry, Ty);\n  }\n\n  auto AddrSpace = GetGlobalVarAddressSpace(D);\n  auto TargetAddrSpace = getContext().getTargetAddressSpace(AddrSpace);\n\n  auto *GV = new llvm::GlobalVariable(\n      getModule(), Ty->getElementType(), false,\n      llvm::GlobalValue::ExternalLinkage, nullptr, MangledName, nullptr,\n      llvm::GlobalVariable::NotThreadLocal, TargetAddrSpace);\n\n  // If we already created a global with the same mangled name (but different\n  // type) before, take its name and remove it from its parent.\n  if (Entry) {\n    GV->takeName(Entry);\n\n    if (!Entry->use_empty()) {\n      llvm::Constant *NewPtrForOldDecl =\n          llvm::ConstantExpr::getBitCast(GV, Entry->getType());\n      Entry->replaceAllUsesWith(NewPtrForOldDecl);\n    }\n\n    Entry->eraseFromParent();\n  }\n\n  // This is the first use or definition of a mangled name.  If there is a\n  // deferred decl with this name, remember that we need to emit it at the end\n  // of the file.\n  auto DDI = DeferredDecls.find(MangledName);\n  if (DDI != DeferredDecls.end()) {\n    // Move the potentially referenced deferred decl to the DeferredDeclsToEmit\n    // list, and remove it from DeferredDecls (since we don't need it anymore).\n    addDeferredDeclToEmit(DDI->second);\n    DeferredDecls.erase(DDI);\n  }\n\n  // Handle things which are present even on external declarations.\n  if (D) {\n    if (LangOpts.OpenMP && !LangOpts.OpenMPSimd)\n      getOpenMPRuntime().registerTargetGlobalVariable(D, GV);\n\n    // FIXME: This code is overly simple and should be merged with other global\n    // handling.\n    GV->setConstant(isTypeConstant(D->getType(), false));\n\n    GV->setAlignment(getContext().getDeclAlign(D).getAsAlign());\n\n    setLinkageForGV(GV, D);\n\n    if (D->getTLSKind()) {\n      if (D->getTLSKind() == VarDecl::TLS_Dynamic)\n        CXXThreadLocals.push_back(D);\n      setTLSMode(GV, *D);\n    }\n\n    setGVProperties(GV, D);\n\n    // If required by the ABI, treat declarations of static data members with\n    // inline initializers as definitions.\n    if (getContext().isMSStaticDataMemberInlineDefinition(D)) {\n      EmitGlobalVarDefinition(D);\n    }\n\n    // Emit section information for extern variables.\n    if (D->hasExternalStorage()) {\n      if (const SectionAttr *SA = D->getAttr<SectionAttr>())\n        GV->setSection(SA->getName());\n    }\n\n    // Handle XCore specific ABI requirements.\n    if (getTriple().getArch() == llvm::Triple::xcore &&\n        D->getLanguageLinkage() == CLanguageLinkage &&\n        D->getType().isConstant(Context) &&\n        isExternallyVisible(D->getLinkageAndVisibility().getLinkage()))\n      GV->setSection(\".cp.rodata\");\n\n    // Check if we a have a const declaration with an initializer, we may be\n    // able to emit it as available_externally to expose it's value to the\n    // optimizer.\n    if (Context.getLangOpts().CPlusPlus && GV->hasExternalLinkage() &&\n        D->getType().isConstQualified() && !GV->hasInitializer() &&\n        !D->hasDefinition() && D->hasInit() && !D->hasAttr<DLLImportAttr>()) {\n      const auto *Record =\n          Context.getBaseElementType(D->getType())->getAsCXXRecordDecl();\n      bool HasMutableFields = Record && Record->hasMutableFields();\n      if (!HasMutableFields) {\n        const VarDecl *InitDecl;\n        const Expr *InitExpr = D->getAnyInitializer(InitDecl);\n        if (InitExpr) {\n          ConstantEmitter emitter(*this);\n          llvm::Constant *Init = emitter.tryEmitForInitializer(*InitDecl);\n          if (Init) {\n            auto *InitType = Init->getType();\n            if (GV->getValueType() != InitType) {\n              // The type of the initializer does not match the definition.\n              // This happens when an initializer has a different type from\n              // the type of the global (because of padding at the end of a\n              // structure for instance).\n              GV->setName(StringRef());\n              // Make a new global with the correct type, this is now guaranteed\n              // to work.\n              auto *NewGV = cast<llvm::GlobalVariable>(\n                  GetAddrOfGlobalVar(D, InitType, IsForDefinition)\n                      ->stripPointerCasts());\n\n              // Erase the old global, since it is no longer used.\n              GV->eraseFromParent();\n              GV = NewGV;\n            } else {\n              GV->setInitializer(Init);\n              GV->setConstant(true);\n              GV->setLinkage(llvm::GlobalValue::AvailableExternallyLinkage);\n            }\n            emitter.finalize(GV);\n          }\n        }\n      }\n    }\n  }\n\n  if (GV->isDeclaration())\n    getTargetCodeGenInfo().setTargetAttributes(D, GV, *this);\n\n  LangAS ExpectedAS =\n      D ? D->getType().getAddressSpace()\n        : (LangOpts.OpenCL ? LangAS::opencl_global : LangAS::Default);\n  assert(getContext().getTargetAddressSpace(ExpectedAS) ==\n         Ty->getPointerAddressSpace());\n  if (AddrSpace != ExpectedAS)\n    return getTargetCodeGenInfo().performAddrSpaceCast(*this, GV, AddrSpace,\n                                                       ExpectedAS, Ty);\n\n  return GV;\n}\n\nllvm::Constant *\nCodeGenModule::GetAddrOfGlobal(GlobalDecl GD, ForDefinition_t IsForDefinition) {\n  const Decl *D = GD.getDecl();\n\n  if (isa<CXXConstructorDecl>(D) || isa<CXXDestructorDecl>(D))\n    return getAddrOfCXXStructor(GD, /*FnInfo=*/nullptr, /*FnType=*/nullptr,\n                                /*DontDefer=*/false, IsForDefinition);\n\n  if (isa<CXXMethodDecl>(D)) {\n    auto FInfo =\n        &getTypes().arrangeCXXMethodDeclaration(cast<CXXMethodDecl>(D));\n    auto Ty = getTypes().GetFunctionType(*FInfo);\n    return GetAddrOfFunction(GD, Ty, /*ForVTable=*/false, /*DontDefer=*/false,\n                             IsForDefinition);\n  }\n\n  if (isa<FunctionDecl>(D)) {\n    const CGFunctionInfo &FI = getTypes().arrangeGlobalDeclaration(GD);\n    llvm::FunctionType *Ty = getTypes().GetFunctionType(FI);\n    return GetAddrOfFunction(GD, Ty, /*ForVTable=*/false, /*DontDefer=*/false,\n                             IsForDefinition);\n  }\n\n  return GetAddrOfGlobalVar(cast<VarDecl>(D), /*Ty=*/nullptr, IsForDefinition);\n}\n\nllvm::GlobalVariable *CodeGenModule::CreateOrReplaceCXXRuntimeVariable(\n    StringRef Name, llvm::Type *Ty, llvm::GlobalValue::LinkageTypes Linkage,\n    unsigned Alignment) {\n  llvm::GlobalVariable *GV = getModule().getNamedGlobal(Name);\n  llvm::GlobalVariable *OldGV = nullptr;\n\n  if (GV) {\n    // Check if the variable has the right type.\n    if (GV->getValueType() == Ty)\n      return GV;\n\n    // Because C++ name mangling, the only way we can end up with an already\n    // existing global with the same name is if it has been declared extern \"C\".\n    assert(GV->isDeclaration() && \"Declaration has wrong type!\");\n    OldGV = GV;\n  }\n\n  // Create a new variable.\n  GV = new llvm::GlobalVariable(getModule(), Ty, /*isConstant=*/true,\n                                Linkage, nullptr, Name);\n\n  if (OldGV) {\n    // Replace occurrences of the old variable if needed.\n    GV->takeName(OldGV);\n\n    if (!OldGV->use_empty()) {\n      llvm::Constant *NewPtrForOldDecl =\n      llvm::ConstantExpr::getBitCast(GV, OldGV->getType());\n      OldGV->replaceAllUsesWith(NewPtrForOldDecl);\n    }\n\n    OldGV->eraseFromParent();\n  }\n\n  if (supportsCOMDAT() && GV->isWeakForLinker() &&\n      !GV->hasAvailableExternallyLinkage())\n    GV->setComdat(TheModule.getOrInsertComdat(GV->getName()));\n\n  GV->setAlignment(llvm::MaybeAlign(Alignment));\n\n  return GV;\n}\n\n/// GetAddrOfGlobalVar - Return the llvm::Constant for the address of the\n/// given global variable.  If Ty is non-null and if the global doesn't exist,\n/// then it will be created with the specified type instead of whatever the\n/// normal requested type would be. If IsForDefinition is true, it is guaranteed\n/// that an actual global with type Ty will be returned, not conversion of a\n/// variable with the same mangled name but some other type.\nllvm::Constant *CodeGenModule::GetAddrOfGlobalVar(const VarDecl *D,\n                                                  llvm::Type *Ty,\n                                           ForDefinition_t IsForDefinition) {\n  assert(D->hasGlobalStorage() && \"Not a global variable\");\n  QualType ASTTy = D->getType();\n  if (!Ty)\n    Ty = getTypes().ConvertTypeForMem(ASTTy);\n\n  llvm::PointerType *PTy =\n    llvm::PointerType::get(Ty, getContext().getTargetAddressSpace(ASTTy));\n\n  StringRef MangledName = getMangledName(D);\n  return GetOrCreateLLVMGlobal(MangledName, PTy, D, IsForDefinition);\n}\n\n/// CreateRuntimeVariable - Create a new runtime global variable with the\n/// specified type and name.\nllvm::Constant *\nCodeGenModule::CreateRuntimeVariable(llvm::Type *Ty,\n                                     StringRef Name) {\n  auto PtrTy =\n      getContext().getLangOpts().OpenCL\n          ? llvm::PointerType::get(\n                Ty, getContext().getTargetAddressSpace(LangAS::opencl_global))\n          : llvm::PointerType::getUnqual(Ty);\n  auto *Ret = GetOrCreateLLVMGlobal(Name, PtrTy, nullptr);\n  setDSOLocal(cast<llvm::GlobalValue>(Ret->stripPointerCasts()));\n  return Ret;\n}\n\nvoid CodeGenModule::EmitTentativeDefinition(const VarDecl *D) {\n  assert(!D->getInit() && \"Cannot emit definite definitions here!\");\n\n  StringRef MangledName = getMangledName(D);\n  llvm::GlobalValue *GV = GetGlobalValue(MangledName);\n\n  // We already have a definition, not declaration, with the same mangled name.\n  // Emitting of declaration is not required (and actually overwrites emitted\n  // definition).\n  if (GV && !GV->isDeclaration())\n    return;\n\n  // If we have not seen a reference to this variable yet, place it into the\n  // deferred declarations table to be emitted if needed later.\n  if (!MustBeEmitted(D) && !GV) {\n      DeferredDecls[MangledName] = D;\n      return;\n  }\n\n  // The tentative definition is the only definition.\n  EmitGlobalVarDefinition(D);\n}\n\nvoid CodeGenModule::EmitExternalDeclaration(const VarDecl *D) {\n  EmitExternalVarDeclaration(D);\n}\n\nCharUnits CodeGenModule::GetTargetTypeStoreSize(llvm::Type *Ty) const {\n  return Context.toCharUnitsFromBits(\n      getDataLayout().getTypeStoreSizeInBits(Ty));\n}\n\nLangAS CodeGenModule::GetGlobalVarAddressSpace(const VarDecl *D) {\n  LangAS AddrSpace = LangAS::Default;\n  if (LangOpts.OpenCL) {\n    AddrSpace = D ? D->getType().getAddressSpace() : LangAS::opencl_global;\n    assert(AddrSpace == LangAS::opencl_global ||\n           AddrSpace == LangAS::opencl_global_device ||\n           AddrSpace == LangAS::opencl_global_host ||\n           AddrSpace == LangAS::opencl_constant ||\n           AddrSpace == LangAS::opencl_local ||\n           AddrSpace >= LangAS::FirstTargetAddressSpace);\n    return AddrSpace;\n  }\n\n  if (LangOpts.CUDA && LangOpts.CUDAIsDevice) {\n    if (D && D->hasAttr<CUDAConstantAttr>())\n      return LangAS::cuda_constant;\n    else if (D && D->hasAttr<CUDASharedAttr>())\n      return LangAS::cuda_shared;\n    else if (D && D->hasAttr<CUDADeviceAttr>())\n      return LangAS::cuda_device;\n    else if (D && D->getType().isConstQualified())\n      return LangAS::cuda_constant;\n    else\n      return LangAS::cuda_device;\n  }\n\n  if (LangOpts.OpenMP) {\n    LangAS AS;\n    if (OpenMPRuntime->hasAllocateAttributeForGlobalVar(D, AS))\n      return AS;\n  }\n  return getTargetCodeGenInfo().getGlobalVarAddressSpace(*this, D);\n}\n\nLangAS CodeGenModule::getStringLiteralAddressSpace() const {\n  // OpenCL v1.2 s6.5.3: a string literal is in the constant address space.\n  if (LangOpts.OpenCL)\n    return LangAS::opencl_constant;\n  if (auto AS = getTarget().getConstantAddressSpace())\n    return AS.getValue();\n  return LangAS::Default;\n}\n\n// In address space agnostic languages, string literals are in default address\n// space in AST. However, certain targets (e.g. amdgcn) request them to be\n// emitted in constant address space in LLVM IR. To be consistent with other\n// parts of AST, string literal global variables in constant address space\n// need to be casted to default address space before being put into address\n// map and referenced by other part of CodeGen.\n// In OpenCL, string literals are in constant address space in AST, therefore\n// they should not be casted to default address space.\nstatic llvm::Constant *\ncastStringLiteralToDefaultAddressSpace(CodeGenModule &CGM,\n                                       llvm::GlobalVariable *GV) {\n  llvm::Constant *Cast = GV;\n  if (!CGM.getLangOpts().OpenCL) {\n    if (auto AS = CGM.getTarget().getConstantAddressSpace()) {\n      if (AS != LangAS::Default)\n        Cast = CGM.getTargetCodeGenInfo().performAddrSpaceCast(\n            CGM, GV, AS.getValue(), LangAS::Default,\n            GV->getValueType()->getPointerTo(\n                CGM.getContext().getTargetAddressSpace(LangAS::Default)));\n    }\n  }\n  return Cast;\n}\n\ntemplate<typename SomeDecl>\nvoid CodeGenModule::MaybeHandleStaticInExternC(const SomeDecl *D,\n                                               llvm::GlobalValue *GV) {\n  if (!getLangOpts().CPlusPlus)\n    return;\n\n  // Must have 'used' attribute, or else inline assembly can't rely on\n  // the name existing.\n  if (!D->template hasAttr<UsedAttr>())\n    return;\n\n  // Must have internal linkage and an ordinary name.\n  if (!D->getIdentifier() || D->getFormalLinkage() != InternalLinkage)\n    return;\n\n  // Must be in an extern \"C\" context. Entities declared directly within\n  // a record are not extern \"C\" even if the record is in such a context.\n  const SomeDecl *First = D->getFirstDecl();\n  if (First->getDeclContext()->isRecord() || !First->isInExternCContext())\n    return;\n\n  // OK, this is an internal linkage entity inside an extern \"C\" linkage\n  // specification. Make a note of that so we can give it the \"expected\"\n  // mangled name if nothing else is using that name.\n  std::pair<StaticExternCMap::iterator, bool> R =\n      StaticExternCValues.insert(std::make_pair(D->getIdentifier(), GV));\n\n  // If we have multiple internal linkage entities with the same name\n  // in extern \"C\" regions, none of them gets that name.\n  if (!R.second)\n    R.first->second = nullptr;\n}\n\nstatic bool shouldBeInCOMDAT(CodeGenModule &CGM, const Decl &D) {\n  if (!CGM.supportsCOMDAT())\n    return false;\n\n  // Do not set COMDAT attribute for CUDA/HIP stub functions to prevent\n  // them being \"merged\" by the COMDAT Folding linker optimization.\n  if (D.hasAttr<CUDAGlobalAttr>())\n    return false;\n\n  if (D.hasAttr<SelectAnyAttr>())\n    return true;\n\n  GVALinkage Linkage;\n  if (auto *VD = dyn_cast<VarDecl>(&D))\n    Linkage = CGM.getContext().GetGVALinkageForVariable(VD);\n  else\n    Linkage = CGM.getContext().GetGVALinkageForFunction(cast<FunctionDecl>(&D));\n\n  switch (Linkage) {\n  case GVA_Internal:\n  case GVA_AvailableExternally:\n  case GVA_StrongExternal:\n    return false;\n  case GVA_DiscardableODR:\n  case GVA_StrongODR:\n    return true;\n  }\n  llvm_unreachable(\"No such linkage\");\n}\n\nvoid CodeGenModule::maybeSetTrivialComdat(const Decl &D,\n                                          llvm::GlobalObject &GO) {\n  if (!shouldBeInCOMDAT(*this, D))\n    return;\n  GO.setComdat(TheModule.getOrInsertComdat(GO.getName()));\n}\n\n/// Pass IsTentative as true if you want to create a tentative definition.\nvoid CodeGenModule::EmitGlobalVarDefinition(const VarDecl *D,\n                                            bool IsTentative) {\n  // OpenCL global variables of sampler type are translated to function calls,\n  // therefore no need to be translated.\n  QualType ASTTy = D->getType();\n  if (getLangOpts().OpenCL && ASTTy->isSamplerT())\n    return;\n\n  // If this is OpenMP device, check if it is legal to emit this global\n  // normally.\n  if (LangOpts.OpenMPIsDevice && OpenMPRuntime &&\n      OpenMPRuntime->emitTargetGlobalVariable(D))\n    return;\n\n  llvm::Constant *Init = nullptr;\n  bool NeedsGlobalCtor = false;\n  bool NeedsGlobalDtor =\n      D->needsDestruction(getContext()) == QualType::DK_cxx_destructor;\n\n  bool IsHIPManagedVarOnDevice =\n      getLangOpts().CUDAIsDevice && D->hasAttr<HIPManagedAttr>();\n\n  const VarDecl *InitDecl;\n  const Expr *InitExpr =\n      IsHIPManagedVarOnDevice ? nullptr : D->getAnyInitializer(InitDecl);\n\n  Optional<ConstantEmitter> emitter;\n\n  // CUDA E.2.4.1 \"__shared__ variables cannot have an initialization\n  // as part of their declaration.\"  Sema has already checked for\n  // error cases, so we just need to set Init to UndefValue.\n  bool IsCUDASharedVar =\n      getLangOpts().CUDAIsDevice && D->hasAttr<CUDASharedAttr>();\n  // Shadows of initialized device-side global variables are also left\n  // undefined.\n  bool IsCUDAShadowVar =\n      !getLangOpts().CUDAIsDevice && !D->hasAttr<HIPManagedAttr>() &&\n      (D->hasAttr<CUDAConstantAttr>() || D->hasAttr<CUDADeviceAttr>() ||\n       D->hasAttr<CUDASharedAttr>());\n  bool IsCUDADeviceShadowVar =\n      getLangOpts().CUDAIsDevice &&\n      (D->getType()->isCUDADeviceBuiltinSurfaceType() ||\n       D->getType()->isCUDADeviceBuiltinTextureType() ||\n       D->hasAttr<HIPManagedAttr>());\n  if (getLangOpts().CUDA &&\n      (IsCUDASharedVar || IsCUDAShadowVar || IsCUDADeviceShadowVar))\n    Init = llvm::UndefValue::get(getTypes().ConvertType(ASTTy));\n  else if (D->hasAttr<LoaderUninitializedAttr>())\n    Init = llvm::UndefValue::get(getTypes().ConvertType(ASTTy));\n  else if (!InitExpr) {\n    // This is a tentative definition; tentative definitions are\n    // implicitly initialized with { 0 }.\n    //\n    // Note that tentative definitions are only emitted at the end of\n    // a translation unit, so they should never have incomplete\n    // type. In addition, EmitTentativeDefinition makes sure that we\n    // never attempt to emit a tentative definition if a real one\n    // exists. A use may still exists, however, so we still may need\n    // to do a RAUW.\n    assert(!ASTTy->isIncompleteType() && \"Unexpected incomplete type\");\n    Init = EmitNullConstant(D->getType());\n  } else {\n    initializedGlobalDecl = GlobalDecl(D);\n    emitter.emplace(*this);\n    Init = emitter->tryEmitForInitializer(*InitDecl);\n\n    if (!Init) {\n      QualType T = InitExpr->getType();\n      if (D->getType()->isReferenceType())\n        T = D->getType();\n\n      if (getLangOpts().CPlusPlus) {\n        Init = EmitNullConstant(T);\n        NeedsGlobalCtor = true;\n      } else {\n        ErrorUnsupported(D, \"static initializer\");\n        Init = llvm::UndefValue::get(getTypes().ConvertType(T));\n      }\n    } else {\n      // We don't need an initializer, so remove the entry for the delayed\n      // initializer position (just in case this entry was delayed) if we\n      // also don't need to register a destructor.\n      if (getLangOpts().CPlusPlus && !NeedsGlobalDtor)\n        DelayedCXXInitPosition.erase(D);\n    }\n  }\n\n  llvm::Type* InitType = Init->getType();\n  llvm::Constant *Entry =\n      GetAddrOfGlobalVar(D, InitType, ForDefinition_t(!IsTentative));\n\n  // Strip off pointer casts if we got them.\n  Entry = Entry->stripPointerCasts();\n\n  // Entry is now either a Function or GlobalVariable.\n  auto *GV = dyn_cast<llvm::GlobalVariable>(Entry);\n\n  // We have a definition after a declaration with the wrong type.\n  // We must make a new GlobalVariable* and update everything that used OldGV\n  // (a declaration or tentative definition) with the new GlobalVariable*\n  // (which will be a definition).\n  //\n  // This happens if there is a prototype for a global (e.g.\n  // \"extern int x[];\") and then a definition of a different type (e.g.\n  // \"int x[10];\"). This also happens when an initializer has a different type\n  // from the type of the global (this happens with unions).\n  if (!GV || GV->getValueType() != InitType ||\n      GV->getType()->getAddressSpace() !=\n          getContext().getTargetAddressSpace(GetGlobalVarAddressSpace(D))) {\n\n    // Move the old entry aside so that we'll create a new one.\n    Entry->setName(StringRef());\n\n    // Make a new global with the correct type, this is now guaranteed to work.\n    GV = cast<llvm::GlobalVariable>(\n        GetAddrOfGlobalVar(D, InitType, ForDefinition_t(!IsTentative))\n            ->stripPointerCasts());\n\n    // Replace all uses of the old global with the new global\n    llvm::Constant *NewPtrForOldDecl =\n        llvm::ConstantExpr::getBitCast(GV, Entry->getType());\n    Entry->replaceAllUsesWith(NewPtrForOldDecl);\n\n    // Erase the old global, since it is no longer used.\n    cast<llvm::GlobalValue>(Entry)->eraseFromParent();\n  }\n\n  MaybeHandleStaticInExternC(D, GV);\n\n  if (D->hasAttr<AnnotateAttr>())\n    AddGlobalAnnotations(D, GV);\n\n  // Set the llvm linkage type as appropriate.\n  llvm::GlobalValue::LinkageTypes Linkage =\n      getLLVMLinkageVarDefinition(D, GV->isConstant());\n\n  // CUDA B.2.1 \"The __device__ qualifier declares a variable that resides on\n  // the device. [...]\"\n  // CUDA B.2.2 \"The __constant__ qualifier, optionally used together with\n  // __device__, declares a variable that: [...]\n  // Is accessible from all the threads within the grid and from the host\n  // through the runtime library (cudaGetSymbolAddress() / cudaGetSymbolSize()\n  // / cudaMemcpyToSymbol() / cudaMemcpyFromSymbol()).\"\n  if (GV && LangOpts.CUDA) {\n    if (LangOpts.CUDAIsDevice) {\n      if (Linkage != llvm::GlobalValue::InternalLinkage &&\n          (D->hasAttr<CUDADeviceAttr>() || D->hasAttr<CUDAConstantAttr>()))\n        GV->setExternallyInitialized(true);\n    } else {\n      getCUDARuntime().internalizeDeviceSideVar(D, Linkage);\n      getCUDARuntime().handleVarRegistration(D, *GV);\n    }\n  }\n\n  // HIP managed variables need to be emitted as declarations in device\n  // compilation.\n  if (!IsHIPManagedVarOnDevice)\n    GV->setInitializer(Init);\n  if (emitter)\n    emitter->finalize(GV);\n\n  // If it is safe to mark the global 'constant', do so now.\n  GV->setConstant(!NeedsGlobalCtor && !NeedsGlobalDtor &&\n                  isTypeConstant(D->getType(), true));\n\n  // If it is in a read-only section, mark it 'constant'.\n  if (const SectionAttr *SA = D->getAttr<SectionAttr>()) {\n    const ASTContext::SectionInfo &SI = Context.SectionInfos[SA->getName()];\n    if ((SI.SectionFlags & ASTContext::PSF_Write) == 0)\n      GV->setConstant(true);\n  }\n\n  GV->setAlignment(getContext().getDeclAlign(D).getAsAlign());\n\n  // On Darwin, unlike other Itanium C++ ABI platforms, the thread-wrapper\n  // function is only defined alongside the variable, not also alongside\n  // callers. Normally, all accesses to a thread_local go through the\n  // thread-wrapper in order to ensure initialization has occurred, underlying\n  // variable will never be used other than the thread-wrapper, so it can be\n  // converted to internal linkage.\n  //\n  // However, if the variable has the 'constinit' attribute, it _can_ be\n  // referenced directly, without calling the thread-wrapper, so the linkage\n  // must not be changed.\n  //\n  // Additionally, if the variable isn't plain external linkage, e.g. if it's\n  // weak or linkonce, the de-duplication semantics are important to preserve,\n  // so we don't change the linkage.\n  if (D->getTLSKind() == VarDecl::TLS_Dynamic &&\n      Linkage == llvm::GlobalValue::ExternalLinkage &&\n      Context.getTargetInfo().getTriple().isOSDarwin() &&\n      !D->hasAttr<ConstInitAttr>())\n    Linkage = llvm::GlobalValue::InternalLinkage;\n\n  GV->setLinkage(Linkage);\n  if (D->hasAttr<DLLImportAttr>())\n    GV->setDLLStorageClass(llvm::GlobalVariable::DLLImportStorageClass);\n  else if (D->hasAttr<DLLExportAttr>())\n    GV->setDLLStorageClass(llvm::GlobalVariable::DLLExportStorageClass);\n  else\n    GV->setDLLStorageClass(llvm::GlobalVariable::DefaultStorageClass);\n\n  if (Linkage == llvm::GlobalVariable::CommonLinkage) {\n    // common vars aren't constant even if declared const.\n    GV->setConstant(false);\n    // Tentative definition of global variables may be initialized with\n    // non-zero null pointers. In this case they should have weak linkage\n    // since common linkage must have zero initializer and must not have\n    // explicit section therefore cannot have non-zero initial value.\n    if (!GV->getInitializer()->isNullValue())\n      GV->setLinkage(llvm::GlobalVariable::WeakAnyLinkage);\n  }\n\n  setNonAliasAttributes(D, GV);\n\n  if (D->getTLSKind() && !GV->isThreadLocal()) {\n    if (D->getTLSKind() == VarDecl::TLS_Dynamic)\n      CXXThreadLocals.push_back(D);\n    setTLSMode(GV, *D);\n  }\n\n  maybeSetTrivialComdat(*D, *GV);\n\n  // Emit the initializer function if necessary.\n  if (NeedsGlobalCtor || NeedsGlobalDtor)\n    EmitCXXGlobalVarDeclInitFunc(D, GV, NeedsGlobalCtor);\n\n  SanitizerMD->reportGlobalToASan(GV, *D, NeedsGlobalCtor);\n\n  // Emit global variable debug information.\n  if (CGDebugInfo *DI = getModuleDebugInfo())\n    if (getCodeGenOpts().hasReducedDebugInfo())\n      DI->EmitGlobalVariable(GV, D);\n}\n\nvoid CodeGenModule::EmitExternalVarDeclaration(const VarDecl *D) {\n  if (CGDebugInfo *DI = getModuleDebugInfo())\n    if (getCodeGenOpts().hasReducedDebugInfo()) {\n      QualType ASTTy = D->getType();\n      llvm::Type *Ty = getTypes().ConvertTypeForMem(D->getType());\n      llvm::PointerType *PTy =\n          llvm::PointerType::get(Ty, getContext().getTargetAddressSpace(ASTTy));\n      llvm::Constant *GV = GetOrCreateLLVMGlobal(D->getName(), PTy, D);\n      DI->EmitExternalVariable(\n          cast<llvm::GlobalVariable>(GV->stripPointerCasts()), D);\n    }\n}\n\nstatic bool isVarDeclStrongDefinition(const ASTContext &Context,\n                                      CodeGenModule &CGM, const VarDecl *D,\n                                      bool NoCommon) {\n  // Don't give variables common linkage if -fno-common was specified unless it\n  // was overridden by a NoCommon attribute.\n  if ((NoCommon || D->hasAttr<NoCommonAttr>()) && !D->hasAttr<CommonAttr>())\n    return true;\n\n  // C11 6.9.2/2:\n  //   A declaration of an identifier for an object that has file scope without\n  //   an initializer, and without a storage-class specifier or with the\n  //   storage-class specifier static, constitutes a tentative definition.\n  if (D->getInit() || D->hasExternalStorage())\n    return true;\n\n  // A variable cannot be both common and exist in a section.\n  if (D->hasAttr<SectionAttr>())\n    return true;\n\n  // A variable cannot be both common and exist in a section.\n  // We don't try to determine which is the right section in the front-end.\n  // If no specialized section name is applicable, it will resort to default.\n  if (D->hasAttr<PragmaClangBSSSectionAttr>() ||\n      D->hasAttr<PragmaClangDataSectionAttr>() ||\n      D->hasAttr<PragmaClangRelroSectionAttr>() ||\n      D->hasAttr<PragmaClangRodataSectionAttr>())\n    return true;\n\n  // Thread local vars aren't considered common linkage.\n  if (D->getTLSKind())\n    return true;\n\n  // Tentative definitions marked with WeakImportAttr are true definitions.\n  if (D->hasAttr<WeakImportAttr>())\n    return true;\n\n  // A variable cannot be both common and exist in a comdat.\n  if (shouldBeInCOMDAT(CGM, *D))\n    return true;\n\n  // Declarations with a required alignment do not have common linkage in MSVC\n  // mode.\n  if (Context.getTargetInfo().getCXXABI().isMicrosoft()) {\n    if (D->hasAttr<AlignedAttr>())\n      return true;\n    QualType VarType = D->getType();\n    if (Context.isAlignmentRequired(VarType))\n      return true;\n\n    if (const auto *RT = VarType->getAs<RecordType>()) {\n      const RecordDecl *RD = RT->getDecl();\n      for (const FieldDecl *FD : RD->fields()) {\n        if (FD->isBitField())\n          continue;\n        if (FD->hasAttr<AlignedAttr>())\n          return true;\n        if (Context.isAlignmentRequired(FD->getType()))\n          return true;\n      }\n    }\n  }\n\n  // Microsoft's link.exe doesn't support alignments greater than 32 bytes for\n  // common symbols, so symbols with greater alignment requirements cannot be\n  // common.\n  // Other COFF linkers (ld.bfd and LLD) support arbitrary power-of-two\n  // alignments for common symbols via the aligncomm directive, so this\n  // restriction only applies to MSVC environments.\n  if (Context.getTargetInfo().getTriple().isKnownWindowsMSVCEnvironment() &&\n      Context.getTypeAlignIfKnown(D->getType()) >\n          Context.toBits(CharUnits::fromQuantity(32)))\n    return true;\n\n  return false;\n}\n\nllvm::GlobalValue::LinkageTypes CodeGenModule::getLLVMLinkageForDeclarator(\n    const DeclaratorDecl *D, GVALinkage Linkage, bool IsConstantVariable) {\n  if (Linkage == GVA_Internal)\n    return llvm::Function::InternalLinkage;\n\n  if (D->hasAttr<WeakAttr>()) {\n    if (IsConstantVariable)\n      return llvm::GlobalVariable::WeakODRLinkage;\n    else\n      return llvm::GlobalVariable::WeakAnyLinkage;\n  }\n\n  if (const auto *FD = D->getAsFunction())\n    if (FD->isMultiVersion() && Linkage == GVA_AvailableExternally)\n      return llvm::GlobalVariable::LinkOnceAnyLinkage;\n\n  // We are guaranteed to have a strong definition somewhere else,\n  // so we can use available_externally linkage.\n  if (Linkage == GVA_AvailableExternally)\n    return llvm::GlobalValue::AvailableExternallyLinkage;\n\n  // Note that Apple's kernel linker doesn't support symbol\n  // coalescing, so we need to avoid linkonce and weak linkages there.\n  // Normally, this means we just map to internal, but for explicit\n  // instantiations we'll map to external.\n\n  // In C++, the compiler has to emit a definition in every translation unit\n  // that references the function.  We should use linkonce_odr because\n  // a) if all references in this translation unit are optimized away, we\n  // don't need to codegen it.  b) if the function persists, it needs to be\n  // merged with other definitions. c) C++ has the ODR, so we know the\n  // definition is dependable.\n  if (Linkage == GVA_DiscardableODR)\n    return !Context.getLangOpts().AppleKext ? llvm::Function::LinkOnceODRLinkage\n                                            : llvm::Function::InternalLinkage;\n\n  // An explicit instantiation of a template has weak linkage, since\n  // explicit instantiations can occur in multiple translation units\n  // and must all be equivalent. However, we are not allowed to\n  // throw away these explicit instantiations.\n  //\n  // CUDA/HIP: For -fno-gpu-rdc case, device code is limited to one TU,\n  // so say that CUDA templates are either external (for kernels) or internal.\n  // This lets llvm perform aggressive inter-procedural optimizations. For\n  // -fgpu-rdc case, device function calls across multiple TU's are allowed,\n  // therefore we need to follow the normal linkage paradigm.\n  if (Linkage == GVA_StrongODR) {\n    if (getLangOpts().AppleKext)\n      return llvm::Function::ExternalLinkage;\n    if (getLangOpts().CUDA && getLangOpts().CUDAIsDevice &&\n        !getLangOpts().GPURelocatableDeviceCode)\n      return D->hasAttr<CUDAGlobalAttr>() ? llvm::Function::ExternalLinkage\n                                          : llvm::Function::InternalLinkage;\n    return llvm::Function::WeakODRLinkage;\n  }\n\n  // C++ doesn't have tentative definitions and thus cannot have common\n  // linkage.\n  if (!getLangOpts().CPlusPlus && isa<VarDecl>(D) &&\n      !isVarDeclStrongDefinition(Context, *this, cast<VarDecl>(D),\n                                 CodeGenOpts.NoCommon))\n    return llvm::GlobalVariable::CommonLinkage;\n\n  // selectany symbols are externally visible, so use weak instead of\n  // linkonce.  MSVC optimizes away references to const selectany globals, so\n  // all definitions should be the same and ODR linkage should be used.\n  // http://msdn.microsoft.com/en-us/library/5tkz6s71.aspx\n  if (D->hasAttr<SelectAnyAttr>())\n    return llvm::GlobalVariable::WeakODRLinkage;\n\n  // Otherwise, we have strong external linkage.\n  assert(Linkage == GVA_StrongExternal);\n  return llvm::GlobalVariable::ExternalLinkage;\n}\n\nllvm::GlobalValue::LinkageTypes CodeGenModule::getLLVMLinkageVarDefinition(\n    const VarDecl *VD, bool IsConstant) {\n  GVALinkage Linkage = getContext().GetGVALinkageForVariable(VD);\n  return getLLVMLinkageForDeclarator(VD, Linkage, IsConstant);\n}\n\n/// Replace the uses of a function that was declared with a non-proto type.\n/// We want to silently drop extra arguments from call sites\nstatic void replaceUsesOfNonProtoConstant(llvm::Constant *old,\n                                          llvm::Function *newFn) {\n  // Fast path.\n  if (old->use_empty()) return;\n\n  llvm::Type *newRetTy = newFn->getReturnType();\n  SmallVector<llvm::Value*, 4> newArgs;\n  SmallVector<llvm::OperandBundleDef, 1> newBundles;\n\n  for (llvm::Value::use_iterator ui = old->use_begin(), ue = old->use_end();\n         ui != ue; ) {\n    llvm::Value::use_iterator use = ui++; // Increment before the use is erased.\n    llvm::User *user = use->getUser();\n\n    // Recognize and replace uses of bitcasts.  Most calls to\n    // unprototyped functions will use bitcasts.\n    if (auto *bitcast = dyn_cast<llvm::ConstantExpr>(user)) {\n      if (bitcast->getOpcode() == llvm::Instruction::BitCast)\n        replaceUsesOfNonProtoConstant(bitcast, newFn);\n      continue;\n    }\n\n    // Recognize calls to the function.\n    llvm::CallBase *callSite = dyn_cast<llvm::CallBase>(user);\n    if (!callSite) continue;\n    if (!callSite->isCallee(&*use))\n      continue;\n\n    // If the return types don't match exactly, then we can't\n    // transform this call unless it's dead.\n    if (callSite->getType() != newRetTy && !callSite->use_empty())\n      continue;\n\n    // Get the call site's attribute list.\n    SmallVector<llvm::AttributeSet, 8> newArgAttrs;\n    llvm::AttributeList oldAttrs = callSite->getAttributes();\n\n    // If the function was passed too few arguments, don't transform.\n    unsigned newNumArgs = newFn->arg_size();\n    if (callSite->arg_size() < newNumArgs)\n      continue;\n\n    // If extra arguments were passed, we silently drop them.\n    // If any of the types mismatch, we don't transform.\n    unsigned argNo = 0;\n    bool dontTransform = false;\n    for (llvm::Argument &A : newFn->args()) {\n      if (callSite->getArgOperand(argNo)->getType() != A.getType()) {\n        dontTransform = true;\n        break;\n      }\n\n      // Add any parameter attributes.\n      newArgAttrs.push_back(oldAttrs.getParamAttributes(argNo));\n      argNo++;\n    }\n    if (dontTransform)\n      continue;\n\n    // Okay, we can transform this.  Create the new call instruction and copy\n    // over the required information.\n    newArgs.append(callSite->arg_begin(), callSite->arg_begin() + argNo);\n\n    // Copy over any operand bundles.\n    callSite->getOperandBundlesAsDefs(newBundles);\n\n    llvm::CallBase *newCall;\n    if (dyn_cast<llvm::CallInst>(callSite)) {\n      newCall =\n          llvm::CallInst::Create(newFn, newArgs, newBundles, \"\", callSite);\n    } else {\n      auto *oldInvoke = cast<llvm::InvokeInst>(callSite);\n      newCall = llvm::InvokeInst::Create(newFn, oldInvoke->getNormalDest(),\n                                         oldInvoke->getUnwindDest(), newArgs,\n                                         newBundles, \"\", callSite);\n    }\n    newArgs.clear(); // for the next iteration\n\n    if (!newCall->getType()->isVoidTy())\n      newCall->takeName(callSite);\n    newCall->setAttributes(llvm::AttributeList::get(\n        newFn->getContext(), oldAttrs.getFnAttributes(),\n        oldAttrs.getRetAttributes(), newArgAttrs));\n    newCall->setCallingConv(callSite->getCallingConv());\n\n    // Finally, remove the old call, replacing any uses with the new one.\n    if (!callSite->use_empty())\n      callSite->replaceAllUsesWith(newCall);\n\n    // Copy debug location attached to CI.\n    if (callSite->getDebugLoc())\n      newCall->setDebugLoc(callSite->getDebugLoc());\n\n    callSite->eraseFromParent();\n  }\n}\n\n/// ReplaceUsesOfNonProtoTypeWithRealFunction - This function is called when we\n/// implement a function with no prototype, e.g. \"int foo() {}\".  If there are\n/// existing call uses of the old function in the module, this adjusts them to\n/// call the new function directly.\n///\n/// This is not just a cleanup: the always_inline pass requires direct calls to\n/// functions to be able to inline them.  If there is a bitcast in the way, it\n/// won't inline them.  Instcombine normally deletes these calls, but it isn't\n/// run at -O0.\nstatic void ReplaceUsesOfNonProtoTypeWithRealFunction(llvm::GlobalValue *Old,\n                                                      llvm::Function *NewFn) {\n  // If we're redefining a global as a function, don't transform it.\n  if (!isa<llvm::Function>(Old)) return;\n\n  replaceUsesOfNonProtoConstant(Old, NewFn);\n}\n\nvoid CodeGenModule::HandleCXXStaticMemberVarInstantiation(VarDecl *VD) {\n  auto DK = VD->isThisDeclarationADefinition();\n  if (DK == VarDecl::Definition && VD->hasAttr<DLLImportAttr>())\n    return;\n\n  TemplateSpecializationKind TSK = VD->getTemplateSpecializationKind();\n  // If we have a definition, this might be a deferred decl. If the\n  // instantiation is explicit, make sure we emit it at the end.\n  if (VD->getDefinition() && TSK == TSK_ExplicitInstantiationDefinition)\n    GetAddrOfGlobalVar(VD);\n\n  EmitTopLevelDecl(VD);\n}\n\nvoid CodeGenModule::EmitGlobalFunctionDefinition(GlobalDecl GD,\n                                                 llvm::GlobalValue *GV) {\n  const auto *D = cast<FunctionDecl>(GD.getDecl());\n\n  // Compute the function info and LLVM type.\n  const CGFunctionInfo &FI = getTypes().arrangeGlobalDeclaration(GD);\n  llvm::FunctionType *Ty = getTypes().GetFunctionType(FI);\n\n  // Get or create the prototype for the function.\n  if (!GV || (GV->getValueType() != Ty))\n    GV = cast<llvm::GlobalValue>(GetAddrOfFunction(GD, Ty, /*ForVTable=*/false,\n                                                   /*DontDefer=*/true,\n                                                   ForDefinition));\n\n  // Already emitted.\n  if (!GV->isDeclaration())\n    return;\n\n  // We need to set linkage and visibility on the function before\n  // generating code for it because various parts of IR generation\n  // want to propagate this information down (e.g. to local static\n  // declarations).\n  auto *Fn = cast<llvm::Function>(GV);\n  setFunctionLinkage(GD, Fn);\n\n  // FIXME: this is redundant with part of setFunctionDefinitionAttributes\n  setGVProperties(Fn, GD);\n\n  MaybeHandleStaticInExternC(D, Fn);\n\n  maybeSetTrivialComdat(*D, *Fn);\n\n  // Set CodeGen attributes that represent floating point environment.\n  setLLVMFunctionFEnvAttributes(D, Fn);\n\n  CodeGenFunction(*this).GenerateCode(GD, Fn, FI);\n\n  setNonAliasAttributes(GD, Fn);\n  SetLLVMFunctionAttributesForDefinition(D, Fn);\n\n  if (const ConstructorAttr *CA = D->getAttr<ConstructorAttr>())\n    AddGlobalCtor(Fn, CA->getPriority());\n  if (const DestructorAttr *DA = D->getAttr<DestructorAttr>())\n    AddGlobalDtor(Fn, DA->getPriority(), true);\n  if (D->hasAttr<AnnotateAttr>())\n    AddGlobalAnnotations(D, Fn);\n}\n\nvoid CodeGenModule::EmitAliasDefinition(GlobalDecl GD) {\n  const auto *D = cast<ValueDecl>(GD.getDecl());\n  const AliasAttr *AA = D->getAttr<AliasAttr>();\n  assert(AA && \"Not an alias?\");\n\n  StringRef MangledName = getMangledName(GD);\n\n  if (AA->getAliasee() == MangledName) {\n    Diags.Report(AA->getLocation(), diag::err_cyclic_alias) << 0;\n    return;\n  }\n\n  // If there is a definition in the module, then it wins over the alias.\n  // This is dubious, but allow it to be safe.  Just ignore the alias.\n  llvm::GlobalValue *Entry = GetGlobalValue(MangledName);\n  if (Entry && !Entry->isDeclaration())\n    return;\n\n  Aliases.push_back(GD);\n\n  llvm::Type *DeclTy = getTypes().ConvertTypeForMem(D->getType());\n\n  // Create a reference to the named value.  This ensures that it is emitted\n  // if a deferred decl.\n  llvm::Constant *Aliasee;\n  llvm::GlobalValue::LinkageTypes LT;\n  if (isa<llvm::FunctionType>(DeclTy)) {\n    Aliasee = GetOrCreateLLVMFunction(AA->getAliasee(), DeclTy, GD,\n                                      /*ForVTable=*/false);\n    LT = getFunctionLinkage(GD);\n  } else {\n    Aliasee = GetOrCreateLLVMGlobal(AA->getAliasee(),\n                                    llvm::PointerType::getUnqual(DeclTy),\n                                    /*D=*/nullptr);\n    if (const auto *VD = dyn_cast<VarDecl>(GD.getDecl()))\n      LT = getLLVMLinkageVarDefinition(VD, D->getType().isConstQualified());\n    else\n      LT = getFunctionLinkage(GD);\n  }\n\n  // Create the new alias itself, but don't set a name yet.\n  unsigned AS = Aliasee->getType()->getPointerAddressSpace();\n  auto *GA =\n      llvm::GlobalAlias::create(DeclTy, AS, LT, \"\", Aliasee, &getModule());\n\n  if (Entry) {\n    if (GA->getAliasee() == Entry) {\n      Diags.Report(AA->getLocation(), diag::err_cyclic_alias) << 0;\n      return;\n    }\n\n    assert(Entry->isDeclaration());\n\n    // If there is a declaration in the module, then we had an extern followed\n    // by the alias, as in:\n    //   extern int test6();\n    //   ...\n    //   int test6() __attribute__((alias(\"test7\")));\n    //\n    // Remove it and replace uses of it with the alias.\n    GA->takeName(Entry);\n\n    Entry->replaceAllUsesWith(llvm::ConstantExpr::getBitCast(GA,\n                                                          Entry->getType()));\n    Entry->eraseFromParent();\n  } else {\n    GA->setName(MangledName);\n  }\n\n  // Set attributes which are particular to an alias; this is a\n  // specialization of the attributes which may be set on a global\n  // variable/function.\n  if (D->hasAttr<WeakAttr>() || D->hasAttr<WeakRefAttr>() ||\n      D->isWeakImported()) {\n    GA->setLinkage(llvm::Function::WeakAnyLinkage);\n  }\n\n  if (const auto *VD = dyn_cast<VarDecl>(D))\n    if (VD->getTLSKind())\n      setTLSMode(GA, *VD);\n\n  SetCommonAttributes(GD, GA);\n}\n\nvoid CodeGenModule::emitIFuncDefinition(GlobalDecl GD) {\n  const auto *D = cast<ValueDecl>(GD.getDecl());\n  const IFuncAttr *IFA = D->getAttr<IFuncAttr>();\n  assert(IFA && \"Not an ifunc?\");\n\n  StringRef MangledName = getMangledName(GD);\n\n  if (IFA->getResolver() == MangledName) {\n    Diags.Report(IFA->getLocation(), diag::err_cyclic_alias) << 1;\n    return;\n  }\n\n  // Report an error if some definition overrides ifunc.\n  llvm::GlobalValue *Entry = GetGlobalValue(MangledName);\n  if (Entry && !Entry->isDeclaration()) {\n    GlobalDecl OtherGD;\n    if (lookupRepresentativeDecl(MangledName, OtherGD) &&\n        DiagnosedConflictingDefinitions.insert(GD).second) {\n      Diags.Report(D->getLocation(), diag::err_duplicate_mangled_name)\n          << MangledName;\n      Diags.Report(OtherGD.getDecl()->getLocation(),\n                   diag::note_previous_definition);\n    }\n    return;\n  }\n\n  Aliases.push_back(GD);\n\n  llvm::Type *DeclTy = getTypes().ConvertTypeForMem(D->getType());\n  llvm::Constant *Resolver =\n      GetOrCreateLLVMFunction(IFA->getResolver(), DeclTy, GD,\n                              /*ForVTable=*/false);\n  llvm::GlobalIFunc *GIF =\n      llvm::GlobalIFunc::create(DeclTy, 0, llvm::Function::ExternalLinkage,\n                                \"\", Resolver, &getModule());\n  if (Entry) {\n    if (GIF->getResolver() == Entry) {\n      Diags.Report(IFA->getLocation(), diag::err_cyclic_alias) << 1;\n      return;\n    }\n    assert(Entry->isDeclaration());\n\n    // If there is a declaration in the module, then we had an extern followed\n    // by the ifunc, as in:\n    //   extern int test();\n    //   ...\n    //   int test() __attribute__((ifunc(\"resolver\")));\n    //\n    // Remove it and replace uses of it with the ifunc.\n    GIF->takeName(Entry);\n\n    Entry->replaceAllUsesWith(llvm::ConstantExpr::getBitCast(GIF,\n                                                          Entry->getType()));\n    Entry->eraseFromParent();\n  } else\n    GIF->setName(MangledName);\n\n  SetCommonAttributes(GD, GIF);\n}\n\nllvm::Function *CodeGenModule::getIntrinsic(unsigned IID,\n                                            ArrayRef<llvm::Type*> Tys) {\n  return llvm::Intrinsic::getDeclaration(&getModule(), (llvm::Intrinsic::ID)IID,\n                                         Tys);\n}\n\nstatic llvm::StringMapEntry<llvm::GlobalVariable *> &\nGetConstantCFStringEntry(llvm::StringMap<llvm::GlobalVariable *> &Map,\n                         const StringLiteral *Literal, bool TargetIsLSB,\n                         bool &IsUTF16, unsigned &StringLength) {\n  StringRef String = Literal->getString();\n  unsigned NumBytes = String.size();\n\n  // Check for simple case.\n  if (!Literal->containsNonAsciiOrNull()) {\n    StringLength = NumBytes;\n    return *Map.insert(std::make_pair(String, nullptr)).first;\n  }\n\n  // Otherwise, convert the UTF8 literals into a string of shorts.\n  IsUTF16 = true;\n\n  SmallVector<llvm::UTF16, 128> ToBuf(NumBytes + 1); // +1 for ending nulls.\n  const llvm::UTF8 *FromPtr = (const llvm::UTF8 *)String.data();\n  llvm::UTF16 *ToPtr = &ToBuf[0];\n\n  (void)llvm::ConvertUTF8toUTF16(&FromPtr, FromPtr + NumBytes, &ToPtr,\n                                 ToPtr + NumBytes, llvm::strictConversion);\n\n  // ConvertUTF8toUTF16 returns the length in ToPtr.\n  StringLength = ToPtr - &ToBuf[0];\n\n  // Add an explicit null.\n  *ToPtr = 0;\n  return *Map.insert(std::make_pair(\n                         StringRef(reinterpret_cast<const char *>(ToBuf.data()),\n                                   (StringLength + 1) * 2),\n                         nullptr)).first;\n}\n\nConstantAddress\nCodeGenModule::GetAddrOfConstantCFString(const StringLiteral *Literal) {\n  unsigned StringLength = 0;\n  bool isUTF16 = false;\n  llvm::StringMapEntry<llvm::GlobalVariable *> &Entry =\n      GetConstantCFStringEntry(CFConstantStringMap, Literal,\n                               getDataLayout().isLittleEndian(), isUTF16,\n                               StringLength);\n\n  if (auto *C = Entry.second)\n    return ConstantAddress(C, CharUnits::fromQuantity(C->getAlignment()));\n\n  llvm::Constant *Zero = llvm::Constant::getNullValue(Int32Ty);\n  llvm::Constant *Zeros[] = { Zero, Zero };\n\n  const ASTContext &Context = getContext();\n  const llvm::Triple &Triple = getTriple();\n\n  const auto CFRuntime = getLangOpts().CFRuntime;\n  const bool IsSwiftABI =\n      static_cast<unsigned>(CFRuntime) >=\n      static_cast<unsigned>(LangOptions::CoreFoundationABI::Swift);\n  const bool IsSwift4_1 = CFRuntime == LangOptions::CoreFoundationABI::Swift4_1;\n\n  // If we don't already have it, get __CFConstantStringClassReference.\n  if (!CFConstantStringClassRef) {\n    const char *CFConstantStringClassName = \"__CFConstantStringClassReference\";\n    llvm::Type *Ty = getTypes().ConvertType(getContext().IntTy);\n    Ty = llvm::ArrayType::get(Ty, 0);\n\n    switch (CFRuntime) {\n    default: break;\n    case LangOptions::CoreFoundationABI::Swift: LLVM_FALLTHROUGH;\n    case LangOptions::CoreFoundationABI::Swift5_0:\n      CFConstantStringClassName =\n          Triple.isOSDarwin() ? \"$s15SwiftFoundation19_NSCFConstantStringCN\"\n                              : \"$s10Foundation19_NSCFConstantStringCN\";\n      Ty = IntPtrTy;\n      break;\n    case LangOptions::CoreFoundationABI::Swift4_2:\n      CFConstantStringClassName =\n          Triple.isOSDarwin() ? \"$S15SwiftFoundation19_NSCFConstantStringCN\"\n                              : \"$S10Foundation19_NSCFConstantStringCN\";\n      Ty = IntPtrTy;\n      break;\n    case LangOptions::CoreFoundationABI::Swift4_1:\n      CFConstantStringClassName =\n          Triple.isOSDarwin() ? \"__T015SwiftFoundation19_NSCFConstantStringCN\"\n                              : \"__T010Foundation19_NSCFConstantStringCN\";\n      Ty = IntPtrTy;\n      break;\n    }\n\n    llvm::Constant *C = CreateRuntimeVariable(Ty, CFConstantStringClassName);\n\n    if (Triple.isOSBinFormatELF() || Triple.isOSBinFormatCOFF()) {\n      llvm::GlobalValue *GV = nullptr;\n\n      if ((GV = dyn_cast<llvm::GlobalValue>(C))) {\n        IdentifierInfo &II = Context.Idents.get(GV->getName());\n        TranslationUnitDecl *TUDecl = Context.getTranslationUnitDecl();\n        DeclContext *DC = TranslationUnitDecl::castToDeclContext(TUDecl);\n\n        const VarDecl *VD = nullptr;\n        for (const auto &Result : DC->lookup(&II))\n          if ((VD = dyn_cast<VarDecl>(Result)))\n            break;\n\n        if (Triple.isOSBinFormatELF()) {\n          if (!VD)\n            GV->setLinkage(llvm::GlobalValue::ExternalLinkage);\n        } else {\n          GV->setLinkage(llvm::GlobalValue::ExternalLinkage);\n          if (!VD || !VD->hasAttr<DLLExportAttr>())\n            GV->setDLLStorageClass(llvm::GlobalValue::DLLImportStorageClass);\n          else\n            GV->setDLLStorageClass(llvm::GlobalValue::DLLExportStorageClass);\n        }\n\n        setDSOLocal(GV);\n      }\n    }\n\n    // Decay array -> ptr\n    CFConstantStringClassRef =\n        IsSwiftABI ? llvm::ConstantExpr::getPtrToInt(C, Ty)\n                   : llvm::ConstantExpr::getGetElementPtr(Ty, C, Zeros);\n  }\n\n  QualType CFTy = Context.getCFConstantStringType();\n\n  auto *STy = cast<llvm::StructType>(getTypes().ConvertType(CFTy));\n\n  ConstantInitBuilder Builder(*this);\n  auto Fields = Builder.beginStruct(STy);\n\n  // Class pointer.\n  Fields.add(cast<llvm::ConstantExpr>(CFConstantStringClassRef));\n\n  // Flags.\n  if (IsSwiftABI) {\n    Fields.addInt(IntPtrTy, IsSwift4_1 ? 0x05 : 0x01);\n    Fields.addInt(Int64Ty, isUTF16 ? 0x07d0 : 0x07c8);\n  } else {\n    Fields.addInt(IntTy, isUTF16 ? 0x07d0 : 0x07C8);\n  }\n\n  // String pointer.\n  llvm::Constant *C = nullptr;\n  if (isUTF16) {\n    auto Arr = llvm::makeArrayRef(\n        reinterpret_cast<uint16_t *>(const_cast<char *>(Entry.first().data())),\n        Entry.first().size() / 2);\n    C = llvm::ConstantDataArray::get(VMContext, Arr);\n  } else {\n    C = llvm::ConstantDataArray::getString(VMContext, Entry.first());\n  }\n\n  // Note: -fwritable-strings doesn't make the backing store strings of\n  // CFStrings writable. (See <rdar://problem/10657500>)\n  auto *GV =\n      new llvm::GlobalVariable(getModule(), C->getType(), /*isConstant=*/true,\n                               llvm::GlobalValue::PrivateLinkage, C, \".str\");\n  GV->setUnnamedAddr(llvm::GlobalValue::UnnamedAddr::Global);\n  // Don't enforce the target's minimum global alignment, since the only use\n  // of the string is via this class initializer.\n  CharUnits Align = isUTF16 ? Context.getTypeAlignInChars(Context.ShortTy)\n                            : Context.getTypeAlignInChars(Context.CharTy);\n  GV->setAlignment(Align.getAsAlign());\n\n  // FIXME: We set the section explicitly to avoid a bug in ld64 224.1.\n  // Without it LLVM can merge the string with a non unnamed_addr one during\n  // LTO.  Doing that changes the section it ends in, which surprises ld64.\n  if (Triple.isOSBinFormatMachO())\n    GV->setSection(isUTF16 ? \"__TEXT,__ustring\"\n                           : \"__TEXT,__cstring,cstring_literals\");\n  // Make sure the literal ends up in .rodata to allow for safe ICF and for\n  // the static linker to adjust permissions to read-only later on.\n  else if (Triple.isOSBinFormatELF())\n    GV->setSection(\".rodata\");\n\n  // String.\n  llvm::Constant *Str =\n      llvm::ConstantExpr::getGetElementPtr(GV->getValueType(), GV, Zeros);\n\n  if (isUTF16)\n    // Cast the UTF16 string to the correct type.\n    Str = llvm::ConstantExpr::getBitCast(Str, Int8PtrTy);\n  Fields.add(Str);\n\n  // String length.\n  llvm::IntegerType *LengthTy =\n      llvm::IntegerType::get(getModule().getContext(),\n                             Context.getTargetInfo().getLongWidth());\n  if (IsSwiftABI) {\n    if (CFRuntime == LangOptions::CoreFoundationABI::Swift4_1 ||\n        CFRuntime == LangOptions::CoreFoundationABI::Swift4_2)\n      LengthTy = Int32Ty;\n    else\n      LengthTy = IntPtrTy;\n  }\n  Fields.addInt(LengthTy, StringLength);\n\n  // Swift ABI requires 8-byte alignment to ensure that the _Atomic(uint64_t) is\n  // properly aligned on 32-bit platforms.\n  CharUnits Alignment =\n      IsSwiftABI ? Context.toCharUnitsFromBits(64) : getPointerAlign();\n\n  // The struct.\n  GV = Fields.finishAndCreateGlobal(\"_unnamed_cfstring_\", Alignment,\n                                    /*isConstant=*/false,\n                                    llvm::GlobalVariable::PrivateLinkage);\n  GV->addAttribute(\"objc_arc_inert\");\n  switch (Triple.getObjectFormat()) {\n  case llvm::Triple::UnknownObjectFormat:\n    llvm_unreachable(\"unknown file format\");\n  case llvm::Triple::GOFF:\n    llvm_unreachable(\"GOFF is not yet implemented\");\n  case llvm::Triple::XCOFF:\n    llvm_unreachable(\"XCOFF is not yet implemented\");\n  case llvm::Triple::COFF:\n  case llvm::Triple::ELF:\n  case llvm::Triple::Wasm:\n    GV->setSection(\"cfstring\");\n    break;\n  case llvm::Triple::MachO:\n    GV->setSection(\"__DATA,__cfstring\");\n    break;\n  }\n  Entry.second = GV;\n\n  return ConstantAddress(GV, Alignment);\n}\n\nbool CodeGenModule::getExpressionLocationsEnabled() const {\n  return !CodeGenOpts.EmitCodeView || CodeGenOpts.DebugColumnInfo;\n}\n\nQualType CodeGenModule::getObjCFastEnumerationStateType() {\n  if (ObjCFastEnumerationStateType.isNull()) {\n    RecordDecl *D = Context.buildImplicitRecord(\"__objcFastEnumerationState\");\n    D->startDefinition();\n\n    QualType FieldTypes[] = {\n      Context.UnsignedLongTy,\n      Context.getPointerType(Context.getObjCIdType()),\n      Context.getPointerType(Context.UnsignedLongTy),\n      Context.getConstantArrayType(Context.UnsignedLongTy,\n                           llvm::APInt(32, 5), nullptr, ArrayType::Normal, 0)\n    };\n\n    for (size_t i = 0; i < 4; ++i) {\n      FieldDecl *Field = FieldDecl::Create(Context,\n                                           D,\n                                           SourceLocation(),\n                                           SourceLocation(), nullptr,\n                                           FieldTypes[i], /*TInfo=*/nullptr,\n                                           /*BitWidth=*/nullptr,\n                                           /*Mutable=*/false,\n                                           ICIS_NoInit);\n      Field->setAccess(AS_public);\n      D->addDecl(Field);\n    }\n\n    D->completeDefinition();\n    ObjCFastEnumerationStateType = Context.getTagDeclType(D);\n  }\n\n  return ObjCFastEnumerationStateType;\n}\n\nllvm::Constant *\nCodeGenModule::GetConstantArrayFromStringLiteral(const StringLiteral *E) {\n  assert(!E->getType()->isPointerType() && \"Strings are always arrays\");\n\n  // Don't emit it as the address of the string, emit the string data itself\n  // as an inline array.\n  if (E->getCharByteWidth() == 1) {\n    SmallString<64> Str(E->getString());\n\n    // Resize the string to the right size, which is indicated by its type.\n    const ConstantArrayType *CAT = Context.getAsConstantArrayType(E->getType());\n    Str.resize(CAT->getSize().getZExtValue());\n    return llvm::ConstantDataArray::getString(VMContext, Str, false);\n  }\n\n  auto *AType = cast<llvm::ArrayType>(getTypes().ConvertType(E->getType()));\n  llvm::Type *ElemTy = AType->getElementType();\n  unsigned NumElements = AType->getNumElements();\n\n  // Wide strings have either 2-byte or 4-byte elements.\n  if (ElemTy->getPrimitiveSizeInBits() == 16) {\n    SmallVector<uint16_t, 32> Elements;\n    Elements.reserve(NumElements);\n\n    for(unsigned i = 0, e = E->getLength(); i != e; ++i)\n      Elements.push_back(E->getCodeUnit(i));\n    Elements.resize(NumElements);\n    return llvm::ConstantDataArray::get(VMContext, Elements);\n  }\n\n  assert(ElemTy->getPrimitiveSizeInBits() == 32);\n  SmallVector<uint32_t, 32> Elements;\n  Elements.reserve(NumElements);\n\n  for(unsigned i = 0, e = E->getLength(); i != e; ++i)\n    Elements.push_back(E->getCodeUnit(i));\n  Elements.resize(NumElements);\n  return llvm::ConstantDataArray::get(VMContext, Elements);\n}\n\nstatic llvm::GlobalVariable *\nGenerateStringLiteral(llvm::Constant *C, llvm::GlobalValue::LinkageTypes LT,\n                      CodeGenModule &CGM, StringRef GlobalName,\n                      CharUnits Alignment) {\n  unsigned AddrSpace = CGM.getContext().getTargetAddressSpace(\n      CGM.getStringLiteralAddressSpace());\n\n  llvm::Module &M = CGM.getModule();\n  // Create a global variable for this string\n  auto *GV = new llvm::GlobalVariable(\n      M, C->getType(), !CGM.getLangOpts().WritableStrings, LT, C, GlobalName,\n      nullptr, llvm::GlobalVariable::NotThreadLocal, AddrSpace);\n  GV->setAlignment(Alignment.getAsAlign());\n  GV->setUnnamedAddr(llvm::GlobalValue::UnnamedAddr::Global);\n  if (GV->isWeakForLinker()) {\n    assert(CGM.supportsCOMDAT() && \"Only COFF uses weak string literals\");\n    GV->setComdat(M.getOrInsertComdat(GV->getName()));\n  }\n  CGM.setDSOLocal(GV);\n\n  return GV;\n}\n\n/// GetAddrOfConstantStringFromLiteral - Return a pointer to a\n/// constant array for the given string literal.\nConstantAddress\nCodeGenModule::GetAddrOfConstantStringFromLiteral(const StringLiteral *S,\n                                                  StringRef Name) {\n  CharUnits Alignment = getContext().getAlignOfGlobalVarInChars(S->getType());\n\n  llvm::Constant *C = GetConstantArrayFromStringLiteral(S);\n  llvm::GlobalVariable **Entry = nullptr;\n  if (!LangOpts.WritableStrings) {\n    Entry = &ConstantStringMap[C];\n    if (auto GV = *Entry) {\n      if (Alignment.getQuantity() > GV->getAlignment())\n        GV->setAlignment(Alignment.getAsAlign());\n      return ConstantAddress(castStringLiteralToDefaultAddressSpace(*this, GV),\n                             Alignment);\n    }\n  }\n\n  SmallString<256> MangledNameBuffer;\n  StringRef GlobalVariableName;\n  llvm::GlobalValue::LinkageTypes LT;\n\n  // Mangle the string literal if that's how the ABI merges duplicate strings.\n  // Don't do it if they are writable, since we don't want writes in one TU to\n  // affect strings in another.\n  if (getCXXABI().getMangleContext().shouldMangleStringLiteral(S) &&\n      !LangOpts.WritableStrings) {\n    llvm::raw_svector_ostream Out(MangledNameBuffer);\n    getCXXABI().getMangleContext().mangleStringLiteral(S, Out);\n    LT = llvm::GlobalValue::LinkOnceODRLinkage;\n    GlobalVariableName = MangledNameBuffer;\n  } else {\n    LT = llvm::GlobalValue::PrivateLinkage;\n    GlobalVariableName = Name;\n  }\n\n  auto GV = GenerateStringLiteral(C, LT, *this, GlobalVariableName, Alignment);\n  if (Entry)\n    *Entry = GV;\n\n  SanitizerMD->reportGlobalToASan(GV, S->getStrTokenLoc(0), \"<string literal>\",\n                                  QualType());\n\n  return ConstantAddress(castStringLiteralToDefaultAddressSpace(*this, GV),\n                         Alignment);\n}\n\n/// GetAddrOfConstantStringFromObjCEncode - Return a pointer to a constant\n/// array for the given ObjCEncodeExpr node.\nConstantAddress\nCodeGenModule::GetAddrOfConstantStringFromObjCEncode(const ObjCEncodeExpr *E) {\n  std::string Str;\n  getContext().getObjCEncodingForType(E->getEncodedType(), Str);\n\n  return GetAddrOfConstantCString(Str);\n}\n\n/// GetAddrOfConstantCString - Returns a pointer to a character array containing\n/// the literal and a terminating '\\0' character.\n/// The result has pointer to array type.\nConstantAddress CodeGenModule::GetAddrOfConstantCString(\n    const std::string &Str, const char *GlobalName) {\n  StringRef StrWithNull(Str.c_str(), Str.size() + 1);\n  CharUnits Alignment =\n    getContext().getAlignOfGlobalVarInChars(getContext().CharTy);\n\n  llvm::Constant *C =\n      llvm::ConstantDataArray::getString(getLLVMContext(), StrWithNull, false);\n\n  // Don't share any string literals if strings aren't constant.\n  llvm::GlobalVariable **Entry = nullptr;\n  if (!LangOpts.WritableStrings) {\n    Entry = &ConstantStringMap[C];\n    if (auto GV = *Entry) {\n      if (Alignment.getQuantity() > GV->getAlignment())\n        GV->setAlignment(Alignment.getAsAlign());\n      return ConstantAddress(castStringLiteralToDefaultAddressSpace(*this, GV),\n                             Alignment);\n    }\n  }\n\n  // Get the default prefix if a name wasn't specified.\n  if (!GlobalName)\n    GlobalName = \".str\";\n  // Create a global variable for this.\n  auto GV = GenerateStringLiteral(C, llvm::GlobalValue::PrivateLinkage, *this,\n                                  GlobalName, Alignment);\n  if (Entry)\n    *Entry = GV;\n\n  return ConstantAddress(castStringLiteralToDefaultAddressSpace(*this, GV),\n                         Alignment);\n}\n\nConstantAddress CodeGenModule::GetAddrOfGlobalTemporary(\n    const MaterializeTemporaryExpr *E, const Expr *Init) {\n  assert((E->getStorageDuration() == SD_Static ||\n          E->getStorageDuration() == SD_Thread) && \"not a global temporary\");\n  const auto *VD = cast<VarDecl>(E->getExtendingDecl());\n\n  // If we're not materializing a subobject of the temporary, keep the\n  // cv-qualifiers from the type of the MaterializeTemporaryExpr.\n  QualType MaterializedType = Init->getType();\n  if (Init == E->getSubExpr())\n    MaterializedType = E->getType();\n\n  CharUnits Align = getContext().getTypeAlignInChars(MaterializedType);\n\n  if (llvm::Constant *Slot = MaterializedGlobalTemporaryMap[E])\n    return ConstantAddress(Slot, Align);\n\n  // FIXME: If an externally-visible declaration extends multiple temporaries,\n  // we need to give each temporary the same name in every translation unit (and\n  // we also need to make the temporaries externally-visible).\n  SmallString<256> Name;\n  llvm::raw_svector_ostream Out(Name);\n  getCXXABI().getMangleContext().mangleReferenceTemporary(\n      VD, E->getManglingNumber(), Out);\n\n  APValue *Value = nullptr;\n  if (E->getStorageDuration() == SD_Static && VD && VD->evaluateValue()) {\n    // If the initializer of the extending declaration is a constant\n    // initializer, we should have a cached constant initializer for this\n    // temporary. Note that this might have a different value from the value\n    // computed by evaluating the initializer if the surrounding constant\n    // expression modifies the temporary.\n    Value = E->getOrCreateValue(false);\n  }\n\n  // Try evaluating it now, it might have a constant initializer.\n  Expr::EvalResult EvalResult;\n  if (!Value && Init->EvaluateAsRValue(EvalResult, getContext()) &&\n      !EvalResult.hasSideEffects())\n    Value = &EvalResult.Val;\n\n  LangAS AddrSpace =\n      VD ? GetGlobalVarAddressSpace(VD) : MaterializedType.getAddressSpace();\n\n  Optional<ConstantEmitter> emitter;\n  llvm::Constant *InitialValue = nullptr;\n  bool Constant = false;\n  llvm::Type *Type;\n  if (Value) {\n    // The temporary has a constant initializer, use it.\n    emitter.emplace(*this);\n    InitialValue = emitter->emitForInitializer(*Value, AddrSpace,\n                                               MaterializedType);\n    Constant = isTypeConstant(MaterializedType, /*ExcludeCtor*/Value);\n    Type = InitialValue->getType();\n  } else {\n    // No initializer, the initialization will be provided when we\n    // initialize the declaration which performed lifetime extension.\n    Type = getTypes().ConvertTypeForMem(MaterializedType);\n  }\n\n  // Create a global variable for this lifetime-extended temporary.\n  llvm::GlobalValue::LinkageTypes Linkage =\n      getLLVMLinkageVarDefinition(VD, Constant);\n  if (Linkage == llvm::GlobalVariable::ExternalLinkage) {\n    const VarDecl *InitVD;\n    if (VD->isStaticDataMember() && VD->getAnyInitializer(InitVD) &&\n        isa<CXXRecordDecl>(InitVD->getLexicalDeclContext())) {\n      // Temporaries defined inside a class get linkonce_odr linkage because the\n      // class can be defined in multiple translation units.\n      Linkage = llvm::GlobalVariable::LinkOnceODRLinkage;\n    } else {\n      // There is no need for this temporary to have external linkage if the\n      // VarDecl has external linkage.\n      Linkage = llvm::GlobalVariable::InternalLinkage;\n    }\n  }\n  auto TargetAS = getContext().getTargetAddressSpace(AddrSpace);\n  auto *GV = new llvm::GlobalVariable(\n      getModule(), Type, Constant, Linkage, InitialValue, Name.c_str(),\n      /*InsertBefore=*/nullptr, llvm::GlobalVariable::NotThreadLocal, TargetAS);\n  if (emitter) emitter->finalize(GV);\n  setGVProperties(GV, VD);\n  GV->setAlignment(Align.getAsAlign());\n  if (supportsCOMDAT() && GV->isWeakForLinker())\n    GV->setComdat(TheModule.getOrInsertComdat(GV->getName()));\n  if (VD->getTLSKind())\n    setTLSMode(GV, *VD);\n  llvm::Constant *CV = GV;\n  if (AddrSpace != LangAS::Default)\n    CV = getTargetCodeGenInfo().performAddrSpaceCast(\n        *this, GV, AddrSpace, LangAS::Default,\n        Type->getPointerTo(\n            getContext().getTargetAddressSpace(LangAS::Default)));\n  MaterializedGlobalTemporaryMap[E] = CV;\n  return ConstantAddress(CV, Align);\n}\n\n/// EmitObjCPropertyImplementations - Emit information for synthesized\n/// properties for an implementation.\nvoid CodeGenModule::EmitObjCPropertyImplementations(const\n                                                    ObjCImplementationDecl *D) {\n  for (const auto *PID : D->property_impls()) {\n    // Dynamic is just for type-checking.\n    if (PID->getPropertyImplementation() == ObjCPropertyImplDecl::Synthesize) {\n      ObjCPropertyDecl *PD = PID->getPropertyDecl();\n\n      // Determine which methods need to be implemented, some may have\n      // been overridden. Note that ::isPropertyAccessor is not the method\n      // we want, that just indicates if the decl came from a\n      // property. What we want to know is if the method is defined in\n      // this implementation.\n      auto *Getter = PID->getGetterMethodDecl();\n      if (!Getter || Getter->isSynthesizedAccessorStub())\n        CodeGenFunction(*this).GenerateObjCGetter(\n            const_cast<ObjCImplementationDecl *>(D), PID);\n      auto *Setter = PID->getSetterMethodDecl();\n      if (!PD->isReadOnly() && (!Setter || Setter->isSynthesizedAccessorStub()))\n        CodeGenFunction(*this).GenerateObjCSetter(\n                                 const_cast<ObjCImplementationDecl *>(D), PID);\n    }\n  }\n}\n\nstatic bool needsDestructMethod(ObjCImplementationDecl *impl) {\n  const ObjCInterfaceDecl *iface = impl->getClassInterface();\n  for (const ObjCIvarDecl *ivar = iface->all_declared_ivar_begin();\n       ivar; ivar = ivar->getNextIvar())\n    if (ivar->getType().isDestructedType())\n      return true;\n\n  return false;\n}\n\nstatic bool AllTrivialInitializers(CodeGenModule &CGM,\n                                   ObjCImplementationDecl *D) {\n  CodeGenFunction CGF(CGM);\n  for (ObjCImplementationDecl::init_iterator B = D->init_begin(),\n       E = D->init_end(); B != E; ++B) {\n    CXXCtorInitializer *CtorInitExp = *B;\n    Expr *Init = CtorInitExp->getInit();\n    if (!CGF.isTrivialInitializer(Init))\n      return false;\n  }\n  return true;\n}\n\n/// EmitObjCIvarInitializations - Emit information for ivar initialization\n/// for an implementation.\nvoid CodeGenModule::EmitObjCIvarInitializations(ObjCImplementationDecl *D) {\n  // We might need a .cxx_destruct even if we don't have any ivar initializers.\n  if (needsDestructMethod(D)) {\n    IdentifierInfo *II = &getContext().Idents.get(\".cxx_destruct\");\n    Selector cxxSelector = getContext().Selectors.getSelector(0, &II);\n    ObjCMethodDecl *DTORMethod = ObjCMethodDecl::Create(\n        getContext(), D->getLocation(), D->getLocation(), cxxSelector,\n        getContext().VoidTy, nullptr, D,\n        /*isInstance=*/true, /*isVariadic=*/false,\n        /*isPropertyAccessor=*/true, /*isSynthesizedAccessorStub=*/false,\n        /*isImplicitlyDeclared=*/true,\n        /*isDefined=*/false, ObjCMethodDecl::Required);\n    D->addInstanceMethod(DTORMethod);\n    CodeGenFunction(*this).GenerateObjCCtorDtorMethod(D, DTORMethod, false);\n    D->setHasDestructors(true);\n  }\n\n  // If the implementation doesn't have any ivar initializers, we don't need\n  // a .cxx_construct.\n  if (D->getNumIvarInitializers() == 0 ||\n      AllTrivialInitializers(*this, D))\n    return;\n\n  IdentifierInfo *II = &getContext().Idents.get(\".cxx_construct\");\n  Selector cxxSelector = getContext().Selectors.getSelector(0, &II);\n  // The constructor returns 'self'.\n  ObjCMethodDecl *CTORMethod = ObjCMethodDecl::Create(\n      getContext(), D->getLocation(), D->getLocation(), cxxSelector,\n      getContext().getObjCIdType(), nullptr, D, /*isInstance=*/true,\n      /*isVariadic=*/false,\n      /*isPropertyAccessor=*/true, /*isSynthesizedAccessorStub=*/false,\n      /*isImplicitlyDeclared=*/true,\n      /*isDefined=*/false, ObjCMethodDecl::Required);\n  D->addInstanceMethod(CTORMethod);\n  CodeGenFunction(*this).GenerateObjCCtorDtorMethod(D, CTORMethod, true);\n  D->setHasNonZeroConstructors(true);\n}\n\n// EmitLinkageSpec - Emit all declarations in a linkage spec.\nvoid CodeGenModule::EmitLinkageSpec(const LinkageSpecDecl *LSD) {\n  if (LSD->getLanguage() != LinkageSpecDecl::lang_c &&\n      LSD->getLanguage() != LinkageSpecDecl::lang_cxx) {\n    ErrorUnsupported(LSD, \"linkage spec\");\n    return;\n  }\n\n  EmitDeclContext(LSD);\n}\n\nvoid CodeGenModule::EmitDeclContext(const DeclContext *DC) {\n  for (auto *I : DC->decls()) {\n    // Unlike other DeclContexts, the contents of an ObjCImplDecl at TU scope\n    // are themselves considered \"top-level\", so EmitTopLevelDecl on an\n    // ObjCImplDecl does not recursively visit them. We need to do that in\n    // case they're nested inside another construct (LinkageSpecDecl /\n    // ExportDecl) that does stop them from being considered \"top-level\".\n    if (auto *OID = dyn_cast<ObjCImplDecl>(I)) {\n      for (auto *M : OID->methods())\n        EmitTopLevelDecl(M);\n    }\n\n    EmitTopLevelDecl(I);\n  }\n}\n\n/// EmitTopLevelDecl - Emit code for a single top level declaration.\nvoid CodeGenModule::EmitTopLevelDecl(Decl *D) {\n  // Ignore dependent declarations.\n  if (D->isTemplated())\n    return;\n\n  // Consteval function shouldn't be emitted.\n  if (auto *FD = dyn_cast<FunctionDecl>(D))\n    if (FD->isConsteval())\n      return;\n\n  switch (D->getKind()) {\n  case Decl::CXXConversion:\n  case Decl::CXXMethod:\n  case Decl::Function:\n    EmitGlobal(cast<FunctionDecl>(D));\n    // Always provide some coverage mapping\n    // even for the functions that aren't emitted.\n    AddDeferredUnusedCoverageMapping(D);\n    break;\n\n  case Decl::CXXDeductionGuide:\n    // Function-like, but does not result in code emission.\n    break;\n\n  case Decl::Var:\n  case Decl::Decomposition:\n  case Decl::VarTemplateSpecialization:\n    EmitGlobal(cast<VarDecl>(D));\n    if (auto *DD = dyn_cast<DecompositionDecl>(D))\n      for (auto *B : DD->bindings())\n        if (auto *HD = B->getHoldingVar())\n          EmitGlobal(HD);\n    break;\n\n  // Indirect fields from global anonymous structs and unions can be\n  // ignored; only the actual variable requires IR gen support.\n  case Decl::IndirectField:\n    break;\n\n  // C++ Decls\n  case Decl::Namespace:\n    EmitDeclContext(cast<NamespaceDecl>(D));\n    break;\n  case Decl::ClassTemplateSpecialization: {\n    const auto *Spec = cast<ClassTemplateSpecializationDecl>(D);\n    if (CGDebugInfo *DI = getModuleDebugInfo())\n      if (Spec->getSpecializationKind() ==\n              TSK_ExplicitInstantiationDefinition &&\n          Spec->hasDefinition())\n        DI->completeTemplateDefinition(*Spec);\n  } LLVM_FALLTHROUGH;\n  case Decl::CXXRecord: {\n    CXXRecordDecl *CRD = cast<CXXRecordDecl>(D);\n    if (CGDebugInfo *DI = getModuleDebugInfo()) {\n      if (CRD->hasDefinition())\n        DI->EmitAndRetainType(getContext().getRecordType(cast<RecordDecl>(D)));\n      if (auto *ES = D->getASTContext().getExternalSource())\n        if (ES->hasExternalDefinitions(D) == ExternalASTSource::EK_Never)\n          DI->completeUnusedClass(*CRD);\n    }\n    // Emit any static data members, they may be definitions.\n    for (auto *I : CRD->decls())\n      if (isa<VarDecl>(I) || isa<CXXRecordDecl>(I))\n        EmitTopLevelDecl(I);\n    break;\n  }\n    // No code generation needed.\n  case Decl::UsingShadow:\n  case Decl::ClassTemplate:\n  case Decl::VarTemplate:\n  case Decl::Concept:\n  case Decl::VarTemplatePartialSpecialization:\n  case Decl::FunctionTemplate:\n  case Decl::TypeAliasTemplate:\n  case Decl::Block:\n  case Decl::Empty:\n  case Decl::Binding:\n    break;\n  case Decl::Using:          // using X; [C++]\n    if (CGDebugInfo *DI = getModuleDebugInfo())\n        DI->EmitUsingDecl(cast<UsingDecl>(*D));\n    break;\n  case Decl::NamespaceAlias:\n    if (CGDebugInfo *DI = getModuleDebugInfo())\n        DI->EmitNamespaceAlias(cast<NamespaceAliasDecl>(*D));\n    break;\n  case Decl::UsingDirective: // using namespace X; [C++]\n    if (CGDebugInfo *DI = getModuleDebugInfo())\n      DI->EmitUsingDirective(cast<UsingDirectiveDecl>(*D));\n    break;\n  case Decl::CXXConstructor:\n    getCXXABI().EmitCXXConstructors(cast<CXXConstructorDecl>(D));\n    break;\n  case Decl::CXXDestructor:\n    getCXXABI().EmitCXXDestructors(cast<CXXDestructorDecl>(D));\n    break;\n\n  case Decl::StaticAssert:\n    // Nothing to do.\n    break;\n\n  // Objective-C Decls\n\n  // Forward declarations, no (immediate) code generation.\n  case Decl::ObjCInterface:\n  case Decl::ObjCCategory:\n    break;\n\n  case Decl::ObjCProtocol: {\n    auto *Proto = cast<ObjCProtocolDecl>(D);\n    if (Proto->isThisDeclarationADefinition())\n      ObjCRuntime->GenerateProtocol(Proto);\n    break;\n  }\n\n  case Decl::ObjCCategoryImpl:\n    // Categories have properties but don't support synthesize so we\n    // can ignore them here.\n    ObjCRuntime->GenerateCategory(cast<ObjCCategoryImplDecl>(D));\n    break;\n\n  case Decl::ObjCImplementation: {\n    auto *OMD = cast<ObjCImplementationDecl>(D);\n    EmitObjCPropertyImplementations(OMD);\n    EmitObjCIvarInitializations(OMD);\n    ObjCRuntime->GenerateClass(OMD);\n    // Emit global variable debug information.\n    if (CGDebugInfo *DI = getModuleDebugInfo())\n      if (getCodeGenOpts().hasReducedDebugInfo())\n        DI->getOrCreateInterfaceType(getContext().getObjCInterfaceType(\n            OMD->getClassInterface()), OMD->getLocation());\n    break;\n  }\n  case Decl::ObjCMethod: {\n    auto *OMD = cast<ObjCMethodDecl>(D);\n    // If this is not a prototype, emit the body.\n    if (OMD->getBody())\n      CodeGenFunction(*this).GenerateObjCMethod(OMD);\n    break;\n  }\n  case Decl::ObjCCompatibleAlias:\n    ObjCRuntime->RegisterAlias(cast<ObjCCompatibleAliasDecl>(D));\n    break;\n\n  case Decl::PragmaComment: {\n    const auto *PCD = cast<PragmaCommentDecl>(D);\n    switch (PCD->getCommentKind()) {\n    case PCK_Unknown:\n      llvm_unreachable(\"unexpected pragma comment kind\");\n    case PCK_Linker:\n      AppendLinkerOptions(PCD->getArg());\n      break;\n    case PCK_Lib:\n        AddDependentLib(PCD->getArg());\n      break;\n    case PCK_Compiler:\n    case PCK_ExeStr:\n    case PCK_User:\n      break; // We ignore all of these.\n    }\n    break;\n  }\n\n  case Decl::PragmaDetectMismatch: {\n    const auto *PDMD = cast<PragmaDetectMismatchDecl>(D);\n    AddDetectMismatch(PDMD->getName(), PDMD->getValue());\n    break;\n  }\n\n  case Decl::LinkageSpec:\n    EmitLinkageSpec(cast<LinkageSpecDecl>(D));\n    break;\n\n  case Decl::FileScopeAsm: {\n    // File-scope asm is ignored during device-side CUDA compilation.\n    if (LangOpts.CUDA && LangOpts.CUDAIsDevice)\n      break;\n    // File-scope asm is ignored during device-side OpenMP compilation.\n    if (LangOpts.OpenMPIsDevice)\n      break;\n    auto *AD = cast<FileScopeAsmDecl>(D);\n    getModule().appendModuleInlineAsm(AD->getAsmString()->getString());\n    break;\n  }\n\n  case Decl::Import: {\n    auto *Import = cast<ImportDecl>(D);\n\n    // If we've already imported this module, we're done.\n    if (!ImportedModules.insert(Import->getImportedModule()))\n      break;\n\n    // Emit debug information for direct imports.\n    if (!Import->getImportedOwningModule()) {\n      if (CGDebugInfo *DI = getModuleDebugInfo())\n        DI->EmitImportDecl(*Import);\n    }\n\n    // Find all of the submodules and emit the module initializers.\n    llvm::SmallPtrSet<clang::Module *, 16> Visited;\n    SmallVector<clang::Module *, 16> Stack;\n    Visited.insert(Import->getImportedModule());\n    Stack.push_back(Import->getImportedModule());\n\n    while (!Stack.empty()) {\n      clang::Module *Mod = Stack.pop_back_val();\n      if (!EmittedModuleInitializers.insert(Mod).second)\n        continue;\n\n      for (auto *D : Context.getModuleInitializers(Mod))\n        EmitTopLevelDecl(D);\n\n      // Visit the submodules of this module.\n      for (clang::Module::submodule_iterator Sub = Mod->submodule_begin(),\n                                             SubEnd = Mod->submodule_end();\n           Sub != SubEnd; ++Sub) {\n        // Skip explicit children; they need to be explicitly imported to emit\n        // the initializers.\n        if ((*Sub)->IsExplicit)\n          continue;\n\n        if (Visited.insert(*Sub).second)\n          Stack.push_back(*Sub);\n      }\n    }\n    break;\n  }\n\n  case Decl::Export:\n    EmitDeclContext(cast<ExportDecl>(D));\n    break;\n\n  case Decl::OMPThreadPrivate:\n    EmitOMPThreadPrivateDecl(cast<OMPThreadPrivateDecl>(D));\n    break;\n\n  case Decl::OMPAllocate:\n    break;\n\n  case Decl::OMPDeclareReduction:\n    EmitOMPDeclareReduction(cast<OMPDeclareReductionDecl>(D));\n    break;\n\n  case Decl::OMPDeclareMapper:\n    EmitOMPDeclareMapper(cast<OMPDeclareMapperDecl>(D));\n    break;\n\n  case Decl::OMPRequires:\n    EmitOMPRequiresDecl(cast<OMPRequiresDecl>(D));\n    break;\n\n  case Decl::Typedef:\n  case Decl::TypeAlias: // using foo = bar; [C++11]\n    if (CGDebugInfo *DI = getModuleDebugInfo())\n      DI->EmitAndRetainType(\n          getContext().getTypedefType(cast<TypedefNameDecl>(D)));\n    break;\n\n  case Decl::Record:\n    if (CGDebugInfo *DI = getModuleDebugInfo())\n      if (cast<RecordDecl>(D)->getDefinition())\n        DI->EmitAndRetainType(getContext().getRecordType(cast<RecordDecl>(D)));\n    break;\n\n  case Decl::Enum:\n    if (CGDebugInfo *DI = getModuleDebugInfo())\n      if (cast<EnumDecl>(D)->getDefinition())\n        DI->EmitAndRetainType(getContext().getEnumType(cast<EnumDecl>(D)));\n    break;\n\n  default:\n    // Make sure we handled everything we should, every other kind is a\n    // non-top-level decl.  FIXME: Would be nice to have an isTopLevelDeclKind\n    // function. Need to recode Decl::Kind to do that easily.\n    assert(isa<TypeDecl>(D) && \"Unsupported decl kind\");\n    break;\n  }\n}\n\nvoid CodeGenModule::AddDeferredUnusedCoverageMapping(Decl *D) {\n  // Do we need to generate coverage mapping?\n  if (!CodeGenOpts.CoverageMapping)\n    return;\n  switch (D->getKind()) {\n  case Decl::CXXConversion:\n  case Decl::CXXMethod:\n  case Decl::Function:\n  case Decl::ObjCMethod:\n  case Decl::CXXConstructor:\n  case Decl::CXXDestructor: {\n    if (!cast<FunctionDecl>(D)->doesThisDeclarationHaveABody())\n      break;\n    SourceManager &SM = getContext().getSourceManager();\n    if (LimitedCoverage && SM.getMainFileID() != SM.getFileID(D->getBeginLoc()))\n      break;\n    auto I = DeferredEmptyCoverageMappingDecls.find(D);\n    if (I == DeferredEmptyCoverageMappingDecls.end())\n      DeferredEmptyCoverageMappingDecls[D] = true;\n    break;\n  }\n  default:\n    break;\n  };\n}\n\nvoid CodeGenModule::ClearUnusedCoverageMapping(const Decl *D) {\n  // Do we need to generate coverage mapping?\n  if (!CodeGenOpts.CoverageMapping)\n    return;\n  if (const auto *Fn = dyn_cast<FunctionDecl>(D)) {\n    if (Fn->isTemplateInstantiation())\n      ClearUnusedCoverageMapping(Fn->getTemplateInstantiationPattern());\n  }\n  auto I = DeferredEmptyCoverageMappingDecls.find(D);\n  if (I == DeferredEmptyCoverageMappingDecls.end())\n    DeferredEmptyCoverageMappingDecls[D] = false;\n  else\n    I->second = false;\n}\n\nvoid CodeGenModule::EmitDeferredUnusedCoverageMappings() {\n  // We call takeVector() here to avoid use-after-free.\n  // FIXME: DeferredEmptyCoverageMappingDecls is getting mutated because\n  // we deserialize function bodies to emit coverage info for them, and that\n  // deserializes more declarations. How should we handle that case?\n  for (const auto &Entry : DeferredEmptyCoverageMappingDecls.takeVector()) {\n    if (!Entry.second)\n      continue;\n    const Decl *D = Entry.first;\n    switch (D->getKind()) {\n    case Decl::CXXConversion:\n    case Decl::CXXMethod:\n    case Decl::Function:\n    case Decl::ObjCMethod: {\n      CodeGenPGO PGO(*this);\n      GlobalDecl GD(cast<FunctionDecl>(D));\n      PGO.emitEmptyCounterMapping(D, getMangledName(GD),\n                                  getFunctionLinkage(GD));\n      break;\n    }\n    case Decl::CXXConstructor: {\n      CodeGenPGO PGO(*this);\n      GlobalDecl GD(cast<CXXConstructorDecl>(D), Ctor_Base);\n      PGO.emitEmptyCounterMapping(D, getMangledName(GD),\n                                  getFunctionLinkage(GD));\n      break;\n    }\n    case Decl::CXXDestructor: {\n      CodeGenPGO PGO(*this);\n      GlobalDecl GD(cast<CXXDestructorDecl>(D), Dtor_Base);\n      PGO.emitEmptyCounterMapping(D, getMangledName(GD),\n                                  getFunctionLinkage(GD));\n      break;\n    }\n    default:\n      break;\n    };\n  }\n}\n\nvoid CodeGenModule::EmitMainVoidAlias() {\n  // In order to transition away from \"__original_main\" gracefully, emit an\n  // alias for \"main\" in the no-argument case so that libc can detect when\n  // new-style no-argument main is in used.\n  if (llvm::Function *F = getModule().getFunction(\"main\")) {\n    if (!F->isDeclaration() && F->arg_size() == 0 && !F->isVarArg() &&\n        F->getReturnType()->isIntegerTy(Context.getTargetInfo().getIntWidth()))\n      addUsedGlobal(llvm::GlobalAlias::create(\"__main_void\", F));\n  }\n}\n\n/// Turns the given pointer into a constant.\nstatic llvm::Constant *GetPointerConstant(llvm::LLVMContext &Context,\n                                          const void *Ptr) {\n  uintptr_t PtrInt = reinterpret_cast<uintptr_t>(Ptr);\n  llvm::Type *i64 = llvm::Type::getInt64Ty(Context);\n  return llvm::ConstantInt::get(i64, PtrInt);\n}\n\nstatic void EmitGlobalDeclMetadata(CodeGenModule &CGM,\n                                   llvm::NamedMDNode *&GlobalMetadata,\n                                   GlobalDecl D,\n                                   llvm::GlobalValue *Addr) {\n  if (!GlobalMetadata)\n    GlobalMetadata =\n      CGM.getModule().getOrInsertNamedMetadata(\"clang.global.decl.ptrs\");\n\n  // TODO: should we report variant information for ctors/dtors?\n  llvm::Metadata *Ops[] = {llvm::ConstantAsMetadata::get(Addr),\n                           llvm::ConstantAsMetadata::get(GetPointerConstant(\n                               CGM.getLLVMContext(), D.getDecl()))};\n  GlobalMetadata->addOperand(llvm::MDNode::get(CGM.getLLVMContext(), Ops));\n}\n\n/// For each function which is declared within an extern \"C\" region and marked\n/// as 'used', but has internal linkage, create an alias from the unmangled\n/// name to the mangled name if possible. People expect to be able to refer\n/// to such functions with an unmangled name from inline assembly within the\n/// same translation unit.\nvoid CodeGenModule::EmitStaticExternCAliases() {\n  if (!getTargetCodeGenInfo().shouldEmitStaticExternCAliases())\n    return;\n  for (auto &I : StaticExternCValues) {\n    IdentifierInfo *Name = I.first;\n    llvm::GlobalValue *Val = I.second;\n    if (Val && !getModule().getNamedValue(Name->getName()))\n      addUsedGlobal(llvm::GlobalAlias::create(Name->getName(), Val));\n  }\n}\n\nbool CodeGenModule::lookupRepresentativeDecl(StringRef MangledName,\n                                             GlobalDecl &Result) const {\n  auto Res = Manglings.find(MangledName);\n  if (Res == Manglings.end())\n    return false;\n  Result = Res->getValue();\n  return true;\n}\n\n/// Emits metadata nodes associating all the global values in the\n/// current module with the Decls they came from.  This is useful for\n/// projects using IR gen as a subroutine.\n///\n/// Since there's currently no way to associate an MDNode directly\n/// with an llvm::GlobalValue, we create a global named metadata\n/// with the name 'clang.global.decl.ptrs'.\nvoid CodeGenModule::EmitDeclMetadata() {\n  llvm::NamedMDNode *GlobalMetadata = nullptr;\n\n  for (auto &I : MangledDeclNames) {\n    llvm::GlobalValue *Addr = getModule().getNamedValue(I.second);\n    // Some mangled names don't necessarily have an associated GlobalValue\n    // in this module, e.g. if we mangled it for DebugInfo.\n    if (Addr)\n      EmitGlobalDeclMetadata(*this, GlobalMetadata, I.first, Addr);\n  }\n}\n\n/// Emits metadata nodes for all the local variables in the current\n/// function.\nvoid CodeGenFunction::EmitDeclMetadata() {\n  if (LocalDeclMap.empty()) return;\n\n  llvm::LLVMContext &Context = getLLVMContext();\n\n  // Find the unique metadata ID for this name.\n  unsigned DeclPtrKind = Context.getMDKindID(\"clang.decl.ptr\");\n\n  llvm::NamedMDNode *GlobalMetadata = nullptr;\n\n  for (auto &I : LocalDeclMap) {\n    const Decl *D = I.first;\n    llvm::Value *Addr = I.second.getPointer();\n    if (auto *Alloca = dyn_cast<llvm::AllocaInst>(Addr)) {\n      llvm::Value *DAddr = GetPointerConstant(getLLVMContext(), D);\n      Alloca->setMetadata(\n          DeclPtrKind, llvm::MDNode::get(\n                           Context, llvm::ValueAsMetadata::getConstant(DAddr)));\n    } else if (auto *GV = dyn_cast<llvm::GlobalValue>(Addr)) {\n      GlobalDecl GD = GlobalDecl(cast<VarDecl>(D));\n      EmitGlobalDeclMetadata(CGM, GlobalMetadata, GD, GV);\n    }\n  }\n}\n\nvoid CodeGenModule::EmitVersionIdentMetadata() {\n  llvm::NamedMDNode *IdentMetadata =\n    TheModule.getOrInsertNamedMetadata(\"llvm.ident\");\n  std::string Version = getClangFullVersion();\n  llvm::LLVMContext &Ctx = TheModule.getContext();\n\n  llvm::Metadata *IdentNode[] = {llvm::MDString::get(Ctx, Version)};\n  IdentMetadata->addOperand(llvm::MDNode::get(Ctx, IdentNode));\n}\n\nvoid CodeGenModule::EmitCommandLineMetadata() {\n  llvm::NamedMDNode *CommandLineMetadata =\n    TheModule.getOrInsertNamedMetadata(\"llvm.commandline\");\n  std::string CommandLine = getCodeGenOpts().RecordCommandLine;\n  llvm::LLVMContext &Ctx = TheModule.getContext();\n\n  llvm::Metadata *CommandLineNode[] = {llvm::MDString::get(Ctx, CommandLine)};\n  CommandLineMetadata->addOperand(llvm::MDNode::get(Ctx, CommandLineNode));\n}\n\nvoid CodeGenModule::EmitCoverageFile() {\n  if (getCodeGenOpts().CoverageDataFile.empty() &&\n      getCodeGenOpts().CoverageNotesFile.empty())\n    return;\n\n  llvm::NamedMDNode *CUNode = TheModule.getNamedMetadata(\"llvm.dbg.cu\");\n  if (!CUNode)\n    return;\n\n  llvm::NamedMDNode *GCov = TheModule.getOrInsertNamedMetadata(\"llvm.gcov\");\n  llvm::LLVMContext &Ctx = TheModule.getContext();\n  auto *CoverageDataFile =\n      llvm::MDString::get(Ctx, getCodeGenOpts().CoverageDataFile);\n  auto *CoverageNotesFile =\n      llvm::MDString::get(Ctx, getCodeGenOpts().CoverageNotesFile);\n  for (int i = 0, e = CUNode->getNumOperands(); i != e; ++i) {\n    llvm::MDNode *CU = CUNode->getOperand(i);\n    llvm::Metadata *Elts[] = {CoverageNotesFile, CoverageDataFile, CU};\n    GCov->addOperand(llvm::MDNode::get(Ctx, Elts));\n  }\n}\n\nllvm::Constant *CodeGenModule::GetAddrOfRTTIDescriptor(QualType Ty,\n                                                       bool ForEH) {\n  // Return a bogus pointer if RTTI is disabled, unless it's for EH.\n  // FIXME: should we even be calling this method if RTTI is disabled\n  // and it's not for EH?\n  if ((!ForEH && !getLangOpts().RTTI) || getLangOpts().CUDAIsDevice ||\n      (getLangOpts().OpenMP && getLangOpts().OpenMPIsDevice &&\n       getTriple().isNVPTX()))\n    return llvm::Constant::getNullValue(Int8PtrTy);\n\n  if (ForEH && Ty->isObjCObjectPointerType() &&\n      LangOpts.ObjCRuntime.isGNUFamily())\n    return ObjCRuntime->GetEHType(Ty);\n\n  return getCXXABI().getAddrOfRTTIDescriptor(Ty);\n}\n\nvoid CodeGenModule::EmitOMPThreadPrivateDecl(const OMPThreadPrivateDecl *D) {\n  // Do not emit threadprivates in simd-only mode.\n  if (LangOpts.OpenMP && LangOpts.OpenMPSimd)\n    return;\n  for (auto RefExpr : D->varlists()) {\n    auto *VD = cast<VarDecl>(cast<DeclRefExpr>(RefExpr)->getDecl());\n    bool PerformInit =\n        VD->getAnyInitializer() &&\n        !VD->getAnyInitializer()->isConstantInitializer(getContext(),\n                                                        /*ForRef=*/false);\n\n    Address Addr(GetAddrOfGlobalVar(VD), getContext().getDeclAlign(VD));\n    if (auto InitFunction = getOpenMPRuntime().emitThreadPrivateVarDefinition(\n            VD, Addr, RefExpr->getBeginLoc(), PerformInit))\n      CXXGlobalInits.push_back(InitFunction);\n  }\n}\n\nllvm::Metadata *\nCodeGenModule::CreateMetadataIdentifierImpl(QualType T, MetadataTypeMap &Map,\n                                            StringRef Suffix) {\n  llvm::Metadata *&InternalId = Map[T.getCanonicalType()];\n  if (InternalId)\n    return InternalId;\n\n  if (isExternallyVisible(T->getLinkage())) {\n    std::string OutName;\n    llvm::raw_string_ostream Out(OutName);\n    getCXXABI().getMangleContext().mangleTypeName(T, Out);\n    Out << Suffix;\n\n    InternalId = llvm::MDString::get(getLLVMContext(), Out.str());\n  } else {\n    InternalId = llvm::MDNode::getDistinct(getLLVMContext(),\n                                           llvm::ArrayRef<llvm::Metadata *>());\n  }\n\n  return InternalId;\n}\n\nllvm::Metadata *CodeGenModule::CreateMetadataIdentifierForType(QualType T) {\n  return CreateMetadataIdentifierImpl(T, MetadataIdMap, \"\");\n}\n\nllvm::Metadata *\nCodeGenModule::CreateMetadataIdentifierForVirtualMemPtrType(QualType T) {\n  return CreateMetadataIdentifierImpl(T, VirtualMetadataIdMap, \".virtual\");\n}\n\n// Generalize pointer types to a void pointer with the qualifiers of the\n// originally pointed-to type, e.g. 'const char *' and 'char * const *'\n// generalize to 'const void *' while 'char *' and 'const char **' generalize to\n// 'void *'.\nstatic QualType GeneralizeType(ASTContext &Ctx, QualType Ty) {\n  if (!Ty->isPointerType())\n    return Ty;\n\n  return Ctx.getPointerType(\n      QualType(Ctx.VoidTy).withCVRQualifiers(\n          Ty->getPointeeType().getCVRQualifiers()));\n}\n\n// Apply type generalization to a FunctionType's return and argument types\nstatic QualType GeneralizeFunctionType(ASTContext &Ctx, QualType Ty) {\n  if (auto *FnType = Ty->getAs<FunctionProtoType>()) {\n    SmallVector<QualType, 8> GeneralizedParams;\n    for (auto &Param : FnType->param_types())\n      GeneralizedParams.push_back(GeneralizeType(Ctx, Param));\n\n    return Ctx.getFunctionType(\n        GeneralizeType(Ctx, FnType->getReturnType()),\n        GeneralizedParams, FnType->getExtProtoInfo());\n  }\n\n  if (auto *FnType = Ty->getAs<FunctionNoProtoType>())\n    return Ctx.getFunctionNoProtoType(\n        GeneralizeType(Ctx, FnType->getReturnType()));\n\n  llvm_unreachable(\"Encountered unknown FunctionType\");\n}\n\nllvm::Metadata *CodeGenModule::CreateMetadataIdentifierGeneralized(QualType T) {\n  return CreateMetadataIdentifierImpl(GeneralizeFunctionType(getContext(), T),\n                                      GeneralizedMetadataIdMap, \".generalized\");\n}\n\n/// Returns whether this module needs the \"all-vtables\" type identifier.\nbool CodeGenModule::NeedAllVtablesTypeId() const {\n  // Returns true if at least one of vtable-based CFI checkers is enabled and\n  // is not in the trapping mode.\n  return ((LangOpts.Sanitize.has(SanitizerKind::CFIVCall) &&\n           !CodeGenOpts.SanitizeTrap.has(SanitizerKind::CFIVCall)) ||\n          (LangOpts.Sanitize.has(SanitizerKind::CFINVCall) &&\n           !CodeGenOpts.SanitizeTrap.has(SanitizerKind::CFINVCall)) ||\n          (LangOpts.Sanitize.has(SanitizerKind::CFIDerivedCast) &&\n           !CodeGenOpts.SanitizeTrap.has(SanitizerKind::CFIDerivedCast)) ||\n          (LangOpts.Sanitize.has(SanitizerKind::CFIUnrelatedCast) &&\n           !CodeGenOpts.SanitizeTrap.has(SanitizerKind::CFIUnrelatedCast)));\n}\n\nvoid CodeGenModule::AddVTableTypeMetadata(llvm::GlobalVariable *VTable,\n                                          CharUnits Offset,\n                                          const CXXRecordDecl *RD) {\n  llvm::Metadata *MD =\n      CreateMetadataIdentifierForType(QualType(RD->getTypeForDecl(), 0));\n  VTable->addTypeMetadata(Offset.getQuantity(), MD);\n\n  if (CodeGenOpts.SanitizeCfiCrossDso)\n    if (auto CrossDsoTypeId = CreateCrossDsoCfiTypeId(MD))\n      VTable->addTypeMetadata(Offset.getQuantity(),\n                              llvm::ConstantAsMetadata::get(CrossDsoTypeId));\n\n  if (NeedAllVtablesTypeId()) {\n    llvm::Metadata *MD = llvm::MDString::get(getLLVMContext(), \"all-vtables\");\n    VTable->addTypeMetadata(Offset.getQuantity(), MD);\n  }\n}\n\nllvm::SanitizerStatReport &CodeGenModule::getSanStats() {\n  if (!SanStats)\n    SanStats = std::make_unique<llvm::SanitizerStatReport>(&getModule());\n\n  return *SanStats;\n}\nllvm::Value *\nCodeGenModule::createOpenCLIntToSamplerConversion(const Expr *E,\n                                                  CodeGenFunction &CGF) {\n  llvm::Constant *C = ConstantEmitter(CGF).emitAbstract(E, E->getType());\n  auto SamplerT = getOpenCLRuntime().getSamplerType(E->getType().getTypePtr());\n  auto FTy = llvm::FunctionType::get(SamplerT, {C->getType()}, false);\n  return CGF.Builder.CreateCall(CreateRuntimeFunction(FTy,\n                                \"__translate_sampler_initializer\"),\n                                {C});\n}\n\nCharUnits CodeGenModule::getNaturalPointeeTypeAlignment(\n    QualType T, LValueBaseInfo *BaseInfo, TBAAAccessInfo *TBAAInfo) {\n  return getNaturalTypeAlignment(T->getPointeeType(), BaseInfo, TBAAInfo,\n                                 /* forPointeeType= */ true);\n}\n\nCharUnits CodeGenModule::getNaturalTypeAlignment(QualType T,\n                                                 LValueBaseInfo *BaseInfo,\n                                                 TBAAAccessInfo *TBAAInfo,\n                                                 bool forPointeeType) {\n  if (TBAAInfo)\n    *TBAAInfo = getTBAAAccessInfo(T);\n\n  // FIXME: This duplicates logic in ASTContext::getTypeAlignIfKnown. But\n  // that doesn't return the information we need to compute BaseInfo.\n\n  // Honor alignment typedef attributes even on incomplete types.\n  // We also honor them straight for C++ class types, even as pointees;\n  // there's an expressivity gap here.\n  if (auto TT = T->getAs<TypedefType>()) {\n    if (auto Align = TT->getDecl()->getMaxAlignment()) {\n      if (BaseInfo)\n        *BaseInfo = LValueBaseInfo(AlignmentSource::AttributedType);\n      return getContext().toCharUnitsFromBits(Align);\n    }\n  }\n\n  bool AlignForArray = T->isArrayType();\n\n  // Analyze the base element type, so we don't get confused by incomplete\n  // array types.\n  T = getContext().getBaseElementType(T);\n\n  if (T->isIncompleteType()) {\n    // We could try to replicate the logic from\n    // ASTContext::getTypeAlignIfKnown, but nothing uses the alignment if the\n    // type is incomplete, so it's impossible to test. We could try to reuse\n    // getTypeAlignIfKnown, but that doesn't return the information we need\n    // to set BaseInfo.  So just ignore the possibility that the alignment is\n    // greater than one.\n    if (BaseInfo)\n      *BaseInfo = LValueBaseInfo(AlignmentSource::Type);\n    return CharUnits::One();\n  }\n\n  if (BaseInfo)\n    *BaseInfo = LValueBaseInfo(AlignmentSource::Type);\n\n  CharUnits Alignment;\n  const CXXRecordDecl *RD;\n  if (T.getQualifiers().hasUnaligned()) {\n    Alignment = CharUnits::One();\n  } else if (forPointeeType && !AlignForArray &&\n             (RD = T->getAsCXXRecordDecl())) {\n    // For C++ class pointees, we don't know whether we're pointing at a\n    // base or a complete object, so we generally need to use the\n    // non-virtual alignment.\n    Alignment = getClassPointerAlignment(RD);\n  } else {\n    Alignment = getContext().getTypeAlignInChars(T);\n  }\n\n  // Cap to the global maximum type alignment unless the alignment\n  // was somehow explicit on the type.\n  if (unsigned MaxAlign = getLangOpts().MaxTypeAlign) {\n    if (Alignment.getQuantity() > MaxAlign &&\n        !getContext().isAlignmentRequired(T))\n      Alignment = CharUnits::fromQuantity(MaxAlign);\n  }\n  return Alignment;\n}\n\nbool CodeGenModule::stopAutoInit() {\n  unsigned StopAfter = getContext().getLangOpts().TrivialAutoVarInitStopAfter;\n  if (StopAfter) {\n    // This number is positive only when -ftrivial-auto-var-init-stop-after=* is\n    // used\n    if (NumAutoVarInit >= StopAfter) {\n      return true;\n    }\n    if (!NumAutoVarInit) {\n      unsigned DiagID = getDiags().getCustomDiagID(\n          DiagnosticsEngine::Warning,\n          \"-ftrivial-auto-var-init-stop-after=%0 has been enabled to limit the \"\n          \"number of times ftrivial-auto-var-init=%1 gets applied.\");\n      getDiags().Report(DiagID)\n          << StopAfter\n          << (getContext().getLangOpts().getTrivialAutoVarInit() ==\n                      LangOptions::TrivialAutoVarInitKind::Zero\n                  ? \"zero\"\n                  : \"pattern\");\n    }\n    ++NumAutoVarInit;\n  }\n  return false;\n}\n"}, "1": {"id": 1, "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CodeGenModule.h", "content": "//===--- CodeGenModule.h - Per-Module state for LLVM CodeGen ----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This is the internal per-translation-unit state used for llvm translation.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_LIB_CODEGEN_CODEGENMODULE_H\n#define LLVM_CLANG_LIB_CODEGEN_CODEGENMODULE_H\n\n#include \"CGVTables.h\"\n#include \"CodeGenTypeCache.h\"\n#include \"CodeGenTypes.h\"\n#include \"SanitizerMetadata.h\"\n#include \"clang/AST/DeclCXX.h\"\n#include \"clang/AST/DeclObjC.h\"\n#include \"clang/AST/DeclOpenMP.h\"\n#include \"clang/AST/GlobalDecl.h\"\n#include \"clang/AST/Mangle.h\"\n#include \"clang/Basic/ABI.h\"\n#include \"clang/Basic/LangOptions.h\"\n#include \"clang/Basic/Module.h\"\n#include \"clang/Basic/SanitizerBlacklist.h\"\n#include \"clang/Basic/TargetInfo.h\"\n#include \"clang/Basic/XRayLists.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/SetVector.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/IR/Module.h\"\n#include \"llvm/IR/ValueHandle.h\"\n#include \"llvm/Transforms/Utils/SanitizerStats.h\"\n\nnamespace llvm {\nclass Module;\nclass Constant;\nclass ConstantInt;\nclass Function;\nclass GlobalValue;\nclass DataLayout;\nclass FunctionType;\nclass LLVMContext;\nclass OpenMPIRBuilder;\nclass IndexedInstrProfReader;\n}\n\nnamespace clang {\nclass ASTContext;\nclass AtomicType;\nclass FunctionDecl;\nclass IdentifierInfo;\nclass ObjCMethodDecl;\nclass ObjCImplementationDecl;\nclass ObjCCategoryImplDecl;\nclass ObjCProtocolDecl;\nclass ObjCEncodeExpr;\nclass BlockExpr;\nclass CharUnits;\nclass Decl;\nclass Expr;\nclass Stmt;\nclass InitListExpr;\nclass StringLiteral;\nclass NamedDecl;\nclass ValueDecl;\nclass VarDecl;\nclass LangOptions;\nclass CodeGenOptions;\nclass HeaderSearchOptions;\nclass PreprocessorOptions;\nclass DiagnosticsEngine;\nclass AnnotateAttr;\nclass CXXDestructorDecl;\nclass Module;\nclass CoverageSourceInfo;\nclass TargetAttr;\nclass InitSegAttr;\nstruct ParsedTargetAttr;\n\nnamespace CodeGen {\n\nclass CallArgList;\nclass CodeGenFunction;\nclass CodeGenTBAA;\nclass CGCXXABI;\nclass CGDebugInfo;\nclass CGObjCRuntime;\nclass CGOpenCLRuntime;\nclass CGOpenMPRuntime;\nclass CGCUDARuntime;\nclass BlockFieldFlags;\nclass FunctionArgList;\nclass CoverageMappingModuleGen;\nclass TargetCodeGenInfo;\n\nenum ForDefinition_t : bool {\n  NotForDefinition = false,\n  ForDefinition = true\n};\n\nstruct OrderGlobalInits {\n  unsigned int priority;\n  unsigned int lex_order;\n  OrderGlobalInits(unsigned int p, unsigned int l)\n      : priority(p), lex_order(l) {}\n\n  bool operator==(const OrderGlobalInits &RHS) const {\n    return priority == RHS.priority && lex_order == RHS.lex_order;\n  }\n\n  bool operator<(const OrderGlobalInits &RHS) const {\n    return std::tie(priority, lex_order) <\n           std::tie(RHS.priority, RHS.lex_order);\n  }\n};\n\nstruct ObjCEntrypoints {\n  ObjCEntrypoints() { memset(this, 0, sizeof(*this)); }\n\n  /// void objc_alloc(id);\n  llvm::FunctionCallee objc_alloc;\n\n  /// void objc_allocWithZone(id);\n  llvm::FunctionCallee objc_allocWithZone;\n\n  /// void objc_alloc_init(id);\n  llvm::FunctionCallee objc_alloc_init;\n\n  /// void objc_autoreleasePoolPop(void*);\n  llvm::FunctionCallee objc_autoreleasePoolPop;\n\n  /// void objc_autoreleasePoolPop(void*);\n  /// Note this method is used when we are using exception handling\n  llvm::FunctionCallee objc_autoreleasePoolPopInvoke;\n\n  /// void *objc_autoreleasePoolPush(void);\n  llvm::Function *objc_autoreleasePoolPush;\n\n  /// id objc_autorelease(id);\n  llvm::Function *objc_autorelease;\n\n  /// id objc_autorelease(id);\n  /// Note this is the runtime method not the intrinsic.\n  llvm::FunctionCallee objc_autoreleaseRuntimeFunction;\n\n  /// id objc_autoreleaseReturnValue(id);\n  llvm::Function *objc_autoreleaseReturnValue;\n\n  /// void objc_copyWeak(id *dest, id *src);\n  llvm::Function *objc_copyWeak;\n\n  /// void objc_destroyWeak(id*);\n  llvm::Function *objc_destroyWeak;\n\n  /// id objc_initWeak(id*, id);\n  llvm::Function *objc_initWeak;\n\n  /// id objc_loadWeak(id*);\n  llvm::Function *objc_loadWeak;\n\n  /// id objc_loadWeakRetained(id*);\n  llvm::Function *objc_loadWeakRetained;\n\n  /// void objc_moveWeak(id *dest, id *src);\n  llvm::Function *objc_moveWeak;\n\n  /// id objc_retain(id);\n  llvm::Function *objc_retain;\n\n  /// id objc_retain(id);\n  /// Note this is the runtime method not the intrinsic.\n  llvm::FunctionCallee objc_retainRuntimeFunction;\n\n  /// id objc_retainAutorelease(id);\n  llvm::Function *objc_retainAutorelease;\n\n  /// id objc_retainAutoreleaseReturnValue(id);\n  llvm::Function *objc_retainAutoreleaseReturnValue;\n\n  /// id objc_retainAutoreleasedReturnValue(id);\n  llvm::Function *objc_retainAutoreleasedReturnValue;\n\n  /// id objc_retainBlock(id);\n  llvm::Function *objc_retainBlock;\n\n  /// void objc_release(id);\n  llvm::Function *objc_release;\n\n  /// void objc_release(id);\n  /// Note this is the runtime method not the intrinsic.\n  llvm::FunctionCallee objc_releaseRuntimeFunction;\n\n  /// void objc_storeStrong(id*, id);\n  llvm::Function *objc_storeStrong;\n\n  /// id objc_storeWeak(id*, id);\n  llvm::Function *objc_storeWeak;\n\n  /// id objc_unsafeClaimAutoreleasedReturnValue(id);\n  llvm::Function *objc_unsafeClaimAutoreleasedReturnValue;\n\n  /// A void(void) inline asm to use to mark that the return value of\n  /// a call will be immediately retain.\n  llvm::InlineAsm *retainAutoreleasedReturnValueMarker;\n\n  /// void clang.arc.use(...);\n  llvm::Function *clang_arc_use;\n};\n\n/// This class records statistics on instrumentation based profiling.\nclass InstrProfStats {\n  uint32_t VisitedInMainFile;\n  uint32_t MissingInMainFile;\n  uint32_t Visited;\n  uint32_t Missing;\n  uint32_t Mismatched;\n\npublic:\n  InstrProfStats()\n      : VisitedInMainFile(0), MissingInMainFile(0), Visited(0), Missing(0),\n        Mismatched(0) {}\n  /// Record that we've visited a function and whether or not that function was\n  /// in the main source file.\n  void addVisited(bool MainFile) {\n    if (MainFile)\n      ++VisitedInMainFile;\n    ++Visited;\n  }\n  /// Record that a function we've visited has no profile data.\n  void addMissing(bool MainFile) {\n    if (MainFile)\n      ++MissingInMainFile;\n    ++Missing;\n  }\n  /// Record that a function we've visited has mismatched profile data.\n  void addMismatched(bool MainFile) { ++Mismatched; }\n  /// Whether or not the stats we've gathered indicate any potential problems.\n  bool hasDiagnostics() { return Missing || Mismatched; }\n  /// Report potential problems we've found to \\c Diags.\n  void reportDiagnostics(DiagnosticsEngine &Diags, StringRef MainFile);\n};\n\n/// A pair of helper functions for a __block variable.\nclass BlockByrefHelpers : public llvm::FoldingSetNode {\n  // MSVC requires this type to be complete in order to process this\n  // header.\npublic:\n  llvm::Constant *CopyHelper;\n  llvm::Constant *DisposeHelper;\n\n  /// The alignment of the field.  This is important because\n  /// different offsets to the field within the byref struct need to\n  /// have different helper functions.\n  CharUnits Alignment;\n\n  BlockByrefHelpers(CharUnits alignment)\n      : CopyHelper(nullptr), DisposeHelper(nullptr), Alignment(alignment) {}\n  BlockByrefHelpers(const BlockByrefHelpers &) = default;\n  virtual ~BlockByrefHelpers();\n\n  void Profile(llvm::FoldingSetNodeID &id) const {\n    id.AddInteger(Alignment.getQuantity());\n    profileImpl(id);\n  }\n  virtual void profileImpl(llvm::FoldingSetNodeID &id) const = 0;\n\n  virtual bool needsCopy() const { return true; }\n  virtual void emitCopy(CodeGenFunction &CGF, Address dest, Address src) = 0;\n\n  virtual bool needsDispose() const { return true; }\n  virtual void emitDispose(CodeGenFunction &CGF, Address field) = 0;\n};\n\n/// This class organizes the cross-function state that is used while generating\n/// LLVM code.\nclass CodeGenModule : public CodeGenTypeCache {\n  CodeGenModule(const CodeGenModule &) = delete;\n  void operator=(const CodeGenModule &) = delete;\n\npublic:\n  struct Structor {\n    Structor() : Priority(0), Initializer(nullptr), AssociatedData(nullptr) {}\n    Structor(int Priority, llvm::Constant *Initializer,\n             llvm::Constant *AssociatedData)\n        : Priority(Priority), Initializer(Initializer),\n          AssociatedData(AssociatedData) {}\n    int Priority;\n    llvm::Constant *Initializer;\n    llvm::Constant *AssociatedData;\n  };\n\n  typedef std::vector<Structor> CtorList;\n\nprivate:\n  ASTContext &Context;\n  const LangOptions &LangOpts;\n  const HeaderSearchOptions &HeaderSearchOpts; // Only used for debug info.\n  const PreprocessorOptions &PreprocessorOpts; // Only used for debug info.\n  const CodeGenOptions &CodeGenOpts;\n  unsigned NumAutoVarInit = 0;\n  llvm::Module &TheModule;\n  DiagnosticsEngine &Diags;\n  const TargetInfo &Target;\n  std::unique_ptr<CGCXXABI> ABI;\n  llvm::LLVMContext &VMContext;\n\n  std::unique_ptr<CodeGenTBAA> TBAA;\n\n  mutable std::unique_ptr<TargetCodeGenInfo> TheTargetCodeGenInfo;\n\n  // This should not be moved earlier, since its initialization depends on some\n  // of the previous reference members being already initialized and also checks\n  // if TheTargetCodeGenInfo is NULL\n  CodeGenTypes Types;\n\n  /// Holds information about C++ vtables.\n  CodeGenVTables VTables;\n\n  std::unique_ptr<CGObjCRuntime> ObjCRuntime;\n  std::unique_ptr<CGOpenCLRuntime> OpenCLRuntime;\n  std::unique_ptr<CGOpenMPRuntime> OpenMPRuntime;\n  std::unique_ptr<CGCUDARuntime> CUDARuntime;\n  std::unique_ptr<CGDebugInfo> DebugInfo;\n  std::unique_ptr<ObjCEntrypoints> ObjCData;\n  llvm::MDNode *NoObjCARCExceptionsMetadata = nullptr;\n  std::unique_ptr<llvm::IndexedInstrProfReader> PGOReader;\n  InstrProfStats PGOStats;\n  std::unique_ptr<llvm::SanitizerStatReport> SanStats;\n\n  // A set of references that have only been seen via a weakref so far. This is\n  // used to remove the weak of the reference if we ever see a direct reference\n  // or a definition.\n  llvm::SmallPtrSet<llvm::GlobalValue*, 10> WeakRefReferences;\n\n  /// This contains all the decls which have definitions but/ which are deferred\n  /// for emission and therefore should only be output if they are actually\n  /// used. If a decl is in this, then it is known to have not been referenced\n  /// yet.\n  std::map<StringRef, GlobalDecl> DeferredDecls;\n\n  /// This is a list of deferred decls which we have seen that *are* actually\n  /// referenced. These get code generated when the module is done.\n  std::vector<GlobalDecl> DeferredDeclsToEmit;\n  void addDeferredDeclToEmit(GlobalDecl GD) {\n    DeferredDeclsToEmit.emplace_back(GD);\n  }\n\n  /// List of alias we have emitted. Used to make sure that what they point to\n  /// is defined once we get to the end of the of the translation unit.\n  std::vector<GlobalDecl> Aliases;\n\n  /// List of multiversion functions that have to be emitted.  Used to make sure\n  /// we properly emit the iFunc.\n  std::vector<GlobalDecl> MultiVersionFuncs;\n\n  typedef llvm::StringMap<llvm::TrackingVH<llvm::Constant> > ReplacementsTy;\n  ReplacementsTy Replacements;\n\n  /// List of global values to be replaced with something else. Used when we\n  /// want to replace a GlobalValue but can't identify it by its mangled name\n  /// anymore (because the name is already taken).\n  llvm::SmallVector<std::pair<llvm::GlobalValue *, llvm::Constant *>, 8>\n    GlobalValReplacements;\n\n  /// Variables for which we've emitted globals containing their constant\n  /// values along with the corresponding globals, for opportunistic reuse.\n  llvm::DenseMap<const VarDecl*, llvm::GlobalVariable*> InitializerConstants;\n\n  /// Set of global decls for which we already diagnosed mangled name conflict.\n  /// Required to not issue a warning (on a mangling conflict) multiple times\n  /// for the same decl.\n  llvm::DenseSet<GlobalDecl> DiagnosedConflictingDefinitions;\n\n  /// A queue of (optional) vtables to consider emitting.\n  std::vector<const CXXRecordDecl*> DeferredVTables;\n\n  /// A queue of (optional) vtables that may be emitted opportunistically.\n  std::vector<const CXXRecordDecl *> OpportunisticVTables;\n\n  /// List of global values which are required to be present in the object file;\n  /// bitcast to i8*. This is used for forcing visibility of symbols which may\n  /// otherwise be optimized out.\n  std::vector<llvm::WeakTrackingVH> LLVMUsed;\n  std::vector<llvm::WeakTrackingVH> LLVMCompilerUsed;\n\n  /// Store the list of global constructors and their respective priorities to\n  /// be emitted when the translation unit is complete.\n  CtorList GlobalCtors;\n\n  /// Store the list of global destructors and their respective priorities to be\n  /// emitted when the translation unit is complete.\n  CtorList GlobalDtors;\n\n  /// An ordered map of canonical GlobalDecls to their mangled names.\n  llvm::MapVector<GlobalDecl, StringRef> MangledDeclNames;\n  llvm::StringMap<GlobalDecl, llvm::BumpPtrAllocator> Manglings;\n\n  // An ordered map of canonical GlobalDecls paired with the cpu-index for\n  // cpu-specific name manglings.\n  llvm::MapVector<std::pair<GlobalDecl, unsigned>, StringRef>\n      CPUSpecificMangledDeclNames;\n  llvm::StringMap<std::pair<GlobalDecl, unsigned>, llvm::BumpPtrAllocator>\n      CPUSpecificManglings;\n\n  /// Global annotations.\n  std::vector<llvm::Constant*> Annotations;\n\n  /// Map used to get unique annotation strings.\n  llvm::StringMap<llvm::Constant*> AnnotationStrings;\n\n  /// Used for uniquing of annotation arguments.\n  llvm::DenseMap<unsigned, llvm::Constant *> AnnotationArgs;\n\n  llvm::StringMap<llvm::GlobalVariable *> CFConstantStringMap;\n\n  llvm::DenseMap<llvm::Constant *, llvm::GlobalVariable *> ConstantStringMap;\n  llvm::DenseMap<const Decl*, llvm::Constant *> StaticLocalDeclMap;\n  llvm::DenseMap<const Decl*, llvm::GlobalVariable*> StaticLocalDeclGuardMap;\n  llvm::DenseMap<const Expr*, llvm::Constant *> MaterializedGlobalTemporaryMap;\n\n  llvm::DenseMap<QualType, llvm::Constant *> AtomicSetterHelperFnMap;\n  llvm::DenseMap<QualType, llvm::Constant *> AtomicGetterHelperFnMap;\n\n  /// Map used to get unique type descriptor constants for sanitizers.\n  llvm::DenseMap<QualType, llvm::Constant *> TypeDescriptorMap;\n\n  /// Map used to track internal linkage functions declared within\n  /// extern \"C\" regions.\n  typedef llvm::MapVector<IdentifierInfo *,\n                          llvm::GlobalValue *> StaticExternCMap;\n  StaticExternCMap StaticExternCValues;\n\n  /// thread_local variables defined or used in this TU.\n  std::vector<const VarDecl *> CXXThreadLocals;\n\n  /// thread_local variables with initializers that need to run\n  /// before any thread_local variable in this TU is odr-used.\n  std::vector<llvm::Function *> CXXThreadLocalInits;\n  std::vector<const VarDecl *> CXXThreadLocalInitVars;\n\n  /// Global variables with initializers that need to run before main.\n  std::vector<llvm::Function *> CXXGlobalInits;\n\n  /// When a C++ decl with an initializer is deferred, null is\n  /// appended to CXXGlobalInits, and the index of that null is placed\n  /// here so that the initializer will be performed in the correct\n  /// order. Once the decl is emitted, the index is replaced with ~0U to ensure\n  /// that we don't re-emit the initializer.\n  llvm::DenseMap<const Decl*, unsigned> DelayedCXXInitPosition;\n\n  typedef std::pair<OrderGlobalInits, llvm::Function*> GlobalInitData;\n\n  struct GlobalInitPriorityCmp {\n    bool operator()(const GlobalInitData &LHS,\n                    const GlobalInitData &RHS) const {\n      return LHS.first.priority < RHS.first.priority;\n    }\n  };\n\n  /// Global variables with initializers whose order of initialization is set by\n  /// init_priority attribute.\n  SmallVector<GlobalInitData, 8> PrioritizedCXXGlobalInits;\n\n  /// Global destructor functions and arguments that need to run on termination.\n  /// When UseSinitAndSterm is set, it instead contains sterm finalizer\n  /// functions, which also run on unloading a shared library.\n  std::vector<\n      std::tuple<llvm::FunctionType *, llvm::WeakTrackingVH, llvm::Constant *>>\n      CXXGlobalDtorsOrStermFinalizers;\n\n  /// The complete set of modules that has been imported.\n  llvm::SetVector<clang::Module *> ImportedModules;\n\n  /// The set of modules for which the module initializers\n  /// have been emitted.\n  llvm::SmallPtrSet<clang::Module *, 16> EmittedModuleInitializers;\n\n  /// A vector of metadata strings for linker options.\n  SmallVector<llvm::MDNode *, 16> LinkerOptionsMetadata;\n\n  /// A vector of metadata strings for dependent libraries for ELF.\n  SmallVector<llvm::MDNode *, 16> ELFDependentLibraries;\n\n  /// @name Cache for Objective-C runtime types\n  /// @{\n\n  /// Cached reference to the class for constant strings. This value has type\n  /// int * but is actually an Obj-C class pointer.\n  llvm::WeakTrackingVH CFConstantStringClassRef;\n\n  /// The type used to describe the state of a fast enumeration in\n  /// Objective-C's for..in loop.\n  QualType ObjCFastEnumerationStateType;\n\n  /// @}\n\n  /// Lazily create the Objective-C runtime\n  void createObjCRuntime();\n\n  void createOpenCLRuntime();\n  void createOpenMPRuntime();\n  void createCUDARuntime();\n\n  bool isTriviallyRecursive(const FunctionDecl *F);\n  bool shouldEmitFunction(GlobalDecl GD);\n  bool shouldOpportunisticallyEmitVTables();\n  /// Map used to be sure we don't emit the same CompoundLiteral twice.\n  llvm::DenseMap<const CompoundLiteralExpr *, llvm::GlobalVariable *>\n      EmittedCompoundLiterals;\n\n  /// Map of the global blocks we've emitted, so that we don't have to re-emit\n  /// them if the constexpr evaluator gets aggressive.\n  llvm::DenseMap<const BlockExpr *, llvm::Constant *> EmittedGlobalBlocks;\n\n  /// @name Cache for Blocks Runtime Globals\n  /// @{\n\n  llvm::Constant *NSConcreteGlobalBlock = nullptr;\n  llvm::Constant *NSConcreteStackBlock = nullptr;\n\n  llvm::FunctionCallee BlockObjectAssign = nullptr;\n  llvm::FunctionCallee BlockObjectDispose = nullptr;\n\n  llvm::Type *BlockDescriptorType = nullptr;\n  llvm::Type *GenericBlockLiteralType = nullptr;\n\n  struct {\n    int GlobalUniqueCount;\n  } Block;\n\n  GlobalDecl initializedGlobalDecl;\n\n  /// @}\n\n  /// void @llvm.lifetime.start(i64 %size, i8* nocapture <ptr>)\n  llvm::Function *LifetimeStartFn = nullptr;\n\n  /// void @llvm.lifetime.end(i64 %size, i8* nocapture <ptr>)\n  llvm::Function *LifetimeEndFn = nullptr;\n\n  std::unique_ptr<SanitizerMetadata> SanitizerMD;\n\n  llvm::MapVector<const Decl *, bool> DeferredEmptyCoverageMappingDecls;\n\n  std::unique_ptr<CoverageMappingModuleGen> CoverageMapping;\n\n  /// Mapping from canonical types to their metadata identifiers. We need to\n  /// maintain this mapping because identifiers may be formed from distinct\n  /// MDNodes.\n  typedef llvm::DenseMap<QualType, llvm::Metadata *> MetadataTypeMap;\n  MetadataTypeMap MetadataIdMap;\n  MetadataTypeMap VirtualMetadataIdMap;\n  MetadataTypeMap GeneralizedMetadataIdMap;\n\npublic:\n  CodeGenModule(ASTContext &C, const HeaderSearchOptions &headersearchopts,\n                const PreprocessorOptions &ppopts,\n                const CodeGenOptions &CodeGenOpts, llvm::Module &M,\n                DiagnosticsEngine &Diags,\n                CoverageSourceInfo *CoverageInfo = nullptr);\n\n  ~CodeGenModule();\n\n  void clear();\n\n  /// Finalize LLVM code generation.\n  void Release();\n\n  /// Return true if we should emit location information for expressions.\n  bool getExpressionLocationsEnabled() const;\n\n  /// Return a reference to the configured Objective-C runtime.\n  CGObjCRuntime &getObjCRuntime() {\n    if (!ObjCRuntime) createObjCRuntime();\n    return *ObjCRuntime;\n  }\n\n  /// Return true iff an Objective-C runtime has been configured.\n  bool hasObjCRuntime() { return !!ObjCRuntime; }\n\n  /// Return a reference to the configured OpenCL runtime.\n  CGOpenCLRuntime &getOpenCLRuntime() {\n    assert(OpenCLRuntime != nullptr);\n    return *OpenCLRuntime;\n  }\n\n  /// Return a reference to the configured OpenMP runtime.\n  CGOpenMPRuntime &getOpenMPRuntime() {\n    assert(OpenMPRuntime != nullptr);\n    return *OpenMPRuntime;\n  }\n\n  /// Return a reference to the configured CUDA runtime.\n  CGCUDARuntime &getCUDARuntime() {\n    assert(CUDARuntime != nullptr);\n    return *CUDARuntime;\n  }\n\n  ObjCEntrypoints &getObjCEntrypoints() const {\n    assert(ObjCData != nullptr);\n    return *ObjCData;\n  }\n\n  // Version checking functions, used to implement ObjC's @available:\n  // i32 @__isOSVersionAtLeast(i32, i32, i32)\n  llvm::FunctionCallee IsOSVersionAtLeastFn = nullptr;\n  // i32 @__isPlatformVersionAtLeast(i32, i32, i32, i32)\n  llvm::FunctionCallee IsPlatformVersionAtLeastFn = nullptr;\n\n  InstrProfStats &getPGOStats() { return PGOStats; }\n  llvm::IndexedInstrProfReader *getPGOReader() const { return PGOReader.get(); }\n\n  CoverageMappingModuleGen *getCoverageMapping() const {\n    return CoverageMapping.get();\n  }\n\n  llvm::Constant *getStaticLocalDeclAddress(const VarDecl *D) {\n    return StaticLocalDeclMap[D];\n  }\n  void setStaticLocalDeclAddress(const VarDecl *D,\n                                 llvm::Constant *C) {\n    StaticLocalDeclMap[D] = C;\n  }\n\n  llvm::Constant *\n  getOrCreateStaticVarDecl(const VarDecl &D,\n                           llvm::GlobalValue::LinkageTypes Linkage);\n\n  llvm::GlobalVariable *getStaticLocalDeclGuardAddress(const VarDecl *D) {\n    return StaticLocalDeclGuardMap[D];\n  }\n  void setStaticLocalDeclGuardAddress(const VarDecl *D,\n                                      llvm::GlobalVariable *C) {\n    StaticLocalDeclGuardMap[D] = C;\n  }\n\n  Address createUnnamedGlobalFrom(const VarDecl &D, llvm::Constant *Constant,\n                                  CharUnits Align);\n\n  bool lookupRepresentativeDecl(StringRef MangledName,\n                                GlobalDecl &Result) const;\n\n  llvm::Constant *getAtomicSetterHelperFnMap(QualType Ty) {\n    return AtomicSetterHelperFnMap[Ty];\n  }\n  void setAtomicSetterHelperFnMap(QualType Ty,\n                            llvm::Constant *Fn) {\n    AtomicSetterHelperFnMap[Ty] = Fn;\n  }\n\n  llvm::Constant *getAtomicGetterHelperFnMap(QualType Ty) {\n    return AtomicGetterHelperFnMap[Ty];\n  }\n  void setAtomicGetterHelperFnMap(QualType Ty,\n                            llvm::Constant *Fn) {\n    AtomicGetterHelperFnMap[Ty] = Fn;\n  }\n\n  llvm::Constant *getTypeDescriptorFromMap(QualType Ty) {\n    return TypeDescriptorMap[Ty];\n  }\n  void setTypeDescriptorInMap(QualType Ty, llvm::Constant *C) {\n    TypeDescriptorMap[Ty] = C;\n  }\n\n  CGDebugInfo *getModuleDebugInfo() { return DebugInfo.get(); }\n\n  llvm::MDNode *getNoObjCARCExceptionsMetadata() {\n    if (!NoObjCARCExceptionsMetadata)\n      NoObjCARCExceptionsMetadata = llvm::MDNode::get(getLLVMContext(), None);\n    return NoObjCARCExceptionsMetadata;\n  }\n\n  ASTContext &getContext() const { return Context; }\n  const LangOptions &getLangOpts() const { return LangOpts; }\n  const HeaderSearchOptions &getHeaderSearchOpts()\n    const { return HeaderSearchOpts; }\n  const PreprocessorOptions &getPreprocessorOpts()\n    const { return PreprocessorOpts; }\n  const CodeGenOptions &getCodeGenOpts() const { return CodeGenOpts; }\n  llvm::Module &getModule() const { return TheModule; }\n  DiagnosticsEngine &getDiags() const { return Diags; }\n  const llvm::DataLayout &getDataLayout() const {\n    return TheModule.getDataLayout();\n  }\n  const TargetInfo &getTarget() const { return Target; }\n  const llvm::Triple &getTriple() const { return Target.getTriple(); }\n  bool supportsCOMDAT() const;\n  void maybeSetTrivialComdat(const Decl &D, llvm::GlobalObject &GO);\n\n  CGCXXABI &getCXXABI() const { return *ABI; }\n  llvm::LLVMContext &getLLVMContext() { return VMContext; }\n\n  bool shouldUseTBAA() const { return TBAA != nullptr; }\n\n  const TargetCodeGenInfo &getTargetCodeGenInfo();\n\n  CodeGenTypes &getTypes() { return Types; }\n\n  CodeGenVTables &getVTables() { return VTables; }\n\n  ItaniumVTableContext &getItaniumVTableContext() {\n    return VTables.getItaniumVTableContext();\n  }\n\n  MicrosoftVTableContext &getMicrosoftVTableContext() {\n    return VTables.getMicrosoftVTableContext();\n  }\n\n  CtorList &getGlobalCtors() { return GlobalCtors; }\n  CtorList &getGlobalDtors() { return GlobalDtors; }\n\n  /// getTBAATypeInfo - Get metadata used to describe accesses to objects of\n  /// the given type.\n  llvm::MDNode *getTBAATypeInfo(QualType QTy);\n\n  /// getTBAAAccessInfo - Get TBAA information that describes an access to\n  /// an object of the given type.\n  TBAAAccessInfo getTBAAAccessInfo(QualType AccessType);\n\n  /// getTBAAVTablePtrAccessInfo - Get the TBAA information that describes an\n  /// access to a virtual table pointer.\n  TBAAAccessInfo getTBAAVTablePtrAccessInfo(llvm::Type *VTablePtrType);\n\n  llvm::MDNode *getTBAAStructInfo(QualType QTy);\n\n  /// getTBAABaseTypeInfo - Get metadata that describes the given base access\n  /// type. Return null if the type is not suitable for use in TBAA access tags.\n  llvm::MDNode *getTBAABaseTypeInfo(QualType QTy);\n\n  /// getTBAAAccessTagInfo - Get TBAA tag for a given memory access.\n  llvm::MDNode *getTBAAAccessTagInfo(TBAAAccessInfo Info);\n\n  /// mergeTBAAInfoForCast - Get merged TBAA information for the purposes of\n  /// type casts.\n  TBAAAccessInfo mergeTBAAInfoForCast(TBAAAccessInfo SourceInfo,\n                                      TBAAAccessInfo TargetInfo);\n\n  /// mergeTBAAInfoForConditionalOperator - Get merged TBAA information for the\n  /// purposes of conditional operator.\n  TBAAAccessInfo mergeTBAAInfoForConditionalOperator(TBAAAccessInfo InfoA,\n                                                     TBAAAccessInfo InfoB);\n\n  /// mergeTBAAInfoForMemoryTransfer - Get merged TBAA information for the\n  /// purposes of memory transfer calls.\n  TBAAAccessInfo mergeTBAAInfoForMemoryTransfer(TBAAAccessInfo DestInfo,\n                                                TBAAAccessInfo SrcInfo);\n\n  /// getTBAAInfoForSubobject - Get TBAA information for an access with a given\n  /// base lvalue.\n  TBAAAccessInfo getTBAAInfoForSubobject(LValue Base, QualType AccessType) {\n    if (Base.getTBAAInfo().isMayAlias())\n      return TBAAAccessInfo::getMayAliasInfo();\n    return getTBAAAccessInfo(AccessType);\n  }\n\n  bool isTypeConstant(QualType QTy, bool ExcludeCtorDtor);\n\n  bool isPaddedAtomicType(QualType type);\n  bool isPaddedAtomicType(const AtomicType *type);\n\n  /// DecorateInstructionWithTBAA - Decorate the instruction with a TBAA tag.\n  void DecorateInstructionWithTBAA(llvm::Instruction *Inst,\n                                   TBAAAccessInfo TBAAInfo);\n\n  /// Adds !invariant.barrier !tag to instruction\n  void DecorateInstructionWithInvariantGroup(llvm::Instruction *I,\n                                             const CXXRecordDecl *RD);\n\n  /// Emit the given number of characters as a value of type size_t.\n  llvm::ConstantInt *getSize(CharUnits numChars);\n\n  /// Set the visibility for the given LLVM GlobalValue.\n  void setGlobalVisibility(llvm::GlobalValue *GV, const NamedDecl *D) const;\n\n  void setDSOLocal(llvm::GlobalValue *GV) const;\n\n  void setDLLImportDLLExport(llvm::GlobalValue *GV, GlobalDecl D) const;\n  void setDLLImportDLLExport(llvm::GlobalValue *GV, const NamedDecl *D) const;\n  /// Set visibility, dllimport/dllexport and dso_local.\n  /// This must be called after dllimport/dllexport is set.\n  void setGVProperties(llvm::GlobalValue *GV, GlobalDecl GD) const;\n  void setGVProperties(llvm::GlobalValue *GV, const NamedDecl *D) const;\n\n  void setGVPropertiesAux(llvm::GlobalValue *GV, const NamedDecl *D) const;\n\n  /// Set the TLS mode for the given LLVM GlobalValue for the thread-local\n  /// variable declaration D.\n  void setTLSMode(llvm::GlobalValue *GV, const VarDecl &D) const;\n\n  /// Get LLVM TLS mode from CodeGenOptions.\n  llvm::GlobalVariable::ThreadLocalMode GetDefaultLLVMTLSModel() const;\n\n  static llvm::GlobalValue::VisibilityTypes GetLLVMVisibility(Visibility V) {\n    switch (V) {\n    case DefaultVisibility:   return llvm::GlobalValue::DefaultVisibility;\n    case HiddenVisibility:    return llvm::GlobalValue::HiddenVisibility;\n    case ProtectedVisibility: return llvm::GlobalValue::ProtectedVisibility;\n    }\n    llvm_unreachable(\"unknown visibility!\");\n  }\n\n  llvm::Constant *GetAddrOfGlobal(GlobalDecl GD,\n                                  ForDefinition_t IsForDefinition\n                                    = NotForDefinition);\n\n  /// Will return a global variable of the given type. If a variable with a\n  /// different type already exists then a new  variable with the right type\n  /// will be created and all uses of the old variable will be replaced with a\n  /// bitcast to the new variable.\n  llvm::GlobalVariable *\n  CreateOrReplaceCXXRuntimeVariable(StringRef Name, llvm::Type *Ty,\n                                    llvm::GlobalValue::LinkageTypes Linkage,\n                                    unsigned Alignment);\n\n  llvm::Function *CreateGlobalInitOrCleanUpFunction(\n      llvm::FunctionType *ty, const Twine &name, const CGFunctionInfo &FI,\n      SourceLocation Loc = SourceLocation(), bool TLS = false);\n\n  /// Return the AST address space of the underlying global variable for D, as\n  /// determined by its declaration. Normally this is the same as the address\n  /// space of D's type, but in CUDA, address spaces are associated with\n  /// declarations, not types. If D is nullptr, return the default address\n  /// space for global variable.\n  ///\n  /// For languages without explicit address spaces, if D has default address\n  /// space, target-specific global or constant address space may be returned.\n  LangAS GetGlobalVarAddressSpace(const VarDecl *D);\n\n  /// Return the llvm::Constant for the address of the given global variable.\n  /// If Ty is non-null and if the global doesn't exist, then it will be created\n  /// with the specified type instead of whatever the normal requested type\n  /// would be. If IsForDefinition is true, it is guaranteed that an actual\n  /// global with type Ty will be returned, not conversion of a variable with\n  /// the same mangled name but some other type.\n  llvm::Constant *GetAddrOfGlobalVar(const VarDecl *D,\n                                     llvm::Type *Ty = nullptr,\n                                     ForDefinition_t IsForDefinition\n                                       = NotForDefinition);\n\n  /// Return the AST address space of string literal, which is used to emit\n  /// the string literal as global variable in LLVM IR.\n  /// Note: This is not necessarily the address space of the string literal\n  /// in AST. For address space agnostic language, e.g. C++, string literal\n  /// in AST is always in default address space.\n  LangAS getStringLiteralAddressSpace() const;\n\n  /// Return the address of the given function. If Ty is non-null, then this\n  /// function will use the specified type if it has to create it.\n  llvm::Constant *GetAddrOfFunction(GlobalDecl GD, llvm::Type *Ty = nullptr,\n                                    bool ForVTable = false,\n                                    bool DontDefer = false,\n                                    ForDefinition_t IsForDefinition\n                                      = NotForDefinition);\n\n  /// Get the address of the RTTI descriptor for the given type.\n  llvm::Constant *GetAddrOfRTTIDescriptor(QualType Ty, bool ForEH = false);\n\n  /// Get the address of a GUID.\n  ConstantAddress GetAddrOfMSGuidDecl(const MSGuidDecl *GD);\n\n  /// Get the address of a template parameter object.\n  ConstantAddress\n  GetAddrOfTemplateParamObject(const TemplateParamObjectDecl *TPO);\n\n  /// Get the address of the thunk for the given global decl.\n  llvm::Constant *GetAddrOfThunk(StringRef Name, llvm::Type *FnTy,\n                                 GlobalDecl GD);\n\n  /// Get a reference to the target of VD.\n  ConstantAddress GetWeakRefReference(const ValueDecl *VD);\n\n  /// Returns the assumed alignment of an opaque pointer to the given class.\n  CharUnits getClassPointerAlignment(const CXXRecordDecl *CD);\n\n  /// Returns the minimum object size for an object of the given class type\n  /// (or a class derived from it).\n  CharUnits getMinimumClassObjectSize(const CXXRecordDecl *CD);\n\n  /// Returns the minimum object size for an object of the given type.\n  CharUnits getMinimumObjectSize(QualType Ty) {\n    if (CXXRecordDecl *RD = Ty->getAsCXXRecordDecl())\n      return getMinimumClassObjectSize(RD);\n    return getContext().getTypeSizeInChars(Ty);\n  }\n\n  /// Returns the assumed alignment of a virtual base of a class.\n  CharUnits getVBaseAlignment(CharUnits DerivedAlign,\n                              const CXXRecordDecl *Derived,\n                              const CXXRecordDecl *VBase);\n\n  /// Given a class pointer with an actual known alignment, and the\n  /// expected alignment of an object at a dynamic offset w.r.t that\n  /// pointer, return the alignment to assume at the offset.\n  CharUnits getDynamicOffsetAlignment(CharUnits ActualAlign,\n                                      const CXXRecordDecl *Class,\n                                      CharUnits ExpectedTargetAlign);\n\n  CharUnits\n  computeNonVirtualBaseClassOffset(const CXXRecordDecl *DerivedClass,\n                                   CastExpr::path_const_iterator Start,\n                                   CastExpr::path_const_iterator End);\n\n  /// Returns the offset from a derived class to  a class. Returns null if the\n  /// offset is 0.\n  llvm::Constant *\n  GetNonVirtualBaseClassOffset(const CXXRecordDecl *ClassDecl,\n                               CastExpr::path_const_iterator PathBegin,\n                               CastExpr::path_const_iterator PathEnd);\n\n  llvm::FoldingSet<BlockByrefHelpers> ByrefHelpersCache;\n\n  /// Fetches the global unique block count.\n  int getUniqueBlockCount() { return ++Block.GlobalUniqueCount; }\n\n  /// Fetches the type of a generic block descriptor.\n  llvm::Type *getBlockDescriptorType();\n\n  /// The type of a generic block literal.\n  llvm::Type *getGenericBlockLiteralType();\n\n  /// Gets the address of a block which requires no captures.\n  llvm::Constant *GetAddrOfGlobalBlock(const BlockExpr *BE, StringRef Name);\n\n  /// Returns the address of a block which requires no caputres, or null if\n  /// we've yet to emit the block for BE.\n  llvm::Constant *getAddrOfGlobalBlockIfEmitted(const BlockExpr *BE) {\n    return EmittedGlobalBlocks.lookup(BE);\n  }\n\n  /// Notes that BE's global block is available via Addr. Asserts that BE\n  /// isn't already emitted.\n  void setAddrOfGlobalBlock(const BlockExpr *BE, llvm::Constant *Addr);\n\n  /// Return a pointer to a constant CFString object for the given string.\n  ConstantAddress GetAddrOfConstantCFString(const StringLiteral *Literal);\n\n  /// Return a pointer to a constant NSString object for the given string. Or a\n  /// user defined String object as defined via\n  /// -fconstant-string-class=class_name option.\n  ConstantAddress GetAddrOfConstantString(const StringLiteral *Literal);\n\n  /// Return a constant array for the given string.\n  llvm::Constant *GetConstantArrayFromStringLiteral(const StringLiteral *E);\n\n  /// Return a pointer to a constant array for the given string literal.\n  ConstantAddress\n  GetAddrOfConstantStringFromLiteral(const StringLiteral *S,\n                                     StringRef Name = \".str\");\n\n  /// Return a pointer to a constant array for the given ObjCEncodeExpr node.\n  ConstantAddress\n  GetAddrOfConstantStringFromObjCEncode(const ObjCEncodeExpr *);\n\n  /// Returns a pointer to a character array containing the literal and a\n  /// terminating '\\0' character. The result has pointer to array type.\n  ///\n  /// \\param GlobalName If provided, the name to use for the global (if one is\n  /// created).\n  ConstantAddress\n  GetAddrOfConstantCString(const std::string &Str,\n                           const char *GlobalName = nullptr);\n\n  /// Returns a pointer to a constant global variable for the given file-scope\n  /// compound literal expression.\n  ConstantAddress GetAddrOfConstantCompoundLiteral(const CompoundLiteralExpr*E);\n\n  /// If it's been emitted already, returns the GlobalVariable corresponding to\n  /// a compound literal. Otherwise, returns null.\n  llvm::GlobalVariable *\n  getAddrOfConstantCompoundLiteralIfEmitted(const CompoundLiteralExpr *E);\n\n  /// Notes that CLE's GlobalVariable is GV. Asserts that CLE isn't already\n  /// emitted.\n  void setAddrOfConstantCompoundLiteral(const CompoundLiteralExpr *CLE,\n                                        llvm::GlobalVariable *GV);\n\n  /// Returns a pointer to a global variable representing a temporary\n  /// with static or thread storage duration.\n  ConstantAddress GetAddrOfGlobalTemporary(const MaterializeTemporaryExpr *E,\n                                           const Expr *Inner);\n\n  /// Retrieve the record type that describes the state of an\n  /// Objective-C fast enumeration loop (for..in).\n  QualType getObjCFastEnumerationStateType();\n\n  // Produce code for this constructor/destructor. This method doesn't try\n  // to apply any ABI rules about which other constructors/destructors\n  // are needed or if they are alias to each other.\n  llvm::Function *codegenCXXStructor(GlobalDecl GD);\n\n  /// Return the address of the constructor/destructor of the given type.\n  llvm::Constant *\n  getAddrOfCXXStructor(GlobalDecl GD, const CGFunctionInfo *FnInfo = nullptr,\n                       llvm::FunctionType *FnType = nullptr,\n                       bool DontDefer = false,\n                       ForDefinition_t IsForDefinition = NotForDefinition) {\n    return cast<llvm::Constant>(getAddrAndTypeOfCXXStructor(GD, FnInfo, FnType,\n                                                            DontDefer,\n                                                            IsForDefinition)\n                                    .getCallee());\n  }\n\n  llvm::FunctionCallee getAddrAndTypeOfCXXStructor(\n      GlobalDecl GD, const CGFunctionInfo *FnInfo = nullptr,\n      llvm::FunctionType *FnType = nullptr, bool DontDefer = false,\n      ForDefinition_t IsForDefinition = NotForDefinition);\n\n  /// Given a builtin id for a function like \"__builtin_fabsf\", return a\n  /// Function* for \"fabsf\".\n  llvm::Constant *getBuiltinLibFunction(const FunctionDecl *FD,\n                                        unsigned BuiltinID);\n\n  llvm::Function *getIntrinsic(unsigned IID, ArrayRef<llvm::Type*> Tys = None);\n\n  /// Emit code for a single top level declaration.\n  void EmitTopLevelDecl(Decl *D);\n\n  /// Stored a deferred empty coverage mapping for an unused\n  /// and thus uninstrumented top level declaration.\n  void AddDeferredUnusedCoverageMapping(Decl *D);\n\n  /// Remove the deferred empty coverage mapping as this\n  /// declaration is actually instrumented.\n  void ClearUnusedCoverageMapping(const Decl *D);\n\n  /// Emit all the deferred coverage mappings\n  /// for the uninstrumented functions.\n  void EmitDeferredUnusedCoverageMappings();\n\n  /// Emit an alias for \"main\" if it has no arguments (needed for wasm).\n  void EmitMainVoidAlias();\n\n  /// Tell the consumer that this variable has been instantiated.\n  void HandleCXXStaticMemberVarInstantiation(VarDecl *VD);\n\n  /// If the declaration has internal linkage but is inside an\n  /// extern \"C\" linkage specification, prepare to emit an alias for it\n  /// to the expected name.\n  template<typename SomeDecl>\n  void MaybeHandleStaticInExternC(const SomeDecl *D, llvm::GlobalValue *GV);\n\n  /// Add a global to a list to be added to the llvm.used metadata.\n  void addUsedGlobal(llvm::GlobalValue *GV);\n\n  /// Add a global to a list to be added to the llvm.compiler.used metadata.\n  void addCompilerUsedGlobal(llvm::GlobalValue *GV);\n\n  /// Add a destructor and object to add to the C++ global destructor function.\n  void AddCXXDtorEntry(llvm::FunctionCallee DtorFn, llvm::Constant *Object) {\n    CXXGlobalDtorsOrStermFinalizers.emplace_back(DtorFn.getFunctionType(),\n                                                 DtorFn.getCallee(), Object);\n  }\n\n  /// Add an sterm finalizer to the C++ global cleanup function.\n  void AddCXXStermFinalizerEntry(llvm::FunctionCallee DtorFn) {\n    CXXGlobalDtorsOrStermFinalizers.emplace_back(DtorFn.getFunctionType(),\n                                                 DtorFn.getCallee(), nullptr);\n  }\n\n  /// Add an sterm finalizer to its own llvm.global_dtors entry.\n  void AddCXXStermFinalizerToGlobalDtor(llvm::Function *StermFinalizer,\n                                        int Priority) {\n    AddGlobalDtor(StermFinalizer, Priority);\n  }\n\n  /// Create or return a runtime function declaration with the specified type\n  /// and name. If \\p AssumeConvergent is true, the call will have the\n  /// convergent attribute added.\n  llvm::FunctionCallee\n  CreateRuntimeFunction(llvm::FunctionType *Ty, StringRef Name,\n                        llvm::AttributeList ExtraAttrs = llvm::AttributeList(),\n                        bool Local = false, bool AssumeConvergent = false);\n\n  /// Create a new runtime global variable with the specified type and name.\n  llvm::Constant *CreateRuntimeVariable(llvm::Type *Ty,\n                                        StringRef Name);\n\n  ///@name Custom Blocks Runtime Interfaces\n  ///@{\n\n  llvm::Constant *getNSConcreteGlobalBlock();\n  llvm::Constant *getNSConcreteStackBlock();\n  llvm::FunctionCallee getBlockObjectAssign();\n  llvm::FunctionCallee getBlockObjectDispose();\n\n  ///@}\n\n  llvm::Function *getLLVMLifetimeStartFn();\n  llvm::Function *getLLVMLifetimeEndFn();\n\n  // Make sure that this type is translated.\n  void UpdateCompletedType(const TagDecl *TD);\n\n  llvm::Constant *getMemberPointerConstant(const UnaryOperator *e);\n\n  /// Emit type info if type of an expression is a variably modified\n  /// type. Also emit proper debug info for cast types.\n  void EmitExplicitCastExprType(const ExplicitCastExpr *E,\n                                CodeGenFunction *CGF = nullptr);\n\n  /// Return the result of value-initializing the given type, i.e. a null\n  /// expression of the given type.  This is usually, but not always, an LLVM\n  /// null constant.\n  llvm::Constant *EmitNullConstant(QualType T);\n\n  /// Return a null constant appropriate for zero-initializing a base class with\n  /// the given type. This is usually, but not always, an LLVM null constant.\n  llvm::Constant *EmitNullConstantForBase(const CXXRecordDecl *Record);\n\n  /// Emit a general error that something can't be done.\n  void Error(SourceLocation loc, StringRef error);\n\n  /// Print out an error that codegen doesn't support the specified stmt yet.\n  void ErrorUnsupported(const Stmt *S, const char *Type);\n\n  /// Print out an error that codegen doesn't support the specified decl yet.\n  void ErrorUnsupported(const Decl *D, const char *Type);\n\n  /// Set the attributes on the LLVM function for the given decl and function\n  /// info. This applies attributes necessary for handling the ABI as well as\n  /// user specified attributes like section.\n  void SetInternalFunctionAttributes(GlobalDecl GD, llvm::Function *F,\n                                     const CGFunctionInfo &FI);\n\n  /// Set the LLVM function attributes (sext, zext, etc).\n  void SetLLVMFunctionAttributes(GlobalDecl GD, const CGFunctionInfo &Info,\n                                 llvm::Function *F);\n\n  /// Set the LLVM function attributes which only apply to a function\n  /// definition.\n  void SetLLVMFunctionAttributesForDefinition(const Decl *D, llvm::Function *F);\n\n  /// Set the LLVM function attributes that represent floating point\n  /// environment.\n  void setLLVMFunctionFEnvAttributes(const FunctionDecl *D, llvm::Function *F);\n\n  /// Return true iff the given type uses 'sret' when used as a return type.\n  bool ReturnTypeUsesSRet(const CGFunctionInfo &FI);\n\n  /// Return true iff the given type uses an argument slot when 'sret' is used\n  /// as a return type.\n  bool ReturnSlotInterferesWithArgs(const CGFunctionInfo &FI);\n\n  /// Return true iff the given type uses 'fpret' when used as a return type.\n  bool ReturnTypeUsesFPRet(QualType ResultType);\n\n  /// Return true iff the given type uses 'fp2ret' when used as a return type.\n  bool ReturnTypeUsesFP2Ret(QualType ResultType);\n\n  /// Get the LLVM attributes and calling convention to use for a particular\n  /// function type.\n  ///\n  /// \\param Name - The function name.\n  /// \\param Info - The function type information.\n  /// \\param CalleeInfo - The callee information these attributes are being\n  /// constructed for. If valid, the attributes applied to this decl may\n  /// contribute to the function attributes and calling convention.\n  /// \\param Attrs [out] - On return, the attribute list to use.\n  /// \\param CallingConv [out] - On return, the LLVM calling convention to use.\n  void ConstructAttributeList(StringRef Name, const CGFunctionInfo &Info,\n                              CGCalleeInfo CalleeInfo,\n                              llvm::AttributeList &Attrs, unsigned &CallingConv,\n                              bool AttrOnCallSite);\n\n  /// Adds attributes to F according to our CodeGenOptions and LangOptions, as\n  /// though we had emitted it ourselves.  We remove any attributes on F that\n  /// conflict with the attributes we add here.\n  ///\n  /// This is useful for adding attrs to bitcode modules that you want to link\n  /// with but don't control, such as CUDA's libdevice.  When linking with such\n  /// a bitcode library, you might want to set e.g. its functions'\n  /// \"unsafe-fp-math\" attribute to match the attr of the functions you're\n  /// codegen'ing.  Otherwise, LLVM will interpret the bitcode module's lack of\n  /// unsafe-fp-math attrs as tantamount to unsafe-fp-math=false, and then LLVM\n  /// will propagate unsafe-fp-math=false up to every transitive caller of a\n  /// function in the bitcode library!\n  ///\n  /// With the exception of fast-math attrs, this will only make the attributes\n  /// on the function more conservative.  But it's unsafe to call this on a\n  /// function which relies on particular fast-math attributes for correctness.\n  /// It's up to you to ensure that this is safe.\n  void addDefaultFunctionDefinitionAttributes(llvm::Function &F);\n\n  /// Like the overload taking a `Function &`, but intended specifically\n  /// for frontends that want to build on Clang's target-configuration logic.\n  void addDefaultFunctionDefinitionAttributes(llvm::AttrBuilder &attrs);\n\n  StringRef getMangledName(GlobalDecl GD);\n  StringRef getBlockMangledName(GlobalDecl GD, const BlockDecl *BD);\n\n  void EmitTentativeDefinition(const VarDecl *D);\n\n  void EmitExternalDeclaration(const VarDecl *D);\n\n  void EmitVTable(CXXRecordDecl *Class);\n\n  void RefreshTypeCacheForClass(const CXXRecordDecl *Class);\n\n  /// Appends Opts to the \"llvm.linker.options\" metadata value.\n  void AppendLinkerOptions(StringRef Opts);\n\n  /// Appends a detect mismatch command to the linker options.\n  void AddDetectMismatch(StringRef Name, StringRef Value);\n\n  /// Appends a dependent lib to the appropriate metadata value.\n  void AddDependentLib(StringRef Lib);\n\n\n  llvm::GlobalVariable::LinkageTypes getFunctionLinkage(GlobalDecl GD);\n\n  void setFunctionLinkage(GlobalDecl GD, llvm::Function *F) {\n    F->setLinkage(getFunctionLinkage(GD));\n  }\n\n  /// Return the appropriate linkage for the vtable, VTT, and type information\n  /// of the given class.\n  llvm::GlobalVariable::LinkageTypes getVTableLinkage(const CXXRecordDecl *RD);\n\n  /// Return the store size, in character units, of the given LLVM type.\n  CharUnits GetTargetTypeStoreSize(llvm::Type *Ty) const;\n\n  /// Returns LLVM linkage for a declarator.\n  llvm::GlobalValue::LinkageTypes\n  getLLVMLinkageForDeclarator(const DeclaratorDecl *D, GVALinkage Linkage,\n                              bool IsConstantVariable);\n\n  /// Returns LLVM linkage for a declarator.\n  llvm::GlobalValue::LinkageTypes\n  getLLVMLinkageVarDefinition(const VarDecl *VD, bool IsConstant);\n\n  /// Emit all the global annotations.\n  void EmitGlobalAnnotations();\n\n  /// Emit an annotation string.\n  llvm::Constant *EmitAnnotationString(StringRef Str);\n\n  /// Emit the annotation's translation unit.\n  llvm::Constant *EmitAnnotationUnit(SourceLocation Loc);\n\n  /// Emit the annotation line number.\n  llvm::Constant *EmitAnnotationLineNo(SourceLocation L);\n\n  /// Emit additional args of the annotation.\n  llvm::Constant *EmitAnnotationArgs(const AnnotateAttr *Attr);\n\n  /// Generate the llvm::ConstantStruct which contains the annotation\n  /// information for a given GlobalValue. The annotation struct is\n  /// {i8 *, i8 *, i8 *, i32}. The first field is a constant expression, the\n  /// GlobalValue being annotated. The second field is the constant string\n  /// created from the AnnotateAttr's annotation. The third field is a constant\n  /// string containing the name of the translation unit. The fourth field is\n  /// the line number in the file of the annotated value declaration.\n  llvm::Constant *EmitAnnotateAttr(llvm::GlobalValue *GV,\n                                   const AnnotateAttr *AA,\n                                   SourceLocation L);\n\n  /// Add global annotations that are set on D, for the global GV. Those\n  /// annotations are emitted during finalization of the LLVM code.\n  void AddGlobalAnnotations(const ValueDecl *D, llvm::GlobalValue *GV);\n\n  bool isInSanitizerBlacklist(SanitizerMask Kind, llvm::Function *Fn,\n                              SourceLocation Loc) const;\n\n  bool isInSanitizerBlacklist(llvm::GlobalVariable *GV, SourceLocation Loc,\n                              QualType Ty,\n                              StringRef Category = StringRef()) const;\n\n  /// Imbue XRay attributes to a function, applying the always/never attribute\n  /// lists in the process. Returns true if we did imbue attributes this way,\n  /// false otherwise.\n  bool imbueXRayAttrs(llvm::Function *Fn, SourceLocation Loc,\n                      StringRef Category = StringRef()) const;\n\n  /// Returns true if function at the given location should be excluded from\n  /// profile instrumentation.\n  bool isProfileInstrExcluded(llvm::Function *Fn, SourceLocation Loc) const;\n\n  SanitizerMetadata *getSanitizerMetadata() {\n    return SanitizerMD.get();\n  }\n\n  void addDeferredVTable(const CXXRecordDecl *RD) {\n    DeferredVTables.push_back(RD);\n  }\n\n  /// Emit code for a single global function or var decl. Forward declarations\n  /// are emitted lazily.\n  void EmitGlobal(GlobalDecl D);\n\n  bool TryEmitBaseDestructorAsAlias(const CXXDestructorDecl *D);\n\n  llvm::GlobalValue *GetGlobalValue(StringRef Ref);\n\n  /// Set attributes which are common to any form of a global definition (alias,\n  /// Objective-C method, function, global variable).\n  ///\n  /// NOTE: This should only be called for definitions.\n  void SetCommonAttributes(GlobalDecl GD, llvm::GlobalValue *GV);\n\n  void addReplacement(StringRef Name, llvm::Constant *C);\n\n  void addGlobalValReplacement(llvm::GlobalValue *GV, llvm::Constant *C);\n\n  /// Emit a code for threadprivate directive.\n  /// \\param D Threadprivate declaration.\n  void EmitOMPThreadPrivateDecl(const OMPThreadPrivateDecl *D);\n\n  /// Emit a code for declare reduction construct.\n  void EmitOMPDeclareReduction(const OMPDeclareReductionDecl *D,\n                               CodeGenFunction *CGF = nullptr);\n\n  /// Emit a code for declare mapper construct.\n  void EmitOMPDeclareMapper(const OMPDeclareMapperDecl *D,\n                            CodeGenFunction *CGF = nullptr);\n\n  /// Emit a code for requires directive.\n  /// \\param D Requires declaration\n  void EmitOMPRequiresDecl(const OMPRequiresDecl *D);\n\n  /// Returns whether the given record has hidden LTO visibility and therefore\n  /// may participate in (single-module) CFI and whole-program vtable\n  /// optimization.\n  bool HasHiddenLTOVisibility(const CXXRecordDecl *RD);\n\n  /// Returns whether the given record has public std LTO visibility\n  /// and therefore may not participate in (single-module) CFI and whole-program\n  /// vtable optimization.\n  bool HasLTOVisibilityPublicStd(const CXXRecordDecl *RD);\n\n  /// Returns the vcall visibility of the given type. This is the scope in which\n  /// a virtual function call could be made which ends up being dispatched to a\n  /// member function of this class. This scope can be wider than the visibility\n  /// of the class itself when the class has a more-visible dynamic base class.\n  /// The client should pass in an empty Visited set, which is used to prevent\n  /// redundant recursive processing.\n  llvm::GlobalObject::VCallVisibility\n  GetVCallVisibilityLevel(const CXXRecordDecl *RD,\n                          llvm::DenseSet<const CXXRecordDecl *> &Visited);\n\n  /// Emit type metadata for the given vtable using the given layout.\n  void EmitVTableTypeMetadata(const CXXRecordDecl *RD,\n                              llvm::GlobalVariable *VTable,\n                              const VTableLayout &VTLayout);\n\n  /// Generate a cross-DSO type identifier for MD.\n  llvm::ConstantInt *CreateCrossDsoCfiTypeId(llvm::Metadata *MD);\n\n  /// Create a metadata identifier for the given type. This may either be an\n  /// MDString (for external identifiers) or a distinct unnamed MDNode (for\n  /// internal identifiers).\n  llvm::Metadata *CreateMetadataIdentifierForType(QualType T);\n\n  /// Create a metadata identifier that is intended to be used to check virtual\n  /// calls via a member function pointer.\n  llvm::Metadata *CreateMetadataIdentifierForVirtualMemPtrType(QualType T);\n\n  /// Create a metadata identifier for the generalization of the given type.\n  /// This may either be an MDString (for external identifiers) or a distinct\n  /// unnamed MDNode (for internal identifiers).\n  llvm::Metadata *CreateMetadataIdentifierGeneralized(QualType T);\n\n  /// Create and attach type metadata to the given function.\n  void CreateFunctionTypeMetadataForIcall(const FunctionDecl *FD,\n                                          llvm::Function *F);\n\n  /// Returns whether this module needs the \"all-vtables\" type identifier.\n  bool NeedAllVtablesTypeId() const;\n\n  /// Create and attach type metadata for the given vtable.\n  void AddVTableTypeMetadata(llvm::GlobalVariable *VTable, CharUnits Offset,\n                             const CXXRecordDecl *RD);\n\n  /// Return a vector of most-base classes for RD. This is used to implement\n  /// control flow integrity checks for member function pointers.\n  ///\n  /// A most-base class of a class C is defined as a recursive base class of C,\n  /// including C itself, that does not have any bases.\n  std::vector<const CXXRecordDecl *>\n  getMostBaseClasses(const CXXRecordDecl *RD);\n\n  /// Get the declaration of std::terminate for the platform.\n  llvm::FunctionCallee getTerminateFn();\n\n  llvm::SanitizerStatReport &getSanStats();\n\n  llvm::Value *\n  createOpenCLIntToSamplerConversion(const Expr *E, CodeGenFunction &CGF);\n\n  /// OpenCL v1.2 s5.6.4.6 allows the compiler to store kernel argument\n  /// information in the program executable. The argument information stored\n  /// includes the argument name, its type, the address and access qualifiers\n  /// used. This helper can be used to generate metadata for source code kernel\n  /// function as well as generated implicitly kernels. If a kernel is generated\n  /// implicitly null value has to be passed to the last two parameters,\n  /// otherwise all parameters must have valid non-null values.\n  /// \\param FN is a pointer to IR function being generated.\n  /// \\param FD is a pointer to function declaration if any.\n  /// \\param CGF is a pointer to CodeGenFunction that generates this function.\n  void GenOpenCLArgMetadata(llvm::Function *FN,\n                            const FunctionDecl *FD = nullptr,\n                            CodeGenFunction *CGF = nullptr);\n\n  /// Get target specific null pointer.\n  /// \\param T is the LLVM type of the null pointer.\n  /// \\param QT is the clang QualType of the null pointer.\n  llvm::Constant *getNullPointer(llvm::PointerType *T, QualType QT);\n\n  CharUnits getNaturalTypeAlignment(QualType T,\n                                    LValueBaseInfo *BaseInfo = nullptr,\n                                    TBAAAccessInfo *TBAAInfo = nullptr,\n                                    bool forPointeeType = false);\n  CharUnits getNaturalPointeeTypeAlignment(QualType T,\n                                           LValueBaseInfo *BaseInfo = nullptr,\n                                           TBAAAccessInfo *TBAAInfo = nullptr);\n  bool stopAutoInit();\n\nprivate:\n  llvm::Constant *GetOrCreateLLVMFunction(\n      StringRef MangledName, llvm::Type *Ty, GlobalDecl D, bool ForVTable,\n      bool DontDefer = false, bool IsThunk = false,\n      llvm::AttributeList ExtraAttrs = llvm::AttributeList(),\n      ForDefinition_t IsForDefinition = NotForDefinition);\n\n  llvm::Constant *GetOrCreateMultiVersionResolver(GlobalDecl GD,\n                                                  llvm::Type *DeclTy,\n                                                  const FunctionDecl *FD);\n  void UpdateMultiVersionNames(GlobalDecl GD, const FunctionDecl *FD);\n\n  llvm::Constant *GetOrCreateLLVMGlobal(StringRef MangledName,\n                                        llvm::PointerType *PTy,\n                                        const VarDecl *D,\n                                        ForDefinition_t IsForDefinition\n                                          = NotForDefinition);\n\n  bool GetCPUAndFeaturesAttributes(GlobalDecl GD,\n                                   llvm::AttrBuilder &AttrBuilder);\n  void setNonAliasAttributes(GlobalDecl GD, llvm::GlobalObject *GO);\n\n  /// Set function attributes for a function declaration.\n  void SetFunctionAttributes(GlobalDecl GD, llvm::Function *F,\n                             bool IsIncompleteFunction, bool IsThunk);\n\n  void EmitGlobalDefinition(GlobalDecl D, llvm::GlobalValue *GV = nullptr);\n\n  void EmitGlobalFunctionDefinition(GlobalDecl GD, llvm::GlobalValue *GV);\n  void EmitMultiVersionFunctionDefinition(GlobalDecl GD, llvm::GlobalValue *GV);\n\n  void EmitGlobalVarDefinition(const VarDecl *D, bool IsTentative = false);\n  void EmitExternalVarDeclaration(const VarDecl *D);\n  void EmitAliasDefinition(GlobalDecl GD);\n  void emitIFuncDefinition(GlobalDecl GD);\n  void emitCPUDispatchDefinition(GlobalDecl GD);\n  void EmitObjCPropertyImplementations(const ObjCImplementationDecl *D);\n  void EmitObjCIvarInitializations(ObjCImplementationDecl *D);\n\n  // C++ related functions.\n\n  void EmitDeclContext(const DeclContext *DC);\n  void EmitLinkageSpec(const LinkageSpecDecl *D);\n\n  /// Emit the function that initializes C++ thread_local variables.\n  void EmitCXXThreadLocalInitFunc();\n\n  /// Emit the function that initializes C++ globals.\n  void EmitCXXGlobalInitFunc();\n\n  /// Emit the function that performs cleanup associated with C++ globals.\n  void EmitCXXGlobalCleanUpFunc();\n\n  /// Emit the function that initializes the specified global (if PerformInit is\n  /// true) and registers its destructor.\n  void EmitCXXGlobalVarDeclInitFunc(const VarDecl *D,\n                                    llvm::GlobalVariable *Addr,\n                                    bool PerformInit);\n\n  void EmitPointerToInitFunc(const VarDecl *VD, llvm::GlobalVariable *Addr,\n                             llvm::Function *InitFunc, InitSegAttr *ISA);\n\n  // FIXME: Hardcoding priority here is gross.\n  void AddGlobalCtor(llvm::Function *Ctor, int Priority = 65535,\n                     llvm::Constant *AssociatedData = nullptr);\n  void AddGlobalDtor(llvm::Function *Dtor, int Priority = 65535,\n                     bool IsDtorAttrFunc = false);\n\n  /// EmitCtorList - Generates a global array of functions and priorities using\n  /// the given list and name. This array will have appending linkage and is\n  /// suitable for use as a LLVM constructor or destructor array. Clears Fns.\n  void EmitCtorList(CtorList &Fns, const char *GlobalName);\n\n  /// Emit any needed decls for which code generation was deferred.\n  void EmitDeferred();\n\n  /// Try to emit external vtables as available_externally if they have emitted\n  /// all inlined virtual functions.  It runs after EmitDeferred() and therefore\n  /// is not allowed to create new references to things that need to be emitted\n  /// lazily.\n  void EmitVTablesOpportunistically();\n\n  /// Call replaceAllUsesWith on all pairs in Replacements.\n  void applyReplacements();\n\n  /// Call replaceAllUsesWith on all pairs in GlobalValReplacements.\n  void applyGlobalValReplacements();\n\n  void checkAliases();\n\n  std::map<int, llvm::TinyPtrVector<llvm::Function *>> DtorsUsingAtExit;\n\n  /// Register functions annotated with __attribute__((destructor)) using\n  /// __cxa_atexit, if it is available, or atexit otherwise.\n  void registerGlobalDtorsWithAtExit();\n\n  // When using sinit and sterm functions, unregister\n  // __attribute__((destructor)) annotated functions which were previously\n  // registered by the atexit subroutine using unatexit.\n  void unregisterGlobalDtorsWithUnAtExit();\n\n  void emitMultiVersionFunctions();\n\n  /// Emit any vtables which we deferred and still have a use for.\n  void EmitDeferredVTables();\n\n  /// Emit a dummy function that reference a CoreFoundation symbol when\n  /// @available is used on Darwin.\n  void emitAtAvailableLinkGuard();\n\n  /// Emit the llvm.used and llvm.compiler.used metadata.\n  void emitLLVMUsed();\n\n  /// Emit the link options introduced by imported modules.\n  void EmitModuleLinkOptions();\n\n  /// Emit aliases for internal-linkage declarations inside \"C\" language\n  /// linkage specifications, giving them the \"expected\" name where possible.\n  void EmitStaticExternCAliases();\n\n  void EmitDeclMetadata();\n\n  /// Emit the Clang version as llvm.ident metadata.\n  void EmitVersionIdentMetadata();\n\n  /// Emit the Clang commandline as llvm.commandline metadata.\n  void EmitCommandLineMetadata();\n\n  /// Emit the module flag metadata used to pass options controlling the\n  /// the backend to LLVM.\n  void EmitBackendOptionsMetadata(const CodeGenOptions CodeGenOpts);\n\n  /// Emits OpenCL specific Metadata e.g. OpenCL version.\n  void EmitOpenCLMetadata();\n\n  /// Emit the llvm.gcov metadata used to tell LLVM where to emit the .gcno and\n  /// .gcda files in a way that persists in .bc files.\n  void EmitCoverageFile();\n\n  /// Determine whether the definition must be emitted; if this returns \\c\n  /// false, the definition can be emitted lazily if it's used.\n  bool MustBeEmitted(const ValueDecl *D);\n\n  /// Determine whether the definition can be emitted eagerly, or should be\n  /// delayed until the end of the translation unit. This is relevant for\n  /// definitions whose linkage can change, e.g. implicit function instantions\n  /// which may later be explicitly instantiated.\n  bool MayBeEmittedEagerly(const ValueDecl *D);\n\n  /// Check whether we can use a \"simpler\", more core exceptions personality\n  /// function.\n  void SimplifyPersonality();\n\n  /// Helper function for ConstructAttributeList and\n  /// addDefaultFunctionDefinitionAttributes.  Builds a set of function\n  /// attributes to add to a function with the given properties.\n  void getDefaultFunctionAttributes(StringRef Name, bool HasOptnone,\n                                    bool AttrOnCallSite,\n                                    llvm::AttrBuilder &FuncAttrs);\n\n  llvm::Metadata *CreateMetadataIdentifierImpl(QualType T, MetadataTypeMap &Map,\n                                               StringRef Suffix);\n};\n\n}  // end namespace CodeGen\n}  // end namespace clang\n\n#endif // LLVM_CLANG_LIB_CODEGEN_CODEGENMODULE_H\n"}}, "reports": [{"events": [{"location": {"col": 16, "file": 2, "line": 97}, "message": "the definition seen here"}, {"location": {"col": 3, "file": 1, "line": 561}, "message": "differing parameters are named here: ('headersearchopts', 'CodeGenOpts'), in definition: ('HSO', 'CGO')"}, {"location": {"col": 3, "file": 1, "line": 561}, "message": "function 'clang::CodeGen::CodeGenModule::CodeGenModule' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CodeGenModule.h", "reportHash": "6b4317a28636b45f0c15ea135d6d14ac", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 35, "file": 2, "line": 889}, "message": "the definition seen here"}, {"location": {"col": 22, "file": 1, "line": 776}, "message": "differing parameters are named here: ('numChars'), in definition: ('size')"}, {"location": {"col": 22, "file": 1, "line": 776}, "message": "function 'clang::CodeGen::CodeGenModule::getSize' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CodeGenModule.h", "reportHash": "0a36430a2d08037c24a9910141a1370b", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 21, "file": 2, "line": 865}, "message": "the definition seen here"}, {"location": {"col": 8, "file": 1, "line": 1117}, "message": "differing parameters are named here: ('error'), in definition: ('message')"}, {"location": {"col": 8, "file": 1, "line": 1117}, "message": "function 'clang::CodeGen::CodeGenModule::Error' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CodeGenModule.h", "reportHash": "8d2c5ddf57d23cfcefa055162a35c84e", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 21, "file": 2, "line": 775}, "message": "the definition seen here"}, {"location": {"col": 8, "file": 1, "line": 1203}, "message": "differing parameters are named here: ('Class'), in definition: ('RD')"}, {"location": {"col": 8, "file": 1, "line": 1203}, "message": "function 'clang::CodeGen::CodeGenModule::RefreshTypeCacheForClass' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CodeGenModule.h", "reportHash": "2ed7c79e78100fece4a085148a8d3e1c", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 35, "file": 2, "line": 1296}, "message": "the definition seen here"}, {"location": {"col": 22, "file": 1, "line": 1298}, "message": "differing parameters are named here: ('Ref'), in definition: ('Name')"}, {"location": {"col": 22, "file": 1, "line": 1298}, "message": "function 'clang::CodeGen::CodeGenModule::GetGlobalValue' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CodeGenModule.h", "reportHash": "f13c8e923befa197f47935355ffa6c0f", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 21, "file": 2, "line": 2565}, "message": "the definition seen here"}, {"location": {"col": 8, "file": 1, "line": 1564}, "message": "differing parameters are named here: ('D'), in definition: ('Global')"}, {"location": {"col": 8, "file": 1, "line": 1564}, "message": "function 'clang::CodeGen::CodeGenModule::MustBeEmitted' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CodeGenModule.h", "reportHash": "26bcb4b9271b691e3d9e0bef6ca5f85b", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 21, "file": 2, "line": 2580}, "message": "the definition seen here"}, {"location": {"col": 8, "file": 1, "line": 1570}, "message": "differing parameters are named here: ('D'), in definition: ('Global')"}, {"location": {"col": 8, "file": 1, "line": 1570}, "message": "function 'clang::CodeGen::CodeGenModule::MayBeEmittedEagerly' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CodeGenModule.h", "reportHash": "51a6c80e439718caf002644036956df2", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
