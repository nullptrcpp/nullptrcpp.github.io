<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"2": {"id": 2, "path": "/home/vsts/work/1/llvm-project/clang/lib/Driver/Driver.cpp", "content": "//===--- Driver.cpp - Clang GCC Compatible Driver -------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#include \"clang/Driver/Driver.h\"\n#include \"InputInfo.h\"\n#include \"ToolChains/AIX.h\"\n#include \"ToolChains/AMDGPU.h\"\n#include \"ToolChains/AMDGPUOpenMP.h\"\n#include \"ToolChains/AVR.h\"\n#include \"ToolChains/Ananas.h\"\n#include \"ToolChains/BareMetal.h\"\n#include \"ToolChains/Clang.h\"\n#include \"ToolChains/CloudABI.h\"\n#include \"ToolChains/Contiki.h\"\n#include \"ToolChains/CrossWindows.h\"\n#include \"ToolChains/Cuda.h\"\n#include \"ToolChains/Darwin.h\"\n#include \"ToolChains/DragonFly.h\"\n#include \"ToolChains/FreeBSD.h\"\n#include \"ToolChains/Fuchsia.h\"\n#include \"ToolChains/Gnu.h\"\n#include \"ToolChains/HIP.h\"\n#include \"ToolChains/Haiku.h\"\n#include \"ToolChains/Hexagon.h\"\n#include \"ToolChains/Hurd.h\"\n#include \"ToolChains/Lanai.h\"\n#include \"ToolChains/Linux.h\"\n#include \"ToolChains/MSP430.h\"\n#include \"ToolChains/MSVC.h\"\n#include \"ToolChains/MinGW.h\"\n#include \"ToolChains/Minix.h\"\n#include \"ToolChains/MipsLinux.h\"\n#include \"ToolChains/Myriad.h\"\n#include \"ToolChains/NaCl.h\"\n#include \"ToolChains/NetBSD.h\"\n#include \"ToolChains/OpenBSD.h\"\n#include \"ToolChains/PPCLinux.h\"\n#include \"ToolChains/PS4CPU.h\"\n#include \"ToolChains/RISCVToolchain.h\"\n#include \"ToolChains/Solaris.h\"\n#include \"ToolChains/TCE.h\"\n#include \"ToolChains/VEToolchain.h\"\n#include \"ToolChains/WebAssembly.h\"\n#include \"ToolChains/XCore.h\"\n#include \"ToolChains/ZOS.h\"\n#include \"clang/Basic/TargetID.h\"\n#include \"clang/Basic/Version.h\"\n#include \"clang/Config/config.h\"\n#include \"clang/Driver/Action.h\"\n#include \"clang/Driver/Compilation.h\"\n#include \"clang/Driver/DriverDiagnostic.h\"\n#include \"clang/Driver/Job.h\"\n#include \"clang/Driver/Options.h\"\n#include \"clang/Driver/SanitizerArgs.h\"\n#include \"clang/Driver/Tool.h\"\n#include \"clang/Driver/ToolChain.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallSet.h\"\n#include \"llvm/ADT/StringExtras.h\"\n#include \"llvm/ADT/StringSet.h\"\n#include \"llvm/ADT/StringSwitch.h\"\n#include \"llvm/Config/llvm-config.h\"\n#include \"llvm/Option/Arg.h\"\n#include \"llvm/Option/ArgList.h\"\n#include \"llvm/Option/OptSpecifier.h\"\n#include \"llvm/Option/OptTable.h\"\n#include \"llvm/Option/Option.h\"\n#include \"llvm/Support/CommandLine.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/ExitCodes.h\"\n#include \"llvm/Support/FileSystem.h\"\n#include \"llvm/Support/FormatVariadic.h\"\n#include \"llvm/Support/Host.h\"\n#include \"llvm/Support/MD5.h\"\n#include \"llvm/Support/Path.h\"\n#include \"llvm/Support/PrettyStackTrace.h\"\n#include \"llvm/Support/Process.h\"\n#include \"llvm/Support/Program.h\"\n#include \"llvm/Support/StringSaver.h\"\n#include \"llvm/Support/TargetRegistry.h\"\n#include \"llvm/Support/VirtualFileSystem.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <map>\n#include <memory>\n#include <utility>\n#if LLVM_ON_UNIX\n#include <unistd.h> // getpid\n#endif\n\nusing namespace clang::driver;\nusing namespace clang;\nusing namespace llvm::opt;\n\nstatic llvm::Triple getHIPOffloadTargetTriple() {\n  static const llvm::Triple T(\"amdgcn-amd-amdhsa\");\n  return T;\n}\n\n// static\nstd::string Driver::GetResourcesPath(StringRef BinaryPath,\n                                     StringRef CustomResourceDir) {\n  // Since the resource directory is embedded in the module hash, it's important\n  // that all places that need it call this function, so that they get the\n  // exact same string (\"a/../b/\" and \"b/\" get different hashes, for example).\n\n  // Dir is bin/ or lib/, depending on where BinaryPath is.\n  std::string Dir = std::string(llvm::sys::path::parent_path(BinaryPath));\n\n  SmallString<128> P(Dir);\n  if (CustomResourceDir != \"\") {\n    llvm::sys::path::append(P, CustomResourceDir);\n  } else {\n    // On Windows, libclang.dll is in bin/.\n    // On non-Windows, libclang.so/.dylib is in lib/.\n    // With a static-library build of libclang, LibClangPath will contain the\n    // path of the embedding binary, which for LLVM binaries will be in bin/.\n    // ../lib gets us to lib/ in both cases.\n    P = llvm::sys::path::parent_path(Dir);\n    llvm::sys::path::append(P, Twine(\"lib\") + CLANG_LIBDIR_SUFFIX, \"clang\",\n                            CLANG_VERSION_STRING);\n  }\n\n  return std::string(P.str());\n}\n\nDriver::Driver(StringRef ClangExecutable, StringRef TargetTriple,\n               DiagnosticsEngine &Diags, std::string Title,\n               IntrusiveRefCntPtr<llvm::vfs::FileSystem> VFS)\n    : Diags(Diags), VFS(std::move(VFS)), Mode(GCCMode),\n      SaveTemps(SaveTempsNone), BitcodeEmbed(EmbedNone), LTOMode(LTOK_None),\n      ClangExecutable(ClangExecutable), SysRoot(DEFAULT_SYSROOT),\n      DriverTitle(Title), CCPrintOptionsFilename(nullptr),\n      CCPrintHeadersFilename(nullptr), CCLogDiagnosticsFilename(nullptr),\n      CCCPrintBindings(false), CCPrintOptions(false), CCPrintHeaders(false),\n      CCLogDiagnostics(false), CCGenDiagnostics(false),\n      TargetTriple(TargetTriple), CCCGenericGCCName(\"\"), Saver(Alloc),\n      CheckInputsExist(true), GenReproducer(false),\n      SuppressMissingInputWarning(false) {\n  // Provide a sane fallback if no VFS is specified.\n  if (!this->VFS)\n    this->VFS = llvm::vfs::getRealFileSystem();\n\n  Name = std::string(llvm::sys::path::filename(ClangExecutable));\n  Dir = std::string(llvm::sys::path::parent_path(ClangExecutable));\n  InstalledDir = Dir; // Provide a sensible default installed dir.\n\n  if ((!SysRoot.empty()) && llvm::sys::path::is_relative(SysRoot)) {\n    // Prepend InstalledDir if SysRoot is relative\n    SmallString<128> P(InstalledDir);\n    llvm::sys::path::append(P, SysRoot);\n    SysRoot = std::string(P);\n  }\n\n#if defined(CLANG_CONFIG_FILE_SYSTEM_DIR)\n  SystemConfigDir = CLANG_CONFIG_FILE_SYSTEM_DIR;\n#endif\n#if defined(CLANG_CONFIG_FILE_USER_DIR)\n  UserConfigDir = CLANG_CONFIG_FILE_USER_DIR;\n#endif\n\n  // Compute the path to the resource directory.\n  ResourceDir = GetResourcesPath(ClangExecutable, CLANG_RESOURCE_DIR);\n}\n\nvoid Driver::ParseDriverMode(StringRef ProgramName,\n                             ArrayRef<const char *> Args) {\n  if (ClangNameParts.isEmpty())\n    ClangNameParts = ToolChain::getTargetAndModeFromProgramName(ProgramName);\n  setDriverModeFromOption(ClangNameParts.DriverMode);\n\n  for (const char *ArgPtr : Args) {\n    // Ignore nullptrs, they are the response file's EOL markers.\n    if (ArgPtr == nullptr)\n      continue;\n    const StringRef Arg = ArgPtr;\n    setDriverModeFromOption(Arg);\n  }\n}\n\nvoid Driver::setDriverModeFromOption(StringRef Opt) {\n  const std::string OptName =\n      getOpts().getOption(options::OPT_driver_mode).getPrefixedName();\n  if (!Opt.startswith(OptName))\n    return;\n  StringRef Value = Opt.drop_front(OptName.size());\n\n  if (auto M = llvm::StringSwitch<llvm::Optional<DriverMode>>(Value)\n                   .Case(\"gcc\", GCCMode)\n                   .Case(\"g++\", GXXMode)\n                   .Case(\"cpp\", CPPMode)\n                   .Case(\"cl\", CLMode)\n                   .Case(\"flang\", FlangMode)\n                   .Default(None))\n    Mode = *M;\n  else\n    Diag(diag::err_drv_unsupported_option_argument) << OptName << Value;\n}\n\nInputArgList Driver::ParseArgStrings(ArrayRef<const char *> ArgStrings,\n                                     bool IsClCompatMode,\n                                     bool &ContainsError) {\n  llvm::PrettyStackTraceString CrashInfo(\"Command line argument parsing\");\n  ContainsError = false;\n\n  unsigned IncludedFlagsBitmask;\n  unsigned ExcludedFlagsBitmask;\n  std::tie(IncludedFlagsBitmask, ExcludedFlagsBitmask) =\n      getIncludeExcludeOptionFlagMasks(IsClCompatMode);\n\n  // Make sure that Flang-only options don't pollute the Clang output\n  // TODO: Make sure that Clang-only options don't pollute Flang output\n  if (!IsFlangMode())\n    ExcludedFlagsBitmask |= options::FlangOnlyOption;\n\n  unsigned MissingArgIndex, MissingArgCount;\n  InputArgList Args =\n      getOpts().ParseArgs(ArgStrings, MissingArgIndex, MissingArgCount,\n                          IncludedFlagsBitmask, ExcludedFlagsBitmask);\n\n  // Check for missing argument error.\n  if (MissingArgCount) {\n    Diag(diag::err_drv_missing_argument)\n        << Args.getArgString(MissingArgIndex) << MissingArgCount;\n    ContainsError |=\n        Diags.getDiagnosticLevel(diag::err_drv_missing_argument,\n                                 SourceLocation()) > DiagnosticsEngine::Warning;\n  }\n\n  // Check for unsupported options.\n  for (const Arg *A : Args) {\n    if (A->getOption().hasFlag(options::Unsupported)) {\n      unsigned DiagID;\n      auto ArgString = A->getAsString(Args);\n      std::string Nearest;\n      if (getOpts().findNearest(\n            ArgString, Nearest, IncludedFlagsBitmask,\n            ExcludedFlagsBitmask | options::Unsupported) > 1) {\n        DiagID = diag::err_drv_unsupported_opt;\n        Diag(DiagID) << ArgString;\n      } else {\n        DiagID = diag::err_drv_unsupported_opt_with_suggestion;\n        Diag(DiagID) << ArgString << Nearest;\n      }\n      ContainsError |= Diags.getDiagnosticLevel(DiagID, SourceLocation()) >\n                       DiagnosticsEngine::Warning;\n      continue;\n    }\n\n    // Warn about -mcpu= without an argument.\n    if (A->getOption().matches(options::OPT_mcpu_EQ) && A->containsValue(\"\")) {\n      Diag(diag::warn_drv_empty_joined_argument) << A->getAsString(Args);\n      ContainsError |= Diags.getDiagnosticLevel(\n                           diag::warn_drv_empty_joined_argument,\n                           SourceLocation()) > DiagnosticsEngine::Warning;\n    }\n  }\n\n  for (const Arg *A : Args.filtered(options::OPT_UNKNOWN)) {\n    unsigned DiagID;\n    auto ArgString = A->getAsString(Args);\n    std::string Nearest;\n    if (getOpts().findNearest(\n          ArgString, Nearest, IncludedFlagsBitmask, ExcludedFlagsBitmask) > 1) {\n      DiagID = IsCLMode() ? diag::warn_drv_unknown_argument_clang_cl\n                          : diag::err_drv_unknown_argument;\n      Diags.Report(DiagID) << ArgString;\n    } else {\n      DiagID = IsCLMode()\n                   ? diag::warn_drv_unknown_argument_clang_cl_with_suggestion\n                   : diag::err_drv_unknown_argument_with_suggestion;\n      Diags.Report(DiagID) << ArgString << Nearest;\n    }\n    ContainsError |= Diags.getDiagnosticLevel(DiagID, SourceLocation()) >\n                     DiagnosticsEngine::Warning;\n  }\n\n  return Args;\n}\n\n// Determine which compilation mode we are in. We look for options which\n// affect the phase, starting with the earliest phases, and record which\n// option we used to determine the final phase.\nphases::ID Driver::getFinalPhase(const DerivedArgList &DAL,\n                                 Arg **FinalPhaseArg) const {\n  Arg *PhaseArg = nullptr;\n  phases::ID FinalPhase;\n\n  // -{E,EP,P,M,MM} only run the preprocessor.\n  if (CCCIsCPP() || (PhaseArg = DAL.getLastArg(options::OPT_E)) ||\n      (PhaseArg = DAL.getLastArg(options::OPT__SLASH_EP)) ||\n      (PhaseArg = DAL.getLastArg(options::OPT_M, options::OPT_MM)) ||\n      (PhaseArg = DAL.getLastArg(options::OPT__SLASH_P))) {\n    FinalPhase = phases::Preprocess;\n\n  // --precompile only runs up to precompilation.\n  } else if ((PhaseArg = DAL.getLastArg(options::OPT__precompile))) {\n    FinalPhase = phases::Precompile;\n\n  // -{fsyntax-only,-analyze,emit-ast} only run up to the compiler.\n  } else if ((PhaseArg = DAL.getLastArg(options::OPT_fsyntax_only)) ||\n             (PhaseArg = DAL.getLastArg(options::OPT_print_supported_cpus)) ||\n             (PhaseArg = DAL.getLastArg(options::OPT_module_file_info)) ||\n             (PhaseArg = DAL.getLastArg(options::OPT_verify_pch)) ||\n             (PhaseArg = DAL.getLastArg(options::OPT_rewrite_objc)) ||\n             (PhaseArg = DAL.getLastArg(options::OPT_rewrite_legacy_objc)) ||\n             (PhaseArg = DAL.getLastArg(options::OPT__migrate)) ||\n             (PhaseArg = DAL.getLastArg(options::OPT__analyze)) ||\n             (PhaseArg = DAL.getLastArg(options::OPT_emit_ast))) {\n    FinalPhase = phases::Compile;\n\n  // -S only runs up to the backend.\n  } else if ((PhaseArg = DAL.getLastArg(options::OPT_S))) {\n    FinalPhase = phases::Backend;\n\n  // -c compilation only runs up to the assembler.\n  } else if ((PhaseArg = DAL.getLastArg(options::OPT_c))) {\n    FinalPhase = phases::Assemble;\n\n  // Otherwise do everything.\n  } else\n    FinalPhase = phases::Link;\n\n  if (FinalPhaseArg)\n    *FinalPhaseArg = PhaseArg;\n\n  return FinalPhase;\n}\n\nstatic Arg *MakeInputArg(DerivedArgList &Args, const OptTable &Opts,\n                         StringRef Value, bool Claim = true) {\n  Arg *A = new Arg(Opts.getOption(options::OPT_INPUT), Value,\n                   Args.getBaseArgs().MakeIndex(Value), Value.data());\n  Args.AddSynthesizedArg(A);\n  if (Claim)\n    A->claim();\n  return A;\n}\n\nDerivedArgList *Driver::TranslateInputArgs(const InputArgList &Args) const {\n  const llvm::opt::OptTable &Opts = getOpts();\n  DerivedArgList *DAL = new DerivedArgList(Args);\n\n  bool HasNostdlib = Args.hasArg(options::OPT_nostdlib);\n  bool HasNostdlibxx = Args.hasArg(options::OPT_nostdlibxx);\n  bool HasNodefaultlib = Args.hasArg(options::OPT_nodefaultlibs);\n  for (Arg *A : Args) {\n    // Unfortunately, we have to parse some forwarding options (-Xassembler,\n    // -Xlinker, -Xpreprocessor) because we either integrate their functionality\n    // (assembler and preprocessor), or bypass a previous driver ('collect2').\n\n    // Rewrite linker options, to replace --no-demangle with a custom internal\n    // option.\n    if ((A->getOption().matches(options::OPT_Wl_COMMA) ||\n         A->getOption().matches(options::OPT_Xlinker)) &&\n        A->containsValue(\"--no-demangle\")) {\n      // Add the rewritten no-demangle argument.\n      DAL->AddFlagArg(A, Opts.getOption(options::OPT_Z_Xlinker__no_demangle));\n\n      // Add the remaining values as Xlinker arguments.\n      for (StringRef Val : A->getValues())\n        if (Val != \"--no-demangle\")\n          DAL->AddSeparateArg(A, Opts.getOption(options::OPT_Xlinker), Val);\n\n      continue;\n    }\n\n    // Rewrite preprocessor options, to replace -Wp,-MD,FOO which is used by\n    // some build systems. We don't try to be complete here because we don't\n    // care to encourage this usage model.\n    if (A->getOption().matches(options::OPT_Wp_COMMA) &&\n        (A->getValue(0) == StringRef(\"-MD\") ||\n         A->getValue(0) == StringRef(\"-MMD\"))) {\n      // Rewrite to -MD/-MMD along with -MF.\n      if (A->getValue(0) == StringRef(\"-MD\"))\n        DAL->AddFlagArg(A, Opts.getOption(options::OPT_MD));\n      else\n        DAL->AddFlagArg(A, Opts.getOption(options::OPT_MMD));\n      if (A->getNumValues() == 2)\n        DAL->AddSeparateArg(A, Opts.getOption(options::OPT_MF), A->getValue(1));\n      continue;\n    }\n\n    // Rewrite reserved library names.\n    if (A->getOption().matches(options::OPT_l)) {\n      StringRef Value = A->getValue();\n\n      // Rewrite unless -nostdlib is present.\n      if (!HasNostdlib && !HasNodefaultlib && !HasNostdlibxx &&\n          Value == \"stdc++\") {\n        DAL->AddFlagArg(A, Opts.getOption(options::OPT_Z_reserved_lib_stdcxx));\n        continue;\n      }\n\n      // Rewrite unconditionally.\n      if (Value == \"cc_kext\") {\n        DAL->AddFlagArg(A, Opts.getOption(options::OPT_Z_reserved_lib_cckext));\n        continue;\n      }\n    }\n\n    // Pick up inputs via the -- option.\n    if (A->getOption().matches(options::OPT__DASH_DASH)) {\n      A->claim();\n      for (StringRef Val : A->getValues())\n        DAL->append(MakeInputArg(*DAL, Opts, Val, false));\n      continue;\n    }\n\n    DAL->append(A);\n  }\n\n  // Enforce -static if -miamcu is present.\n  if (Args.hasFlag(options::OPT_miamcu, options::OPT_mno_iamcu, false))\n    DAL->AddFlagArg(0, Opts.getOption(options::OPT_static));\n\n// Add a default value of -mlinker-version=, if one was given and the user\n// didn't specify one.\n#if defined(HOST_LINK_VERSION)\n  if (!Args.hasArg(options::OPT_mlinker_version_EQ) &&\n      strlen(HOST_LINK_VERSION) > 0) {\n    DAL->AddJoinedArg(0, Opts.getOption(options::OPT_mlinker_version_EQ),\n                      HOST_LINK_VERSION);\n    DAL->getLastArg(options::OPT_mlinker_version_EQ)->claim();\n  }\n#endif\n\n  return DAL;\n}\n\n/// Compute target triple from args.\n///\n/// This routine provides the logic to compute a target triple from various\n/// args passed to the driver and the default triple string.\nstatic llvm::Triple computeTargetTriple(const Driver &D,\n                                        StringRef TargetTriple,\n                                        const ArgList &Args,\n                                        StringRef DarwinArchName = \"\") {\n  // FIXME: Already done in Compilation *Driver::BuildCompilation\n  if (const Arg *A = Args.getLastArg(options::OPT_target))\n    TargetTriple = A->getValue();\n\n  llvm::Triple Target(llvm::Triple::normalize(TargetTriple));\n\n  // GNU/Hurd's triples should have been -hurd-gnu*, but were historically made\n  // -gnu* only, and we can not change this, so we have to detect that case as\n  // being the Hurd OS.\n  if (TargetTriple.find(\"-unknown-gnu\") != StringRef::npos ||\n      TargetTriple.find(\"-pc-gnu\") != StringRef::npos)\n    Target.setOSName(\"hurd\");\n\n  // Handle Apple-specific options available here.\n  if (Target.isOSBinFormatMachO()) {\n    // If an explicit Darwin arch name is given, that trumps all.\n    if (!DarwinArchName.empty()) {\n      tools::darwin::setTripleTypeForMachOArchName(Target, DarwinArchName);\n      return Target;\n    }\n\n    // Handle the Darwin '-arch' flag.\n    if (Arg *A = Args.getLastArg(options::OPT_arch)) {\n      StringRef ArchName = A->getValue();\n      tools::darwin::setTripleTypeForMachOArchName(Target, ArchName);\n    }\n  }\n\n  // Handle pseudo-target flags '-mlittle-endian'/'-EL' and\n  // '-mbig-endian'/'-EB'.\n  if (Arg *A = Args.getLastArg(options::OPT_mlittle_endian,\n                               options::OPT_mbig_endian)) {\n    if (A->getOption().matches(options::OPT_mlittle_endian)) {\n      llvm::Triple LE = Target.getLittleEndianArchVariant();\n      if (LE.getArch() != llvm::Triple::UnknownArch)\n        Target = std::move(LE);\n    } else {\n      llvm::Triple BE = Target.getBigEndianArchVariant();\n      if (BE.getArch() != llvm::Triple::UnknownArch)\n        Target = std::move(BE);\n    }\n  }\n\n  // Skip further flag support on OSes which don't support '-m32' or '-m64'.\n  if (Target.getArch() == llvm::Triple::tce ||\n      Target.getOS() == llvm::Triple::Minix)\n    return Target;\n\n  // On AIX, the env OBJECT_MODE may affect the resulting arch variant.\n  if (Target.isOSAIX()) {\n    if (Optional<std::string> ObjectModeValue =\n            llvm::sys::Process::GetEnv(\"OBJECT_MODE\")) {\n      StringRef ObjectMode = *ObjectModeValue;\n      llvm::Triple::ArchType AT = llvm::Triple::UnknownArch;\n\n      if (ObjectMode.equals(\"64\")) {\n        AT = Target.get64BitArchVariant().getArch();\n      } else if (ObjectMode.equals(\"32\")) {\n        AT = Target.get32BitArchVariant().getArch();\n      } else {\n        D.Diag(diag::err_drv_invalid_object_mode) << ObjectMode;\n      }\n\n      if (AT != llvm::Triple::UnknownArch && AT != Target.getArch())\n        Target.setArch(AT);\n    }\n  }\n\n  // Handle pseudo-target flags '-m64', '-mx32', '-m32' and '-m16'.\n  Arg *A = Args.getLastArg(options::OPT_m64, options::OPT_mx32,\n                           options::OPT_m32, options::OPT_m16);\n  if (A) {\n    llvm::Triple::ArchType AT = llvm::Triple::UnknownArch;\n\n    if (A->getOption().matches(options::OPT_m64)) {\n      AT = Target.get64BitArchVariant().getArch();\n      if (Target.getEnvironment() == llvm::Triple::GNUX32)\n        Target.setEnvironment(llvm::Triple::GNU);\n    } else if (A->getOption().matches(options::OPT_mx32) &&\n               Target.get64BitArchVariant().getArch() == llvm::Triple::x86_64) {\n      AT = llvm::Triple::x86_64;\n      Target.setEnvironment(llvm::Triple::GNUX32);\n    } else if (A->getOption().matches(options::OPT_m32)) {\n      AT = Target.get32BitArchVariant().getArch();\n      if (Target.getEnvironment() == llvm::Triple::GNUX32)\n        Target.setEnvironment(llvm::Triple::GNU);\n    } else if (A->getOption().matches(options::OPT_m16) &&\n               Target.get32BitArchVariant().getArch() == llvm::Triple::x86) {\n      AT = llvm::Triple::x86;\n      Target.setEnvironment(llvm::Triple::CODE16);\n    }\n\n    if (AT != llvm::Triple::UnknownArch && AT != Target.getArch())\n      Target.setArch(AT);\n  }\n\n  // Handle -miamcu flag.\n  if (Args.hasFlag(options::OPT_miamcu, options::OPT_mno_iamcu, false)) {\n    if (Target.get32BitArchVariant().getArch() != llvm::Triple::x86)\n      D.Diag(diag::err_drv_unsupported_opt_for_target) << \"-miamcu\"\n                                                       << Target.str();\n\n    if (A && !A->getOption().matches(options::OPT_m32))\n      D.Diag(diag::err_drv_argument_not_allowed_with)\n          << \"-miamcu\" << A->getBaseArg().getAsString(Args);\n\n    Target.setArch(llvm::Triple::x86);\n    Target.setArchName(\"i586\");\n    Target.setEnvironment(llvm::Triple::UnknownEnvironment);\n    Target.setEnvironmentName(\"\");\n    Target.setOS(llvm::Triple::ELFIAMCU);\n    Target.setVendor(llvm::Triple::UnknownVendor);\n    Target.setVendorName(\"intel\");\n  }\n\n  // If target is MIPS adjust the target triple\n  // accordingly to provided ABI name.\n  A = Args.getLastArg(options::OPT_mabi_EQ);\n  if (A && Target.isMIPS()) {\n    StringRef ABIName = A->getValue();\n    if (ABIName == \"32\") {\n      Target = Target.get32BitArchVariant();\n      if (Target.getEnvironment() == llvm::Triple::GNUABI64 ||\n          Target.getEnvironment() == llvm::Triple::GNUABIN32)\n        Target.setEnvironment(llvm::Triple::GNU);\n    } else if (ABIName == \"n32\") {\n      Target = Target.get64BitArchVariant();\n      if (Target.getEnvironment() == llvm::Triple::GNU ||\n          Target.getEnvironment() == llvm::Triple::GNUABI64)\n        Target.setEnvironment(llvm::Triple::GNUABIN32);\n    } else if (ABIName == \"64\") {\n      Target = Target.get64BitArchVariant();\n      if (Target.getEnvironment() == llvm::Triple::GNU ||\n          Target.getEnvironment() == llvm::Triple::GNUABIN32)\n        Target.setEnvironment(llvm::Triple::GNUABI64);\n    }\n  }\n\n  // If target is RISC-V adjust the target triple according to\n  // provided architecture name\n  A = Args.getLastArg(options::OPT_march_EQ);\n  if (A && Target.isRISCV()) {\n    StringRef ArchName = A->getValue();\n    if (ArchName.startswith_lower(\"rv32\"))\n      Target.setArch(llvm::Triple::riscv32);\n    else if (ArchName.startswith_lower(\"rv64\"))\n      Target.setArch(llvm::Triple::riscv64);\n  }\n\n  return Target;\n}\n\n// Parse the LTO options and record the type of LTO compilation\n// based on which -f(no-)?lto(=.*)? option occurs last.\nvoid Driver::setLTOMode(const llvm::opt::ArgList &Args) {\n  LTOMode = LTOK_None;\n  if (!Args.hasFlag(options::OPT_flto, options::OPT_flto_EQ,\n                    options::OPT_fno_lto, false))\n    return;\n\n  StringRef LTOName(\"full\");\n\n  const Arg *A = Args.getLastArg(options::OPT_flto_EQ);\n  if (A)\n    LTOName = A->getValue();\n\n  LTOMode = llvm::StringSwitch<LTOKind>(LTOName)\n                .Case(\"full\", LTOK_Full)\n                .Case(\"thin\", LTOK_Thin)\n                .Default(LTOK_Unknown);\n\n  if (LTOMode == LTOK_Unknown) {\n    assert(A);\n    Diag(diag::err_drv_unsupported_option_argument) << A->getOption().getName()\n                                                    << A->getValue();\n  }\n}\n\n/// Compute the desired OpenMP runtime from the flags provided.\nDriver::OpenMPRuntimeKind Driver::getOpenMPRuntime(const ArgList &Args) const {\n  StringRef RuntimeName(CLANG_DEFAULT_OPENMP_RUNTIME);\n\n  const Arg *A = Args.getLastArg(options::OPT_fopenmp_EQ);\n  if (A)\n    RuntimeName = A->getValue();\n\n  auto RT = llvm::StringSwitch<OpenMPRuntimeKind>(RuntimeName)\n                .Case(\"libomp\", OMPRT_OMP)\n                .Case(\"libgomp\", OMPRT_GOMP)\n                .Case(\"libiomp5\", OMPRT_IOMP5)\n                .Default(OMPRT_Unknown);\n\n  if (RT == OMPRT_Unknown) {\n    if (A)\n      Diag(diag::err_drv_unsupported_option_argument)\n          << A->getOption().getName() << A->getValue();\n    else\n      // FIXME: We could use a nicer diagnostic here.\n      Diag(diag::err_drv_unsupported_opt) << \"-fopenmp\";\n  }\n\n  return RT;\n}\n\nvoid Driver::CreateOffloadingDeviceToolChains(Compilation &C,\n                                              InputList &Inputs) {\n\n  //\n  // CUDA/HIP\n  //\n  // We need to generate a CUDA/HIP toolchain if any of the inputs has a CUDA\n  // or HIP type. However, mixed CUDA/HIP compilation is not supported.\n  bool IsCuda =\n      llvm::any_of(Inputs, [](std::pair<types::ID, const llvm::opt::Arg *> &I) {\n        return types::isCuda(I.first);\n      });\n  bool IsHIP =\n      llvm::any_of(Inputs,\n                   [](std::pair<types::ID, const llvm::opt::Arg *> &I) {\n                     return types::isHIP(I.first);\n                   }) ||\n      C.getInputArgs().hasArg(options::OPT_hip_link);\n  if (IsCuda && IsHIP) {\n    Diag(clang::diag::err_drv_mix_cuda_hip);\n    return;\n  }\n  if (IsCuda) {\n    const ToolChain *HostTC = C.getSingleOffloadToolChain<Action::OFK_Host>();\n    const llvm::Triple &HostTriple = HostTC->getTriple();\n    StringRef DeviceTripleStr;\n    auto OFK = Action::OFK_Cuda;\n    DeviceTripleStr =\n        HostTriple.isArch64Bit() ? \"nvptx64-nvidia-cuda\" : \"nvptx-nvidia-cuda\";\n    llvm::Triple CudaTriple(DeviceTripleStr);\n    // Use the CUDA and host triples as the key into the ToolChains map,\n    // because the device toolchain we create depends on both.\n    auto &CudaTC = ToolChains[CudaTriple.str() + \"/\" + HostTriple.str()];\n    if (!CudaTC) {\n      CudaTC = std::make_unique<toolchains::CudaToolChain>(\n          *this, CudaTriple, *HostTC, C.getInputArgs(), OFK);\n    }\n    C.addOffloadDeviceToolChain(CudaTC.get(), OFK);\n  } else if (IsHIP) {\n    const ToolChain *HostTC = C.getSingleOffloadToolChain<Action::OFK_Host>();\n    const llvm::Triple &HostTriple = HostTC->getTriple();\n    auto OFK = Action::OFK_HIP;\n    llvm::Triple HIPTriple = getHIPOffloadTargetTriple();\n    // Use the HIP and host triples as the key into the ToolChains map,\n    // because the device toolchain we create depends on both.\n    auto &HIPTC = ToolChains[HIPTriple.str() + \"/\" + HostTriple.str()];\n    if (!HIPTC) {\n      HIPTC = std::make_unique<toolchains::HIPToolChain>(\n          *this, HIPTriple, *HostTC, C.getInputArgs());\n    }\n    C.addOffloadDeviceToolChain(HIPTC.get(), OFK);\n  }\n\n  //\n  // OpenMP\n  //\n  // We need to generate an OpenMP toolchain if the user specified targets with\n  // the -fopenmp-targets option.\n  if (Arg *OpenMPTargets =\n          C.getInputArgs().getLastArg(options::OPT_fopenmp_targets_EQ)) {\n    if (OpenMPTargets->getNumValues()) {\n      // We expect that -fopenmp-targets is always used in conjunction with the\n      // option -fopenmp specifying a valid runtime with offloading support,\n      // i.e. libomp or libiomp.\n      bool HasValidOpenMPRuntime = C.getInputArgs().hasFlag(\n          options::OPT_fopenmp, options::OPT_fopenmp_EQ,\n          options::OPT_fno_openmp, false);\n      if (HasValidOpenMPRuntime) {\n        OpenMPRuntimeKind OpenMPKind = getOpenMPRuntime(C.getInputArgs());\n        HasValidOpenMPRuntime =\n            OpenMPKind == OMPRT_OMP || OpenMPKind == OMPRT_IOMP5;\n      }\n\n      if (HasValidOpenMPRuntime) {\n        llvm::StringMap<const char *> FoundNormalizedTriples;\n        for (const char *Val : OpenMPTargets->getValues()) {\n          llvm::Triple TT(Val);\n          std::string NormalizedName = TT.normalize();\n\n          // Make sure we don't have a duplicate triple.\n          auto Duplicate = FoundNormalizedTriples.find(NormalizedName);\n          if (Duplicate != FoundNormalizedTriples.end()) {\n            Diag(clang::diag::warn_drv_omp_offload_target_duplicate)\n                << Val << Duplicate->second;\n            continue;\n          }\n\n          // Store the current triple so that we can check for duplicates in the\n          // following iterations.\n          FoundNormalizedTriples[NormalizedName] = Val;\n\n          // If the specified target is invalid, emit a diagnostic.\n          if (TT.getArch() == llvm::Triple::UnknownArch)\n            Diag(clang::diag::err_drv_invalid_omp_target) << Val;\n          else {\n            const ToolChain *TC;\n            // Device toolchains have to be selected differently. They pair host\n            // and device in their implementation.\n            if (TT.isNVPTX() || TT.isAMDGCN()) {\n              const ToolChain *HostTC =\n                  C.getSingleOffloadToolChain<Action::OFK_Host>();\n              assert(HostTC && \"Host toolchain should be always defined.\");\n              auto &DeviceTC =\n                  ToolChains[TT.str() + \"/\" + HostTC->getTriple().normalize()];\n              if (!DeviceTC) {\n                if (TT.isNVPTX())\n                  DeviceTC = std::make_unique<toolchains::CudaToolChain>(\n                      *this, TT, *HostTC, C.getInputArgs(), Action::OFK_OpenMP);\n                else if (TT.isAMDGCN())\n                  DeviceTC =\n                      std::make_unique<toolchains::AMDGPUOpenMPToolChain>(\n                          *this, TT, *HostTC, C.getInputArgs());\n                else\n                  assert(DeviceTC && \"Device toolchain not defined.\");\n              }\n\n              TC = DeviceTC.get();\n            } else\n              TC = &getToolChain(C.getInputArgs(), TT);\n            C.addOffloadDeviceToolChain(TC, Action::OFK_OpenMP);\n          }\n        }\n      } else\n        Diag(clang::diag::err_drv_expecting_fopenmp_with_fopenmp_targets);\n    } else\n      Diag(clang::diag::warn_drv_empty_joined_argument)\n          << OpenMPTargets->getAsString(C.getInputArgs());\n  }\n\n  //\n  // TODO: Add support for other offloading programming models here.\n  //\n}\n\n/// Looks the given directories for the specified file.\n///\n/// \\param[out] FilePath File path, if the file was found.\n/// \\param[in]  Dirs Directories used for the search.\n/// \\param[in]  FileName Name of the file to search for.\n/// \\return True if file was found.\n///\n/// Looks for file specified by FileName sequentially in directories specified\n/// by Dirs.\n///\nstatic bool searchForFile(SmallVectorImpl<char> &FilePath,\n                          ArrayRef<StringRef> Dirs, StringRef FileName) {\n  SmallString<128> WPath;\n  for (const StringRef &Dir : Dirs) {\n    if (Dir.empty())\n      continue;\n    WPath.clear();\n    llvm::sys::path::append(WPath, Dir, FileName);\n    llvm::sys::path::native(WPath);\n    if (llvm::sys::fs::is_regular_file(WPath)) {\n      FilePath = std::move(WPath);\n      return true;\n    }\n  }\n  return false;\n}\n\nbool Driver::readConfigFile(StringRef FileName) {\n  // Try reading the given file.\n  SmallVector<const char *, 32> NewCfgArgs;\n  if (!llvm::cl::readConfigFile(FileName, Saver, NewCfgArgs)) {\n    Diag(diag::err_drv_cannot_read_config_file) << FileName;\n    return true;\n  }\n\n  // Read options from config file.\n  llvm::SmallString<128> CfgFileName(FileName);\n  llvm::sys::path::native(CfgFileName);\n  ConfigFile = std::string(CfgFileName);\n  bool ContainErrors;\n  CfgOptions = std::make_unique<InputArgList>(\n      ParseArgStrings(NewCfgArgs, IsCLMode(), ContainErrors));\n  if (ContainErrors) {\n    CfgOptions.reset();\n    return true;\n  }\n\n  if (CfgOptions->hasArg(options::OPT_config)) {\n    CfgOptions.reset();\n    Diag(diag::err_drv_nested_config_file);\n    return true;\n  }\n\n  // Claim all arguments that come from a configuration file so that the driver\n  // does not warn on any that is unused.\n  for (Arg *A : *CfgOptions)\n    A->claim();\n  return false;\n}\n\nbool Driver::loadConfigFile() {\n  std::string CfgFileName;\n  bool FileSpecifiedExplicitly = false;\n\n  // Process options that change search path for config files.\n  if (CLOptions) {\n    if (CLOptions->hasArg(options::OPT_config_system_dir_EQ)) {\n      SmallString<128> CfgDir;\n      CfgDir.append(\n          CLOptions->getLastArgValue(options::OPT_config_system_dir_EQ));\n      if (!CfgDir.empty()) {\n        if (llvm::sys::fs::make_absolute(CfgDir).value() != 0)\n          SystemConfigDir.clear();\n        else\n          SystemConfigDir = std::string(CfgDir.begin(), CfgDir.end());\n      }\n    }\n    if (CLOptions->hasArg(options::OPT_config_user_dir_EQ)) {\n      SmallString<128> CfgDir;\n      CfgDir.append(\n          CLOptions->getLastArgValue(options::OPT_config_user_dir_EQ));\n      if (!CfgDir.empty()) {\n        if (llvm::sys::fs::make_absolute(CfgDir).value() != 0)\n          UserConfigDir.clear();\n        else\n          UserConfigDir = std::string(CfgDir.begin(), CfgDir.end());\n      }\n    }\n  }\n\n  // First try to find config file specified in command line.\n  if (CLOptions) {\n    std::vector<std::string> ConfigFiles =\n        CLOptions->getAllArgValues(options::OPT_config);\n    if (ConfigFiles.size() > 1) {\n      if (!std::all_of(ConfigFiles.begin(), ConfigFiles.end(),\n                       [ConfigFiles](const std::string &s) {\n                         return s == ConfigFiles[0];\n                       })) {\n        Diag(diag::err_drv_duplicate_config);\n        return true;\n      }\n    }\n\n    if (!ConfigFiles.empty()) {\n      CfgFileName = ConfigFiles.front();\n      assert(!CfgFileName.empty());\n\n      // If argument contains directory separator, treat it as a path to\n      // configuration file.\n      if (llvm::sys::path::has_parent_path(CfgFileName)) {\n        SmallString<128> CfgFilePath;\n        if (llvm::sys::path::is_relative(CfgFileName))\n          llvm::sys::fs::current_path(CfgFilePath);\n        llvm::sys::path::append(CfgFilePath, CfgFileName);\n        if (!llvm::sys::fs::is_regular_file(CfgFilePath)) {\n          Diag(diag::err_drv_config_file_not_exist) << CfgFilePath;\n          return true;\n        }\n        return readConfigFile(CfgFilePath);\n      }\n\n      FileSpecifiedExplicitly = true;\n    }\n  }\n\n  // If config file is not specified explicitly, try to deduce configuration\n  // from executable name. For instance, an executable 'armv7l-clang' will\n  // search for config file 'armv7l-clang.cfg'.\n  if (CfgFileName.empty() && !ClangNameParts.TargetPrefix.empty())\n    CfgFileName = ClangNameParts.TargetPrefix + '-' + ClangNameParts.ModeSuffix;\n\n  if (CfgFileName.empty())\n    return false;\n\n  // Determine architecture part of the file name, if it is present.\n  StringRef CfgFileArch = CfgFileName;\n  size_t ArchPrefixLen = CfgFileArch.find('-');\n  if (ArchPrefixLen == StringRef::npos)\n    ArchPrefixLen = CfgFileArch.size();\n  llvm::Triple CfgTriple;\n  CfgFileArch = CfgFileArch.take_front(ArchPrefixLen);\n  CfgTriple = llvm::Triple(llvm::Triple::normalize(CfgFileArch));\n  if (CfgTriple.getArch() == llvm::Triple::ArchType::UnknownArch)\n    ArchPrefixLen = 0;\n\n  if (!StringRef(CfgFileName).endswith(\".cfg\"))\n    CfgFileName += \".cfg\";\n\n  // If config file starts with architecture name and command line options\n  // redefine architecture (with options like -m32 -LE etc), try finding new\n  // config file with that architecture.\n  SmallString<128> FixedConfigFile;\n  size_t FixedArchPrefixLen = 0;\n  if (ArchPrefixLen) {\n    // Get architecture name from config file name like 'i386.cfg' or\n    // 'armv7l-clang.cfg'.\n    // Check if command line options changes effective triple.\n    llvm::Triple EffectiveTriple = computeTargetTriple(*this,\n                                             CfgTriple.getTriple(), *CLOptions);\n    if (CfgTriple.getArch() != EffectiveTriple.getArch()) {\n      FixedConfigFile = EffectiveTriple.getArchName();\n      FixedArchPrefixLen = FixedConfigFile.size();\n      // Append the rest of original file name so that file name transforms\n      // like: i386-clang.cfg -> x86_64-clang.cfg.\n      if (ArchPrefixLen < CfgFileName.size())\n        FixedConfigFile += CfgFileName.substr(ArchPrefixLen);\n    }\n  }\n\n  // Prepare list of directories where config file is searched for.\n  StringRef CfgFileSearchDirs[] = {UserConfigDir, SystemConfigDir, Dir};\n\n  // Try to find config file. First try file with corrected architecture.\n  llvm::SmallString<128> CfgFilePath;\n  if (!FixedConfigFile.empty()) {\n    if (searchForFile(CfgFilePath, CfgFileSearchDirs, FixedConfigFile))\n      return readConfigFile(CfgFilePath);\n    // If 'x86_64-clang.cfg' was not found, try 'x86_64.cfg'.\n    FixedConfigFile.resize(FixedArchPrefixLen);\n    FixedConfigFile.append(\".cfg\");\n    if (searchForFile(CfgFilePath, CfgFileSearchDirs, FixedConfigFile))\n      return readConfigFile(CfgFilePath);\n  }\n\n  // Then try original file name.\n  if (searchForFile(CfgFilePath, CfgFileSearchDirs, CfgFileName))\n    return readConfigFile(CfgFilePath);\n\n  // Finally try removing driver mode part: 'x86_64-clang.cfg' -> 'x86_64.cfg'.\n  if (!ClangNameParts.ModeSuffix.empty() &&\n      !ClangNameParts.TargetPrefix.empty()) {\n    CfgFileName.assign(ClangNameParts.TargetPrefix);\n    CfgFileName.append(\".cfg\");\n    if (searchForFile(CfgFilePath, CfgFileSearchDirs, CfgFileName))\n      return readConfigFile(CfgFilePath);\n  }\n\n  // Report error but only if config file was specified explicitly, by option\n  // --config. If it was deduced from executable name, it is not an error.\n  if (FileSpecifiedExplicitly) {\n    Diag(diag::err_drv_config_file_not_found) << CfgFileName;\n    for (const StringRef &SearchDir : CfgFileSearchDirs)\n      if (!SearchDir.empty())\n        Diag(diag::note_drv_config_file_searched_in) << SearchDir;\n    return true;\n  }\n\n  return false;\n}\n\nCompilation *Driver::BuildCompilation(ArrayRef<const char *> ArgList) {\n  llvm::PrettyStackTraceString CrashInfo(\"Compilation construction\");\n\n  // FIXME: Handle environment options which affect driver behavior, somewhere\n  // (client?). GCC_EXEC_PREFIX, LPATH, CC_PRINT_OPTIONS.\n\n  // We look for the driver mode option early, because the mode can affect\n  // how other options are parsed.\n  ParseDriverMode(ClangExecutable, ArgList.slice(1));\n\n  // FIXME: What are we going to do with -V and -b?\n\n  // Arguments specified in command line.\n  bool ContainsError;\n  CLOptions = std::make_unique<InputArgList>(\n      ParseArgStrings(ArgList.slice(1), IsCLMode(), ContainsError));\n\n  // Try parsing configuration file.\n  if (!ContainsError)\n    ContainsError = loadConfigFile();\n  bool HasConfigFile = !ContainsError && (CfgOptions.get() != nullptr);\n\n  // All arguments, from both config file and command line.\n  InputArgList Args = std::move(HasConfigFile ? std::move(*CfgOptions)\n                                              : std::move(*CLOptions));\n\n  // The args for config files or /clang: flags belong to different InputArgList\n  // objects than Args. This copies an Arg from one of those other InputArgLists\n  // to the ownership of Args.\n  auto appendOneArg = [&Args](const Arg *Opt, const Arg *BaseArg) {\n    unsigned Index = Args.MakeIndex(Opt->getSpelling());\n    Arg *Copy = new llvm::opt::Arg(Opt->getOption(), Args.getArgString(Index),\n                                   Index, BaseArg);\n    Copy->getValues() = Opt->getValues();\n    if (Opt->isClaimed())\n      Copy->claim();\n    Copy->setOwnsValues(Opt->getOwnsValues());\n    Opt->setOwnsValues(false);\n    Args.append(Copy);\n  };\n\n  if (HasConfigFile)\n    for (auto *Opt : *CLOptions) {\n      if (Opt->getOption().matches(options::OPT_config))\n        continue;\n      const Arg *BaseArg = &Opt->getBaseArg();\n      if (BaseArg == Opt)\n        BaseArg = nullptr;\n      appendOneArg(Opt, BaseArg);\n    }\n\n  // In CL mode, look for any pass-through arguments\n  if (IsCLMode() && !ContainsError) {\n    SmallVector<const char *, 16> CLModePassThroughArgList;\n    for (const auto *A : Args.filtered(options::OPT__SLASH_clang)) {\n      A->claim();\n      CLModePassThroughArgList.push_back(A->getValue());\n    }\n\n    if (!CLModePassThroughArgList.empty()) {\n      // Parse any pass through args using default clang processing rather\n      // than clang-cl processing.\n      auto CLModePassThroughOptions = std::make_unique<InputArgList>(\n          ParseArgStrings(CLModePassThroughArgList, false, ContainsError));\n\n      if (!ContainsError)\n        for (auto *Opt : *CLModePassThroughOptions) {\n          appendOneArg(Opt, nullptr);\n        }\n    }\n  }\n\n  // Check for working directory option before accessing any files\n  if (Arg *WD = Args.getLastArg(options::OPT_working_directory))\n    if (VFS->setCurrentWorkingDirectory(WD->getValue()))\n      Diag(diag::err_drv_unable_to_set_working_directory) << WD->getValue();\n\n  // FIXME: This stuff needs to go into the Compilation, not the driver.\n  bool CCCPrintPhases;\n\n  // Silence driver warnings if requested\n  Diags.setIgnoreAllWarnings(Args.hasArg(options::OPT_w));\n\n  // -no-canonical-prefixes is used very early in main.\n  Args.ClaimAllArgs(options::OPT_no_canonical_prefixes);\n\n  // f(no-)integated-cc1 is also used very early in main.\n  Args.ClaimAllArgs(options::OPT_fintegrated_cc1);\n  Args.ClaimAllArgs(options::OPT_fno_integrated_cc1);\n\n  // Ignore -pipe.\n  Args.ClaimAllArgs(options::OPT_pipe);\n\n  // Extract -ccc args.\n  //\n  // FIXME: We need to figure out where this behavior should live. Most of it\n  // should be outside in the client; the parts that aren't should have proper\n  // options, either by introducing new ones or by overloading gcc ones like -V\n  // or -b.\n  CCCPrintPhases = Args.hasArg(options::OPT_ccc_print_phases);\n  CCCPrintBindings = Args.hasArg(options::OPT_ccc_print_bindings);\n  if (const Arg *A = Args.getLastArg(options::OPT_ccc_gcc_name))\n    CCCGenericGCCName = A->getValue();\n  GenReproducer = Args.hasFlag(options::OPT_gen_reproducer,\n                               options::OPT_fno_crash_diagnostics,\n                               !!::getenv(\"FORCE_CLANG_DIAGNOSTICS_CRASH\"));\n  // FIXME: TargetTriple is used by the target-prefixed calls to as/ld\n  // and getToolChain is const.\n  if (IsCLMode()) {\n    // clang-cl targets MSVC-style Win32.\n    llvm::Triple T(TargetTriple);\n    T.setOS(llvm::Triple::Win32);\n    T.setVendor(llvm::Triple::PC);\n    T.setEnvironment(llvm::Triple::MSVC);\n    T.setObjectFormat(llvm::Triple::COFF);\n    TargetTriple = T.str();\n  }\n  if (const Arg *A = Args.getLastArg(options::OPT_target))\n    TargetTriple = A->getValue();\n  if (const Arg *A = Args.getLastArg(options::OPT_ccc_install_dir))\n    Dir = InstalledDir = A->getValue();\n  for (const Arg *A : Args.filtered(options::OPT_B)) {\n    A->claim();\n    PrefixDirs.push_back(A->getValue(0));\n  }\n  if (Optional<std::string> CompilerPathValue =\n          llvm::sys::Process::GetEnv(\"COMPILER_PATH\")) {\n    StringRef CompilerPath = *CompilerPathValue;\n    while (!CompilerPath.empty()) {\n      std::pair<StringRef, StringRef> Split =\n          CompilerPath.split(llvm::sys::EnvPathSeparator);\n      PrefixDirs.push_back(std::string(Split.first));\n      CompilerPath = Split.second;\n    }\n  }\n  if (const Arg *A = Args.getLastArg(options::OPT__sysroot_EQ))\n    SysRoot = A->getValue();\n  if (const Arg *A = Args.getLastArg(options::OPT__dyld_prefix_EQ))\n    DyldPrefix = A->getValue();\n\n  if (const Arg *A = Args.getLastArg(options::OPT_resource_dir))\n    ResourceDir = A->getValue();\n\n  if (const Arg *A = Args.getLastArg(options::OPT_save_temps_EQ)) {\n    SaveTemps = llvm::StringSwitch<SaveTempsMode>(A->getValue())\n                    .Case(\"cwd\", SaveTempsCwd)\n                    .Case(\"obj\", SaveTempsObj)\n                    .Default(SaveTempsCwd);\n  }\n\n  setLTOMode(Args);\n\n  // Process -fembed-bitcode= flags.\n  if (Arg *A = Args.getLastArg(options::OPT_fembed_bitcode_EQ)) {\n    StringRef Name = A->getValue();\n    unsigned Model = llvm::StringSwitch<unsigned>(Name)\n        .Case(\"off\", EmbedNone)\n        .Case(\"all\", EmbedBitcode)\n        .Case(\"bitcode\", EmbedBitcode)\n        .Case(\"marker\", EmbedMarker)\n        .Default(~0U);\n    if (Model == ~0U) {\n      Diags.Report(diag::err_drv_invalid_value) << A->getAsString(Args)\n                                                << Name;\n    } else\n      BitcodeEmbed = static_cast<BitcodeEmbedMode>(Model);\n  }\n\n  std::unique_ptr<llvm::opt::InputArgList> UArgs =\n      std::make_unique<InputArgList>(std::move(Args));\n\n  // Perform the default argument translations.\n  DerivedArgList *TranslatedArgs = TranslateInputArgs(*UArgs);\n\n  // Owned by the host.\n  const ToolChain &TC = getToolChain(\n      *UArgs, computeTargetTriple(*this, TargetTriple, *UArgs));\n\n  // The compilation takes ownership of Args.\n  Compilation *C = new Compilation(*this, TC, UArgs.release(), TranslatedArgs,\n                                   ContainsError);\n\n  if (!HandleImmediateArgs(*C))\n    return C;\n\n  // Construct the list of inputs.\n  InputList Inputs;\n  BuildInputs(C->getDefaultToolChain(), *TranslatedArgs, Inputs);\n\n  // Populate the tool chains for the offloading devices, if any.\n  CreateOffloadingDeviceToolChains(*C, Inputs);\n\n  // Construct the list of abstract actions to perform for this compilation. On\n  // MachO targets this uses the driver-driver and universal actions.\n  if (TC.getTriple().isOSBinFormatMachO())\n    BuildUniversalActions(*C, C->getDefaultToolChain(), Inputs);\n  else\n    BuildActions(*C, C->getArgs(), Inputs, C->getActions());\n\n  if (CCCPrintPhases) {\n    PrintActions(*C);\n    return C;\n  }\n\n  BuildJobs(*C);\n\n  return C;\n}\n\nstatic void printArgList(raw_ostream &OS, const llvm::opt::ArgList &Args) {\n  llvm::opt::ArgStringList ASL;\n  for (const auto *A : Args)\n    A->render(Args, ASL);\n\n  for (auto I = ASL.begin(), E = ASL.end(); I != E; ++I) {\n    if (I != ASL.begin())\n      OS << ' ';\n    llvm::sys::printArg(OS, *I, true);\n  }\n  OS << '\\n';\n}\n\nbool Driver::getCrashDiagnosticFile(StringRef ReproCrashFilename,\n                                    SmallString<128> &CrashDiagDir) {\n  using namespace llvm::sys;\n  assert(llvm::Triple(llvm::sys::getProcessTriple()).isOSDarwin() &&\n         \"Only knows about .crash files on Darwin\");\n\n  // The .crash file can be found on at ~/Library/Logs/DiagnosticReports/\n  // (or /Library/Logs/DiagnosticReports for root) and has the filename pattern\n  // clang-<VERSION>_<YYYY-MM-DD-HHMMSS>_<hostname>.crash.\n  path::home_directory(CrashDiagDir);\n  if (CrashDiagDir.startswith(\"/var/root\"))\n    CrashDiagDir = \"/\";\n  path::append(CrashDiagDir, \"Library/Logs/DiagnosticReports\");\n  int PID =\n#if LLVM_ON_UNIX\n      getpid();\n#else\n      0;\n#endif\n  std::error_code EC;\n  fs::file_status FileStatus;\n  TimePoint<> LastAccessTime;\n  SmallString<128> CrashFilePath;\n  // Lookup the .crash files and get the one generated by a subprocess spawned\n  // by this driver invocation.\n  for (fs::directory_iterator File(CrashDiagDir, EC), FileEnd;\n       File != FileEnd && !EC; File.increment(EC)) {\n    StringRef FileName = path::filename(File->path());\n    if (!FileName.startswith(Name))\n      continue;\n    if (fs::status(File->path(), FileStatus))\n      continue;\n    llvm::ErrorOr<std::unique_ptr<llvm::MemoryBuffer>> CrashFile =\n        llvm::MemoryBuffer::getFile(File->path());\n    if (!CrashFile)\n      continue;\n    // The first line should start with \"Process:\", otherwise this isn't a real\n    // .crash file.\n    StringRef Data = CrashFile.get()->getBuffer();\n    if (!Data.startswith(\"Process:\"))\n      continue;\n    // Parse parent process pid line, e.g: \"Parent Process: clang-4.0 [79141]\"\n    size_t ParentProcPos = Data.find(\"Parent Process:\");\n    if (ParentProcPos == StringRef::npos)\n      continue;\n    size_t LineEnd = Data.find_first_of(\"\\n\", ParentProcPos);\n    if (LineEnd == StringRef::npos)\n      continue;\n    StringRef ParentProcess = Data.slice(ParentProcPos+15, LineEnd).trim();\n    int OpenBracket = -1, CloseBracket = -1;\n    for (size_t i = 0, e = ParentProcess.size(); i < e; ++i) {\n      if (ParentProcess[i] == '[')\n        OpenBracket = i;\n      if (ParentProcess[i] == ']')\n        CloseBracket = i;\n    }\n    // Extract the parent process PID from the .crash file and check whether\n    // it matches this driver invocation pid.\n    int CrashPID;\n    if (OpenBracket < 0 || CloseBracket < 0 ||\n        ParentProcess.slice(OpenBracket + 1, CloseBracket)\n            .getAsInteger(10, CrashPID) || CrashPID != PID) {\n      continue;\n    }\n\n    // Found a .crash file matching the driver pid. To avoid getting an older\n    // and misleading crash file, continue looking for the most recent.\n    // FIXME: the driver can dispatch multiple cc1 invocations, leading to\n    // multiple crashes poiting to the same parent process. Since the driver\n    // does not collect pid information for the dispatched invocation there's\n    // currently no way to distinguish among them.\n    const auto FileAccessTime = FileStatus.getLastModificationTime();\n    if (FileAccessTime > LastAccessTime) {\n      CrashFilePath.assign(File->path());\n      LastAccessTime = FileAccessTime;\n    }\n  }\n\n  // If found, copy it over to the location of other reproducer files.\n  if (!CrashFilePath.empty()) {\n    EC = fs::copy_file(CrashFilePath, ReproCrashFilename);\n    if (EC)\n      return false;\n    return true;\n  }\n\n  return false;\n}\n\n// When clang crashes, produce diagnostic information including the fully\n// preprocessed source file(s).  Request that the developer attach the\n// diagnostic information to a bug report.\nvoid Driver::generateCompilationDiagnostics(\n    Compilation &C, const Command &FailingCommand,\n    StringRef AdditionalInformation, CompilationDiagnosticReport *Report) {\n  if (C.getArgs().hasArg(options::OPT_fno_crash_diagnostics))\n    return;\n\n  // Don't try to generate diagnostics for link or dsymutil jobs.\n  if (FailingCommand.getCreator().isLinkJob() ||\n      FailingCommand.getCreator().isDsymutilJob())\n    return;\n\n  // Print the version of the compiler.\n  PrintVersion(C, llvm::errs());\n\n  // Suppress driver output and emit preprocessor output to temp file.\n  Mode = CPPMode;\n  CCGenDiagnostics = true;\n\n  // Save the original job command(s).\n  Command Cmd = FailingCommand;\n\n  // Keep track of whether we produce any errors while trying to produce\n  // preprocessed sources.\n  DiagnosticErrorTrap Trap(Diags);\n\n  // Suppress tool output.\n  C.initCompilationForDiagnostics();\n\n  // Construct the list of inputs.\n  InputList Inputs;\n  BuildInputs(C.getDefaultToolChain(), C.getArgs(), Inputs);\n\n  for (InputList::iterator it = Inputs.begin(), ie = Inputs.end(); it != ie;) {\n    bool IgnoreInput = false;\n\n    // Ignore input from stdin or any inputs that cannot be preprocessed.\n    // Check type first as not all linker inputs have a value.\n    if (types::getPreprocessedType(it->first) == types::TY_INVALID) {\n      IgnoreInput = true;\n    } else if (!strcmp(it->second->getValue(), \"-\")) {\n      Diag(clang::diag::note_drv_command_failed_diag_msg)\n          << \"Error generating preprocessed source(s) - \"\n             \"ignoring input from stdin.\";\n      IgnoreInput = true;\n    }\n\n    if (IgnoreInput) {\n      it = Inputs.erase(it);\n      ie = Inputs.end();\n    } else {\n      ++it;\n    }\n  }\n\n  if (Inputs.empty()) {\n    Diag(clang::diag::note_drv_command_failed_diag_msg)\n        << \"Error generating preprocessed source(s) - \"\n           \"no preprocessable inputs.\";\n    return;\n  }\n\n  // Don't attempt to generate preprocessed files if multiple -arch options are\n  // used, unless they're all duplicates.\n  llvm::StringSet<> ArchNames;\n  for (const Arg *A : C.getArgs()) {\n    if (A->getOption().matches(options::OPT_arch)) {\n      StringRef ArchName = A->getValue();\n      ArchNames.insert(ArchName);\n    }\n  }\n  if (ArchNames.size() > 1) {\n    Diag(clang::diag::note_drv_command_failed_diag_msg)\n        << \"Error generating preprocessed source(s) - cannot generate \"\n           \"preprocessed source with multiple -arch options.\";\n    return;\n  }\n\n  // Construct the list of abstract actions to perform for this compilation. On\n  // Darwin OSes this uses the driver-driver and builds universal actions.\n  const ToolChain &TC = C.getDefaultToolChain();\n  if (TC.getTriple().isOSBinFormatMachO())\n    BuildUniversalActions(C, TC, Inputs);\n  else\n    BuildActions(C, C.getArgs(), Inputs, C.getActions());\n\n  BuildJobs(C);\n\n  // If there were errors building the compilation, quit now.\n  if (Trap.hasErrorOccurred()) {\n    Diag(clang::diag::note_drv_command_failed_diag_msg)\n        << \"Error generating preprocessed source(s).\";\n    return;\n  }\n\n  // Generate preprocessed output.\n  SmallVector<std::pair<int, const Command *>, 4> FailingCommands;\n  C.ExecuteJobs(C.getJobs(), FailingCommands);\n\n  // If any of the preprocessing commands failed, clean up and exit.\n  if (!FailingCommands.empty()) {\n    Diag(clang::diag::note_drv_command_failed_diag_msg)\n        << \"Error generating preprocessed source(s).\";\n    return;\n  }\n\n  const ArgStringList &TempFiles = C.getTempFiles();\n  if (TempFiles.empty()) {\n    Diag(clang::diag::note_drv_command_failed_diag_msg)\n        << \"Error generating preprocessed source(s).\";\n    return;\n  }\n\n  Diag(clang::diag::note_drv_command_failed_diag_msg)\n      << \"\\n********************\\n\\n\"\n         \"PLEASE ATTACH THE FOLLOWING FILES TO THE BUG REPORT:\\n\"\n         \"Preprocessed source(s) and associated run script(s) are located at:\";\n\n  SmallString<128> VFS;\n  SmallString<128> ReproCrashFilename;\n  for (const char *TempFile : TempFiles) {\n    Diag(clang::diag::note_drv_command_failed_diag_msg) << TempFile;\n    if (Report)\n      Report->TemporaryFiles.push_back(TempFile);\n    if (ReproCrashFilename.empty()) {\n      ReproCrashFilename = TempFile;\n      llvm::sys::path::replace_extension(ReproCrashFilename, \".crash\");\n    }\n    if (StringRef(TempFile).endswith(\".cache\")) {\n      // In some cases (modules) we'll dump extra data to help with reproducing\n      // the crash into a directory next to the output.\n      VFS = llvm::sys::path::filename(TempFile);\n      llvm::sys::path::append(VFS, \"vfs\", \"vfs.yaml\");\n    }\n  }\n\n  // Assume associated files are based off of the first temporary file.\n  CrashReportInfo CrashInfo(TempFiles[0], VFS);\n\n  llvm::SmallString<128> Script(CrashInfo.Filename);\n  llvm::sys::path::replace_extension(Script, \"sh\");\n  std::error_code EC;\n  llvm::raw_fd_ostream ScriptOS(Script, EC, llvm::sys::fs::CD_CreateNew);\n  if (EC) {\n    Diag(clang::diag::note_drv_command_failed_diag_msg)\n        << \"Error generating run script: \" << Script << \" \" << EC.message();\n  } else {\n    ScriptOS << \"# Crash reproducer for \" << getClangFullVersion() << \"\\n\"\n             << \"# Driver args: \";\n    printArgList(ScriptOS, C.getInputArgs());\n    ScriptOS << \"# Original command: \";\n    Cmd.Print(ScriptOS, \"\\n\", /*Quote=*/true);\n    Cmd.Print(ScriptOS, \"\\n\", /*Quote=*/true, &CrashInfo);\n    if (!AdditionalInformation.empty())\n      ScriptOS << \"\\n# Additional information: \" << AdditionalInformation\n               << \"\\n\";\n    if (Report)\n      Report->TemporaryFiles.push_back(std::string(Script.str()));\n    Diag(clang::diag::note_drv_command_failed_diag_msg) << Script;\n  }\n\n  // On darwin, provide information about the .crash diagnostic report.\n  if (llvm::Triple(llvm::sys::getProcessTriple()).isOSDarwin()) {\n    SmallString<128> CrashDiagDir;\n    if (getCrashDiagnosticFile(ReproCrashFilename, CrashDiagDir)) {\n      Diag(clang::diag::note_drv_command_failed_diag_msg)\n          << ReproCrashFilename.str();\n    } else { // Suggest a directory for the user to look for .crash files.\n      llvm::sys::path::append(CrashDiagDir, Name);\n      CrashDiagDir += \"_<YYYY-MM-DD-HHMMSS>_<hostname>.crash\";\n      Diag(clang::diag::note_drv_command_failed_diag_msg)\n          << \"Crash backtrace is located in\";\n      Diag(clang::diag::note_drv_command_failed_diag_msg)\n          << CrashDiagDir.str();\n      Diag(clang::diag::note_drv_command_failed_diag_msg)\n          << \"(choose the .crash file that corresponds to your crash)\";\n    }\n  }\n\n  for (const auto &A : C.getArgs().filtered(options::OPT_frewrite_map_file,\n                                            options::OPT_frewrite_map_file_EQ))\n    Diag(clang::diag::note_drv_command_failed_diag_msg) << A->getValue();\n\n  Diag(clang::diag::note_drv_command_failed_diag_msg)\n      << \"\\n\\n********************\";\n}\n\nvoid Driver::setUpResponseFiles(Compilation &C, Command &Cmd) {\n  // Since commandLineFitsWithinSystemLimits() may underestimate system's\n  // capacity if the tool does not support response files, there is a chance/\n  // that things will just work without a response file, so we silently just\n  // skip it.\n  if (Cmd.getResponseFileSupport().ResponseKind ==\n          ResponseFileSupport::RF_None ||\n      llvm::sys::commandLineFitsWithinSystemLimits(Cmd.getExecutable(),\n                                                   Cmd.getArguments()))\n    return;\n\n  std::string TmpName = GetTemporaryPath(\"response\", \"txt\");\n  Cmd.setResponseFile(C.addTempFile(C.getArgs().MakeArgString(TmpName)));\n}\n\nint Driver::ExecuteCompilation(\n    Compilation &C,\n    SmallVectorImpl<std::pair<int, const Command *>> &FailingCommands) {\n  // Just print if -### was present.\n  if (C.getArgs().hasArg(options::OPT__HASH_HASH_HASH)) {\n    C.getJobs().Print(llvm::errs(), \"\\n\", true);\n    return 0;\n  }\n\n  // If there were errors building the compilation, quit now.\n  if (Diags.hasErrorOccurred())\n    return 1;\n\n  // Set up response file names for each command, if necessary\n  for (auto &Job : C.getJobs())\n    setUpResponseFiles(C, Job);\n\n  C.ExecuteJobs(C.getJobs(), FailingCommands);\n\n  // If the command succeeded, we are done.\n  if (FailingCommands.empty())\n    return 0;\n\n  // Otherwise, remove result files and print extra information about abnormal\n  // failures.\n  int Res = 0;\n  for (const auto &CmdPair : FailingCommands) {\n    int CommandRes = CmdPair.first;\n    const Command *FailingCommand = CmdPair.second;\n\n    // Remove result files if we're not saving temps.\n    if (!isSaveTempsEnabled()) {\n      const JobAction *JA = cast<JobAction>(&FailingCommand->getSource());\n      C.CleanupFileMap(C.getResultFiles(), JA, true);\n\n      // Failure result files are valid unless we crashed.\n      if (CommandRes < 0)\n        C.CleanupFileMap(C.getFailureResultFiles(), JA, true);\n    }\n\n#if LLVM_ON_UNIX\n    // llvm/lib/Support/Unix/Signals.inc will exit with a special return code\n    // for SIGPIPE. Do not print diagnostics for this case.\n    if (CommandRes == EX_IOERR) {\n      Res = CommandRes;\n      continue;\n    }\n#endif\n\n    // Print extra information about abnormal failures, if possible.\n    //\n    // This is ad-hoc, but we don't want to be excessively noisy. If the result\n    // status was 1, assume the command failed normally. In particular, if it\n    // was the compiler then assume it gave a reasonable error code. Failures\n    // in other tools are less common, and they generally have worse\n    // diagnostics, so always print the diagnostic there.\n    const Tool &FailingTool = FailingCommand->getCreator();\n\n    if (!FailingCommand->getCreator().hasGoodDiagnostics() || CommandRes != 1) {\n      // FIXME: See FIXME above regarding result code interpretation.\n      if (CommandRes < 0)\n        Diag(clang::diag::err_drv_command_signalled)\n            << FailingTool.getShortName();\n      else\n        Diag(clang::diag::err_drv_command_failed)\n            << FailingTool.getShortName() << CommandRes;\n    }\n  }\n  return Res;\n}\n\nvoid Driver::PrintHelp(bool ShowHidden) const {\n  unsigned IncludedFlagsBitmask;\n  unsigned ExcludedFlagsBitmask;\n  std::tie(IncludedFlagsBitmask, ExcludedFlagsBitmask) =\n      getIncludeExcludeOptionFlagMasks(IsCLMode());\n\n  ExcludedFlagsBitmask |= options::NoDriverOption;\n  if (!ShowHidden)\n    ExcludedFlagsBitmask |= HelpHidden;\n\n  if (IsFlangMode())\n    IncludedFlagsBitmask |= options::FlangOption;\n  else\n    ExcludedFlagsBitmask |= options::FlangOnlyOption;\n\n  std::string Usage = llvm::formatv(\"{0} [options] file...\", Name).str();\n  getOpts().PrintHelp(llvm::outs(), Usage.c_str(), DriverTitle.c_str(),\n                      IncludedFlagsBitmask, ExcludedFlagsBitmask,\n                      /*ShowAllAliases=*/false);\n}\n\nvoid Driver::PrintVersion(const Compilation &C, raw_ostream &OS) const {\n  if (IsFlangMode()) {\n    OS << getClangToolFullVersion(\"flang-new\") << '\\n';\n  } else {\n    // FIXME: The following handlers should use a callback mechanism, we don't\n    // know what the client would like to do.\n    OS << getClangFullVersion() << '\\n';\n  }\n  const ToolChain &TC = C.getDefaultToolChain();\n  OS << \"Target: \" << TC.getTripleString() << '\\n';\n\n  // Print the threading model.\n  if (Arg *A = C.getArgs().getLastArg(options::OPT_mthread_model)) {\n    // Don't print if the ToolChain would have barfed on it already\n    if (TC.isThreadModelSupported(A->getValue()))\n      OS << \"Thread model: \" << A->getValue();\n  } else\n    OS << \"Thread model: \" << TC.getThreadModel();\n  OS << '\\n';\n\n  // Print out the install directory.\n  OS << \"InstalledDir: \" << InstalledDir << '\\n';\n\n  // If configuration file was used, print its path.\n  if (!ConfigFile.empty())\n    OS << \"Configuration file: \" << ConfigFile << '\\n';\n}\n\n/// PrintDiagnosticCategories - Implement the --print-diagnostic-categories\n/// option.\nstatic void PrintDiagnosticCategories(raw_ostream &OS) {\n  // Skip the empty category.\n  for (unsigned i = 1, max = DiagnosticIDs::getNumberOfCategories(); i != max;\n       ++i)\n    OS << i << ',' << DiagnosticIDs::getCategoryNameFromID(i) << '\\n';\n}\n\nvoid Driver::HandleAutocompletions(StringRef PassedFlags) const {\n  if (PassedFlags == \"\")\n    return;\n  // Print out all options that start with a given argument. This is used for\n  // shell autocompletion.\n  std::vector<std::string> SuggestedCompletions;\n  std::vector<std::string> Flags;\n\n  unsigned int DisableFlags =\n      options::NoDriverOption | options::Unsupported | options::Ignored;\n\n  // Make sure that Flang-only options don't pollute the Clang output\n  // TODO: Make sure that Clang-only options don't pollute Flang output\n  if (!IsFlangMode())\n    DisableFlags |= options::FlangOnlyOption;\n\n  // Distinguish \"--autocomplete=-someflag\" and \"--autocomplete=-someflag,\"\n  // because the latter indicates that the user put space before pushing tab\n  // which should end up in a file completion.\n  const bool HasSpace = PassedFlags.endswith(\",\");\n\n  // Parse PassedFlags by \",\" as all the command-line flags are passed to this\n  // function separated by \",\"\n  StringRef TargetFlags = PassedFlags;\n  while (TargetFlags != \"\") {\n    StringRef CurFlag;\n    std::tie(CurFlag, TargetFlags) = TargetFlags.split(\",\");\n    Flags.push_back(std::string(CurFlag));\n  }\n\n  // We want to show cc1-only options only when clang is invoked with -cc1 or\n  // -Xclang.\n  if (llvm::is_contained(Flags, \"-Xclang\") || llvm::is_contained(Flags, \"-cc1\"))\n    DisableFlags &= ~options::NoDriverOption;\n\n  const llvm::opt::OptTable &Opts = getOpts();\n  StringRef Cur;\n  Cur = Flags.at(Flags.size() - 1);\n  StringRef Prev;\n  if (Flags.size() >= 2) {\n    Prev = Flags.at(Flags.size() - 2);\n    SuggestedCompletions = Opts.suggestValueCompletions(Prev, Cur);\n  }\n\n  if (SuggestedCompletions.empty())\n    SuggestedCompletions = Opts.suggestValueCompletions(Cur, \"\");\n\n  // If Flags were empty, it means the user typed `clang [tab]` where we should\n  // list all possible flags. If there was no value completion and the user\n  // pressed tab after a space, we should fall back to a file completion.\n  // We're printing a newline to be consistent with what we print at the end of\n  // this function.\n  if (SuggestedCompletions.empty() && HasSpace && !Flags.empty()) {\n    llvm::outs() << '\\n';\n    return;\n  }\n\n  // When flag ends with '=' and there was no value completion, return empty\n  // string and fall back to the file autocompletion.\n  if (SuggestedCompletions.empty() && !Cur.endswith(\"=\")) {\n    // If the flag is in the form of \"--autocomplete=-foo\",\n    // we were requested to print out all option names that start with \"-foo\".\n    // For example, \"--autocomplete=-fsyn\" is expanded to \"-fsyntax-only\".\n    SuggestedCompletions = Opts.findByPrefix(Cur, DisableFlags);\n\n    // We have to query the -W flags manually as they're not in the OptTable.\n    // TODO: Find a good way to add them to OptTable instead and them remove\n    // this code.\n    for (StringRef S : DiagnosticIDs::getDiagnosticFlags())\n      if (S.startswith(Cur))\n        SuggestedCompletions.push_back(std::string(S));\n  }\n\n  // Sort the autocomplete candidates so that shells print them out in a\n  // deterministic order. We could sort in any way, but we chose\n  // case-insensitive sorting for consistency with the -help option\n  // which prints out options in the case-insensitive alphabetical order.\n  llvm::sort(SuggestedCompletions, [](StringRef A, StringRef B) {\n    if (int X = A.compare_lower(B))\n      return X < 0;\n    return A.compare(B) > 0;\n  });\n\n  llvm::outs() << llvm::join(SuggestedCompletions, \"\\n\") << '\\n';\n}\n\nbool Driver::HandleImmediateArgs(const Compilation &C) {\n  // The order these options are handled in gcc is all over the place, but we\n  // don't expect inconsistencies w.r.t. that to matter in practice.\n\n  if (C.getArgs().hasArg(options::OPT_dumpmachine)) {\n    llvm::outs() << C.getDefaultToolChain().getTripleString() << '\\n';\n    return false;\n  }\n\n  if (C.getArgs().hasArg(options::OPT_dumpversion)) {\n    // Since -dumpversion is only implemented for pedantic GCC compatibility, we\n    // return an answer which matches our definition of __VERSION__.\n    llvm::outs() << CLANG_VERSION_STRING << \"\\n\";\n    return false;\n  }\n\n  if (C.getArgs().hasArg(options::OPT__print_diagnostic_categories)) {\n    PrintDiagnosticCategories(llvm::outs());\n    return false;\n  }\n\n  if (C.getArgs().hasArg(options::OPT_help) ||\n      C.getArgs().hasArg(options::OPT__help_hidden)) {\n    PrintHelp(C.getArgs().hasArg(options::OPT__help_hidden));\n    return false;\n  }\n\n  if (C.getArgs().hasArg(options::OPT__version)) {\n    // Follow gcc behavior and use stdout for --version and stderr for -v.\n    PrintVersion(C, llvm::outs());\n    return false;\n  }\n\n  if (C.getArgs().hasArg(options::OPT_v) ||\n      C.getArgs().hasArg(options::OPT__HASH_HASH_HASH) ||\n      C.getArgs().hasArg(options::OPT_print_supported_cpus)) {\n    PrintVersion(C, llvm::errs());\n    SuppressMissingInputWarning = true;\n  }\n\n  if (C.getArgs().hasArg(options::OPT_v)) {\n    if (!SystemConfigDir.empty())\n      llvm::errs() << \"System configuration file directory: \"\n                   << SystemConfigDir << \"\\n\";\n    if (!UserConfigDir.empty())\n      llvm::errs() << \"User configuration file directory: \"\n                   << UserConfigDir << \"\\n\";\n  }\n\n  const ToolChain &TC = C.getDefaultToolChain();\n\n  if (C.getArgs().hasArg(options::OPT_v))\n    TC.printVerboseInfo(llvm::errs());\n\n  if (C.getArgs().hasArg(options::OPT_print_resource_dir)) {\n    llvm::outs() << ResourceDir << '\\n';\n    return false;\n  }\n\n  if (C.getArgs().hasArg(options::OPT_print_search_dirs)) {\n    llvm::outs() << \"programs: =\";\n    bool separator = false;\n    // Print -B and COMPILER_PATH.\n    for (const std::string &Path : PrefixDirs) {\n      if (separator)\n        llvm::outs() << llvm::sys::EnvPathSeparator;\n      llvm::outs() << Path;\n      separator = true;\n    }\n    for (const std::string &Path : TC.getProgramPaths()) {\n      if (separator)\n        llvm::outs() << llvm::sys::EnvPathSeparator;\n      llvm::outs() << Path;\n      separator = true;\n    }\n    llvm::outs() << \"\\n\";\n    llvm::outs() << \"libraries: =\" << ResourceDir;\n\n    StringRef sysroot = C.getSysRoot();\n\n    for (const std::string &Path : TC.getFilePaths()) {\n      // Always print a separator. ResourceDir was the first item shown.\n      llvm::outs() << llvm::sys::EnvPathSeparator;\n      // Interpretation of leading '=' is needed only for NetBSD.\n      if (Path[0] == '=')\n        llvm::outs() << sysroot << Path.substr(1);\n      else\n        llvm::outs() << Path;\n    }\n    llvm::outs() << \"\\n\";\n    return false;\n  }\n\n  // FIXME: The following handlers should use a callback mechanism, we don't\n  // know what the client would like to do.\n  if (Arg *A = C.getArgs().getLastArg(options::OPT_print_file_name_EQ)) {\n    llvm::outs() << GetFilePath(A->getValue(), TC) << \"\\n\";\n    return false;\n  }\n\n  if (Arg *A = C.getArgs().getLastArg(options::OPT_print_prog_name_EQ)) {\n    StringRef ProgName = A->getValue();\n\n    // Null program name cannot have a path.\n    if (! ProgName.empty())\n      llvm::outs() << GetProgramPath(ProgName, TC);\n\n    llvm::outs() << \"\\n\";\n    return false;\n  }\n\n  if (Arg *A = C.getArgs().getLastArg(options::OPT_autocomplete)) {\n    StringRef PassedFlags = A->getValue();\n    HandleAutocompletions(PassedFlags);\n    return false;\n  }\n\n  if (C.getArgs().hasArg(options::OPT_print_libgcc_file_name)) {\n    ToolChain::RuntimeLibType RLT = TC.GetRuntimeLibType(C.getArgs());\n    const llvm::Triple Triple(TC.ComputeEffectiveClangTriple(C.getArgs()));\n    RegisterEffectiveTriple TripleRAII(TC, Triple);\n    switch (RLT) {\n    case ToolChain::RLT_CompilerRT:\n      llvm::outs() << TC.getCompilerRT(C.getArgs(), \"builtins\") << \"\\n\";\n      break;\n    case ToolChain::RLT_Libgcc:\n      llvm::outs() << GetFilePath(\"libgcc.a\", TC) << \"\\n\";\n      break;\n    }\n    return false;\n  }\n\n  if (C.getArgs().hasArg(options::OPT_print_multi_lib)) {\n    for (const Multilib &Multilib : TC.getMultilibs())\n      llvm::outs() << Multilib << \"\\n\";\n    return false;\n  }\n\n  if (C.getArgs().hasArg(options::OPT_print_multi_directory)) {\n    const Multilib &Multilib = TC.getMultilib();\n    if (Multilib.gccSuffix().empty())\n      llvm::outs() << \".\\n\";\n    else {\n      StringRef Suffix(Multilib.gccSuffix());\n      assert(Suffix.front() == '/');\n      llvm::outs() << Suffix.substr(1) << \"\\n\";\n    }\n    return false;\n  }\n\n  if (C.getArgs().hasArg(options::OPT_print_target_triple)) {\n    llvm::outs() << TC.getTripleString() << \"\\n\";\n    return false;\n  }\n\n  if (C.getArgs().hasArg(options::OPT_print_effective_triple)) {\n    const llvm::Triple Triple(TC.ComputeEffectiveClangTriple(C.getArgs()));\n    llvm::outs() << Triple.getTriple() << \"\\n\";\n    return false;\n  }\n\n  if (C.getArgs().hasArg(options::OPT_print_targets)) {\n    llvm::TargetRegistry::printRegisteredTargetsForVersion(llvm::outs());\n    return false;\n  }\n\n  return true;\n}\n\nenum {\n  TopLevelAction = 0,\n  HeadSibAction = 1,\n  OtherSibAction = 2,\n};\n\n// Display an action graph human-readably.  Action A is the \"sink\" node\n// and latest-occuring action. Traversal is in pre-order, visiting the\n// inputs to each action before printing the action itself.\nstatic unsigned PrintActions1(const Compilation &C, Action *A,\n                              std::map<Action *, unsigned> &Ids,\n                              Twine Indent = {}, int Kind = TopLevelAction) {\n  if (Ids.count(A)) // A was already visited.\n    return Ids[A];\n\n  std::string str;\n  llvm::raw_string_ostream os(str);\n\n  auto getSibIndent = [](int K) -> Twine {\n    return (K == HeadSibAction) ? \"   \" : (K == OtherSibAction) ? \"|  \" : \"\";\n  };\n\n  Twine SibIndent = Indent + getSibIndent(Kind);\n  int SibKind = HeadSibAction;\n  os << Action::getClassName(A->getKind()) << \", \";\n  if (InputAction *IA = dyn_cast<InputAction>(A)) {\n    os << \"\\\"\" << IA->getInputArg().getValue() << \"\\\"\";\n  } else if (BindArchAction *BIA = dyn_cast<BindArchAction>(A)) {\n    os << '\"' << BIA->getArchName() << '\"' << \", {\"\n       << PrintActions1(C, *BIA->input_begin(), Ids, SibIndent, SibKind) << \"}\";\n  } else if (OffloadAction *OA = dyn_cast<OffloadAction>(A)) {\n    bool IsFirst = true;\n    OA->doOnEachDependence(\n        [&](Action *A, const ToolChain *TC, const char *BoundArch) {\n          assert(TC && \"Unknown host toolchain\");\n          // E.g. for two CUDA device dependences whose bound arch is sm_20 and\n          // sm_35 this will generate:\n          // \"cuda-device\" (nvptx64-nvidia-cuda:sm_20) {#ID}, \"cuda-device\"\n          // (nvptx64-nvidia-cuda:sm_35) {#ID}\n          if (!IsFirst)\n            os << \", \";\n          os << '\"';\n          os << A->getOffloadingKindPrefix();\n          os << \" (\";\n          os << TC->getTriple().normalize();\n          if (BoundArch)\n            os << \":\" << BoundArch;\n          os << \")\";\n          os << '\"';\n          os << \" {\" << PrintActions1(C, A, Ids, SibIndent, SibKind) << \"}\";\n          IsFirst = false;\n          SibKind = OtherSibAction;\n        });\n  } else {\n    const ActionList *AL = &A->getInputs();\n\n    if (AL->size()) {\n      const char *Prefix = \"{\";\n      for (Action *PreRequisite : *AL) {\n        os << Prefix << PrintActions1(C, PreRequisite, Ids, SibIndent, SibKind);\n        Prefix = \", \";\n        SibKind = OtherSibAction;\n      }\n      os << \"}\";\n    } else\n      os << \"{}\";\n  }\n\n  // Append offload info for all options other than the offloading action\n  // itself (e.g. (cuda-device, sm_20) or (cuda-host)).\n  std::string offload_str;\n  llvm::raw_string_ostream offload_os(offload_str);\n  if (!isa<OffloadAction>(A)) {\n    auto S = A->getOffloadingKindPrefix();\n    if (!S.empty()) {\n      offload_os << \", (\" << S;\n      if (A->getOffloadingArch())\n        offload_os << \", \" << A->getOffloadingArch();\n      offload_os << \")\";\n    }\n  }\n\n  auto getSelfIndent = [](int K) -> Twine {\n    return (K == HeadSibAction) ? \"+- \" : (K == OtherSibAction) ? \"|- \" : \"\";\n  };\n\n  unsigned Id = Ids.size();\n  Ids[A] = Id;\n  llvm::errs() << Indent + getSelfIndent(Kind) << Id << \": \" << os.str() << \", \"\n               << types::getTypeName(A->getType()) << offload_os.str() << \"\\n\";\n\n  return Id;\n}\n\n// Print the action graphs in a compilation C.\n// For example \"clang -c file1.c file2.c\" is composed of two subgraphs.\nvoid Driver::PrintActions(const Compilation &C) const {\n  std::map<Action *, unsigned> Ids;\n  for (Action *A : C.getActions())\n    PrintActions1(C, A, Ids);\n}\n\n/// Check whether the given input tree contains any compilation or\n/// assembly actions.\nstatic bool ContainsCompileOrAssembleAction(const Action *A) {\n  if (isa<CompileJobAction>(A) || isa<BackendJobAction>(A) ||\n      isa<AssembleJobAction>(A))\n    return true;\n\n  for (const Action *Input : A->inputs())\n    if (ContainsCompileOrAssembleAction(Input))\n      return true;\n\n  return false;\n}\n\nvoid Driver::BuildUniversalActions(Compilation &C, const ToolChain &TC,\n                                   const InputList &BAInputs) const {\n  DerivedArgList &Args = C.getArgs();\n  ActionList &Actions = C.getActions();\n  llvm::PrettyStackTraceString CrashInfo(\"Building universal build actions\");\n  // Collect the list of architectures. Duplicates are allowed, but should only\n  // be handled once (in the order seen).\n  llvm::StringSet<> ArchNames;\n  SmallVector<const char *, 4> Archs;\n  for (Arg *A : Args) {\n    if (A->getOption().matches(options::OPT_arch)) {\n      // Validate the option here; we don't save the type here because its\n      // particular spelling may participate in other driver choices.\n      llvm::Triple::ArchType Arch =\n          tools::darwin::getArchTypeForMachOArchName(A->getValue());\n      if (Arch == llvm::Triple::UnknownArch) {\n        Diag(clang::diag::err_drv_invalid_arch_name) << A->getAsString(Args);\n        continue;\n      }\n\n      A->claim();\n      if (ArchNames.insert(A->getValue()).second)\n        Archs.push_back(A->getValue());\n    }\n  }\n\n  // When there is no explicit arch for this platform, make sure we still bind\n  // the architecture (to the default) so that -Xarch_ is handled correctly.\n  if (!Archs.size())\n    Archs.push_back(Args.MakeArgString(TC.getDefaultUniversalArchName()));\n\n  ActionList SingleActions;\n  BuildActions(C, Args, BAInputs, SingleActions);\n\n  // Add in arch bindings for every top level action, as well as lipo and\n  // dsymutil steps if needed.\n  for (Action* Act : SingleActions) {\n    // Make sure we can lipo this kind of output. If not (and it is an actual\n    // output) then we disallow, since we can't create an output file with the\n    // right name without overwriting it. We could remove this oddity by just\n    // changing the output names to include the arch, which would also fix\n    // -save-temps. Compatibility wins for now.\n\n    if (Archs.size() > 1 && !types::canLipoType(Act->getType()))\n      Diag(clang::diag::err_drv_invalid_output_with_multiple_archs)\n          << types::getTypeName(Act->getType());\n\n    ActionList Inputs;\n    for (unsigned i = 0, e = Archs.size(); i != e; ++i)\n      Inputs.push_back(C.MakeAction<BindArchAction>(Act, Archs[i]));\n\n    // Lipo if necessary, we do it this way because we need to set the arch flag\n    // so that -Xarch_ gets overwritten.\n    if (Inputs.size() == 1 || Act->getType() == types::TY_Nothing)\n      Actions.append(Inputs.begin(), Inputs.end());\n    else\n      Actions.push_back(C.MakeAction<LipoJobAction>(Inputs, Act->getType()));\n\n    // Handle debug info queries.\n    Arg *A = Args.getLastArg(options::OPT_g_Group);\n    bool enablesDebugInfo = A && !A->getOption().matches(options::OPT_g0) &&\n                            !A->getOption().matches(options::OPT_gstabs);\n    if ((enablesDebugInfo || willEmitRemarks(Args)) &&\n        ContainsCompileOrAssembleAction(Actions.back())) {\n\n      // Add a 'dsymutil' step if necessary, when debug info is enabled and we\n      // have a compile input. We need to run 'dsymutil' ourselves in such cases\n      // because the debug info will refer to a temporary object file which\n      // will be removed at the end of the compilation process.\n      if (Act->getType() == types::TY_Image) {\n        ActionList Inputs;\n        Inputs.push_back(Actions.back());\n        Actions.pop_back();\n        Actions.push_back(\n            C.MakeAction<DsymutilJobAction>(Inputs, types::TY_dSYM));\n      }\n\n      // Verify the debug info output.\n      if (Args.hasArg(options::OPT_verify_debug_info)) {\n        Action* LastAction = Actions.back();\n        Actions.pop_back();\n        Actions.push_back(C.MakeAction<VerifyDebugInfoJobAction>(\n            LastAction, types::TY_Nothing));\n      }\n    }\n  }\n}\n\nbool Driver::DiagnoseInputExistence(const DerivedArgList &Args, StringRef Value,\n                                    types::ID Ty, bool TypoCorrect) const {\n  if (!getCheckInputsExist())\n    return true;\n\n  // stdin always exists.\n  if (Value == \"-\")\n    return true;\n\n  if (getVFS().exists(Value))\n    return true;\n\n  if (IsCLMode()) {\n    if (!llvm::sys::path::is_absolute(Twine(Value)) &&\n        llvm::sys::Process::FindInEnvPath(\"LIB\", Value, ';'))\n      return true;\n\n    if (Args.hasArg(options::OPT__SLASH_link) && Ty == types::TY_Object) {\n      // Arguments to the /link flag might cause the linker to search for object\n      // and library files in paths we don't know about. Don't error in such\n      // cases.\n      return true;\n    }\n  }\n\n  if (TypoCorrect) {\n    // Check if the filename is a typo for an option flag. OptTable thinks\n    // that all args that are not known options and that start with / are\n    // filenames, but e.g. `/diagnostic:caret` is more likely a typo for\n    // the option `/diagnostics:caret` than a reference to a file in the root\n    // directory.\n    unsigned IncludedFlagsBitmask;\n    unsigned ExcludedFlagsBitmask;\n    std::tie(IncludedFlagsBitmask, ExcludedFlagsBitmask) =\n        getIncludeExcludeOptionFlagMasks(IsCLMode());\n    std::string Nearest;\n    if (getOpts().findNearest(Value, Nearest, IncludedFlagsBitmask,\n                              ExcludedFlagsBitmask) <= 1) {\n      Diag(clang::diag::err_drv_no_such_file_with_suggestion)\n          << Value << Nearest;\n      return false;\n    }\n  }\n\n  Diag(clang::diag::err_drv_no_such_file) << Value;\n  return false;\n}\n\n// Construct a the list of inputs and their types.\nvoid Driver::BuildInputs(const ToolChain &TC, DerivedArgList &Args,\n                         InputList &Inputs) const {\n  const llvm::opt::OptTable &Opts = getOpts();\n  // Track the current user specified (-x) input. We also explicitly track the\n  // argument used to set the type; we only want to claim the type when we\n  // actually use it, so we warn about unused -x arguments.\n  types::ID InputType = types::TY_Nothing;\n  Arg *InputTypeArg = nullptr;\n\n  // The last /TC or /TP option sets the input type to C or C++ globally.\n  if (Arg *TCTP = Args.getLastArgNoClaim(options::OPT__SLASH_TC,\n                                         options::OPT__SLASH_TP)) {\n    InputTypeArg = TCTP;\n    InputType = TCTP->getOption().matches(options::OPT__SLASH_TC)\n                    ? types::TY_C\n                    : types::TY_CXX;\n\n    Arg *Previous = nullptr;\n    bool ShowNote = false;\n    for (Arg *A :\n         Args.filtered(options::OPT__SLASH_TC, options::OPT__SLASH_TP)) {\n      if (Previous) {\n        Diag(clang::diag::warn_drv_overriding_flag_option)\n          << Previous->getSpelling() << A->getSpelling();\n        ShowNote = true;\n      }\n      Previous = A;\n    }\n    if (ShowNote)\n      Diag(clang::diag::note_drv_t_option_is_global);\n\n    // No driver mode exposes -x and /TC or /TP; we don't support mixing them.\n    assert(!Args.hasArg(options::OPT_x) && \"-x and /TC or /TP is not allowed\");\n  }\n\n  for (Arg *A : Args) {\n    if (A->getOption().getKind() == Option::InputClass) {\n      const char *Value = A->getValue();\n      types::ID Ty = types::TY_INVALID;\n\n      // Infer the input type if necessary.\n      if (InputType == types::TY_Nothing) {\n        // If there was an explicit arg for this, claim it.\n        if (InputTypeArg)\n          InputTypeArg->claim();\n\n        // stdin must be handled specially.\n        if (memcmp(Value, \"-\", 2) == 0) {\n          // If running with -E, treat as a C input (this changes the builtin\n          // macros, for example). This may be overridden by -ObjC below.\n          //\n          // Otherwise emit an error but still use a valid type to avoid\n          // spurious errors (e.g., no inputs).\n          if (!Args.hasArgNoClaim(options::OPT_E) && !CCCIsCPP())\n            Diag(IsCLMode() ? clang::diag::err_drv_unknown_stdin_type_clang_cl\n                            : clang::diag::err_drv_unknown_stdin_type);\n          Ty = types::TY_C;\n        } else {\n          // Otherwise lookup by extension.\n          // Fallback is C if invoked as C preprocessor, C++ if invoked with\n          // clang-cl /E, or Object otherwise.\n          // We use a host hook here because Darwin at least has its own\n          // idea of what .s is.\n          if (const char *Ext = strrchr(Value, '.'))\n            Ty = TC.LookupTypeForExtension(Ext + 1);\n\n          if (Ty == types::TY_INVALID) {\n            if (CCCIsCPP())\n              Ty = types::TY_C;\n            else if (IsCLMode() && Args.hasArgNoClaim(options::OPT_E))\n              Ty = types::TY_CXX;\n            else\n              Ty = types::TY_Object;\n          }\n\n          // If the driver is invoked as C++ compiler (like clang++ or c++) it\n          // should autodetect some input files as C++ for g++ compatibility.\n          if (CCCIsCXX()) {\n            types::ID OldTy = Ty;\n            Ty = types::lookupCXXTypeForCType(Ty);\n\n            if (Ty != OldTy)\n              Diag(clang::diag::warn_drv_treating_input_as_cxx)\n                  << getTypeName(OldTy) << getTypeName(Ty);\n          }\n\n          // If running with -fthinlto-index=, extensions that normally identify\n          // native object files actually identify LLVM bitcode files.\n          if (Args.hasArgNoClaim(options::OPT_fthinlto_index_EQ) &&\n              Ty == types::TY_Object)\n            Ty = types::TY_LLVM_BC;\n        }\n\n        // -ObjC and -ObjC++ override the default language, but only for \"source\n        // files\". We just treat everything that isn't a linker input as a\n        // source file.\n        //\n        // FIXME: Clean this up if we move the phase sequence into the type.\n        if (Ty != types::TY_Object) {\n          if (Args.hasArg(options::OPT_ObjC))\n            Ty = types::TY_ObjC;\n          else if (Args.hasArg(options::OPT_ObjCXX))\n            Ty = types::TY_ObjCXX;\n        }\n      } else {\n        assert(InputTypeArg && \"InputType set w/o InputTypeArg\");\n        if (!InputTypeArg->getOption().matches(options::OPT_x)) {\n          // If emulating cl.exe, make sure that /TC and /TP don't affect input\n          // object files.\n          const char *Ext = strrchr(Value, '.');\n          if (Ext && TC.LookupTypeForExtension(Ext + 1) == types::TY_Object)\n            Ty = types::TY_Object;\n        }\n        if (Ty == types::TY_INVALID) {\n          Ty = InputType;\n          InputTypeArg->claim();\n        }\n      }\n\n      if (DiagnoseInputExistence(Args, Value, Ty, /*TypoCorrect=*/true))\n        Inputs.push_back(std::make_pair(Ty, A));\n\n    } else if (A->getOption().matches(options::OPT__SLASH_Tc)) {\n      StringRef Value = A->getValue();\n      if (DiagnoseInputExistence(Args, Value, types::TY_C,\n                                 /*TypoCorrect=*/false)) {\n        Arg *InputArg = MakeInputArg(Args, Opts, A->getValue());\n        Inputs.push_back(std::make_pair(types::TY_C, InputArg));\n      }\n      A->claim();\n    } else if (A->getOption().matches(options::OPT__SLASH_Tp)) {\n      StringRef Value = A->getValue();\n      if (DiagnoseInputExistence(Args, Value, types::TY_CXX,\n                                 /*TypoCorrect=*/false)) {\n        Arg *InputArg = MakeInputArg(Args, Opts, A->getValue());\n        Inputs.push_back(std::make_pair(types::TY_CXX, InputArg));\n      }\n      A->claim();\n    } else if (A->getOption().hasFlag(options::LinkerInput)) {\n      // Just treat as object type, we could make a special type for this if\n      // necessary.\n      Inputs.push_back(std::make_pair(types::TY_Object, A));\n\n    } else if (A->getOption().matches(options::OPT_x)) {\n      InputTypeArg = A;\n      InputType = types::lookupTypeForTypeSpecifier(A->getValue());\n      A->claim();\n\n      // Follow gcc behavior and treat as linker input for invalid -x\n      // options. Its not clear why we shouldn't just revert to unknown; but\n      // this isn't very important, we might as well be bug compatible.\n      if (!InputType) {\n        Diag(clang::diag::err_drv_unknown_language) << A->getValue();\n        InputType = types::TY_Object;\n      }\n    } else if (A->getOption().getID() == options::OPT_U) {\n      assert(A->getNumValues() == 1 && \"The /U option has one value.\");\n      StringRef Val = A->getValue(0);\n      if (Val.find_first_of(\"/\\\\\") != StringRef::npos) {\n        // Warn about e.g. \"/Users/me/myfile.c\".\n        Diag(diag::warn_slash_u_filename) << Val;\n        Diag(diag::note_use_dashdash);\n      }\n    }\n  }\n  if (CCCIsCPP() && Inputs.empty()) {\n    // If called as standalone preprocessor, stdin is processed\n    // if no other input is present.\n    Arg *A = MakeInputArg(Args, Opts, \"-\");\n    Inputs.push_back(std::make_pair(types::TY_C, A));\n  }\n}\n\nnamespace {\n/// Provides a convenient interface for different programming models to generate\n/// the required device actions.\nclass OffloadingActionBuilder final {\n  /// Flag used to trace errors in the builder.\n  bool IsValid = false;\n\n  /// The compilation that is using this builder.\n  Compilation &C;\n\n  /// Map between an input argument and the offload kinds used to process it.\n  std::map<const Arg *, unsigned> InputArgToOffloadKindMap;\n\n  /// Builder interface. It doesn't build anything or keep any state.\n  class DeviceActionBuilder {\n  public:\n    typedef const llvm::SmallVectorImpl<phases::ID> PhasesTy;\n\n    enum ActionBuilderReturnCode {\n      // The builder acted successfully on the current action.\n      ABRT_Success,\n      // The builder didn't have to act on the current action.\n      ABRT_Inactive,\n      // The builder was successful and requested the host action to not be\n      // generated.\n      ABRT_Ignore_Host,\n    };\n\n  protected:\n    /// Compilation associated with this builder.\n    Compilation &C;\n\n    /// Tool chains associated with this builder. The same programming\n    /// model may have associated one or more tool chains.\n    SmallVector<const ToolChain *, 2> ToolChains;\n\n    /// The derived arguments associated with this builder.\n    DerivedArgList &Args;\n\n    /// The inputs associated with this builder.\n    const Driver::InputList &Inputs;\n\n    /// The associated offload kind.\n    Action::OffloadKind AssociatedOffloadKind = Action::OFK_None;\n\n  public:\n    DeviceActionBuilder(Compilation &C, DerivedArgList &Args,\n                        const Driver::InputList &Inputs,\n                        Action::OffloadKind AssociatedOffloadKind)\n        : C(C), Args(Args), Inputs(Inputs),\n          AssociatedOffloadKind(AssociatedOffloadKind) {}\n    virtual ~DeviceActionBuilder() {}\n\n    /// Fill up the array \\a DA with all the device dependences that should be\n    /// added to the provided host action \\a HostAction. By default it is\n    /// inactive.\n    virtual ActionBuilderReturnCode\n    getDeviceDependences(OffloadAction::DeviceDependences &DA,\n                         phases::ID CurPhase, phases::ID FinalPhase,\n                         PhasesTy &Phases) {\n      return ABRT_Inactive;\n    }\n\n    /// Update the state to include the provided host action \\a HostAction as a\n    /// dependency of the current device action. By default it is inactive.\n    virtual ActionBuilderReturnCode addDeviceDepences(Action *HostAction) {\n      return ABRT_Inactive;\n    }\n\n    /// Append top level actions generated by the builder.\n    virtual void appendTopLevelActions(ActionList &AL) {}\n\n    /// Append linker device actions generated by the builder.\n    virtual void appendLinkDeviceActions(ActionList &AL) {}\n\n    /// Append linker host action generated by the builder.\n    virtual Action* appendLinkHostActions(ActionList &AL) { return nullptr; }\n\n    /// Append linker actions generated by the builder.\n    virtual void appendLinkDependences(OffloadAction::DeviceDependences &DA) {}\n\n    /// Initialize the builder. Return true if any initialization errors are\n    /// found.\n    virtual bool initialize() { return false; }\n\n    /// Return true if the builder can use bundling/unbundling.\n    virtual bool canUseBundlerUnbundler() const { return false; }\n\n    /// Return true if this builder is valid. We have a valid builder if we have\n    /// associated device tool chains.\n    bool isValid() { return !ToolChains.empty(); }\n\n    /// Return the associated offload kind.\n    Action::OffloadKind getAssociatedOffloadKind() {\n      return AssociatedOffloadKind;\n    }\n  };\n\n  /// Base class for CUDA/HIP action builder. It injects device code in\n  /// the host backend action.\n  class CudaActionBuilderBase : public DeviceActionBuilder {\n  protected:\n    /// Flags to signal if the user requested host-only or device-only\n    /// compilation.\n    bool CompileHostOnly = false;\n    bool CompileDeviceOnly = false;\n    bool EmitLLVM = false;\n    bool EmitAsm = false;\n\n    /// ID to identify each device compilation. For CUDA it is simply the\n    /// GPU arch string. For HIP it is either the GPU arch string or GPU\n    /// arch string plus feature strings delimited by a plus sign, e.g.\n    /// gfx906+xnack.\n    struct TargetID {\n      /// Target ID string which is persistent throughout the compilation.\n      const char *ID;\n      TargetID(CudaArch Arch) { ID = CudaArchToString(Arch); }\n      TargetID(const char *ID) : ID(ID) {}\n      operator const char *() { return ID; }\n      operator StringRef() { return StringRef(ID); }\n    };\n    /// List of GPU architectures to use in this compilation.\n    SmallVector<TargetID, 4> GpuArchList;\n\n    /// The CUDA actions for the current input.\n    ActionList CudaDeviceActions;\n\n    /// The CUDA fat binary if it was generated for the current input.\n    Action *CudaFatBinary = nullptr;\n\n    /// Flag that is set to true if this builder acted on the current input.\n    bool IsActive = false;\n\n    /// Flag for -fgpu-rdc.\n    bool Relocatable = false;\n\n    /// Default GPU architecture if there's no one specified.\n    CudaArch DefaultCudaArch = CudaArch::UNKNOWN;\n\n    /// Method to generate compilation unit ID specified by option\n    /// '-fuse-cuid='.\n    enum UseCUIDKind { CUID_Hash, CUID_Random, CUID_None, CUID_Invalid };\n    UseCUIDKind UseCUID = CUID_Hash;\n\n    /// Compilation unit ID specified by option '-cuid='.\n    StringRef FixedCUID;\n\n  public:\n    CudaActionBuilderBase(Compilation &C, DerivedArgList &Args,\n                          const Driver::InputList &Inputs,\n                          Action::OffloadKind OFKind)\n        : DeviceActionBuilder(C, Args, Inputs, OFKind) {}\n\n    ActionBuilderReturnCode addDeviceDepences(Action *HostAction) override {\n      // While generating code for CUDA, we only depend on the host input action\n      // to trigger the creation of all the CUDA device actions.\n\n      // If we are dealing with an input action, replicate it for each GPU\n      // architecture. If we are in host-only mode we return 'success' so that\n      // the host uses the CUDA offload kind.\n      if (auto *IA = dyn_cast<InputAction>(HostAction)) {\n        assert(!GpuArchList.empty() &&\n               \"We should have at least one GPU architecture.\");\n\n        // If the host input is not CUDA or HIP, we don't need to bother about\n        // this input.\n        if (!(IA->getType() == types::TY_CUDA ||\n              IA->getType() == types::TY_HIP ||\n              IA->getType() == types::TY_PP_HIP)) {\n          // The builder will ignore this input.\n          IsActive = false;\n          return ABRT_Inactive;\n        }\n\n        // Set the flag to true, so that the builder acts on the current input.\n        IsActive = true;\n\n        if (CompileHostOnly)\n          return ABRT_Success;\n\n        // Replicate inputs for each GPU architecture.\n        auto Ty = IA->getType() == types::TY_HIP ? types::TY_HIP_DEVICE\n                                                 : types::TY_CUDA_DEVICE;\n        std::string CUID = FixedCUID.str();\n        if (CUID.empty()) {\n          if (UseCUID == CUID_Random)\n            CUID = llvm::utohexstr(llvm::sys::Process::GetRandomNumber(),\n                                   /*LowerCase=*/true);\n          else if (UseCUID == CUID_Hash) {\n            llvm::MD5 Hasher;\n            llvm::MD5::MD5Result Hash;\n            SmallString<256> RealPath;\n            llvm::sys::fs::real_path(IA->getInputArg().getValue(), RealPath,\n                                     /*expand_tilde=*/true);\n            Hasher.update(RealPath);\n            for (auto *A : Args) {\n              if (A->getOption().matches(options::OPT_INPUT))\n                continue;\n              Hasher.update(A->getAsString(Args));\n            }\n            Hasher.final(Hash);\n            CUID = llvm::utohexstr(Hash.low(), /*LowerCase=*/true);\n          }\n        }\n        IA->setId(CUID);\n\n        for (unsigned I = 0, E = GpuArchList.size(); I != E; ++I) {\n          CudaDeviceActions.push_back(\n              C.MakeAction<InputAction>(IA->getInputArg(), Ty, IA->getId()));\n        }\n\n        return ABRT_Success;\n      }\n\n      // If this is an unbundling action use it as is for each CUDA toolchain.\n      if (auto *UA = dyn_cast<OffloadUnbundlingJobAction>(HostAction)) {\n\n        // If -fgpu-rdc is disabled, should not unbundle since there is no\n        // device code to link.\n        if (UA->getType() == types::TY_Object && !Relocatable)\n          return ABRT_Inactive;\n\n        CudaDeviceActions.clear();\n        auto *IA = cast<InputAction>(UA->getInputs().back());\n        std::string FileName = IA->getInputArg().getAsString(Args);\n        // Check if the type of the file is the same as the action. Do not\n        // unbundle it if it is not. Do not unbundle .so files, for example,\n        // which are not object files.\n        if (IA->getType() == types::TY_Object &&\n            (!llvm::sys::path::has_extension(FileName) ||\n             types::lookupTypeForExtension(\n                 llvm::sys::path::extension(FileName).drop_front()) !=\n                 types::TY_Object))\n          return ABRT_Inactive;\n\n        for (auto Arch : GpuArchList) {\n          CudaDeviceActions.push_back(UA);\n          UA->registerDependentActionInfo(ToolChains[0], Arch,\n                                          AssociatedOffloadKind);\n        }\n        return ABRT_Success;\n      }\n\n      return IsActive ? ABRT_Success : ABRT_Inactive;\n    }\n\n    void appendTopLevelActions(ActionList &AL) override {\n      // Utility to append actions to the top level list.\n      auto AddTopLevel = [&](Action *A, TargetID TargetID) {\n        OffloadAction::DeviceDependences Dep;\n        Dep.add(*A, *ToolChains.front(), TargetID, AssociatedOffloadKind);\n        AL.push_back(C.MakeAction<OffloadAction>(Dep, A->getType()));\n      };\n\n      // If we have a fat binary, add it to the list.\n      if (CudaFatBinary) {\n        AddTopLevel(CudaFatBinary, CudaArch::UNUSED);\n        CudaDeviceActions.clear();\n        CudaFatBinary = nullptr;\n        return;\n      }\n\n      if (CudaDeviceActions.empty())\n        return;\n\n      // If we have CUDA actions at this point, that's because we have a have\n      // partial compilation, so we should have an action for each GPU\n      // architecture.\n      assert(CudaDeviceActions.size() == GpuArchList.size() &&\n             \"Expecting one action per GPU architecture.\");\n      assert(ToolChains.size() == 1 &&\n             \"Expecting to have a sing CUDA toolchain.\");\n      for (unsigned I = 0, E = GpuArchList.size(); I != E; ++I)\n        AddTopLevel(CudaDeviceActions[I], GpuArchList[I]);\n\n      CudaDeviceActions.clear();\n    }\n\n    /// Get canonicalized offload arch option. \\returns empty StringRef if the\n    /// option is invalid.\n    virtual StringRef getCanonicalOffloadArch(StringRef Arch) = 0;\n\n    virtual llvm::Optional<std::pair<llvm::StringRef, llvm::StringRef>>\n    getConflictOffloadArchCombination(const std::set<StringRef> &GpuArchs) = 0;\n\n    bool initialize() override {\n      assert(AssociatedOffloadKind == Action::OFK_Cuda ||\n             AssociatedOffloadKind == Action::OFK_HIP);\n\n      // We don't need to support CUDA.\n      if (AssociatedOffloadKind == Action::OFK_Cuda &&\n          !C.hasOffloadToolChain<Action::OFK_Cuda>())\n        return false;\n\n      // We don't need to support HIP.\n      if (AssociatedOffloadKind == Action::OFK_HIP &&\n          !C.hasOffloadToolChain<Action::OFK_HIP>())\n        return false;\n\n      Relocatable = Args.hasFlag(options::OPT_fgpu_rdc,\n          options::OPT_fno_gpu_rdc, /*Default=*/false);\n\n      const ToolChain *HostTC = C.getSingleOffloadToolChain<Action::OFK_Host>();\n      assert(HostTC && \"No toolchain for host compilation.\");\n      if (HostTC->getTriple().isNVPTX() ||\n          HostTC->getTriple().getArch() == llvm::Triple::amdgcn) {\n        // We do not support targeting NVPTX/AMDGCN for host compilation. Throw\n        // an error and abort pipeline construction early so we don't trip\n        // asserts that assume device-side compilation.\n        C.getDriver().Diag(diag::err_drv_cuda_host_arch)\n            << HostTC->getTriple().getArchName();\n        return true;\n      }\n\n      ToolChains.push_back(\n          AssociatedOffloadKind == Action::OFK_Cuda\n              ? C.getSingleOffloadToolChain<Action::OFK_Cuda>()\n              : C.getSingleOffloadToolChain<Action::OFK_HIP>());\n\n      Arg *PartialCompilationArg = Args.getLastArg(\n          options::OPT_cuda_host_only, options::OPT_cuda_device_only,\n          options::OPT_cuda_compile_host_device);\n      CompileHostOnly = PartialCompilationArg &&\n                        PartialCompilationArg->getOption().matches(\n                            options::OPT_cuda_host_only);\n      CompileDeviceOnly = PartialCompilationArg &&\n                          PartialCompilationArg->getOption().matches(\n                              options::OPT_cuda_device_only);\n      EmitLLVM = Args.getLastArg(options::OPT_emit_llvm);\n      EmitAsm = Args.getLastArg(options::OPT_S);\n      FixedCUID = Args.getLastArgValue(options::OPT_cuid_EQ);\n      if (Arg *A = Args.getLastArg(options::OPT_fuse_cuid_EQ)) {\n        StringRef UseCUIDStr = A->getValue();\n        UseCUID = llvm::StringSwitch<UseCUIDKind>(UseCUIDStr)\n                      .Case(\"hash\", CUID_Hash)\n                      .Case(\"random\", CUID_Random)\n                      .Case(\"none\", CUID_None)\n                      .Default(CUID_Invalid);\n        if (UseCUID == CUID_Invalid) {\n          C.getDriver().Diag(diag::err_drv_invalid_value)\n              << A->getAsString(Args) << UseCUIDStr;\n          C.setContainsError();\n          return true;\n        }\n      }\n\n      // Collect all cuda_gpu_arch parameters, removing duplicates.\n      std::set<StringRef> GpuArchs;\n      bool Error = false;\n      for (Arg *A : Args) {\n        if (!(A->getOption().matches(options::OPT_offload_arch_EQ) ||\n              A->getOption().matches(options::OPT_no_offload_arch_EQ)))\n          continue;\n        A->claim();\n\n        StringRef ArchStr = A->getValue();\n        if (A->getOption().matches(options::OPT_no_offload_arch_EQ) &&\n            ArchStr == \"all\") {\n          GpuArchs.clear();\n          continue;\n        }\n        ArchStr = getCanonicalOffloadArch(ArchStr);\n        if (ArchStr.empty()) {\n          Error = true;\n        } else if (A->getOption().matches(options::OPT_offload_arch_EQ))\n          GpuArchs.insert(ArchStr);\n        else if (A->getOption().matches(options::OPT_no_offload_arch_EQ))\n          GpuArchs.erase(ArchStr);\n        else\n          llvm_unreachable(\"Unexpected option.\");\n      }\n\n      auto &&ConflictingArchs = getConflictOffloadArchCombination(GpuArchs);\n      if (ConflictingArchs) {\n        C.getDriver().Diag(clang::diag::err_drv_bad_offload_arch_combo)\n            << ConflictingArchs.getValue().first\n            << ConflictingArchs.getValue().second;\n        C.setContainsError();\n        return true;\n      }\n\n      // Collect list of GPUs remaining in the set.\n      for (auto Arch : GpuArchs)\n        GpuArchList.push_back(Arch.data());\n\n      // Default to sm_20 which is the lowest common denominator for\n      // supported GPUs.  sm_20 code should work correctly, if\n      // suboptimally, on all newer GPUs.\n      if (GpuArchList.empty())\n        GpuArchList.push_back(DefaultCudaArch);\n\n      return Error;\n    }\n  };\n\n  /// \\brief CUDA action builder. It injects device code in the host backend\n  /// action.\n  class CudaActionBuilder final : public CudaActionBuilderBase {\n  public:\n    CudaActionBuilder(Compilation &C, DerivedArgList &Args,\n                      const Driver::InputList &Inputs)\n        : CudaActionBuilderBase(C, Args, Inputs, Action::OFK_Cuda) {\n      DefaultCudaArch = CudaArch::SM_20;\n    }\n\n    StringRef getCanonicalOffloadArch(StringRef ArchStr) override {\n      CudaArch Arch = StringToCudaArch(ArchStr);\n      if (Arch == CudaArch::UNKNOWN) {\n        C.getDriver().Diag(clang::diag::err_drv_cuda_bad_gpu_arch) << ArchStr;\n        return StringRef();\n      }\n      return CudaArchToString(Arch);\n    }\n\n    llvm::Optional<std::pair<llvm::StringRef, llvm::StringRef>>\n    getConflictOffloadArchCombination(\n        const std::set<StringRef> &GpuArchs) override {\n      return llvm::None;\n    }\n\n    ActionBuilderReturnCode\n    getDeviceDependences(OffloadAction::DeviceDependences &DA,\n                         phases::ID CurPhase, phases::ID FinalPhase,\n                         PhasesTy &Phases) override {\n      if (!IsActive)\n        return ABRT_Inactive;\n\n      // If we don't have more CUDA actions, we don't have any dependences to\n      // create for the host.\n      if (CudaDeviceActions.empty())\n        return ABRT_Success;\n\n      assert(CudaDeviceActions.size() == GpuArchList.size() &&\n             \"Expecting one action per GPU architecture.\");\n      assert(!CompileHostOnly &&\n             \"Not expecting CUDA actions in host-only compilation.\");\n\n      // If we are generating code for the device or we are in a backend phase,\n      // we attempt to generate the fat binary. We compile each arch to ptx and\n      // assemble to cubin, then feed the cubin *and* the ptx into a device\n      // \"link\" action, which uses fatbinary to combine these cubins into one\n      // fatbin.  The fatbin is then an input to the host action if not in\n      // device-only mode.\n      if (CompileDeviceOnly || CurPhase == phases::Backend) {\n        ActionList DeviceActions;\n        for (unsigned I = 0, E = GpuArchList.size(); I != E; ++I) {\n          // Produce the device action from the current phase up to the assemble\n          // phase.\n          for (auto Ph : Phases) {\n            // Skip the phases that were already dealt with.\n            if (Ph < CurPhase)\n              continue;\n            // We have to be consistent with the host final phase.\n            if (Ph > FinalPhase)\n              break;\n\n            CudaDeviceActions[I] = C.getDriver().ConstructPhaseAction(\n                C, Args, Ph, CudaDeviceActions[I], Action::OFK_Cuda);\n\n            if (Ph == phases::Assemble)\n              break;\n          }\n\n          // If we didn't reach the assemble phase, we can't generate the fat\n          // binary. We don't need to generate the fat binary if we are not in\n          // device-only mode.\n          if (!isa<AssembleJobAction>(CudaDeviceActions[I]) ||\n              CompileDeviceOnly)\n            continue;\n\n          Action *AssembleAction = CudaDeviceActions[I];\n          assert(AssembleAction->getType() == types::TY_Object);\n          assert(AssembleAction->getInputs().size() == 1);\n\n          Action *BackendAction = AssembleAction->getInputs()[0];\n          assert(BackendAction->getType() == types::TY_PP_Asm);\n\n          for (auto &A : {AssembleAction, BackendAction}) {\n            OffloadAction::DeviceDependences DDep;\n            DDep.add(*A, *ToolChains.front(), GpuArchList[I], Action::OFK_Cuda);\n            DeviceActions.push_back(\n                C.MakeAction<OffloadAction>(DDep, A->getType()));\n          }\n        }\n\n        // We generate the fat binary if we have device input actions.\n        if (!DeviceActions.empty()) {\n          CudaFatBinary =\n              C.MakeAction<LinkJobAction>(DeviceActions, types::TY_CUDA_FATBIN);\n\n          if (!CompileDeviceOnly) {\n            DA.add(*CudaFatBinary, *ToolChains.front(), /*BoundArch=*/nullptr,\n                   Action::OFK_Cuda);\n            // Clear the fat binary, it is already a dependence to an host\n            // action.\n            CudaFatBinary = nullptr;\n          }\n\n          // Remove the CUDA actions as they are already connected to an host\n          // action or fat binary.\n          CudaDeviceActions.clear();\n        }\n\n        // We avoid creating host action in device-only mode.\n        return CompileDeviceOnly ? ABRT_Ignore_Host : ABRT_Success;\n      } else if (CurPhase > phases::Backend) {\n        // If we are past the backend phase and still have a device action, we\n        // don't have to do anything as this action is already a device\n        // top-level action.\n        return ABRT_Success;\n      }\n\n      assert(CurPhase < phases::Backend && \"Generating single CUDA \"\n                                           \"instructions should only occur \"\n                                           \"before the backend phase!\");\n\n      // By default, we produce an action for each device arch.\n      for (Action *&A : CudaDeviceActions)\n        A = C.getDriver().ConstructPhaseAction(C, Args, CurPhase, A);\n\n      return ABRT_Success;\n    }\n  };\n  /// \\brief HIP action builder. It injects device code in the host backend\n  /// action.\n  class HIPActionBuilder final : public CudaActionBuilderBase {\n    /// The linker inputs obtained for each device arch.\n    SmallVector<ActionList, 8> DeviceLinkerInputs;\n\n  public:\n    HIPActionBuilder(Compilation &C, DerivedArgList &Args,\n                     const Driver::InputList &Inputs)\n        : CudaActionBuilderBase(C, Args, Inputs, Action::OFK_HIP) {\n      DefaultCudaArch = CudaArch::GFX803;\n    }\n\n    bool canUseBundlerUnbundler() const override { return true; }\n\n    StringRef getCanonicalOffloadArch(StringRef IdStr) override {\n      llvm::StringMap<bool> Features;\n      auto ArchStr =\n          parseTargetID(getHIPOffloadTargetTriple(), IdStr, &Features);\n      if (!ArchStr) {\n        C.getDriver().Diag(clang::diag::err_drv_bad_target_id) << IdStr;\n        C.setContainsError();\n        return StringRef();\n      }\n      auto CanId = getCanonicalTargetID(ArchStr.getValue(), Features);\n      return Args.MakeArgStringRef(CanId);\n    };\n\n    llvm::Optional<std::pair<llvm::StringRef, llvm::StringRef>>\n    getConflictOffloadArchCombination(\n        const std::set<StringRef> &GpuArchs) override {\n      return getConflictTargetIDCombination(GpuArchs);\n    }\n\n    ActionBuilderReturnCode\n    getDeviceDependences(OffloadAction::DeviceDependences &DA,\n                         phases::ID CurPhase, phases::ID FinalPhase,\n                         PhasesTy &Phases) override {\n      // amdgcn does not support linking of object files, therefore we skip\n      // backend and assemble phases to output LLVM IR. Except for generating\n      // non-relocatable device coee, where we generate fat binary for device\n      // code and pass to host in Backend phase.\n      if (CudaDeviceActions.empty())\n        return ABRT_Success;\n\n      assert(((CurPhase == phases::Link && Relocatable) ||\n              CudaDeviceActions.size() == GpuArchList.size()) &&\n             \"Expecting one action per GPU architecture.\");\n      assert(!CompileHostOnly &&\n             \"Not expecting CUDA actions in host-only compilation.\");\n\n      if (!Relocatable && CurPhase == phases::Backend && !EmitLLVM &&\n          !EmitAsm) {\n        // If we are in backend phase, we attempt to generate the fat binary.\n        // We compile each arch to IR and use a link action to generate code\n        // object containing ISA. Then we use a special \"link\" action to create\n        // a fat binary containing all the code objects for different GPU's.\n        // The fat binary is then an input to the host action.\n        for (unsigned I = 0, E = GpuArchList.size(); I != E; ++I) {\n          auto BackendAction = C.getDriver().ConstructPhaseAction(\n              C, Args, phases::Backend, CudaDeviceActions[I],\n              AssociatedOffloadKind);\n          auto AssembleAction = C.getDriver().ConstructPhaseAction(\n              C, Args, phases::Assemble, BackendAction, AssociatedOffloadKind);\n          // Create a link action to link device IR with device library\n          // and generate ISA.\n          ActionList AL;\n          AL.push_back(AssembleAction);\n          CudaDeviceActions[I] =\n              C.MakeAction<LinkJobAction>(AL, types::TY_Image);\n\n          // OffloadingActionBuilder propagates device arch until an offload\n          // action. Since the next action for creating fatbin does\n          // not have device arch, whereas the above link action and its input\n          // have device arch, an offload action is needed to stop the null\n          // device arch of the next action being propagated to the above link\n          // action.\n          OffloadAction::DeviceDependences DDep;\n          DDep.add(*CudaDeviceActions[I], *ToolChains.front(), GpuArchList[I],\n                   AssociatedOffloadKind);\n          CudaDeviceActions[I] = C.MakeAction<OffloadAction>(\n              DDep, CudaDeviceActions[I]->getType());\n        }\n        // Create HIP fat binary with a special \"link\" action.\n        CudaFatBinary =\n            C.MakeAction<LinkJobAction>(CudaDeviceActions,\n                types::TY_HIP_FATBIN);\n\n        if (!CompileDeviceOnly) {\n          DA.add(*CudaFatBinary, *ToolChains.front(), /*BoundArch=*/nullptr,\n                 AssociatedOffloadKind);\n          // Clear the fat binary, it is already a dependence to an host\n          // action.\n          CudaFatBinary = nullptr;\n        }\n\n        // Remove the CUDA actions as they are already connected to an host\n        // action or fat binary.\n        CudaDeviceActions.clear();\n\n        return CompileDeviceOnly ? ABRT_Ignore_Host : ABRT_Success;\n      } else if (CurPhase == phases::Link) {\n        // Save CudaDeviceActions to DeviceLinkerInputs for each GPU subarch.\n        // This happens to each device action originated from each input file.\n        // Later on, device actions in DeviceLinkerInputs are used to create\n        // device link actions in appendLinkDependences and the created device\n        // link actions are passed to the offload action as device dependence.\n        DeviceLinkerInputs.resize(CudaDeviceActions.size());\n        auto LI = DeviceLinkerInputs.begin();\n        for (auto *A : CudaDeviceActions) {\n          LI->push_back(A);\n          ++LI;\n        }\n\n        // We will pass the device action as a host dependence, so we don't\n        // need to do anything else with them.\n        CudaDeviceActions.clear();\n        return ABRT_Success;\n      }\n\n      // By default, we produce an action for each device arch.\n      for (Action *&A : CudaDeviceActions)\n        A = C.getDriver().ConstructPhaseAction(C, Args, CurPhase, A,\n                                               AssociatedOffloadKind);\n\n      return (CompileDeviceOnly && CurPhase == FinalPhase) ? ABRT_Ignore_Host\n                                                           : ABRT_Success;\n    }\n\n    void appendLinkDeviceActions(ActionList &AL) override {\n      if (DeviceLinkerInputs.size() == 0)\n        return;\n\n      assert(DeviceLinkerInputs.size() == GpuArchList.size() &&\n             \"Linker inputs and GPU arch list sizes do not match.\");\n\n      // Append a new link action for each device.\n      unsigned I = 0;\n      for (auto &LI : DeviceLinkerInputs) {\n        // Each entry in DeviceLinkerInputs corresponds to a GPU arch.\n        auto *DeviceLinkAction =\n            C.MakeAction<LinkJobAction>(LI, types::TY_Image);\n        // Linking all inputs for the current GPU arch.\n        // LI contains all the inputs for the linker.\n        OffloadAction::DeviceDependences DeviceLinkDeps;\n        DeviceLinkDeps.add(*DeviceLinkAction, *ToolChains[0],\n            GpuArchList[I], AssociatedOffloadKind);\n        AL.push_back(C.MakeAction<OffloadAction>(DeviceLinkDeps,\n            DeviceLinkAction->getType()));\n        ++I;\n      }\n      DeviceLinkerInputs.clear();\n\n      // Create a host object from all the device images by embedding them\n      // in a fat binary.\n      OffloadAction::DeviceDependences DDeps;\n      auto *TopDeviceLinkAction =\n          C.MakeAction<LinkJobAction>(AL, types::TY_Object);\n      DDeps.add(*TopDeviceLinkAction, *ToolChains[0],\n          nullptr, AssociatedOffloadKind);\n\n      // Offload the host object to the host linker.\n      AL.push_back(C.MakeAction<OffloadAction>(DDeps, TopDeviceLinkAction->getType()));\n    }\n\n    Action* appendLinkHostActions(ActionList &AL) override { return AL.back(); }\n\n    void appendLinkDependences(OffloadAction::DeviceDependences &DA) override {}\n  };\n\n  /// OpenMP action builder. The host bitcode is passed to the device frontend\n  /// and all the device linked images are passed to the host link phase.\n  class OpenMPActionBuilder final : public DeviceActionBuilder {\n    /// The OpenMP actions for the current input.\n    ActionList OpenMPDeviceActions;\n\n    /// The linker inputs obtained for each toolchain.\n    SmallVector<ActionList, 8> DeviceLinkerInputs;\n\n  public:\n    OpenMPActionBuilder(Compilation &C, DerivedArgList &Args,\n                        const Driver::InputList &Inputs)\n        : DeviceActionBuilder(C, Args, Inputs, Action::OFK_OpenMP) {}\n\n    ActionBuilderReturnCode\n    getDeviceDependences(OffloadAction::DeviceDependences &DA,\n                         phases::ID CurPhase, phases::ID FinalPhase,\n                         PhasesTy &Phases) override {\n      if (OpenMPDeviceActions.empty())\n        return ABRT_Inactive;\n\n      // We should always have an action for each input.\n      assert(OpenMPDeviceActions.size() == ToolChains.size() &&\n             \"Number of OpenMP actions and toolchains do not match.\");\n\n      // The host only depends on device action in the linking phase, when all\n      // the device images have to be embedded in the host image.\n      if (CurPhase == phases::Link) {\n        assert(ToolChains.size() == DeviceLinkerInputs.size() &&\n               \"Toolchains and linker inputs sizes do not match.\");\n        auto LI = DeviceLinkerInputs.begin();\n        for (auto *A : OpenMPDeviceActions) {\n          LI->push_back(A);\n          ++LI;\n        }\n\n        // We passed the device action as a host dependence, so we don't need to\n        // do anything else with them.\n        OpenMPDeviceActions.clear();\n        return ABRT_Success;\n      }\n\n      // By default, we produce an action for each device arch.\n      for (Action *&A : OpenMPDeviceActions)\n        A = C.getDriver().ConstructPhaseAction(C, Args, CurPhase, A);\n\n      return ABRT_Success;\n    }\n\n    ActionBuilderReturnCode addDeviceDepences(Action *HostAction) override {\n\n      // If this is an input action replicate it for each OpenMP toolchain.\n      if (auto *IA = dyn_cast<InputAction>(HostAction)) {\n        OpenMPDeviceActions.clear();\n        for (unsigned I = 0; I < ToolChains.size(); ++I)\n          OpenMPDeviceActions.push_back(\n              C.MakeAction<InputAction>(IA->getInputArg(), IA->getType()));\n        return ABRT_Success;\n      }\n\n      // If this is an unbundling action use it as is for each OpenMP toolchain.\n      if (auto *UA = dyn_cast<OffloadUnbundlingJobAction>(HostAction)) {\n        OpenMPDeviceActions.clear();\n        auto *IA = cast<InputAction>(UA->getInputs().back());\n        std::string FileName = IA->getInputArg().getAsString(Args);\n        // Check if the type of the file is the same as the action. Do not\n        // unbundle it if it is not. Do not unbundle .so files, for example,\n        // which are not object files.\n        if (IA->getType() == types::TY_Object &&\n            (!llvm::sys::path::has_extension(FileName) ||\n             types::lookupTypeForExtension(\n                 llvm::sys::path::extension(FileName).drop_front()) !=\n                 types::TY_Object))\n          return ABRT_Inactive;\n        for (unsigned I = 0; I < ToolChains.size(); ++I) {\n          OpenMPDeviceActions.push_back(UA);\n          UA->registerDependentActionInfo(\n              ToolChains[I], /*BoundArch=*/StringRef(), Action::OFK_OpenMP);\n        }\n        return ABRT_Success;\n      }\n\n      // When generating code for OpenMP we use the host compile phase result as\n      // a dependence to the device compile phase so that it can learn what\n      // declarations should be emitted. However, this is not the only use for\n      // the host action, so we prevent it from being collapsed.\n      if (isa<CompileJobAction>(HostAction)) {\n        HostAction->setCannotBeCollapsedWithNextDependentAction();\n        assert(ToolChains.size() == OpenMPDeviceActions.size() &&\n               \"Toolchains and device action sizes do not match.\");\n        OffloadAction::HostDependence HDep(\n            *HostAction, *C.getSingleOffloadToolChain<Action::OFK_Host>(),\n            /*BoundArch=*/nullptr, Action::OFK_OpenMP);\n        auto TC = ToolChains.begin();\n        for (Action *&A : OpenMPDeviceActions) {\n          assert(isa<CompileJobAction>(A));\n          OffloadAction::DeviceDependences DDep;\n          DDep.add(*A, **TC, /*BoundArch=*/nullptr, Action::OFK_OpenMP);\n          A = C.MakeAction<OffloadAction>(HDep, DDep);\n          ++TC;\n        }\n      }\n      return ABRT_Success;\n    }\n\n    void appendTopLevelActions(ActionList &AL) override {\n      if (OpenMPDeviceActions.empty())\n        return;\n\n      // We should always have an action for each input.\n      assert(OpenMPDeviceActions.size() == ToolChains.size() &&\n             \"Number of OpenMP actions and toolchains do not match.\");\n\n      // Append all device actions followed by the proper offload action.\n      auto TI = ToolChains.begin();\n      for (auto *A : OpenMPDeviceActions) {\n        OffloadAction::DeviceDependences Dep;\n        Dep.add(*A, **TI, /*BoundArch=*/nullptr, Action::OFK_OpenMP);\n        AL.push_back(C.MakeAction<OffloadAction>(Dep, A->getType()));\n        ++TI;\n      }\n      // We no longer need the action stored in this builder.\n      OpenMPDeviceActions.clear();\n    }\n\n    void appendLinkDeviceActions(ActionList &AL) override {\n      assert(ToolChains.size() == DeviceLinkerInputs.size() &&\n             \"Toolchains and linker inputs sizes do not match.\");\n\n      // Append a new link action for each device.\n      auto TC = ToolChains.begin();\n      for (auto &LI : DeviceLinkerInputs) {\n        auto *DeviceLinkAction =\n            C.MakeAction<LinkJobAction>(LI, types::TY_Image);\n        OffloadAction::DeviceDependences DeviceLinkDeps;\n        DeviceLinkDeps.add(*DeviceLinkAction, **TC, /*BoundArch=*/nullptr,\n\t\t        Action::OFK_OpenMP);\n        AL.push_back(C.MakeAction<OffloadAction>(DeviceLinkDeps,\n            DeviceLinkAction->getType()));\n        ++TC;\n      }\n      DeviceLinkerInputs.clear();\n    }\n\n    Action* appendLinkHostActions(ActionList &AL) override {\n      // Create wrapper bitcode from the result of device link actions and compile\n      // it to an object which will be added to the host link command.\n      auto *BC = C.MakeAction<OffloadWrapperJobAction>(AL, types::TY_LLVM_BC);\n      auto *ASM = C.MakeAction<BackendJobAction>(BC, types::TY_PP_Asm);\n      return C.MakeAction<AssembleJobAction>(ASM, types::TY_Object);\n    }\n\n    void appendLinkDependences(OffloadAction::DeviceDependences &DA) override {}\n\n    bool initialize() override {\n      // Get the OpenMP toolchains. If we don't get any, the action builder will\n      // know there is nothing to do related to OpenMP offloading.\n      auto OpenMPTCRange = C.getOffloadToolChains<Action::OFK_OpenMP>();\n      for (auto TI = OpenMPTCRange.first, TE = OpenMPTCRange.second; TI != TE;\n           ++TI)\n        ToolChains.push_back(TI->second);\n\n      DeviceLinkerInputs.resize(ToolChains.size());\n      return false;\n    }\n\n    bool canUseBundlerUnbundler() const override {\n      // OpenMP should use bundled files whenever possible.\n      return true;\n    }\n  };\n\n  ///\n  /// TODO: Add the implementation for other specialized builders here.\n  ///\n\n  /// Specialized builders being used by this offloading action builder.\n  SmallVector<DeviceActionBuilder *, 4> SpecializedBuilders;\n\n  /// Flag set to true if all valid builders allow file bundling/unbundling.\n  bool CanUseBundler;\n\npublic:\n  OffloadingActionBuilder(Compilation &C, DerivedArgList &Args,\n                          const Driver::InputList &Inputs)\n      : C(C) {\n    // Create a specialized builder for each device toolchain.\n\n    IsValid = true;\n\n    // Create a specialized builder for CUDA.\n    SpecializedBuilders.push_back(new CudaActionBuilder(C, Args, Inputs));\n\n    // Create a specialized builder for HIP.\n    SpecializedBuilders.push_back(new HIPActionBuilder(C, Args, Inputs));\n\n    // Create a specialized builder for OpenMP.\n    SpecializedBuilders.push_back(new OpenMPActionBuilder(C, Args, Inputs));\n\n    //\n    // TODO: Build other specialized builders here.\n    //\n\n    // Initialize all the builders, keeping track of errors. If all valid\n    // builders agree that we can use bundling, set the flag to true.\n    unsigned ValidBuilders = 0u;\n    unsigned ValidBuildersSupportingBundling = 0u;\n    for (auto *SB : SpecializedBuilders) {\n      IsValid = IsValid && !SB->initialize();\n\n      // Update the counters if the builder is valid.\n      if (SB->isValid()) {\n        ++ValidBuilders;\n        if (SB->canUseBundlerUnbundler())\n          ++ValidBuildersSupportingBundling;\n      }\n    }\n    CanUseBundler =\n        ValidBuilders && ValidBuilders == ValidBuildersSupportingBundling;\n  }\n\n  ~OffloadingActionBuilder() {\n    for (auto *SB : SpecializedBuilders)\n      delete SB;\n  }\n\n  /// Generate an action that adds device dependences (if any) to a host action.\n  /// If no device dependence actions exist, just return the host action \\a\n  /// HostAction. If an error is found or if no builder requires the host action\n  /// to be generated, return nullptr.\n  Action *\n  addDeviceDependencesToHostAction(Action *HostAction, const Arg *InputArg,\n                                   phases::ID CurPhase, phases::ID FinalPhase,\n                                   DeviceActionBuilder::PhasesTy &Phases) {\n    if (!IsValid)\n      return nullptr;\n\n    if (SpecializedBuilders.empty())\n      return HostAction;\n\n    assert(HostAction && \"Invalid host action!\");\n\n    OffloadAction::DeviceDependences DDeps;\n    // Check if all the programming models agree we should not emit the host\n    // action. Also, keep track of the offloading kinds employed.\n    auto &OffloadKind = InputArgToOffloadKindMap[InputArg];\n    unsigned InactiveBuilders = 0u;\n    unsigned IgnoringBuilders = 0u;\n    for (auto *SB : SpecializedBuilders) {\n      if (!SB->isValid()) {\n        ++InactiveBuilders;\n        continue;\n      }\n\n      auto RetCode =\n          SB->getDeviceDependences(DDeps, CurPhase, FinalPhase, Phases);\n\n      // If the builder explicitly says the host action should be ignored,\n      // we need to increment the variable that tracks the builders that request\n      // the host object to be ignored.\n      if (RetCode == DeviceActionBuilder::ABRT_Ignore_Host)\n        ++IgnoringBuilders;\n\n      // Unless the builder was inactive for this action, we have to record the\n      // offload kind because the host will have to use it.\n      if (RetCode != DeviceActionBuilder::ABRT_Inactive)\n        OffloadKind |= SB->getAssociatedOffloadKind();\n    }\n\n    // If all builders agree that the host object should be ignored, just return\n    // nullptr.\n    if (IgnoringBuilders &&\n        SpecializedBuilders.size() == (InactiveBuilders + IgnoringBuilders))\n      return nullptr;\n\n    if (DDeps.getActions().empty())\n      return HostAction;\n\n    // We have dependences we need to bundle together. We use an offload action\n    // for that.\n    OffloadAction::HostDependence HDep(\n        *HostAction, *C.getSingleOffloadToolChain<Action::OFK_Host>(),\n        /*BoundArch=*/nullptr, DDeps);\n    return C.MakeAction<OffloadAction>(HDep, DDeps);\n  }\n\n  /// Generate an action that adds a host dependence to a device action. The\n  /// results will be kept in this action builder. Return true if an error was\n  /// found.\n  bool addHostDependenceToDeviceActions(Action *&HostAction,\n                                        const Arg *InputArg) {\n    if (!IsValid)\n      return true;\n\n    // If we are supporting bundling/unbundling and the current action is an\n    // input action of non-source file, we replace the host action by the\n    // unbundling action. The bundler tool has the logic to detect if an input\n    // is a bundle or not and if the input is not a bundle it assumes it is a\n    // host file. Therefore it is safe to create an unbundling action even if\n    // the input is not a bundle.\n    if (CanUseBundler && isa<InputAction>(HostAction) &&\n        InputArg->getOption().getKind() == llvm::opt::Option::InputClass &&\n        (!types::isSrcFile(HostAction->getType()) ||\n         HostAction->getType() == types::TY_PP_HIP)) {\n      auto UnbundlingHostAction =\n          C.MakeAction<OffloadUnbundlingJobAction>(HostAction);\n      UnbundlingHostAction->registerDependentActionInfo(\n          C.getSingleOffloadToolChain<Action::OFK_Host>(),\n          /*BoundArch=*/StringRef(), Action::OFK_Host);\n      HostAction = UnbundlingHostAction;\n    }\n\n    assert(HostAction && \"Invalid host action!\");\n\n    // Register the offload kinds that are used.\n    auto &OffloadKind = InputArgToOffloadKindMap[InputArg];\n    for (auto *SB : SpecializedBuilders) {\n      if (!SB->isValid())\n        continue;\n\n      auto RetCode = SB->addDeviceDepences(HostAction);\n\n      // Host dependences for device actions are not compatible with that same\n      // action being ignored.\n      assert(RetCode != DeviceActionBuilder::ABRT_Ignore_Host &&\n             \"Host dependence not expected to be ignored.!\");\n\n      // Unless the builder was inactive for this action, we have to record the\n      // offload kind because the host will have to use it.\n      if (RetCode != DeviceActionBuilder::ABRT_Inactive)\n        OffloadKind |= SB->getAssociatedOffloadKind();\n    }\n\n    // Do not use unbundler if the Host does not depend on device action.\n    if (OffloadKind == Action::OFK_None && CanUseBundler)\n      if (auto *UA = dyn_cast<OffloadUnbundlingJobAction>(HostAction))\n        HostAction = UA->getInputs().back();\n\n    return false;\n  }\n\n  /// Add the offloading top level actions to the provided action list. This\n  /// function can replace the host action by a bundling action if the\n  /// programming models allow it.\n  bool appendTopLevelActions(ActionList &AL, Action *HostAction,\n                             const Arg *InputArg) {\n    // Get the device actions to be appended.\n    ActionList OffloadAL;\n    for (auto *SB : SpecializedBuilders) {\n      if (!SB->isValid())\n        continue;\n      SB->appendTopLevelActions(OffloadAL);\n    }\n\n    // If we can use the bundler, replace the host action by the bundling one in\n    // the resulting list. Otherwise, just append the device actions. For\n    // device only compilation, HostAction is a null pointer, therefore only do\n    // this when HostAction is not a null pointer.\n    if (CanUseBundler && HostAction &&\n        HostAction->getType() != types::TY_Nothing && !OffloadAL.empty()) {\n      // Add the host action to the list in order to create the bundling action.\n      OffloadAL.push_back(HostAction);\n\n      // We expect that the host action was just appended to the action list\n      // before this method was called.\n      assert(HostAction == AL.back() && \"Host action not in the list??\");\n      HostAction = C.MakeAction<OffloadBundlingJobAction>(OffloadAL);\n      AL.back() = HostAction;\n    } else\n      AL.append(OffloadAL.begin(), OffloadAL.end());\n\n    // Propagate to the current host action (if any) the offload information\n    // associated with the current input.\n    if (HostAction)\n      HostAction->propagateHostOffloadInfo(InputArgToOffloadKindMap[InputArg],\n                                           /*BoundArch=*/nullptr);\n    return false;\n  }\n\n  Action* makeHostLinkAction() {\n    // Build a list of device linking actions.\n    ActionList DeviceAL;\n    for (DeviceActionBuilder *SB : SpecializedBuilders) {\n      if (!SB->isValid())\n        continue;\n      SB->appendLinkDeviceActions(DeviceAL);\n    }\n\n    if (DeviceAL.empty())\n      return nullptr;\n\n    // Let builders add host linking actions.\n    Action* HA;\n    for (DeviceActionBuilder *SB : SpecializedBuilders) {\n      if (!SB->isValid())\n        continue;\n      HA = SB->appendLinkHostActions(DeviceAL);\n    }\n    return HA;\n  }\n\n  /// Processes the host linker action. This currently consists of replacing it\n  /// with an offload action if there are device link objects and propagate to\n  /// the host action all the offload kinds used in the current compilation. The\n  /// resulting action is returned.\n  Action *processHostLinkAction(Action *HostAction) {\n    // Add all the dependences from the device linking actions.\n    OffloadAction::DeviceDependences DDeps;\n    for (auto *SB : SpecializedBuilders) {\n      if (!SB->isValid())\n        continue;\n\n      SB->appendLinkDependences(DDeps);\n    }\n\n    // Calculate all the offload kinds used in the current compilation.\n    unsigned ActiveOffloadKinds = 0u;\n    for (auto &I : InputArgToOffloadKindMap)\n      ActiveOffloadKinds |= I.second;\n\n    // If we don't have device dependencies, we don't have to create an offload\n    // action.\n    if (DDeps.getActions().empty()) {\n      // Propagate all the active kinds to host action. Given that it is a link\n      // action it is assumed to depend on all actions generated so far.\n      HostAction->propagateHostOffloadInfo(ActiveOffloadKinds,\n                                           /*BoundArch=*/nullptr);\n      return HostAction;\n    }\n\n    // Create the offload action with all dependences. When an offload action\n    // is created the kinds are propagated to the host action, so we don't have\n    // to do that explicitly here.\n    OffloadAction::HostDependence HDep(\n        *HostAction, *C.getSingleOffloadToolChain<Action::OFK_Host>(),\n        /*BoundArch*/ nullptr, ActiveOffloadKinds);\n    return C.MakeAction<OffloadAction>(HDep, DDeps);\n  }\n};\n} // anonymous namespace.\n\nvoid Driver::handleArguments(Compilation &C, DerivedArgList &Args,\n                             const InputList &Inputs,\n                             ActionList &Actions) const {\n\n  // Ignore /Yc/Yu if both /Yc and /Yu passed but with different filenames.\n  Arg *YcArg = Args.getLastArg(options::OPT__SLASH_Yc);\n  Arg *YuArg = Args.getLastArg(options::OPT__SLASH_Yu);\n  if (YcArg && YuArg && strcmp(YcArg->getValue(), YuArg->getValue()) != 0) {\n    Diag(clang::diag::warn_drv_ycyu_different_arg_clang_cl);\n    Args.eraseArg(options::OPT__SLASH_Yc);\n    Args.eraseArg(options::OPT__SLASH_Yu);\n    YcArg = YuArg = nullptr;\n  }\n  if (YcArg && Inputs.size() > 1) {\n    Diag(clang::diag::warn_drv_yc_multiple_inputs_clang_cl);\n    Args.eraseArg(options::OPT__SLASH_Yc);\n    YcArg = nullptr;\n  }\n\n  Arg *FinalPhaseArg;\n  phases::ID FinalPhase = getFinalPhase(Args, &FinalPhaseArg);\n\n  if (FinalPhase == phases::Link) {\n    if (Args.hasArg(options::OPT_emit_llvm))\n      Diag(clang::diag::err_drv_emit_llvm_link);\n    if (IsCLMode() && LTOMode != LTOK_None &&\n        !Args.getLastArgValue(options::OPT_fuse_ld_EQ).equals_lower(\"lld\"))\n      Diag(clang::diag::err_drv_lto_without_lld);\n  }\n\n  if (FinalPhase == phases::Preprocess || Args.hasArg(options::OPT__SLASH_Y_)) {\n    // If only preprocessing or /Y- is used, all pch handling is disabled.\n    // Rather than check for it everywhere, just remove clang-cl pch-related\n    // flags here.\n    Args.eraseArg(options::OPT__SLASH_Fp);\n    Args.eraseArg(options::OPT__SLASH_Yc);\n    Args.eraseArg(options::OPT__SLASH_Yu);\n    YcArg = YuArg = nullptr;\n  }\n\n  unsigned LastPLSize = 0;\n  for (auto &I : Inputs) {\n    types::ID InputType = I.first;\n    const Arg *InputArg = I.second;\n\n    auto PL = types::getCompilationPhases(InputType);\n    LastPLSize = PL.size();\n\n    // If the first step comes after the final phase we are doing as part of\n    // this compilation, warn the user about it.\n    phases::ID InitialPhase = PL[0];\n    if (InitialPhase > FinalPhase) {\n      if (InputArg->isClaimed())\n        continue;\n\n      // Claim here to avoid the more general unused warning.\n      InputArg->claim();\n\n      // Suppress all unused style warnings with -Qunused-arguments\n      if (Args.hasArg(options::OPT_Qunused_arguments))\n        continue;\n\n      // Special case when final phase determined by binary name, rather than\n      // by a command-line argument with a corresponding Arg.\n      if (CCCIsCPP())\n        Diag(clang::diag::warn_drv_input_file_unused_by_cpp)\n            << InputArg->getAsString(Args) << getPhaseName(InitialPhase);\n      // Special case '-E' warning on a previously preprocessed file to make\n      // more sense.\n      else if (InitialPhase == phases::Compile &&\n               (Args.getLastArg(options::OPT__SLASH_EP,\n                                options::OPT__SLASH_P) ||\n                Args.getLastArg(options::OPT_E) ||\n                Args.getLastArg(options::OPT_M, options::OPT_MM)) &&\n               getPreprocessedType(InputType) == types::TY_INVALID)\n        Diag(clang::diag::warn_drv_preprocessed_input_file_unused)\n            << InputArg->getAsString(Args) << !!FinalPhaseArg\n            << (FinalPhaseArg ? FinalPhaseArg->getOption().getName() : \"\");\n      else\n        Diag(clang::diag::warn_drv_input_file_unused)\n            << InputArg->getAsString(Args) << getPhaseName(InitialPhase)\n            << !!FinalPhaseArg\n            << (FinalPhaseArg ? FinalPhaseArg->getOption().getName() : \"\");\n      continue;\n    }\n\n    if (YcArg) {\n      // Add a separate precompile phase for the compile phase.\n      if (FinalPhase >= phases::Compile) {\n        const types::ID HeaderType = lookupHeaderTypeForSourceType(InputType);\n        // Build the pipeline for the pch file.\n        Action *ClangClPch = C.MakeAction<InputAction>(*InputArg, HeaderType);\n        for (phases::ID Phase : types::getCompilationPhases(HeaderType))\n          ClangClPch = ConstructPhaseAction(C, Args, Phase, ClangClPch);\n        assert(ClangClPch);\n        Actions.push_back(ClangClPch);\n        // The driver currently exits after the first failed command.  This\n        // relies on that behavior, to make sure if the pch generation fails,\n        // the main compilation won't run.\n        // FIXME: If the main compilation fails, the PCH generation should\n        // probably not be considered successful either.\n      }\n    }\n  }\n\n  // If we are linking, claim any options which are obviously only used for\n  // compilation.\n  // FIXME: Understand why the last Phase List length is used here.\n  if (FinalPhase == phases::Link && LastPLSize == 1) {\n    Args.ClaimAllArgs(options::OPT_CompileOnly_Group);\n    Args.ClaimAllArgs(options::OPT_cl_compile_Group);\n  }\n}\n\nvoid Driver::BuildActions(Compilation &C, DerivedArgList &Args,\n                          const InputList &Inputs, ActionList &Actions) const {\n  llvm::PrettyStackTraceString CrashInfo(\"Building compilation actions\");\n\n  if (!SuppressMissingInputWarning && Inputs.empty()) {\n    Diag(clang::diag::err_drv_no_input_files);\n    return;\n  }\n\n  // Reject -Z* at the top level, these options should never have been exposed\n  // by gcc.\n  if (Arg *A = Args.getLastArg(options::OPT_Z_Joined))\n    Diag(clang::diag::err_drv_use_of_Z_option) << A->getAsString(Args);\n\n  // Diagnose misuse of /Fo.\n  if (Arg *A = Args.getLastArg(options::OPT__SLASH_Fo)) {\n    StringRef V = A->getValue();\n    if (Inputs.size() > 1 && !V.empty() &&\n        !llvm::sys::path::is_separator(V.back())) {\n      // Check whether /Fo tries to name an output file for multiple inputs.\n      Diag(clang::diag::err_drv_out_file_argument_with_multiple_sources)\n          << A->getSpelling() << V;\n      Args.eraseArg(options::OPT__SLASH_Fo);\n    }\n  }\n\n  // Diagnose misuse of /Fa.\n  if (Arg *A = Args.getLastArg(options::OPT__SLASH_Fa)) {\n    StringRef V = A->getValue();\n    if (Inputs.size() > 1 && !V.empty() &&\n        !llvm::sys::path::is_separator(V.back())) {\n      // Check whether /Fa tries to name an asm file for multiple inputs.\n      Diag(clang::diag::err_drv_out_file_argument_with_multiple_sources)\n          << A->getSpelling() << V;\n      Args.eraseArg(options::OPT__SLASH_Fa);\n    }\n  }\n\n  // Diagnose misuse of /o.\n  if (Arg *A = Args.getLastArg(options::OPT__SLASH_o)) {\n    if (A->getValue()[0] == '\\0') {\n      // It has to have a value.\n      Diag(clang::diag::err_drv_missing_argument) << A->getSpelling() << 1;\n      Args.eraseArg(options::OPT__SLASH_o);\n    }\n  }\n\n  handleArguments(C, Args, Inputs, Actions);\n\n  // Builder to be used to build offloading actions.\n  OffloadingActionBuilder OffloadBuilder(C, Args, Inputs);\n\n  // Construct the actions to perform.\n  HeaderModulePrecompileJobAction *HeaderModuleAction = nullptr;\n  ActionList LinkerInputs;\n  ActionList MergerInputs;\n\n  for (auto &I : Inputs) {\n    types::ID InputType = I.first;\n    const Arg *InputArg = I.second;\n\n    auto PL = types::getCompilationPhases(*this, Args, InputType);\n    if (PL.empty())\n      continue;\n\n    auto FullPL = types::getCompilationPhases(InputType);\n\n    // Build the pipeline for this file.\n    Action *Current = C.MakeAction<InputAction>(*InputArg, InputType);\n\n    // Use the current host action in any of the offloading actions, if\n    // required.\n    if (OffloadBuilder.addHostDependenceToDeviceActions(Current, InputArg))\n      break;\n\n    for (phases::ID Phase : PL) {\n\n      // Add any offload action the host action depends on.\n      Current = OffloadBuilder.addDeviceDependencesToHostAction(\n          Current, InputArg, Phase, PL.back(), FullPL);\n      if (!Current)\n        break;\n\n      // Queue linker inputs.\n      if (Phase == phases::Link) {\n        assert(Phase == PL.back() && \"linking must be final compilation step.\");\n        LinkerInputs.push_back(Current);\n        Current = nullptr;\n        break;\n      }\n\n      // TODO: Consider removing this because the merged may not end up being\n      // the final Phase in the pipeline. Perhaps the merged could just merge\n      // and then pass an artifact of some sort to the Link Phase.\n      // Queue merger inputs.\n      if (Phase == phases::IfsMerge) {\n        assert(Phase == PL.back() && \"merging must be final compilation step.\");\n        MergerInputs.push_back(Current);\n        Current = nullptr;\n        break;\n      }\n\n      // Each precompiled header file after a module file action is a module\n      // header of that same module file, rather than being compiled to a\n      // separate PCH.\n      if (Phase == phases::Precompile && HeaderModuleAction &&\n          getPrecompiledType(InputType) == types::TY_PCH) {\n        HeaderModuleAction->addModuleHeaderInput(Current);\n        Current = nullptr;\n        break;\n      }\n\n      // FIXME: Should we include any prior module file outputs as inputs of\n      // later actions in the same command line?\n\n      // Otherwise construct the appropriate action.\n      Action *NewCurrent = ConstructPhaseAction(C, Args, Phase, Current);\n\n      // We didn't create a new action, so we will just move to the next phase.\n      if (NewCurrent == Current)\n        continue;\n\n      if (auto *HMA = dyn_cast<HeaderModulePrecompileJobAction>(NewCurrent))\n        HeaderModuleAction = HMA;\n\n      Current = NewCurrent;\n\n      // Use the current host action in any of the offloading actions, if\n      // required.\n      if (OffloadBuilder.addHostDependenceToDeviceActions(Current, InputArg))\n        break;\n\n      if (Current->getType() == types::TY_Nothing)\n        break;\n    }\n\n    // If we ended with something, add to the output list.\n    if (Current)\n      Actions.push_back(Current);\n\n    // Add any top level actions generated for offloading.\n    OffloadBuilder.appendTopLevelActions(Actions, Current, InputArg);\n  }\n\n  // Add a link action if necessary.\n  if (!LinkerInputs.empty()) {\n    if (Action *Wrapper = OffloadBuilder.makeHostLinkAction())\n      LinkerInputs.push_back(Wrapper);\n    Action *LA;\n    // Check if this Linker Job should emit a static library.\n    if (ShouldEmitStaticLibrary(Args)) {\n      LA = C.MakeAction<StaticLibJobAction>(LinkerInputs, types::TY_Image);\n    } else {\n      LA = C.MakeAction<LinkJobAction>(LinkerInputs, types::TY_Image);\n    }\n    LA = OffloadBuilder.processHostLinkAction(LA);\n    Actions.push_back(LA);\n  }\n\n  // Add an interface stubs merge action if necessary.\n  if (!MergerInputs.empty())\n    Actions.push_back(\n        C.MakeAction<IfsMergeJobAction>(MergerInputs, types::TY_Image));\n\n  if (Args.hasArg(options::OPT_emit_interface_stubs)) {\n    auto PhaseList = types::getCompilationPhases(\n        types::TY_IFS_CPP,\n        Args.hasArg(options::OPT_c) ? phases::Compile : phases::LastPhase);\n\n    ActionList MergerInputs;\n\n    for (auto &I : Inputs) {\n      types::ID InputType = I.first;\n      const Arg *InputArg = I.second;\n\n      // Currently clang and the llvm assembler do not support generating symbol\n      // stubs from assembly, so we skip the input on asm files. For ifs files\n      // we rely on the normal pipeline setup in the pipeline setup code above.\n      if (InputType == types::TY_IFS || InputType == types::TY_PP_Asm ||\n          InputType == types::TY_Asm)\n        continue;\n\n      Action *Current = C.MakeAction<InputAction>(*InputArg, InputType);\n\n      for (auto Phase : PhaseList) {\n        switch (Phase) {\n        default:\n          llvm_unreachable(\n              \"IFS Pipeline can only consist of Compile followed by IfsMerge.\");\n        case phases::Compile: {\n          // Only IfsMerge (llvm-ifs) can handle .o files by looking for ifs\n          // files where the .o file is located. The compile action can not\n          // handle this.\n          if (InputType == types::TY_Object)\n            break;\n\n          Current = C.MakeAction<CompileJobAction>(Current, types::TY_IFS_CPP);\n          break;\n        }\n        case phases::IfsMerge: {\n          assert(Phase == PhaseList.back() &&\n                 \"merging must be final compilation step.\");\n          MergerInputs.push_back(Current);\n          Current = nullptr;\n          break;\n        }\n        }\n      }\n\n      // If we ended with something, add to the output list.\n      if (Current)\n        Actions.push_back(Current);\n    }\n\n    // Add an interface stubs merge action if necessary.\n    if (!MergerInputs.empty())\n      Actions.push_back(\n          C.MakeAction<IfsMergeJobAction>(MergerInputs, types::TY_Image));\n  }\n\n  // If --print-supported-cpus, -mcpu=? or -mtune=? is specified, build a custom\n  // Compile phase that prints out supported cpu models and quits.\n  if (Arg *A = Args.getLastArg(options::OPT_print_supported_cpus)) {\n    // Use the -mcpu=? flag as the dummy input to cc1.\n    Actions.clear();\n    Action *InputAc = C.MakeAction<InputAction>(*A, types::TY_C);\n    Actions.push_back(\n        C.MakeAction<PrecompileJobAction>(InputAc, types::TY_Nothing));\n    for (auto &I : Inputs)\n      I.second->claim();\n  }\n\n  // Claim ignored clang-cl options.\n  Args.ClaimAllArgs(options::OPT_cl_ignored_Group);\n\n  // Claim --cuda-host-only and --cuda-compile-host-device, which may be passed\n  // to non-CUDA compilations and should not trigger warnings there.\n  Args.ClaimAllArgs(options::OPT_cuda_host_only);\n  Args.ClaimAllArgs(options::OPT_cuda_compile_host_device);\n}\n\nAction *Driver::ConstructPhaseAction(\n    Compilation &C, const ArgList &Args, phases::ID Phase, Action *Input,\n    Action::OffloadKind TargetDeviceOffloadKind) const {\n  llvm::PrettyStackTraceString CrashInfo(\"Constructing phase actions\");\n\n  // Some types skip the assembler phase (e.g., llvm-bc), but we can't\n  // encode this in the steps because the intermediate type depends on\n  // arguments. Just special case here.\n  if (Phase == phases::Assemble && Input->getType() != types::TY_PP_Asm)\n    return Input;\n\n  // Build the appropriate action.\n  switch (Phase) {\n  case phases::Link:\n    llvm_unreachable(\"link action invalid here.\");\n  case phases::IfsMerge:\n    llvm_unreachable(\"ifsmerge action invalid here.\");\n  case phases::Preprocess: {\n    types::ID OutputTy;\n    // -M and -MM specify the dependency file name by altering the output type,\n    // -if -MD and -MMD are not specified.\n    if (Args.hasArg(options::OPT_M, options::OPT_MM) &&\n        !Args.hasArg(options::OPT_MD, options::OPT_MMD)) {\n      OutputTy = types::TY_Dependencies;\n    } else {\n      OutputTy = Input->getType();\n      if (!Args.hasFlag(options::OPT_frewrite_includes,\n                        options::OPT_fno_rewrite_includes, false) &&\n          !Args.hasFlag(options::OPT_frewrite_imports,\n                        options::OPT_fno_rewrite_imports, false) &&\n          !CCGenDiagnostics)\n        OutputTy = types::getPreprocessedType(OutputTy);\n      assert(OutputTy != types::TY_INVALID &&\n             \"Cannot preprocess this input type!\");\n    }\n    return C.MakeAction<PreprocessJobAction>(Input, OutputTy);\n  }\n  case phases::Precompile: {\n    types::ID OutputTy = getPrecompiledType(Input->getType());\n    assert(OutputTy != types::TY_INVALID &&\n           \"Cannot precompile this input type!\");\n\n    // If we're given a module name, precompile header file inputs as a\n    // module, not as a precompiled header.\n    const char *ModName = nullptr;\n    if (OutputTy == types::TY_PCH) {\n      if (Arg *A = Args.getLastArg(options::OPT_fmodule_name_EQ))\n        ModName = A->getValue();\n      if (ModName)\n        OutputTy = types::TY_ModuleFile;\n    }\n\n    if (Args.hasArg(options::OPT_fsyntax_only)) {\n      // Syntax checks should not emit a PCH file\n      OutputTy = types::TY_Nothing;\n    }\n\n    if (ModName)\n      return C.MakeAction<HeaderModulePrecompileJobAction>(Input, OutputTy,\n                                                           ModName);\n    return C.MakeAction<PrecompileJobAction>(Input, OutputTy);\n  }\n  case phases::Compile: {\n    if (Args.hasArg(options::OPT_fsyntax_only))\n      return C.MakeAction<CompileJobAction>(Input, types::TY_Nothing);\n    if (Args.hasArg(options::OPT_rewrite_objc))\n      return C.MakeAction<CompileJobAction>(Input, types::TY_RewrittenObjC);\n    if (Args.hasArg(options::OPT_rewrite_legacy_objc))\n      return C.MakeAction<CompileJobAction>(Input,\n                                            types::TY_RewrittenLegacyObjC);\n    if (Args.hasArg(options::OPT__analyze))\n      return C.MakeAction<AnalyzeJobAction>(Input, types::TY_Plist);\n    if (Args.hasArg(options::OPT__migrate))\n      return C.MakeAction<MigrateJobAction>(Input, types::TY_Remap);\n    if (Args.hasArg(options::OPT_emit_ast))\n      return C.MakeAction<CompileJobAction>(Input, types::TY_AST);\n    if (Args.hasArg(options::OPT_module_file_info))\n      return C.MakeAction<CompileJobAction>(Input, types::TY_ModuleFile);\n    if (Args.hasArg(options::OPT_verify_pch))\n      return C.MakeAction<VerifyPCHJobAction>(Input, types::TY_Nothing);\n    return C.MakeAction<CompileJobAction>(Input, types::TY_LLVM_BC);\n  }\n  case phases::Backend: {\n    if (isUsingLTO() && TargetDeviceOffloadKind == Action::OFK_None) {\n      types::ID Output =\n          Args.hasArg(options::OPT_S) ? types::TY_LTO_IR : types::TY_LTO_BC;\n      return C.MakeAction<BackendJobAction>(Input, Output);\n    }\n    if (Args.hasArg(options::OPT_emit_llvm) ||\n        (TargetDeviceOffloadKind == Action::OFK_HIP &&\n         Args.hasFlag(options::OPT_fgpu_rdc, options::OPT_fno_gpu_rdc,\n                      false))) {\n      types::ID Output =\n          Args.hasArg(options::OPT_S) ? types::TY_LLVM_IR : types::TY_LLVM_BC;\n      return C.MakeAction<BackendJobAction>(Input, Output);\n    }\n    return C.MakeAction<BackendJobAction>(Input, types::TY_PP_Asm);\n  }\n  case phases::Assemble:\n    return C.MakeAction<AssembleJobAction>(std::move(Input), types::TY_Object);\n  }\n\n  llvm_unreachable(\"invalid phase in ConstructPhaseAction\");\n}\n\nvoid Driver::BuildJobs(Compilation &C) const {\n  llvm::PrettyStackTraceString CrashInfo(\"Building compilation jobs\");\n\n  Arg *FinalOutput = C.getArgs().getLastArg(options::OPT_o);\n\n  // It is an error to provide a -o option if we are making multiple output\n  // files. There are exceptions:\n  //\n  // IfsMergeJob: when generating interface stubs enabled we want to be able to\n  // generate the stub file at the same time that we generate the real\n  // library/a.out. So when a .o, .so, etc are the output, with clang interface\n  // stubs there will also be a .ifs and .ifso at the same location.\n  //\n  // CompileJob of type TY_IFS_CPP: when generating interface stubs is enabled\n  // and -c is passed, we still want to be able to generate a .ifs file while\n  // we are also generating .o files. So we allow more than one output file in\n  // this case as well.\n  //\n  if (FinalOutput) {\n    unsigned NumOutputs = 0;\n    unsigned NumIfsOutputs = 0;\n    for (const Action *A : C.getActions())\n      if (A->getType() != types::TY_Nothing &&\n          !(A->getKind() == Action::IfsMergeJobClass ||\n            (A->getType() == clang::driver::types::TY_IFS_CPP &&\n             A->getKind() == clang::driver::Action::CompileJobClass &&\n             0 == NumIfsOutputs++) ||\n            (A->getKind() == Action::BindArchClass && A->getInputs().size() &&\n             A->getInputs().front()->getKind() == Action::IfsMergeJobClass)))\n        ++NumOutputs;\n\n    if (NumOutputs > 1) {\n      Diag(clang::diag::err_drv_output_argument_with_multiple_files);\n      FinalOutput = nullptr;\n    }\n  }\n\n  const llvm::Triple &RawTriple = C.getDefaultToolChain().getTriple();\n  if (RawTriple.isOSAIX())\n    if (Arg *A = C.getArgs().getLastArg(options::OPT_G))\n      Diag(diag::err_drv_unsupported_opt_for_target)\n          << A->getSpelling() << RawTriple.str();\n\n  // Collect the list of architectures.\n  llvm::StringSet<> ArchNames;\n  if (RawTriple.isOSBinFormatMachO())\n    for (const Arg *A : C.getArgs())\n      if (A->getOption().matches(options::OPT_arch))\n        ArchNames.insert(A->getValue());\n\n  // Set of (Action, canonical ToolChain triple) pairs we've built jobs for.\n  std::map<std::pair<const Action *, std::string>, InputInfo> CachedResults;\n  for (Action *A : C.getActions()) {\n    // If we are linking an image for multiple archs then the linker wants\n    // -arch_multiple and -final_output <final image name>. Unfortunately, this\n    // doesn't fit in cleanly because we have to pass this information down.\n    //\n    // FIXME: This is a hack; find a cleaner way to integrate this into the\n    // process.\n    const char *LinkingOutput = nullptr;\n    if (isa<LipoJobAction>(A)) {\n      if (FinalOutput)\n        LinkingOutput = FinalOutput->getValue();\n      else\n        LinkingOutput = getDefaultImageName();\n    }\n\n    BuildJobsForAction(C, A, &C.getDefaultToolChain(),\n                       /*BoundArch*/ StringRef(),\n                       /*AtTopLevel*/ true,\n                       /*MultipleArchs*/ ArchNames.size() > 1,\n                       /*LinkingOutput*/ LinkingOutput, CachedResults,\n                       /*TargetDeviceOffloadKind*/ Action::OFK_None);\n  }\n\n  StringRef StatReportFile;\n  bool PrintProcessStat = false;\n  if (const Arg *A = C.getArgs().getLastArg(options::OPT_fproc_stat_report_EQ))\n    StatReportFile = A->getValue();\n  if (C.getArgs().hasArg(options::OPT_fproc_stat_report))\n    PrintProcessStat = true;\n\n  // If we have more than one job, then disable integrated-cc1 for now. Do this\n  // also when we need to report process execution statistics.\n  if (C.getJobs().size() > 1 || !StatReportFile.empty() || PrintProcessStat)\n    for (auto &J : C.getJobs())\n      J.InProcess = false;\n\n  if (!StatReportFile.empty() || PrintProcessStat) {\n    C.setPostCallback([=](const Command &Cmd, int Res) {\n      Optional<llvm::sys::ProcessStatistics> ProcStat =\n          Cmd.getProcessStatistics();\n      if (!ProcStat)\n        return;\n      if (PrintProcessStat) {\n        using namespace llvm;\n        // Human readable output.\n        outs() << sys::path::filename(Cmd.getExecutable()) << \": \"\n               << \"output=\";\n        if (Cmd.getOutputFilenames().empty())\n          outs() << \"\\\"\\\"\";\n        else\n          outs() << Cmd.getOutputFilenames().front();\n        outs() << \", total=\"\n               << format(\"%.3f\", ProcStat->TotalTime.count() / 1000.) << \" ms\"\n               << \", user=\"\n               << format(\"%.3f\", ProcStat->UserTime.count() / 1000.) << \" ms\"\n               << \", mem=\" << ProcStat->PeakMemory << \" Kb\\n\";\n      }\n      if (!StatReportFile.empty()) {\n        // CSV format.\n        std::string Buffer;\n        llvm::raw_string_ostream Out(Buffer);\n        llvm::sys::printArg(Out, llvm::sys::path::filename(Cmd.getExecutable()),\n                            /*Quote*/ true);\n        Out << ',';\n        if (Cmd.getOutputFilenames().empty())\n          Out << \"\\\"\\\"\";\n        else\n          llvm::sys::printArg(Out, Cmd.getOutputFilenames().front(), true);\n        Out << ',' << ProcStat->TotalTime.count() << ','\n            << ProcStat->UserTime.count() << ',' << ProcStat->PeakMemory\n            << '\\n';\n        Out.flush();\n        std::error_code EC;\n        llvm::raw_fd_ostream OS(StatReportFile, EC, llvm::sys::fs::OF_Append);\n        if (EC)\n          return;\n        auto L = OS.lock();\n        if (!L) {\n          llvm::errs() << \"ERROR: Cannot lock file \" << StatReportFile << \": \"\n                       << toString(L.takeError()) << \"\\n\";\n          return;\n        }\n        OS << Buffer;\n      }\n    });\n  }\n\n  // If the user passed -Qunused-arguments or there were errors, don't warn\n  // about any unused arguments.\n  if (Diags.hasErrorOccurred() ||\n      C.getArgs().hasArg(options::OPT_Qunused_arguments))\n    return;\n\n  // Claim -### here.\n  (void)C.getArgs().hasArg(options::OPT__HASH_HASH_HASH);\n\n  // Claim --driver-mode, --rsp-quoting, it was handled earlier.\n  (void)C.getArgs().hasArg(options::OPT_driver_mode);\n  (void)C.getArgs().hasArg(options::OPT_rsp_quoting);\n\n  for (Arg *A : C.getArgs()) {\n    // FIXME: It would be nice to be able to send the argument to the\n    // DiagnosticsEngine, so that extra values, position, and so on could be\n    // printed.\n    if (!A->isClaimed()) {\n      if (A->getOption().hasFlag(options::NoArgumentUnused))\n        continue;\n\n      // Suppress the warning automatically if this is just a flag, and it is an\n      // instance of an argument we already claimed.\n      const Option &Opt = A->getOption();\n      if (Opt.getKind() == Option::FlagClass) {\n        bool DuplicateClaimed = false;\n\n        for (const Arg *AA : C.getArgs().filtered(&Opt)) {\n          if (AA->isClaimed()) {\n            DuplicateClaimed = true;\n            break;\n          }\n        }\n\n        if (DuplicateClaimed)\n          continue;\n      }\n\n      // In clang-cl, don't mention unknown arguments here since they have\n      // already been warned about.\n      if (!IsCLMode() || !A->getOption().matches(options::OPT_UNKNOWN))\n        Diag(clang::diag::warn_drv_unused_argument)\n            << A->getAsString(C.getArgs());\n    }\n  }\n}\n\nnamespace {\n/// Utility class to control the collapse of dependent actions and select the\n/// tools accordingly.\nclass ToolSelector final {\n  /// The tool chain this selector refers to.\n  const ToolChain &TC;\n\n  /// The compilation this selector refers to.\n  const Compilation &C;\n\n  /// The base action this selector refers to.\n  const JobAction *BaseAction;\n\n  /// Set to true if the current toolchain refers to host actions.\n  bool IsHostSelector;\n\n  /// Set to true if save-temps and embed-bitcode functionalities are active.\n  bool SaveTemps;\n  bool EmbedBitcode;\n\n  /// Get previous dependent action or null if that does not exist. If\n  /// \\a CanBeCollapsed is false, that action must be legal to collapse or\n  /// null will be returned.\n  const JobAction *getPrevDependentAction(const ActionList &Inputs,\n                                          ActionList &SavedOffloadAction,\n                                          bool CanBeCollapsed = true) {\n    // An option can be collapsed only if it has a single input.\n    if (Inputs.size() != 1)\n      return nullptr;\n\n    Action *CurAction = *Inputs.begin();\n    if (CanBeCollapsed &&\n        !CurAction->isCollapsingWithNextDependentActionLegal())\n      return nullptr;\n\n    // If the input action is an offload action. Look through it and save any\n    // offload action that can be dropped in the event of a collapse.\n    if (auto *OA = dyn_cast<OffloadAction>(CurAction)) {\n      // If the dependent action is a device action, we will attempt to collapse\n      // only with other device actions. Otherwise, we would do the same but\n      // with host actions only.\n      if (!IsHostSelector) {\n        if (OA->hasSingleDeviceDependence(/*DoNotConsiderHostActions=*/true)) {\n          CurAction =\n              OA->getSingleDeviceDependence(/*DoNotConsiderHostActions=*/true);\n          if (CanBeCollapsed &&\n              !CurAction->isCollapsingWithNextDependentActionLegal())\n            return nullptr;\n          SavedOffloadAction.push_back(OA);\n          return dyn_cast<JobAction>(CurAction);\n        }\n      } else if (OA->hasHostDependence()) {\n        CurAction = OA->getHostDependence();\n        if (CanBeCollapsed &&\n            !CurAction->isCollapsingWithNextDependentActionLegal())\n          return nullptr;\n        SavedOffloadAction.push_back(OA);\n        return dyn_cast<JobAction>(CurAction);\n      }\n      return nullptr;\n    }\n\n    return dyn_cast<JobAction>(CurAction);\n  }\n\n  /// Return true if an assemble action can be collapsed.\n  bool canCollapseAssembleAction() const {\n    return TC.useIntegratedAs() && !SaveTemps &&\n           !C.getArgs().hasArg(options::OPT_via_file_asm) &&\n           !C.getArgs().hasArg(options::OPT__SLASH_FA) &&\n           !C.getArgs().hasArg(options::OPT__SLASH_Fa);\n  }\n\n  /// Return true if a preprocessor action can be collapsed.\n  bool canCollapsePreprocessorAction() const {\n    return !C.getArgs().hasArg(options::OPT_no_integrated_cpp) &&\n           !C.getArgs().hasArg(options::OPT_traditional_cpp) && !SaveTemps &&\n           !C.getArgs().hasArg(options::OPT_rewrite_objc);\n  }\n\n  /// Struct that relates an action with the offload actions that would be\n  /// collapsed with it.\n  struct JobActionInfo final {\n    /// The action this info refers to.\n    const JobAction *JA = nullptr;\n    /// The offload actions we need to take care off if this action is\n    /// collapsed.\n    ActionList SavedOffloadAction;\n  };\n\n  /// Append collapsed offload actions from the give nnumber of elements in the\n  /// action info array.\n  static void AppendCollapsedOffloadAction(ActionList &CollapsedOffloadAction,\n                                           ArrayRef<JobActionInfo> &ActionInfo,\n                                           unsigned ElementNum) {\n    assert(ElementNum <= ActionInfo.size() && \"Invalid number of elements.\");\n    for (unsigned I = 0; I < ElementNum; ++I)\n      CollapsedOffloadAction.append(ActionInfo[I].SavedOffloadAction.begin(),\n                                    ActionInfo[I].SavedOffloadAction.end());\n  }\n\n  /// Functions that attempt to perform the combining. They detect if that is\n  /// legal, and if so they update the inputs \\a Inputs and the offload action\n  /// that were collapsed in \\a CollapsedOffloadAction. A tool that deals with\n  /// the combined action is returned. If the combining is not legal or if the\n  /// tool does not exist, null is returned.\n  /// Currently three kinds of collapsing are supported:\n  ///  - Assemble + Backend + Compile;\n  ///  - Assemble + Backend ;\n  ///  - Backend + Compile.\n  const Tool *\n  combineAssembleBackendCompile(ArrayRef<JobActionInfo> ActionInfo,\n                                ActionList &Inputs,\n                                ActionList &CollapsedOffloadAction) {\n    if (ActionInfo.size() < 3 || !canCollapseAssembleAction())\n      return nullptr;\n    auto *AJ = dyn_cast<AssembleJobAction>(ActionInfo[0].JA);\n    auto *BJ = dyn_cast<BackendJobAction>(ActionInfo[1].JA);\n    auto *CJ = dyn_cast<CompileJobAction>(ActionInfo[2].JA);\n    if (!AJ || !BJ || !CJ)\n      return nullptr;\n\n    // Get compiler tool.\n    const Tool *T = TC.SelectTool(*CJ);\n    if (!T)\n      return nullptr;\n\n    // When using -fembed-bitcode, it is required to have the same tool (clang)\n    // for both CompilerJA and BackendJA. Otherwise, combine two stages.\n    if (EmbedBitcode) {\n      const Tool *BT = TC.SelectTool(*BJ);\n      if (BT == T)\n        return nullptr;\n    }\n\n    if (!T->hasIntegratedAssembler())\n      return nullptr;\n\n    Inputs = CJ->getInputs();\n    AppendCollapsedOffloadAction(CollapsedOffloadAction, ActionInfo,\n                                 /*NumElements=*/3);\n    return T;\n  }\n  const Tool *combineAssembleBackend(ArrayRef<JobActionInfo> ActionInfo,\n                                     ActionList &Inputs,\n                                     ActionList &CollapsedOffloadAction) {\n    if (ActionInfo.size() < 2 || !canCollapseAssembleAction())\n      return nullptr;\n    auto *AJ = dyn_cast<AssembleJobAction>(ActionInfo[0].JA);\n    auto *BJ = dyn_cast<BackendJobAction>(ActionInfo[1].JA);\n    if (!AJ || !BJ)\n      return nullptr;\n\n    // Get backend tool.\n    const Tool *T = TC.SelectTool(*BJ);\n    if (!T)\n      return nullptr;\n\n    if (!T->hasIntegratedAssembler())\n      return nullptr;\n\n    Inputs = BJ->getInputs();\n    AppendCollapsedOffloadAction(CollapsedOffloadAction, ActionInfo,\n                                 /*NumElements=*/2);\n    return T;\n  }\n  const Tool *combineBackendCompile(ArrayRef<JobActionInfo> ActionInfo,\n                                    ActionList &Inputs,\n                                    ActionList &CollapsedOffloadAction) {\n    if (ActionInfo.size() < 2)\n      return nullptr;\n    auto *BJ = dyn_cast<BackendJobAction>(ActionInfo[0].JA);\n    auto *CJ = dyn_cast<CompileJobAction>(ActionInfo[1].JA);\n    if (!BJ || !CJ)\n      return nullptr;\n\n    // Check if the initial input (to the compile job or its predessor if one\n    // exists) is LLVM bitcode. In that case, no preprocessor step is required\n    // and we can still collapse the compile and backend jobs when we have\n    // -save-temps. I.e. there is no need for a separate compile job just to\n    // emit unoptimized bitcode.\n    bool InputIsBitcode = true;\n    for (size_t i = 1; i < ActionInfo.size(); i++)\n      if (ActionInfo[i].JA->getType() != types::TY_LLVM_BC &&\n          ActionInfo[i].JA->getType() != types::TY_LTO_BC) {\n        InputIsBitcode = false;\n        break;\n      }\n    if (!InputIsBitcode && !canCollapsePreprocessorAction())\n      return nullptr;\n\n    // Get compiler tool.\n    const Tool *T = TC.SelectTool(*CJ);\n    if (!T)\n      return nullptr;\n\n    if (T->canEmitIR() && ((SaveTemps && !InputIsBitcode) || EmbedBitcode))\n      return nullptr;\n\n    Inputs = CJ->getInputs();\n    AppendCollapsedOffloadAction(CollapsedOffloadAction, ActionInfo,\n                                 /*NumElements=*/2);\n    return T;\n  }\n\n  /// Updates the inputs if the obtained tool supports combining with\n  /// preprocessor action, and the current input is indeed a preprocessor\n  /// action. If combining results in the collapse of offloading actions, those\n  /// are appended to \\a CollapsedOffloadAction.\n  void combineWithPreprocessor(const Tool *T, ActionList &Inputs,\n                               ActionList &CollapsedOffloadAction) {\n    if (!T || !canCollapsePreprocessorAction() || !T->hasIntegratedCPP())\n      return;\n\n    // Attempt to get a preprocessor action dependence.\n    ActionList PreprocessJobOffloadActions;\n    ActionList NewInputs;\n    for (Action *A : Inputs) {\n      auto *PJ = getPrevDependentAction({A}, PreprocessJobOffloadActions);\n      if (!PJ || !isa<PreprocessJobAction>(PJ)) {\n        NewInputs.push_back(A);\n        continue;\n      }\n\n      // This is legal to combine. Append any offload action we found and add the\n      // current input to preprocessor inputs.\n      CollapsedOffloadAction.append(PreprocessJobOffloadActions.begin(),\n                                    PreprocessJobOffloadActions.end());\n      NewInputs.append(PJ->input_begin(), PJ->input_end());\n    }\n    Inputs = NewInputs;\n  }\n\npublic:\n  ToolSelector(const JobAction *BaseAction, const ToolChain &TC,\n               const Compilation &C, bool SaveTemps, bool EmbedBitcode)\n      : TC(TC), C(C), BaseAction(BaseAction), SaveTemps(SaveTemps),\n        EmbedBitcode(EmbedBitcode) {\n    assert(BaseAction && \"Invalid base action.\");\n    IsHostSelector = BaseAction->getOffloadingDeviceKind() == Action::OFK_None;\n  }\n\n  /// Check if a chain of actions can be combined and return the tool that can\n  /// handle the combination of actions. The pointer to the current inputs \\a\n  /// Inputs and the list of offload actions \\a CollapsedOffloadActions\n  /// connected to collapsed actions are updated accordingly. The latter enables\n  /// the caller of the selector to process them afterwards instead of just\n  /// dropping them. If no suitable tool is found, null will be returned.\n  const Tool *getTool(ActionList &Inputs,\n                      ActionList &CollapsedOffloadAction) {\n    //\n    // Get the largest chain of actions that we could combine.\n    //\n\n    SmallVector<JobActionInfo, 5> ActionChain(1);\n    ActionChain.back().JA = BaseAction;\n    while (ActionChain.back().JA) {\n      const Action *CurAction = ActionChain.back().JA;\n\n      // Grow the chain by one element.\n      ActionChain.resize(ActionChain.size() + 1);\n      JobActionInfo &AI = ActionChain.back();\n\n      // Attempt to fill it with the\n      AI.JA =\n          getPrevDependentAction(CurAction->getInputs(), AI.SavedOffloadAction);\n    }\n\n    // Pop the last action info as it could not be filled.\n    ActionChain.pop_back();\n\n    //\n    // Attempt to combine actions. If all combining attempts failed, just return\n    // the tool of the provided action. At the end we attempt to combine the\n    // action with any preprocessor action it may depend on.\n    //\n\n    const Tool *T = combineAssembleBackendCompile(ActionChain, Inputs,\n                                                  CollapsedOffloadAction);\n    if (!T)\n      T = combineAssembleBackend(ActionChain, Inputs, CollapsedOffloadAction);\n    if (!T)\n      T = combineBackendCompile(ActionChain, Inputs, CollapsedOffloadAction);\n    if (!T) {\n      Inputs = BaseAction->getInputs();\n      T = TC.SelectTool(*BaseAction);\n    }\n\n    combineWithPreprocessor(T, Inputs, CollapsedOffloadAction);\n    return T;\n  }\n};\n}\n\n/// Return a string that uniquely identifies the result of a job. The bound arch\n/// is not necessarily represented in the toolchain's triple -- for example,\n/// armv7 and armv7s both map to the same triple -- so we need both in our map.\n/// Also, we need to add the offloading device kind, as the same tool chain can\n/// be used for host and device for some programming models, e.g. OpenMP.\nstatic std::string GetTriplePlusArchString(const ToolChain *TC,\n                                           StringRef BoundArch,\n                                           Action::OffloadKind OffloadKind) {\n  std::string TriplePlusArch = TC->getTriple().normalize();\n  if (!BoundArch.empty()) {\n    TriplePlusArch += \"-\";\n    TriplePlusArch += BoundArch;\n  }\n  TriplePlusArch += \"-\";\n  TriplePlusArch += Action::GetOffloadKindName(OffloadKind);\n  return TriplePlusArch;\n}\n\nInputInfo Driver::BuildJobsForAction(\n    Compilation &C, const Action *A, const ToolChain *TC, StringRef BoundArch,\n    bool AtTopLevel, bool MultipleArchs, const char *LinkingOutput,\n    std::map<std::pair<const Action *, std::string>, InputInfo> &CachedResults,\n    Action::OffloadKind TargetDeviceOffloadKind) const {\n  std::pair<const Action *, std::string> ActionTC = {\n      A, GetTriplePlusArchString(TC, BoundArch, TargetDeviceOffloadKind)};\n  auto CachedResult = CachedResults.find(ActionTC);\n  if (CachedResult != CachedResults.end()) {\n    return CachedResult->second;\n  }\n  InputInfo Result = BuildJobsForActionNoCache(\n      C, A, TC, BoundArch, AtTopLevel, MultipleArchs, LinkingOutput,\n      CachedResults, TargetDeviceOffloadKind);\n  CachedResults[ActionTC] = Result;\n  return Result;\n}\n\nInputInfo Driver::BuildJobsForActionNoCache(\n    Compilation &C, const Action *A, const ToolChain *TC, StringRef BoundArch,\n    bool AtTopLevel, bool MultipleArchs, const char *LinkingOutput,\n    std::map<std::pair<const Action *, std::string>, InputInfo> &CachedResults,\n    Action::OffloadKind TargetDeviceOffloadKind) const {\n  llvm::PrettyStackTraceString CrashInfo(\"Building compilation jobs\");\n\n  InputInfoList OffloadDependencesInputInfo;\n  bool BuildingForOffloadDevice = TargetDeviceOffloadKind != Action::OFK_None;\n  if (const OffloadAction *OA = dyn_cast<OffloadAction>(A)) {\n    // The 'Darwin' toolchain is initialized only when its arguments are\n    // computed. Get the default arguments for OFK_None to ensure that\n    // initialization is performed before processing the offload action.\n    // FIXME: Remove when darwin's toolchain is initialized during construction.\n    C.getArgsForToolChain(TC, BoundArch, Action::OFK_None);\n\n    // The offload action is expected to be used in four different situations.\n    //\n    // a) Set a toolchain/architecture/kind for a host action:\n    //    Host Action 1 -> OffloadAction -> Host Action 2\n    //\n    // b) Set a toolchain/architecture/kind for a device action;\n    //    Device Action 1 -> OffloadAction -> Device Action 2\n    //\n    // c) Specify a device dependence to a host action;\n    //    Device Action 1  _\n    //                      \\\n    //      Host Action 1  ---> OffloadAction -> Host Action 2\n    //\n    // d) Specify a host dependence to a device action.\n    //      Host Action 1  _\n    //                      \\\n    //    Device Action 1  ---> OffloadAction -> Device Action 2\n    //\n    // For a) and b), we just return the job generated for the dependence. For\n    // c) and d) we override the current action with the host/device dependence\n    // if the current toolchain is host/device and set the offload dependences\n    // info with the jobs obtained from the device/host dependence(s).\n\n    // If there is a single device option, just generate the job for it.\n    if (OA->hasSingleDeviceDependence()) {\n      InputInfo DevA;\n      OA->doOnEachDeviceDependence([&](Action *DepA, const ToolChain *DepTC,\n                                       const char *DepBoundArch) {\n        DevA =\n            BuildJobsForAction(C, DepA, DepTC, DepBoundArch, AtTopLevel,\n                               /*MultipleArchs*/ !!DepBoundArch, LinkingOutput,\n                               CachedResults, DepA->getOffloadingDeviceKind());\n      });\n      return DevA;\n    }\n\n    // If 'Action 2' is host, we generate jobs for the device dependences and\n    // override the current action with the host dependence. Otherwise, we\n    // generate the host dependences and override the action with the device\n    // dependence. The dependences can't therefore be a top-level action.\n    OA->doOnEachDependence(\n        /*IsHostDependence=*/BuildingForOffloadDevice,\n        [&](Action *DepA, const ToolChain *DepTC, const char *DepBoundArch) {\n          OffloadDependencesInputInfo.push_back(BuildJobsForAction(\n              C, DepA, DepTC, DepBoundArch, /*AtTopLevel=*/false,\n              /*MultipleArchs*/ !!DepBoundArch, LinkingOutput, CachedResults,\n              DepA->getOffloadingDeviceKind()));\n        });\n\n    A = BuildingForOffloadDevice\n            ? OA->getSingleDeviceDependence(/*DoNotConsiderHostActions=*/true)\n            : OA->getHostDependence();\n  }\n\n  if (const InputAction *IA = dyn_cast<InputAction>(A)) {\n    // FIXME: It would be nice to not claim this here; maybe the old scheme of\n    // just using Args was better?\n    const Arg &Input = IA->getInputArg();\n    Input.claim();\n    if (Input.getOption().matches(options::OPT_INPUT)) {\n      const char *Name = Input.getValue();\n      return InputInfo(A, Name, /* _BaseInput = */ Name);\n    }\n    return InputInfo(A, &Input, /* _BaseInput = */ \"\");\n  }\n\n  if (const BindArchAction *BAA = dyn_cast<BindArchAction>(A)) {\n    const ToolChain *TC;\n    StringRef ArchName = BAA->getArchName();\n\n    if (!ArchName.empty())\n      TC = &getToolChain(C.getArgs(),\n                         computeTargetTriple(*this, TargetTriple,\n                                             C.getArgs(), ArchName));\n    else\n      TC = &C.getDefaultToolChain();\n\n    return BuildJobsForAction(C, *BAA->input_begin(), TC, ArchName, AtTopLevel,\n                              MultipleArchs, LinkingOutput, CachedResults,\n                              TargetDeviceOffloadKind);\n  }\n\n\n  ActionList Inputs = A->getInputs();\n\n  const JobAction *JA = cast<JobAction>(A);\n  ActionList CollapsedOffloadActions;\n\n  ToolSelector TS(JA, *TC, C, isSaveTempsEnabled(),\n                  embedBitcodeInObject() && !isUsingLTO());\n  const Tool *T = TS.getTool(Inputs, CollapsedOffloadActions);\n\n  if (!T)\n    return InputInfo();\n\n  // If we've collapsed action list that contained OffloadAction we\n  // need to build jobs for host/device-side inputs it may have held.\n  for (const auto *OA : CollapsedOffloadActions)\n    cast<OffloadAction>(OA)->doOnEachDependence(\n        /*IsHostDependence=*/BuildingForOffloadDevice,\n        [&](Action *DepA, const ToolChain *DepTC, const char *DepBoundArch) {\n          OffloadDependencesInputInfo.push_back(BuildJobsForAction(\n              C, DepA, DepTC, DepBoundArch, /* AtTopLevel */ false,\n              /*MultipleArchs=*/!!DepBoundArch, LinkingOutput, CachedResults,\n              DepA->getOffloadingDeviceKind()));\n        });\n\n  // Only use pipes when there is exactly one input.\n  InputInfoList InputInfos;\n  for (const Action *Input : Inputs) {\n    // Treat dsymutil and verify sub-jobs as being at the top-level too, they\n    // shouldn't get temporary output names.\n    // FIXME: Clean this up.\n    bool SubJobAtTopLevel =\n        AtTopLevel && (isa<DsymutilJobAction>(A) || isa<VerifyJobAction>(A));\n    InputInfos.push_back(BuildJobsForAction(\n        C, Input, TC, BoundArch, SubJobAtTopLevel, MultipleArchs, LinkingOutput,\n        CachedResults, A->getOffloadingDeviceKind()));\n  }\n\n  // Always use the first input as the base input.\n  const char *BaseInput = InputInfos[0].getBaseInput();\n\n  // ... except dsymutil actions, which use their actual input as the base\n  // input.\n  if (JA->getType() == types::TY_dSYM)\n    BaseInput = InputInfos[0].getFilename();\n\n  // ... and in header module compilations, which use the module name.\n  if (auto *ModuleJA = dyn_cast<HeaderModulePrecompileJobAction>(JA))\n    BaseInput = ModuleJA->getModuleName();\n\n  // Append outputs of offload device jobs to the input list\n  if (!OffloadDependencesInputInfo.empty())\n    InputInfos.append(OffloadDependencesInputInfo.begin(),\n                      OffloadDependencesInputInfo.end());\n\n  // Set the effective triple of the toolchain for the duration of this job.\n  llvm::Triple EffectiveTriple;\n  const ToolChain &ToolTC = T->getToolChain();\n  const ArgList &Args =\n      C.getArgsForToolChain(TC, BoundArch, A->getOffloadingDeviceKind());\n  if (InputInfos.size() != 1) {\n    EffectiveTriple = llvm::Triple(ToolTC.ComputeEffectiveClangTriple(Args));\n  } else {\n    // Pass along the input type if it can be unambiguously determined.\n    EffectiveTriple = llvm::Triple(\n        ToolTC.ComputeEffectiveClangTriple(Args, InputInfos[0].getType()));\n  }\n  RegisterEffectiveTriple TripleRAII(ToolTC, EffectiveTriple);\n\n  // Determine the place to write output to, if any.\n  InputInfo Result;\n  InputInfoList UnbundlingResults;\n  if (auto *UA = dyn_cast<OffloadUnbundlingJobAction>(JA)) {\n    // If we have an unbundling job, we need to create results for all the\n    // outputs. We also update the results cache so that other actions using\n    // this unbundling action can get the right results.\n    for (auto &UI : UA->getDependentActionsInfo()) {\n      assert(UI.DependentOffloadKind != Action::OFK_None &&\n             \"Unbundling with no offloading??\");\n\n      // Unbundling actions are never at the top level. When we generate the\n      // offloading prefix, we also do that for the host file because the\n      // unbundling action does not change the type of the output which can\n      // cause a overwrite.\n      std::string OffloadingPrefix = Action::GetOffloadingFileNamePrefix(\n          UI.DependentOffloadKind,\n          UI.DependentToolChain->getTriple().normalize(),\n          /*CreatePrefixForHost=*/true);\n      auto CurI = InputInfo(\n          UA,\n          GetNamedOutputPath(C, *UA, BaseInput, UI.DependentBoundArch,\n                             /*AtTopLevel=*/false,\n                             MultipleArchs ||\n                                 UI.DependentOffloadKind == Action::OFK_HIP,\n                             OffloadingPrefix),\n          BaseInput);\n      // Save the unbundling result.\n      UnbundlingResults.push_back(CurI);\n\n      // Get the unique string identifier for this dependence and cache the\n      // result.\n      StringRef Arch;\n      if (TargetDeviceOffloadKind == Action::OFK_HIP) {\n        if (UI.DependentOffloadKind == Action::OFK_Host)\n          Arch = StringRef();\n        else\n          Arch = UI.DependentBoundArch;\n      } else\n        Arch = BoundArch;\n\n      CachedResults[{A, GetTriplePlusArchString(UI.DependentToolChain, Arch,\n                                                UI.DependentOffloadKind)}] =\n          CurI;\n    }\n\n    // Now that we have all the results generated, select the one that should be\n    // returned for the current depending action.\n    std::pair<const Action *, std::string> ActionTC = {\n        A, GetTriplePlusArchString(TC, BoundArch, TargetDeviceOffloadKind)};\n    assert(CachedResults.find(ActionTC) != CachedResults.end() &&\n           \"Result does not exist??\");\n    Result = CachedResults[ActionTC];\n  } else if (JA->getType() == types::TY_Nothing)\n    Result = InputInfo(A, BaseInput);\n  else {\n    // We only have to generate a prefix for the host if this is not a top-level\n    // action.\n    std::string OffloadingPrefix = Action::GetOffloadingFileNamePrefix(\n        A->getOffloadingDeviceKind(), TC->getTriple().normalize(),\n        /*CreatePrefixForHost=*/!!A->getOffloadingHostActiveKinds() &&\n            !AtTopLevel);\n    if (isa<OffloadWrapperJobAction>(JA)) {\n      OffloadingPrefix += \"-wrapper\";\n      if (Arg *FinalOutput = C.getArgs().getLastArg(options::OPT_o))\n        BaseInput = FinalOutput->getValue();\n      else\n        BaseInput = getDefaultImageName();\n    }\n    Result = InputInfo(A, GetNamedOutputPath(C, *JA, BaseInput, BoundArch,\n                                             AtTopLevel, MultipleArchs,\n                                             OffloadingPrefix),\n                       BaseInput);\n  }\n\n  if (CCCPrintBindings && !CCGenDiagnostics) {\n    llvm::errs() << \"# \\\"\" << T->getToolChain().getTripleString() << '\"'\n                 << \" - \\\"\" << T->getName() << \"\\\", inputs: [\";\n    for (unsigned i = 0, e = InputInfos.size(); i != e; ++i) {\n      llvm::errs() << InputInfos[i].getAsString();\n      if (i + 1 != e)\n        llvm::errs() << \", \";\n    }\n    if (UnbundlingResults.empty())\n      llvm::errs() << \"], output: \" << Result.getAsString() << \"\\n\";\n    else {\n      llvm::errs() << \"], outputs: [\";\n      for (unsigned i = 0, e = UnbundlingResults.size(); i != e; ++i) {\n        llvm::errs() << UnbundlingResults[i].getAsString();\n        if (i + 1 != e)\n          llvm::errs() << \", \";\n      }\n      llvm::errs() << \"] \\n\";\n    }\n  } else {\n    if (UnbundlingResults.empty())\n      T->ConstructJob(\n          C, *JA, Result, InputInfos,\n          C.getArgsForToolChain(TC, BoundArch, JA->getOffloadingDeviceKind()),\n          LinkingOutput);\n    else\n      T->ConstructJobMultipleOutputs(\n          C, *JA, UnbundlingResults, InputInfos,\n          C.getArgsForToolChain(TC, BoundArch, JA->getOffloadingDeviceKind()),\n          LinkingOutput);\n  }\n  return Result;\n}\n\nconst char *Driver::getDefaultImageName() const {\n  llvm::Triple Target(llvm::Triple::normalize(TargetTriple));\n  return Target.isOSWindows() ? \"a.exe\" : \"a.out\";\n}\n\n/// Create output filename based on ArgValue, which could either be a\n/// full filename, filename without extension, or a directory. If ArgValue\n/// does not provide a filename, then use BaseName, and use the extension\n/// suitable for FileType.\nstatic const char *MakeCLOutputFilename(const ArgList &Args, StringRef ArgValue,\n                                        StringRef BaseName,\n                                        types::ID FileType) {\n  SmallString<128> Filename = ArgValue;\n\n  if (ArgValue.empty()) {\n    // If the argument is empty, output to BaseName in the current dir.\n    Filename = BaseName;\n  } else if (llvm::sys::path::is_separator(Filename.back())) {\n    // If the argument is a directory, output to BaseName in that dir.\n    llvm::sys::path::append(Filename, BaseName);\n  }\n\n  if (!llvm::sys::path::has_extension(ArgValue)) {\n    // If the argument didn't provide an extension, then set it.\n    const char *Extension = types::getTypeTempSuffix(FileType, true);\n\n    if (FileType == types::TY_Image &&\n        Args.hasArg(options::OPT__SLASH_LD, options::OPT__SLASH_LDd)) {\n      // The output file is a dll.\n      Extension = \"dll\";\n    }\n\n    llvm::sys::path::replace_extension(Filename, Extension);\n  }\n\n  return Args.MakeArgString(Filename.c_str());\n}\n\nstatic bool HasPreprocessOutput(const Action &JA) {\n  if (isa<PreprocessJobAction>(JA))\n    return true;\n  if (isa<OffloadAction>(JA) && isa<PreprocessJobAction>(JA.getInputs()[0]))\n    return true;\n  if (isa<OffloadBundlingJobAction>(JA) &&\n      HasPreprocessOutput(*(JA.getInputs()[0])))\n    return true;\n  return false;\n}\n\nconst char *Driver::GetNamedOutputPath(Compilation &C, const JobAction &JA,\n                                       const char *BaseInput,\n                                       StringRef OrigBoundArch, bool AtTopLevel,\n                                       bool MultipleArchs,\n                                       StringRef OffloadingPrefix) const {\n  std::string BoundArch = OrigBoundArch.str();\n#if defined(_WIN32)\n  // BoundArch may contains ':', which is invalid in file names on Windows,\n  // therefore replace it with '%'.\n  std::replace(BoundArch.begin(), BoundArch.end(), ':', '@');\n#endif\n\n  llvm::PrettyStackTraceString CrashInfo(\"Computing output path\");\n  // Output to a user requested destination?\n  if (AtTopLevel && !isa<DsymutilJobAction>(JA) && !isa<VerifyJobAction>(JA)) {\n    if (Arg *FinalOutput = C.getArgs().getLastArg(options::OPT_o))\n      return C.addResultFile(FinalOutput->getValue(), &JA);\n  }\n\n  // For /P, preprocess to file named after BaseInput.\n  if (C.getArgs().hasArg(options::OPT__SLASH_P)) {\n    assert(AtTopLevel && isa<PreprocessJobAction>(JA));\n    StringRef BaseName = llvm::sys::path::filename(BaseInput);\n    StringRef NameArg;\n    if (Arg *A = C.getArgs().getLastArg(options::OPT__SLASH_Fi))\n      NameArg = A->getValue();\n    return C.addResultFile(\n        MakeCLOutputFilename(C.getArgs(), NameArg, BaseName, types::TY_PP_C),\n        &JA);\n  }\n\n  // Default to writing to stdout?\n  if (AtTopLevel && !CCGenDiagnostics && HasPreprocessOutput(JA)) {\n    return \"-\";\n  }\n\n  // Is this the assembly listing for /FA?\n  if (JA.getType() == types::TY_PP_Asm &&\n      (C.getArgs().hasArg(options::OPT__SLASH_FA) ||\n       C.getArgs().hasArg(options::OPT__SLASH_Fa))) {\n    // Use /Fa and the input filename to determine the asm file name.\n    StringRef BaseName = llvm::sys::path::filename(BaseInput);\n    StringRef FaValue = C.getArgs().getLastArgValue(options::OPT__SLASH_Fa);\n    return C.addResultFile(\n        MakeCLOutputFilename(C.getArgs(), FaValue, BaseName, JA.getType()),\n        &JA);\n  }\n\n  // Output to a temporary file?\n  if ((!AtTopLevel && !isSaveTempsEnabled() &&\n       !C.getArgs().hasArg(options::OPT__SLASH_Fo)) ||\n      CCGenDiagnostics) {\n    StringRef Name = llvm::sys::path::filename(BaseInput);\n    std::pair<StringRef, StringRef> Split = Name.split('.');\n    SmallString<128> TmpName;\n    const char *Suffix = types::getTypeTempSuffix(JA.getType(), IsCLMode());\n    Arg *A = C.getArgs().getLastArg(options::OPT_fcrash_diagnostics_dir);\n    if (CCGenDiagnostics && A) {\n      SmallString<128> CrashDirectory(A->getValue());\n      if (!getVFS().exists(CrashDirectory))\n        llvm::sys::fs::create_directories(CrashDirectory);\n      llvm::sys::path::append(CrashDirectory, Split.first);\n      const char *Middle = Suffix ? \"-%%%%%%.\" : \"-%%%%%%\";\n      std::error_code EC = llvm::sys::fs::createUniqueFile(\n          CrashDirectory + Middle + Suffix, TmpName);\n      if (EC) {\n        Diag(clang::diag::err_unable_to_make_temp) << EC.message();\n        return \"\";\n      }\n    } else {\n      TmpName = GetTemporaryPath(Split.first, Suffix);\n    }\n    return C.addTempFile(C.getArgs().MakeArgString(TmpName));\n  }\n\n  SmallString<128> BasePath(BaseInput);\n  SmallString<128> ExternalPath(\"\");\n  StringRef BaseName;\n\n  // Dsymutil actions should use the full path.\n  if (isa<DsymutilJobAction>(JA) && C.getArgs().hasArg(options::OPT_dsym_dir)) {\n    ExternalPath += C.getArgs().getLastArg(options::OPT_dsym_dir)->getValue();\n    // We use posix style here because the tests (specifically\n    // darwin-dsymutil.c) demonstrate that posix style paths are acceptable\n    // even on Windows and if we don't then the similar test covering this\n    // fails.\n    llvm::sys::path::append(ExternalPath, llvm::sys::path::Style::posix,\n                            llvm::sys::path::filename(BasePath));\n    BaseName = ExternalPath;\n  } else if (isa<DsymutilJobAction>(JA) || isa<VerifyJobAction>(JA))\n    BaseName = BasePath;\n  else\n    BaseName = llvm::sys::path::filename(BasePath);\n\n  // Determine what the derived output name should be.\n  const char *NamedOutput;\n\n  if ((JA.getType() == types::TY_Object || JA.getType() == types::TY_LTO_BC) &&\n      C.getArgs().hasArg(options::OPT__SLASH_Fo, options::OPT__SLASH_o)) {\n    // The /Fo or /o flag decides the object filename.\n    StringRef Val =\n        C.getArgs()\n            .getLastArg(options::OPT__SLASH_Fo, options::OPT__SLASH_o)\n            ->getValue();\n    NamedOutput =\n        MakeCLOutputFilename(C.getArgs(), Val, BaseName, types::TY_Object);\n  } else if (JA.getType() == types::TY_Image &&\n             C.getArgs().hasArg(options::OPT__SLASH_Fe,\n                                options::OPT__SLASH_o)) {\n    // The /Fe or /o flag names the linked file.\n    StringRef Val =\n        C.getArgs()\n            .getLastArg(options::OPT__SLASH_Fe, options::OPT__SLASH_o)\n            ->getValue();\n    NamedOutput =\n        MakeCLOutputFilename(C.getArgs(), Val, BaseName, types::TY_Image);\n  } else if (JA.getType() == types::TY_Image) {\n    if (IsCLMode()) {\n      // clang-cl uses BaseName for the executable name.\n      NamedOutput =\n          MakeCLOutputFilename(C.getArgs(), \"\", BaseName, types::TY_Image);\n    } else {\n      SmallString<128> Output(getDefaultImageName());\n      // HIP image for device compilation with -fno-gpu-rdc is per compilation\n      // unit.\n      bool IsHIPNoRDC = JA.getOffloadingDeviceKind() == Action::OFK_HIP &&\n                        !C.getArgs().hasFlag(options::OPT_fgpu_rdc,\n                                             options::OPT_fno_gpu_rdc, false);\n      if (IsHIPNoRDC) {\n        Output = BaseName;\n        llvm::sys::path::replace_extension(Output, \"\");\n      }\n      Output += OffloadingPrefix;\n      if (MultipleArchs && !BoundArch.empty()) {\n        Output += \"-\";\n        Output.append(BoundArch);\n      }\n      if (IsHIPNoRDC)\n        Output += \".out\";\n      NamedOutput = C.getArgs().MakeArgString(Output.c_str());\n    }\n  } else if (JA.getType() == types::TY_PCH && IsCLMode()) {\n    NamedOutput = C.getArgs().MakeArgString(GetClPchPath(C, BaseName));\n  } else {\n    const char *Suffix = types::getTypeTempSuffix(JA.getType(), IsCLMode());\n    assert(Suffix && \"All types used for output should have a suffix.\");\n\n    std::string::size_type End = std::string::npos;\n    if (!types::appendSuffixForType(JA.getType()))\n      End = BaseName.rfind('.');\n    SmallString<128> Suffixed(BaseName.substr(0, End));\n    Suffixed += OffloadingPrefix;\n    if (MultipleArchs && !BoundArch.empty()) {\n      Suffixed += \"-\";\n      Suffixed.append(BoundArch);\n    }\n    // When using both -save-temps and -emit-llvm, use a \".tmp.bc\" suffix for\n    // the unoptimized bitcode so that it does not get overwritten by the \".bc\"\n    // optimized bitcode output.\n    auto IsHIPRDCInCompilePhase = [](const JobAction &JA,\n                                     const llvm::opt::DerivedArgList &Args) {\n      // The relocatable compilation in HIP implies -emit-llvm. Similarly, use a\n      // \".tmp.bc\" suffix for the unoptimized bitcode (generated in the compile\n      // phase.)\n      return isa<CompileJobAction>(JA) &&\n             JA.getOffloadingDeviceKind() == Action::OFK_HIP &&\n             Args.hasFlag(options::OPT_fgpu_rdc, options::OPT_fno_gpu_rdc,\n                          false);\n    };\n    if (!AtTopLevel && JA.getType() == types::TY_LLVM_BC &&\n        (C.getArgs().hasArg(options::OPT_emit_llvm) ||\n         IsHIPRDCInCompilePhase(JA, C.getArgs())))\n      Suffixed += \".tmp\";\n    Suffixed += '.';\n    Suffixed += Suffix;\n    NamedOutput = C.getArgs().MakeArgString(Suffixed.c_str());\n  }\n\n  // Prepend object file path if -save-temps=obj\n  if (!AtTopLevel && isSaveTempsObj() && C.getArgs().hasArg(options::OPT_o) &&\n      JA.getType() != types::TY_PCH) {\n    Arg *FinalOutput = C.getArgs().getLastArg(options::OPT_o);\n    SmallString<128> TempPath(FinalOutput->getValue());\n    llvm::sys::path::remove_filename(TempPath);\n    StringRef OutputFileName = llvm::sys::path::filename(NamedOutput);\n    llvm::sys::path::append(TempPath, OutputFileName);\n    NamedOutput = C.getArgs().MakeArgString(TempPath.c_str());\n  }\n\n  // If we're saving temps and the temp file conflicts with the input file,\n  // then avoid overwriting input file.\n  if (!AtTopLevel && isSaveTempsEnabled() && NamedOutput == BaseName) {\n    bool SameFile = false;\n    SmallString<256> Result;\n    llvm::sys::fs::current_path(Result);\n    llvm::sys::path::append(Result, BaseName);\n    llvm::sys::fs::equivalent(BaseInput, Result.c_str(), SameFile);\n    // Must share the same path to conflict.\n    if (SameFile) {\n      StringRef Name = llvm::sys::path::filename(BaseInput);\n      std::pair<StringRef, StringRef> Split = Name.split('.');\n      std::string TmpName = GetTemporaryPath(\n          Split.first, types::getTypeTempSuffix(JA.getType(), IsCLMode()));\n      return C.addTempFile(C.getArgs().MakeArgString(TmpName));\n    }\n  }\n\n  // As an annoying special case, PCH generation doesn't strip the pathname.\n  if (JA.getType() == types::TY_PCH && !IsCLMode()) {\n    llvm::sys::path::remove_filename(BasePath);\n    if (BasePath.empty())\n      BasePath = NamedOutput;\n    else\n      llvm::sys::path::append(BasePath, NamedOutput);\n    return C.addResultFile(C.getArgs().MakeArgString(BasePath.c_str()), &JA);\n  } else {\n    return C.addResultFile(NamedOutput, &JA);\n  }\n}\n\nstd::string Driver::GetFilePath(StringRef Name, const ToolChain &TC) const {\n  // Search for Name in a list of paths.\n  auto SearchPaths = [&](const llvm::SmallVectorImpl<std::string> &P)\n      -> llvm::Optional<std::string> {\n    // Respect a limited subset of the '-Bprefix' functionality in GCC by\n    // attempting to use this prefix when looking for file paths.\n    for (const auto &Dir : P) {\n      if (Dir.empty())\n        continue;\n      SmallString<128> P(Dir[0] == '=' ? SysRoot + Dir.substr(1) : Dir);\n      llvm::sys::path::append(P, Name);\n      if (llvm::sys::fs::exists(Twine(P)))\n        return std::string(P);\n    }\n    return None;\n  };\n\n  if (auto P = SearchPaths(PrefixDirs))\n    return *P;\n\n  SmallString<128> R(ResourceDir);\n  llvm::sys::path::append(R, Name);\n  if (llvm::sys::fs::exists(Twine(R)))\n    return std::string(R.str());\n\n  SmallString<128> P(TC.getCompilerRTPath());\n  llvm::sys::path::append(P, Name);\n  if (llvm::sys::fs::exists(Twine(P)))\n    return std::string(P.str());\n\n  SmallString<128> D(Dir);\n  llvm::sys::path::append(D, \"..\", Name);\n  if (llvm::sys::fs::exists(Twine(D)))\n    return std::string(D.str());\n\n  if (auto P = SearchPaths(TC.getLibraryPaths()))\n    return *P;\n\n  if (auto P = SearchPaths(TC.getFilePaths()))\n    return *P;\n\n  return std::string(Name);\n}\n\nvoid Driver::generatePrefixedToolNames(\n    StringRef Tool, const ToolChain &TC,\n    SmallVectorImpl<std::string> &Names) const {\n  // FIXME: Needs a better variable than TargetTriple\n  Names.emplace_back((TargetTriple + \"-\" + Tool).str());\n  Names.emplace_back(Tool);\n\n  // Allow the discovery of tools prefixed with LLVM's default target triple.\n  std::string DefaultTargetTriple = llvm::sys::getDefaultTargetTriple();\n  if (DefaultTargetTriple != TargetTriple)\n    Names.emplace_back((DefaultTargetTriple + \"-\" + Tool).str());\n}\n\nstatic bool ScanDirForExecutable(SmallString<128> &Dir, StringRef Name) {\n  llvm::sys::path::append(Dir, Name);\n  if (llvm::sys::fs::can_execute(Twine(Dir)))\n    return true;\n  llvm::sys::path::remove_filename(Dir);\n  return false;\n}\n\nstd::string Driver::GetProgramPath(StringRef Name, const ToolChain &TC) const {\n  SmallVector<std::string, 2> TargetSpecificExecutables;\n  generatePrefixedToolNames(Name, TC, TargetSpecificExecutables);\n\n  // Respect a limited subset of the '-Bprefix' functionality in GCC by\n  // attempting to use this prefix when looking for program paths.\n  for (const auto &PrefixDir : PrefixDirs) {\n    if (llvm::sys::fs::is_directory(PrefixDir)) {\n      SmallString<128> P(PrefixDir);\n      if (ScanDirForExecutable(P, Name))\n        return std::string(P.str());\n    } else {\n      SmallString<128> P((PrefixDir + Name).str());\n      if (llvm::sys::fs::can_execute(Twine(P)))\n        return std::string(P.str());\n    }\n  }\n\n  const ToolChain::path_list &List = TC.getProgramPaths();\n  for (const auto &TargetSpecificExecutable : TargetSpecificExecutables) {\n    // For each possible name of the tool look for it in\n    // program paths first, then the path.\n    // Higher priority names will be first, meaning that\n    // a higher priority name in the path will be found\n    // instead of a lower priority name in the program path.\n    // E.g. <triple>-gcc on the path will be found instead\n    // of gcc in the program path\n    for (const auto &Path : List) {\n      SmallString<128> P(Path);\n      if (ScanDirForExecutable(P, TargetSpecificExecutable))\n        return std::string(P.str());\n    }\n\n    // Fall back to the path\n    if (llvm::ErrorOr<std::string> P =\n            llvm::sys::findProgramByName(TargetSpecificExecutable))\n      return *P;\n  }\n\n  return std::string(Name);\n}\n\nstd::string Driver::GetTemporaryPath(StringRef Prefix, StringRef Suffix) const {\n  SmallString<128> Path;\n  std::error_code EC = llvm::sys::fs::createTemporaryFile(Prefix, Suffix, Path);\n  if (EC) {\n    Diag(clang::diag::err_unable_to_make_temp) << EC.message();\n    return \"\";\n  }\n\n  return std::string(Path.str());\n}\n\nstd::string Driver::GetTemporaryDirectory(StringRef Prefix) const {\n  SmallString<128> Path;\n  std::error_code EC = llvm::sys::fs::createUniqueDirectory(Prefix, Path);\n  if (EC) {\n    Diag(clang::diag::err_unable_to_make_temp) << EC.message();\n    return \"\";\n  }\n\n  return std::string(Path.str());\n}\n\nstd::string Driver::GetClPchPath(Compilation &C, StringRef BaseName) const {\n  SmallString<128> Output;\n  if (Arg *FpArg = C.getArgs().getLastArg(options::OPT__SLASH_Fp)) {\n    // FIXME: If anybody needs it, implement this obscure rule:\n    // \"If you specify a directory without a file name, the default file name\n    // is VCx0.pch., where x is the major version of Visual C++ in use.\"\n    Output = FpArg->getValue();\n\n    // \"If you do not specify an extension as part of the path name, an\n    // extension of .pch is assumed. \"\n    if (!llvm::sys::path::has_extension(Output))\n      Output += \".pch\";\n  } else {\n    if (Arg *YcArg = C.getArgs().getLastArg(options::OPT__SLASH_Yc))\n      Output = YcArg->getValue();\n    if (Output.empty())\n      Output = BaseName;\n    llvm::sys::path::replace_extension(Output, \".pch\");\n  }\n  return std::string(Output.str());\n}\n\nconst ToolChain &Driver::getToolChain(const ArgList &Args,\n                                      const llvm::Triple &Target) const {\n\n  auto &TC = ToolChains[Target.str()];\n  if (!TC) {\n    switch (Target.getOS()) {\n    case llvm::Triple::AIX:\n      TC = std::make_unique<toolchains::AIX>(*this, Target, Args);\n      break;\n    case llvm::Triple::Haiku:\n      TC = std::make_unique<toolchains::Haiku>(*this, Target, Args);\n      break;\n    case llvm::Triple::Ananas:\n      TC = std::make_unique<toolchains::Ananas>(*this, Target, Args);\n      break;\n    case llvm::Triple::CloudABI:\n      TC = std::make_unique<toolchains::CloudABI>(*this, Target, Args);\n      break;\n    case llvm::Triple::Darwin:\n    case llvm::Triple::MacOSX:\n    case llvm::Triple::IOS:\n    case llvm::Triple::TvOS:\n    case llvm::Triple::WatchOS:\n      TC = std::make_unique<toolchains::DarwinClang>(*this, Target, Args);\n      break;\n    case llvm::Triple::DragonFly:\n      TC = std::make_unique<toolchains::DragonFly>(*this, Target, Args);\n      break;\n    case llvm::Triple::OpenBSD:\n      TC = std::make_unique<toolchains::OpenBSD>(*this, Target, Args);\n      break;\n    case llvm::Triple::NetBSD:\n      TC = std::make_unique<toolchains::NetBSD>(*this, Target, Args);\n      break;\n    case llvm::Triple::FreeBSD:\n      TC = std::make_unique<toolchains::FreeBSD>(*this, Target, Args);\n      break;\n    case llvm::Triple::Minix:\n      TC = std::make_unique<toolchains::Minix>(*this, Target, Args);\n      break;\n    case llvm::Triple::Linux:\n    case llvm::Triple::ELFIAMCU:\n      if (Target.getArch() == llvm::Triple::hexagon)\n        TC = std::make_unique<toolchains::HexagonToolChain>(*this, Target,\n                                                             Args);\n      else if ((Target.getVendor() == llvm::Triple::MipsTechnologies) &&\n               !Target.hasEnvironment())\n        TC = std::make_unique<toolchains::MipsLLVMToolChain>(*this, Target,\n                                                              Args);\n      else if (Target.isPPC())\n        TC = std::make_unique<toolchains::PPCLinuxToolChain>(*this, Target,\n                                                              Args);\n      else if (Target.getArch() == llvm::Triple::ve)\n        TC = std::make_unique<toolchains::VEToolChain>(*this, Target, Args);\n\n      else\n        TC = std::make_unique<toolchains::Linux>(*this, Target, Args);\n      break;\n    case llvm::Triple::NaCl:\n      TC = std::make_unique<toolchains::NaClToolChain>(*this, Target, Args);\n      break;\n    case llvm::Triple::Fuchsia:\n      TC = std::make_unique<toolchains::Fuchsia>(*this, Target, Args);\n      break;\n    case llvm::Triple::Solaris:\n      TC = std::make_unique<toolchains::Solaris>(*this, Target, Args);\n      break;\n    case llvm::Triple::AMDHSA:\n      TC = std::make_unique<toolchains::ROCMToolChain>(*this, Target, Args);\n      break;\n    case llvm::Triple::AMDPAL:\n    case llvm::Triple::Mesa3D:\n      TC = std::make_unique<toolchains::AMDGPUToolChain>(*this, Target, Args);\n      break;\n    case llvm::Triple::Win32:\n      switch (Target.getEnvironment()) {\n      default:\n        if (Target.isOSBinFormatELF())\n          TC = std::make_unique<toolchains::Generic_ELF>(*this, Target, Args);\n        else if (Target.isOSBinFormatMachO())\n          TC = std::make_unique<toolchains::MachO>(*this, Target, Args);\n        else\n          TC = std::make_unique<toolchains::Generic_GCC>(*this, Target, Args);\n        break;\n      case llvm::Triple::GNU:\n        TC = std::make_unique<toolchains::MinGW>(*this, Target, Args);\n        break;\n      case llvm::Triple::Itanium:\n        TC = std::make_unique<toolchains::CrossWindowsToolChain>(*this, Target,\n                                                                  Args);\n        break;\n      case llvm::Triple::MSVC:\n      case llvm::Triple::UnknownEnvironment:\n        if (Args.getLastArgValue(options::OPT_fuse_ld_EQ)\n                .startswith_lower(\"bfd\"))\n          TC = std::make_unique<toolchains::CrossWindowsToolChain>(\n              *this, Target, Args);\n        else\n          TC =\n              std::make_unique<toolchains::MSVCToolChain>(*this, Target, Args);\n        break;\n      }\n      break;\n    case llvm::Triple::PS4:\n      TC = std::make_unique<toolchains::PS4CPU>(*this, Target, Args);\n      break;\n    case llvm::Triple::Contiki:\n      TC = std::make_unique<toolchains::Contiki>(*this, Target, Args);\n      break;\n    case llvm::Triple::Hurd:\n      TC = std::make_unique<toolchains::Hurd>(*this, Target, Args);\n      break;\n    case llvm::Triple::ZOS:\n      TC = std::make_unique<toolchains::ZOS>(*this, Target, Args);\n      break;\n    default:\n      // Of these targets, Hexagon is the only one that might have\n      // an OS of Linux, in which case it got handled above already.\n      switch (Target.getArch()) {\n      case llvm::Triple::tce:\n        TC = std::make_unique<toolchains::TCEToolChain>(*this, Target, Args);\n        break;\n      case llvm::Triple::tcele:\n        TC = std::make_unique<toolchains::TCELEToolChain>(*this, Target, Args);\n        break;\n      case llvm::Triple::hexagon:\n        TC = std::make_unique<toolchains::HexagonToolChain>(*this, Target,\n                                                             Args);\n        break;\n      case llvm::Triple::lanai:\n        TC = std::make_unique<toolchains::LanaiToolChain>(*this, Target, Args);\n        break;\n      case llvm::Triple::xcore:\n        TC = std::make_unique<toolchains::XCoreToolChain>(*this, Target, Args);\n        break;\n      case llvm::Triple::wasm32:\n      case llvm::Triple::wasm64:\n        TC = std::make_unique<toolchains::WebAssembly>(*this, Target, Args);\n        break;\n      case llvm::Triple::avr:\n        TC = std::make_unique<toolchains::AVRToolChain>(*this, Target, Args);\n        break;\n      case llvm::Triple::msp430:\n        TC =\n            std::make_unique<toolchains::MSP430ToolChain>(*this, Target, Args);\n        break;\n      case llvm::Triple::riscv32:\n      case llvm::Triple::riscv64:\n        if (toolchains::RISCVToolChain::hasGCCToolchain(*this, Args))\n          TC =\n              std::make_unique<toolchains::RISCVToolChain>(*this, Target, Args);\n        else\n          TC = std::make_unique<toolchains::BareMetal>(*this, Target, Args);\n        break;\n      case llvm::Triple::ve:\n        TC = std::make_unique<toolchains::VEToolChain>(*this, Target, Args);\n        break;\n      default:\n        if (Target.getVendor() == llvm::Triple::Myriad)\n          TC = std::make_unique<toolchains::MyriadToolChain>(*this, Target,\n                                                              Args);\n        else if (toolchains::BareMetal::handlesTarget(Target))\n          TC = std::make_unique<toolchains::BareMetal>(*this, Target, Args);\n        else if (Target.isOSBinFormatELF())\n          TC = std::make_unique<toolchains::Generic_ELF>(*this, Target, Args);\n        else if (Target.isOSBinFormatMachO())\n          TC = std::make_unique<toolchains::MachO>(*this, Target, Args);\n        else\n          TC = std::make_unique<toolchains::Generic_GCC>(*this, Target, Args);\n      }\n    }\n  }\n\n  // Intentionally omitted from the switch above: llvm::Triple::CUDA.  CUDA\n  // compiles always need two toolchains, the CUDA toolchain and the host\n  // toolchain.  So the only valid way to create a CUDA toolchain is via\n  // CreateOffloadingDeviceToolChains.\n\n  return *TC;\n}\n\nbool Driver::ShouldUseClangCompiler(const JobAction &JA) const {\n  // Say \"no\" if there is not exactly one input of a type clang understands.\n  if (JA.size() != 1 ||\n      !types::isAcceptedByClang((*JA.input_begin())->getType()))\n    return false;\n\n  // And say \"no\" if this is not a kind of action clang understands.\n  if (!isa<PreprocessJobAction>(JA) && !isa<PrecompileJobAction>(JA) &&\n      !isa<CompileJobAction>(JA) && !isa<BackendJobAction>(JA))\n    return false;\n\n  return true;\n}\n\nbool Driver::ShouldUseFlangCompiler(const JobAction &JA) const {\n  // Say \"no\" if there is not exactly one input of a type flang understands.\n  if (JA.size() != 1 ||\n      !types::isFortran((*JA.input_begin())->getType()))\n    return false;\n\n  // And say \"no\" if this is not a kind of action flang understands.\n  if (!isa<PreprocessJobAction>(JA) && !isa<CompileJobAction>(JA) && !isa<BackendJobAction>(JA))\n    return false;\n\n  return true;\n}\n\nbool Driver::ShouldEmitStaticLibrary(const ArgList &Args) const {\n  // Only emit static library if the flag is set explicitly.\n  if (Args.hasArg(options::OPT_emit_static_lib))\n    return true;\n  return false;\n}\n\n/// GetReleaseVersion - Parse (([0-9]+)(.([0-9]+)(.([0-9]+)?))?)? and return the\n/// grouped values as integers. Numbers which are not provided are set to 0.\n///\n/// \\return True if the entire string was parsed (9.2), or all groups were\n/// parsed (10.3.5extrastuff).\nbool Driver::GetReleaseVersion(StringRef Str, unsigned &Major, unsigned &Minor,\n                               unsigned &Micro, bool &HadExtra) {\n  HadExtra = false;\n\n  Major = Minor = Micro = 0;\n  if (Str.empty())\n    return false;\n\n  if (Str.consumeInteger(10, Major))\n    return false;\n  if (Str.empty())\n    return true;\n  if (Str[0] != '.')\n    return false;\n\n  Str = Str.drop_front(1);\n\n  if (Str.consumeInteger(10, Minor))\n    return false;\n  if (Str.empty())\n    return true;\n  if (Str[0] != '.')\n    return false;\n  Str = Str.drop_front(1);\n\n  if (Str.consumeInteger(10, Micro))\n    return false;\n  if (!Str.empty())\n    HadExtra = true;\n  return true;\n}\n\n/// Parse digits from a string \\p Str and fulfill \\p Digits with\n/// the parsed numbers. This method assumes that the max number of\n/// digits to look for is equal to Digits.size().\n///\n/// \\return True if the entire string was parsed and there are\n/// no extra characters remaining at the end.\nbool Driver::GetReleaseVersion(StringRef Str,\n                               MutableArrayRef<unsigned> Digits) {\n  if (Str.empty())\n    return false;\n\n  unsigned CurDigit = 0;\n  while (CurDigit < Digits.size()) {\n    unsigned Digit;\n    if (Str.consumeInteger(10, Digit))\n      return false;\n    Digits[CurDigit] = Digit;\n    if (Str.empty())\n      return true;\n    if (Str[0] != '.')\n      return false;\n    Str = Str.drop_front(1);\n    CurDigit++;\n  }\n\n  // More digits than requested, bail out...\n  return false;\n}\n\nstd::pair<unsigned, unsigned>\nDriver::getIncludeExcludeOptionFlagMasks(bool IsClCompatMode) const {\n  unsigned IncludedFlagsBitmask = 0;\n  unsigned ExcludedFlagsBitmask = options::NoDriverOption;\n\n  if (IsClCompatMode) {\n    // Include CL and Core options.\n    IncludedFlagsBitmask |= options::CLOption;\n    IncludedFlagsBitmask |= options::CoreOption;\n  } else {\n    ExcludedFlagsBitmask |= options::CLOption;\n  }\n\n  return std::make_pair(IncludedFlagsBitmask, ExcludedFlagsBitmask);\n}\n\nbool clang::driver::isOptimizationLevelFast(const ArgList &Args) {\n  return Args.hasFlag(options::OPT_Ofast, options::OPT_O_Group, false);\n}\n\nbool clang::driver::willEmitRemarks(const ArgList &Args) {\n  // -fsave-optimization-record enables it.\n  if (Args.hasFlag(options::OPT_fsave_optimization_record,\n                   options::OPT_fno_save_optimization_record, false))\n    return true;\n\n  // -fsave-optimization-record=<format> enables it as well.\n  if (Args.hasFlag(options::OPT_fsave_optimization_record_EQ,\n                   options::OPT_fno_save_optimization_record, false))\n    return true;\n\n  // -foptimization-record-file alone enables it too.\n  if (Args.hasFlag(options::OPT_foptimization_record_file_EQ,\n                   options::OPT_fno_save_optimization_record, false))\n    return true;\n\n  // -foptimization-record-passes alone enables it too.\n  if (Args.hasFlag(options::OPT_foptimization_record_passes_EQ,\n                   options::OPT_fno_save_optimization_record, false))\n    return true;\n  return false;\n}\n"}, "1": {"id": 1, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Driver/Driver.h", "content": "//===--- Driver.h - Clang GCC Compatible Driver -----------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_DRIVER_DRIVER_H\n#define LLVM_CLANG_DRIVER_DRIVER_H\n\n#include \"clang/Basic/Diagnostic.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Driver/Action.h\"\n#include \"clang/Driver/Options.h\"\n#include \"clang/Driver/Phases.h\"\n#include \"clang/Driver/ToolChain.h\"\n#include \"clang/Driver/Types.h\"\n#include \"clang/Driver/Util.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Option/Arg.h\"\n#include \"llvm/Option/ArgList.h\"\n#include \"llvm/Support/StringSaver.h\"\n\n#include <list>\n#include <map>\n#include <string>\n\nnamespace llvm {\nclass Triple;\nnamespace vfs {\nclass FileSystem;\n}\n} // namespace llvm\n\nnamespace clang {\n\nnamespace driver {\n\n  class Command;\n  class Compilation;\n  class InputInfo;\n  class JobList;\n  class JobAction;\n  class SanitizerArgs;\n  class ToolChain;\n\n/// Describes the kind of LTO mode selected via -f(no-)?lto(=.*)? options.\nenum LTOKind {\n  LTOK_None,\n  LTOK_Full,\n  LTOK_Thin,\n  LTOK_Unknown\n};\n\n/// Driver - Encapsulate logic for constructing compilation processes\n/// from a set of gcc-driver-like command line arguments.\nclass Driver {\n  DiagnosticsEngine &Diags;\n\n  IntrusiveRefCntPtr<llvm::vfs::FileSystem> VFS;\n\n  enum DriverMode {\n    GCCMode,\n    GXXMode,\n    CPPMode,\n    CLMode,\n    FlangMode\n  } Mode;\n\n  enum SaveTempsMode {\n    SaveTempsNone,\n    SaveTempsCwd,\n    SaveTempsObj\n  } SaveTemps;\n\n  enum BitcodeEmbedMode {\n    EmbedNone,\n    EmbedMarker,\n    EmbedBitcode\n  } BitcodeEmbed;\n\n  /// LTO mode selected via -f(no-)?lto(=.*)? options.\n  LTOKind LTOMode;\n\npublic:\n  enum OpenMPRuntimeKind {\n    /// An unknown OpenMP runtime. We can't generate effective OpenMP code\n    /// without knowing what runtime to target.\n    OMPRT_Unknown,\n\n    /// The LLVM OpenMP runtime. When completed and integrated, this will become\n    /// the default for Clang.\n    OMPRT_OMP,\n\n    /// The GNU OpenMP runtime. Clang doesn't support generating OpenMP code for\n    /// this runtime but can swallow the pragmas, and find and link against the\n    /// runtime library itself.\n    OMPRT_GOMP,\n\n    /// The legacy name for the LLVM OpenMP runtime from when it was the Intel\n    /// OpenMP runtime. We support this mode for users with existing\n    /// dependencies on this runtime library name.\n    OMPRT_IOMP5\n  };\n\n  // Diag - Forwarding function for diagnostics.\n  DiagnosticBuilder Diag(unsigned DiagID) const {\n    return Diags.Report(DiagID);\n  }\n\n  // FIXME: Privatize once interface is stable.\npublic:\n  /// The name the driver was invoked as.\n  std::string Name;\n\n  /// The path the driver executable was in, as invoked from the\n  /// command line.\n  std::string Dir;\n\n  /// The original path to the clang executable.\n  std::string ClangExecutable;\n\n  /// Target and driver mode components extracted from clang executable name.\n  ParsedClangName ClangNameParts;\n\n  /// The path to the installed clang directory, if any.\n  std::string InstalledDir;\n\n  /// The path to the compiler resource directory.\n  std::string ResourceDir;\n\n  /// System directory for config files.\n  std::string SystemConfigDir;\n\n  /// User directory for config files.\n  std::string UserConfigDir;\n\n  /// A prefix directory used to emulate a limited subset of GCC's '-Bprefix'\n  /// functionality.\n  /// FIXME: This type of customization should be removed in favor of the\n  /// universal driver when it is ready.\n  typedef SmallVector<std::string, 4> prefix_list;\n  prefix_list PrefixDirs;\n\n  /// sysroot, if present\n  std::string SysRoot;\n\n  /// Dynamic loader prefix, if present\n  std::string DyldPrefix;\n\n  /// Driver title to use with help.\n  std::string DriverTitle;\n\n  /// Information about the host which can be overridden by the user.\n  std::string HostBits, HostMachine, HostSystem, HostRelease;\n\n  /// The file to log CC_PRINT_OPTIONS output to, if enabled.\n  const char *CCPrintOptionsFilename;\n\n  /// The file to log CC_PRINT_HEADERS output to, if enabled.\n  const char *CCPrintHeadersFilename;\n\n  /// The file to log CC_LOG_DIAGNOSTICS output to, if enabled.\n  const char *CCLogDiagnosticsFilename;\n\n  /// A list of inputs and their types for the given arguments.\n  typedef SmallVector<std::pair<types::ID, const llvm::opt::Arg *>, 16>\n      InputList;\n\n  /// Whether the driver should follow g++ like behavior.\n  bool CCCIsCXX() const { return Mode == GXXMode; }\n\n  /// Whether the driver is just the preprocessor.\n  bool CCCIsCPP() const { return Mode == CPPMode; }\n\n  /// Whether the driver should follow gcc like behavior.\n  bool CCCIsCC() const { return Mode == GCCMode; }\n\n  /// Whether the driver should follow cl.exe like behavior.\n  bool IsCLMode() const { return Mode == CLMode; }\n\n  /// Whether the driver should invoke flang for fortran inputs.\n  /// Other modes fall back to calling gcc which in turn calls gfortran.\n  bool IsFlangMode() const { return Mode == FlangMode; }\n\n  /// Only print tool bindings, don't build any jobs.\n  unsigned CCCPrintBindings : 1;\n\n  /// Set CC_PRINT_OPTIONS mode, which is like -v but logs the commands to\n  /// CCPrintOptionsFilename or to stderr.\n  unsigned CCPrintOptions : 1;\n\n  /// Set CC_PRINT_HEADERS mode, which causes the frontend to log header include\n  /// information to CCPrintHeadersFilename or to stderr.\n  unsigned CCPrintHeaders : 1;\n\n  /// Set CC_LOG_DIAGNOSTICS mode, which causes the frontend to log diagnostics\n  /// to CCLogDiagnosticsFilename or to stderr, in a stable machine readable\n  /// format.\n  unsigned CCLogDiagnostics : 1;\n\n  /// Whether the driver is generating diagnostics for debugging purposes.\n  unsigned CCGenDiagnostics : 1;\n\n  /// Pointer to the ExecuteCC1Tool function, if available.\n  /// When the clangDriver lib is used through clang.exe, this provides a\n  /// shortcut for executing the -cc1 command-line directly, in the same\n  /// process.\n  typedef int (*CC1ToolFunc)(SmallVectorImpl<const char *> &ArgV);\n  CC1ToolFunc CC1Main = nullptr;\n\nprivate:\n  /// Raw target triple.\n  std::string TargetTriple;\n\n  /// Name to use when invoking gcc/g++.\n  std::string CCCGenericGCCName;\n\n  /// Name of configuration file if used.\n  std::string ConfigFile;\n\n  /// Allocator for string saver.\n  llvm::BumpPtrAllocator Alloc;\n\n  /// Object that stores strings read from configuration file.\n  llvm::StringSaver Saver;\n\n  /// Arguments originated from configuration file.\n  std::unique_ptr<llvm::opt::InputArgList> CfgOptions;\n\n  /// Arguments originated from command line.\n  std::unique_ptr<llvm::opt::InputArgList> CLOptions;\n\n  /// Whether to check that input files exist when constructing compilation\n  /// jobs.\n  unsigned CheckInputsExist : 1;\n\npublic:\n  /// Force clang to emit reproducer for driver invocation. This is enabled\n  /// indirectly by setting FORCE_CLANG_DIAGNOSTICS_CRASH environment variable\n  /// or when using the -gen-reproducer driver flag.\n  unsigned GenReproducer : 1;\n\nprivate:\n  /// Certain options suppress the 'no input files' warning.\n  unsigned SuppressMissingInputWarning : 1;\n\n  /// Cache of all the ToolChains in use by the driver.\n  ///\n  /// This maps from the string representation of a triple to a ToolChain\n  /// created targeting that triple. The driver owns all the ToolChain objects\n  /// stored in it, and will clean them up when torn down.\n  mutable llvm::StringMap<std::unique_ptr<ToolChain>> ToolChains;\n\nprivate:\n  /// TranslateInputArgs - Create a new derived argument list from the input\n  /// arguments, after applying the standard argument translations.\n  llvm::opt::DerivedArgList *\n  TranslateInputArgs(const llvm::opt::InputArgList &Args) const;\n\n  // getFinalPhase - Determine which compilation mode we are in and record\n  // which option we used to determine the final phase.\n  // TODO: Much of what getFinalPhase returns are not actually true compiler\n  //       modes. Fold this functionality into Types::getCompilationPhases and\n  //       handleArguments.\n  phases::ID getFinalPhase(const llvm::opt::DerivedArgList &DAL,\n                           llvm::opt::Arg **FinalPhaseArg = nullptr) const;\n\n  // handleArguments - All code related to claiming and printing diagnostics\n  // related to arguments to the driver are done here.\n  void handleArguments(Compilation &C, llvm::opt::DerivedArgList &Args,\n                       const InputList &Inputs, ActionList &Actions) const;\n\n  // Before executing jobs, sets up response files for commands that need them.\n  void setUpResponseFiles(Compilation &C, Command &Cmd);\n\n  void generatePrefixedToolNames(StringRef Tool, const ToolChain &TC,\n                                 SmallVectorImpl<std::string> &Names) const;\n\n  /// Find the appropriate .crash diagonostic file for the child crash\n  /// under this driver and copy it out to a temporary destination with the\n  /// other reproducer related files (.sh, .cache, etc). If not found, suggest a\n  /// directory for the user to look at.\n  ///\n  /// \\param ReproCrashFilename The file path to copy the .crash to.\n  /// \\param CrashDiagDir       The suggested directory for the user to look at\n  ///                           in case the search or copy fails.\n  ///\n  /// \\returns If the .crash is found and successfully copied return true,\n  /// otherwise false and return the suggested directory in \\p CrashDiagDir.\n  bool getCrashDiagnosticFile(StringRef ReproCrashFilename,\n                              SmallString<128> &CrashDiagDir);\n\npublic:\n\n  /// Takes the path to a binary that's either in bin/ or lib/ and returns\n  /// the path to clang's resource directory.\n  static std::string GetResourcesPath(StringRef BinaryPath,\n                                      StringRef CustomResourceDir = \"\");\n\n  Driver(StringRef ClangExecutable, StringRef TargetTriple,\n         DiagnosticsEngine &Diags, std::string Title = \"clang LLVM compiler\",\n         IntrusiveRefCntPtr<llvm::vfs::FileSystem> VFS = nullptr);\n\n  /// @name Accessors\n  /// @{\n\n  /// Name to use when invoking gcc/g++.\n  const std::string &getCCCGenericGCCName() const { return CCCGenericGCCName; }\n\n  const std::string &getConfigFile() const { return ConfigFile; }\n\n  const llvm::opt::OptTable &getOpts() const { return getDriverOptTable(); }\n\n  DiagnosticsEngine &getDiags() const { return Diags; }\n\n  llvm::vfs::FileSystem &getVFS() const { return *VFS; }\n\n  bool getCheckInputsExist() const { return CheckInputsExist; }\n\n  void setCheckInputsExist(bool Value) { CheckInputsExist = Value; }\n\n  void setTargetAndMode(const ParsedClangName &TM) { ClangNameParts = TM; }\n\n  const std::string &getTitle() { return DriverTitle; }\n  void setTitle(std::string Value) { DriverTitle = std::move(Value); }\n\n  std::string getTargetTriple() const { return TargetTriple; }\n\n  /// Get the path to the main clang executable.\n  const char *getClangProgramPath() const {\n    return ClangExecutable.c_str();\n  }\n\n  /// Get the path to where the clang executable was installed.\n  const char *getInstalledDir() const {\n    if (!InstalledDir.empty())\n      return InstalledDir.c_str();\n    return Dir.c_str();\n  }\n  void setInstalledDir(StringRef Value) { InstalledDir = std::string(Value); }\n\n  bool isSaveTempsEnabled() const { return SaveTemps != SaveTempsNone; }\n  bool isSaveTempsObj() const { return SaveTemps == SaveTempsObj; }\n\n  bool embedBitcodeEnabled() const { return BitcodeEmbed != EmbedNone; }\n  bool embedBitcodeInObject() const { return (BitcodeEmbed == EmbedBitcode); }\n  bool embedBitcodeMarkerOnly() const { return (BitcodeEmbed == EmbedMarker); }\n\n  /// Compute the desired OpenMP runtime from the flags provided.\n  OpenMPRuntimeKind getOpenMPRuntime(const llvm::opt::ArgList &Args) const;\n\n  /// @}\n  /// @name Primary Functionality\n  /// @{\n\n  /// CreateOffloadingDeviceToolChains - create all the toolchains required to\n  /// support offloading devices given the programming models specified in the\n  /// current compilation. Also, update the host tool chain kind accordingly.\n  void CreateOffloadingDeviceToolChains(Compilation &C, InputList &Inputs);\n\n  /// BuildCompilation - Construct a compilation object for a command\n  /// line argument vector.\n  ///\n  /// \\return A compilation, or 0 if none was built for the given\n  /// argument vector. A null return value does not necessarily\n  /// indicate an error condition, the diagnostics should be queried\n  /// to determine if an error occurred.\n  Compilation *BuildCompilation(ArrayRef<const char *> Args);\n\n  /// @name Driver Steps\n  /// @{\n\n  /// ParseDriverMode - Look for and handle the driver mode option in Args.\n  void ParseDriverMode(StringRef ProgramName, ArrayRef<const char *> Args);\n\n  /// ParseArgStrings - Parse the given list of strings into an\n  /// ArgList.\n  llvm::opt::InputArgList ParseArgStrings(ArrayRef<const char *> Args,\n                                          bool IsClCompatMode,\n                                          bool &ContainsError);\n\n  /// BuildInputs - Construct the list of inputs and their types from\n  /// the given arguments.\n  ///\n  /// \\param TC - The default host tool chain.\n  /// \\param Args - The input arguments.\n  /// \\param Inputs - The list to store the resulting compilation\n  /// inputs onto.\n  void BuildInputs(const ToolChain &TC, llvm::opt::DerivedArgList &Args,\n                   InputList &Inputs) const;\n\n  /// BuildActions - Construct the list of actions to perform for the\n  /// given arguments, which are only done for a single architecture.\n  ///\n  /// \\param C - The compilation that is being built.\n  /// \\param Args - The input arguments.\n  /// \\param Actions - The list to store the resulting actions onto.\n  void BuildActions(Compilation &C, llvm::opt::DerivedArgList &Args,\n                    const InputList &Inputs, ActionList &Actions) const;\n\n  /// BuildUniversalActions - Construct the list of actions to perform\n  /// for the given arguments, which may require a universal build.\n  ///\n  /// \\param C - The compilation that is being built.\n  /// \\param TC - The default host tool chain.\n  void BuildUniversalActions(Compilation &C, const ToolChain &TC,\n                             const InputList &BAInputs) const;\n\n  /// Check that the file referenced by Value exists. If it doesn't,\n  /// issue a diagnostic and return false.\n  /// If TypoCorrect is true and the file does not exist, see if it looks\n  /// like a likely typo for a flag and if so print a \"did you mean\" blurb.\n  bool DiagnoseInputExistence(const llvm::opt::DerivedArgList &Args,\n                              StringRef Value, types::ID Ty,\n                              bool TypoCorrect) const;\n\n  /// BuildJobs - Bind actions to concrete tools and translate\n  /// arguments to form the list of jobs to run.\n  ///\n  /// \\param C - The compilation that is being built.\n  void BuildJobs(Compilation &C) const;\n\n  /// ExecuteCompilation - Execute the compilation according to the command line\n  /// arguments and return an appropriate exit code.\n  ///\n  /// This routine handles additional processing that must be done in addition\n  /// to just running the subprocesses, for example reporting errors, setting\n  /// up response files, removing temporary files, etc.\n  int ExecuteCompilation(Compilation &C,\n     SmallVectorImpl< std::pair<int, const Command *> > &FailingCommands);\n\n  /// Contains the files in the compilation diagnostic report generated by\n  /// generateCompilationDiagnostics.\n  struct CompilationDiagnosticReport {\n    llvm::SmallVector<std::string, 4> TemporaryFiles;\n  };\n\n  /// generateCompilationDiagnostics - Generate diagnostics information\n  /// including preprocessed source file(s).\n  ///\n  void generateCompilationDiagnostics(\n      Compilation &C, const Command &FailingCommand,\n      StringRef AdditionalInformation = \"\",\n      CompilationDiagnosticReport *GeneratedReport = nullptr);\n\n  /// @}\n  /// @name Helper Methods\n  /// @{\n\n  /// PrintActions - Print the list of actions.\n  void PrintActions(const Compilation &C) const;\n\n  /// PrintHelp - Print the help text.\n  ///\n  /// \\param ShowHidden - Show hidden options.\n  void PrintHelp(bool ShowHidden) const;\n\n  /// PrintVersion - Print the driver version.\n  void PrintVersion(const Compilation &C, raw_ostream &OS) const;\n\n  /// GetFilePath - Lookup \\p Name in the list of file search paths.\n  ///\n  /// \\param TC - The tool chain for additional information on\n  /// directories to search.\n  //\n  // FIXME: This should be in CompilationInfo.\n  std::string GetFilePath(StringRef Name, const ToolChain &TC) const;\n\n  /// GetProgramPath - Lookup \\p Name in the list of program search paths.\n  ///\n  /// \\param TC - The provided tool chain for additional information on\n  /// directories to search.\n  //\n  // FIXME: This should be in CompilationInfo.\n  std::string GetProgramPath(StringRef Name, const ToolChain &TC) const;\n\n  /// HandleAutocompletions - Handle --autocomplete by searching and printing\n  /// possible flags, descriptions, and its arguments.\n  void HandleAutocompletions(StringRef PassedFlags) const;\n\n  /// HandleImmediateArgs - Handle any arguments which should be\n  /// treated before building actions or binding tools.\n  ///\n  /// \\return Whether any compilation should be built for this\n  /// invocation.\n  bool HandleImmediateArgs(const Compilation &C);\n\n  /// ConstructAction - Construct the appropriate action to do for\n  /// \\p Phase on the \\p Input, taking in to account arguments\n  /// like -fsyntax-only or --analyze.\n  Action *ConstructPhaseAction(\n      Compilation &C, const llvm::opt::ArgList &Args, phases::ID Phase,\n      Action *Input,\n      Action::OffloadKind TargetDeviceOffloadKind = Action::OFK_None) const;\n\n  /// BuildJobsForAction - Construct the jobs to perform for the action \\p A and\n  /// return an InputInfo for the result of running \\p A.  Will only construct\n  /// jobs for a given (Action, ToolChain, BoundArch, DeviceKind) tuple once.\n  InputInfo\n  BuildJobsForAction(Compilation &C, const Action *A, const ToolChain *TC,\n                     StringRef BoundArch, bool AtTopLevel, bool MultipleArchs,\n                     const char *LinkingOutput,\n                     std::map<std::pair<const Action *, std::string>, InputInfo>\n                         &CachedResults,\n                     Action::OffloadKind TargetDeviceOffloadKind) const;\n\n  /// Returns the default name for linked images (e.g., \"a.out\").\n  const char *getDefaultImageName() const;\n\n  /// GetNamedOutputPath - Return the name to use for the output of\n  /// the action \\p JA. The result is appended to the compilation's\n  /// list of temporary or result files, as appropriate.\n  ///\n  /// \\param C - The compilation.\n  /// \\param JA - The action of interest.\n  /// \\param BaseInput - The original input file that this action was\n  /// triggered by.\n  /// \\param BoundArch - The bound architecture.\n  /// \\param AtTopLevel - Whether this is a \"top-level\" action.\n  /// \\param MultipleArchs - Whether multiple -arch options were supplied.\n  /// \\param NormalizedTriple - The normalized triple of the relevant target.\n  const char *GetNamedOutputPath(Compilation &C, const JobAction &JA,\n                                 const char *BaseInput, StringRef BoundArch,\n                                 bool AtTopLevel, bool MultipleArchs,\n                                 StringRef NormalizedTriple) const;\n\n  /// GetTemporaryPath - Return the pathname of a temporary file to use\n  /// as part of compilation; the file will have the given prefix and suffix.\n  ///\n  /// GCC goes to extra lengths here to be a bit more robust.\n  std::string GetTemporaryPath(StringRef Prefix, StringRef Suffix) const;\n\n  /// GetTemporaryDirectory - Return the pathname of a temporary directory to\n  /// use as part of compilation; the directory will have the given prefix.\n  std::string GetTemporaryDirectory(StringRef Prefix) const;\n\n  /// Return the pathname of the pch file in clang-cl mode.\n  std::string GetClPchPath(Compilation &C, StringRef BaseName) const;\n\n  /// ShouldUseClangCompiler - Should the clang compiler be used to\n  /// handle this action.\n  bool ShouldUseClangCompiler(const JobAction &JA) const;\n\n  /// ShouldUseFlangCompiler - Should the flang compiler be used to\n  /// handle this action.\n  bool ShouldUseFlangCompiler(const JobAction &JA) const;\n\n  /// ShouldEmitStaticLibrary - Should the linker emit a static library.\n  bool ShouldEmitStaticLibrary(const llvm::opt::ArgList &Args) const;\n\n  /// Returns true if we are performing any kind of LTO.\n  bool isUsingLTO() const { return LTOMode != LTOK_None; }\n\n  /// Get the specific kind of LTO being performed.\n  LTOKind getLTOMode() const { return LTOMode; }\n\nprivate:\n\n  /// Tries to load options from configuration file.\n  ///\n  /// \\returns true if error occurred.\n  bool loadConfigFile();\n\n  /// Read options from the specified file.\n  ///\n  /// \\param [in] FileName File to read.\n  /// \\returns true, if error occurred while reading.\n  bool readConfigFile(StringRef FileName);\n\n  /// Set the driver mode (cl, gcc, etc) from an option string of the form\n  /// --driver-mode=<mode>.\n  void setDriverModeFromOption(StringRef Opt);\n\n  /// Parse the \\p Args list for LTO options and record the type of LTO\n  /// compilation based on which -f(no-)?lto(=.*)? option occurs last.\n  void setLTOMode(const llvm::opt::ArgList &Args);\n\n  /// Retrieves a ToolChain for a particular \\p Target triple.\n  ///\n  /// Will cache ToolChains for the life of the driver object, and create them\n  /// on-demand.\n  const ToolChain &getToolChain(const llvm::opt::ArgList &Args,\n                                const llvm::Triple &Target) const;\n\n  /// @}\n\n  /// Get bitmasks for which option flags to include and exclude based on\n  /// the driver mode.\n  std::pair<unsigned, unsigned> getIncludeExcludeOptionFlagMasks(bool IsClCompatMode) const;\n\n  /// Helper used in BuildJobsForAction.  Doesn't use the cache when building\n  /// jobs specifically for the given action, but will use the cache when\n  /// building jobs for the Action's inputs.\n  InputInfo BuildJobsForActionNoCache(\n      Compilation &C, const Action *A, const ToolChain *TC, StringRef BoundArch,\n      bool AtTopLevel, bool MultipleArchs, const char *LinkingOutput,\n      std::map<std::pair<const Action *, std::string>, InputInfo>\n          &CachedResults,\n      Action::OffloadKind TargetDeviceOffloadKind) const;\n\npublic:\n  /// GetReleaseVersion - Parse (([0-9]+)(.([0-9]+)(.([0-9]+)?))?)? and\n  /// return the grouped values as integers. Numbers which are not\n  /// provided are set to 0.\n  ///\n  /// \\return True if the entire string was parsed (9.2), or all\n  /// groups were parsed (10.3.5extrastuff). HadExtra is true if all\n  /// groups were parsed but extra characters remain at the end.\n  static bool GetReleaseVersion(StringRef Str, unsigned &Major, unsigned &Minor,\n                                unsigned &Micro, bool &HadExtra);\n\n  /// Parse digits from a string \\p Str and fulfill \\p Digits with\n  /// the parsed numbers. This method assumes that the max number of\n  /// digits to look for is equal to Digits.size().\n  ///\n  /// \\return True if the entire string was parsed and there are\n  /// no extra characters remaining at the end.\n  static bool GetReleaseVersion(StringRef Str,\n                                MutableArrayRef<unsigned> Digits);\n  /// Compute the default -fmodule-cache-path.\n  /// \\return True if the system provides a default cache directory.\n  static bool getDefaultModuleCachePath(SmallVectorImpl<char> &Result);\n};\n\n/// \\return True if the last defined optimization level is -Ofast.\n/// And False otherwise.\nbool isOptimizationLevelFast(const llvm::opt::ArgList &Args);\n\n/// \\return True if the argument combination will end up generating remarks.\nbool willEmitRemarks(const llvm::opt::ArgList &Args);\n\n} // end namespace driver\n} // end namespace clang\n\n#endif\n"}}, "reports": [{"events": [{"location": {"col": 22, "file": 2, "line": 993}, "message": "the definition seen here"}, {"location": {"col": 16, "file": 1, "line": 371}, "message": "differing parameters are named here: ('Args'), in definition: ('ArgList')"}, {"location": {"col": 16, "file": 1, "line": 371}, "message": "function 'clang::driver::Driver::BuildCompilation' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Driver/Driver.h", "reportHash": "8277636987a1a5e50af92f135778404a", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 21, "file": 2, "line": 4753}, "message": "the definition seen here"}, {"location": {"col": 15, "file": 1, "line": 525}, "message": "differing parameters are named here: ('NormalizedTriple'), in definition: ('OffloadingPrefix')"}, {"location": {"col": 15, "file": 1, "line": 525}, "message": "function 'clang::driver::Driver::GetNamedOutputPath' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Driver/Driver.h", "reportHash": "3d61ec7fbd5d6279e931f3d0377f6ed3", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
