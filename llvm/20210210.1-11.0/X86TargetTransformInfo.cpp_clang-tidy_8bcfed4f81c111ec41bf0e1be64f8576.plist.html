<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"4": {"id": 4, "path": "/home/vsts/work/1/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp", "content": "//===-- X86TargetTransformInfo.cpp - X86 specific TTI pass ----------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n/// \\file\n/// This file implements a TargetTransformInfo analysis pass specific to the\n/// X86 target machine. It uses the target's detailed information to provide\n/// more precise answers to certain TTI queries, while letting the target\n/// independent and default TTI implementations handle the rest.\n///\n//===----------------------------------------------------------------------===//\n/// About Cost Model numbers used below it's necessary to say the following:\n/// the numbers correspond to some \"generic\" X86 CPU instead of usage of\n/// concrete CPU model. Usually the numbers correspond to CPU where the feature\n/// apeared at the first time. For example, if we do Subtarget.hasSSE42() in\n/// the lookups below the cost is based on Nehalem as that was the first CPU\n/// to support that feature level and thus has most likely the worst case cost.\n/// Some examples of other technologies/CPUs:\n///   SSE 3   - Pentium4 / Athlon64\n///   SSE 4.1 - Penryn\n///   SSE 4.2 - Nehalem\n///   AVX     - Sandy Bridge\n///   AVX2    - Haswell\n///   AVX-512 - Xeon Phi / Skylake\n/// And some examples of instruction target dependent costs (latency)\n///                   divss     sqrtss          rsqrtss\n///   AMD K7            11-16     19              3\n///   Piledriver        9-24      13-15           5\n///   Jaguar            14        16              2\n///   Pentium II,III    18        30              2\n///   Nehalem           7-14      7-18            3\n///   Haswell           10-13     11              5\n/// TODO: Develop and implement  the target dependent cost model and\n/// specialize cost numbers for different Cost Model Targets such as throughput,\n/// code size, latency and uop count.\n//===----------------------------------------------------------------------===//\n\n#include \"X86TargetTransformInfo.h\"\n#include \"llvm/Analysis/TargetTransformInfo.h\"\n#include \"llvm/CodeGen/BasicTTIImpl.h\"\n#include \"llvm/CodeGen/CostTable.h\"\n#include \"llvm/CodeGen/TargetLowering.h\"\n#include \"llvm/IR/IntrinsicInst.h\"\n#include \"llvm/Support/Debug.h\"\n\nusing namespace llvm;\n\n#define DEBUG_TYPE \"x86tti\"\n\n//===----------------------------------------------------------------------===//\n//\n// X86 cost model.\n//\n//===----------------------------------------------------------------------===//\n\nTargetTransformInfo::PopcntSupportKind\nX86TTIImpl::getPopcntSupport(unsigned TyWidth) {\n  assert(isPowerOf2_32(TyWidth) && \"Ty width must be power of 2\");\n  // TODO: Currently the __builtin_popcount() implementation using SSE3\n  //   instructions is inefficient. Once the problem is fixed, we should\n  //   call ST->hasSSE3() instead of ST->hasPOPCNT().\n  return ST->hasPOPCNT() ? TTI::PSK_FastHardware : TTI::PSK_Software;\n}\n\nllvm::Optional<unsigned> X86TTIImpl::getCacheSize(\n  TargetTransformInfo::CacheLevel Level) const {\n  switch (Level) {\n  case TargetTransformInfo::CacheLevel::L1D:\n    //   - Penryn\n    //   - Nehalem\n    //   - Westmere\n    //   - Sandy Bridge\n    //   - Ivy Bridge\n    //   - Haswell\n    //   - Broadwell\n    //   - Skylake\n    //   - Kabylake\n    return 32 * 1024;  //  32 KByte\n  case TargetTransformInfo::CacheLevel::L2D:\n    //   - Penryn\n    //   - Nehalem\n    //   - Westmere\n    //   - Sandy Bridge\n    //   - Ivy Bridge\n    //   - Haswell\n    //   - Broadwell\n    //   - Skylake\n    //   - Kabylake\n    return 256 * 1024; // 256 KByte\n  }\n\n  llvm_unreachable(\"Unknown TargetTransformInfo::CacheLevel\");\n}\n\nllvm::Optional<unsigned> X86TTIImpl::getCacheAssociativity(\n  TargetTransformInfo::CacheLevel Level) const {\n  //   - Penryn\n  //   - Nehalem\n  //   - Westmere\n  //   - Sandy Bridge\n  //   - Ivy Bridge\n  //   - Haswell\n  //   - Broadwell\n  //   - Skylake\n  //   - Kabylake\n  switch (Level) {\n  case TargetTransformInfo::CacheLevel::L1D:\n    LLVM_FALLTHROUGH;\n  case TargetTransformInfo::CacheLevel::L2D:\n    return 8;\n  }\n\n  llvm_unreachable(\"Unknown TargetTransformInfo::CacheLevel\");\n}\n\nunsigned X86TTIImpl::getNumberOfRegisters(unsigned ClassID) const {\n  bool Vector = (ClassID == 1);\n  if (Vector && !ST->hasSSE1())\n    return 0;\n\n  if (ST->is64Bit()) {\n    if (Vector && ST->hasAVX512())\n      return 32;\n    return 16;\n  }\n  return 8;\n}\n\nunsigned X86TTIImpl::getRegisterBitWidth(bool Vector) const {\n  unsigned PreferVectorWidth = ST->getPreferVectorWidth();\n  if (Vector) {\n    if (ST->hasAVX512() && PreferVectorWidth >= 512)\n      return 512;\n    if (ST->hasAVX() && PreferVectorWidth >= 256)\n      return 256;\n    if (ST->hasSSE1() && PreferVectorWidth >= 128)\n      return 128;\n    return 0;\n  }\n\n  if (ST->is64Bit())\n    return 64;\n\n  return 32;\n}\n\nunsigned X86TTIImpl::getLoadStoreVecRegBitWidth(unsigned) const {\n  return getRegisterBitWidth(true);\n}\n\nunsigned X86TTIImpl::getMaxInterleaveFactor(unsigned VF) {\n  // If the loop will not be vectorized, don't interleave the loop.\n  // Let regular unroll to unroll the loop, which saves the overflow\n  // check and memory check cost.\n  if (VF == 1)\n    return 1;\n\n  if (ST->isAtom())\n    return 1;\n\n  // Sandybridge and Haswell have multiple execution ports and pipelined\n  // vector units.\n  if (ST->hasAVX())\n    return 4;\n\n  return 2;\n}\n\nint X86TTIImpl::getArithmeticInstrCost(unsigned Opcode, Type *Ty,\n                                       TTI::TargetCostKind CostKind,\n                                       TTI::OperandValueKind Op1Info,\n                                       TTI::OperandValueKind Op2Info,\n                                       TTI::OperandValueProperties Opd1PropInfo,\n                                       TTI::OperandValueProperties Opd2PropInfo,\n                                       ArrayRef<const Value *> Args,\n                                       const Instruction *CxtI) {\n  // TODO: Handle more cost kinds.\n  if (CostKind != TTI::TCK_RecipThroughput)\n    return BaseT::getArithmeticInstrCost(Opcode, Ty, CostKind, Op1Info,\n                                         Op2Info, Opd1PropInfo,\n                                         Opd2PropInfo, Args, CxtI);\n  // Legalize the type.\n  std::pair<int, MVT> LT = TLI->getTypeLegalizationCost(DL, Ty);\n\n  int ISD = TLI->InstructionOpcodeToISD(Opcode);\n  assert(ISD && \"Invalid opcode\");\n\n  static const CostTblEntry GLMCostTable[] = {\n    { ISD::FDIV,  MVT::f32,   18 }, // divss\n    { ISD::FDIV,  MVT::v4f32, 35 }, // divps\n    { ISD::FDIV,  MVT::f64,   33 }, // divsd\n    { ISD::FDIV,  MVT::v2f64, 65 }, // divpd\n  };\n\n  if (ST->useGLMDivSqrtCosts())\n    if (const auto *Entry = CostTableLookup(GLMCostTable, ISD,\n                                            LT.second))\n      return LT.first * Entry->Cost;\n\n  static const CostTblEntry SLMCostTable[] = {\n    { ISD::MUL,   MVT::v4i32, 11 }, // pmulld\n    { ISD::MUL,   MVT::v8i16, 2  }, // pmullw\n    { ISD::MUL,   MVT::v16i8, 14 }, // extend/pmullw/trunc sequence.\n    { ISD::FMUL,  MVT::f64,   2  }, // mulsd\n    { ISD::FMUL,  MVT::v2f64, 4  }, // mulpd\n    { ISD::FMUL,  MVT::v4f32, 2  }, // mulps\n    { ISD::FDIV,  MVT::f32,   17 }, // divss\n    { ISD::FDIV,  MVT::v4f32, 39 }, // divps\n    { ISD::FDIV,  MVT::f64,   32 }, // divsd\n    { ISD::FDIV,  MVT::v2f64, 69 }, // divpd\n    { ISD::FADD,  MVT::v2f64, 2  }, // addpd\n    { ISD::FSUB,  MVT::v2f64, 2  }, // subpd\n    // v2i64/v4i64 mul is custom lowered as a series of long:\n    // multiplies(3), shifts(3) and adds(2)\n    // slm muldq version throughput is 2 and addq throughput 4\n    // thus: 3X2 (muldq throughput) + 3X1 (shift throughput) +\n    //       3X4 (addq throughput) = 17\n    { ISD::MUL,   MVT::v2i64, 17 },\n    // slm addq\\subq throughput is 4\n    { ISD::ADD,   MVT::v2i64, 4  },\n    { ISD::SUB,   MVT::v2i64, 4  },\n  };\n\n  if (ST->isSLM()) {\n    if (Args.size() == 2 && ISD == ISD::MUL && LT.second == MVT::v4i32) {\n      // Check if the operands can be shrinked into a smaller datatype.\n      bool Op1Signed = false;\n      unsigned Op1MinSize = BaseT::minRequiredElementSize(Args[0], Op1Signed);\n      bool Op2Signed = false;\n      unsigned Op2MinSize = BaseT::minRequiredElementSize(Args[1], Op2Signed);\n\n      bool SignedMode = Op1Signed || Op2Signed;\n      unsigned OpMinSize = std::max(Op1MinSize, Op2MinSize);\n\n      if (OpMinSize <= 7)\n        return LT.first * 3; // pmullw/sext\n      if (!SignedMode && OpMinSize <= 8)\n        return LT.first * 3; // pmullw/zext\n      if (OpMinSize <= 15)\n        return LT.first * 5; // pmullw/pmulhw/pshuf\n      if (!SignedMode && OpMinSize <= 16)\n        return LT.first * 5; // pmullw/pmulhw/pshuf\n    }\n\n    if (const auto *Entry = CostTableLookup(SLMCostTable, ISD,\n                                            LT.second)) {\n      return LT.first * Entry->Cost;\n    }\n  }\n\n  if ((ISD == ISD::SDIV || ISD == ISD::SREM || ISD == ISD::UDIV ||\n       ISD == ISD::UREM) &&\n      (Op2Info == TargetTransformInfo::OK_UniformConstantValue ||\n       Op2Info == TargetTransformInfo::OK_NonUniformConstantValue) &&\n      Opd2PropInfo == TargetTransformInfo::OP_PowerOf2) {\n    if (ISD == ISD::SDIV || ISD == ISD::SREM) {\n      // On X86, vector signed division by constants power-of-two are\n      // normally expanded to the sequence SRA + SRL + ADD + SRA.\n      // The OperandValue properties may not be the same as that of the previous\n      // operation; conservatively assume OP_None.\n      int Cost =\n          2 * getArithmeticInstrCost(Instruction::AShr, Ty, CostKind, Op1Info,\n                                     Op2Info,\n                                     TargetTransformInfo::OP_None,\n                                     TargetTransformInfo::OP_None);\n      Cost += getArithmeticInstrCost(Instruction::LShr, Ty, CostKind, Op1Info,\n                                     Op2Info,\n                                     TargetTransformInfo::OP_None,\n                                     TargetTransformInfo::OP_None);\n      Cost += getArithmeticInstrCost(Instruction::Add, Ty, CostKind, Op1Info,\n                                     Op2Info,\n                                     TargetTransformInfo::OP_None,\n                                     TargetTransformInfo::OP_None);\n\n      if (ISD == ISD::SREM) {\n        // For SREM: (X % C) is the equivalent of (X - (X/C)*C)\n        Cost += getArithmeticInstrCost(Instruction::Mul, Ty, CostKind, Op1Info,\n                                       Op2Info);\n        Cost += getArithmeticInstrCost(Instruction::Sub, Ty, CostKind, Op1Info,\n                                       Op2Info);\n      }\n\n      return Cost;\n    }\n\n    // Vector unsigned division/remainder will be simplified to shifts/masks.\n    if (ISD == ISD::UDIV)\n      return getArithmeticInstrCost(Instruction::LShr, Ty, CostKind,\n                                    Op1Info, Op2Info,\n                                    TargetTransformInfo::OP_None,\n                                    TargetTransformInfo::OP_None);\n\n    else // UREM\n      return getArithmeticInstrCost(Instruction::And, Ty, CostKind,\n                                    Op1Info, Op2Info,\n                                    TargetTransformInfo::OP_None,\n                                    TargetTransformInfo::OP_None);\n  }\n\n  static const CostTblEntry AVX512BWUniformConstCostTable[] = {\n    { ISD::SHL,  MVT::v64i8,   2 }, // psllw + pand.\n    { ISD::SRL,  MVT::v64i8,   2 }, // psrlw + pand.\n    { ISD::SRA,  MVT::v64i8,   4 }, // psrlw, pand, pxor, psubb.\n  };\n\n  if (Op2Info == TargetTransformInfo::OK_UniformConstantValue &&\n      ST->hasBWI()) {\n    if (const auto *Entry = CostTableLookup(AVX512BWUniformConstCostTable, ISD,\n                                            LT.second))\n      return LT.first * Entry->Cost;\n  }\n\n  static const CostTblEntry AVX512UniformConstCostTable[] = {\n    { ISD::SRA,  MVT::v2i64,   1 },\n    { ISD::SRA,  MVT::v4i64,   1 },\n    { ISD::SRA,  MVT::v8i64,   1 },\n\n    { ISD::SHL,  MVT::v64i8,   4 }, // psllw + pand.\n    { ISD::SRL,  MVT::v64i8,   4 }, // psrlw + pand.\n    { ISD::SRA,  MVT::v64i8,   8 }, // psrlw, pand, pxor, psubb.\n\n    { ISD::SDIV, MVT::v16i32,  6 }, // pmuludq sequence\n    { ISD::SREM, MVT::v16i32,  8 }, // pmuludq+mul+sub sequence\n    { ISD::UDIV, MVT::v16i32,  5 }, // pmuludq sequence\n    { ISD::UREM, MVT::v16i32,  7 }, // pmuludq+mul+sub sequence\n  };\n\n  if (Op2Info == TargetTransformInfo::OK_UniformConstantValue &&\n      ST->hasAVX512()) {\n    if (const auto *Entry = CostTableLookup(AVX512UniformConstCostTable, ISD,\n                                            LT.second))\n      return LT.first * Entry->Cost;\n  }\n\n  static const CostTblEntry AVX2UniformConstCostTable[] = {\n    { ISD::SHL,  MVT::v32i8,   2 }, // psllw + pand.\n    { ISD::SRL,  MVT::v32i8,   2 }, // psrlw + pand.\n    { ISD::SRA,  MVT::v32i8,   4 }, // psrlw, pand, pxor, psubb.\n\n    { ISD::SRA,  MVT::v4i64,   4 }, // 2 x psrad + shuffle.\n\n    { ISD::SDIV, MVT::v8i32,   6 }, // pmuludq sequence\n    { ISD::SREM, MVT::v8i32,   8 }, // pmuludq+mul+sub sequence\n    { ISD::UDIV, MVT::v8i32,   5 }, // pmuludq sequence\n    { ISD::UREM, MVT::v8i32,   7 }, // pmuludq+mul+sub sequence\n  };\n\n  if (Op2Info == TargetTransformInfo::OK_UniformConstantValue &&\n      ST->hasAVX2()) {\n    if (const auto *Entry = CostTableLookup(AVX2UniformConstCostTable, ISD,\n                                            LT.second))\n      return LT.first * Entry->Cost;\n  }\n\n  static const CostTblEntry SSE2UniformConstCostTable[] = {\n    { ISD::SHL,  MVT::v16i8,     2 }, // psllw + pand.\n    { ISD::SRL,  MVT::v16i8,     2 }, // psrlw + pand.\n    { ISD::SRA,  MVT::v16i8,     4 }, // psrlw, pand, pxor, psubb.\n\n    { ISD::SHL,  MVT::v32i8,   4+2 }, // 2*(psllw + pand) + split.\n    { ISD::SRL,  MVT::v32i8,   4+2 }, // 2*(psrlw + pand) + split.\n    { ISD::SRA,  MVT::v32i8,   8+2 }, // 2*(psrlw, pand, pxor, psubb) + split.\n\n    { ISD::SDIV, MVT::v8i32,  12+2 }, // 2*pmuludq sequence + split.\n    { ISD::SREM, MVT::v8i32,  16+2 }, // 2*pmuludq+mul+sub sequence + split.\n    { ISD::SDIV, MVT::v4i32,     6 }, // pmuludq sequence\n    { ISD::SREM, MVT::v4i32,     8 }, // pmuludq+mul+sub sequence\n    { ISD::UDIV, MVT::v8i32,  10+2 }, // 2*pmuludq sequence + split.\n    { ISD::UREM, MVT::v8i32,  14+2 }, // 2*pmuludq+mul+sub sequence + split.\n    { ISD::UDIV, MVT::v4i32,     5 }, // pmuludq sequence\n    { ISD::UREM, MVT::v4i32,     7 }, // pmuludq+mul+sub sequence\n  };\n\n  // XOP has faster vXi8 shifts.\n  if (Op2Info == TargetTransformInfo::OK_UniformConstantValue &&\n      ST->hasSSE2() && !ST->hasXOP()) {\n    if (const auto *Entry =\n            CostTableLookup(SSE2UniformConstCostTable, ISD, LT.second))\n      return LT.first * Entry->Cost;\n  }\n\n  static const CostTblEntry AVX512BWConstCostTable[] = {\n    { ISD::SDIV, MVT::v64i8,  14 }, // 2*ext+2*pmulhw sequence\n    { ISD::SREM, MVT::v64i8,  16 }, // 2*ext+2*pmulhw+mul+sub sequence\n    { ISD::UDIV, MVT::v64i8,  14 }, // 2*ext+2*pmulhw sequence\n    { ISD::UREM, MVT::v64i8,  16 }, // 2*ext+2*pmulhw+mul+sub sequence\n    { ISD::SDIV, MVT::v32i16,  6 }, // vpmulhw sequence\n    { ISD::SREM, MVT::v32i16,  8 }, // vpmulhw+mul+sub sequence\n    { ISD::UDIV, MVT::v32i16,  6 }, // vpmulhuw sequence\n    { ISD::UREM, MVT::v32i16,  8 }, // vpmulhuw+mul+sub sequence\n  };\n\n  if ((Op2Info == TargetTransformInfo::OK_UniformConstantValue ||\n       Op2Info == TargetTransformInfo::OK_NonUniformConstantValue) &&\n      ST->hasBWI()) {\n    if (const auto *Entry =\n            CostTableLookup(AVX512BWConstCostTable, ISD, LT.second))\n      return LT.first * Entry->Cost;\n  }\n\n  static const CostTblEntry AVX512ConstCostTable[] = {\n    { ISD::SDIV, MVT::v16i32, 15 }, // vpmuldq sequence\n    { ISD::SREM, MVT::v16i32, 17 }, // vpmuldq+mul+sub sequence\n    { ISD::UDIV, MVT::v16i32, 15 }, // vpmuludq sequence\n    { ISD::UREM, MVT::v16i32, 17 }, // vpmuludq+mul+sub sequence\n    { ISD::SDIV, MVT::v64i8,  28 }, // 4*ext+4*pmulhw sequence\n    { ISD::SREM, MVT::v64i8,  32 }, // 4*ext+4*pmulhw+mul+sub sequence\n    { ISD::UDIV, MVT::v64i8,  28 }, // 4*ext+4*pmulhw sequence\n    { ISD::UREM, MVT::v64i8,  32 }, // 4*ext+4*pmulhw+mul+sub sequence\n    { ISD::SDIV, MVT::v32i16, 12 }, // 2*vpmulhw sequence\n    { ISD::SREM, MVT::v32i16, 16 }, // 2*vpmulhw+mul+sub sequence\n    { ISD::UDIV, MVT::v32i16, 12 }, // 2*vpmulhuw sequence\n    { ISD::UREM, MVT::v32i16, 16 }, // 2*vpmulhuw+mul+sub sequence\n  };\n\n  if ((Op2Info == TargetTransformInfo::OK_UniformConstantValue ||\n       Op2Info == TargetTransformInfo::OK_NonUniformConstantValue) &&\n      ST->hasAVX512()) {\n    if (const auto *Entry =\n            CostTableLookup(AVX512ConstCostTable, ISD, LT.second))\n      return LT.first * Entry->Cost;\n  }\n\n  static const CostTblEntry AVX2ConstCostTable[] = {\n    { ISD::SDIV, MVT::v32i8,  14 }, // 2*ext+2*pmulhw sequence\n    { ISD::SREM, MVT::v32i8,  16 }, // 2*ext+2*pmulhw+mul+sub sequence\n    { ISD::UDIV, MVT::v32i8,  14 }, // 2*ext+2*pmulhw sequence\n    { ISD::UREM, MVT::v32i8,  16 }, // 2*ext+2*pmulhw+mul+sub sequence\n    { ISD::SDIV, MVT::v16i16,  6 }, // vpmulhw sequence\n    { ISD::SREM, MVT::v16i16,  8 }, // vpmulhw+mul+sub sequence\n    { ISD::UDIV, MVT::v16i16,  6 }, // vpmulhuw sequence\n    { ISD::UREM, MVT::v16i16,  8 }, // vpmulhuw+mul+sub sequence\n    { ISD::SDIV, MVT::v8i32,  15 }, // vpmuldq sequence\n    { ISD::SREM, MVT::v8i32,  19 }, // vpmuldq+mul+sub sequence\n    { ISD::UDIV, MVT::v8i32,  15 }, // vpmuludq sequence\n    { ISD::UREM, MVT::v8i32,  19 }, // vpmuludq+mul+sub sequence\n  };\n\n  if ((Op2Info == TargetTransformInfo::OK_UniformConstantValue ||\n       Op2Info == TargetTransformInfo::OK_NonUniformConstantValue) &&\n      ST->hasAVX2()) {\n    if (const auto *Entry = CostTableLookup(AVX2ConstCostTable, ISD, LT.second))\n      return LT.first * Entry->Cost;\n  }\n\n  static const CostTblEntry SSE2ConstCostTable[] = {\n    { ISD::SDIV, MVT::v32i8,  28+2 }, // 4*ext+4*pmulhw sequence + split.\n    { ISD::SREM, MVT::v32i8,  32+2 }, // 4*ext+4*pmulhw+mul+sub sequence + split.\n    { ISD::SDIV, MVT::v16i8,    14 }, // 2*ext+2*pmulhw sequence\n    { ISD::SREM, MVT::v16i8,    16 }, // 2*ext+2*pmulhw+mul+sub sequence\n    { ISD::UDIV, MVT::v32i8,  28+2 }, // 4*ext+4*pmulhw sequence + split.\n    { ISD::UREM, MVT::v32i8,  32+2 }, // 4*ext+4*pmulhw+mul+sub sequence + split.\n    { ISD::UDIV, MVT::v16i8,    14 }, // 2*ext+2*pmulhw sequence\n    { ISD::UREM, MVT::v16i8,    16 }, // 2*ext+2*pmulhw+mul+sub sequence\n    { ISD::SDIV, MVT::v16i16, 12+2 }, // 2*pmulhw sequence + split.\n    { ISD::SREM, MVT::v16i16, 16+2 }, // 2*pmulhw+mul+sub sequence + split.\n    { ISD::SDIV, MVT::v8i16,     6 }, // pmulhw sequence\n    { ISD::SREM, MVT::v8i16,     8 }, // pmulhw+mul+sub sequence\n    { ISD::UDIV, MVT::v16i16, 12+2 }, // 2*pmulhuw sequence + split.\n    { ISD::UREM, MVT::v16i16, 16+2 }, // 2*pmulhuw+mul+sub sequence + split.\n    { ISD::UDIV, MVT::v8i16,     6 }, // pmulhuw sequence\n    { ISD::UREM, MVT::v8i16,     8 }, // pmulhuw+mul+sub sequence\n    { ISD::SDIV, MVT::v8i32,  38+2 }, // 2*pmuludq sequence + split.\n    { ISD::SREM, MVT::v8i32,  48+2 }, // 2*pmuludq+mul+sub sequence + split.\n    { ISD::SDIV, MVT::v4i32,    19 }, // pmuludq sequence\n    { ISD::SREM, MVT::v4i32,    24 }, // pmuludq+mul+sub sequence\n    { ISD::UDIV, MVT::v8i32,  30+2 }, // 2*pmuludq sequence + split.\n    { ISD::UREM, MVT::v8i32,  40+2 }, // 2*pmuludq+mul+sub sequence + split.\n    { ISD::UDIV, MVT::v4i32,    15 }, // pmuludq sequence\n    { ISD::UREM, MVT::v4i32,    20 }, // pmuludq+mul+sub sequence\n  };\n\n  if ((Op2Info == TargetTransformInfo::OK_UniformConstantValue ||\n       Op2Info == TargetTransformInfo::OK_NonUniformConstantValue) &&\n      ST->hasSSE2()) {\n    // pmuldq sequence.\n    if (ISD == ISD::SDIV && LT.second == MVT::v8i32 && ST->hasAVX())\n      return LT.first * 32;\n    if (ISD == ISD::SREM && LT.second == MVT::v8i32 && ST->hasAVX())\n      return LT.first * 38;\n    if (ISD == ISD::SDIV && LT.second == MVT::v4i32 && ST->hasSSE41())\n      return LT.first * 15;\n    if (ISD == ISD::SREM && LT.second == MVT::v4i32 && ST->hasSSE41())\n      return LT.first * 20;\n\n    if (const auto *Entry = CostTableLookup(SSE2ConstCostTable, ISD, LT.second))\n      return LT.first * Entry->Cost;\n  }\n\n  static const CostTblEntry AVX512BWShiftCostTable[] = {\n    { ISD::SHL,   MVT::v8i16,      1 }, // vpsllvw\n    { ISD::SRL,   MVT::v8i16,      1 }, // vpsrlvw\n    { ISD::SRA,   MVT::v8i16,      1 }, // vpsravw\n\n    { ISD::SHL,   MVT::v16i16,     1 }, // vpsllvw\n    { ISD::SRL,   MVT::v16i16,     1 }, // vpsrlvw\n    { ISD::SRA,   MVT::v16i16,     1 }, // vpsravw\n\n    { ISD::SHL,   MVT::v32i16,     1 }, // vpsllvw\n    { ISD::SRL,   MVT::v32i16,     1 }, // vpsrlvw\n    { ISD::SRA,   MVT::v32i16,     1 }, // vpsravw\n  };\n\n  if (ST->hasBWI())\n    if (const auto *Entry = CostTableLookup(AVX512BWShiftCostTable, ISD, LT.second))\n      return LT.first * Entry->Cost;\n\n  static const CostTblEntry AVX2UniformCostTable[] = {\n    // Uniform splats are cheaper for the following instructions.\n    { ISD::SHL,  MVT::v16i16, 1 }, // psllw.\n    { ISD::SRL,  MVT::v16i16, 1 }, // psrlw.\n    { ISD::SRA,  MVT::v16i16, 1 }, // psraw.\n    { ISD::SHL,  MVT::v32i16, 2 }, // 2*psllw.\n    { ISD::SRL,  MVT::v32i16, 2 }, // 2*psrlw.\n    { ISD::SRA,  MVT::v32i16, 2 }, // 2*psraw.\n  };\n\n  if (ST->hasAVX2() &&\n      ((Op2Info == TargetTransformInfo::OK_UniformConstantValue) ||\n       (Op2Info == TargetTransformInfo::OK_UniformValue))) {\n    if (const auto *Entry =\n            CostTableLookup(AVX2UniformCostTable, ISD, LT.second))\n      return LT.first * Entry->Cost;\n  }\n\n  static const CostTblEntry SSE2UniformCostTable[] = {\n    // Uniform splats are cheaper for the following instructions.\n    { ISD::SHL,  MVT::v8i16,  1 }, // psllw.\n    { ISD::SHL,  MVT::v4i32,  1 }, // pslld\n    { ISD::SHL,  MVT::v2i64,  1 }, // psllq.\n\n    { ISD::SRL,  MVT::v8i16,  1 }, // psrlw.\n    { ISD::SRL,  MVT::v4i32,  1 }, // psrld.\n    { ISD::SRL,  MVT::v2i64,  1 }, // psrlq.\n\n    { ISD::SRA,  MVT::v8i16,  1 }, // psraw.\n    { ISD::SRA,  MVT::v4i32,  1 }, // psrad.\n  };\n\n  if (ST->hasSSE2() &&\n      ((Op2Info == TargetTransformInfo::OK_UniformConstantValue) ||\n       (Op2Info == TargetTransformInfo::OK_UniformValue))) {\n    if (const auto *Entry =\n            CostTableLookup(SSE2UniformCostTable, ISD, LT.second))\n      return LT.first * Entry->Cost;\n  }\n\n  static const CostTblEntry AVX512DQCostTable[] = {\n    { ISD::MUL,  MVT::v2i64, 1 },\n    { ISD::MUL,  MVT::v4i64, 1 },\n    { ISD::MUL,  MVT::v8i64, 1 }\n  };\n\n  // Look for AVX512DQ lowering tricks for custom cases.\n  if (ST->hasDQI())\n    if (const auto *Entry = CostTableLookup(AVX512DQCostTable, ISD, LT.second))\n      return LT.first * Entry->Cost;\n\n  static const CostTblEntry AVX512BWCostTable[] = {\n    { ISD::SHL,   MVT::v64i8,     11 }, // vpblendvb sequence.\n    { ISD::SRL,   MVT::v64i8,     11 }, // vpblendvb sequence.\n    { ISD::SRA,   MVT::v64i8,     24 }, // vpblendvb sequence.\n\n    { ISD::MUL,   MVT::v64i8,     11 }, // extend/pmullw/trunc sequence.\n    { ISD::MUL,   MVT::v32i8,      4 }, // extend/pmullw/trunc sequence.\n    { ISD::MUL,   MVT::v16i8,      4 }, // extend/pmullw/trunc sequence.\n  };\n\n  // Look for AVX512BW lowering tricks for custom cases.\n  if (ST->hasBWI())\n    if (const auto *Entry = CostTableLookup(AVX512BWCostTable, ISD, LT.second))\n      return LT.first * Entry->Cost;\n\n  static const CostTblEntry AVX512CostTable[] = {\n    { ISD::SHL,     MVT::v16i32,     1 },\n    { ISD::SRL,     MVT::v16i32,     1 },\n    { ISD::SRA,     MVT::v16i32,     1 },\n\n    { ISD::SHL,     MVT::v8i64,      1 },\n    { ISD::SRL,     MVT::v8i64,      1 },\n\n    { ISD::SRA,     MVT::v2i64,      1 },\n    { ISD::SRA,     MVT::v4i64,      1 },\n    { ISD::SRA,     MVT::v8i64,      1 },\n\n    { ISD::MUL,     MVT::v64i8,     26 }, // extend/pmullw/trunc sequence.\n    { ISD::MUL,     MVT::v32i8,     13 }, // extend/pmullw/trunc sequence.\n    { ISD::MUL,     MVT::v16i8,      5 }, // extend/pmullw/trunc sequence.\n    { ISD::MUL,     MVT::v16i32,     1 }, // pmulld (Skylake from agner.org)\n    { ISD::MUL,     MVT::v8i32,      1 }, // pmulld (Skylake from agner.org)\n    { ISD::MUL,     MVT::v4i32,      1 }, // pmulld (Skylake from agner.org)\n    { ISD::MUL,     MVT::v8i64,      8 }, // 3*pmuludq/3*shift/2*add\n\n    { ISD::FADD,    MVT::v8f64,      1 }, // Skylake from http://www.agner.org/\n    { ISD::FSUB,    MVT::v8f64,      1 }, // Skylake from http://www.agner.org/\n    { ISD::FMUL,    MVT::v8f64,      1 }, // Skylake from http://www.agner.org/\n\n    { ISD::FADD,    MVT::v16f32,     1 }, // Skylake from http://www.agner.org/\n    { ISD::FSUB,    MVT::v16f32,     1 }, // Skylake from http://www.agner.org/\n    { ISD::FMUL,    MVT::v16f32,     1 }, // Skylake from http://www.agner.org/\n  };\n\n  if (ST->hasAVX512())\n    if (const auto *Entry = CostTableLookup(AVX512CostTable, ISD, LT.second))\n      return LT.first * Entry->Cost;\n\n  static const CostTblEntry AVX2ShiftCostTable[] = {\n    // Shifts on v4i64/v8i32 on AVX2 is legal even though we declare to\n    // customize them to detect the cases where shift amount is a scalar one.\n    { ISD::SHL,     MVT::v4i32,    1 },\n    { ISD::SRL,     MVT::v4i32,    1 },\n    { ISD::SRA,     MVT::v4i32,    1 },\n    { ISD::SHL,     MVT::v8i32,    1 },\n    { ISD::SRL,     MVT::v8i32,    1 },\n    { ISD::SRA,     MVT::v8i32,    1 },\n    { ISD::SHL,     MVT::v2i64,    1 },\n    { ISD::SRL,     MVT::v2i64,    1 },\n    { ISD::SHL,     MVT::v4i64,    1 },\n    { ISD::SRL,     MVT::v4i64,    1 },\n  };\n\n  if (ST->hasAVX512()) {\n    if (ISD == ISD::SHL && LT.second == MVT::v32i16 &&\n        (Op2Info == TargetTransformInfo::OK_UniformConstantValue ||\n         Op2Info == TargetTransformInfo::OK_NonUniformConstantValue))\n      // On AVX512, a packed v32i16 shift left by a constant build_vector\n      // is lowered into a vector multiply (vpmullw).\n      return getArithmeticInstrCost(Instruction::Mul, Ty, CostKind,\n                                    Op1Info, Op2Info,\n                                    TargetTransformInfo::OP_None,\n                                    TargetTransformInfo::OP_None);\n  }\n\n  // Look for AVX2 lowering tricks.\n  if (ST->hasAVX2()) {\n    if (ISD == ISD::SHL && LT.second == MVT::v16i16 &&\n        (Op2Info == TargetTransformInfo::OK_UniformConstantValue ||\n         Op2Info == TargetTransformInfo::OK_NonUniformConstantValue))\n      // On AVX2, a packed v16i16 shift left by a constant build_vector\n      // is lowered into a vector multiply (vpmullw).\n      return getArithmeticInstrCost(Instruction::Mul, Ty, CostKind,\n                                    Op1Info, Op2Info,\n                                    TargetTransformInfo::OP_None,\n                                    TargetTransformInfo::OP_None);\n\n    if (const auto *Entry = CostTableLookup(AVX2ShiftCostTable, ISD, LT.second))\n      return LT.first * Entry->Cost;\n  }\n\n  static const CostTblEntry XOPShiftCostTable[] = {\n    // 128bit shifts take 1cy, but right shifts require negation beforehand.\n    { ISD::SHL,     MVT::v16i8,    1 },\n    { ISD::SRL,     MVT::v16i8,    2 },\n    { ISD::SRA,     MVT::v16i8,    2 },\n    { ISD::SHL,     MVT::v8i16,    1 },\n    { ISD::SRL,     MVT::v8i16,    2 },\n    { ISD::SRA,     MVT::v8i16,    2 },\n    { ISD::SHL,     MVT::v4i32,    1 },\n    { ISD::SRL,     MVT::v4i32,    2 },\n    { ISD::SRA,     MVT::v4i32,    2 },\n    { ISD::SHL,     MVT::v2i64,    1 },\n    { ISD::SRL,     MVT::v2i64,    2 },\n    { ISD::SRA,     MVT::v2i64,    2 },\n    // 256bit shifts require splitting if AVX2 didn't catch them above.\n    { ISD::SHL,     MVT::v32i8,  2+2 },\n    { ISD::SRL,     MVT::v32i8,  4+2 },\n    { ISD::SRA,     MVT::v32i8,  4+2 },\n    { ISD::SHL,     MVT::v16i16, 2+2 },\n    { ISD::SRL,     MVT::v16i16, 4+2 },\n    { ISD::SRA,     MVT::v16i16, 4+2 },\n    { ISD::SHL,     MVT::v8i32,  2+2 },\n    { ISD::SRL,     MVT::v8i32,  4+2 },\n    { ISD::SRA,     MVT::v8i32,  4+2 },\n    { ISD::SHL,     MVT::v4i64,  2+2 },\n    { ISD::SRL,     MVT::v4i64,  4+2 },\n    { ISD::SRA,     MVT::v4i64,  4+2 },\n  };\n\n  // Look for XOP lowering tricks.\n  if (ST->hasXOP()) {\n    // If the right shift is constant then we'll fold the negation so\n    // it's as cheap as a left shift.\n    int ShiftISD = ISD;\n    if ((ShiftISD == ISD::SRL || ShiftISD == ISD::SRA) &&\n        (Op2Info == TargetTransformInfo::OK_UniformConstantValue ||\n         Op2Info == TargetTransformInfo::OK_NonUniformConstantValue))\n      ShiftISD = ISD::SHL;\n    if (const auto *Entry =\n            CostTableLookup(XOPShiftCostTable, ShiftISD, LT.second))\n      return LT.first * Entry->Cost;\n  }\n\n  static const CostTblEntry SSE2UniformShiftCostTable[] = {\n    // Uniform splats are cheaper for the following instructions.\n    { ISD::SHL,  MVT::v16i16, 2+2 }, // 2*psllw + split.\n    { ISD::SHL,  MVT::v8i32,  2+2 }, // 2*pslld + split.\n    { ISD::SHL,  MVT::v4i64,  2+2 }, // 2*psllq + split.\n\n    { ISD::SRL,  MVT::v16i16, 2+2 }, // 2*psrlw + split.\n    { ISD::SRL,  MVT::v8i32,  2+2 }, // 2*psrld + split.\n    { ISD::SRL,  MVT::v4i64,  2+2 }, // 2*psrlq + split.\n\n    { ISD::SRA,  MVT::v16i16, 2+2 }, // 2*psraw + split.\n    { ISD::SRA,  MVT::v8i32,  2+2 }, // 2*psrad + split.\n    { ISD::SRA,  MVT::v2i64,    4 }, // 2*psrad + shuffle.\n    { ISD::SRA,  MVT::v4i64,  8+2 }, // 2*(2*psrad + shuffle) + split.\n  };\n\n  if (ST->hasSSE2() &&\n      ((Op2Info == TargetTransformInfo::OK_UniformConstantValue) ||\n       (Op2Info == TargetTransformInfo::OK_UniformValue))) {\n\n    // Handle AVX2 uniform v4i64 ISD::SRA, it's not worth a table.\n    if (ISD == ISD::SRA && LT.second == MVT::v4i64 && ST->hasAVX2())\n      return LT.first * 4; // 2*psrad + shuffle.\n\n    if (const auto *Entry =\n            CostTableLookup(SSE2UniformShiftCostTable, ISD, LT.second))\n      return LT.first * Entry->Cost;\n  }\n\n  if (ISD == ISD::SHL &&\n      Op2Info == TargetTransformInfo::OK_NonUniformConstantValue) {\n    MVT VT = LT.second;\n    // Vector shift left by non uniform constant can be lowered\n    // into vector multiply.\n    if (((VT == MVT::v8i16 || VT == MVT::v4i32) && ST->hasSSE2()) ||\n        ((VT == MVT::v16i16 || VT == MVT::v8i32) && ST->hasAVX()))\n      ISD = ISD::MUL;\n  }\n\n  static const CostTblEntry AVX2CostTable[] = {\n    { ISD::SHL,  MVT::v32i8,     11 }, // vpblendvb sequence.\n    { ISD::SHL,  MVT::v64i8,     22 }, // 2*vpblendvb sequence.\n    { ISD::SHL,  MVT::v16i16,    10 }, // extend/vpsrlvd/pack sequence.\n    { ISD::SHL,  MVT::v32i16,    20 }, // 2*extend/vpsrlvd/pack sequence.\n\n    { ISD::SRL,  MVT::v32i8,     11 }, // vpblendvb sequence.\n    { ISD::SRL,  MVT::v64i8,     22 }, // 2*vpblendvb sequence.\n    { ISD::SRL,  MVT::v16i16,    10 }, // extend/vpsrlvd/pack sequence.\n    { ISD::SRL,  MVT::v32i16,    20 }, // 2*extend/vpsrlvd/pack sequence.\n\n    { ISD::SRA,  MVT::v32i8,     24 }, // vpblendvb sequence.\n    { ISD::SRA,  MVT::v64i8,     48 }, // 2*vpblendvb sequence.\n    { ISD::SRA,  MVT::v16i16,    10 }, // extend/vpsravd/pack sequence.\n    { ISD::SRA,  MVT::v32i16,    20 }, // 2*extend/vpsravd/pack sequence.\n    { ISD::SRA,  MVT::v2i64,      4 }, // srl/xor/sub sequence.\n    { ISD::SRA,  MVT::v4i64,      4 }, // srl/xor/sub sequence.\n\n    { ISD::SUB,  MVT::v32i8,      1 }, // psubb\n    { ISD::ADD,  MVT::v32i8,      1 }, // paddb\n    { ISD::SUB,  MVT::v16i16,     1 }, // psubw\n    { ISD::ADD,  MVT::v16i16,     1 }, // paddw\n    { ISD::SUB,  MVT::v8i32,      1 }, // psubd\n    { ISD::ADD,  MVT::v8i32,      1 }, // paddd\n    { ISD::SUB,  MVT::v4i64,      1 }, // psubq\n    { ISD::ADD,  MVT::v4i64,      1 }, // paddq\n\n    { ISD::MUL,  MVT::v32i8,     17 }, // extend/pmullw/trunc sequence.\n    { ISD::MUL,  MVT::v16i8,      7 }, // extend/pmullw/trunc sequence.\n    { ISD::MUL,  MVT::v16i16,     1 }, // pmullw\n    { ISD::MUL,  MVT::v8i32,      2 }, // pmulld (Haswell from agner.org)\n    { ISD::MUL,  MVT::v4i64,      8 }, // 3*pmuludq/3*shift/2*add\n\n    { ISD::FADD, MVT::v4f64,      1 }, // Haswell from http://www.agner.org/\n    { ISD::FADD, MVT::v8f32,      1 }, // Haswell from http://www.agner.org/\n    { ISD::FSUB, MVT::v4f64,      1 }, // Haswell from http://www.agner.org/\n    { ISD::FSUB, MVT::v8f32,      1 }, // Haswell from http://www.agner.org/\n    { ISD::FMUL, MVT::v4f64,      1 }, // Haswell from http://www.agner.org/\n    { ISD::FMUL, MVT::v8f32,      1 }, // Haswell from http://www.agner.org/\n\n    { ISD::FDIV, MVT::f32,        7 }, // Haswell from http://www.agner.org/\n    { ISD::FDIV, MVT::v4f32,      7 }, // Haswell from http://www.agner.org/\n    { ISD::FDIV, MVT::v8f32,     14 }, // Haswell from http://www.agner.org/\n    { ISD::FDIV, MVT::f64,       14 }, // Haswell from http://www.agner.org/\n    { ISD::FDIV, MVT::v2f64,     14 }, // Haswell from http://www.agner.org/\n    { ISD::FDIV, MVT::v4f64,     28 }, // Haswell from http://www.agner.org/\n  };\n\n  // Look for AVX2 lowering tricks for custom cases.\n  if (ST->hasAVX2())\n    if (const auto *Entry = CostTableLookup(AVX2CostTable, ISD, LT.second))\n      return LT.first * Entry->Cost;\n\n  static const CostTblEntry AVX1CostTable[] = {\n    // We don't have to scalarize unsupported ops. We can issue two half-sized\n    // operations and we only need to extract the upper YMM half.\n    // Two ops + 1 extract + 1 insert = 4.\n    { ISD::MUL,     MVT::v16i16,     4 },\n    { ISD::MUL,     MVT::v8i32,      4 },\n    { ISD::SUB,     MVT::v32i8,      4 },\n    { ISD::ADD,     MVT::v32i8,      4 },\n    { ISD::SUB,     MVT::v16i16,     4 },\n    { ISD::ADD,     MVT::v16i16,     4 },\n    { ISD::SUB,     MVT::v8i32,      4 },\n    { ISD::ADD,     MVT::v8i32,      4 },\n    { ISD::SUB,     MVT::v4i64,      4 },\n    { ISD::ADD,     MVT::v4i64,      4 },\n\n    // A v4i64 multiply is custom lowered as two split v2i64 vectors that then\n    // are lowered as a series of long multiplies(3), shifts(3) and adds(2)\n    // Because we believe v4i64 to be a legal type, we must also include the\n    // extract+insert in the cost table. Therefore, the cost here is 18\n    // instead of 8.\n    { ISD::MUL,     MVT::v4i64,     18 },\n\n    { ISD::MUL,     MVT::v32i8,     26 }, // extend/pmullw/trunc sequence.\n\n    { ISD::FDIV,    MVT::f32,       14 }, // SNB from http://www.agner.org/\n    { ISD::FDIV,    MVT::v4f32,     14 }, // SNB from http://www.agner.org/\n    { ISD::FDIV,    MVT::v8f32,     28 }, // SNB from http://www.agner.org/\n    { ISD::FDIV,    MVT::f64,       22 }, // SNB from http://www.agner.org/\n    { ISD::FDIV,    MVT::v2f64,     22 }, // SNB from http://www.agner.org/\n    { ISD::FDIV,    MVT::v4f64,     44 }, // SNB from http://www.agner.org/\n  };\n\n  if (ST->hasAVX())\n    if (const auto *Entry = CostTableLookup(AVX1CostTable, ISD, LT.second))\n      return LT.first * Entry->Cost;\n\n  static const CostTblEntry SSE42CostTable[] = {\n    { ISD::FADD, MVT::f64,     1 }, // Nehalem from http://www.agner.org/\n    { ISD::FADD, MVT::f32,     1 }, // Nehalem from http://www.agner.org/\n    { ISD::FADD, MVT::v2f64,   1 }, // Nehalem from http://www.agner.org/\n    { ISD::FADD, MVT::v4f32,   1 }, // Nehalem from http://www.agner.org/\n\n    { ISD::FSUB, MVT::f64,     1 }, // Nehalem from http://www.agner.org/\n    { ISD::FSUB, MVT::f32 ,    1 }, // Nehalem from http://www.agner.org/\n    { ISD::FSUB, MVT::v2f64,   1 }, // Nehalem from http://www.agner.org/\n    { ISD::FSUB, MVT::v4f32,   1 }, // Nehalem from http://www.agner.org/\n\n    { ISD::FMUL, MVT::f64,     1 }, // Nehalem from http://www.agner.org/\n    { ISD::FMUL, MVT::f32,     1 }, // Nehalem from http://www.agner.org/\n    { ISD::FMUL, MVT::v2f64,   1 }, // Nehalem from http://www.agner.org/\n    { ISD::FMUL, MVT::v4f32,   1 }, // Nehalem from http://www.agner.org/\n\n    { ISD::FDIV,  MVT::f32,   14 }, // Nehalem from http://www.agner.org/\n    { ISD::FDIV,  MVT::v4f32, 14 }, // Nehalem from http://www.agner.org/\n    { ISD::FDIV,  MVT::f64,   22 }, // Nehalem from http://www.agner.org/\n    { ISD::FDIV,  MVT::v2f64, 22 }, // Nehalem from http://www.agner.org/\n  };\n\n  if (ST->hasSSE42())\n    if (const auto *Entry = CostTableLookup(SSE42CostTable, ISD, LT.second))\n      return LT.first * Entry->Cost;\n\n  static const CostTblEntry SSE41CostTable[] = {\n    { ISD::SHL,  MVT::v16i8,      11 }, // pblendvb sequence.\n    { ISD::SHL,  MVT::v32i8,  2*11+2 }, // pblendvb sequence + split.\n    { ISD::SHL,  MVT::v8i16,      14 }, // pblendvb sequence.\n    { ISD::SHL,  MVT::v16i16, 2*14+2 }, // pblendvb sequence + split.\n    { ISD::SHL,  MVT::v4i32,       4 }, // pslld/paddd/cvttps2dq/pmulld\n    { ISD::SHL,  MVT::v8i32,   2*4+2 }, // pslld/paddd/cvttps2dq/pmulld + split\n\n    { ISD::SRL,  MVT::v16i8,      12 }, // pblendvb sequence.\n    { ISD::SRL,  MVT::v32i8,  2*12+2 }, // pblendvb sequence + split.\n    { ISD::SRL,  MVT::v8i16,      14 }, // pblendvb sequence.\n    { ISD::SRL,  MVT::v16i16, 2*14+2 }, // pblendvb sequence + split.\n    { ISD::SRL,  MVT::v4i32,      11 }, // Shift each lane + blend.\n    { ISD::SRL,  MVT::v8i32,  2*11+2 }, // Shift each lane + blend + split.\n\n    { ISD::SRA,  MVT::v16i8,      24 }, // pblendvb sequence.\n    { ISD::SRA,  MVT::v32i8,  2*24+2 }, // pblendvb sequence + split.\n    { ISD::SRA,  MVT::v8i16,      14 }, // pblendvb sequence.\n    { ISD::SRA,  MVT::v16i16, 2*14+2 }, // pblendvb sequence + split.\n    { ISD::SRA,  MVT::v4i32,      12 }, // Shift each lane + blend.\n    { ISD::SRA,  MVT::v8i32,  2*12+2 }, // Shift each lane + blend + split.\n\n    { ISD::MUL,  MVT::v4i32,       2 }  // pmulld (Nehalem from agner.org)\n  };\n\n  if (ST->hasSSE41())\n    if (const auto *Entry = CostTableLookup(SSE41CostTable, ISD, LT.second))\n      return LT.first * Entry->Cost;\n\n  static const CostTblEntry SSE2CostTable[] = {\n    // We don't correctly identify costs of casts because they are marked as\n    // custom.\n    { ISD::SHL,  MVT::v16i8,      26 }, // cmpgtb sequence.\n    { ISD::SHL,  MVT::v8i16,      32 }, // cmpgtb sequence.\n    { ISD::SHL,  MVT::v4i32,     2*5 }, // We optimized this using mul.\n    { ISD::SHL,  MVT::v2i64,       4 }, // splat+shuffle sequence.\n    { ISD::SHL,  MVT::v4i64,   2*4+2 }, // splat+shuffle sequence + split.\n\n    { ISD::SRL,  MVT::v16i8,      26 }, // cmpgtb sequence.\n    { ISD::SRL,  MVT::v8i16,      32 }, // cmpgtb sequence.\n    { ISD::SRL,  MVT::v4i32,      16 }, // Shift each lane + blend.\n    { ISD::SRL,  MVT::v2i64,       4 }, // splat+shuffle sequence.\n    { ISD::SRL,  MVT::v4i64,   2*4+2 }, // splat+shuffle sequence + split.\n\n    { ISD::SRA,  MVT::v16i8,      54 }, // unpacked cmpgtb sequence.\n    { ISD::SRA,  MVT::v8i16,      32 }, // cmpgtb sequence.\n    { ISD::SRA,  MVT::v4i32,      16 }, // Shift each lane + blend.\n    { ISD::SRA,  MVT::v2i64,      12 }, // srl/xor/sub sequence.\n    { ISD::SRA,  MVT::v4i64,  2*12+2 }, // srl/xor/sub sequence+split.\n\n    { ISD::MUL,  MVT::v16i8,      12 }, // extend/pmullw/trunc sequence.\n    { ISD::MUL,  MVT::v8i16,       1 }, // pmullw\n    { ISD::MUL,  MVT::v4i32,       6 }, // 3*pmuludq/4*shuffle\n    { ISD::MUL,  MVT::v2i64,       8 }, // 3*pmuludq/3*shift/2*add\n\n    { ISD::FDIV, MVT::f32,        23 }, // Pentium IV from http://www.agner.org/\n    { ISD::FDIV, MVT::v4f32,      39 }, // Pentium IV from http://www.agner.org/\n    { ISD::FDIV, MVT::f64,        38 }, // Pentium IV from http://www.agner.org/\n    { ISD::FDIV, MVT::v2f64,      69 }, // Pentium IV from http://www.agner.org/\n\n    { ISD::FADD, MVT::f32,         2 }, // Pentium IV from http://www.agner.org/\n    { ISD::FADD, MVT::f64,         2 }, // Pentium IV from http://www.agner.org/\n\n    { ISD::FSUB, MVT::f32,         2 }, // Pentium IV from http://www.agner.org/\n    { ISD::FSUB, MVT::f64,         2 }, // Pentium IV from http://www.agner.org/\n  };\n\n  if (ST->hasSSE2())\n    if (const auto *Entry = CostTableLookup(SSE2CostTable, ISD, LT.second))\n      return LT.first * Entry->Cost;\n\n  static const CostTblEntry SSE1CostTable[] = {\n    { ISD::FDIV, MVT::f32,   17 }, // Pentium III from http://www.agner.org/\n    { ISD::FDIV, MVT::v4f32, 34 }, // Pentium III from http://www.agner.org/\n\n    { ISD::FADD, MVT::f32,    1 }, // Pentium III from http://www.agner.org/\n    { ISD::FADD, MVT::v4f32,  2 }, // Pentium III from http://www.agner.org/\n\n    { ISD::FSUB, MVT::f32,    1 }, // Pentium III from http://www.agner.org/\n    { ISD::FSUB, MVT::v4f32,  2 }, // Pentium III from http://www.agner.org/\n\n    { ISD::ADD, MVT::i8,      1 }, // Pentium III from http://www.agner.org/\n    { ISD::ADD, MVT::i16,     1 }, // Pentium III from http://www.agner.org/\n    { ISD::ADD, MVT::i32,     1 }, // Pentium III from http://www.agner.org/\n\n    { ISD::SUB, MVT::i8,      1 }, // Pentium III from http://www.agner.org/\n    { ISD::SUB, MVT::i16,     1 }, // Pentium III from http://www.agner.org/\n    { ISD::SUB, MVT::i32,     1 }, // Pentium III from http://www.agner.org/\n  };\n\n  if (ST->hasSSE1())\n    if (const auto *Entry = CostTableLookup(SSE1CostTable, ISD, LT.second))\n      return LT.first * Entry->Cost;\n\n  // It is not a good idea to vectorize division. We have to scalarize it and\n  // in the process we will often end up having to spilling regular\n  // registers. The overhead of division is going to dominate most kernels\n  // anyways so try hard to prevent vectorization of division - it is\n  // generally a bad idea. Assume somewhat arbitrarily that we have to be able\n  // to hide \"20 cycles\" for each lane.\n  if (LT.second.isVector() && (ISD == ISD::SDIV || ISD == ISD::SREM ||\n                               ISD == ISD::UDIV || ISD == ISD::UREM)) {\n    int ScalarCost = getArithmeticInstrCost(\n        Opcode, Ty->getScalarType(), CostKind, Op1Info, Op2Info,\n        TargetTransformInfo::OP_None, TargetTransformInfo::OP_None);\n    return 20 * LT.first * LT.second.getVectorNumElements() * ScalarCost;\n  }\n\n  // Fallback to the default implementation.\n  return BaseT::getArithmeticInstrCost(Opcode, Ty, CostKind, Op1Info, Op2Info);\n}\n\nint X86TTIImpl::getShuffleCost(TTI::ShuffleKind Kind, VectorType *BaseTp,\n                               int Index, VectorType *SubTp) {\n  // 64-bit packed float vectors (v2f32) are widened to type v4f32.\n  // 64-bit packed integer vectors (v2i32) are widened to type v4i32.\n  std::pair<int, MVT> LT = TLI->getTypeLegalizationCost(DL, BaseTp);\n\n  // Treat Transpose as 2-op shuffles - there's no difference in lowering.\n  if (Kind == TTI::SK_Transpose)\n    Kind = TTI::SK_PermuteTwoSrc;\n\n  // For Broadcasts we are splatting the first element from the first input\n  // register, so only need to reference that input and all the output\n  // registers are the same.\n  if (Kind == TTI::SK_Broadcast)\n    LT.first = 1;\n\n  // Subvector extractions are free if they start at the beginning of a\n  // vector and cheap if the subvectors are aligned.\n  if (Kind == TTI::SK_ExtractSubvector && LT.second.isVector()) {\n    int NumElts = LT.second.getVectorNumElements();\n    if ((Index % NumElts) == 0)\n      return 0;\n    std::pair<int, MVT> SubLT = TLI->getTypeLegalizationCost(DL, SubTp);\n    if (SubLT.second.isVector()) {\n      int NumSubElts = SubLT.second.getVectorNumElements();\n      if ((Index % NumSubElts) == 0 && (NumElts % NumSubElts) == 0)\n        return SubLT.first;\n      // Handle some cases for widening legalization. For now we only handle\n      // cases where the original subvector was naturally aligned and evenly\n      // fit in its legalized subvector type.\n      // FIXME: Remove some of the alignment restrictions.\n      // FIXME: We can use permq for 64-bit or larger extracts from 256-bit\n      // vectors.\n      int OrigSubElts = cast<FixedVectorType>(SubTp)->getNumElements();\n      if (NumSubElts > OrigSubElts && (Index % OrigSubElts) == 0 &&\n          (NumSubElts % OrigSubElts) == 0 &&\n          LT.second.getVectorElementType() ==\n              SubLT.second.getVectorElementType() &&\n          LT.second.getVectorElementType().getSizeInBits() ==\n              BaseTp->getElementType()->getPrimitiveSizeInBits()) {\n        assert(NumElts >= NumSubElts && NumElts > OrigSubElts &&\n               \"Unexpected number of elements!\");\n        auto *VecTy = FixedVectorType::get(BaseTp->getElementType(),\n                                           LT.second.getVectorNumElements());\n        auto *SubTy = FixedVectorType::get(BaseTp->getElementType(),\n                                           SubLT.second.getVectorNumElements());\n        int ExtractIndex = alignDown((Index % NumElts), NumSubElts);\n        int ExtractCost = getShuffleCost(TTI::SK_ExtractSubvector, VecTy,\n                                         ExtractIndex, SubTy);\n\n        // If the original size is 32-bits or more, we can use pshufd. Otherwise\n        // if we have SSSE3 we can use pshufb.\n        if (SubTp->getPrimitiveSizeInBits() >= 32 || ST->hasSSSE3())\n          return ExtractCost + 1; // pshufd or pshufb\n\n        assert(SubTp->getPrimitiveSizeInBits() == 16 &&\n               \"Unexpected vector size\");\n\n        return ExtractCost + 2; // worst case pshufhw + pshufd\n      }\n    }\n  }\n\n  // Handle some common (illegal) sub-vector types as they are often very cheap\n  // to shuffle even on targets without PSHUFB.\n  EVT VT = TLI->getValueType(DL, BaseTp);\n  if (VT.isSimple() && VT.isVector() && VT.getSizeInBits() < 128 &&\n      !ST->hasSSSE3()) {\n     static const CostTblEntry SSE2SubVectorShuffleTbl[] = {\n      {TTI::SK_Broadcast,        MVT::v4i16, 1}, // pshuflw\n      {TTI::SK_Broadcast,        MVT::v2i16, 1}, // pshuflw\n      {TTI::SK_Broadcast,        MVT::v8i8,  2}, // punpck/pshuflw\n      {TTI::SK_Broadcast,        MVT::v4i8,  2}, // punpck/pshuflw\n      {TTI::SK_Broadcast,        MVT::v2i8,  1}, // punpck\n\n      {TTI::SK_Reverse,          MVT::v4i16, 1}, // pshuflw\n      {TTI::SK_Reverse,          MVT::v2i16, 1}, // pshuflw\n      {TTI::SK_Reverse,          MVT::v4i8,  3}, // punpck/pshuflw/packus\n      {TTI::SK_Reverse,          MVT::v2i8,  1}, // punpck\n\n      {TTI::SK_PermuteTwoSrc,    MVT::v4i16, 2}, // punpck/pshuflw\n      {TTI::SK_PermuteTwoSrc,    MVT::v2i16, 2}, // punpck/pshuflw\n      {TTI::SK_PermuteTwoSrc,    MVT::v8i8,  7}, // punpck/pshuflw\n      {TTI::SK_PermuteTwoSrc,    MVT::v4i8,  4}, // punpck/pshuflw\n      {TTI::SK_PermuteTwoSrc,    MVT::v2i8,  2}, // punpck\n\n      {TTI::SK_PermuteSingleSrc, MVT::v4i16, 1}, // pshuflw\n      {TTI::SK_PermuteSingleSrc, MVT::v2i16, 1}, // pshuflw\n      {TTI::SK_PermuteSingleSrc, MVT::v8i8,  5}, // punpck/pshuflw\n      {TTI::SK_PermuteSingleSrc, MVT::v4i8,  3}, // punpck/pshuflw\n      {TTI::SK_PermuteSingleSrc, MVT::v2i8,  1}, // punpck\n    };\n\n    if (ST->hasSSE2())\n      if (const auto *Entry =\n              CostTableLookup(SSE2SubVectorShuffleTbl, Kind, VT.getSimpleVT()))\n        return Entry->Cost;\n  }\n\n  // We are going to permute multiple sources and the result will be in multiple\n  // destinations. Providing an accurate cost only for splits where the element\n  // type remains the same.\n  if (Kind == TTI::SK_PermuteSingleSrc && LT.first != 1) {\n    MVT LegalVT = LT.second;\n    if (LegalVT.isVector() &&\n        LegalVT.getVectorElementType().getSizeInBits() ==\n            BaseTp->getElementType()->getPrimitiveSizeInBits() &&\n        LegalVT.getVectorNumElements() <\n            cast<FixedVectorType>(BaseTp)->getNumElements()) {\n\n      unsigned VecTySize = DL.getTypeStoreSize(BaseTp);\n      unsigned LegalVTSize = LegalVT.getStoreSize();\n      // Number of source vectors after legalization:\n      unsigned NumOfSrcs = (VecTySize + LegalVTSize - 1) / LegalVTSize;\n      // Number of destination vectors after legalization:\n      unsigned NumOfDests = LT.first;\n\n      auto *SingleOpTy = FixedVectorType::get(BaseTp->getElementType(),\n                                              LegalVT.getVectorNumElements());\n\n      unsigned NumOfShuffles = (NumOfSrcs - 1) * NumOfDests;\n      return NumOfShuffles *\n             getShuffleCost(TTI::SK_PermuteTwoSrc, SingleOpTy, 0, nullptr);\n    }\n\n    return BaseT::getShuffleCost(Kind, BaseTp, Index, SubTp);\n  }\n\n  // For 2-input shuffles, we must account for splitting the 2 inputs into many.\n  if (Kind == TTI::SK_PermuteTwoSrc && LT.first != 1) {\n    // We assume that source and destination have the same vector type.\n    int NumOfDests = LT.first;\n    int NumOfShufflesPerDest = LT.first * 2 - 1;\n    LT.first = NumOfDests * NumOfShufflesPerDest;\n  }\n\n  static const CostTblEntry AVX512VBMIShuffleTbl[] = {\n      {TTI::SK_Reverse, MVT::v64i8, 1}, // vpermb\n      {TTI::SK_Reverse, MVT::v32i8, 1}, // vpermb\n\n      {TTI::SK_PermuteSingleSrc, MVT::v64i8, 1}, // vpermb\n      {TTI::SK_PermuteSingleSrc, MVT::v32i8, 1}, // vpermb\n\n      {TTI::SK_PermuteTwoSrc, MVT::v64i8, 2}, // vpermt2b\n      {TTI::SK_PermuteTwoSrc, MVT::v32i8, 2}, // vpermt2b\n      {TTI::SK_PermuteTwoSrc, MVT::v16i8, 2}  // vpermt2b\n  };\n\n  if (ST->hasVBMI())\n    if (const auto *Entry =\n            CostTableLookup(AVX512VBMIShuffleTbl, Kind, LT.second))\n      return LT.first * Entry->Cost;\n\n  static const CostTblEntry AVX512BWShuffleTbl[] = {\n      {TTI::SK_Broadcast, MVT::v32i16, 1}, // vpbroadcastw\n      {TTI::SK_Broadcast, MVT::v64i8, 1},  // vpbroadcastb\n\n      {TTI::SK_Reverse, MVT::v32i16, 2}, // vpermw\n      {TTI::SK_Reverse, MVT::v16i16, 2}, // vpermw\n      {TTI::SK_Reverse, MVT::v64i8, 2},  // pshufb + vshufi64x2\n\n      {TTI::SK_PermuteSingleSrc, MVT::v32i16, 2}, // vpermw\n      {TTI::SK_PermuteSingleSrc, MVT::v16i16, 2}, // vpermw\n      {TTI::SK_PermuteSingleSrc, MVT::v64i8, 8},  // extend to v32i16\n\n      {TTI::SK_PermuteTwoSrc, MVT::v32i16, 2}, // vpermt2w\n      {TTI::SK_PermuteTwoSrc, MVT::v16i16, 2}, // vpermt2w\n      {TTI::SK_PermuteTwoSrc, MVT::v8i16, 2},  // vpermt2w\n      {TTI::SK_PermuteTwoSrc, MVT::v64i8, 19}, // 6 * v32i8 + 1\n\n      {TTI::SK_Select, MVT::v32i16, 1}, // vblendmw\n      {TTI::SK_Select, MVT::v64i8,  1}, // vblendmb\n  };\n\n  if (ST->hasBWI())\n    if (const auto *Entry =\n            CostTableLookup(AVX512BWShuffleTbl, Kind, LT.second))\n      return LT.first * Entry->Cost;\n\n  static const CostTblEntry AVX512ShuffleTbl[] = {\n      {TTI::SK_Broadcast, MVT::v8f64, 1},  // vbroadcastpd\n      {TTI::SK_Broadcast, MVT::v16f32, 1}, // vbroadcastps\n      {TTI::SK_Broadcast, MVT::v8i64, 1},  // vpbroadcastq\n      {TTI::SK_Broadcast, MVT::v16i32, 1}, // vpbroadcastd\n      {TTI::SK_Broadcast, MVT::v32i16, 1}, // vpbroadcastw\n      {TTI::SK_Broadcast, MVT::v64i8, 1},  // vpbroadcastb\n\n      {TTI::SK_Reverse, MVT::v8f64, 1},  // vpermpd\n      {TTI::SK_Reverse, MVT::v16f32, 1}, // vpermps\n      {TTI::SK_Reverse, MVT::v8i64, 1},  // vpermq\n      {TTI::SK_Reverse, MVT::v16i32, 1}, // vpermd\n\n      {TTI::SK_PermuteSingleSrc, MVT::v8f64, 1},  // vpermpd\n      {TTI::SK_PermuteSingleSrc, MVT::v4f64, 1},  // vpermpd\n      {TTI::SK_PermuteSingleSrc, MVT::v2f64, 1},  // vpermpd\n      {TTI::SK_PermuteSingleSrc, MVT::v16f32, 1}, // vpermps\n      {TTI::SK_PermuteSingleSrc, MVT::v8f32, 1},  // vpermps\n      {TTI::SK_PermuteSingleSrc, MVT::v4f32, 1},  // vpermps\n      {TTI::SK_PermuteSingleSrc, MVT::v8i64, 1},  // vpermq\n      {TTI::SK_PermuteSingleSrc, MVT::v4i64, 1},  // vpermq\n      {TTI::SK_PermuteSingleSrc, MVT::v2i64, 1},  // vpermq\n      {TTI::SK_PermuteSingleSrc, MVT::v16i32, 1}, // vpermd\n      {TTI::SK_PermuteSingleSrc, MVT::v8i32, 1},  // vpermd\n      {TTI::SK_PermuteSingleSrc, MVT::v4i32, 1},  // vpermd\n      {TTI::SK_PermuteSingleSrc, MVT::v16i8, 1},  // pshufb\n\n      {TTI::SK_PermuteTwoSrc, MVT::v8f64, 1},  // vpermt2pd\n      {TTI::SK_PermuteTwoSrc, MVT::v16f32, 1}, // vpermt2ps\n      {TTI::SK_PermuteTwoSrc, MVT::v8i64, 1},  // vpermt2q\n      {TTI::SK_PermuteTwoSrc, MVT::v16i32, 1}, // vpermt2d\n      {TTI::SK_PermuteTwoSrc, MVT::v4f64, 1},  // vpermt2pd\n      {TTI::SK_PermuteTwoSrc, MVT::v8f32, 1},  // vpermt2ps\n      {TTI::SK_PermuteTwoSrc, MVT::v4i64, 1},  // vpermt2q\n      {TTI::SK_PermuteTwoSrc, MVT::v8i32, 1},  // vpermt2d\n      {TTI::SK_PermuteTwoSrc, MVT::v2f64, 1},  // vpermt2pd\n      {TTI::SK_PermuteTwoSrc, MVT::v4f32, 1},  // vpermt2ps\n      {TTI::SK_PermuteTwoSrc, MVT::v2i64, 1},  // vpermt2q\n      {TTI::SK_PermuteTwoSrc, MVT::v4i32, 1},  // vpermt2d\n\n      // FIXME: This just applies the type legalization cost rules above\n      // assuming these completely split.\n      {TTI::SK_PermuteSingleSrc, MVT::v32i16, 14},\n      {TTI::SK_PermuteSingleSrc, MVT::v64i8,  14},\n      {TTI::SK_PermuteTwoSrc,    MVT::v32i16, 42},\n      {TTI::SK_PermuteTwoSrc,    MVT::v64i8,  42},\n\n      {TTI::SK_Select, MVT::v32i16, 1}, // vpternlogq\n      {TTI::SK_Select, MVT::v64i8,  1}, // vpternlogq\n      {TTI::SK_Select, MVT::v8f64,  1}, // vblendmpd\n      {TTI::SK_Select, MVT::v16f32, 1}, // vblendmps\n      {TTI::SK_Select, MVT::v8i64,  1}, // vblendmq\n      {TTI::SK_Select, MVT::v16i32, 1}, // vblendmd\n  };\n\n  if (ST->hasAVX512())\n    if (const auto *Entry = CostTableLookup(AVX512ShuffleTbl, Kind, LT.second))\n      return LT.first * Entry->Cost;\n\n  static const CostTblEntry AVX2ShuffleTbl[] = {\n      {TTI::SK_Broadcast, MVT::v4f64, 1},  // vbroadcastpd\n      {TTI::SK_Broadcast, MVT::v8f32, 1},  // vbroadcastps\n      {TTI::SK_Broadcast, MVT::v4i64, 1},  // vpbroadcastq\n      {TTI::SK_Broadcast, MVT::v8i32, 1},  // vpbroadcastd\n      {TTI::SK_Broadcast, MVT::v16i16, 1}, // vpbroadcastw\n      {TTI::SK_Broadcast, MVT::v32i8, 1},  // vpbroadcastb\n\n      {TTI::SK_Reverse, MVT::v4f64, 1},  // vpermpd\n      {TTI::SK_Reverse, MVT::v8f32, 1},  // vpermps\n      {TTI::SK_Reverse, MVT::v4i64, 1},  // vpermq\n      {TTI::SK_Reverse, MVT::v8i32, 1},  // vpermd\n      {TTI::SK_Reverse, MVT::v16i16, 2}, // vperm2i128 + pshufb\n      {TTI::SK_Reverse, MVT::v32i8, 2},  // vperm2i128 + pshufb\n\n      {TTI::SK_Select, MVT::v16i16, 1}, // vpblendvb\n      {TTI::SK_Select, MVT::v32i8, 1},  // vpblendvb\n\n      {TTI::SK_PermuteSingleSrc, MVT::v4f64, 1},  // vpermpd\n      {TTI::SK_PermuteSingleSrc, MVT::v8f32, 1},  // vpermps\n      {TTI::SK_PermuteSingleSrc, MVT::v4i64, 1},  // vpermq\n      {TTI::SK_PermuteSingleSrc, MVT::v8i32, 1},  // vpermd\n      {TTI::SK_PermuteSingleSrc, MVT::v16i16, 4}, // vperm2i128 + 2*vpshufb\n                                                  // + vpblendvb\n      {TTI::SK_PermuteSingleSrc, MVT::v32i8, 4},  // vperm2i128 + 2*vpshufb\n                                                  // + vpblendvb\n\n      {TTI::SK_PermuteTwoSrc, MVT::v4f64, 3},  // 2*vpermpd + vblendpd\n      {TTI::SK_PermuteTwoSrc, MVT::v8f32, 3},  // 2*vpermps + vblendps\n      {TTI::SK_PermuteTwoSrc, MVT::v4i64, 3},  // 2*vpermq + vpblendd\n      {TTI::SK_PermuteTwoSrc, MVT::v8i32, 3},  // 2*vpermd + vpblendd\n      {TTI::SK_PermuteTwoSrc, MVT::v16i16, 7}, // 2*vperm2i128 + 4*vpshufb\n                                               // + vpblendvb\n      {TTI::SK_PermuteTwoSrc, MVT::v32i8, 7},  // 2*vperm2i128 + 4*vpshufb\n                                               // + vpblendvb\n  };\n\n  if (ST->hasAVX2())\n    if (const auto *Entry = CostTableLookup(AVX2ShuffleTbl, Kind, LT.second))\n      return LT.first * Entry->Cost;\n\n  static const CostTblEntry XOPShuffleTbl[] = {\n      {TTI::SK_PermuteSingleSrc, MVT::v4f64, 2},  // vperm2f128 + vpermil2pd\n      {TTI::SK_PermuteSingleSrc, MVT::v8f32, 2},  // vperm2f128 + vpermil2ps\n      {TTI::SK_PermuteSingleSrc, MVT::v4i64, 2},  // vperm2f128 + vpermil2pd\n      {TTI::SK_PermuteSingleSrc, MVT::v8i32, 2},  // vperm2f128 + vpermil2ps\n      {TTI::SK_PermuteSingleSrc, MVT::v16i16, 4}, // vextractf128 + 2*vpperm\n                                                  // + vinsertf128\n      {TTI::SK_PermuteSingleSrc, MVT::v32i8, 4},  // vextractf128 + 2*vpperm\n                                                  // + vinsertf128\n\n      {TTI::SK_PermuteTwoSrc, MVT::v16i16, 9}, // 2*vextractf128 + 6*vpperm\n                                               // + vinsertf128\n      {TTI::SK_PermuteTwoSrc, MVT::v8i16, 1},  // vpperm\n      {TTI::SK_PermuteTwoSrc, MVT::v32i8, 9},  // 2*vextractf128 + 6*vpperm\n                                               // + vinsertf128\n      {TTI::SK_PermuteTwoSrc, MVT::v16i8, 1},  // vpperm\n  };\n\n  if (ST->hasXOP())\n    if (const auto *Entry = CostTableLookup(XOPShuffleTbl, Kind, LT.second))\n      return LT.first * Entry->Cost;\n\n  static const CostTblEntry AVX1ShuffleTbl[] = {\n      {TTI::SK_Broadcast, MVT::v4f64, 2},  // vperm2f128 + vpermilpd\n      {TTI::SK_Broadcast, MVT::v8f32, 2},  // vperm2f128 + vpermilps\n      {TTI::SK_Broadcast, MVT::v4i64, 2},  // vperm2f128 + vpermilpd\n      {TTI::SK_Broadcast, MVT::v8i32, 2},  // vperm2f128 + vpermilps\n      {TTI::SK_Broadcast, MVT::v16i16, 3}, // vpshuflw + vpshufd + vinsertf128\n      {TTI::SK_Broadcast, MVT::v32i8, 2},  // vpshufb + vinsertf128\n\n      {TTI::SK_Reverse, MVT::v4f64, 2},  // vperm2f128 + vpermilpd\n      {TTI::SK_Reverse, MVT::v8f32, 2},  // vperm2f128 + vpermilps\n      {TTI::SK_Reverse, MVT::v4i64, 2},  // vperm2f128 + vpermilpd\n      {TTI::SK_Reverse, MVT::v8i32, 2},  // vperm2f128 + vpermilps\n      {TTI::SK_Reverse, MVT::v16i16, 4}, // vextractf128 + 2*pshufb\n                                         // + vinsertf128\n      {TTI::SK_Reverse, MVT::v32i8, 4},  // vextractf128 + 2*pshufb\n                                         // + vinsertf128\n\n      {TTI::SK_Select, MVT::v4i64, 1},  // vblendpd\n      {TTI::SK_Select, MVT::v4f64, 1},  // vblendpd\n      {TTI::SK_Select, MVT::v8i32, 1},  // vblendps\n      {TTI::SK_Select, MVT::v8f32, 1},  // vblendps\n      {TTI::SK_Select, MVT::v16i16, 3}, // vpand + vpandn + vpor\n      {TTI::SK_Select, MVT::v32i8, 3},  // vpand + vpandn + vpor\n\n      {TTI::SK_PermuteSingleSrc, MVT::v4f64, 2},  // vperm2f128 + vshufpd\n      {TTI::SK_PermuteSingleSrc, MVT::v4i64, 2},  // vperm2f128 + vshufpd\n      {TTI::SK_PermuteSingleSrc, MVT::v8f32, 4},  // 2*vperm2f128 + 2*vshufps\n      {TTI::SK_PermuteSingleSrc, MVT::v8i32, 4},  // 2*vperm2f128 + 2*vshufps\n      {TTI::SK_PermuteSingleSrc, MVT::v16i16, 8}, // vextractf128 + 4*pshufb\n                                                  // + 2*por + vinsertf128\n      {TTI::SK_PermuteSingleSrc, MVT::v32i8, 8},  // vextractf128 + 4*pshufb\n                                                  // + 2*por + vinsertf128\n\n      {TTI::SK_PermuteTwoSrc, MVT::v4f64, 3},   // 2*vperm2f128 + vshufpd\n      {TTI::SK_PermuteTwoSrc, MVT::v4i64, 3},   // 2*vperm2f128 + vshufpd\n      {TTI::SK_PermuteTwoSrc, MVT::v8f32, 4},   // 2*vperm2f128 + 2*vshufps\n      {TTI::SK_PermuteTwoSrc, MVT::v8i32, 4},   // 2*vperm2f128 + 2*vshufps\n      {TTI::SK_PermuteTwoSrc, MVT::v16i16, 15}, // 2*vextractf128 + 8*pshufb\n                                                // + 4*por + vinsertf128\n      {TTI::SK_PermuteTwoSrc, MVT::v32i8, 15},  // 2*vextractf128 + 8*pshufb\n                                                // + 4*por + vinsertf128\n  };\n\n  if (ST->hasAVX())\n    if (const auto *Entry = CostTableLookup(AVX1ShuffleTbl, Kind, LT.second))\n      return LT.first * Entry->Cost;\n\n  static const CostTblEntry SSE41ShuffleTbl[] = {\n      {TTI::SK_Select, MVT::v2i64, 1}, // pblendw\n      {TTI::SK_Select, MVT::v2f64, 1}, // movsd\n      {TTI::SK_Select, MVT::v4i32, 1}, // pblendw\n      {TTI::SK_Select, MVT::v4f32, 1}, // blendps\n      {TTI::SK_Select, MVT::v8i16, 1}, // pblendw\n      {TTI::SK_Select, MVT::v16i8, 1}  // pblendvb\n  };\n\n  if (ST->hasSSE41())\n    if (const auto *Entry = CostTableLookup(SSE41ShuffleTbl, Kind, LT.second))\n      return LT.first * Entry->Cost;\n\n  static const CostTblEntry SSSE3ShuffleTbl[] = {\n      {TTI::SK_Broadcast, MVT::v8i16, 1}, // pshufb\n      {TTI::SK_Broadcast, MVT::v16i8, 1}, // pshufb\n\n      {TTI::SK_Reverse, MVT::v8i16, 1}, // pshufb\n      {TTI::SK_Reverse, MVT::v16i8, 1}, // pshufb\n\n      {TTI::SK_Select, MVT::v8i16, 3}, // 2*pshufb + por\n      {TTI::SK_Select, MVT::v16i8, 3}, // 2*pshufb + por\n\n      {TTI::SK_PermuteSingleSrc, MVT::v8i16, 1}, // pshufb\n      {TTI::SK_PermuteSingleSrc, MVT::v16i8, 1}, // pshufb\n\n      {TTI::SK_PermuteTwoSrc, MVT::v8i16, 3}, // 2*pshufb + por\n      {TTI::SK_PermuteTwoSrc, MVT::v16i8, 3}, // 2*pshufb + por\n  };\n\n  if (ST->hasSSSE3())\n    if (const auto *Entry = CostTableLookup(SSSE3ShuffleTbl, Kind, LT.second))\n      return LT.first * Entry->Cost;\n\n  static const CostTblEntry SSE2ShuffleTbl[] = {\n      {TTI::SK_Broadcast, MVT::v2f64, 1}, // shufpd\n      {TTI::SK_Broadcast, MVT::v2i64, 1}, // pshufd\n      {TTI::SK_Broadcast, MVT::v4i32, 1}, // pshufd\n      {TTI::SK_Broadcast, MVT::v8i16, 2}, // pshuflw + pshufd\n      {TTI::SK_Broadcast, MVT::v16i8, 3}, // unpck + pshuflw + pshufd\n\n      {TTI::SK_Reverse, MVT::v2f64, 1}, // shufpd\n      {TTI::SK_Reverse, MVT::v2i64, 1}, // pshufd\n      {TTI::SK_Reverse, MVT::v4i32, 1}, // pshufd\n      {TTI::SK_Reverse, MVT::v8i16, 3}, // pshuflw + pshufhw + pshufd\n      {TTI::SK_Reverse, MVT::v16i8, 9}, // 2*pshuflw + 2*pshufhw\n                                        // + 2*pshufd + 2*unpck + packus\n\n      {TTI::SK_Select, MVT::v2i64, 1}, // movsd\n      {TTI::SK_Select, MVT::v2f64, 1}, // movsd\n      {TTI::SK_Select, MVT::v4i32, 2}, // 2*shufps\n      {TTI::SK_Select, MVT::v8i16, 3}, // pand + pandn + por\n      {TTI::SK_Select, MVT::v16i8, 3}, // pand + pandn + por\n\n      {TTI::SK_PermuteSingleSrc, MVT::v2f64, 1}, // shufpd\n      {TTI::SK_PermuteSingleSrc, MVT::v2i64, 1}, // pshufd\n      {TTI::SK_PermuteSingleSrc, MVT::v4i32, 1}, // pshufd\n      {TTI::SK_PermuteSingleSrc, MVT::v8i16, 5}, // 2*pshuflw + 2*pshufhw\n                                                  // + pshufd/unpck\n    { TTI::SK_PermuteSingleSrc, MVT::v16i8, 10 }, // 2*pshuflw + 2*pshufhw\n                                                  // + 2*pshufd + 2*unpck + 2*packus\n\n    { TTI::SK_PermuteTwoSrc,    MVT::v2f64,  1 }, // shufpd\n    { TTI::SK_PermuteTwoSrc,    MVT::v2i64,  1 }, // shufpd\n    { TTI::SK_PermuteTwoSrc,    MVT::v4i32,  2 }, // 2*{unpck,movsd,pshufd}\n    { TTI::SK_PermuteTwoSrc,    MVT::v8i16,  8 }, // blend+permute\n    { TTI::SK_PermuteTwoSrc,    MVT::v16i8, 13 }, // blend+permute\n  };\n\n  if (ST->hasSSE2())\n    if (const auto *Entry = CostTableLookup(SSE2ShuffleTbl, Kind, LT.second))\n      return LT.first * Entry->Cost;\n\n  static const CostTblEntry SSE1ShuffleTbl[] = {\n    { TTI::SK_Broadcast,        MVT::v4f32, 1 }, // shufps\n    { TTI::SK_Reverse,          MVT::v4f32, 1 }, // shufps\n    { TTI::SK_Select,           MVT::v4f32, 2 }, // 2*shufps\n    { TTI::SK_PermuteSingleSrc, MVT::v4f32, 1 }, // shufps\n    { TTI::SK_PermuteTwoSrc,    MVT::v4f32, 2 }, // 2*shufps\n  };\n\n  if (ST->hasSSE1())\n    if (const auto *Entry = CostTableLookup(SSE1ShuffleTbl, Kind, LT.second))\n      return LT.first * Entry->Cost;\n\n  return BaseT::getShuffleCost(Kind, BaseTp, Index, SubTp);\n}\n\nint X86TTIImpl::getCastInstrCost(unsigned Opcode, Type *Dst, Type *Src,\n                                 TTI::CastContextHint CCH,\n                                 TTI::TargetCostKind CostKind,\n                                 const Instruction *I) {\n  int ISD = TLI->InstructionOpcodeToISD(Opcode);\n  assert(ISD && \"Invalid opcode\");\n\n  // TODO: Allow non-throughput costs that aren't binary.\n  auto AdjustCost = [&CostKind](int Cost) {\n    if (CostKind != TTI::TCK_RecipThroughput)\n      return Cost == 0 ? 0 : 1;\n    return Cost;\n  };\n\n  // FIXME: Need a better design of the cost table to handle non-simple types of\n  // potential massive combinations (elem_num x src_type x dst_type).\n\n  static const TypeConversionCostTblEntry AVX512BWConversionTbl[] {\n    { ISD::SIGN_EXTEND, MVT::v32i16, MVT::v32i8, 1 },\n    { ISD::ZERO_EXTEND, MVT::v32i16, MVT::v32i8, 1 },\n\n    // Mask sign extend has an instruction.\n    { ISD::SIGN_EXTEND, MVT::v2i8,   MVT::v2i1,  1 },\n    { ISD::SIGN_EXTEND, MVT::v2i16,  MVT::v2i1,  1 },\n    { ISD::SIGN_EXTEND, MVT::v4i8,   MVT::v4i1,  1 },\n    { ISD::SIGN_EXTEND, MVT::v4i16,  MVT::v4i1,  1 },\n    { ISD::SIGN_EXTEND, MVT::v8i8,   MVT::v8i1,  1 },\n    { ISD::SIGN_EXTEND, MVT::v8i16,  MVT::v8i1,  1 },\n    { ISD::SIGN_EXTEND, MVT::v16i8,  MVT::v16i1, 1 },\n    { ISD::SIGN_EXTEND, MVT::v16i16, MVT::v16i1, 1 },\n    { ISD::SIGN_EXTEND, MVT::v32i8,  MVT::v32i1, 1 },\n    { ISD::SIGN_EXTEND, MVT::v32i16, MVT::v32i1, 1 },\n    { ISD::SIGN_EXTEND, MVT::v64i8,  MVT::v64i1, 1 },\n\n    // Mask zero extend is a sext + shift.\n    { ISD::ZERO_EXTEND, MVT::v2i8,   MVT::v2i1,  2 },\n    { ISD::ZERO_EXTEND, MVT::v2i16,  MVT::v2i1,  2 },\n    { ISD::ZERO_EXTEND, MVT::v4i8,   MVT::v4i1,  2 },\n    { ISD::ZERO_EXTEND, MVT::v4i16,  MVT::v4i1,  2 },\n    { ISD::ZERO_EXTEND, MVT::v8i8,   MVT::v8i1,  2 },\n    { ISD::ZERO_EXTEND, MVT::v8i16,  MVT::v8i1,  2 },\n    { ISD::ZERO_EXTEND, MVT::v16i8,  MVT::v16i1, 2 },\n    { ISD::ZERO_EXTEND, MVT::v16i16, MVT::v16i1, 2 },\n    { ISD::ZERO_EXTEND, MVT::v32i8,  MVT::v32i1, 2 },\n    { ISD::ZERO_EXTEND, MVT::v32i16, MVT::v32i1, 2 },\n    { ISD::ZERO_EXTEND, MVT::v64i8,  MVT::v64i1, 2 },\n\n    { ISD::TRUNCATE,    MVT::v32i8,  MVT::v32i16, 2 },\n    { ISD::TRUNCATE,    MVT::v16i8,  MVT::v16i16, 2 }, // widen to zmm\n    { ISD::TRUNCATE,    MVT::v2i1,   MVT::v2i8,   2 }, // widen to zmm\n    { ISD::TRUNCATE,    MVT::v2i1,   MVT::v2i16,  2 }, // widen to zmm\n    { ISD::TRUNCATE,    MVT::v4i1,   MVT::v4i8,   2 }, // widen to zmm\n    { ISD::TRUNCATE,    MVT::v4i1,   MVT::v4i16,  2 }, // widen to zmm\n    { ISD::TRUNCATE,    MVT::v8i1,   MVT::v8i8,   2 }, // widen to zmm\n    { ISD::TRUNCATE,    MVT::v8i1,   MVT::v8i16,  2 }, // widen to zmm\n    { ISD::TRUNCATE,    MVT::v16i1,  MVT::v16i8,  2 }, // widen to zmm\n    { ISD::TRUNCATE,    MVT::v16i1,  MVT::v16i16, 2 }, // widen to zmm\n    { ISD::TRUNCATE,    MVT::v32i1,  MVT::v32i8,  2 }, // widen to zmm\n    { ISD::TRUNCATE,    MVT::v32i1,  MVT::v32i16, 2 },\n    { ISD::TRUNCATE,    MVT::v64i1,  MVT::v64i8,  2 },\n  };\n\n  static const TypeConversionCostTblEntry AVX512DQConversionTbl[] = {\n    { ISD::SINT_TO_FP,  MVT::v8f32,  MVT::v8i64,  1 },\n    { ISD::SINT_TO_FP,  MVT::v8f64,  MVT::v8i64,  1 },\n\n    { ISD::UINT_TO_FP,  MVT::v8f32,  MVT::v8i64,  1 },\n    { ISD::UINT_TO_FP,  MVT::v8f64,  MVT::v8i64,  1 },\n\n    { ISD::FP_TO_SINT,  MVT::v8i64,  MVT::v8f32,  1 },\n    { ISD::FP_TO_SINT,  MVT::v8i64,  MVT::v8f64,  1 },\n\n    { ISD::FP_TO_UINT,  MVT::v8i64,  MVT::v8f32,  1 },\n    { ISD::FP_TO_UINT,  MVT::v8i64,  MVT::v8f64,  1 },\n  };\n\n  // TODO: For AVX512DQ + AVX512VL, we also have cheap casts for 128-bit and\n  // 256-bit wide vectors.\n\n  static const TypeConversionCostTblEntry AVX512FConversionTbl[] = {\n    { ISD::FP_EXTEND, MVT::v8f64,   MVT::v8f32,  1 },\n    { ISD::FP_EXTEND, MVT::v8f64,   MVT::v16f32, 3 },\n    { ISD::FP_ROUND,  MVT::v8f32,   MVT::v8f64,  1 },\n\n    { ISD::TRUNCATE,  MVT::v2i1,    MVT::v2i8,   3 }, // sext+vpslld+vptestmd\n    { ISD::TRUNCATE,  MVT::v4i1,    MVT::v4i8,   3 }, // sext+vpslld+vptestmd\n    { ISD::TRUNCATE,  MVT::v8i1,    MVT::v8i8,   3 }, // sext+vpslld+vptestmd\n    { ISD::TRUNCATE,  MVT::v16i1,   MVT::v16i8,  3 }, // sext+vpslld+vptestmd\n    { ISD::TRUNCATE,  MVT::v2i1,    MVT::v2i16,  3 }, // sext+vpsllq+vptestmq\n    { ISD::TRUNCATE,  MVT::v4i1,    MVT::v4i16,  3 }, // sext+vpsllq+vptestmq\n    { ISD::TRUNCATE,  MVT::v8i1,    MVT::v8i16,  3 }, // sext+vpsllq+vptestmq\n    { ISD::TRUNCATE,  MVT::v16i1,   MVT::v16i16, 3 }, // sext+vpslld+vptestmd\n    { ISD::TRUNCATE,  MVT::v2i1,    MVT::v2i32,  2 }, // zmm vpslld+vptestmd\n    { ISD::TRUNCATE,  MVT::v4i1,    MVT::v4i32,  2 }, // zmm vpslld+vptestmd\n    { ISD::TRUNCATE,  MVT::v8i1,    MVT::v8i32,  2 }, // zmm vpslld+vptestmd\n    { ISD::TRUNCATE,  MVT::v16i1,   MVT::v16i32, 2 }, // vpslld+vptestmd\n    { ISD::TRUNCATE,  MVT::v2i1,    MVT::v2i64,  2 }, // zmm vpsllq+vptestmq\n    { ISD::TRUNCATE,  MVT::v4i1,    MVT::v4i64,  2 }, // zmm vpsllq+vptestmq\n    { ISD::TRUNCATE,  MVT::v8i1,    MVT::v8i64,  2 }, // vpsllq+vptestmq\n    { ISD::TRUNCATE,  MVT::v16i8,   MVT::v16i32, 2 },\n    { ISD::TRUNCATE,  MVT::v16i16,  MVT::v16i32, 2 },\n    { ISD::TRUNCATE,  MVT::v8i8,    MVT::v8i64,  2 },\n    { ISD::TRUNCATE,  MVT::v8i16,   MVT::v8i64,  2 },\n    { ISD::TRUNCATE,  MVT::v8i32,   MVT::v8i64,  1 },\n    { ISD::TRUNCATE,  MVT::v4i32,   MVT::v4i64,  1 }, // zmm vpmovqd\n    { ISD::TRUNCATE,  MVT::v16i8,   MVT::v16i64, 5 },// 2*vpmovqd+concat+vpmovdb\n\n    { ISD::TRUNCATE,  MVT::v16i8,  MVT::v16i16,  3 }, // extend to v16i32\n    { ISD::TRUNCATE,  MVT::v32i8,  MVT::v32i16,  8 },\n\n    // Sign extend is zmm vpternlogd+vptruncdb.\n    // Zero extend is zmm broadcast load+vptruncdw.\n    { ISD::SIGN_EXTEND, MVT::v2i8,   MVT::v2i1,   3 },\n    { ISD::ZERO_EXTEND, MVT::v2i8,   MVT::v2i1,   4 },\n    { ISD::SIGN_EXTEND, MVT::v4i8,   MVT::v4i1,   3 },\n    { ISD::ZERO_EXTEND, MVT::v4i8,   MVT::v4i1,   4 },\n    { ISD::SIGN_EXTEND, MVT::v8i8,   MVT::v8i1,   3 },\n    { ISD::ZERO_EXTEND, MVT::v8i8,   MVT::v8i1,   4 },\n    { ISD::SIGN_EXTEND, MVT::v16i8,  MVT::v16i1,  3 },\n    { ISD::ZERO_EXTEND, MVT::v16i8,  MVT::v16i1,  4 },\n\n    // Sign extend is zmm vpternlogd+vptruncdw.\n    // Zero extend is zmm vpternlogd+vptruncdw+vpsrlw.\n    { ISD::SIGN_EXTEND, MVT::v2i16,  MVT::v2i1,   3 },\n    { ISD::ZERO_EXTEND, MVT::v2i16,  MVT::v2i1,   4 },\n    { ISD::SIGN_EXTEND, MVT::v4i16,  MVT::v4i1,   3 },\n    { ISD::ZERO_EXTEND, MVT::v4i16,  MVT::v4i1,   4 },\n    { ISD::SIGN_EXTEND, MVT::v8i16,  MVT::v8i1,   3 },\n    { ISD::ZERO_EXTEND, MVT::v8i16,  MVT::v8i1,   4 },\n    { ISD::SIGN_EXTEND, MVT::v16i16, MVT::v16i1,  3 },\n    { ISD::ZERO_EXTEND, MVT::v16i16, MVT::v16i1,  4 },\n\n    { ISD::SIGN_EXTEND, MVT::v2i32,  MVT::v2i1,   1 }, // zmm vpternlogd\n    { ISD::ZERO_EXTEND, MVT::v2i32,  MVT::v2i1,   2 }, // zmm vpternlogd+psrld\n    { ISD::SIGN_EXTEND, MVT::v4i32,  MVT::v4i1,   1 }, // zmm vpternlogd\n    { ISD::ZERO_EXTEND, MVT::v4i32,  MVT::v4i1,   2 }, // zmm vpternlogd+psrld\n    { ISD::SIGN_EXTEND, MVT::v8i32,  MVT::v8i1,   1 }, // zmm vpternlogd\n    { ISD::ZERO_EXTEND, MVT::v8i32,  MVT::v8i1,   2 }, // zmm vpternlogd+psrld\n    { ISD::SIGN_EXTEND, MVT::v2i64,  MVT::v2i1,   1 }, // zmm vpternlogq\n    { ISD::ZERO_EXTEND, MVT::v2i64,  MVT::v2i1,   2 }, // zmm vpternlogq+psrlq\n    { ISD::SIGN_EXTEND, MVT::v4i64,  MVT::v4i1,   1 }, // zmm vpternlogq\n    { ISD::ZERO_EXTEND, MVT::v4i64,  MVT::v4i1,   2 }, // zmm vpternlogq+psrlq\n\n    { ISD::SIGN_EXTEND, MVT::v16i32, MVT::v16i1,  1 }, // vpternlogd\n    { ISD::ZERO_EXTEND, MVT::v16i32, MVT::v16i1,  2 }, // vpternlogd+psrld\n    { ISD::SIGN_EXTEND, MVT::v8i64,  MVT::v8i1,   1 }, // vpternlogq\n    { ISD::ZERO_EXTEND, MVT::v8i64,  MVT::v8i1,   2 }, // vpternlogq+psrlq\n\n    { ISD::SIGN_EXTEND, MVT::v16i32, MVT::v16i8,  1 },\n    { ISD::ZERO_EXTEND, MVT::v16i32, MVT::v16i8,  1 },\n    { ISD::SIGN_EXTEND, MVT::v16i32, MVT::v16i16, 1 },\n    { ISD::ZERO_EXTEND, MVT::v16i32, MVT::v16i16, 1 },\n    { ISD::SIGN_EXTEND, MVT::v8i64,  MVT::v8i8,   1 },\n    { ISD::ZERO_EXTEND, MVT::v8i64,  MVT::v8i8,   1 },\n    { ISD::SIGN_EXTEND, MVT::v8i64,  MVT::v8i16,  1 },\n    { ISD::ZERO_EXTEND, MVT::v8i64,  MVT::v8i16,  1 },\n    { ISD::SIGN_EXTEND, MVT::v8i64,  MVT::v8i32,  1 },\n    { ISD::ZERO_EXTEND, MVT::v8i64,  MVT::v8i32,  1 },\n\n    { ISD::SIGN_EXTEND, MVT::v32i16, MVT::v32i8, 3 }, // FIXME: May not be right\n    { ISD::ZERO_EXTEND, MVT::v32i16, MVT::v32i8, 3 }, // FIXME: May not be right\n\n    { ISD::SINT_TO_FP,  MVT::v8f64,  MVT::v8i1,   4 },\n    { ISD::SINT_TO_FP,  MVT::v16f32, MVT::v16i1,  3 },\n    { ISD::SINT_TO_FP,  MVT::v8f64,  MVT::v8i8,   2 },\n    { ISD::SINT_TO_FP,  MVT::v16f32, MVT::v16i8,  2 },\n    { ISD::SINT_TO_FP,  MVT::v8f64,  MVT::v8i16,  2 },\n    { ISD::SINT_TO_FP,  MVT::v16f32, MVT::v16i16, 2 },\n    { ISD::SINT_TO_FP,  MVT::v16f32, MVT::v16i32, 1 },\n    { ISD::SINT_TO_FP,  MVT::v8f64,  MVT::v8i32,  1 },\n\n    { ISD::UINT_TO_FP,  MVT::v8f64,  MVT::v8i1,   4 },\n    { ISD::UINT_TO_FP,  MVT::v16f32, MVT::v16i1,  3 },\n    { ISD::UINT_TO_FP,  MVT::v8f64,  MVT::v8i8,   2 },\n    { ISD::UINT_TO_FP,  MVT::v16f32, MVT::v16i8,  2 },\n    { ISD::UINT_TO_FP,  MVT::v8f64,  MVT::v8i16,  2 },\n    { ISD::UINT_TO_FP,  MVT::v16f32, MVT::v16i16, 2 },\n    { ISD::UINT_TO_FP,  MVT::v8f64,  MVT::v8i32,  1 },\n    { ISD::UINT_TO_FP,  MVT::v16f32, MVT::v16i32, 1 },\n    { ISD::UINT_TO_FP,  MVT::v8f32,  MVT::v8i64, 26 },\n    { ISD::UINT_TO_FP,  MVT::v8f64,  MVT::v8i64,  5 },\n\n    { ISD::FP_TO_SINT,  MVT::v8i8,   MVT::v8f64,  3 },\n    { ISD::FP_TO_SINT,  MVT::v8i16,  MVT::v8f64,  3 },\n    { ISD::FP_TO_SINT,  MVT::v16i8,  MVT::v16f32, 3 },\n    { ISD::FP_TO_SINT,  MVT::v16i16, MVT::v16f32, 3 },\n\n    { ISD::FP_TO_UINT,  MVT::v8i32,  MVT::v8f64,  1 },\n    { ISD::FP_TO_UINT,  MVT::v8i16,  MVT::v8f64,  3 },\n    { ISD::FP_TO_UINT,  MVT::v8i8,   MVT::v8f64,  3 },\n    { ISD::FP_TO_UINT,  MVT::v16i32, MVT::v16f32, 1 },\n    { ISD::FP_TO_UINT,  MVT::v16i16, MVT::v16f32, 3 },\n    { ISD::FP_TO_UINT,  MVT::v16i8,  MVT::v16f32, 3 },\n  };\n\n  static const TypeConversionCostTblEntry AVX512BWVLConversionTbl[] {\n    // Mask sign extend has an instruction.\n    { ISD::SIGN_EXTEND, MVT::v2i8,   MVT::v2i1,  1 },\n    { ISD::SIGN_EXTEND, MVT::v2i16,  MVT::v2i1,  1 },\n    { ISD::SIGN_EXTEND, MVT::v4i8,   MVT::v4i1,  1 },\n    { ISD::SIGN_EXTEND, MVT::v4i16,  MVT::v4i1,  1 },\n    { ISD::SIGN_EXTEND, MVT::v8i8,   MVT::v8i1,  1 },\n    { ISD::SIGN_EXTEND, MVT::v8i16,  MVT::v8i1,  1 },\n    { ISD::SIGN_EXTEND, MVT::v16i8,  MVT::v16i1, 1 },\n    { ISD::SIGN_EXTEND, MVT::v16i16, MVT::v16i1, 1 },\n    { ISD::SIGN_EXTEND, MVT::v32i8,  MVT::v32i1, 1 },\n\n    // Mask zero extend is a sext + shift.\n    { ISD::ZERO_EXTEND, MVT::v2i8,   MVT::v2i1,  2 },\n    { ISD::ZERO_EXTEND, MVT::v2i16,  MVT::v2i1,  2 },\n    { ISD::ZERO_EXTEND, MVT::v4i8,   MVT::v4i1,  2 },\n    { ISD::ZERO_EXTEND, MVT::v4i16,  MVT::v4i1,  2 },\n    { ISD::ZERO_EXTEND, MVT::v8i8,   MVT::v8i1,  2 },\n    { ISD::ZERO_EXTEND, MVT::v8i16,  MVT::v8i1,  2 },\n    { ISD::ZERO_EXTEND, MVT::v16i8,  MVT::v16i1, 2 },\n    { ISD::ZERO_EXTEND, MVT::v16i16, MVT::v16i1, 2 },\n    { ISD::ZERO_EXTEND, MVT::v32i8,  MVT::v32i1, 2 },\n\n    { ISD::TRUNCATE,    MVT::v16i8,  MVT::v16i16, 2 },\n    { ISD::TRUNCATE,    MVT::v2i1,   MVT::v2i8,   2 }, // vpsllw+vptestmb\n    { ISD::TRUNCATE,    MVT::v2i1,   MVT::v2i16,  2 }, // vpsllw+vptestmw\n    { ISD::TRUNCATE,    MVT::v4i1,   MVT::v4i8,   2 }, // vpsllw+vptestmb\n    { ISD::TRUNCATE,    MVT::v4i1,   MVT::v4i16,  2 }, // vpsllw+vptestmw\n    { ISD::TRUNCATE,    MVT::v8i1,   MVT::v8i8,   2 }, // vpsllw+vptestmb\n    { ISD::TRUNCATE,    MVT::v8i1,   MVT::v8i16,  2 }, // vpsllw+vptestmw\n    { ISD::TRUNCATE,    MVT::v16i1,  MVT::v16i8,  2 }, // vpsllw+vptestmb\n    { ISD::TRUNCATE,    MVT::v16i1,  MVT::v16i16, 2 }, // vpsllw+vptestmw\n    { ISD::TRUNCATE,    MVT::v32i1,  MVT::v32i8,  2 }, // vpsllw+vptestmb\n  };\n\n  static const TypeConversionCostTblEntry AVX512DQVLConversionTbl[] = {\n    { ISD::SINT_TO_FP,  MVT::v2f32,  MVT::v2i64,  1 },\n    { ISD::SINT_TO_FP,  MVT::v2f64,  MVT::v2i64,  1 },\n    { ISD::SINT_TO_FP,  MVT::v4f32,  MVT::v4i64,  1 },\n    { ISD::SINT_TO_FP,  MVT::v4f64,  MVT::v4i64,  1 },\n\n    { ISD::UINT_TO_FP,  MVT::v2f32,  MVT::v2i64,  1 },\n    { ISD::UINT_TO_FP,  MVT::v2f64,  MVT::v2i64,  1 },\n    { ISD::UINT_TO_FP,  MVT::v4f32,  MVT::v4i64,  1 },\n    { ISD::UINT_TO_FP,  MVT::v4f64,  MVT::v4i64,  1 },\n\n    { ISD::FP_TO_SINT,  MVT::v2i64,  MVT::v2f32,  1 },\n    { ISD::FP_TO_SINT,  MVT::v4i64,  MVT::v4f32,  1 },\n    { ISD::FP_TO_SINT,  MVT::v2i64,  MVT::v2f64,  1 },\n    { ISD::FP_TO_SINT,  MVT::v4i64,  MVT::v4f64,  1 },\n\n    { ISD::FP_TO_UINT,  MVT::v2i64,  MVT::v2f32,  1 },\n    { ISD::FP_TO_UINT,  MVT::v4i64,  MVT::v4f32,  1 },\n    { ISD::FP_TO_UINT,  MVT::v2i64,  MVT::v2f64,  1 },\n    { ISD::FP_TO_UINT,  MVT::v4i64,  MVT::v4f64,  1 },\n  };\n\n  static const TypeConversionCostTblEntry AVX512VLConversionTbl[] = {\n    { ISD::TRUNCATE,  MVT::v2i1,    MVT::v2i8,   3 }, // sext+vpslld+vptestmd\n    { ISD::TRUNCATE,  MVT::v4i1,    MVT::v4i8,   3 }, // sext+vpslld+vptestmd\n    { ISD::TRUNCATE,  MVT::v8i1,    MVT::v8i8,   3 }, // sext+vpslld+vptestmd\n    { ISD::TRUNCATE,  MVT::v16i1,   MVT::v16i8,  8 }, // split+2*v8i8\n    { ISD::TRUNCATE,  MVT::v2i1,    MVT::v2i16,  3 }, // sext+vpsllq+vptestmq\n    { ISD::TRUNCATE,  MVT::v4i1,    MVT::v4i16,  3 }, // sext+vpsllq+vptestmq\n    { ISD::TRUNCATE,  MVT::v8i1,    MVT::v8i16,  3 }, // sext+vpsllq+vptestmq\n    { ISD::TRUNCATE,  MVT::v16i1,   MVT::v16i16, 8 }, // split+2*v8i16\n    { ISD::TRUNCATE,  MVT::v2i1,    MVT::v2i32,  2 }, // vpslld+vptestmd\n    { ISD::TRUNCATE,  MVT::v4i1,    MVT::v4i32,  2 }, // vpslld+vptestmd\n    { ISD::TRUNCATE,  MVT::v8i1,    MVT::v8i32,  2 }, // vpslld+vptestmd\n    { ISD::TRUNCATE,  MVT::v2i1,    MVT::v2i64,  2 }, // vpsllq+vptestmq\n    { ISD::TRUNCATE,  MVT::v4i1,    MVT::v4i64,  2 }, // vpsllq+vptestmq\n    { ISD::TRUNCATE,  MVT::v4i32,   MVT::v4i64,  1 }, // vpmovqd\n\n    // sign extend is vpcmpeq+maskedmove+vpmovdw+vpacksswb\n    // zero extend is vpcmpeq+maskedmove+vpmovdw+vpsrlw+vpackuswb\n    { ISD::SIGN_EXTEND, MVT::v2i8,   MVT::v2i1,   5 },\n    { ISD::ZERO_EXTEND, MVT::v2i8,   MVT::v2i1,   6 },\n    { ISD::SIGN_EXTEND, MVT::v4i8,   MVT::v4i1,   5 },\n    { ISD::ZERO_EXTEND, MVT::v4i8,   MVT::v4i1,   6 },\n    { ISD::SIGN_EXTEND, MVT::v8i8,   MVT::v8i1,   5 },\n    { ISD::ZERO_EXTEND, MVT::v8i8,   MVT::v8i1,   6 },\n    { ISD::SIGN_EXTEND, MVT::v16i8,  MVT::v16i1, 10 },\n    { ISD::ZERO_EXTEND, MVT::v16i8,  MVT::v16i1, 12 },\n\n    // sign extend is vpcmpeq+maskedmove+vpmovdw\n    // zero extend is vpcmpeq+maskedmove+vpmovdw+vpsrlw\n    { ISD::SIGN_EXTEND, MVT::v2i16,  MVT::v2i1,   4 },\n    { ISD::ZERO_EXTEND, MVT::v2i16,  MVT::v2i1,   5 },\n    { ISD::SIGN_EXTEND, MVT::v4i16,  MVT::v4i1,   4 },\n    { ISD::ZERO_EXTEND, MVT::v4i16,  MVT::v4i1,   5 },\n    { ISD::SIGN_EXTEND, MVT::v8i16,  MVT::v8i1,   4 },\n    { ISD::ZERO_EXTEND, MVT::v8i16,  MVT::v8i1,   5 },\n    { ISD::SIGN_EXTEND, MVT::v16i16, MVT::v16i1, 10 },\n    { ISD::ZERO_EXTEND, MVT::v16i16, MVT::v16i1, 12 },\n\n    { ISD::SIGN_EXTEND, MVT::v2i32,  MVT::v2i1,   1 }, // vpternlogd\n    { ISD::ZERO_EXTEND, MVT::v2i32,  MVT::v2i1,   2 }, // vpternlogd+psrld\n    { ISD::SIGN_EXTEND, MVT::v4i32,  MVT::v4i1,   1 }, // vpternlogd\n    { ISD::ZERO_EXTEND, MVT::v4i32,  MVT::v4i1,   2 }, // vpternlogd+psrld\n    { ISD::SIGN_EXTEND, MVT::v8i32,  MVT::v8i1,   1 }, // vpternlogd\n    { ISD::ZERO_EXTEND, MVT::v8i32,  MVT::v8i1,   2 }, // vpternlogd+psrld\n    { ISD::SIGN_EXTEND, MVT::v2i64,  MVT::v2i1,   1 }, // vpternlogq\n    { ISD::ZERO_EXTEND, MVT::v2i64,  MVT::v2i1,   2 }, // vpternlogq+psrlq\n    { ISD::SIGN_EXTEND, MVT::v4i64,  MVT::v4i1,   1 }, // vpternlogq\n    { ISD::ZERO_EXTEND, MVT::v4i64,  MVT::v4i1,   2 }, // vpternlogq+psrlq\n\n    { ISD::UINT_TO_FP,  MVT::v2f64,  MVT::v2i8,   2 },\n    { ISD::UINT_TO_FP,  MVT::v4f64,  MVT::v4i8,   2 },\n    { ISD::UINT_TO_FP,  MVT::v8f32,  MVT::v8i8,   2 },\n    { ISD::UINT_TO_FP,  MVT::v2f64,  MVT::v2i16,  5 },\n    { ISD::UINT_TO_FP,  MVT::v4f64,  MVT::v4i16,  2 },\n    { ISD::UINT_TO_FP,  MVT::v8f32,  MVT::v8i16,  2 },\n    { ISD::UINT_TO_FP,  MVT::v2f32,  MVT::v2i32,  2 },\n    { ISD::UINT_TO_FP,  MVT::v2f64,  MVT::v2i32,  1 },\n    { ISD::UINT_TO_FP,  MVT::v4f32,  MVT::v4i32,  1 },\n    { ISD::UINT_TO_FP,  MVT::v4f64,  MVT::v4i32,  1 },\n    { ISD::UINT_TO_FP,  MVT::v8f32,  MVT::v8i32,  1 },\n    { ISD::UINT_TO_FP,  MVT::v2f32,  MVT::v2i64,  5 },\n    { ISD::UINT_TO_FP,  MVT::v2f64,  MVT::v2i64,  5 },\n    { ISD::UINT_TO_FP,  MVT::v4f64,  MVT::v4i64,  5 },\n\n    { ISD::UINT_TO_FP,  MVT::f32,    MVT::i64,    1 },\n    { ISD::UINT_TO_FP,  MVT::f64,    MVT::i64,    1 },\n\n    { ISD::FP_TO_SINT,  MVT::v8i8,   MVT::v8f32,  3 },\n    { ISD::FP_TO_UINT,  MVT::v8i8,   MVT::v8f32,  3 },\n\n    { ISD::FP_TO_UINT,  MVT::i64,    MVT::f32,    1 },\n    { ISD::FP_TO_UINT,  MVT::i64,    MVT::f64,    1 },\n\n    { ISD::FP_TO_UINT,  MVT::v2i32,  MVT::v2f32,  1 },\n    { ISD::FP_TO_UINT,  MVT::v4i32,  MVT::v4f32,  1 },\n    { ISD::FP_TO_UINT,  MVT::v2i32,  MVT::v2f64,  1 },\n    { ISD::FP_TO_UINT,  MVT::v4i32,  MVT::v4f64,  1 },\n    { ISD::FP_TO_UINT,  MVT::v8i32,  MVT::v8f32,  1 },\n  };\n\n  static const TypeConversionCostTblEntry AVX2ConversionTbl[] = {\n    { ISD::SIGN_EXTEND, MVT::v4i64,  MVT::v4i1,   3 },\n    { ISD::ZERO_EXTEND, MVT::v4i64,  MVT::v4i1,   3 },\n    { ISD::SIGN_EXTEND, MVT::v8i32,  MVT::v8i1,   3 },\n    { ISD::ZERO_EXTEND, MVT::v8i32,  MVT::v8i1,   3 },\n    { ISD::SIGN_EXTEND, MVT::v4i64,  MVT::v4i8,   1 },\n    { ISD::ZERO_EXTEND, MVT::v4i64,  MVT::v4i8,   1 },\n    { ISD::SIGN_EXTEND, MVT::v8i32,  MVT::v8i8,   1 },\n    { ISD::ZERO_EXTEND, MVT::v8i32,  MVT::v8i8,   1 },\n    { ISD::SIGN_EXTEND, MVT::v16i16, MVT::v16i1,  1 },\n    { ISD::ZERO_EXTEND, MVT::v16i16, MVT::v16i1,  1 },\n    { ISD::SIGN_EXTEND, MVT::v16i16, MVT::v16i8,  1 },\n    { ISD::ZERO_EXTEND, MVT::v16i16, MVT::v16i8,  1 },\n    { ISD::SIGN_EXTEND, MVT::v4i64,  MVT::v4i16,  1 },\n    { ISD::ZERO_EXTEND, MVT::v4i64,  MVT::v4i16,  1 },\n    { ISD::SIGN_EXTEND, MVT::v8i32,  MVT::v8i16,  1 },\n    { ISD::ZERO_EXTEND, MVT::v8i32,  MVT::v8i16,  1 },\n    { ISD::SIGN_EXTEND, MVT::v4i64,  MVT::v4i32,  1 },\n    { ISD::ZERO_EXTEND, MVT::v4i64,  MVT::v4i32,  1 },\n    { ISD::ZERO_EXTEND, MVT::v16i32, MVT::v16i16, 3 },\n    { ISD::SIGN_EXTEND, MVT::v16i32, MVT::v16i16, 3 },\n\n    { ISD::TRUNCATE,    MVT::v4i32,  MVT::v4i64,  2 },\n    { ISD::TRUNCATE,    MVT::v8i1,   MVT::v8i32,  2 },\n\n    { ISD::TRUNCATE,    MVT::v4i8,   MVT::v4i64,  2 },\n    { ISD::TRUNCATE,    MVT::v4i16,  MVT::v4i64,  2 },\n    { ISD::TRUNCATE,    MVT::v8i8,   MVT::v8i32,  2 },\n    { ISD::TRUNCATE,    MVT::v8i16,  MVT::v8i32,  2 },\n\n    { ISD::FP_EXTEND,   MVT::v8f64,  MVT::v8f32,  3 },\n    { ISD::FP_ROUND,    MVT::v8f32,  MVT::v8f64,  3 },\n\n    { ISD::UINT_TO_FP,  MVT::v8f32,  MVT::v8i32,  8 },\n  };\n\n  static const TypeConversionCostTblEntry AVXConversionTbl[] = {\n    { ISD::SIGN_EXTEND, MVT::v4i64,  MVT::v4i1,  6 },\n    { ISD::ZERO_EXTEND, MVT::v4i64,  MVT::v4i1,  4 },\n    { ISD::SIGN_EXTEND, MVT::v8i32,  MVT::v8i1,  7 },\n    { ISD::ZERO_EXTEND, MVT::v8i32,  MVT::v8i1,  4 },\n    { ISD::SIGN_EXTEND, MVT::v4i64,  MVT::v4i8,  4 },\n    { ISD::ZERO_EXTEND, MVT::v4i64,  MVT::v4i8,  4 },\n    { ISD::SIGN_EXTEND, MVT::v8i32,  MVT::v8i8,  4 },\n    { ISD::ZERO_EXTEND, MVT::v8i32,  MVT::v8i8,  4 },\n    { ISD::SIGN_EXTEND, MVT::v16i16, MVT::v16i1, 4 },\n    { ISD::ZERO_EXTEND, MVT::v16i16, MVT::v16i1, 4 },\n    { ISD::SIGN_EXTEND, MVT::v16i16, MVT::v16i8, 4 },\n    { ISD::ZERO_EXTEND, MVT::v16i16, MVT::v16i8, 4 },\n    { ISD::SIGN_EXTEND, MVT::v4i64,  MVT::v4i16, 4 },\n    { ISD::ZERO_EXTEND, MVT::v4i64,  MVT::v4i16, 3 },\n    { ISD::SIGN_EXTEND, MVT::v8i32,  MVT::v8i16, 4 },\n    { ISD::ZERO_EXTEND, MVT::v8i32,  MVT::v8i16, 4 },\n    { ISD::SIGN_EXTEND, MVT::v4i64,  MVT::v4i32, 4 },\n    { ISD::ZERO_EXTEND, MVT::v4i64,  MVT::v4i32, 4 },\n\n    { ISD::TRUNCATE,    MVT::v4i1,  MVT::v4i64,  4 },\n    { ISD::TRUNCATE,    MVT::v8i1,  MVT::v8i32,  5 },\n    { ISD::TRUNCATE,    MVT::v16i1, MVT::v16i16, 4 },\n    { ISD::TRUNCATE,    MVT::v8i1,  MVT::v8i64,  9 },\n    { ISD::TRUNCATE,    MVT::v16i1, MVT::v16i64, 11 },\n\n    { ISD::TRUNCATE,    MVT::v16i8, MVT::v16i16, 4 },\n    { ISD::TRUNCATE,    MVT::v8i8,  MVT::v8i32,  4 },\n    { ISD::TRUNCATE,    MVT::v8i16, MVT::v8i32,  5 },\n    { ISD::TRUNCATE,    MVT::v4i8,  MVT::v4i64,  4 },\n    { ISD::TRUNCATE,    MVT::v4i16, MVT::v4i64,  4 },\n    { ISD::TRUNCATE,    MVT::v4i32, MVT::v4i64,  2 },\n    { ISD::TRUNCATE,    MVT::v8i8,  MVT::v8i64, 11 },\n    { ISD::TRUNCATE,    MVT::v8i16, MVT::v8i64,  9 },\n    { ISD::TRUNCATE,    MVT::v8i32, MVT::v8i64,  3 },\n    { ISD::TRUNCATE,    MVT::v16i8, MVT::v16i64, 11 },\n\n    { ISD::SINT_TO_FP,  MVT::v4f32, MVT::v4i1,  3 },\n    { ISD::SINT_TO_FP,  MVT::v4f64, MVT::v4i1,  3 },\n    { ISD::SINT_TO_FP,  MVT::v8f32, MVT::v8i1,  8 },\n    { ISD::SINT_TO_FP,  MVT::v4f32, MVT::v4i8,  3 },\n    { ISD::SINT_TO_FP,  MVT::v4f64, MVT::v4i8,  3 },\n    { ISD::SINT_TO_FP,  MVT::v8f32, MVT::v8i8,  8 },\n    { ISD::SINT_TO_FP,  MVT::v4f32, MVT::v4i16, 3 },\n    { ISD::SINT_TO_FP,  MVT::v4f64, MVT::v4i16, 3 },\n    { ISD::SINT_TO_FP,  MVT::v8f32, MVT::v8i16, 5 },\n    { ISD::SINT_TO_FP,  MVT::v4f32, MVT::v4i32, 1 },\n    { ISD::SINT_TO_FP,  MVT::v4f64, MVT::v4i32, 1 },\n    { ISD::SINT_TO_FP,  MVT::v8f32, MVT::v8i32, 1 },\n\n    { ISD::UINT_TO_FP,  MVT::v4f32, MVT::v4i1,  7 },\n    { ISD::UINT_TO_FP,  MVT::v4f64, MVT::v4i1,  7 },\n    { ISD::UINT_TO_FP,  MVT::v8f32, MVT::v8i1,  6 },\n    { ISD::UINT_TO_FP,  MVT::v4f32, MVT::v4i8,  2 },\n    { ISD::UINT_TO_FP,  MVT::v4f64, MVT::v4i8,  2 },\n    { ISD::UINT_TO_FP,  MVT::v8f32, MVT::v8i8,  5 },\n    { ISD::UINT_TO_FP,  MVT::v4f32, MVT::v4i16, 2 },\n    { ISD::UINT_TO_FP,  MVT::v4f64, MVT::v4i16, 2 },\n    { ISD::UINT_TO_FP,  MVT::v8f32, MVT::v8i16, 5 },\n    { ISD::UINT_TO_FP,  MVT::v2f64, MVT::v2i32, 6 },\n    { ISD::UINT_TO_FP,  MVT::v4f32, MVT::v4i32, 6 },\n    { ISD::UINT_TO_FP,  MVT::v4f64, MVT::v4i32, 6 },\n    { ISD::UINT_TO_FP,  MVT::v8f32, MVT::v8i32, 9 },\n    { ISD::UINT_TO_FP,  MVT::v2f64, MVT::v2i64, 5 },\n    { ISD::UINT_TO_FP,  MVT::v4f64, MVT::v4i64, 6 },\n    // The generic code to compute the scalar overhead is currently broken.\n    // Workaround this limitation by estimating the scalarization overhead\n    // here. We have roughly 10 instructions per scalar element.\n    // Multiply that by the vector width.\n    // FIXME: remove that when PR19268 is fixed.\n    { ISD::SINT_TO_FP,  MVT::v4f64, MVT::v4i64, 13 },\n    { ISD::SINT_TO_FP,  MVT::v4f64, MVT::v4i64, 13 },\n\n    { ISD::FP_TO_SINT,  MVT::v8i8,  MVT::v8f32, 4 },\n    { ISD::FP_TO_SINT,  MVT::v4i8,  MVT::v4f64, 3 },\n    { ISD::FP_TO_SINT,  MVT::v4i16, MVT::v4f64, 2 },\n    { ISD::FP_TO_SINT,  MVT::v8i16, MVT::v8f32, 3 },\n\n    { ISD::FP_TO_UINT,  MVT::v4i8,  MVT::v4f64, 3 },\n    { ISD::FP_TO_UINT,  MVT::v4i16, MVT::v4f64, 2 },\n    { ISD::FP_TO_UINT,  MVT::v8i8,  MVT::v8f32, 4 },\n    { ISD::FP_TO_UINT,  MVT::v8i16, MVT::v8f32, 3 },\n    // This node is expanded into scalarized operations but BasicTTI is overly\n    // optimistic estimating its cost.  It computes 3 per element (one\n    // vector-extract, one scalar conversion and one vector-insert).  The\n    // problem is that the inserts form a read-modify-write chain so latency\n    // should be factored in too.  Inflating the cost per element by 1.\n    { ISD::FP_TO_UINT,  MVT::v8i32, MVT::v8f32, 8*4 },\n    { ISD::FP_TO_UINT,  MVT::v4i32, MVT::v4f64, 4*4 },\n\n    { ISD::FP_EXTEND,   MVT::v4f64,  MVT::v4f32,  1 },\n    { ISD::FP_ROUND,    MVT::v4f32,  MVT::v4f64,  1 },\n  };\n\n  static const TypeConversionCostTblEntry SSE41ConversionTbl[] = {\n    { ISD::ZERO_EXTEND, MVT::v4i64, MVT::v4i8,    2 },\n    { ISD::SIGN_EXTEND, MVT::v4i64, MVT::v4i8,    2 },\n    { ISD::ZERO_EXTEND, MVT::v4i64, MVT::v4i16,   2 },\n    { ISD::SIGN_EXTEND, MVT::v4i64, MVT::v4i16,   2 },\n    { ISD::ZERO_EXTEND, MVT::v4i64, MVT::v4i32,   2 },\n    { ISD::SIGN_EXTEND, MVT::v4i64, MVT::v4i32,   2 },\n\n    { ISD::ZERO_EXTEND, MVT::v4i16,  MVT::v4i8,   1 },\n    { ISD::SIGN_EXTEND, MVT::v4i16,  MVT::v4i8,   2 },\n    { ISD::ZERO_EXTEND, MVT::v4i32,  MVT::v4i8,   1 },\n    { ISD::SIGN_EXTEND, MVT::v4i32,  MVT::v4i8,   1 },\n    { ISD::ZERO_EXTEND, MVT::v8i16,  MVT::v8i8,   1 },\n    { ISD::SIGN_EXTEND, MVT::v8i16,  MVT::v8i8,   1 },\n    { ISD::ZERO_EXTEND, MVT::v8i32,  MVT::v8i8,   2 },\n    { ISD::SIGN_EXTEND, MVT::v8i32,  MVT::v8i8,   2 },\n    { ISD::ZERO_EXTEND, MVT::v16i16, MVT::v16i8,  2 },\n    { ISD::SIGN_EXTEND, MVT::v16i16, MVT::v16i8,  2 },\n    { ISD::ZERO_EXTEND, MVT::v16i32, MVT::v16i8,  4 },\n    { ISD::SIGN_EXTEND, MVT::v16i32, MVT::v16i8,  4 },\n    { ISD::ZERO_EXTEND, MVT::v4i32,  MVT::v4i16,  1 },\n    { ISD::SIGN_EXTEND, MVT::v4i32,  MVT::v4i16,  1 },\n    { ISD::ZERO_EXTEND, MVT::v8i32,  MVT::v8i16,  2 },\n    { ISD::SIGN_EXTEND, MVT::v8i32,  MVT::v8i16,  2 },\n    { ISD::ZERO_EXTEND, MVT::v16i32, MVT::v16i16, 4 },\n    { ISD::SIGN_EXTEND, MVT::v16i32, MVT::v16i16, 4 },\n\n    // These truncates end up widening elements.\n    { ISD::TRUNCATE,    MVT::v2i1,   MVT::v2i8,   1 }, // PMOVXZBQ\n    { ISD::TRUNCATE,    MVT::v2i1,   MVT::v2i16,  1 }, // PMOVXZWQ\n    { ISD::TRUNCATE,    MVT::v4i1,   MVT::v4i8,   1 }, // PMOVXZBD\n\n    { ISD::TRUNCATE,    MVT::v2i8,   MVT::v2i16,  1 },\n    { ISD::TRUNCATE,    MVT::v4i8,   MVT::v4i16,  1 },\n    { ISD::TRUNCATE,    MVT::v8i8,   MVT::v8i16,  1 },\n    { ISD::TRUNCATE,    MVT::v4i8,   MVT::v4i32,  1 },\n    { ISD::TRUNCATE,    MVT::v4i16,  MVT::v4i32,  1 },\n    { ISD::TRUNCATE,    MVT::v8i8,   MVT::v8i32,  3 },\n    { ISD::TRUNCATE,    MVT::v8i16,  MVT::v8i32,  3 },\n    { ISD::TRUNCATE,    MVT::v16i16, MVT::v16i32, 6 },\n    { ISD::TRUNCATE,    MVT::v2i8,   MVT::v2i64,  1 }, // PSHUFB\n\n    { ISD::UINT_TO_FP,  MVT::f32,    MVT::i64,    4 },\n    { ISD::UINT_TO_FP,  MVT::f64,    MVT::i64,    4 },\n\n    { ISD::FP_TO_SINT,  MVT::v2i8,   MVT::v2f32,  3 },\n    { ISD::FP_TO_SINT,  MVT::v2i8,   MVT::v2f64,  3 },\n\n    { ISD::FP_TO_UINT,  MVT::v2i8,   MVT::v2f32,  3 },\n    { ISD::FP_TO_UINT,  MVT::v2i8,   MVT::v2f64,  3 },\n    { ISD::FP_TO_UINT,  MVT::v4i16,  MVT::v4f32,  2 },\n  };\n\n  static const TypeConversionCostTblEntry SSE2ConversionTbl[] = {\n    // These are somewhat magic numbers justified by looking at the output of\n    // Intel's IACA, running some kernels and making sure when we take\n    // legalization into account the throughput will be overestimated.\n    { ISD::SINT_TO_FP, MVT::v4f32, MVT::v16i8, 8 },\n    { ISD::SINT_TO_FP, MVT::v2f64, MVT::v16i8, 16*10 },\n    { ISD::SINT_TO_FP, MVT::v4f32, MVT::v8i16, 15 },\n    { ISD::SINT_TO_FP, MVT::v2f64, MVT::v8i16, 8*10 },\n    { ISD::SINT_TO_FP, MVT::v4f32, MVT::v4i32, 5 },\n    { ISD::SINT_TO_FP, MVT::v2f64, MVT::v4i32, 2*10 },\n    { ISD::SINT_TO_FP, MVT::v2f64, MVT::v2i32, 2*10 },\n    { ISD::SINT_TO_FP, MVT::v4f32, MVT::v2i64, 15 },\n    { ISD::SINT_TO_FP, MVT::v2f64, MVT::v2i64, 2*10 },\n\n    { ISD::UINT_TO_FP, MVT::v2f64, MVT::v16i8, 16*10 },\n    { ISD::UINT_TO_FP, MVT::v4f32, MVT::v16i8, 8 },\n    { ISD::UINT_TO_FP, MVT::v4f32, MVT::v8i16, 15 },\n    { ISD::UINT_TO_FP, MVT::v2f64, MVT::v8i16, 8*10 },\n    { ISD::UINT_TO_FP, MVT::v2f64, MVT::v4i32, 4*10 },\n    { ISD::UINT_TO_FP, MVT::v4f32, MVT::v4i32, 8 },\n    { ISD::UINT_TO_FP, MVT::v2f64, MVT::v2i64, 6 },\n    { ISD::UINT_TO_FP, MVT::v4f32, MVT::v2i64, 15 },\n\n    { ISD::FP_TO_SINT,  MVT::v2i8,   MVT::v2f32,  4 },\n    { ISD::FP_TO_SINT,  MVT::v2i16,  MVT::v2f32,  2 },\n    { ISD::FP_TO_SINT,  MVT::v4i8,   MVT::v4f32,  3 },\n    { ISD::FP_TO_SINT,  MVT::v4i16,  MVT::v4f32,  2 },\n    { ISD::FP_TO_SINT,  MVT::v2i16,  MVT::v2f64,  2 },\n    { ISD::FP_TO_SINT,  MVT::v2i8,   MVT::v2f64,  4 },\n\n    { ISD::FP_TO_SINT,  MVT::v2i32,  MVT::v2f64,  1 },\n\n    { ISD::UINT_TO_FP,  MVT::f32,    MVT::i64,    6 },\n    { ISD::UINT_TO_FP,  MVT::f64,    MVT::i64,    6 },\n\n    { ISD::FP_TO_UINT,  MVT::i64,    MVT::f32,    4 },\n    { ISD::FP_TO_UINT,  MVT::i64,    MVT::f64,    4 },\n    { ISD::FP_TO_UINT,  MVT::v2i8,   MVT::v2f32,  4 },\n    { ISD::FP_TO_UINT,  MVT::v2i8,   MVT::v2f64,  4 },\n    { ISD::FP_TO_UINT,  MVT::v4i8,   MVT::v4f32,  3 },\n    { ISD::FP_TO_UINT,  MVT::v2i16,  MVT::v2f32,  2 },\n    { ISD::FP_TO_UINT,  MVT::v2i16,  MVT::v2f64,  2 },\n    { ISD::FP_TO_UINT,  MVT::v4i16,  MVT::v4f32,  4 },\n\n    { ISD::ZERO_EXTEND, MVT::v4i16,  MVT::v4i8,   1 },\n    { ISD::SIGN_EXTEND, MVT::v4i16,  MVT::v4i8,   6 },\n    { ISD::ZERO_EXTEND, MVT::v4i32,  MVT::v4i8,   2 },\n    { ISD::SIGN_EXTEND, MVT::v4i32,  MVT::v4i8,   3 },\n    { ISD::ZERO_EXTEND, MVT::v4i64,  MVT::v4i8,   4 },\n    { ISD::SIGN_EXTEND, MVT::v4i64,  MVT::v4i8,   8 },\n    { ISD::ZERO_EXTEND, MVT::v8i16,  MVT::v8i8,   1 },\n    { ISD::SIGN_EXTEND, MVT::v8i16,  MVT::v8i8,   2 },\n    { ISD::ZERO_EXTEND, MVT::v8i32,  MVT::v8i8,   6 },\n    { ISD::SIGN_EXTEND, MVT::v8i32,  MVT::v8i8,   6 },\n    { ISD::ZERO_EXTEND, MVT::v16i16, MVT::v16i8,  3 },\n    { ISD::SIGN_EXTEND, MVT::v16i16, MVT::v16i8,  4 },\n    { ISD::ZERO_EXTEND, MVT::v16i32, MVT::v16i8,  9 },\n    { ISD::SIGN_EXTEND, MVT::v16i32, MVT::v16i8,  12 },\n    { ISD::ZERO_EXTEND, MVT::v4i32,  MVT::v4i16,  1 },\n    { ISD::SIGN_EXTEND, MVT::v4i32,  MVT::v4i16,  2 },\n    { ISD::ZERO_EXTEND, MVT::v4i64,  MVT::v4i16,  3 },\n    { ISD::SIGN_EXTEND, MVT::v4i64,  MVT::v4i16,  10 },\n    { ISD::ZERO_EXTEND, MVT::v8i32,  MVT::v8i16,  3 },\n    { ISD::SIGN_EXTEND, MVT::v8i32,  MVT::v8i16,  4 },\n    { ISD::ZERO_EXTEND, MVT::v16i32, MVT::v16i16, 6 },\n    { ISD::SIGN_EXTEND, MVT::v16i32, MVT::v16i16, 8 },\n    { ISD::ZERO_EXTEND, MVT::v4i64,  MVT::v4i32,  3 },\n    { ISD::SIGN_EXTEND, MVT::v4i64,  MVT::v4i32,  5 },\n\n    // These truncates are really widening elements.\n    { ISD::TRUNCATE,    MVT::v2i1,   MVT::v2i32,  1 }, // PSHUFD\n    { ISD::TRUNCATE,    MVT::v2i1,   MVT::v2i16,  2 }, // PUNPCKLWD+DQ\n    { ISD::TRUNCATE,    MVT::v2i1,   MVT::v2i8,   3 }, // PUNPCKLBW+WD+PSHUFD\n    { ISD::TRUNCATE,    MVT::v4i1,   MVT::v4i16,  1 }, // PUNPCKLWD\n    { ISD::TRUNCATE,    MVT::v4i1,   MVT::v4i8,   2 }, // PUNPCKLBW+WD\n    { ISD::TRUNCATE,    MVT::v8i1,   MVT::v8i8,   1 }, // PUNPCKLBW\n\n    { ISD::TRUNCATE,    MVT::v2i8,   MVT::v2i16,  2 }, // PAND+PACKUSWB\n    { ISD::TRUNCATE,    MVT::v4i8,   MVT::v4i16,  2 }, // PAND+PACKUSWB\n    { ISD::TRUNCATE,    MVT::v8i8,   MVT::v8i16,  2 }, // PAND+PACKUSWB\n    { ISD::TRUNCATE,    MVT::v16i8,  MVT::v16i16, 3 },\n    { ISD::TRUNCATE,    MVT::v2i8,   MVT::v2i32,  3 }, // PAND+2*PACKUSWB\n    { ISD::TRUNCATE,    MVT::v2i16,  MVT::v2i32,  1 },\n    { ISD::TRUNCATE,    MVT::v4i8,   MVT::v4i32,  3 },\n    { ISD::TRUNCATE,    MVT::v4i16,  MVT::v4i32,  3 },\n    { ISD::TRUNCATE,    MVT::v8i8,   MVT::v8i32,  4 },\n    { ISD::TRUNCATE,    MVT::v16i8,  MVT::v16i32, 7 },\n    { ISD::TRUNCATE,    MVT::v8i16,  MVT::v8i32,  5 },\n    { ISD::TRUNCATE,    MVT::v16i16, MVT::v16i32, 10 },\n    { ISD::TRUNCATE,    MVT::v2i8,   MVT::v2i64,  4 }, // PAND+3*PACKUSWB\n    { ISD::TRUNCATE,    MVT::v2i16,  MVT::v2i64,  2 }, // PSHUFD+PSHUFLW\n    { ISD::TRUNCATE,    MVT::v2i32,  MVT::v2i64,  1 }, // PSHUFD\n  };\n\n  std::pair<int, MVT> LTSrc = TLI->getTypeLegalizationCost(DL, Src);\n  std::pair<int, MVT> LTDest = TLI->getTypeLegalizationCost(DL, Dst);\n\n  if (ST->hasSSE2() && !ST->hasAVX()) {\n    if (const auto *Entry = ConvertCostTableLookup(SSE2ConversionTbl, ISD,\n                                                   LTDest.second, LTSrc.second))\n      return AdjustCost(LTSrc.first * Entry->Cost);\n  }\n\n  EVT SrcTy = TLI->getValueType(DL, Src);\n  EVT DstTy = TLI->getValueType(DL, Dst);\n\n  // The function getSimpleVT only handles simple value types.\n  if (!SrcTy.isSimple() || !DstTy.isSimple())\n    return AdjustCost(BaseT::getCastInstrCost(Opcode, Dst, Src, CCH, CostKind));\n\n  MVT SimpleSrcTy = SrcTy.getSimpleVT();\n  MVT SimpleDstTy = DstTy.getSimpleVT();\n\n  if (ST->useAVX512Regs()) {\n    if (ST->hasBWI())\n      if (const auto *Entry = ConvertCostTableLookup(AVX512BWConversionTbl, ISD,\n                                                     SimpleDstTy, SimpleSrcTy))\n        return AdjustCost(Entry->Cost);\n\n    if (ST->hasDQI())\n      if (const auto *Entry = ConvertCostTableLookup(AVX512DQConversionTbl, ISD,\n                                                     SimpleDstTy, SimpleSrcTy))\n        return AdjustCost(Entry->Cost);\n\n    if (ST->hasAVX512())\n      if (const auto *Entry = ConvertCostTableLookup(AVX512FConversionTbl, ISD,\n                                                     SimpleDstTy, SimpleSrcTy))\n        return AdjustCost(Entry->Cost);\n  }\n\n  if (ST->hasBWI())\n    if (const auto *Entry = ConvertCostTableLookup(AVX512BWVLConversionTbl, ISD,\n                                                   SimpleDstTy, SimpleSrcTy))\n      return AdjustCost(Entry->Cost);\n\n  if (ST->hasDQI())\n    if (const auto *Entry = ConvertCostTableLookup(AVX512DQVLConversionTbl, ISD,\n                                                   SimpleDstTy, SimpleSrcTy))\n      return AdjustCost(Entry->Cost);\n\n  if (ST->hasAVX512())\n    if (const auto *Entry = ConvertCostTableLookup(AVX512VLConversionTbl, ISD,\n                                                   SimpleDstTy, SimpleSrcTy))\n      return AdjustCost(Entry->Cost);\n\n  if (ST->hasAVX2()) {\n    if (const auto *Entry = ConvertCostTableLookup(AVX2ConversionTbl, ISD,\n                                                   SimpleDstTy, SimpleSrcTy))\n      return AdjustCost(Entry->Cost);\n  }\n\n  if (ST->hasAVX()) {\n    if (const auto *Entry = ConvertCostTableLookup(AVXConversionTbl, ISD,\n                                                   SimpleDstTy, SimpleSrcTy))\n      return AdjustCost(Entry->Cost);\n  }\n\n  if (ST->hasSSE41()) {\n    if (const auto *Entry = ConvertCostTableLookup(SSE41ConversionTbl, ISD,\n                                                   SimpleDstTy, SimpleSrcTy))\n      return AdjustCost(Entry->Cost);\n  }\n\n  if (ST->hasSSE2()) {\n    if (const auto *Entry = ConvertCostTableLookup(SSE2ConversionTbl, ISD,\n                                                   SimpleDstTy, SimpleSrcTy))\n      return AdjustCost(Entry->Cost);\n  }\n\n  return AdjustCost(\n      BaseT::getCastInstrCost(Opcode, Dst, Src, CCH, CostKind, I));\n}\n\nint X86TTIImpl::getCmpSelInstrCost(unsigned Opcode, Type *ValTy, Type *CondTy,\n                                   CmpInst::Predicate VecPred,\n                                   TTI::TargetCostKind CostKind,\n                                   const Instruction *I) {\n  // TODO: Handle other cost kinds.\n  if (CostKind != TTI::TCK_RecipThroughput)\n    return BaseT::getCmpSelInstrCost(Opcode, ValTy, CondTy, VecPred, CostKind,\n                                     I);\n\n  // Legalize the type.\n  std::pair<int, MVT> LT = TLI->getTypeLegalizationCost(DL, ValTy);\n\n  MVT MTy = LT.second;\n\n  int ISD = TLI->InstructionOpcodeToISD(Opcode);\n  assert(ISD && \"Invalid opcode\");\n\n  unsigned ExtraCost = 0;\n  if (I && (Opcode == Instruction::ICmp || Opcode == Instruction::FCmp)) {\n    // Some vector comparison predicates cost extra instructions.\n    if (MTy.isVector() &&\n        !((ST->hasXOP() && (!ST->hasAVX2() || MTy.is128BitVector())) ||\n          (ST->hasAVX512() && 32 <= MTy.getScalarSizeInBits()) ||\n          ST->hasBWI())) {\n      switch (cast<CmpInst>(I)->getPredicate()) {\n      case CmpInst::Predicate::ICMP_NE:\n        // xor(cmpeq(x,y),-1)\n        ExtraCost = 1;\n        break;\n      case CmpInst::Predicate::ICMP_SGE:\n      case CmpInst::Predicate::ICMP_SLE:\n        // xor(cmpgt(x,y),-1)\n        ExtraCost = 1;\n        break;\n      case CmpInst::Predicate::ICMP_ULT:\n      case CmpInst::Predicate::ICMP_UGT:\n        // cmpgt(xor(x,signbit),xor(y,signbit))\n        // xor(cmpeq(pmaxu(x,y),x),-1)\n        ExtraCost = 2;\n        break;\n      case CmpInst::Predicate::ICMP_ULE:\n      case CmpInst::Predicate::ICMP_UGE:\n        if ((ST->hasSSE41() && MTy.getScalarSizeInBits() == 32) ||\n            (ST->hasSSE2() && MTy.getScalarSizeInBits() < 32)) {\n          // cmpeq(psubus(x,y),0)\n          // cmpeq(pminu(x,y),x)\n          ExtraCost = 1;\n        } else {\n          // xor(cmpgt(xor(x,signbit),xor(y,signbit)),-1)\n          ExtraCost = 3;\n        }\n        break;\n      default:\n        break;\n      }\n    }\n  }\n\n  static const CostTblEntry SLMCostTbl[] = {\n    // slm pcmpeq/pcmpgt throughput is 2\n    { ISD::SETCC,   MVT::v2i64,   2 },\n  };\n\n  static const CostTblEntry AVX512BWCostTbl[] = {\n    { ISD::SETCC,   MVT::v32i16,  1 },\n    { ISD::SETCC,   MVT::v64i8,   1 },\n\n    { ISD::SELECT,  MVT::v32i16,  1 },\n    { ISD::SELECT,  MVT::v64i8,   1 },\n  };\n\n  static const CostTblEntry AVX512CostTbl[] = {\n    { ISD::SETCC,   MVT::v8i64,   1 },\n    { ISD::SETCC,   MVT::v16i32,  1 },\n    { ISD::SETCC,   MVT::v8f64,   1 },\n    { ISD::SETCC,   MVT::v16f32,  1 },\n\n    { ISD::SELECT,  MVT::v8i64,   1 },\n    { ISD::SELECT,  MVT::v16i32,  1 },\n    { ISD::SELECT,  MVT::v8f64,   1 },\n    { ISD::SELECT,  MVT::v16f32,  1 },\n\n    { ISD::SETCC,   MVT::v32i16,  2 }, // FIXME: should probably be 4\n    { ISD::SETCC,   MVT::v64i8,   2 }, // FIXME: should probably be 4\n\n    { ISD::SELECT,  MVT::v32i16,  2 }, // FIXME: should be 3\n    { ISD::SELECT,  MVT::v64i8,   2 }, // FIXME: should be 3\n  };\n\n  static const CostTblEntry AVX2CostTbl[] = {\n    { ISD::SETCC,   MVT::v4i64,   1 },\n    { ISD::SETCC,   MVT::v8i32,   1 },\n    { ISD::SETCC,   MVT::v16i16,  1 },\n    { ISD::SETCC,   MVT::v32i8,   1 },\n\n    { ISD::SELECT,  MVT::v4i64,   1 }, // pblendvb\n    { ISD::SELECT,  MVT::v8i32,   1 }, // pblendvb\n    { ISD::SELECT,  MVT::v16i16,  1 }, // pblendvb\n    { ISD::SELECT,  MVT::v32i8,   1 }, // pblendvb\n  };\n\n  static const CostTblEntry AVX1CostTbl[] = {\n    { ISD::SETCC,   MVT::v4f64,   1 },\n    { ISD::SETCC,   MVT::v8f32,   1 },\n    // AVX1 does not support 8-wide integer compare.\n    { ISD::SETCC,   MVT::v4i64,   4 },\n    { ISD::SETCC,   MVT::v8i32,   4 },\n    { ISD::SETCC,   MVT::v16i16,  4 },\n    { ISD::SETCC,   MVT::v32i8,   4 },\n\n    { ISD::SELECT,  MVT::v4f64,   1 }, // vblendvpd\n    { ISD::SELECT,  MVT::v8f32,   1 }, // vblendvps\n    { ISD::SELECT,  MVT::v4i64,   1 }, // vblendvpd\n    { ISD::SELECT,  MVT::v8i32,   1 }, // vblendvps\n    { ISD::SELECT,  MVT::v16i16,  3 }, // vandps + vandnps + vorps\n    { ISD::SELECT,  MVT::v32i8,   3 }, // vandps + vandnps + vorps\n  };\n\n  static const CostTblEntry SSE42CostTbl[] = {\n    { ISD::SETCC,   MVT::v2f64,   1 },\n    { ISD::SETCC,   MVT::v4f32,   1 },\n    { ISD::SETCC,   MVT::v2i64,   1 },\n  };\n\n  static const CostTblEntry SSE41CostTbl[] = {\n    { ISD::SELECT,  MVT::v2f64,   1 }, // blendvpd\n    { ISD::SELECT,  MVT::v4f32,   1 }, // blendvps\n    { ISD::SELECT,  MVT::v2i64,   1 }, // pblendvb\n    { ISD::SELECT,  MVT::v4i32,   1 }, // pblendvb\n    { ISD::SELECT,  MVT::v8i16,   1 }, // pblendvb\n    { ISD::SELECT,  MVT::v16i8,   1 }, // pblendvb\n  };\n\n  static const CostTblEntry SSE2CostTbl[] = {\n    { ISD::SETCC,   MVT::v2f64,   2 },\n    { ISD::SETCC,   MVT::f64,     1 },\n    { ISD::SETCC,   MVT::v2i64,   8 },\n    { ISD::SETCC,   MVT::v4i32,   1 },\n    { ISD::SETCC,   MVT::v8i16,   1 },\n    { ISD::SETCC,   MVT::v16i8,   1 },\n\n    { ISD::SELECT,  MVT::v2f64,   3 }, // andpd + andnpd + orpd\n    { ISD::SELECT,  MVT::v2i64,   3 }, // pand + pandn + por\n    { ISD::SELECT,  MVT::v4i32,   3 }, // pand + pandn + por\n    { ISD::SELECT,  MVT::v8i16,   3 }, // pand + pandn + por\n    { ISD::SELECT,  MVT::v16i8,   3 }, // pand + pandn + por\n  };\n\n  static const CostTblEntry SSE1CostTbl[] = {\n    { ISD::SETCC,   MVT::v4f32,   2 },\n    { ISD::SETCC,   MVT::f32,     1 },\n\n    { ISD::SELECT,  MVT::v4f32,   3 }, // andps + andnps + orps\n  };\n\n  if (ST->isSLM())\n    if (const auto *Entry = CostTableLookup(SLMCostTbl, ISD, MTy))\n      return LT.first * (ExtraCost + Entry->Cost);\n\n  if (ST->hasBWI())\n    if (const auto *Entry = CostTableLookup(AVX512BWCostTbl, ISD, MTy))\n      return LT.first * (ExtraCost + Entry->Cost);\n\n  if (ST->hasAVX512())\n    if (const auto *Entry = CostTableLookup(AVX512CostTbl, ISD, MTy))\n      return LT.first * (ExtraCost + Entry->Cost);\n\n  if (ST->hasAVX2())\n    if (const auto *Entry = CostTableLookup(AVX2CostTbl, ISD, MTy))\n      return LT.first * (ExtraCost + Entry->Cost);\n\n  if (ST->hasAVX())\n    if (const auto *Entry = CostTableLookup(AVX1CostTbl, ISD, MTy))\n      return LT.first * (ExtraCost + Entry->Cost);\n\n  if (ST->hasSSE42())\n    if (const auto *Entry = CostTableLookup(SSE42CostTbl, ISD, MTy))\n      return LT.first * (ExtraCost + Entry->Cost);\n\n  if (ST->hasSSE41())\n    if (const auto *Entry = CostTableLookup(SSE41CostTbl, ISD, MTy))\n      return LT.first * (ExtraCost + Entry->Cost);\n\n  if (ST->hasSSE2())\n    if (const auto *Entry = CostTableLookup(SSE2CostTbl, ISD, MTy))\n      return LT.first * (ExtraCost + Entry->Cost);\n\n  if (ST->hasSSE1())\n    if (const auto *Entry = CostTableLookup(SSE1CostTbl, ISD, MTy))\n      return LT.first * (ExtraCost + Entry->Cost);\n\n  return BaseT::getCmpSelInstrCost(Opcode, ValTy, CondTy, VecPred, CostKind, I);\n}\n\nunsigned X86TTIImpl::getAtomicMemIntrinsicMaxElementSize() const { return 16; }\n\nint X86TTIImpl::getTypeBasedIntrinsicInstrCost(\n  const IntrinsicCostAttributes &ICA, TTI::TargetCostKind CostKind) {\n\n  // Costs should match the codegen from:\n  // BITREVERSE: llvm\\test\\CodeGen\\X86\\vector-bitreverse.ll\n  // BSWAP: llvm\\test\\CodeGen\\X86\\bswap-vector.ll\n  // CTLZ: llvm\\test\\CodeGen\\X86\\vector-lzcnt-*.ll\n  // CTPOP: llvm\\test\\CodeGen\\X86\\vector-popcnt-*.ll\n  // CTTZ: llvm\\test\\CodeGen\\X86\\vector-tzcnt-*.ll\n\n  // TODO: Overflow intrinsics (*ADDO, *SUBO, *MULO) with vector types are not\n  //       specialized in these tables yet.\n  static const CostTblEntry AVX512CDCostTbl[] = {\n    { ISD::CTLZ,       MVT::v8i64,   1 },\n    { ISD::CTLZ,       MVT::v16i32,  1 },\n    { ISD::CTLZ,       MVT::v32i16,  8 },\n    { ISD::CTLZ,       MVT::v64i8,  20 },\n    { ISD::CTLZ,       MVT::v4i64,   1 },\n    { ISD::CTLZ,       MVT::v8i32,   1 },\n    { ISD::CTLZ,       MVT::v16i16,  4 },\n    { ISD::CTLZ,       MVT::v32i8,  10 },\n    { ISD::CTLZ,       MVT::v2i64,   1 },\n    { ISD::CTLZ,       MVT::v4i32,   1 },\n    { ISD::CTLZ,       MVT::v8i16,   4 },\n    { ISD::CTLZ,       MVT::v16i8,   4 },\n  };\n  static const CostTblEntry AVX512BWCostTbl[] = {\n    { ISD::ABS,        MVT::v32i16,  1 },\n    { ISD::ABS,        MVT::v64i8,   1 },\n    { ISD::BITREVERSE, MVT::v8i64,   5 },\n    { ISD::BITREVERSE, MVT::v16i32,  5 },\n    { ISD::BITREVERSE, MVT::v32i16,  5 },\n    { ISD::BITREVERSE, MVT::v64i8,   5 },\n    { ISD::CTLZ,       MVT::v8i64,  23 },\n    { ISD::CTLZ,       MVT::v16i32, 22 },\n    { ISD::CTLZ,       MVT::v32i16, 18 },\n    { ISD::CTLZ,       MVT::v64i8,  17 },\n    { ISD::CTPOP,      MVT::v8i64,   7 },\n    { ISD::CTPOP,      MVT::v16i32, 11 },\n    { ISD::CTPOP,      MVT::v32i16,  9 },\n    { ISD::CTPOP,      MVT::v64i8,   6 },\n    { ISD::CTTZ,       MVT::v8i64,  10 },\n    { ISD::CTTZ,       MVT::v16i32, 14 },\n    { ISD::CTTZ,       MVT::v32i16, 12 },\n    { ISD::CTTZ,       MVT::v64i8,   9 },\n    { ISD::SADDSAT,    MVT::v32i16,  1 },\n    { ISD::SADDSAT,    MVT::v64i8,   1 },\n    { ISD::SMAX,       MVT::v32i16,  1 },\n    { ISD::SMAX,       MVT::v64i8,   1 },\n    { ISD::SMIN,       MVT::v32i16,  1 },\n    { ISD::SMIN,       MVT::v64i8,   1 },\n    { ISD::SSUBSAT,    MVT::v32i16,  1 },\n    { ISD::SSUBSAT,    MVT::v64i8,   1 },\n    { ISD::UADDSAT,    MVT::v32i16,  1 },\n    { ISD::UADDSAT,    MVT::v64i8,   1 },\n    { ISD::UMAX,       MVT::v32i16,  1 },\n    { ISD::UMAX,       MVT::v64i8,   1 },\n    { ISD::UMIN,       MVT::v32i16,  1 },\n    { ISD::UMIN,       MVT::v64i8,   1 },\n    { ISD::USUBSAT,    MVT::v32i16,  1 },\n    { ISD::USUBSAT,    MVT::v64i8,   1 },\n  };\n  static const CostTblEntry AVX512CostTbl[] = {\n    { ISD::ABS,        MVT::v8i64,   1 },\n    { ISD::ABS,        MVT::v16i32,  1 },\n    { ISD::ABS,        MVT::v32i16,  2 }, // FIXME: include split\n    { ISD::ABS,        MVT::v64i8,   2 }, // FIXME: include split\n    { ISD::ABS,        MVT::v4i64,   1 },\n    { ISD::ABS,        MVT::v2i64,   1 },\n    { ISD::BITREVERSE, MVT::v8i64,  36 },\n    { ISD::BITREVERSE, MVT::v16i32, 24 },\n    { ISD::BITREVERSE, MVT::v32i16, 10 },\n    { ISD::BITREVERSE, MVT::v64i8,  10 },\n    { ISD::CTLZ,       MVT::v8i64,  29 },\n    { ISD::CTLZ,       MVT::v16i32, 35 },\n    { ISD::CTLZ,       MVT::v32i16, 28 },\n    { ISD::CTLZ,       MVT::v64i8,  18 },\n    { ISD::CTPOP,      MVT::v8i64,  16 },\n    { ISD::CTPOP,      MVT::v16i32, 24 },\n    { ISD::CTPOP,      MVT::v32i16, 18 },\n    { ISD::CTPOP,      MVT::v64i8,  12 },\n    { ISD::CTTZ,       MVT::v8i64,  20 },\n    { ISD::CTTZ,       MVT::v16i32, 28 },\n    { ISD::CTTZ,       MVT::v32i16, 24 },\n    { ISD::CTTZ,       MVT::v64i8,  18 },\n    { ISD::SMAX,       MVT::v8i64,   1 },\n    { ISD::SMAX,       MVT::v16i32,  1 },\n    { ISD::SMAX,       MVT::v32i16,  2 }, // FIXME: include split\n    { ISD::SMAX,       MVT::v64i8,   2 }, // FIXME: include split\n    { ISD::SMAX,       MVT::v4i64,   1 },\n    { ISD::SMAX,       MVT::v2i64,   1 },\n    { ISD::SMIN,       MVT::v8i64,   1 },\n    { ISD::SMIN,       MVT::v16i32,  1 },\n    { ISD::SMIN,       MVT::v32i16,  2 }, // FIXME: include split\n    { ISD::SMIN,       MVT::v64i8,   2 }, // FIXME: include split\n    { ISD::SMIN,       MVT::v4i64,   1 },\n    { ISD::SMIN,       MVT::v2i64,   1 },\n    { ISD::UMAX,       MVT::v8i64,   1 },\n    { ISD::UMAX,       MVT::v16i32,  1 },\n    { ISD::UMAX,       MVT::v32i16,  2 }, // FIXME: include split\n    { ISD::UMAX,       MVT::v64i8,   2 }, // FIXME: include split\n    { ISD::UMAX,       MVT::v4i64,   1 },\n    { ISD::UMAX,       MVT::v2i64,   1 },\n    { ISD::UMIN,       MVT::v8i64,   1 },\n    { ISD::UMIN,       MVT::v16i32,  1 },\n    { ISD::UMIN,       MVT::v32i16,  2 }, // FIXME: include split\n    { ISD::UMIN,       MVT::v64i8,   2 }, // FIXME: include split\n    { ISD::UMIN,       MVT::v4i64,   1 },\n    { ISD::UMIN,       MVT::v2i64,   1 },\n    { ISD::USUBSAT,    MVT::v16i32,  2 }, // pmaxud + psubd\n    { ISD::USUBSAT,    MVT::v2i64,   2 }, // pmaxuq + psubq\n    { ISD::USUBSAT,    MVT::v4i64,   2 }, // pmaxuq + psubq\n    { ISD::USUBSAT,    MVT::v8i64,   2 }, // pmaxuq + psubq\n    { ISD::UADDSAT,    MVT::v16i32,  3 }, // not + pminud + paddd\n    { ISD::UADDSAT,    MVT::v2i64,   3 }, // not + pminuq + paddq\n    { ISD::UADDSAT,    MVT::v4i64,   3 }, // not + pminuq + paddq\n    { ISD::UADDSAT,    MVT::v8i64,   3 }, // not + pminuq + paddq\n    { ISD::SADDSAT,    MVT::v32i16,  2 }, // FIXME: include split\n    { ISD::SADDSAT,    MVT::v64i8,   2 }, // FIXME: include split\n    { ISD::SSUBSAT,    MVT::v32i16,  2 }, // FIXME: include split\n    { ISD::SSUBSAT,    MVT::v64i8,   2 }, // FIXME: include split\n    { ISD::UADDSAT,    MVT::v32i16,  2 }, // FIXME: include split\n    { ISD::UADDSAT,    MVT::v64i8,   2 }, // FIXME: include split\n    { ISD::USUBSAT,    MVT::v32i16,  2 }, // FIXME: include split\n    { ISD::USUBSAT,    MVT::v64i8,   2 }, // FIXME: include split\n    { ISD::FMAXNUM,    MVT::f32,     2 },\n    { ISD::FMAXNUM,    MVT::v4f32,   2 },\n    { ISD::FMAXNUM,    MVT::v8f32,   2 },\n    { ISD::FMAXNUM,    MVT::v16f32,  2 },\n    { ISD::FMAXNUM,    MVT::f64,     2 },\n    { ISD::FMAXNUM,    MVT::v2f64,   2 },\n    { ISD::FMAXNUM,    MVT::v4f64,   2 },\n    { ISD::FMAXNUM,    MVT::v8f64,   2 },\n  };\n  static const CostTblEntry XOPCostTbl[] = {\n    { ISD::BITREVERSE, MVT::v4i64,   4 },\n    { ISD::BITREVERSE, MVT::v8i32,   4 },\n    { ISD::BITREVERSE, MVT::v16i16,  4 },\n    { ISD::BITREVERSE, MVT::v32i8,   4 },\n    { ISD::BITREVERSE, MVT::v2i64,   1 },\n    { ISD::BITREVERSE, MVT::v4i32,   1 },\n    { ISD::BITREVERSE, MVT::v8i16,   1 },\n    { ISD::BITREVERSE, MVT::v16i8,   1 },\n    { ISD::BITREVERSE, MVT::i64,     3 },\n    { ISD::BITREVERSE, MVT::i32,     3 },\n    { ISD::BITREVERSE, MVT::i16,     3 },\n    { ISD::BITREVERSE, MVT::i8,      3 }\n  };\n  static const CostTblEntry AVX2CostTbl[] = {\n    { ISD::ABS,        MVT::v4i64,   2 }, // VBLENDVPD(X,VPSUBQ(0,X),X)\n    { ISD::ABS,        MVT::v8i32,   1 },\n    { ISD::ABS,        MVT::v16i16,  1 },\n    { ISD::ABS,        MVT::v32i8,   1 },\n    { ISD::BITREVERSE, MVT::v4i64,   5 },\n    { ISD::BITREVERSE, MVT::v8i32,   5 },\n    { ISD::BITREVERSE, MVT::v16i16,  5 },\n    { ISD::BITREVERSE, MVT::v32i8,   5 },\n    { ISD::BSWAP,      MVT::v4i64,   1 },\n    { ISD::BSWAP,      MVT::v8i32,   1 },\n    { ISD::BSWAP,      MVT::v16i16,  1 },\n    { ISD::CTLZ,       MVT::v4i64,  23 },\n    { ISD::CTLZ,       MVT::v8i32,  18 },\n    { ISD::CTLZ,       MVT::v16i16, 14 },\n    { ISD::CTLZ,       MVT::v32i8,   9 },\n    { ISD::CTPOP,      MVT::v4i64,   7 },\n    { ISD::CTPOP,      MVT::v8i32,  11 },\n    { ISD::CTPOP,      MVT::v16i16,  9 },\n    { ISD::CTPOP,      MVT::v32i8,   6 },\n    { ISD::CTTZ,       MVT::v4i64,  10 },\n    { ISD::CTTZ,       MVT::v8i32,  14 },\n    { ISD::CTTZ,       MVT::v16i16, 12 },\n    { ISD::CTTZ,       MVT::v32i8,   9 },\n    { ISD::SADDSAT,    MVT::v16i16,  1 },\n    { ISD::SADDSAT,    MVT::v32i8,   1 },\n    { ISD::SMAX,       MVT::v8i32,   1 },\n    { ISD::SMAX,       MVT::v16i16,  1 },\n    { ISD::SMAX,       MVT::v32i8,   1 },\n    { ISD::SMIN,       MVT::v8i32,   1 },\n    { ISD::SMIN,       MVT::v16i16,  1 },\n    { ISD::SMIN,       MVT::v32i8,   1 },\n    { ISD::SSUBSAT,    MVT::v16i16,  1 },\n    { ISD::SSUBSAT,    MVT::v32i8,   1 },\n    { ISD::UADDSAT,    MVT::v16i16,  1 },\n    { ISD::UADDSAT,    MVT::v32i8,   1 },\n    { ISD::UADDSAT,    MVT::v8i32,   3 }, // not + pminud + paddd\n    { ISD::UMAX,       MVT::v8i32,   1 },\n    { ISD::UMAX,       MVT::v16i16,  1 },\n    { ISD::UMAX,       MVT::v32i8,   1 },\n    { ISD::UMIN,       MVT::v8i32,   1 },\n    { ISD::UMIN,       MVT::v16i16,  1 },\n    { ISD::UMIN,       MVT::v32i8,   1 },\n    { ISD::USUBSAT,    MVT::v16i16,  1 },\n    { ISD::USUBSAT,    MVT::v32i8,   1 },\n    { ISD::USUBSAT,    MVT::v8i32,   2 }, // pmaxud + psubd\n    { ISD::FMAXNUM,    MVT::v8f32,   3 }, // MAXPS + CMPUNORDPS + BLENDVPS\n    { ISD::FMAXNUM,    MVT::v4f64,   3 }, // MAXPD + CMPUNORDPD + BLENDVPD\n    { ISD::FSQRT,      MVT::f32,     7 }, // Haswell from http://www.agner.org/\n    { ISD::FSQRT,      MVT::v4f32,   7 }, // Haswell from http://www.agner.org/\n    { ISD::FSQRT,      MVT::v8f32,  14 }, // Haswell from http://www.agner.org/\n    { ISD::FSQRT,      MVT::f64,    14 }, // Haswell from http://www.agner.org/\n    { ISD::FSQRT,      MVT::v2f64,  14 }, // Haswell from http://www.agner.org/\n    { ISD::FSQRT,      MVT::v4f64,  28 }, // Haswell from http://www.agner.org/\n  };\n  static const CostTblEntry AVX1CostTbl[] = {\n    { ISD::ABS,        MVT::v4i64,   5 }, // VBLENDVPD(X,VPSUBQ(0,X),X)\n    { ISD::ABS,        MVT::v8i32,   3 },\n    { ISD::ABS,        MVT::v16i16,  3 },\n    { ISD::ABS,        MVT::v32i8,   3 },\n    { ISD::BITREVERSE, MVT::v4i64,  12 }, // 2 x 128-bit Op + extract/insert\n    { ISD::BITREVERSE, MVT::v8i32,  12 }, // 2 x 128-bit Op + extract/insert\n    { ISD::BITREVERSE, MVT::v16i16, 12 }, // 2 x 128-bit Op + extract/insert\n    { ISD::BITREVERSE, MVT::v32i8,  12 }, // 2 x 128-bit Op + extract/insert\n    { ISD::BSWAP,      MVT::v4i64,   4 },\n    { ISD::BSWAP,      MVT::v8i32,   4 },\n    { ISD::BSWAP,      MVT::v16i16,  4 },\n    { ISD::CTLZ,       MVT::v4i64,  48 }, // 2 x 128-bit Op + extract/insert\n    { ISD::CTLZ,       MVT::v8i32,  38 }, // 2 x 128-bit Op + extract/insert\n    { ISD::CTLZ,       MVT::v16i16, 30 }, // 2 x 128-bit Op + extract/insert\n    { ISD::CTLZ,       MVT::v32i8,  20 }, // 2 x 128-bit Op + extract/insert\n    { ISD::CTPOP,      MVT::v4i64,  16 }, // 2 x 128-bit Op + extract/insert\n    { ISD::CTPOP,      MVT::v8i32,  24 }, // 2 x 128-bit Op + extract/insert\n    { ISD::CTPOP,      MVT::v16i16, 20 }, // 2 x 128-bit Op + extract/insert\n    { ISD::CTPOP,      MVT::v32i8,  14 }, // 2 x 128-bit Op + extract/insert\n    { ISD::CTTZ,       MVT::v4i64,  22 }, // 2 x 128-bit Op + extract/insert\n    { ISD::CTTZ,       MVT::v8i32,  30 }, // 2 x 128-bit Op + extract/insert\n    { ISD::CTTZ,       MVT::v16i16, 26 }, // 2 x 128-bit Op + extract/insert\n    { ISD::CTTZ,       MVT::v32i8,  20 }, // 2 x 128-bit Op + extract/insert\n    { ISD::SADDSAT,    MVT::v16i16,  4 }, // 2 x 128-bit Op + extract/insert\n    { ISD::SADDSAT,    MVT::v32i8,   4 }, // 2 x 128-bit Op + extract/insert\n    { ISD::SMAX,       MVT::v8i32,   4 }, // 2 x 128-bit Op + extract/insert\n    { ISD::SMAX,       MVT::v16i16,  4 }, // 2 x 128-bit Op + extract/insert\n    { ISD::SMAX,       MVT::v32i8,   4 }, // 2 x 128-bit Op + extract/insert\n    { ISD::SMIN,       MVT::v8i32,   4 }, // 2 x 128-bit Op + extract/insert\n    { ISD::SMIN,       MVT::v16i16,  4 }, // 2 x 128-bit Op + extract/insert\n    { ISD::SMIN,       MVT::v32i8,   4 }, // 2 x 128-bit Op + extract/insert\n    { ISD::SSUBSAT,    MVT::v16i16,  4 }, // 2 x 128-bit Op + extract/insert\n    { ISD::SSUBSAT,    MVT::v32i8,   4 }, // 2 x 128-bit Op + extract/insert\n    { ISD::UADDSAT,    MVT::v16i16,  4 }, // 2 x 128-bit Op + extract/insert\n    { ISD::UADDSAT,    MVT::v32i8,   4 }, // 2 x 128-bit Op + extract/insert\n    { ISD::UADDSAT,    MVT::v8i32,   8 }, // 2 x 128-bit Op + extract/insert\n    { ISD::UMAX,       MVT::v8i32,   4 }, // 2 x 128-bit Op + extract/insert\n    { ISD::UMAX,       MVT::v16i16,  4 }, // 2 x 128-bit Op + extract/insert\n    { ISD::UMAX,       MVT::v32i8,   4 }, // 2 x 128-bit Op + extract/insert\n    { ISD::UMIN,       MVT::v8i32,   4 }, // 2 x 128-bit Op + extract/insert\n    { ISD::UMIN,       MVT::v16i16,  4 }, // 2 x 128-bit Op + extract/insert\n    { ISD::UMIN,       MVT::v32i8,   4 }, // 2 x 128-bit Op + extract/insert\n    { ISD::USUBSAT,    MVT::v16i16,  4 }, // 2 x 128-bit Op + extract/insert\n    { ISD::USUBSAT,    MVT::v32i8,   4 }, // 2 x 128-bit Op + extract/insert\n    { ISD::USUBSAT,    MVT::v8i32,   6 }, // 2 x 128-bit Op + extract/insert\n    { ISD::FMAXNUM,    MVT::f32,     3 }, // MAXSS + CMPUNORDSS + BLENDVPS\n    { ISD::FMAXNUM,    MVT::v4f32,   3 }, // MAXPS + CMPUNORDPS + BLENDVPS\n    { ISD::FMAXNUM,    MVT::v8f32,   5 }, // MAXPS + CMPUNORDPS + BLENDVPS + ?\n    { ISD::FMAXNUM,    MVT::f64,     3 }, // MAXSD + CMPUNORDSD + BLENDVPD\n    { ISD::FMAXNUM,    MVT::v2f64,   3 }, // MAXPD + CMPUNORDPD + BLENDVPD\n    { ISD::FMAXNUM,    MVT::v4f64,   5 }, // MAXPD + CMPUNORDPD + BLENDVPD + ?\n    { ISD::FSQRT,      MVT::f32,    14 }, // SNB from http://www.agner.org/\n    { ISD::FSQRT,      MVT::v4f32,  14 }, // SNB from http://www.agner.org/\n    { ISD::FSQRT,      MVT::v8f32,  28 }, // SNB from http://www.agner.org/\n    { ISD::FSQRT,      MVT::f64,    21 }, // SNB from http://www.agner.org/\n    { ISD::FSQRT,      MVT::v2f64,  21 }, // SNB from http://www.agner.org/\n    { ISD::FSQRT,      MVT::v4f64,  43 }, // SNB from http://www.agner.org/\n  };\n  static const CostTblEntry GLMCostTbl[] = {\n    { ISD::FSQRT, MVT::f32,   19 }, // sqrtss\n    { ISD::FSQRT, MVT::v4f32, 37 }, // sqrtps\n    { ISD::FSQRT, MVT::f64,   34 }, // sqrtsd\n    { ISD::FSQRT, MVT::v2f64, 67 }, // sqrtpd\n  };\n  static const CostTblEntry SLMCostTbl[] = {\n    { ISD::FSQRT, MVT::f32,   20 }, // sqrtss\n    { ISD::FSQRT, MVT::v4f32, 40 }, // sqrtps\n    { ISD::FSQRT, MVT::f64,   35 }, // sqrtsd\n    { ISD::FSQRT, MVT::v2f64, 70 }, // sqrtpd\n  };\n  static const CostTblEntry SSE42CostTbl[] = {\n    { ISD::USUBSAT,    MVT::v4i32,   2 }, // pmaxud + psubd\n    { ISD::UADDSAT,    MVT::v4i32,   3 }, // not + pminud + paddd\n    { ISD::FSQRT,      MVT::f32,    18 }, // Nehalem from http://www.agner.org/\n    { ISD::FSQRT,      MVT::v4f32,  18 }, // Nehalem from http://www.agner.org/\n  };\n  static const CostTblEntry SSE41CostTbl[] = {\n    { ISD::ABS,        MVT::v2i64,   2 }, // BLENDVPD(X,PSUBQ(0,X),X)\n    { ISD::SMAX,       MVT::v4i32,   1 },\n    { ISD::SMAX,       MVT::v16i8,   1 },\n    { ISD::SMIN,       MVT::v4i32,   1 },\n    { ISD::SMIN,       MVT::v16i8,   1 },\n    { ISD::UMAX,       MVT::v4i32,   1 },\n    { ISD::UMAX,       MVT::v8i16,   1 },\n    { ISD::UMIN,       MVT::v4i32,   1 },\n    { ISD::UMIN,       MVT::v8i16,   1 },\n  };\n  static const CostTblEntry SSSE3CostTbl[] = {\n    { ISD::ABS,        MVT::v4i32,   1 },\n    { ISD::ABS,        MVT::v8i16,   1 },\n    { ISD::ABS,        MVT::v16i8,   1 },\n    { ISD::BITREVERSE, MVT::v2i64,   5 },\n    { ISD::BITREVERSE, MVT::v4i32,   5 },\n    { ISD::BITREVERSE, MVT::v8i16,   5 },\n    { ISD::BITREVERSE, MVT::v16i8,   5 },\n    { ISD::BSWAP,      MVT::v2i64,   1 },\n    { ISD::BSWAP,      MVT::v4i32,   1 },\n    { ISD::BSWAP,      MVT::v8i16,   1 },\n    { ISD::CTLZ,       MVT::v2i64,  23 },\n    { ISD::CTLZ,       MVT::v4i32,  18 },\n    { ISD::CTLZ,       MVT::v8i16,  14 },\n    { ISD::CTLZ,       MVT::v16i8,   9 },\n    { ISD::CTPOP,      MVT::v2i64,   7 },\n    { ISD::CTPOP,      MVT::v4i32,  11 },\n    { ISD::CTPOP,      MVT::v8i16,   9 },\n    { ISD::CTPOP,      MVT::v16i8,   6 },\n    { ISD::CTTZ,       MVT::v2i64,  10 },\n    { ISD::CTTZ,       MVT::v4i32,  14 },\n    { ISD::CTTZ,       MVT::v8i16,  12 },\n    { ISD::CTTZ,       MVT::v16i8,   9 }\n  };\n  static const CostTblEntry SSE2CostTbl[] = {\n    { ISD::ABS,        MVT::v2i64,   4 },\n    { ISD::ABS,        MVT::v4i32,   3 },\n    { ISD::ABS,        MVT::v8i16,   2 },\n    { ISD::ABS,        MVT::v16i8,   2 },\n    { ISD::BITREVERSE, MVT::v2i64,  29 },\n    { ISD::BITREVERSE, MVT::v4i32,  27 },\n    { ISD::BITREVERSE, MVT::v8i16,  27 },\n    { ISD::BITREVERSE, MVT::v16i8,  20 },\n    { ISD::BSWAP,      MVT::v2i64,   7 },\n    { ISD::BSWAP,      MVT::v4i32,   7 },\n    { ISD::BSWAP,      MVT::v8i16,   7 },\n    { ISD::CTLZ,       MVT::v2i64,  25 },\n    { ISD::CTLZ,       MVT::v4i32,  26 },\n    { ISD::CTLZ,       MVT::v8i16,  20 },\n    { ISD::CTLZ,       MVT::v16i8,  17 },\n    { ISD::CTPOP,      MVT::v2i64,  12 },\n    { ISD::CTPOP,      MVT::v4i32,  15 },\n    { ISD::CTPOP,      MVT::v8i16,  13 },\n    { ISD::CTPOP,      MVT::v16i8,  10 },\n    { ISD::CTTZ,       MVT::v2i64,  14 },\n    { ISD::CTTZ,       MVT::v4i32,  18 },\n    { ISD::CTTZ,       MVT::v8i16,  16 },\n    { ISD::CTTZ,       MVT::v16i8,  13 },\n    { ISD::SADDSAT,    MVT::v8i16,   1 },\n    { ISD::SADDSAT,    MVT::v16i8,   1 },\n    { ISD::SMAX,       MVT::v8i16,   1 },\n    { ISD::SMIN,       MVT::v8i16,   1 },\n    { ISD::SSUBSAT,    MVT::v8i16,   1 },\n    { ISD::SSUBSAT,    MVT::v16i8,   1 },\n    { ISD::UADDSAT,    MVT::v8i16,   1 },\n    { ISD::UADDSAT,    MVT::v16i8,   1 },\n    { ISD::UMAX,       MVT::v8i16,   2 },\n    { ISD::UMAX,       MVT::v16i8,   1 },\n    { ISD::UMIN,       MVT::v8i16,   2 },\n    { ISD::UMIN,       MVT::v16i8,   1 },\n    { ISD::USUBSAT,    MVT::v8i16,   1 },\n    { ISD::USUBSAT,    MVT::v16i8,   1 },\n    { ISD::FMAXNUM,    MVT::f64,     4 },\n    { ISD::FMAXNUM,    MVT::v2f64,   4 },\n    { ISD::FSQRT,      MVT::f64,    32 }, // Nehalem from http://www.agner.org/\n    { ISD::FSQRT,      MVT::v2f64,  32 }, // Nehalem from http://www.agner.org/\n  };\n  static const CostTblEntry SSE1CostTbl[] = {\n    { ISD::FMAXNUM,    MVT::f32,     4 },\n    { ISD::FMAXNUM,    MVT::v4f32,   4 },\n    { ISD::FSQRT,      MVT::f32,    28 }, // Pentium III from http://www.agner.org/\n    { ISD::FSQRT,      MVT::v4f32,  56 }, // Pentium III from http://www.agner.org/\n  };\n  static const CostTblEntry BMI64CostTbl[] = { // 64-bit targets\n    { ISD::CTTZ,       MVT::i64,     1 },\n  };\n  static const CostTblEntry BMI32CostTbl[] = { // 32 or 64-bit targets\n    { ISD::CTTZ,       MVT::i32,     1 },\n    { ISD::CTTZ,       MVT::i16,     1 },\n    { ISD::CTTZ,       MVT::i8,      1 },\n  };\n  static const CostTblEntry LZCNT64CostTbl[] = { // 64-bit targets\n    { ISD::CTLZ,       MVT::i64,     1 },\n  };\n  static const CostTblEntry LZCNT32CostTbl[] = { // 32 or 64-bit targets\n    { ISD::CTLZ,       MVT::i32,     1 },\n    { ISD::CTLZ,       MVT::i16,     1 },\n    { ISD::CTLZ,       MVT::i8,      1 },\n  };\n  static const CostTblEntry POPCNT64CostTbl[] = { // 64-bit targets\n    { ISD::CTPOP,      MVT::i64,     1 },\n  };\n  static const CostTblEntry POPCNT32CostTbl[] = { // 32 or 64-bit targets\n    { ISD::CTPOP,      MVT::i32,     1 },\n    { ISD::CTPOP,      MVT::i16,     1 },\n    { ISD::CTPOP,      MVT::i8,      1 },\n  };\n  static const CostTblEntry X64CostTbl[] = { // 64-bit targets\n    { ISD::ABS,        MVT::i64,     2 }, // SUB+CMOV\n    { ISD::BITREVERSE, MVT::i64,    14 },\n    { ISD::CTLZ,       MVT::i64,     4 }, // BSR+XOR or BSR+XOR+CMOV\n    { ISD::CTTZ,       MVT::i64,     3 }, // TEST+BSF+CMOV/BRANCH\n    { ISD::CTPOP,      MVT::i64,    10 },\n    { ISD::SADDO,      MVT::i64,     1 },\n    { ISD::UADDO,      MVT::i64,     1 },\n    { ISD::UMULO,      MVT::i64,     2 }, // mulq + seto\n  };\n  static const CostTblEntry X86CostTbl[] = { // 32 or 64-bit targets\n    { ISD::ABS,        MVT::i32,     2 }, // SUB+CMOV\n    { ISD::ABS,        MVT::i16,     2 }, // SUB+CMOV\n    { ISD::BITREVERSE, MVT::i32,    14 },\n    { ISD::BITREVERSE, MVT::i16,    14 },\n    { ISD::BITREVERSE, MVT::i8,     11 },\n    { ISD::CTLZ,       MVT::i32,     4 }, // BSR+XOR or BSR+XOR+CMOV\n    { ISD::CTLZ,       MVT::i16,     4 }, // BSR+XOR or BSR+XOR+CMOV\n    { ISD::CTLZ,       MVT::i8,      4 }, // BSR+XOR or BSR+XOR+CMOV\n    { ISD::CTTZ,       MVT::i32,     3 }, // TEST+BSF+CMOV/BRANCH\n    { ISD::CTTZ,       MVT::i16,     3 }, // TEST+BSF+CMOV/BRANCH\n    { ISD::CTTZ,       MVT::i8,      3 }, // TEST+BSF+CMOV/BRANCH\n    { ISD::CTPOP,      MVT::i32,     8 },\n    { ISD::CTPOP,      MVT::i16,     9 },\n    { ISD::CTPOP,      MVT::i8,      7 },\n    { ISD::SADDO,      MVT::i32,     1 },\n    { ISD::SADDO,      MVT::i16,     1 },\n    { ISD::SADDO,      MVT::i8,      1 },\n    { ISD::UADDO,      MVT::i32,     1 },\n    { ISD::UADDO,      MVT::i16,     1 },\n    { ISD::UADDO,      MVT::i8,      1 },\n    { ISD::UMULO,      MVT::i32,     2 }, // mul + seto\n    { ISD::UMULO,      MVT::i16,     2 },\n    { ISD::UMULO,      MVT::i8,      2 },\n  };\n\n  Type *RetTy = ICA.getReturnType();\n  Type *OpTy = RetTy;\n  Intrinsic::ID IID = ICA.getID();\n  unsigned ISD = ISD::DELETED_NODE;\n  switch (IID) {\n  default:\n    break;\n  case Intrinsic::abs:\n    ISD = ISD::ABS;\n    break;\n  case Intrinsic::bitreverse:\n    ISD = ISD::BITREVERSE;\n    break;\n  case Intrinsic::bswap:\n    ISD = ISD::BSWAP;\n    break;\n  case Intrinsic::ctlz:\n    ISD = ISD::CTLZ;\n    break;\n  case Intrinsic::ctpop:\n    ISD = ISD::CTPOP;\n    break;\n  case Intrinsic::cttz:\n    ISD = ISD::CTTZ;\n    break;\n  case Intrinsic::maxnum:\n  case Intrinsic::minnum:\n    // FMINNUM has same costs so don't duplicate.\n    ISD = ISD::FMAXNUM;\n    break;\n  case Intrinsic::sadd_sat:\n    ISD = ISD::SADDSAT;\n    break;\n  case Intrinsic::smax:\n    ISD = ISD::SMAX;\n    break;\n  case Intrinsic::smin:\n    ISD = ISD::SMIN;\n    break;\n  case Intrinsic::ssub_sat:\n    ISD = ISD::SSUBSAT;\n    break;\n  case Intrinsic::uadd_sat:\n    ISD = ISD::UADDSAT;\n    break;\n  case Intrinsic::umax:\n    ISD = ISD::UMAX;\n    break;\n  case Intrinsic::umin:\n    ISD = ISD::UMIN;\n    break;\n  case Intrinsic::usub_sat:\n    ISD = ISD::USUBSAT;\n    break;\n  case Intrinsic::sqrt:\n    ISD = ISD::FSQRT;\n    break;\n  case Intrinsic::sadd_with_overflow:\n  case Intrinsic::ssub_with_overflow:\n    // SSUBO has same costs so don't duplicate.\n    ISD = ISD::SADDO;\n    OpTy = RetTy->getContainedType(0);\n    break;\n  case Intrinsic::uadd_with_overflow:\n  case Intrinsic::usub_with_overflow:\n    // USUBO has same costs so don't duplicate.\n    ISD = ISD::UADDO;\n    OpTy = RetTy->getContainedType(0);\n    break;\n  case Intrinsic::umul_with_overflow:\n  case Intrinsic::smul_with_overflow:\n    // SMULO has same costs so don't duplicate.\n    ISD = ISD::UMULO;\n    OpTy = RetTy->getContainedType(0);\n    break;\n  }\n\n  if (ISD != ISD::DELETED_NODE) {\n    // Legalize the type.\n    std::pair<int, MVT> LT = TLI->getTypeLegalizationCost(DL, OpTy);\n    MVT MTy = LT.second;\n\n    // Attempt to lookup cost.\n    if (ISD == ISD::BITREVERSE && ST->hasGFNI() && ST->hasSSSE3() &&\n        MTy.isVector()) {\n      // With PSHUFB the code is very similar for all types. If we have integer\n      // byte operations, we just need a GF2P8AFFINEQB for vXi8. For other types\n      // we also need a PSHUFB.\n      unsigned Cost = MTy.getVectorElementType() == MVT::i8 ? 1 : 2;\n\n      // Without byte operations, we need twice as many GF2P8AFFINEQB and PSHUFB\n      // instructions. We also need an extract and an insert.\n      if (!(MTy.is128BitVector() || (ST->hasAVX2() && MTy.is256BitVector()) ||\n            (ST->hasBWI() && MTy.is512BitVector())))\n        Cost = Cost * 2 + 2;\n\n      return LT.first * Cost;\n    }\n\n    auto adjustTableCost = [](const CostTblEntry &Entry, int LegalizationCost,\n                              FastMathFlags FMF) {\n      // If there are no NANs to deal with, then these are reduced to a\n      // single MIN** or MAX** instruction instead of the MIN/CMP/SELECT that we\n      // assume is used in the non-fast case.\n      if (Entry.ISD == ISD::FMAXNUM || Entry.ISD == ISD::FMINNUM) {\n        if (FMF.noNaNs())\n          return LegalizationCost * 1;\n      }\n      return LegalizationCost * (int)Entry.Cost;\n    };\n\n    if (ST->useGLMDivSqrtCosts())\n      if (const auto *Entry = CostTableLookup(GLMCostTbl, ISD, MTy))\n        return adjustTableCost(*Entry, LT.first, ICA.getFlags());\n\n    if (ST->isSLM())\n      if (const auto *Entry = CostTableLookup(SLMCostTbl, ISD, MTy))\n        return adjustTableCost(*Entry, LT.first, ICA.getFlags());\n\n    if (ST->hasCDI())\n      if (const auto *Entry = CostTableLookup(AVX512CDCostTbl, ISD, MTy))\n        return adjustTableCost(*Entry, LT.first, ICA.getFlags());\n\n    if (ST->hasBWI())\n      if (const auto *Entry = CostTableLookup(AVX512BWCostTbl, ISD, MTy))\n        return adjustTableCost(*Entry, LT.first, ICA.getFlags());\n\n    if (ST->hasAVX512())\n      if (const auto *Entry = CostTableLookup(AVX512CostTbl, ISD, MTy))\n        return adjustTableCost(*Entry, LT.first, ICA.getFlags());\n\n    if (ST->hasXOP())\n      if (const auto *Entry = CostTableLookup(XOPCostTbl, ISD, MTy))\n        return adjustTableCost(*Entry, LT.first, ICA.getFlags());\n\n    if (ST->hasAVX2())\n      if (const auto *Entry = CostTableLookup(AVX2CostTbl, ISD, MTy))\n        return adjustTableCost(*Entry, LT.first, ICA.getFlags());\n\n    if (ST->hasAVX())\n      if (const auto *Entry = CostTableLookup(AVX1CostTbl, ISD, MTy))\n        return adjustTableCost(*Entry, LT.first, ICA.getFlags());\n\n    if (ST->hasSSE42())\n      if (const auto *Entry = CostTableLookup(SSE42CostTbl, ISD, MTy))\n        return adjustTableCost(*Entry, LT.first, ICA.getFlags());\n\n    if (ST->hasSSE41())\n      if (const auto *Entry = CostTableLookup(SSE41CostTbl, ISD, MTy))\n        return adjustTableCost(*Entry, LT.first, ICA.getFlags());\n\n    if (ST->hasSSSE3())\n      if (const auto *Entry = CostTableLookup(SSSE3CostTbl, ISD, MTy))\n        return adjustTableCost(*Entry, LT.first, ICA.getFlags());\n\n    if (ST->hasSSE2())\n      if (const auto *Entry = CostTableLookup(SSE2CostTbl, ISD, MTy))\n        return adjustTableCost(*Entry, LT.first, ICA.getFlags());\n\n    if (ST->hasSSE1())\n      if (const auto *Entry = CostTableLookup(SSE1CostTbl, ISD, MTy))\n        return adjustTableCost(*Entry, LT.first, ICA.getFlags());\n\n    if (ST->hasBMI()) {\n      if (ST->is64Bit())\n        if (const auto *Entry = CostTableLookup(BMI64CostTbl, ISD, MTy))\n          return adjustTableCost(*Entry, LT.first, ICA.getFlags());\n\n      if (const auto *Entry = CostTableLookup(BMI32CostTbl, ISD, MTy))\n        return adjustTableCost(*Entry, LT.first, ICA.getFlags());\n    }\n\n    if (ST->hasLZCNT()) {\n      if (ST->is64Bit())\n        if (const auto *Entry = CostTableLookup(LZCNT64CostTbl, ISD, MTy))\n          return adjustTableCost(*Entry, LT.first, ICA.getFlags());\n\n      if (const auto *Entry = CostTableLookup(LZCNT32CostTbl, ISD, MTy))\n        return adjustTableCost(*Entry, LT.first, ICA.getFlags());\n    }\n\n    if (ST->hasPOPCNT()) {\n      if (ST->is64Bit())\n        if (const auto *Entry = CostTableLookup(POPCNT64CostTbl, ISD, MTy))\n          return adjustTableCost(*Entry, LT.first, ICA.getFlags());\n\n      if (const auto *Entry = CostTableLookup(POPCNT32CostTbl, ISD, MTy))\n        return adjustTableCost(*Entry, LT.first, ICA.getFlags());\n    }\n\n    // TODO - add BMI (TZCNT) scalar handling\n\n    if (ST->is64Bit())\n      if (const auto *Entry = CostTableLookup(X64CostTbl, ISD, MTy))\n        return adjustTableCost(*Entry, LT.first, ICA.getFlags());\n\n    if (const auto *Entry = CostTableLookup(X86CostTbl, ISD, MTy))\n      return adjustTableCost(*Entry, LT.first, ICA.getFlags());\n  }\n\n  return BaseT::getIntrinsicInstrCost(ICA, CostKind);\n}\n\nint X86TTIImpl::getIntrinsicInstrCost(const IntrinsicCostAttributes &ICA,\n                                      TTI::TargetCostKind CostKind) {\n  if (ICA.isTypeBasedOnly())\n    return getTypeBasedIntrinsicInstrCost(ICA, CostKind);\n\n  static const CostTblEntry AVX512CostTbl[] = {\n    { ISD::ROTL,       MVT::v8i64,   1 },\n    { ISD::ROTL,       MVT::v4i64,   1 },\n    { ISD::ROTL,       MVT::v2i64,   1 },\n    { ISD::ROTL,       MVT::v16i32,  1 },\n    { ISD::ROTL,       MVT::v8i32,   1 },\n    { ISD::ROTL,       MVT::v4i32,   1 },\n    { ISD::ROTR,       MVT::v8i64,   1 },\n    { ISD::ROTR,       MVT::v4i64,   1 },\n    { ISD::ROTR,       MVT::v2i64,   1 },\n    { ISD::ROTR,       MVT::v16i32,  1 },\n    { ISD::ROTR,       MVT::v8i32,   1 },\n    { ISD::ROTR,       MVT::v4i32,   1 }\n  };\n  // XOP: ROTL = VPROT(X,Y), ROTR = VPROT(X,SUB(0,Y))\n  static const CostTblEntry XOPCostTbl[] = {\n    { ISD::ROTL,       MVT::v4i64,   4 },\n    { ISD::ROTL,       MVT::v8i32,   4 },\n    { ISD::ROTL,       MVT::v16i16,  4 },\n    { ISD::ROTL,       MVT::v32i8,   4 },\n    { ISD::ROTL,       MVT::v2i64,   1 },\n    { ISD::ROTL,       MVT::v4i32,   1 },\n    { ISD::ROTL,       MVT::v8i16,   1 },\n    { ISD::ROTL,       MVT::v16i8,   1 },\n    { ISD::ROTR,       MVT::v4i64,   6 },\n    { ISD::ROTR,       MVT::v8i32,   6 },\n    { ISD::ROTR,       MVT::v16i16,  6 },\n    { ISD::ROTR,       MVT::v32i8,   6 },\n    { ISD::ROTR,       MVT::v2i64,   2 },\n    { ISD::ROTR,       MVT::v4i32,   2 },\n    { ISD::ROTR,       MVT::v8i16,   2 },\n    { ISD::ROTR,       MVT::v16i8,   2 }\n  };\n  static const CostTblEntry X64CostTbl[] = { // 64-bit targets\n    { ISD::ROTL,       MVT::i64,     1 },\n    { ISD::ROTR,       MVT::i64,     1 },\n    { ISD::FSHL,       MVT::i64,     4 }\n  };\n  static const CostTblEntry X86CostTbl[] = { // 32 or 64-bit targets\n    { ISD::ROTL,       MVT::i32,     1 },\n    { ISD::ROTL,       MVT::i16,     1 },\n    { ISD::ROTL,       MVT::i8,      1 },\n    { ISD::ROTR,       MVT::i32,     1 },\n    { ISD::ROTR,       MVT::i16,     1 },\n    { ISD::ROTR,       MVT::i8,      1 },\n    { ISD::FSHL,       MVT::i32,     4 },\n    { ISD::FSHL,       MVT::i16,     4 },\n    { ISD::FSHL,       MVT::i8,      4 }\n  };\n\n  Intrinsic::ID IID = ICA.getID();\n  Type *RetTy = ICA.getReturnType();\n  const SmallVectorImpl<const Value *> &Args = ICA.getArgs();\n  unsigned ISD = ISD::DELETED_NODE;\n  switch (IID) {\n  default:\n    break;\n  case Intrinsic::fshl:\n    ISD = ISD::FSHL;\n    if (Args[0] == Args[1])\n      ISD = ISD::ROTL;\n    break;\n  case Intrinsic::fshr:\n    // FSHR has same costs so don't duplicate.\n    ISD = ISD::FSHL;\n    if (Args[0] == Args[1])\n      ISD = ISD::ROTR;\n    break;\n  }\n\n  if (ISD != ISD::DELETED_NODE) {\n    // Legalize the type.\n    std::pair<int, MVT> LT = TLI->getTypeLegalizationCost(DL, RetTy);\n    MVT MTy = LT.second;\n\n    // Attempt to lookup cost.\n    if (ST->hasAVX512())\n      if (const auto *Entry = CostTableLookup(AVX512CostTbl, ISD, MTy))\n        return LT.first * Entry->Cost;\n\n    if (ST->hasXOP())\n      if (const auto *Entry = CostTableLookup(XOPCostTbl, ISD, MTy))\n        return LT.first * Entry->Cost;\n\n    if (ST->is64Bit())\n      if (const auto *Entry = CostTableLookup(X64CostTbl, ISD, MTy))\n        return LT.first * Entry->Cost;\n\n    if (const auto *Entry = CostTableLookup(X86CostTbl, ISD, MTy))\n      return LT.first * Entry->Cost;\n  }\n\n  return BaseT::getIntrinsicInstrCost(ICA, CostKind);\n}\n\nint X86TTIImpl::getVectorInstrCost(unsigned Opcode, Type *Val, unsigned Index) {\n  static const CostTblEntry SLMCostTbl[] = {\n     { ISD::EXTRACT_VECTOR_ELT,       MVT::i8,      4 },\n     { ISD::EXTRACT_VECTOR_ELT,       MVT::i16,     4 },\n     { ISD::EXTRACT_VECTOR_ELT,       MVT::i32,     4 },\n     { ISD::EXTRACT_VECTOR_ELT,       MVT::i64,     7 }\n   };\n\n  assert(Val->isVectorTy() && \"This must be a vector type\");\n  Type *ScalarType = Val->getScalarType();\n  int RegisterFileMoveCost = 0;\n\n  if (Index != -1U && (Opcode == Instruction::ExtractElement ||\n                       Opcode == Instruction::InsertElement)) {\n    // Legalize the type.\n    std::pair<int, MVT> LT = TLI->getTypeLegalizationCost(DL, Val);\n\n    // This type is legalized to a scalar type.\n    if (!LT.second.isVector())\n      return 0;\n\n    // The type may be split. Normalize the index to the new type.\n    unsigned NumElts = LT.second.getVectorNumElements();\n    unsigned SubNumElts = NumElts;\n    Index = Index % NumElts;\n\n    // For >128-bit vectors, we need to extract higher 128-bit subvectors.\n    // For inserts, we also need to insert the subvector back.\n    if (LT.second.getSizeInBits() > 128) {\n      assert((LT.second.getSizeInBits() % 128) == 0 && \"Illegal vector\");\n      unsigned NumSubVecs = LT.second.getSizeInBits() / 128;\n      SubNumElts = NumElts / NumSubVecs;\n      if (SubNumElts <= Index) {\n        RegisterFileMoveCost += (Opcode == Instruction::InsertElement ? 2 : 1);\n        Index %= SubNumElts;\n      }\n    }\n\n    if (Index == 0) {\n      // Floating point scalars are already located in index #0.\n      // Many insertions to #0 can fold away for scalar fp-ops, so let's assume\n      // true for all.\n      if (ScalarType->isFloatingPointTy())\n        return RegisterFileMoveCost;\n\n      // Assume movd/movq XMM -> GPR is relatively cheap on all targets.\n      if (ScalarType->isIntegerTy() && Opcode == Instruction::ExtractElement)\n        return 1 + RegisterFileMoveCost;\n    }\n\n    int ISD = TLI->InstructionOpcodeToISD(Opcode);\n    assert(ISD && \"Unexpected vector opcode\");\n    MVT MScalarTy = LT.second.getScalarType();\n    if (ST->isSLM())\n      if (auto *Entry = CostTableLookup(SLMCostTbl, ISD, MScalarTy))\n        return Entry->Cost + RegisterFileMoveCost;\n\n    // Assume pinsr/pextr XMM <-> GPR is relatively cheap on all targets.\n    if ((MScalarTy == MVT::i16 && ST->hasSSE2()) ||\n        (MScalarTy.isInteger() && ST->hasSSE41()))\n      return 1 + RegisterFileMoveCost;\n\n    // Assume insertps is relatively cheap on all targets.\n    if (MScalarTy == MVT::f32 && ST->hasSSE41() &&\n        Opcode == Instruction::InsertElement)\n      return 1 + RegisterFileMoveCost;\n\n    // For extractions we just need to shuffle the element to index 0, which\n    // should be very cheap (assume cost = 1). For insertions we need to shuffle\n    // the elements to its destination. In both cases we must handle the\n    // subvector move(s).\n    // If the vector type is already less than 128-bits then don't reduce it.\n    // TODO: Under what circumstances should we shuffle using the full width?\n    int ShuffleCost = 1;\n    if (Opcode == Instruction::InsertElement) {\n      auto *SubTy = cast<VectorType>(Val);\n      EVT VT = TLI->getValueType(DL, Val);\n      if (VT.getScalarType() != MScalarTy || VT.getSizeInBits() >= 128)\n        SubTy = FixedVectorType::get(ScalarType, SubNumElts);\n      ShuffleCost = getShuffleCost(TTI::SK_PermuteTwoSrc, SubTy, 0, SubTy);\n    }\n    int IntOrFpCost = ScalarType->isFloatingPointTy() ? 0 : 1;\n    return ShuffleCost + IntOrFpCost + RegisterFileMoveCost;\n  }\n\n  // Add to the base cost if we know that the extracted element of a vector is\n  // destined to be moved to and used in the integer register file.\n  if (Opcode == Instruction::ExtractElement && ScalarType->isPointerTy())\n    RegisterFileMoveCost += 1;\n\n  return BaseT::getVectorInstrCost(Opcode, Val, Index) + RegisterFileMoveCost;\n}\n\nunsigned X86TTIImpl::getScalarizationOverhead(VectorType *Ty,\n                                              const APInt &DemandedElts,\n                                              bool Insert, bool Extract) {\n  unsigned Cost = 0;\n\n  // For insertions, a ISD::BUILD_VECTOR style vector initialization can be much\n  // cheaper than an accumulation of ISD::INSERT_VECTOR_ELT.\n  if (Insert) {\n    std::pair<int, MVT> LT = TLI->getTypeLegalizationCost(DL, Ty);\n    MVT MScalarTy = LT.second.getScalarType();\n\n    if ((MScalarTy == MVT::i16 && ST->hasSSE2()) ||\n        (MScalarTy.isInteger() && ST->hasSSE41()) ||\n        (MScalarTy == MVT::f32 && ST->hasSSE41())) {\n      // For types we can insert directly, insertion into 128-bit sub vectors is\n      // cheap, followed by a cheap chain of concatenations.\n      if (LT.second.getSizeInBits() <= 128) {\n        Cost +=\n            BaseT::getScalarizationOverhead(Ty, DemandedElts, Insert, false);\n      } else {\n        // In each 128-lane, if at least one index is demanded but not all\n        // indices are demanded and this 128-lane is not the first 128-lane of\n        // the legalized-vector, then this 128-lane needs a extracti128; If in\n        // each 128-lane, there is at least one demanded index, this 128-lane\n        // needs a inserti128.\n\n        // The following cases will help you build a better understanding:\n        // Assume we insert several elements into a v8i32 vector in avx2,\n        // Case#1: inserting into 1th index needs vpinsrd + inserti128.\n        // Case#2: inserting into 5th index needs extracti128 + vpinsrd +\n        // inserti128.\n        // Case#3: inserting into 4,5,6,7 index needs 4*vpinsrd + inserti128.\n        unsigned Num128Lanes = LT.second.getSizeInBits() / 128 * LT.first;\n        unsigned NumElts = LT.second.getVectorNumElements() * LT.first;\n        APInt WidenedDemandedElts = DemandedElts.zextOrSelf(NumElts);\n        unsigned Scale = NumElts / Num128Lanes;\n        // We iterate each 128-lane, and check if we need a\n        // extracti128/inserti128 for this 128-lane.\n        for (unsigned I = 0; I < NumElts; I += Scale) {\n          APInt Mask = WidenedDemandedElts.getBitsSet(NumElts, I, I + Scale);\n          APInt MaskedDE = Mask & WidenedDemandedElts;\n          unsigned Population = MaskedDE.countPopulation();\n          Cost += (Population > 0 && Population != Scale &&\n                   I % LT.second.getVectorNumElements() != 0);\n          Cost += Population > 0;\n        }\n        Cost += DemandedElts.countPopulation();\n\n        // For vXf32 cases, insertion into the 0'th index in each v4f32\n        // 128-bit vector is free.\n        // NOTE: This assumes legalization widens vXf32 vectors.\n        if (MScalarTy == MVT::f32)\n          for (unsigned i = 0, e = cast<FixedVectorType>(Ty)->getNumElements();\n               i < e; i += 4)\n            if (DemandedElts[i])\n              Cost--;\n      }\n    } else if (LT.second.isVector()) {\n      // Without fast insertion, we need to use MOVD/MOVQ to pass each demanded\n      // integer element as a SCALAR_TO_VECTOR, then we build the vector as a\n      // series of UNPCK followed by CONCAT_VECTORS - all of these can be\n      // considered cheap.\n      if (Ty->isIntOrIntVectorTy())\n        Cost += DemandedElts.countPopulation();\n\n      // Get the smaller of the legalized or original pow2-extended number of\n      // vector elements, which represents the number of unpacks we'll end up\n      // performing.\n      unsigned NumElts = LT.second.getVectorNumElements();\n      unsigned Pow2Elts =\n          PowerOf2Ceil(cast<FixedVectorType>(Ty)->getNumElements());\n      Cost += (std::min<unsigned>(NumElts, Pow2Elts) - 1) * LT.first;\n    }\n  }\n\n  // TODO: Use default extraction for now, but we should investigate extending this\n  // to handle repeated subvector extraction.\n  if (Extract)\n    Cost += BaseT::getScalarizationOverhead(Ty, DemandedElts, false, Extract);\n\n  return Cost;\n}\n\nint X86TTIImpl::getMemoryOpCost(unsigned Opcode, Type *Src,\n                                MaybeAlign Alignment, unsigned AddressSpace,\n                                TTI::TargetCostKind CostKind,\n                                const Instruction *I) {\n  // TODO: Handle other cost kinds.\n  if (CostKind != TTI::TCK_RecipThroughput) {\n    if (auto *SI = dyn_cast_or_null<StoreInst>(I)) {\n      // Store instruction with index and scale costs 2 Uops.\n      // Check the preceding GEP to identify non-const indices.\n      if (auto *GEP = dyn_cast<GetElementPtrInst>(SI->getPointerOperand())) {\n        if (!all_of(GEP->indices(), [](Value *V) { return isa<Constant>(V); }))\n          return TTI::TCC_Basic * 2;\n      }\n    }\n    return TTI::TCC_Basic;\n  }\n\n  // Handle non-power-of-two vectors such as <3 x float>\n  if (auto *VTy = dyn_cast<FixedVectorType>(Src)) {\n    unsigned NumElem = VTy->getNumElements();\n\n    // Handle a few common cases:\n    // <3 x float>\n    if (NumElem == 3 && VTy->getScalarSizeInBits() == 32)\n      // Cost = 64 bit store + extract + 32 bit store.\n      return 3;\n\n    // <3 x double>\n    if (NumElem == 3 && VTy->getScalarSizeInBits() == 64)\n      // Cost = 128 bit store + unpack + 64 bit store.\n      return 3;\n\n    // Assume that all other non-power-of-two numbers are scalarized.\n    if (!isPowerOf2_32(NumElem)) {\n      APInt DemandedElts = APInt::getAllOnesValue(NumElem);\n      int Cost = BaseT::getMemoryOpCost(Opcode, VTy->getScalarType(), Alignment,\n                                        AddressSpace, CostKind);\n      int SplitCost = getScalarizationOverhead(VTy, DemandedElts,\n                                               Opcode == Instruction::Load,\n                                               Opcode == Instruction::Store);\n      return NumElem * Cost + SplitCost;\n    }\n  }\n\n  // Type legalization can't handle structs\n  if (TLI->getValueType(DL, Src,  true) == MVT::Other)\n    return BaseT::getMemoryOpCost(Opcode, Src, Alignment, AddressSpace,\n                                  CostKind);\n\n  // Legalize the type.\n  std::pair<int, MVT> LT = TLI->getTypeLegalizationCost(DL, Src);\n  assert((Opcode == Instruction::Load || Opcode == Instruction::Store) &&\n         \"Invalid Opcode\");\n\n  // Each load/store unit costs 1.\n  int Cost = LT.first * 1;\n\n  // This isn't exactly right. We're using slow unaligned 32-byte accesses as a\n  // proxy for a double-pumped AVX memory interface such as on Sandybridge.\n  if (LT.second.getStoreSize() == 32 && ST->isUnalignedMem32Slow())\n    Cost *= 2;\n\n  return Cost;\n}\n\nint X86TTIImpl::getMaskedMemoryOpCost(unsigned Opcode, Type *SrcTy,\n                                      Align Alignment, unsigned AddressSpace,\n                                      TTI::TargetCostKind CostKind) {\n  bool IsLoad = (Instruction::Load == Opcode);\n  bool IsStore = (Instruction::Store == Opcode);\n\n  auto *SrcVTy = dyn_cast<FixedVectorType>(SrcTy);\n  if (!SrcVTy)\n    // To calculate scalar take the regular cost, without mask\n    return getMemoryOpCost(Opcode, SrcTy, Alignment, AddressSpace, CostKind);\n\n  unsigned NumElem = SrcVTy->getNumElements();\n  auto *MaskTy =\n      FixedVectorType::get(Type::getInt8Ty(SrcVTy->getContext()), NumElem);\n  if ((IsLoad && !isLegalMaskedLoad(SrcVTy, Alignment)) ||\n      (IsStore && !isLegalMaskedStore(SrcVTy, Alignment)) ||\n      !isPowerOf2_32(NumElem)) {\n    // Scalarization\n    APInt DemandedElts = APInt::getAllOnesValue(NumElem);\n    int MaskSplitCost =\n        getScalarizationOverhead(MaskTy, DemandedElts, false, true);\n    int ScalarCompareCost = getCmpSelInstrCost(\n        Instruction::ICmp, Type::getInt8Ty(SrcVTy->getContext()), nullptr,\n        CmpInst::BAD_ICMP_PREDICATE, CostKind);\n    int BranchCost = getCFInstrCost(Instruction::Br, CostKind);\n    int MaskCmpCost = NumElem * (BranchCost + ScalarCompareCost);\n    int ValueSplitCost =\n        getScalarizationOverhead(SrcVTy, DemandedElts, IsLoad, IsStore);\n    int MemopCost =\n        NumElem * BaseT::getMemoryOpCost(Opcode, SrcVTy->getScalarType(),\n                                         Alignment, AddressSpace, CostKind);\n    return MemopCost + ValueSplitCost + MaskSplitCost + MaskCmpCost;\n  }\n\n  // Legalize the type.\n  std::pair<int, MVT> LT = TLI->getTypeLegalizationCost(DL, SrcVTy);\n  auto VT = TLI->getValueType(DL, SrcVTy);\n  int Cost = 0;\n  if (VT.isSimple() && LT.second != VT.getSimpleVT() &&\n      LT.second.getVectorNumElements() == NumElem)\n    // Promotion requires expand/truncate for data and a shuffle for mask.\n    Cost += getShuffleCost(TTI::SK_PermuteTwoSrc, SrcVTy, 0, nullptr) +\n            getShuffleCost(TTI::SK_PermuteTwoSrc, MaskTy, 0, nullptr);\n\n  else if (LT.second.getVectorNumElements() > NumElem) {\n    auto *NewMaskTy = FixedVectorType::get(MaskTy->getElementType(),\n                                           LT.second.getVectorNumElements());\n    // Expanding requires fill mask with zeroes\n    Cost += getShuffleCost(TTI::SK_InsertSubvector, NewMaskTy, 0, MaskTy);\n  }\n\n  // Pre-AVX512 - each maskmov load costs 2 + store costs ~8.\n  if (!ST->hasAVX512())\n    return Cost + LT.first * (IsLoad ? 2 : 8);\n\n  // AVX-512 masked load/store is cheapper\n  return Cost + LT.first;\n}\n\nint X86TTIImpl::getAddressComputationCost(Type *Ty, ScalarEvolution *SE,\n                                          const SCEV *Ptr) {\n  // Address computations in vectorized code with non-consecutive addresses will\n  // likely result in more instructions compared to scalar code where the\n  // computation can more often be merged into the index mode. The resulting\n  // extra micro-ops can significantly decrease throughput.\n  const unsigned NumVectorInstToHideOverhead = 10;\n\n  // Cost modeling of Strided Access Computation is hidden by the indexing\n  // modes of X86 regardless of the stride value. We dont believe that there\n  // is a difference between constant strided access in gerenal and constant\n  // strided value which is less than or equal to 64.\n  // Even in the case of (loop invariant) stride whose value is not known at\n  // compile time, the address computation will not incur more than one extra\n  // ADD instruction.\n  if (Ty->isVectorTy() && SE) {\n    if (!BaseT::isStridedAccess(Ptr))\n      return NumVectorInstToHideOverhead;\n    if (!BaseT::getConstantStrideStep(SE, Ptr))\n      return 1;\n  }\n\n  return BaseT::getAddressComputationCost(Ty, SE, Ptr);\n}\n\nint X86TTIImpl::getArithmeticReductionCost(unsigned Opcode, VectorType *ValTy,\n                                           bool IsPairwise,\n                                           TTI::TargetCostKind CostKind) {\n  // Just use the default implementation for pair reductions.\n  if (IsPairwise)\n    return BaseT::getArithmeticReductionCost(Opcode, ValTy, IsPairwise, CostKind);\n\n  // We use the Intel Architecture Code Analyzer(IACA) to measure the throughput\n  // and make it as the cost.\n\n  static const CostTblEntry SLMCostTblNoPairWise[] = {\n    { ISD::FADD,  MVT::v2f64,   3 },\n    { ISD::ADD,   MVT::v2i64,   5 },\n  };\n\n  static const CostTblEntry SSE2CostTblNoPairWise[] = {\n    { ISD::FADD,  MVT::v2f64,   2 },\n    { ISD::FADD,  MVT::v4f32,   4 },\n    { ISD::ADD,   MVT::v2i64,   2 },      // The data reported by the IACA tool is \"1.6\".\n    { ISD::ADD,   MVT::v2i32,   2 }, // FIXME: chosen to be less than v4i32\n    { ISD::ADD,   MVT::v4i32,   3 },      // The data reported by the IACA tool is \"3.3\".\n    { ISD::ADD,   MVT::v2i16,   2 },      // The data reported by the IACA tool is \"4.3\".\n    { ISD::ADD,   MVT::v4i16,   3 },      // The data reported by the IACA tool is \"4.3\".\n    { ISD::ADD,   MVT::v8i16,   4 },      // The data reported by the IACA tool is \"4.3\".\n    { ISD::ADD,   MVT::v2i8,    2 },\n    { ISD::ADD,   MVT::v4i8,    2 },\n    { ISD::ADD,   MVT::v8i8,    2 },\n    { ISD::ADD,   MVT::v16i8,   3 },\n  };\n\n  static const CostTblEntry AVX1CostTblNoPairWise[] = {\n    { ISD::FADD,  MVT::v4f64,   3 },\n    { ISD::FADD,  MVT::v4f32,   3 },\n    { ISD::FADD,  MVT::v8f32,   4 },\n    { ISD::ADD,   MVT::v2i64,   1 },      // The data reported by the IACA tool is \"1.5\".\n    { ISD::ADD,   MVT::v4i64,   3 },\n    { ISD::ADD,   MVT::v8i32,   5 },\n    { ISD::ADD,   MVT::v16i16,  5 },\n    { ISD::ADD,   MVT::v32i8,   4 },\n  };\n\n  int ISD = TLI->InstructionOpcodeToISD(Opcode);\n  assert(ISD && \"Invalid opcode\");\n\n  // Before legalizing the type, give a chance to look up illegal narrow types\n  // in the table.\n  // FIXME: Is there a better way to do this?\n  EVT VT = TLI->getValueType(DL, ValTy);\n  if (VT.isSimple()) {\n    MVT MTy = VT.getSimpleVT();\n    if (ST->isSLM())\n      if (const auto *Entry = CostTableLookup(SLMCostTblNoPairWise, ISD, MTy))\n        return Entry->Cost;\n\n    if (ST->hasAVX())\n      if (const auto *Entry = CostTableLookup(AVX1CostTblNoPairWise, ISD, MTy))\n        return Entry->Cost;\n\n    if (ST->hasSSE2())\n      if (const auto *Entry = CostTableLookup(SSE2CostTblNoPairWise, ISD, MTy))\n        return Entry->Cost;\n  }\n\n  std::pair<int, MVT> LT = TLI->getTypeLegalizationCost(DL, ValTy);\n\n  MVT MTy = LT.second;\n\n  auto *ValVTy = cast<FixedVectorType>(ValTy);\n\n  unsigned ArithmeticCost = 0;\n  if (LT.first != 1 && MTy.isVector() &&\n      MTy.getVectorNumElements() < ValVTy->getNumElements()) {\n    // Type needs to be split. We need LT.first - 1 arithmetic ops.\n    auto *SingleOpTy = FixedVectorType::get(ValVTy->getElementType(),\n                                            MTy.getVectorNumElements());\n    ArithmeticCost = getArithmeticInstrCost(Opcode, SingleOpTy, CostKind);\n    ArithmeticCost *= LT.first - 1;\n  }\n\n  if (ST->isSLM())\n    if (const auto *Entry = CostTableLookup(SLMCostTblNoPairWise, ISD, MTy))\n      return ArithmeticCost + Entry->Cost;\n\n  if (ST->hasAVX())\n    if (const auto *Entry = CostTableLookup(AVX1CostTblNoPairWise, ISD, MTy))\n      return ArithmeticCost + Entry->Cost;\n\n  if (ST->hasSSE2())\n    if (const auto *Entry = CostTableLookup(SSE2CostTblNoPairWise, ISD, MTy))\n      return ArithmeticCost + Entry->Cost;\n\n  // FIXME: These assume a naive kshift+binop lowering, which is probably\n  // conservative in most cases.\n  static const CostTblEntry AVX512BoolReduction[] = {\n    { ISD::AND,  MVT::v2i1,   3 },\n    { ISD::AND,  MVT::v4i1,   5 },\n    { ISD::AND,  MVT::v8i1,   7 },\n    { ISD::AND,  MVT::v16i1,  9 },\n    { ISD::AND,  MVT::v32i1, 11 },\n    { ISD::AND,  MVT::v64i1, 13 },\n    { ISD::OR,   MVT::v2i1,   3 },\n    { ISD::OR,   MVT::v4i1,   5 },\n    { ISD::OR,   MVT::v8i1,   7 },\n    { ISD::OR,   MVT::v16i1,  9 },\n    { ISD::OR,   MVT::v32i1, 11 },\n    { ISD::OR,   MVT::v64i1, 13 },\n  };\n\n  static const CostTblEntry AVX2BoolReduction[] = {\n    { ISD::AND,  MVT::v16i16,  2 }, // vpmovmskb + cmp\n    { ISD::AND,  MVT::v32i8,   2 }, // vpmovmskb + cmp\n    { ISD::OR,   MVT::v16i16,  2 }, // vpmovmskb + cmp\n    { ISD::OR,   MVT::v32i8,   2 }, // vpmovmskb + cmp\n  };\n\n  static const CostTblEntry AVX1BoolReduction[] = {\n    { ISD::AND,  MVT::v4i64,   2 }, // vmovmskpd + cmp\n    { ISD::AND,  MVT::v8i32,   2 }, // vmovmskps + cmp\n    { ISD::AND,  MVT::v16i16,  4 }, // vextractf128 + vpand + vpmovmskb + cmp\n    { ISD::AND,  MVT::v32i8,   4 }, // vextractf128 + vpand + vpmovmskb + cmp\n    { ISD::OR,   MVT::v4i64,   2 }, // vmovmskpd + cmp\n    { ISD::OR,   MVT::v8i32,   2 }, // vmovmskps + cmp\n    { ISD::OR,   MVT::v16i16,  4 }, // vextractf128 + vpor + vpmovmskb + cmp\n    { ISD::OR,   MVT::v32i8,   4 }, // vextractf128 + vpor + vpmovmskb + cmp\n  };\n\n  static const CostTblEntry SSE2BoolReduction[] = {\n    { ISD::AND,  MVT::v2i64,   2 }, // movmskpd + cmp\n    { ISD::AND,  MVT::v4i32,   2 }, // movmskps + cmp\n    { ISD::AND,  MVT::v8i16,   2 }, // pmovmskb + cmp\n    { ISD::AND,  MVT::v16i8,   2 }, // pmovmskb + cmp\n    { ISD::OR,   MVT::v2i64,   2 }, // movmskpd + cmp\n    { ISD::OR,   MVT::v4i32,   2 }, // movmskps + cmp\n    { ISD::OR,   MVT::v8i16,   2 }, // pmovmskb + cmp\n    { ISD::OR,   MVT::v16i8,   2 }, // pmovmskb + cmp\n  };\n\n  // Handle bool allof/anyof patterns.\n  if (ValVTy->getElementType()->isIntegerTy(1)) {\n    unsigned ArithmeticCost = 0;\n    if (LT.first != 1 && MTy.isVector() &&\n        MTy.getVectorNumElements() < ValVTy->getNumElements()) {\n      // Type needs to be split. We need LT.first - 1 arithmetic ops.\n      auto *SingleOpTy = FixedVectorType::get(ValVTy->getElementType(),\n                                              MTy.getVectorNumElements());\n      ArithmeticCost = getArithmeticInstrCost(Opcode, SingleOpTy, CostKind);\n      ArithmeticCost *= LT.first - 1;\n    }\n\n    if (ST->hasAVX512())\n      if (const auto *Entry = CostTableLookup(AVX512BoolReduction, ISD, MTy))\n        return ArithmeticCost + Entry->Cost;\n    if (ST->hasAVX2())\n      if (const auto *Entry = CostTableLookup(AVX2BoolReduction, ISD, MTy))\n        return ArithmeticCost + Entry->Cost;\n    if (ST->hasAVX())\n      if (const auto *Entry = CostTableLookup(AVX1BoolReduction, ISD, MTy))\n        return ArithmeticCost + Entry->Cost;\n    if (ST->hasSSE2())\n      if (const auto *Entry = CostTableLookup(SSE2BoolReduction, ISD, MTy))\n        return ArithmeticCost + Entry->Cost;\n\n    return BaseT::getArithmeticReductionCost(Opcode, ValVTy, IsPairwise,\n                                             CostKind);\n  }\n\n  unsigned NumVecElts = ValVTy->getNumElements();\n  unsigned ScalarSize = ValVTy->getScalarSizeInBits();\n\n  // Special case power of 2 reductions where the scalar type isn't changed\n  // by type legalization.\n  if (!isPowerOf2_32(NumVecElts) || ScalarSize != MTy.getScalarSizeInBits())\n    return BaseT::getArithmeticReductionCost(Opcode, ValVTy, IsPairwise,\n                                             CostKind);\n\n  unsigned ReductionCost = 0;\n\n  auto *Ty = ValVTy;\n  if (LT.first != 1 && MTy.isVector() &&\n      MTy.getVectorNumElements() < ValVTy->getNumElements()) {\n    // Type needs to be split. We need LT.first - 1 arithmetic ops.\n    Ty = FixedVectorType::get(ValVTy->getElementType(),\n                              MTy.getVectorNumElements());\n    ReductionCost = getArithmeticInstrCost(Opcode, Ty, CostKind);\n    ReductionCost *= LT.first - 1;\n    NumVecElts = MTy.getVectorNumElements();\n  }\n\n  // Now handle reduction with the legal type, taking into account size changes\n  // at each level.\n  while (NumVecElts > 1) {\n    // Determine the size of the remaining vector we need to reduce.\n    unsigned Size = NumVecElts * ScalarSize;\n    NumVecElts /= 2;\n    // If we're reducing from 256/512 bits, use an extract_subvector.\n    if (Size > 128) {\n      auto *SubTy = FixedVectorType::get(ValVTy->getElementType(), NumVecElts);\n      ReductionCost +=\n          getShuffleCost(TTI::SK_ExtractSubvector, Ty, NumVecElts, SubTy);\n      Ty = SubTy;\n    } else if (Size == 128) {\n      // Reducing from 128 bits is a permute of v2f64/v2i64.\n      FixedVectorType *ShufTy;\n      if (ValVTy->isFloatingPointTy())\n        ShufTy =\n            FixedVectorType::get(Type::getDoubleTy(ValVTy->getContext()), 2);\n      else\n        ShufTy =\n            FixedVectorType::get(Type::getInt64Ty(ValVTy->getContext()), 2);\n      ReductionCost +=\n          getShuffleCost(TTI::SK_PermuteSingleSrc, ShufTy, 0, nullptr);\n    } else if (Size == 64) {\n      // Reducing from 64 bits is a shuffle of v4f32/v4i32.\n      FixedVectorType *ShufTy;\n      if (ValVTy->isFloatingPointTy())\n        ShufTy =\n            FixedVectorType::get(Type::getFloatTy(ValVTy->getContext()), 4);\n      else\n        ShufTy =\n            FixedVectorType::get(Type::getInt32Ty(ValVTy->getContext()), 4);\n      ReductionCost +=\n          getShuffleCost(TTI::SK_PermuteSingleSrc, ShufTy, 0, nullptr);\n    } else {\n      // Reducing from smaller size is a shift by immediate.\n      auto *ShiftTy = FixedVectorType::get(\n          Type::getIntNTy(ValVTy->getContext(), Size), 128 / Size);\n      ReductionCost += getArithmeticInstrCost(\n          Instruction::LShr, ShiftTy, CostKind,\n          TargetTransformInfo::OK_AnyValue,\n          TargetTransformInfo::OK_UniformConstantValue,\n          TargetTransformInfo::OP_None, TargetTransformInfo::OP_None);\n    }\n\n    // Add the arithmetic op for this level.\n    ReductionCost += getArithmeticInstrCost(Opcode, Ty, CostKind);\n  }\n\n  // Add the final extract element to the cost.\n  return ReductionCost + getVectorInstrCost(Instruction::ExtractElement, Ty, 0);\n}\n\nint X86TTIImpl::getMinMaxCost(Type *Ty, Type *CondTy, bool IsUnsigned) {\n  std::pair<int, MVT> LT = TLI->getTypeLegalizationCost(DL, Ty);\n\n  MVT MTy = LT.second;\n\n  int ISD;\n  if (Ty->isIntOrIntVectorTy()) {\n    ISD = IsUnsigned ? ISD::UMIN : ISD::SMIN;\n  } else {\n    assert(Ty->isFPOrFPVectorTy() &&\n           \"Expected float point or integer vector type.\");\n    ISD = ISD::FMINNUM;\n  }\n\n  static const CostTblEntry SSE1CostTbl[] = {\n    {ISD::FMINNUM, MVT::v4f32, 1},\n  };\n\n  static const CostTblEntry SSE2CostTbl[] = {\n    {ISD::FMINNUM, MVT::v2f64, 1},\n    {ISD::SMIN,    MVT::v8i16, 1},\n    {ISD::UMIN,    MVT::v16i8, 1},\n  };\n\n  static const CostTblEntry SSE41CostTbl[] = {\n    {ISD::SMIN,    MVT::v4i32, 1},\n    {ISD::UMIN,    MVT::v4i32, 1},\n    {ISD::UMIN,    MVT::v8i16, 1},\n    {ISD::SMIN,    MVT::v16i8, 1},\n  };\n\n  static const CostTblEntry SSE42CostTbl[] = {\n    {ISD::UMIN,    MVT::v2i64, 3}, // xor+pcmpgtq+blendvpd\n  };\n\n  static const CostTblEntry AVX1CostTbl[] = {\n    {ISD::FMINNUM, MVT::v8f32,  1},\n    {ISD::FMINNUM, MVT::v4f64,  1},\n    {ISD::SMIN,    MVT::v8i32,  3},\n    {ISD::UMIN,    MVT::v8i32,  3},\n    {ISD::SMIN,    MVT::v16i16, 3},\n    {ISD::UMIN,    MVT::v16i16, 3},\n    {ISD::SMIN,    MVT::v32i8,  3},\n    {ISD::UMIN,    MVT::v32i8,  3},\n  };\n\n  static const CostTblEntry AVX2CostTbl[] = {\n    {ISD::SMIN,    MVT::v8i32,  1},\n    {ISD::UMIN,    MVT::v8i32,  1},\n    {ISD::SMIN,    MVT::v16i16, 1},\n    {ISD::UMIN,    MVT::v16i16, 1},\n    {ISD::SMIN,    MVT::v32i8,  1},\n    {ISD::UMIN,    MVT::v32i8,  1},\n  };\n\n  static const CostTblEntry AVX512CostTbl[] = {\n    {ISD::FMINNUM, MVT::v16f32, 1},\n    {ISD::FMINNUM, MVT::v8f64,  1},\n    {ISD::SMIN,    MVT::v2i64,  1},\n    {ISD::UMIN,    MVT::v2i64,  1},\n    {ISD::SMIN,    MVT::v4i64,  1},\n    {ISD::UMIN,    MVT::v4i64,  1},\n    {ISD::SMIN,    MVT::v8i64,  1},\n    {ISD::UMIN,    MVT::v8i64,  1},\n    {ISD::SMIN,    MVT::v16i32, 1},\n    {ISD::UMIN,    MVT::v16i32, 1},\n  };\n\n  static const CostTblEntry AVX512BWCostTbl[] = {\n    {ISD::SMIN,    MVT::v32i16, 1},\n    {ISD::UMIN,    MVT::v32i16, 1},\n    {ISD::SMIN,    MVT::v64i8,  1},\n    {ISD::UMIN,    MVT::v64i8,  1},\n  };\n\n  // If we have a native MIN/MAX instruction for this type, use it.\n  if (ST->hasBWI())\n    if (const auto *Entry = CostTableLookup(AVX512BWCostTbl, ISD, MTy))\n      return LT.first * Entry->Cost;\n\n  if (ST->hasAVX512())\n    if (const auto *Entry = CostTableLookup(AVX512CostTbl, ISD, MTy))\n      return LT.first * Entry->Cost;\n\n  if (ST->hasAVX2())\n    if (const auto *Entry = CostTableLookup(AVX2CostTbl, ISD, MTy))\n      return LT.first * Entry->Cost;\n\n  if (ST->hasAVX())\n    if (const auto *Entry = CostTableLookup(AVX1CostTbl, ISD, MTy))\n      return LT.first * Entry->Cost;\n\n  if (ST->hasSSE42())\n    if (const auto *Entry = CostTableLookup(SSE42CostTbl, ISD, MTy))\n      return LT.first * Entry->Cost;\n\n  if (ST->hasSSE41())\n    if (const auto *Entry = CostTableLookup(SSE41CostTbl, ISD, MTy))\n      return LT.first * Entry->Cost;\n\n  if (ST->hasSSE2())\n    if (const auto *Entry = CostTableLookup(SSE2CostTbl, ISD, MTy))\n      return LT.first * Entry->Cost;\n\n  if (ST->hasSSE1())\n    if (const auto *Entry = CostTableLookup(SSE1CostTbl, ISD, MTy))\n      return LT.first * Entry->Cost;\n\n  unsigned CmpOpcode;\n  if (Ty->isFPOrFPVectorTy()) {\n    CmpOpcode = Instruction::FCmp;\n  } else {\n    assert(Ty->isIntOrIntVectorTy() &&\n           \"expecting floating point or integer type for min/max reduction\");\n    CmpOpcode = Instruction::ICmp;\n  }\n\n  TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput;\n  // Otherwise fall back to cmp+select.\n  return getCmpSelInstrCost(CmpOpcode, Ty, CondTy, CmpInst::BAD_ICMP_PREDICATE,\n                            CostKind) +\n         getCmpSelInstrCost(Instruction::Select, Ty, CondTy,\n                            CmpInst::BAD_ICMP_PREDICATE, CostKind);\n}\n\nint X86TTIImpl::getMinMaxReductionCost(VectorType *ValTy, VectorType *CondTy,\n                                       bool IsPairwise, bool IsUnsigned,\n                                       TTI::TargetCostKind CostKind) {\n  // Just use the default implementation for pair reductions.\n  if (IsPairwise)\n    return BaseT::getMinMaxReductionCost(ValTy, CondTy, IsPairwise, IsUnsigned,\n                                         CostKind);\n\n  std::pair<int, MVT> LT = TLI->getTypeLegalizationCost(DL, ValTy);\n\n  MVT MTy = LT.second;\n\n  int ISD;\n  if (ValTy->isIntOrIntVectorTy()) {\n    ISD = IsUnsigned ? ISD::UMIN : ISD::SMIN;\n  } else {\n    assert(ValTy->isFPOrFPVectorTy() &&\n           \"Expected float point or integer vector type.\");\n    ISD = ISD::FMINNUM;\n  }\n\n  // We use the Intel Architecture Code Analyzer(IACA) to measure the throughput\n  // and make it as the cost.\n\n  static const CostTblEntry SSE2CostTblNoPairWise[] = {\n      {ISD::UMIN, MVT::v2i16, 5}, // need pxors to use pminsw/pmaxsw\n      {ISD::UMIN, MVT::v4i16, 7}, // need pxors to use pminsw/pmaxsw\n      {ISD::UMIN, MVT::v8i16, 9}, // need pxors to use pminsw/pmaxsw\n  };\n\n  static const CostTblEntry SSE41CostTblNoPairWise[] = {\n      {ISD::SMIN, MVT::v2i16, 3}, // same as sse2\n      {ISD::SMIN, MVT::v4i16, 5}, // same as sse2\n      {ISD::UMIN, MVT::v2i16, 5}, // same as sse2\n      {ISD::UMIN, MVT::v4i16, 7}, // same as sse2\n      {ISD::SMIN, MVT::v8i16, 4}, // phminposuw+xor\n      {ISD::UMIN, MVT::v8i16, 4}, // FIXME: umin is cheaper than umax\n      {ISD::SMIN, MVT::v2i8,  3}, // pminsb\n      {ISD::SMIN, MVT::v4i8,  5}, // pminsb\n      {ISD::SMIN, MVT::v8i8,  7}, // pminsb\n      {ISD::SMIN, MVT::v16i8, 6},\n      {ISD::UMIN, MVT::v2i8,  3}, // same as sse2\n      {ISD::UMIN, MVT::v4i8,  5}, // same as sse2\n      {ISD::UMIN, MVT::v8i8,  7}, // same as sse2\n      {ISD::UMIN, MVT::v16i8, 6}, // FIXME: umin is cheaper than umax\n  };\n\n  static const CostTblEntry AVX1CostTblNoPairWise[] = {\n      {ISD::SMIN, MVT::v16i16, 6},\n      {ISD::UMIN, MVT::v16i16, 6}, // FIXME: umin is cheaper than umax\n      {ISD::SMIN, MVT::v32i8, 8},\n      {ISD::UMIN, MVT::v32i8, 8},\n  };\n\n  static const CostTblEntry AVX512BWCostTblNoPairWise[] = {\n      {ISD::SMIN, MVT::v32i16, 8},\n      {ISD::UMIN, MVT::v32i16, 8}, // FIXME: umin is cheaper than umax\n      {ISD::SMIN, MVT::v64i8, 10},\n      {ISD::UMIN, MVT::v64i8, 10},\n  };\n\n  // Before legalizing the type, give a chance to look up illegal narrow types\n  // in the table.\n  // FIXME: Is there a better way to do this?\n  EVT VT = TLI->getValueType(DL, ValTy);\n  if (VT.isSimple()) {\n    MVT MTy = VT.getSimpleVT();\n    if (ST->hasBWI())\n      if (const auto *Entry = CostTableLookup(AVX512BWCostTblNoPairWise, ISD, MTy))\n        return Entry->Cost;\n\n    if (ST->hasAVX())\n      if (const auto *Entry = CostTableLookup(AVX1CostTblNoPairWise, ISD, MTy))\n        return Entry->Cost;\n\n    if (ST->hasSSE41())\n      if (const auto *Entry = CostTableLookup(SSE41CostTblNoPairWise, ISD, MTy))\n        return Entry->Cost;\n\n    if (ST->hasSSE2())\n      if (const auto *Entry = CostTableLookup(SSE2CostTblNoPairWise, ISD, MTy))\n        return Entry->Cost;\n  }\n\n  auto *ValVTy = cast<FixedVectorType>(ValTy);\n  unsigned NumVecElts = ValVTy->getNumElements();\n\n  auto *Ty = ValVTy;\n  unsigned MinMaxCost = 0;\n  if (LT.first != 1 && MTy.isVector() &&\n      MTy.getVectorNumElements() < ValVTy->getNumElements()) {\n    // Type needs to be split. We need LT.first - 1 operations ops.\n    Ty = FixedVectorType::get(ValVTy->getElementType(),\n                              MTy.getVectorNumElements());\n    auto *SubCondTy = FixedVectorType::get(CondTy->getElementType(),\n                                           MTy.getVectorNumElements());\n    MinMaxCost = getMinMaxCost(Ty, SubCondTy, IsUnsigned);\n    MinMaxCost *= LT.first - 1;\n    NumVecElts = MTy.getVectorNumElements();\n  }\n\n  if (ST->hasBWI())\n    if (const auto *Entry = CostTableLookup(AVX512BWCostTblNoPairWise, ISD, MTy))\n      return MinMaxCost + Entry->Cost;\n\n  if (ST->hasAVX())\n    if (const auto *Entry = CostTableLookup(AVX1CostTblNoPairWise, ISD, MTy))\n      return MinMaxCost + Entry->Cost;\n\n  if (ST->hasSSE41())\n    if (const auto *Entry = CostTableLookup(SSE41CostTblNoPairWise, ISD, MTy))\n      return MinMaxCost + Entry->Cost;\n\n  if (ST->hasSSE2())\n    if (const auto *Entry = CostTableLookup(SSE2CostTblNoPairWise, ISD, MTy))\n      return MinMaxCost + Entry->Cost;\n\n  unsigned ScalarSize = ValTy->getScalarSizeInBits();\n\n  // Special case power of 2 reductions where the scalar type isn't changed\n  // by type legalization.\n  if (!isPowerOf2_32(ValVTy->getNumElements()) ||\n      ScalarSize != MTy.getScalarSizeInBits())\n    return BaseT::getMinMaxReductionCost(ValTy, CondTy, IsPairwise, IsUnsigned,\n                                         CostKind);\n\n  // Now handle reduction with the legal type, taking into account size changes\n  // at each level.\n  while (NumVecElts > 1) {\n    // Determine the size of the remaining vector we need to reduce.\n    unsigned Size = NumVecElts * ScalarSize;\n    NumVecElts /= 2;\n    // If we're reducing from 256/512 bits, use an extract_subvector.\n    if (Size > 128) {\n      auto *SubTy = FixedVectorType::get(ValVTy->getElementType(), NumVecElts);\n      MinMaxCost +=\n          getShuffleCost(TTI::SK_ExtractSubvector, Ty, NumVecElts, SubTy);\n      Ty = SubTy;\n    } else if (Size == 128) {\n      // Reducing from 128 bits is a permute of v2f64/v2i64.\n      VectorType *ShufTy;\n      if (ValTy->isFloatingPointTy())\n        ShufTy =\n            FixedVectorType::get(Type::getDoubleTy(ValTy->getContext()), 2);\n      else\n        ShufTy = FixedVectorType::get(Type::getInt64Ty(ValTy->getContext()), 2);\n      MinMaxCost +=\n          getShuffleCost(TTI::SK_PermuteSingleSrc, ShufTy, 0, nullptr);\n    } else if (Size == 64) {\n      // Reducing from 64 bits is a shuffle of v4f32/v4i32.\n      FixedVectorType *ShufTy;\n      if (ValTy->isFloatingPointTy())\n        ShufTy = FixedVectorType::get(Type::getFloatTy(ValTy->getContext()), 4);\n      else\n        ShufTy = FixedVectorType::get(Type::getInt32Ty(ValTy->getContext()), 4);\n      MinMaxCost +=\n          getShuffleCost(TTI::SK_PermuteSingleSrc, ShufTy, 0, nullptr);\n    } else {\n      // Reducing from smaller size is a shift by immediate.\n      auto *ShiftTy = FixedVectorType::get(\n          Type::getIntNTy(ValTy->getContext(), Size), 128 / Size);\n      MinMaxCost += getArithmeticInstrCost(\n          Instruction::LShr, ShiftTy, TTI::TCK_RecipThroughput,\n          TargetTransformInfo::OK_AnyValue,\n          TargetTransformInfo::OK_UniformConstantValue,\n          TargetTransformInfo::OP_None, TargetTransformInfo::OP_None);\n    }\n\n    // Add the arithmetic op for this level.\n    auto *SubCondTy =\n        FixedVectorType::get(CondTy->getElementType(), Ty->getNumElements());\n    MinMaxCost += getMinMaxCost(Ty, SubCondTy, IsUnsigned);\n  }\n\n  // Add the final extract element to the cost.\n  return MinMaxCost + getVectorInstrCost(Instruction::ExtractElement, Ty, 0);\n}\n\n/// Calculate the cost of materializing a 64-bit value. This helper\n/// method might only calculate a fraction of a larger immediate. Therefore it\n/// is valid to return a cost of ZERO.\nint X86TTIImpl::getIntImmCost(int64_t Val) {\n  if (Val == 0)\n    return TTI::TCC_Free;\n\n  if (isInt<32>(Val))\n    return TTI::TCC_Basic;\n\n  return 2 * TTI::TCC_Basic;\n}\n\nint X86TTIImpl::getIntImmCost(const APInt &Imm, Type *Ty,\n                              TTI::TargetCostKind CostKind) {\n  assert(Ty->isIntegerTy());\n\n  unsigned BitSize = Ty->getPrimitiveSizeInBits();\n  if (BitSize == 0)\n    return ~0U;\n\n  // Never hoist constants larger than 128bit, because this might lead to\n  // incorrect code generation or assertions in codegen.\n  // Fixme: Create a cost model for types larger than i128 once the codegen\n  // issues have been fixed.\n  if (BitSize > 128)\n    return TTI::TCC_Free;\n\n  if (Imm == 0)\n    return TTI::TCC_Free;\n\n  // Sign-extend all constants to a multiple of 64-bit.\n  APInt ImmVal = Imm;\n  if (BitSize % 64 != 0)\n    ImmVal = Imm.sext(alignTo(BitSize, 64));\n\n  // Split the constant into 64-bit chunks and calculate the cost for each\n  // chunk.\n  int Cost = 0;\n  for (unsigned ShiftVal = 0; ShiftVal < BitSize; ShiftVal += 64) {\n    APInt Tmp = ImmVal.ashr(ShiftVal).sextOrTrunc(64);\n    int64_t Val = Tmp.getSExtValue();\n    Cost += getIntImmCost(Val);\n  }\n  // We need at least one instruction to materialize the constant.\n  return std::max(1, Cost);\n}\n\nint X86TTIImpl::getIntImmCostInst(unsigned Opcode, unsigned Idx,\n                                  const APInt &Imm, Type *Ty,\n                                  TTI::TargetCostKind CostKind,\n                                  Instruction *Inst) {\n  assert(Ty->isIntegerTy());\n\n  unsigned BitSize = Ty->getPrimitiveSizeInBits();\n  // There is no cost model for constants with a bit size of 0. Return TCC_Free\n  // here, so that constant hoisting will ignore this constant.\n  if (BitSize == 0)\n    return TTI::TCC_Free;\n\n  unsigned ImmIdx = ~0U;\n  switch (Opcode) {\n  default:\n    return TTI::TCC_Free;\n  case Instruction::GetElementPtr:\n    // Always hoist the base address of a GetElementPtr. This prevents the\n    // creation of new constants for every base constant that gets constant\n    // folded with the offset.\n    if (Idx == 0)\n      return 2 * TTI::TCC_Basic;\n    return TTI::TCC_Free;\n  case Instruction::Store:\n    ImmIdx = 0;\n    break;\n  case Instruction::ICmp:\n    // This is an imperfect hack to prevent constant hoisting of\n    // compares that might be trying to check if a 64-bit value fits in\n    // 32-bits. The backend can optimize these cases using a right shift by 32.\n    // Ideally we would check the compare predicate here. There also other\n    // similar immediates the backend can use shifts for.\n    if (Idx == 1 && Imm.getBitWidth() == 64) {\n      uint64_t ImmVal = Imm.getZExtValue();\n      if (ImmVal == 0x100000000ULL || ImmVal == 0xffffffff)\n        return TTI::TCC_Free;\n    }\n    ImmIdx = 1;\n    break;\n  case Instruction::And:\n    // We support 64-bit ANDs with immediates with 32-bits of leading zeroes\n    // by using a 32-bit operation with implicit zero extension. Detect such\n    // immediates here as the normal path expects bit 31 to be sign extended.\n    if (Idx == 1 && Imm.getBitWidth() == 64 && isUInt<32>(Imm.getZExtValue()))\n      return TTI::TCC_Free;\n    ImmIdx = 1;\n    break;\n  case Instruction::Add:\n  case Instruction::Sub:\n    // For add/sub, we can use the opposite instruction for INT32_MIN.\n    if (Idx == 1 && Imm.getBitWidth() == 64 && Imm.getZExtValue() == 0x80000000)\n      return TTI::TCC_Free;\n    ImmIdx = 1;\n    break;\n  case Instruction::UDiv:\n  case Instruction::SDiv:\n  case Instruction::URem:\n  case Instruction::SRem:\n    // Division by constant is typically expanded later into a different\n    // instruction sequence. This completely changes the constants.\n    // Report them as \"free\" to stop ConstantHoist from marking them as opaque.\n    return TTI::TCC_Free;\n  case Instruction::Mul:\n  case Instruction::Or:\n  case Instruction::Xor:\n    ImmIdx = 1;\n    break;\n  // Always return TCC_Free for the shift value of a shift instruction.\n  case Instruction::Shl:\n  case Instruction::LShr:\n  case Instruction::AShr:\n    if (Idx == 1)\n      return TTI::TCC_Free;\n    break;\n  case Instruction::Trunc:\n  case Instruction::ZExt:\n  case Instruction::SExt:\n  case Instruction::IntToPtr:\n  case Instruction::PtrToInt:\n  case Instruction::BitCast:\n  case Instruction::PHI:\n  case Instruction::Call:\n  case Instruction::Select:\n  case Instruction::Ret:\n  case Instruction::Load:\n    break;\n  }\n\n  if (Idx == ImmIdx) {\n    int NumConstants = divideCeil(BitSize, 64);\n    int Cost = X86TTIImpl::getIntImmCost(Imm, Ty, CostKind);\n    return (Cost <= NumConstants * TTI::TCC_Basic)\n               ? static_cast<int>(TTI::TCC_Free)\n               : Cost;\n  }\n\n  return X86TTIImpl::getIntImmCost(Imm, Ty, CostKind);\n}\n\nint X86TTIImpl::getIntImmCostIntrin(Intrinsic::ID IID, unsigned Idx,\n                                    const APInt &Imm, Type *Ty,\n                                    TTI::TargetCostKind CostKind) {\n  assert(Ty->isIntegerTy());\n\n  unsigned BitSize = Ty->getPrimitiveSizeInBits();\n  // There is no cost model for constants with a bit size of 0. Return TCC_Free\n  // here, so that constant hoisting will ignore this constant.\n  if (BitSize == 0)\n    return TTI::TCC_Free;\n\n  switch (IID) {\n  default:\n    return TTI::TCC_Free;\n  case Intrinsic::sadd_with_overflow:\n  case Intrinsic::uadd_with_overflow:\n  case Intrinsic::ssub_with_overflow:\n  case Intrinsic::usub_with_overflow:\n  case Intrinsic::smul_with_overflow:\n  case Intrinsic::umul_with_overflow:\n    if ((Idx == 1) && Imm.getBitWidth() <= 64 && isInt<32>(Imm.getSExtValue()))\n      return TTI::TCC_Free;\n    break;\n  case Intrinsic::experimental_stackmap:\n    if ((Idx < 2) || (Imm.getBitWidth() <= 64 && isInt<64>(Imm.getSExtValue())))\n      return TTI::TCC_Free;\n    break;\n  case Intrinsic::experimental_patchpoint_void:\n  case Intrinsic::experimental_patchpoint_i64:\n    if ((Idx < 4) || (Imm.getBitWidth() <= 64 && isInt<64>(Imm.getSExtValue())))\n      return TTI::TCC_Free;\n    break;\n  }\n  return X86TTIImpl::getIntImmCost(Imm, Ty, CostKind);\n}\n\nunsigned\nX86TTIImpl::getCFInstrCost(unsigned Opcode, TTI::TargetCostKind CostKind) {\n  if (CostKind != TTI::TCK_RecipThroughput)\n    return Opcode == Instruction::PHI ? 0 : 1;\n  // Branches are assumed to be predicted.\n  return CostKind == TTI::TCK_RecipThroughput ? 0 : 1;\n}\n\nint X86TTIImpl::getGatherOverhead() const {\n  // Some CPUs have more overhead for gather. The specified overhead is relative\n  // to the Load operation. \"2\" is the number provided by Intel architects. This\n  // parameter is used for cost estimation of Gather Op and comparison with\n  // other alternatives.\n  // TODO: Remove the explicit hasAVX512()?, That would mean we would only\n  // enable gather with a -march.\n  if (ST->hasAVX512() || (ST->hasAVX2() && ST->hasFastGather()))\n    return 2;\n\n  return 1024;\n}\n\nint X86TTIImpl::getScatterOverhead() const {\n  if (ST->hasAVX512())\n    return 2;\n\n  return 1024;\n}\n\n// Return an average cost of Gather / Scatter instruction, maybe improved later.\n// FIXME: Add TargetCostKind support.\nint X86TTIImpl::getGSVectorCost(unsigned Opcode, Type *SrcVTy, const Value *Ptr,\n                                Align Alignment, unsigned AddressSpace) {\n\n  assert(isa<VectorType>(SrcVTy) && \"Unexpected type in getGSVectorCost\");\n  unsigned VF = cast<FixedVectorType>(SrcVTy)->getNumElements();\n\n  // Try to reduce index size from 64 bit (default for GEP)\n  // to 32. It is essential for VF 16. If the index can't be reduced to 32, the\n  // operation will use 16 x 64 indices which do not fit in a zmm and needs\n  // to split. Also check that the base pointer is the same for all lanes,\n  // and that there's at most one variable index.\n  auto getIndexSizeInBits = [](const Value *Ptr, const DataLayout &DL) {\n    unsigned IndexSize = DL.getPointerSizeInBits();\n    const GetElementPtrInst *GEP = dyn_cast<GetElementPtrInst>(Ptr);\n    if (IndexSize < 64 || !GEP)\n      return IndexSize;\n\n    unsigned NumOfVarIndices = 0;\n    const Value *Ptrs = GEP->getPointerOperand();\n    if (Ptrs->getType()->isVectorTy() && !getSplatValue(Ptrs))\n      return IndexSize;\n    for (unsigned i = 1; i < GEP->getNumOperands(); ++i) {\n      if (isa<Constant>(GEP->getOperand(i)))\n        continue;\n      Type *IndxTy = GEP->getOperand(i)->getType();\n      if (auto *IndexVTy = dyn_cast<VectorType>(IndxTy))\n        IndxTy = IndexVTy->getElementType();\n      if ((IndxTy->getPrimitiveSizeInBits() == 64 &&\n          !isa<SExtInst>(GEP->getOperand(i))) ||\n         ++NumOfVarIndices > 1)\n        return IndexSize; // 64\n    }\n    return (unsigned)32;\n  };\n\n  // Trying to reduce IndexSize to 32 bits for vector 16.\n  // By default the IndexSize is equal to pointer size.\n  unsigned IndexSize = (ST->hasAVX512() && VF >= 16)\n                           ? getIndexSizeInBits(Ptr, DL)\n                           : DL.getPointerSizeInBits();\n\n  auto *IndexVTy = FixedVectorType::get(\n      IntegerType::get(SrcVTy->getContext(), IndexSize), VF);\n  std::pair<int, MVT> IdxsLT = TLI->getTypeLegalizationCost(DL, IndexVTy);\n  std::pair<int, MVT> SrcLT = TLI->getTypeLegalizationCost(DL, SrcVTy);\n  int SplitFactor = std::max(IdxsLT.first, SrcLT.first);\n  if (SplitFactor > 1) {\n    // Handle splitting of vector of pointers\n    auto *SplitSrcTy =\n        FixedVectorType::get(SrcVTy->getScalarType(), VF / SplitFactor);\n    return SplitFactor * getGSVectorCost(Opcode, SplitSrcTy, Ptr, Alignment,\n                                         AddressSpace);\n  }\n\n  // The gather / scatter cost is given by Intel architects. It is a rough\n  // number since we are looking at one instruction in a time.\n  const int GSOverhead = (Opcode == Instruction::Load)\n                             ? getGatherOverhead()\n                             : getScatterOverhead();\n  return GSOverhead + VF * getMemoryOpCost(Opcode, SrcVTy->getScalarType(),\n                                           MaybeAlign(Alignment), AddressSpace,\n                                           TTI::TCK_RecipThroughput);\n}\n\n/// Return the cost of full scalarization of gather / scatter operation.\n///\n/// Opcode - Load or Store instruction.\n/// SrcVTy - The type of the data vector that should be gathered or scattered.\n/// VariableMask - The mask is non-constant at compile time.\n/// Alignment - Alignment for one element.\n/// AddressSpace - pointer[s] address space.\n///\n/// FIXME: Add TargetCostKind support.\nint X86TTIImpl::getGSScalarCost(unsigned Opcode, Type *SrcVTy,\n                                bool VariableMask, Align Alignment,\n                                unsigned AddressSpace) {\n  unsigned VF = cast<FixedVectorType>(SrcVTy)->getNumElements();\n  APInt DemandedElts = APInt::getAllOnesValue(VF);\n  TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput;\n\n  int MaskUnpackCost = 0;\n  if (VariableMask) {\n    auto *MaskTy =\n        FixedVectorType::get(Type::getInt1Ty(SrcVTy->getContext()), VF);\n    MaskUnpackCost =\n        getScalarizationOverhead(MaskTy, DemandedElts, false, true);\n    int ScalarCompareCost = getCmpSelInstrCost(\n        Instruction::ICmp, Type::getInt1Ty(SrcVTy->getContext()), nullptr,\n        CmpInst::BAD_ICMP_PREDICATE, CostKind);\n    int BranchCost = getCFInstrCost(Instruction::Br, CostKind);\n    MaskUnpackCost += VF * (BranchCost + ScalarCompareCost);\n  }\n\n  // The cost of the scalar loads/stores.\n  int MemoryOpCost = VF * getMemoryOpCost(Opcode, SrcVTy->getScalarType(),\n                                          MaybeAlign(Alignment), AddressSpace,\n                                          CostKind);\n\n  int InsertExtractCost = 0;\n  if (Opcode == Instruction::Load)\n    for (unsigned i = 0; i < VF; ++i)\n      // Add the cost of inserting each scalar load into the vector\n      InsertExtractCost +=\n        getVectorInstrCost(Instruction::InsertElement, SrcVTy, i);\n  else\n    for (unsigned i = 0; i < VF; ++i)\n      // Add the cost of extracting each element out of the data vector\n      InsertExtractCost +=\n        getVectorInstrCost(Instruction::ExtractElement, SrcVTy, i);\n\n  return MemoryOpCost + MaskUnpackCost + InsertExtractCost;\n}\n\n/// Calculate the cost of Gather / Scatter operation\nint X86TTIImpl::getGatherScatterOpCost(unsigned Opcode, Type *SrcVTy,\n                                       const Value *Ptr, bool VariableMask,\n                                       Align Alignment,\n                                       TTI::TargetCostKind CostKind,\n                                       const Instruction *I = nullptr) {\n  if (CostKind != TTI::TCK_RecipThroughput) {\n    if ((Opcode == Instruction::Load &&\n         isLegalMaskedGather(SrcVTy, Align(Alignment))) ||\n        (Opcode == Instruction::Store &&\n         isLegalMaskedScatter(SrcVTy, Align(Alignment))))\n      return 1;\n    return BaseT::getGatherScatterOpCost(Opcode, SrcVTy, Ptr, VariableMask,\n                                         Alignment, CostKind, I);\n  }\n\n  assert(SrcVTy->isVectorTy() && \"Unexpected data type for Gather/Scatter\");\n  unsigned VF = cast<FixedVectorType>(SrcVTy)->getNumElements();\n  PointerType *PtrTy = dyn_cast<PointerType>(Ptr->getType());\n  if (!PtrTy && Ptr->getType()->isVectorTy())\n    PtrTy = dyn_cast<PointerType>(\n        cast<VectorType>(Ptr->getType())->getElementType());\n  assert(PtrTy && \"Unexpected type for Ptr argument\");\n  unsigned AddressSpace = PtrTy->getAddressSpace();\n\n  bool Scalarize = false;\n  if ((Opcode == Instruction::Load &&\n       !isLegalMaskedGather(SrcVTy, Align(Alignment))) ||\n      (Opcode == Instruction::Store &&\n       !isLegalMaskedScatter(SrcVTy, Align(Alignment))))\n    Scalarize = true;\n  // Gather / Scatter for vector 2 is not profitable on KNL / SKX\n  // Vector-4 of gather/scatter instruction does not exist on KNL.\n  // We can extend it to 8 elements, but zeroing upper bits of\n  // the mask vector will add more instructions. Right now we give the scalar\n  // cost of vector-4 for KNL. TODO: Check, maybe the gather/scatter instruction\n  // is better in the VariableMask case.\n  if (ST->hasAVX512() && (VF == 2 || (VF == 4 && !ST->hasVLX())))\n    Scalarize = true;\n\n  if (Scalarize)\n    return getGSScalarCost(Opcode, SrcVTy, VariableMask, Alignment,\n                           AddressSpace);\n\n  return getGSVectorCost(Opcode, SrcVTy, Ptr, Alignment, AddressSpace);\n}\n\nbool X86TTIImpl::isLSRCostLess(TargetTransformInfo::LSRCost &C1,\n                               TargetTransformInfo::LSRCost &C2) {\n    // X86 specific here are \"instruction number 1st priority\".\n    return std::tie(C1.Insns, C1.NumRegs, C1.AddRecCost,\n                    C1.NumIVMuls, C1.NumBaseAdds,\n                    C1.ScaleCost, C1.ImmCost, C1.SetupCost) <\n           std::tie(C2.Insns, C2.NumRegs, C2.AddRecCost,\n                    C2.NumIVMuls, C2.NumBaseAdds,\n                    C2.ScaleCost, C2.ImmCost, C2.SetupCost);\n}\n\nbool X86TTIImpl::canMacroFuseCmp() {\n  return ST->hasMacroFusion() || ST->hasBranchFusion();\n}\n\nbool X86TTIImpl::isLegalMaskedLoad(Type *DataTy, Align Alignment) {\n  if (!ST->hasAVX())\n    return false;\n\n  // The backend can't handle a single element vector.\n  if (isa<VectorType>(DataTy) &&\n      cast<FixedVectorType>(DataTy)->getNumElements() == 1)\n    return false;\n  Type *ScalarTy = DataTy->getScalarType();\n\n  if (ScalarTy->isPointerTy())\n    return true;\n\n  if (ScalarTy->isFloatTy() || ScalarTy->isDoubleTy())\n    return true;\n\n  if (!ScalarTy->isIntegerTy())\n    return false;\n\n  unsigned IntWidth = ScalarTy->getIntegerBitWidth();\n  return IntWidth == 32 || IntWidth == 64 ||\n         ((IntWidth == 8 || IntWidth == 16) && ST->hasBWI());\n}\n\nbool X86TTIImpl::isLegalMaskedStore(Type *DataType, Align Alignment) {\n  return isLegalMaskedLoad(DataType, Alignment);\n}\n\nbool X86TTIImpl::isLegalNTLoad(Type *DataType, Align Alignment) {\n  unsigned DataSize = DL.getTypeStoreSize(DataType);\n  // The only supported nontemporal loads are for aligned vectors of 16 or 32\n  // bytes.  Note that 32-byte nontemporal vector loads are supported by AVX2\n  // (the equivalent stores only require AVX).\n  if (Alignment >= DataSize && (DataSize == 16 || DataSize == 32))\n    return DataSize == 16 ?  ST->hasSSE1() : ST->hasAVX2();\n\n  return false;\n}\n\nbool X86TTIImpl::isLegalNTStore(Type *DataType, Align Alignment) {\n  unsigned DataSize = DL.getTypeStoreSize(DataType);\n\n  // SSE4A supports nontemporal stores of float and double at arbitrary\n  // alignment.\n  if (ST->hasSSE4A() && (DataType->isFloatTy() || DataType->isDoubleTy()))\n    return true;\n\n  // Besides the SSE4A subtarget exception above, only aligned stores are\n  // available nontemporaly on any other subtarget.  And only stores with a size\n  // of 4..32 bytes (powers of 2, only) are permitted.\n  if (Alignment < DataSize || DataSize < 4 || DataSize > 32 ||\n      !isPowerOf2_32(DataSize))\n    return false;\n\n  // 32-byte vector nontemporal stores are supported by AVX (the equivalent\n  // loads require AVX2).\n  if (DataSize == 32)\n    return ST->hasAVX();\n  else if (DataSize == 16)\n    return ST->hasSSE1();\n  return true;\n}\n\nbool X86TTIImpl::isLegalMaskedExpandLoad(Type *DataTy) {\n  if (!isa<VectorType>(DataTy))\n    return false;\n\n  if (!ST->hasAVX512())\n    return false;\n\n  // The backend can't handle a single element vector.\n  if (cast<FixedVectorType>(DataTy)->getNumElements() == 1)\n    return false;\n\n  Type *ScalarTy = cast<VectorType>(DataTy)->getElementType();\n\n  if (ScalarTy->isFloatTy() || ScalarTy->isDoubleTy())\n    return true;\n\n  if (!ScalarTy->isIntegerTy())\n    return false;\n\n  unsigned IntWidth = ScalarTy->getIntegerBitWidth();\n  return IntWidth == 32 || IntWidth == 64 ||\n         ((IntWidth == 8 || IntWidth == 16) && ST->hasVBMI2());\n}\n\nbool X86TTIImpl::isLegalMaskedCompressStore(Type *DataTy) {\n  return isLegalMaskedExpandLoad(DataTy);\n}\n\nbool X86TTIImpl::isLegalMaskedGather(Type *DataTy, Align Alignment) {\n  // Some CPUs have better gather performance than others.\n  // TODO: Remove the explicit ST->hasAVX512()?, That would mean we would only\n  // enable gather with a -march.\n  if (!(ST->hasAVX512() || (ST->hasFastGather() && ST->hasAVX2())))\n    return false;\n\n  // This function is called now in two cases: from the Loop Vectorizer\n  // and from the Scalarizer.\n  // When the Loop Vectorizer asks about legality of the feature,\n  // the vectorization factor is not calculated yet. The Loop Vectorizer\n  // sends a scalar type and the decision is based on the width of the\n  // scalar element.\n  // Later on, the cost model will estimate usage this intrinsic based on\n  // the vector type.\n  // The Scalarizer asks again about legality. It sends a vector type.\n  // In this case we can reject non-power-of-2 vectors.\n  // We also reject single element vectors as the type legalizer can't\n  // scalarize it.\n  if (auto *DataVTy = dyn_cast<FixedVectorType>(DataTy)) {\n    unsigned NumElts = DataVTy->getNumElements();\n    if (NumElts == 1)\n      return false;\n  }\n  Type *ScalarTy = DataTy->getScalarType();\n  if (ScalarTy->isPointerTy())\n    return true;\n\n  if (ScalarTy->isFloatTy() || ScalarTy->isDoubleTy())\n    return true;\n\n  if (!ScalarTy->isIntegerTy())\n    return false;\n\n  unsigned IntWidth = ScalarTy->getIntegerBitWidth();\n  return IntWidth == 32 || IntWidth == 64;\n}\n\nbool X86TTIImpl::isLegalMaskedScatter(Type *DataType, Align Alignment) {\n  // AVX2 doesn't support scatter\n  if (!ST->hasAVX512())\n    return false;\n  return isLegalMaskedGather(DataType, Alignment);\n}\n\nbool X86TTIImpl::hasDivRemOp(Type *DataType, bool IsSigned) {\n  EVT VT = TLI->getValueType(DL, DataType);\n  return TLI->isOperationLegal(IsSigned ? ISD::SDIVREM : ISD::UDIVREM, VT);\n}\n\nbool X86TTIImpl::isFCmpOrdCheaperThanFCmpZero(Type *Ty) {\n  return false;\n}\n\nbool X86TTIImpl::areInlineCompatible(const Function *Caller,\n                                     const Function *Callee) const {\n  const TargetMachine &TM = getTLI()->getTargetMachine();\n\n  // Work this as a subsetting of subtarget features.\n  const FeatureBitset &CallerBits =\n      TM.getSubtargetImpl(*Caller)->getFeatureBits();\n  const FeatureBitset &CalleeBits =\n      TM.getSubtargetImpl(*Callee)->getFeatureBits();\n\n  FeatureBitset RealCallerBits = CallerBits & ~InlineFeatureIgnoreList;\n  FeatureBitset RealCalleeBits = CalleeBits & ~InlineFeatureIgnoreList;\n  return (RealCallerBits & RealCalleeBits) == RealCalleeBits;\n}\n\nbool X86TTIImpl::areFunctionArgsABICompatible(\n    const Function *Caller, const Function *Callee,\n    SmallPtrSetImpl<Argument *> &Args) const {\n  if (!BaseT::areFunctionArgsABICompatible(Caller, Callee, Args))\n    return false;\n\n  // If we get here, we know the target features match. If one function\n  // considers 512-bit vectors legal and the other does not, consider them\n  // incompatible.\n  const TargetMachine &TM = getTLI()->getTargetMachine();\n\n  if (TM.getSubtarget<X86Subtarget>(*Caller).useAVX512Regs() ==\n      TM.getSubtarget<X86Subtarget>(*Callee).useAVX512Regs())\n    return true;\n\n  // Consider the arguments compatible if they aren't vectors or aggregates.\n  // FIXME: Look at the size of vectors.\n  // FIXME: Look at the element types of aggregates to see if there are vectors.\n  // FIXME: The API of this function seems intended to allow arguments\n  // to be removed from the set, but the caller doesn't check if the set\n  // becomes empty so that may not work in practice.\n  return llvm::none_of(Args, [](Argument *A) {\n    auto *EltTy = cast<PointerType>(A->getType())->getElementType();\n    return EltTy->isVectorTy() || EltTy->isAggregateType();\n  });\n}\n\nX86TTIImpl::TTI::MemCmpExpansionOptions\nX86TTIImpl::enableMemCmpExpansion(bool OptSize, bool IsZeroCmp) const {\n  TTI::MemCmpExpansionOptions Options;\n  Options.MaxNumLoads = TLI->getMaxExpandSizeMemcmp(OptSize);\n  Options.NumLoadsPerBlock = 2;\n  // All GPR and vector loads can be unaligned.\n  Options.AllowOverlappingLoads = true;\n  if (IsZeroCmp) {\n    // Only enable vector loads for equality comparison. Right now the vector\n    // version is not as fast for three way compare (see #33329).\n    const unsigned PreferredWidth = ST->getPreferVectorWidth();\n    if (PreferredWidth >= 512 && ST->hasAVX512()) Options.LoadSizes.push_back(64);\n    if (PreferredWidth >= 256 && ST->hasAVX()) Options.LoadSizes.push_back(32);\n    if (PreferredWidth >= 128 && ST->hasSSE2()) Options.LoadSizes.push_back(16);\n  }\n  if (ST->is64Bit()) {\n    Options.LoadSizes.push_back(8);\n  }\n  Options.LoadSizes.push_back(4);\n  Options.LoadSizes.push_back(2);\n  Options.LoadSizes.push_back(1);\n  return Options;\n}\n\nbool X86TTIImpl::enableInterleavedAccessVectorization() {\n  // TODO: We expect this to be beneficial regardless of arch,\n  // but there are currently some unexplained performance artifacts on Atom.\n  // As a temporary solution, disable on Atom.\n  return !(ST->isAtom());\n}\n\n// Get estimation for interleaved load/store operations for AVX2.\n// \\p Factor is the interleaved-access factor (stride) - number of\n// (interleaved) elements in the group.\n// \\p Indices contains the indices for a strided load: when the\n// interleaved load has gaps they indicate which elements are used.\n// If Indices is empty (or if the number of indices is equal to the size\n// of the interleaved-access as given in \\p Factor) the access has no gaps.\n//\n// As opposed to AVX-512, AVX2 does not have generic shuffles that allow\n// computing the cost using a generic formula as a function of generic\n// shuffles. We therefore use a lookup table instead, filled according to\n// the instruction sequences that codegen currently generates.\nint X86TTIImpl::getInterleavedMemoryOpCostAVX2(\n    unsigned Opcode, FixedVectorType *VecTy, unsigned Factor,\n    ArrayRef<unsigned> Indices, Align Alignment, unsigned AddressSpace,\n    TTI::TargetCostKind CostKind, bool UseMaskForCond, bool UseMaskForGaps) {\n\n  if (UseMaskForCond || UseMaskForGaps)\n    return BaseT::getInterleavedMemoryOpCost(Opcode, VecTy, Factor, Indices,\n                                             Alignment, AddressSpace, CostKind,\n                                             UseMaskForCond, UseMaskForGaps);\n\n  // We currently Support only fully-interleaved groups, with no gaps.\n  // TODO: Support also strided loads (interleaved-groups with gaps).\n  if (Indices.size() && Indices.size() != Factor)\n    return BaseT::getInterleavedMemoryOpCost(Opcode, VecTy, Factor, Indices,\n                                             Alignment, AddressSpace,\n                                             CostKind);\n\n  // VecTy for interleave memop is <VF*Factor x Elt>.\n  // So, for VF=4, Interleave Factor = 3, Element type = i32 we have\n  // VecTy = <12 x i32>.\n  MVT LegalVT = getTLI()->getTypeLegalizationCost(DL, VecTy).second;\n\n  // This function can be called with VecTy=<6xi128>, Factor=3, in which case\n  // the VF=2, while v2i128 is an unsupported MVT vector type\n  // (see MachineValueType.h::getVectorVT()).\n  if (!LegalVT.isVector())\n    return BaseT::getInterleavedMemoryOpCost(Opcode, VecTy, Factor, Indices,\n                                             Alignment, AddressSpace,\n                                             CostKind);\n\n  unsigned VF = VecTy->getNumElements() / Factor;\n  Type *ScalarTy = VecTy->getElementType();\n\n  // Calculate the number of memory operations (NumOfMemOps), required\n  // for load/store the VecTy.\n  unsigned VecTySize = DL.getTypeStoreSize(VecTy);\n  unsigned LegalVTSize = LegalVT.getStoreSize();\n  unsigned NumOfMemOps = (VecTySize + LegalVTSize - 1) / LegalVTSize;\n\n  // Get the cost of one memory operation.\n  auto *SingleMemOpTy = FixedVectorType::get(VecTy->getElementType(),\n                                             LegalVT.getVectorNumElements());\n  unsigned MemOpCost = getMemoryOpCost(Opcode, SingleMemOpTy,\n                                       MaybeAlign(Alignment), AddressSpace,\n                                       CostKind);\n\n  auto *VT = FixedVectorType::get(ScalarTy, VF);\n  EVT ETy = TLI->getValueType(DL, VT);\n  if (!ETy.isSimple())\n    return BaseT::getInterleavedMemoryOpCost(Opcode, VecTy, Factor, Indices,\n                                             Alignment, AddressSpace,\n                                             CostKind);\n\n  // TODO: Complete for other data-types and strides.\n  // Each combination of Stride, ElementTy and VF results in a different\n  // sequence; The cost tables are therefore accessed with:\n  // Factor (stride) and VectorType=VFxElemType.\n  // The Cost accounts only for the shuffle sequence;\n  // The cost of the loads/stores is accounted for separately.\n  //\n  static const CostTblEntry AVX2InterleavedLoadTbl[] = {\n    { 2, MVT::v4i64, 6 }, //(load 8i64 and) deinterleave into 2 x 4i64\n    { 2, MVT::v4f64, 6 }, //(load 8f64 and) deinterleave into 2 x 4f64\n\n    { 3, MVT::v2i8,  10 }, //(load 6i8 and)  deinterleave into 3 x 2i8\n    { 3, MVT::v4i8,  4 },  //(load 12i8 and) deinterleave into 3 x 4i8\n    { 3, MVT::v8i8,  9 },  //(load 24i8 and) deinterleave into 3 x 8i8\n    { 3, MVT::v16i8, 11},  //(load 48i8 and) deinterleave into 3 x 16i8\n    { 3, MVT::v32i8, 13},  //(load 96i8 and) deinterleave into 3 x 32i8\n    { 3, MVT::v8f32, 17 }, //(load 24f32 and)deinterleave into 3 x 8f32\n\n    { 4, MVT::v2i8,  12 }, //(load 8i8 and)   deinterleave into 4 x 2i8\n    { 4, MVT::v4i8,  4 },  //(load 16i8 and)  deinterleave into 4 x 4i8\n    { 4, MVT::v8i8,  20 }, //(load 32i8 and)  deinterleave into 4 x 8i8\n    { 4, MVT::v16i8, 39 }, //(load 64i8 and)  deinterleave into 4 x 16i8\n    { 4, MVT::v32i8, 80 }, //(load 128i8 and) deinterleave into 4 x 32i8\n\n    { 8, MVT::v8f32, 40 }  //(load 64f32 and)deinterleave into 8 x 8f32\n  };\n\n  static const CostTblEntry AVX2InterleavedStoreTbl[] = {\n    { 2, MVT::v4i64, 6 }, //interleave into 2 x 4i64 into 8i64 (and store)\n    { 2, MVT::v4f64, 6 }, //interleave into 2 x 4f64 into 8f64 (and store)\n\n    { 3, MVT::v2i8,  7 },  //interleave 3 x 2i8  into 6i8 (and store)\n    { 3, MVT::v4i8,  8 },  //interleave 3 x 4i8  into 12i8 (and store)\n    { 3, MVT::v8i8,  11 }, //interleave 3 x 8i8  into 24i8 (and store)\n    { 3, MVT::v16i8, 11 }, //interleave 3 x 16i8 into 48i8 (and store)\n    { 3, MVT::v32i8, 13 }, //interleave 3 x 32i8 into 96i8 (and store)\n\n    { 4, MVT::v2i8,  12 }, //interleave 4 x 2i8  into 8i8 (and store)\n    { 4, MVT::v4i8,  9 },  //interleave 4 x 4i8  into 16i8 (and store)\n    { 4, MVT::v8i8,  10 }, //interleave 4 x 8i8  into 32i8 (and store)\n    { 4, MVT::v16i8, 10 }, //interleave 4 x 16i8 into 64i8 (and store)\n    { 4, MVT::v32i8, 12 }  //interleave 4 x 32i8 into 128i8 (and store)\n  };\n\n  if (Opcode == Instruction::Load) {\n    if (const auto *Entry =\n            CostTableLookup(AVX2InterleavedLoadTbl, Factor, ETy.getSimpleVT()))\n      return NumOfMemOps * MemOpCost + Entry->Cost;\n  } else {\n    assert(Opcode == Instruction::Store &&\n           \"Expected Store Instruction at this  point\");\n    if (const auto *Entry =\n            CostTableLookup(AVX2InterleavedStoreTbl, Factor, ETy.getSimpleVT()))\n      return NumOfMemOps * MemOpCost + Entry->Cost;\n  }\n\n  return BaseT::getInterleavedMemoryOpCost(Opcode, VecTy, Factor, Indices,\n                                           Alignment, AddressSpace, CostKind);\n}\n\n// Get estimation for interleaved load/store operations and strided load.\n// \\p Indices contains indices for strided load.\n// \\p Factor - the factor of interleaving.\n// AVX-512 provides 3-src shuffles that significantly reduces the cost.\nint X86TTIImpl::getInterleavedMemoryOpCostAVX512(\n    unsigned Opcode, FixedVectorType *VecTy, unsigned Factor,\n    ArrayRef<unsigned> Indices, Align Alignment, unsigned AddressSpace,\n    TTI::TargetCostKind CostKind, bool UseMaskForCond, bool UseMaskForGaps) {\n\n  if (UseMaskForCond || UseMaskForGaps)\n    return BaseT::getInterleavedMemoryOpCost(Opcode, VecTy, Factor, Indices,\n                                             Alignment, AddressSpace, CostKind,\n                                             UseMaskForCond, UseMaskForGaps);\n\n  // VecTy for interleave memop is <VF*Factor x Elt>.\n  // So, for VF=4, Interleave Factor = 3, Element type = i32 we have\n  // VecTy = <12 x i32>.\n\n  // Calculate the number of memory operations (NumOfMemOps), required\n  // for load/store the VecTy.\n  MVT LegalVT = getTLI()->getTypeLegalizationCost(DL, VecTy).second;\n  unsigned VecTySize = DL.getTypeStoreSize(VecTy);\n  unsigned LegalVTSize = LegalVT.getStoreSize();\n  unsigned NumOfMemOps = (VecTySize + LegalVTSize - 1) / LegalVTSize;\n\n  // Get the cost of one memory operation.\n  auto *SingleMemOpTy = FixedVectorType::get(VecTy->getElementType(),\n                                             LegalVT.getVectorNumElements());\n  unsigned MemOpCost = getMemoryOpCost(Opcode, SingleMemOpTy,\n                                       MaybeAlign(Alignment), AddressSpace,\n                                       CostKind);\n\n  unsigned VF = VecTy->getNumElements() / Factor;\n  MVT VT = MVT::getVectorVT(MVT::getVT(VecTy->getScalarType()), VF);\n\n  if (Opcode == Instruction::Load) {\n    // The tables (AVX512InterleavedLoadTbl and AVX512InterleavedStoreTbl)\n    // contain the cost of the optimized shuffle sequence that the\n    // X86InterleavedAccess pass will generate.\n    // The cost of loads and stores are computed separately from the table.\n\n    // X86InterleavedAccess support only the following interleaved-access group.\n    static const CostTblEntry AVX512InterleavedLoadTbl[] = {\n        {3, MVT::v16i8, 12}, //(load 48i8 and) deinterleave into 3 x 16i8\n        {3, MVT::v32i8, 14}, //(load 96i8 and) deinterleave into 3 x 32i8\n        {3, MVT::v64i8, 22}, //(load 96i8 and) deinterleave into 3 x 32i8\n    };\n\n    if (const auto *Entry =\n            CostTableLookup(AVX512InterleavedLoadTbl, Factor, VT))\n      return NumOfMemOps * MemOpCost + Entry->Cost;\n    //If an entry does not exist, fallback to the default implementation.\n\n    // Kind of shuffle depends on number of loaded values.\n    // If we load the entire data in one register, we can use a 1-src shuffle.\n    // Otherwise, we'll merge 2 sources in each operation.\n    TTI::ShuffleKind ShuffleKind =\n        (NumOfMemOps > 1) ? TTI::SK_PermuteTwoSrc : TTI::SK_PermuteSingleSrc;\n\n    unsigned ShuffleCost =\n        getShuffleCost(ShuffleKind, SingleMemOpTy, 0, nullptr);\n\n    unsigned NumOfLoadsInInterleaveGrp =\n        Indices.size() ? Indices.size() : Factor;\n    auto *ResultTy = FixedVectorType::get(VecTy->getElementType(),\n                                          VecTy->getNumElements() / Factor);\n    unsigned NumOfResults =\n        getTLI()->getTypeLegalizationCost(DL, ResultTy).first *\n        NumOfLoadsInInterleaveGrp;\n\n    // About a half of the loads may be folded in shuffles when we have only\n    // one result. If we have more than one result, we do not fold loads at all.\n    unsigned NumOfUnfoldedLoads =\n        NumOfResults > 1 ? NumOfMemOps : NumOfMemOps / 2;\n\n    // Get a number of shuffle operations per result.\n    unsigned NumOfShufflesPerResult =\n        std::max((unsigned)1, (unsigned)(NumOfMemOps - 1));\n\n    // The SK_MergeTwoSrc shuffle clobbers one of src operands.\n    // When we have more than one destination, we need additional instructions\n    // to keep sources.\n    unsigned NumOfMoves = 0;\n    if (NumOfResults > 1 && ShuffleKind == TTI::SK_PermuteTwoSrc)\n      NumOfMoves = NumOfResults * NumOfShufflesPerResult / 2;\n\n    int Cost = NumOfResults * NumOfShufflesPerResult * ShuffleCost +\n               NumOfUnfoldedLoads * MemOpCost + NumOfMoves;\n\n    return Cost;\n  }\n\n  // Store.\n  assert(Opcode == Instruction::Store &&\n         \"Expected Store Instruction at this  point\");\n  // X86InterleavedAccess support only the following interleaved-access group.\n  static const CostTblEntry AVX512InterleavedStoreTbl[] = {\n      {3, MVT::v16i8, 12}, // interleave 3 x 16i8 into 48i8 (and store)\n      {3, MVT::v32i8, 14}, // interleave 3 x 32i8 into 96i8 (and store)\n      {3, MVT::v64i8, 26}, // interleave 3 x 64i8 into 96i8 (and store)\n\n      {4, MVT::v8i8, 10},  // interleave 4 x 8i8  into 32i8  (and store)\n      {4, MVT::v16i8, 11}, // interleave 4 x 16i8 into 64i8  (and store)\n      {4, MVT::v32i8, 14}, // interleave 4 x 32i8 into 128i8 (and store)\n      {4, MVT::v64i8, 24}  // interleave 4 x 32i8 into 256i8 (and store)\n  };\n\n  if (const auto *Entry =\n          CostTableLookup(AVX512InterleavedStoreTbl, Factor, VT))\n    return NumOfMemOps * MemOpCost + Entry->Cost;\n  //If an entry does not exist, fallback to the default implementation.\n\n  // There is no strided stores meanwhile. And store can't be folded in\n  // shuffle.\n  unsigned NumOfSources = Factor; // The number of values to be merged.\n  unsigned ShuffleCost =\n      getShuffleCost(TTI::SK_PermuteTwoSrc, SingleMemOpTy, 0, nullptr);\n  unsigned NumOfShufflesPerStore = NumOfSources - 1;\n\n  // The SK_MergeTwoSrc shuffle clobbers one of src operands.\n  // We need additional instructions to keep sources.\n  unsigned NumOfMoves = NumOfMemOps * NumOfShufflesPerStore / 2;\n  int Cost = NumOfMemOps * (MemOpCost + NumOfShufflesPerStore * ShuffleCost) +\n             NumOfMoves;\n  return Cost;\n}\n\nint X86TTIImpl::getInterleavedMemoryOpCost(\n    unsigned Opcode, Type *VecTy, unsigned Factor, ArrayRef<unsigned> Indices,\n    Align Alignment, unsigned AddressSpace, TTI::TargetCostKind CostKind,\n    bool UseMaskForCond, bool UseMaskForGaps) {\n  auto isSupportedOnAVX512 = [](Type *VecTy, bool HasBW) {\n    Type *EltTy = cast<VectorType>(VecTy)->getElementType();\n    if (EltTy->isFloatTy() || EltTy->isDoubleTy() || EltTy->isIntegerTy(64) ||\n        EltTy->isIntegerTy(32) || EltTy->isPointerTy())\n      return true;\n    if (EltTy->isIntegerTy(16) || EltTy->isIntegerTy(8))\n      return HasBW;\n    return false;\n  };\n  if (ST->hasAVX512() && isSupportedOnAVX512(VecTy, ST->hasBWI()))\n    return getInterleavedMemoryOpCostAVX512(\n        Opcode, cast<FixedVectorType>(VecTy), Factor, Indices, Alignment,\n        AddressSpace, CostKind, UseMaskForCond, UseMaskForGaps);\n  if (ST->hasAVX2())\n    return getInterleavedMemoryOpCostAVX2(\n        Opcode, cast<FixedVectorType>(VecTy), Factor, Indices, Alignment,\n        AddressSpace, CostKind, UseMaskForCond, UseMaskForGaps);\n\n  return BaseT::getInterleavedMemoryOpCost(Opcode, VecTy, Factor, Indices,\n                                           Alignment, AddressSpace, CostKind,\n                                           UseMaskForCond, UseMaskForGaps);\n}\n"}, "3": {"id": 3, "path": "/home/vsts/work/1/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.h", "content": "//===-- X86TargetTransformInfo.h - X86 specific TTI -------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n/// \\file\n/// This file a TargetTransformInfo::Concept conforming object specific to the\n/// X86 target machine. It uses the target's detailed information to\n/// provide more precise answers to certain TTI queries, while letting the\n/// target independent and default TTI implementations handle the rest.\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_LIB_TARGET_X86_X86TARGETTRANSFORMINFO_H\n#define LLVM_LIB_TARGET_X86_X86TARGETTRANSFORMINFO_H\n\n#include \"X86TargetMachine.h\"\n#include \"llvm/Analysis/TargetTransformInfo.h\"\n#include \"llvm/CodeGen/BasicTTIImpl.h\"\n\nnamespace llvm {\n\nclass InstCombiner;\n\nclass X86TTIImpl : public BasicTTIImplBase<X86TTIImpl> {\n  typedef BasicTTIImplBase<X86TTIImpl> BaseT;\n  typedef TargetTransformInfo TTI;\n  friend BaseT;\n\n  const X86Subtarget *ST;\n  const X86TargetLowering *TLI;\n\n  const X86Subtarget *getST() const { return ST; }\n  const X86TargetLowering *getTLI() const { return TLI; }\n\n  const FeatureBitset InlineFeatureIgnoreList = {\n      // This indicates the CPU is 64 bit capable not that we are in 64-bit\n      // mode.\n      X86::Feature64Bit,\n\n      // These features don't have any intrinsics or ABI effect.\n      X86::FeatureNOPL,\n      X86::FeatureCMPXCHG16B,\n      X86::FeatureLAHFSAHF,\n\n      // Codegen control options.\n      X86::FeatureFast11ByteNOP,\n      X86::FeatureFast15ByteNOP,\n      X86::FeatureFastBEXTR,\n      X86::FeatureFastHorizontalOps,\n      X86::FeatureFastLZCNT,\n      X86::FeatureFastScalarFSQRT,\n      X86::FeatureFastSHLDRotate,\n      X86::FeatureFastScalarShiftMasks,\n      X86::FeatureFastVectorShiftMasks,\n      X86::FeatureFastVariableShuffle,\n      X86::FeatureFastVectorFSQRT,\n      X86::FeatureLEAForSP,\n      X86::FeatureLEAUsesAG,\n      X86::FeatureLZCNTFalseDeps,\n      X86::FeatureBranchFusion,\n      X86::FeatureMacroFusion,\n      X86::FeaturePadShortFunctions,\n      X86::FeaturePOPCNTFalseDeps,\n      X86::FeatureSSEUnalignedMem,\n      X86::FeatureSlow3OpsLEA,\n      X86::FeatureSlowDivide32,\n      X86::FeatureSlowDivide64,\n      X86::FeatureSlowIncDec,\n      X86::FeatureSlowLEA,\n      X86::FeatureSlowPMADDWD,\n      X86::FeatureSlowPMULLD,\n      X86::FeatureSlowSHLD,\n      X86::FeatureSlowTwoMemOps,\n      X86::FeatureSlowUAMem16,\n      X86::FeaturePreferMaskRegisters,\n      X86::FeatureInsertVZEROUPPER,\n      X86::FeatureUseGLMDivSqrtCosts,\n\n      // Perf-tuning flags.\n      X86::FeatureHasFastGather,\n      X86::FeatureSlowUAMem32,\n\n      // Based on whether user set the -mprefer-vector-width command line.\n      X86::FeaturePrefer128Bit,\n      X86::FeaturePrefer256Bit,\n\n      // CPU name enums. These just follow CPU string.\n      X86::ProcIntelAtom,\n      X86::ProcIntelSLM,\n  };\n\npublic:\n  explicit X86TTIImpl(const X86TargetMachine *TM, const Function &F)\n      : BaseT(TM, F.getParent()->getDataLayout()), ST(TM->getSubtargetImpl(F)),\n        TLI(ST->getTargetLowering()) {}\n\n  /// \\name Scalar TTI Implementations\n  /// @{\n  TTI::PopcntSupportKind getPopcntSupport(unsigned TyWidth);\n\n  /// @}\n\n  /// \\name Cache TTI Implementation\n  /// @{\n  llvm::Optional<unsigned> getCacheSize(\n    TargetTransformInfo::CacheLevel Level) const override;\n  llvm::Optional<unsigned> getCacheAssociativity(\n    TargetTransformInfo::CacheLevel Level) const override;\n  /// @}\n\n  /// \\name Vector TTI Implementations\n  /// @{\n\n  unsigned getNumberOfRegisters(unsigned ClassID) const;\n  unsigned getRegisterBitWidth(bool Vector) const;\n  unsigned getLoadStoreVecRegBitWidth(unsigned AS) const;\n  unsigned getMaxInterleaveFactor(unsigned VF);\n  int getArithmeticInstrCost(\n      unsigned Opcode, Type *Ty,\n      TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput,\n      TTI::OperandValueKind Opd1Info = TTI::OK_AnyValue,\n      TTI::OperandValueKind Opd2Info = TTI::OK_AnyValue,\n      TTI::OperandValueProperties Opd1PropInfo = TTI::OP_None,\n      TTI::OperandValueProperties Opd2PropInfo = TTI::OP_None,\n      ArrayRef<const Value *> Args = ArrayRef<const Value *>(),\n      const Instruction *CxtI = nullptr);\n  int getShuffleCost(TTI::ShuffleKind Kind, VectorType *Tp, int Index,\n                     VectorType *SubTp);\n  int getCastInstrCost(unsigned Opcode, Type *Dst, Type *Src,\n                       TTI::CastContextHint CCH, TTI::TargetCostKind CostKind,\n                       const Instruction *I = nullptr);\n  int getCmpSelInstrCost(unsigned Opcode, Type *ValTy, Type *CondTy,\n                         CmpInst::Predicate VecPred,\n                         TTI::TargetCostKind CostKind,\n                         const Instruction *I = nullptr);\n  int getVectorInstrCost(unsigned Opcode, Type *Val, unsigned Index);\n  unsigned getScalarizationOverhead(VectorType *Ty, const APInt &DemandedElts,\n                                    bool Insert, bool Extract);\n  int getMemoryOpCost(unsigned Opcode, Type *Src, MaybeAlign Alignment,\n                      unsigned AddressSpace,\n                      TTI::TargetCostKind CostKind,\n                      const Instruction *I = nullptr);\n  int getMaskedMemoryOpCost(\n      unsigned Opcode, Type *Src, Align Alignment, unsigned AddressSpace,\n      TTI::TargetCostKind CostKind = TTI::TCK_SizeAndLatency);\n  int getGatherScatterOpCost(unsigned Opcode, Type *DataTy, const Value *Ptr,\n                             bool VariableMask, Align Alignment,\n                             TTI::TargetCostKind CostKind,\n                             const Instruction *I);\n  int getAddressComputationCost(Type *PtrTy, ScalarEvolution *SE,\n                                const SCEV *Ptr);\n\n  Optional<Instruction *> instCombineIntrinsic(InstCombiner &IC,\n                                               IntrinsicInst &II) const;\n  Optional<Value *>\n  simplifyDemandedUseBitsIntrinsic(InstCombiner &IC, IntrinsicInst &II,\n                                   APInt DemandedMask, KnownBits &Known,\n                                   bool &KnownBitsComputed) const;\n  Optional<Value *> simplifyDemandedVectorEltsIntrinsic(\n      InstCombiner &IC, IntrinsicInst &II, APInt DemandedElts, APInt &UndefElts,\n      APInt &UndefElts2, APInt &UndefElts3,\n      std::function<void(Instruction *, unsigned, APInt, APInt &)>\n          SimplifyAndSetOp) const;\n\n  unsigned getAtomicMemIntrinsicMaxElementSize() const;\n\n  int getTypeBasedIntrinsicInstrCost(const IntrinsicCostAttributes &ICA,\n                                     TTI::TargetCostKind CostKind);\n  int getIntrinsicInstrCost(const IntrinsicCostAttributes &ICA,\n                            TTI::TargetCostKind CostKind);\n\n  int getArithmeticReductionCost(unsigned Opcode, VectorType *Ty,\n                                 bool IsPairwiseForm,\n                                 TTI::TargetCostKind CostKind = TTI::TCK_SizeAndLatency);\n\n  int getMinMaxCost(Type *Ty, Type *CondTy, bool IsUnsigned);\n\n  int getMinMaxReductionCost(VectorType *Ty, VectorType *CondTy,\n                             bool IsPairwiseForm, bool IsUnsigned,\n                             TTI::TargetCostKind CostKind);\n\n  int getInterleavedMemoryOpCost(\n      unsigned Opcode, Type *VecTy, unsigned Factor, ArrayRef<unsigned> Indices,\n      Align Alignment, unsigned AddressSpace,\n      TTI::TargetCostKind CostKind = TTI::TCK_SizeAndLatency,\n      bool UseMaskForCond = false, bool UseMaskForGaps = false);\n  int getInterleavedMemoryOpCostAVX512(\n      unsigned Opcode, FixedVectorType *VecTy, unsigned Factor,\n      ArrayRef<unsigned> Indices, Align Alignment, unsigned AddressSpace,\n      TTI::TargetCostKind CostKind = TTI::TCK_SizeAndLatency,\n      bool UseMaskForCond = false, bool UseMaskForGaps = false);\n  int getInterleavedMemoryOpCostAVX2(\n      unsigned Opcode, FixedVectorType *VecTy, unsigned Factor,\n      ArrayRef<unsigned> Indices, Align Alignment, unsigned AddressSpace,\n      TTI::TargetCostKind CostKind = TTI::TCK_SizeAndLatency,\n      bool UseMaskForCond = false, bool UseMaskForGaps = false);\n\n  int getIntImmCost(int64_t);\n\n  int getIntImmCost(const APInt &Imm, Type *Ty, TTI::TargetCostKind CostKind);\n\n  unsigned getCFInstrCost(unsigned Opcode, TTI::TargetCostKind CostKind);\n\n  int getIntImmCostInst(unsigned Opcode, unsigned Idx, const APInt &Imm,\n                        Type *Ty, TTI::TargetCostKind CostKind,\n                        Instruction *Inst = nullptr);\n  int getIntImmCostIntrin(Intrinsic::ID IID, unsigned Idx, const APInt &Imm,\n                          Type *Ty, TTI::TargetCostKind CostKind);\n  bool isLSRCostLess(TargetTransformInfo::LSRCost &C1,\n                     TargetTransformInfo::LSRCost &C2);\n  bool canMacroFuseCmp();\n  bool isLegalMaskedLoad(Type *DataType, Align Alignment);\n  bool isLegalMaskedStore(Type *DataType, Align Alignment);\n  bool isLegalNTLoad(Type *DataType, Align Alignment);\n  bool isLegalNTStore(Type *DataType, Align Alignment);\n  bool isLegalMaskedGather(Type *DataType, Align Alignment);\n  bool isLegalMaskedScatter(Type *DataType, Align Alignment);\n  bool isLegalMaskedExpandLoad(Type *DataType);\n  bool isLegalMaskedCompressStore(Type *DataType);\n  bool hasDivRemOp(Type *DataType, bool IsSigned);\n  bool isFCmpOrdCheaperThanFCmpZero(Type *Ty);\n  bool areInlineCompatible(const Function *Caller,\n                           const Function *Callee) const;\n  bool areFunctionArgsABICompatible(const Function *Caller,\n                                    const Function *Callee,\n                                    SmallPtrSetImpl<Argument *> &Args) const;\n  TTI::MemCmpExpansionOptions enableMemCmpExpansion(bool OptSize,\n                                                    bool IsZeroCmp) const;\n  bool enableInterleavedAccessVectorization();\n\n  /// Allow vectorizers to form reduction intrinsics in IR. The IR is expanded\n  /// into shuffles and vector math/logic by the backend\n  /// (see TTI::shouldExpandReduction)\n  bool useReductionIntrinsic(unsigned Opcode, Type *Ty,\n                             TTI::ReductionFlags Flags) const {\n    return true;\n  }\n\nprivate:\n  int getGSScalarCost(unsigned Opcode, Type *DataTy, bool VariableMask,\n                      Align Alignment, unsigned AddressSpace);\n  int getGSVectorCost(unsigned Opcode, Type *DataTy, const Value *Ptr,\n                      Align Alignment, unsigned AddressSpace);\n\n  int getGatherOverhead() const;\n  int getScatterOverhead() const;\n\n  /// @}\n};\n\n} // end namespace llvm\n\n#endif\n"}}, "reports": [{"events": [{"location": {"col": 17, "file": 4, "line": 172}, "message": "the definition seen here"}, {"location": {"col": 7, "file": 3, "line": 121}, "message": "differing parameters are named here: ('Opd1Info', 'Opd2Info'), in definition: ('Op1Info', 'Op2Info')"}, {"location": {"col": 7, "file": 3, "line": 121}, "message": "function 'llvm::X86TTIImpl::getArithmeticInstrCost' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.h", "reportHash": "d160396e1ff171313ba6289b2a11eeb5", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 17, "file": 4, "line": 4205}, "message": "the definition seen here"}, {"location": {"col": 7, "file": 3, "line": 149}, "message": "differing parameters are named here: ('DataTy'), in definition: ('SrcVTy')"}, {"location": {"col": 7, "file": 3, "line": 149}, "message": "function 'llvm::X86TTIImpl::getGatherScatterOpCost' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.h", "reportHash": "3d49ee70228fcbad12ee44adf6870870", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 17, "file": 4, "line": 4164}, "message": "the definition seen here"}, {"location": {"col": 7, "file": 3, "line": 243}, "message": "differing parameters are named here: ('DataTy'), in definition: ('SrcVTy')"}, {"location": {"col": 7, "file": 3, "line": 243}, "message": "function 'llvm::X86TTIImpl::getGSScalarCost' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.h", "reportHash": "c5d2c1d27acaf94195d0ed549a5b99ee", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 17, "file": 4, "line": 4091}, "message": "the definition seen here"}, {"location": {"col": 7, "file": 3, "line": 245}, "message": "differing parameters are named here: ('DataTy'), in definition: ('SrcVTy')"}, {"location": {"col": 7, "file": 3, "line": 245}, "message": "function 'llvm::X86TTIImpl::getGSVectorCost' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.h", "reportHash": "bdfd8221d36e2f638908dca5b9704ffc", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
