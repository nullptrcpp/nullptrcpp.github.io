<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"1": {"id": 1, "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaOpenMP.cpp", "content": "//===--- SemaOpenMP.cpp - Semantic Analysis for OpenMP constructs ---------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n/// \\file\n/// This file implements semantic analysis for OpenMP directives and\n/// clauses.\n///\n//===----------------------------------------------------------------------===//\n\n#include \"TreeTransform.h\"\n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/ASTMutationListener.h\"\n#include \"clang/AST/CXXInheritance.h\"\n#include \"clang/AST/Decl.h\"\n#include \"clang/AST/DeclCXX.h\"\n#include \"clang/AST/DeclOpenMP.h\"\n#include \"clang/AST/OpenMPClause.h\"\n#include \"clang/AST/StmtCXX.h\"\n#include \"clang/AST/StmtOpenMP.h\"\n#include \"clang/AST/StmtVisitor.h\"\n#include \"clang/AST/TypeOrdering.h\"\n#include \"clang/Basic/DiagnosticSema.h\"\n#include \"clang/Basic/OpenMPKinds.h\"\n#include \"clang/Basic/PartialDiagnostic.h\"\n#include \"clang/Basic/TargetInfo.h\"\n#include \"clang/Sema/Initialization.h\"\n#include \"clang/Sema/Lookup.h\"\n#include \"clang/Sema/Scope.h\"\n#include \"clang/Sema/ScopeInfo.h\"\n#include \"clang/Sema/SemaInternal.h\"\n#include \"llvm/ADT/IndexedMap.h\"\n#include \"llvm/ADT/PointerEmbeddedInt.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/StringExtras.h\"\n#include \"llvm/Frontend/OpenMP/OMPConstants.h\"\n#include <set>\n\nusing namespace clang;\nusing namespace llvm::omp;\n\n//===----------------------------------------------------------------------===//\n// Stack of data-sharing attributes for variables\n//===----------------------------------------------------------------------===//\n\nstatic const Expr *checkMapClauseExpressionBase(\n    Sema &SemaRef, Expr *E,\n    OMPClauseMappableExprCommon::MappableExprComponentList &CurComponents,\n    OpenMPClauseKind CKind, OpenMPDirectiveKind DKind, bool NoDiagnose);\n\nnamespace {\n/// Default data sharing attributes, which can be applied to directive.\nenum DefaultDataSharingAttributes {\n  DSA_unspecified = 0,       /// Data sharing attribute not specified.\n  DSA_none = 1 << 0,         /// Default data sharing attribute 'none'.\n  DSA_shared = 1 << 1,       /// Default data sharing attribute 'shared'.\n  DSA_firstprivate = 1 << 2, /// Default data sharing attribute 'firstprivate'.\n};\n\n/// Stack for tracking declarations used in OpenMP directives and\n/// clauses and their data-sharing attributes.\nclass DSAStackTy {\npublic:\n  struct DSAVarData {\n    OpenMPDirectiveKind DKind = OMPD_unknown;\n    OpenMPClauseKind CKind = OMPC_unknown;\n    unsigned Modifier = 0;\n    const Expr *RefExpr = nullptr;\n    DeclRefExpr *PrivateCopy = nullptr;\n    SourceLocation ImplicitDSALoc;\n    bool AppliedToPointee = false;\n    DSAVarData() = default;\n    DSAVarData(OpenMPDirectiveKind DKind, OpenMPClauseKind CKind,\n               const Expr *RefExpr, DeclRefExpr *PrivateCopy,\n               SourceLocation ImplicitDSALoc, unsigned Modifier,\n               bool AppliedToPointee)\n        : DKind(DKind), CKind(CKind), Modifier(Modifier), RefExpr(RefExpr),\n          PrivateCopy(PrivateCopy), ImplicitDSALoc(ImplicitDSALoc),\n          AppliedToPointee(AppliedToPointee) {}\n  };\n  using OperatorOffsetTy =\n      llvm::SmallVector<std::pair<Expr *, OverloadedOperatorKind>, 4>;\n  using DoacrossDependMapTy =\n      llvm::DenseMap<OMPDependClause *, OperatorOffsetTy>;\n  /// Kind of the declaration used in the uses_allocators clauses.\n  enum class UsesAllocatorsDeclKind {\n    /// Predefined allocator\n    PredefinedAllocator,\n    /// User-defined allocator\n    UserDefinedAllocator,\n    /// The declaration that represent allocator trait\n    AllocatorTrait,\n  };\n\nprivate:\n  struct DSAInfo {\n    OpenMPClauseKind Attributes = OMPC_unknown;\n    unsigned Modifier = 0;\n    /// Pointer to a reference expression and a flag which shows that the\n    /// variable is marked as lastprivate(true) or not (false).\n    llvm::PointerIntPair<const Expr *, 1, bool> RefExpr;\n    DeclRefExpr *PrivateCopy = nullptr;\n    /// true if the attribute is applied to the pointee, not the variable\n    /// itself.\n    bool AppliedToPointee = false;\n  };\n  using DeclSAMapTy = llvm::SmallDenseMap<const ValueDecl *, DSAInfo, 8>;\n  using UsedRefMapTy = llvm::SmallDenseMap<const ValueDecl *, const Expr *, 8>;\n  using LCDeclInfo = std::pair<unsigned, VarDecl *>;\n  using LoopControlVariablesMapTy =\n      llvm::SmallDenseMap<const ValueDecl *, LCDeclInfo, 8>;\n  /// Struct that associates a component with the clause kind where they are\n  /// found.\n  struct MappedExprComponentTy {\n    OMPClauseMappableExprCommon::MappableExprComponentLists Components;\n    OpenMPClauseKind Kind = OMPC_unknown;\n  };\n  using MappedExprComponentsTy =\n      llvm::DenseMap<const ValueDecl *, MappedExprComponentTy>;\n  using CriticalsWithHintsTy =\n      llvm::StringMap<std::pair<const OMPCriticalDirective *, llvm::APSInt>>;\n  struct ReductionData {\n    using BOKPtrType = llvm::PointerEmbeddedInt<BinaryOperatorKind, 16>;\n    SourceRange ReductionRange;\n    llvm::PointerUnion<const Expr *, BOKPtrType> ReductionOp;\n    ReductionData() = default;\n    void set(BinaryOperatorKind BO, SourceRange RR) {\n      ReductionRange = RR;\n      ReductionOp = BO;\n    }\n    void set(const Expr *RefExpr, SourceRange RR) {\n      ReductionRange = RR;\n      ReductionOp = RefExpr;\n    }\n  };\n  using DeclReductionMapTy =\n      llvm::SmallDenseMap<const ValueDecl *, ReductionData, 4>;\n  struct DefaultmapInfo {\n    OpenMPDefaultmapClauseModifier ImplicitBehavior =\n        OMPC_DEFAULTMAP_MODIFIER_unknown;\n    SourceLocation SLoc;\n    DefaultmapInfo() = default;\n    DefaultmapInfo(OpenMPDefaultmapClauseModifier M, SourceLocation Loc)\n        : ImplicitBehavior(M), SLoc(Loc) {}\n  };\n\n  struct SharingMapTy {\n    DeclSAMapTy SharingMap;\n    DeclReductionMapTy ReductionMap;\n    UsedRefMapTy AlignedMap;\n    UsedRefMapTy NontemporalMap;\n    MappedExprComponentsTy MappedExprComponents;\n    LoopControlVariablesMapTy LCVMap;\n    DefaultDataSharingAttributes DefaultAttr = DSA_unspecified;\n    SourceLocation DefaultAttrLoc;\n    DefaultmapInfo DefaultmapMap[OMPC_DEFAULTMAP_unknown];\n    OpenMPDirectiveKind Directive = OMPD_unknown;\n    DeclarationNameInfo DirectiveName;\n    Scope *CurScope = nullptr;\n    DeclContext *Context = nullptr;\n    SourceLocation ConstructLoc;\n    /// Set of 'depend' clauses with 'sink|source' dependence kind. Required to\n    /// get the data (loop counters etc.) about enclosing loop-based construct.\n    /// This data is required during codegen.\n    DoacrossDependMapTy DoacrossDepends;\n    /// First argument (Expr *) contains optional argument of the\n    /// 'ordered' clause, the second one is true if the regions has 'ordered'\n    /// clause, false otherwise.\n    llvm::Optional<std::pair<const Expr *, OMPOrderedClause *>> OrderedRegion;\n    unsigned AssociatedLoops = 1;\n    bool HasMutipleLoops = false;\n    const Decl *PossiblyLoopCounter = nullptr;\n    bool NowaitRegion = false;\n    bool CancelRegion = false;\n    bool LoopStart = false;\n    bool BodyComplete = false;\n    SourceLocation PrevScanLocation;\n    SourceLocation PrevOrderedLocation;\n    SourceLocation InnerTeamsRegionLoc;\n    /// Reference to the taskgroup task_reduction reference expression.\n    Expr *TaskgroupReductionRef = nullptr;\n    llvm::DenseSet<QualType> MappedClassesQualTypes;\n    SmallVector<Expr *, 4> InnerUsedAllocators;\n    llvm::DenseSet<CanonicalDeclPtr<Decl>> ImplicitTaskFirstprivates;\n    /// List of globals marked as declare target link in this target region\n    /// (isOpenMPTargetExecutionDirective(Directive) == true).\n    llvm::SmallVector<DeclRefExpr *, 4> DeclareTargetLinkVarDecls;\n    /// List of decls used in inclusive/exclusive clauses of the scan directive.\n    llvm::DenseSet<CanonicalDeclPtr<Decl>> UsedInScanDirective;\n    llvm::DenseMap<CanonicalDeclPtr<const Decl>, UsesAllocatorsDeclKind>\n        UsesAllocatorsDecls;\n    Expr *DeclareMapperVar = nullptr;\n    SharingMapTy(OpenMPDirectiveKind DKind, DeclarationNameInfo Name,\n                 Scope *CurScope, SourceLocation Loc)\n        : Directive(DKind), DirectiveName(Name), CurScope(CurScope),\n          ConstructLoc(Loc) {}\n    SharingMapTy() = default;\n  };\n\n  using StackTy = SmallVector<SharingMapTy, 4>;\n\n  /// Stack of used declaration and their data-sharing attributes.\n  DeclSAMapTy Threadprivates;\n  const FunctionScopeInfo *CurrentNonCapturingFunctionScope = nullptr;\n  SmallVector<std::pair<StackTy, const FunctionScopeInfo *>, 4> Stack;\n  /// true, if check for DSA must be from parent directive, false, if\n  /// from current directive.\n  OpenMPClauseKind ClauseKindMode = OMPC_unknown;\n  Sema &SemaRef;\n  bool ForceCapturing = false;\n  /// true if all the variables in the target executable directives must be\n  /// captured by reference.\n  bool ForceCaptureByReferenceInTargetExecutable = false;\n  CriticalsWithHintsTy Criticals;\n  unsigned IgnoredStackElements = 0;\n\n  /// Iterators over the stack iterate in order from innermost to outermost\n  /// directive.\n  using const_iterator = StackTy::const_reverse_iterator;\n  const_iterator begin() const {\n    return Stack.empty() ? const_iterator()\n                         : Stack.back().first.rbegin() + IgnoredStackElements;\n  }\n  const_iterator end() const {\n    return Stack.empty() ? const_iterator() : Stack.back().first.rend();\n  }\n  using iterator = StackTy::reverse_iterator;\n  iterator begin() {\n    return Stack.empty() ? iterator()\n                         : Stack.back().first.rbegin() + IgnoredStackElements;\n  }\n  iterator end() {\n    return Stack.empty() ? iterator() : Stack.back().first.rend();\n  }\n\n  // Convenience operations to get at the elements of the stack.\n\n  bool isStackEmpty() const {\n    return Stack.empty() ||\n           Stack.back().second != CurrentNonCapturingFunctionScope ||\n           Stack.back().first.size() <= IgnoredStackElements;\n  }\n  size_t getStackSize() const {\n    return isStackEmpty() ? 0\n                          : Stack.back().first.size() - IgnoredStackElements;\n  }\n\n  SharingMapTy *getTopOfStackOrNull() {\n    size_t Size = getStackSize();\n    if (Size == 0)\n      return nullptr;\n    return &Stack.back().first[Size - 1];\n  }\n  const SharingMapTy *getTopOfStackOrNull() const {\n    return const_cast<DSAStackTy&>(*this).getTopOfStackOrNull();\n  }\n  SharingMapTy &getTopOfStack() {\n    assert(!isStackEmpty() && \"no current directive\");\n    return *getTopOfStackOrNull();\n  }\n  const SharingMapTy &getTopOfStack() const {\n    return const_cast<DSAStackTy&>(*this).getTopOfStack();\n  }\n\n  SharingMapTy *getSecondOnStackOrNull() {\n    size_t Size = getStackSize();\n    if (Size <= 1)\n      return nullptr;\n    return &Stack.back().first[Size - 2];\n  }\n  const SharingMapTy *getSecondOnStackOrNull() const {\n    return const_cast<DSAStackTy&>(*this).getSecondOnStackOrNull();\n  }\n\n  /// Get the stack element at a certain level (previously returned by\n  /// \\c getNestingLevel).\n  ///\n  /// Note that nesting levels count from outermost to innermost, and this is\n  /// the reverse of our iteration order where new inner levels are pushed at\n  /// the front of the stack.\n  SharingMapTy &getStackElemAtLevel(unsigned Level) {\n    assert(Level < getStackSize() && \"no such stack element\");\n    return Stack.back().first[Level];\n  }\n  const SharingMapTy &getStackElemAtLevel(unsigned Level) const {\n    return const_cast<DSAStackTy&>(*this).getStackElemAtLevel(Level);\n  }\n\n  DSAVarData getDSA(const_iterator &Iter, ValueDecl *D) const;\n\n  /// Checks if the variable is a local for OpenMP region.\n  bool isOpenMPLocal(VarDecl *D, const_iterator Iter) const;\n\n  /// Vector of previously declared requires directives\n  SmallVector<const OMPRequiresDecl *, 2> RequiresDecls;\n  /// omp_allocator_handle_t type.\n  QualType OMPAllocatorHandleT;\n  /// omp_depend_t type.\n  QualType OMPDependT;\n  /// omp_event_handle_t type.\n  QualType OMPEventHandleT;\n  /// omp_alloctrait_t type.\n  QualType OMPAlloctraitT;\n  /// Expression for the predefined allocators.\n  Expr *OMPPredefinedAllocators[OMPAllocateDeclAttr::OMPUserDefinedMemAlloc] = {\n      nullptr};\n  /// Vector of previously encountered target directives\n  SmallVector<SourceLocation, 2> TargetLocations;\n  SourceLocation AtomicLocation;\n\npublic:\n  explicit DSAStackTy(Sema &S) : SemaRef(S) {}\n\n  /// Sets omp_allocator_handle_t type.\n  void setOMPAllocatorHandleT(QualType Ty) { OMPAllocatorHandleT = Ty; }\n  /// Gets omp_allocator_handle_t type.\n  QualType getOMPAllocatorHandleT() const { return OMPAllocatorHandleT; }\n  /// Sets omp_alloctrait_t type.\n  void setOMPAlloctraitT(QualType Ty) { OMPAlloctraitT = Ty; }\n  /// Gets omp_alloctrait_t type.\n  QualType getOMPAlloctraitT() const { return OMPAlloctraitT; }\n  /// Sets the given default allocator.\n  void setAllocator(OMPAllocateDeclAttr::AllocatorTypeTy AllocatorKind,\n                    Expr *Allocator) {\n    OMPPredefinedAllocators[AllocatorKind] = Allocator;\n  }\n  /// Returns the specified default allocator.\n  Expr *getAllocator(OMPAllocateDeclAttr::AllocatorTypeTy AllocatorKind) const {\n    return OMPPredefinedAllocators[AllocatorKind];\n  }\n  /// Sets omp_depend_t type.\n  void setOMPDependT(QualType Ty) { OMPDependT = Ty; }\n  /// Gets omp_depend_t type.\n  QualType getOMPDependT() const { return OMPDependT; }\n\n  /// Sets omp_event_handle_t type.\n  void setOMPEventHandleT(QualType Ty) { OMPEventHandleT = Ty; }\n  /// Gets omp_event_handle_t type.\n  QualType getOMPEventHandleT() const { return OMPEventHandleT; }\n\n  bool isClauseParsingMode() const { return ClauseKindMode != OMPC_unknown; }\n  OpenMPClauseKind getClauseParsingMode() const {\n    assert(isClauseParsingMode() && \"Must be in clause parsing mode.\");\n    return ClauseKindMode;\n  }\n  void setClauseParsingMode(OpenMPClauseKind K) { ClauseKindMode = K; }\n\n  bool isBodyComplete() const {\n    const SharingMapTy *Top = getTopOfStackOrNull();\n    return Top && Top->BodyComplete;\n  }\n  void setBodyComplete() {\n    getTopOfStack().BodyComplete = true;\n  }\n\n  bool isForceVarCapturing() const { return ForceCapturing; }\n  void setForceVarCapturing(bool V) { ForceCapturing = V; }\n\n  void setForceCaptureByReferenceInTargetExecutable(bool V) {\n    ForceCaptureByReferenceInTargetExecutable = V;\n  }\n  bool isForceCaptureByReferenceInTargetExecutable() const {\n    return ForceCaptureByReferenceInTargetExecutable;\n  }\n\n  void push(OpenMPDirectiveKind DKind, const DeclarationNameInfo &DirName,\n            Scope *CurScope, SourceLocation Loc) {\n    assert(!IgnoredStackElements &&\n           \"cannot change stack while ignoring elements\");\n    if (Stack.empty() ||\n        Stack.back().second != CurrentNonCapturingFunctionScope)\n      Stack.emplace_back(StackTy(), CurrentNonCapturingFunctionScope);\n    Stack.back().first.emplace_back(DKind, DirName, CurScope, Loc);\n    Stack.back().first.back().DefaultAttrLoc = Loc;\n  }\n\n  void pop() {\n    assert(!IgnoredStackElements &&\n           \"cannot change stack while ignoring elements\");\n    assert(!Stack.back().first.empty() &&\n           \"Data-sharing attributes stack is empty!\");\n    Stack.back().first.pop_back();\n  }\n\n  /// RAII object to temporarily leave the scope of a directive when we want to\n  /// logically operate in its parent.\n  class ParentDirectiveScope {\n    DSAStackTy &Self;\n    bool Active;\n  public:\n    ParentDirectiveScope(DSAStackTy &Self, bool Activate)\n        : Self(Self), Active(false) {\n      if (Activate)\n        enable();\n    }\n    ~ParentDirectiveScope() { disable(); }\n    void disable() {\n      if (Active) {\n        --Self.IgnoredStackElements;\n        Active = false;\n      }\n    }\n    void enable() {\n      if (!Active) {\n        ++Self.IgnoredStackElements;\n        Active = true;\n      }\n    }\n  };\n\n  /// Marks that we're started loop parsing.\n  void loopInit() {\n    assert(isOpenMPLoopDirective(getCurrentDirective()) &&\n           \"Expected loop-based directive.\");\n    getTopOfStack().LoopStart = true;\n  }\n  /// Start capturing of the variables in the loop context.\n  void loopStart() {\n    assert(isOpenMPLoopDirective(getCurrentDirective()) &&\n           \"Expected loop-based directive.\");\n    getTopOfStack().LoopStart = false;\n  }\n  /// true, if variables are captured, false otherwise.\n  bool isLoopStarted() const {\n    assert(isOpenMPLoopDirective(getCurrentDirective()) &&\n           \"Expected loop-based directive.\");\n    return !getTopOfStack().LoopStart;\n  }\n  /// Marks (or clears) declaration as possibly loop counter.\n  void resetPossibleLoopCounter(const Decl *D = nullptr) {\n    getTopOfStack().PossiblyLoopCounter =\n        D ? D->getCanonicalDecl() : D;\n  }\n  /// Gets the possible loop counter decl.\n  const Decl *getPossiblyLoopCunter() const {\n    return getTopOfStack().PossiblyLoopCounter;\n  }\n  /// Start new OpenMP region stack in new non-capturing function.\n  void pushFunction() {\n    assert(!IgnoredStackElements &&\n           \"cannot change stack while ignoring elements\");\n    const FunctionScopeInfo *CurFnScope = SemaRef.getCurFunction();\n    assert(!isa<CapturingScopeInfo>(CurFnScope));\n    CurrentNonCapturingFunctionScope = CurFnScope;\n  }\n  /// Pop region stack for non-capturing function.\n  void popFunction(const FunctionScopeInfo *OldFSI) {\n    assert(!IgnoredStackElements &&\n           \"cannot change stack while ignoring elements\");\n    if (!Stack.empty() && Stack.back().second == OldFSI) {\n      assert(Stack.back().first.empty());\n      Stack.pop_back();\n    }\n    CurrentNonCapturingFunctionScope = nullptr;\n    for (const FunctionScopeInfo *FSI : llvm::reverse(SemaRef.FunctionScopes)) {\n      if (!isa<CapturingScopeInfo>(FSI)) {\n        CurrentNonCapturingFunctionScope = FSI;\n        break;\n      }\n    }\n  }\n\n  void addCriticalWithHint(const OMPCriticalDirective *D, llvm::APSInt Hint) {\n    Criticals.try_emplace(D->getDirectiveName().getAsString(), D, Hint);\n  }\n  const std::pair<const OMPCriticalDirective *, llvm::APSInt>\n  getCriticalWithHint(const DeclarationNameInfo &Name) const {\n    auto I = Criticals.find(Name.getAsString());\n    if (I != Criticals.end())\n      return I->second;\n    return std::make_pair(nullptr, llvm::APSInt());\n  }\n  /// If 'aligned' declaration for given variable \\a D was not seen yet,\n  /// add it and return NULL; otherwise return previous occurrence's expression\n  /// for diagnostics.\n  const Expr *addUniqueAligned(const ValueDecl *D, const Expr *NewDE);\n  /// If 'nontemporal' declaration for given variable \\a D was not seen yet,\n  /// add it and return NULL; otherwise return previous occurrence's expression\n  /// for diagnostics.\n  const Expr *addUniqueNontemporal(const ValueDecl *D, const Expr *NewDE);\n\n  /// Register specified variable as loop control variable.\n  void addLoopControlVariable(const ValueDecl *D, VarDecl *Capture);\n  /// Check if the specified variable is a loop control variable for\n  /// current region.\n  /// \\return The index of the loop control variable in the list of associated\n  /// for-loops (from outer to inner).\n  const LCDeclInfo isLoopControlVariable(const ValueDecl *D) const;\n  /// Check if the specified variable is a loop control variable for\n  /// parent region.\n  /// \\return The index of the loop control variable in the list of associated\n  /// for-loops (from outer to inner).\n  const LCDeclInfo isParentLoopControlVariable(const ValueDecl *D) const;\n  /// Check if the specified variable is a loop control variable for\n  /// current region.\n  /// \\return The index of the loop control variable in the list of associated\n  /// for-loops (from outer to inner).\n  const LCDeclInfo isLoopControlVariable(const ValueDecl *D,\n                                         unsigned Level) const;\n  /// Get the loop control variable for the I-th loop (or nullptr) in\n  /// parent directive.\n  const ValueDecl *getParentLoopControlVariable(unsigned I) const;\n\n  /// Marks the specified decl \\p D as used in scan directive.\n  void markDeclAsUsedInScanDirective(ValueDecl *D) {\n    if (SharingMapTy *Stack = getSecondOnStackOrNull())\n      Stack->UsedInScanDirective.insert(D);\n  }\n\n  /// Checks if the specified declaration was used in the inner scan directive.\n  bool isUsedInScanDirective(ValueDecl *D) const {\n    if (const SharingMapTy *Stack = getTopOfStackOrNull())\n      return Stack->UsedInScanDirective.count(D) > 0;\n    return false;\n  }\n\n  /// Adds explicit data sharing attribute to the specified declaration.\n  void addDSA(const ValueDecl *D, const Expr *E, OpenMPClauseKind A,\n              DeclRefExpr *PrivateCopy = nullptr, unsigned Modifier = 0,\n              bool AppliedToPointee = false);\n\n  /// Adds additional information for the reduction items with the reduction id\n  /// represented as an operator.\n  void addTaskgroupReductionData(const ValueDecl *D, SourceRange SR,\n                                 BinaryOperatorKind BOK);\n  /// Adds additional information for the reduction items with the reduction id\n  /// represented as reduction identifier.\n  void addTaskgroupReductionData(const ValueDecl *D, SourceRange SR,\n                                 const Expr *ReductionRef);\n  /// Returns the location and reduction operation from the innermost parent\n  /// region for the given \\p D.\n  const DSAVarData\n  getTopMostTaskgroupReductionData(const ValueDecl *D, SourceRange &SR,\n                                   BinaryOperatorKind &BOK,\n                                   Expr *&TaskgroupDescriptor) const;\n  /// Returns the location and reduction operation from the innermost parent\n  /// region for the given \\p D.\n  const DSAVarData\n  getTopMostTaskgroupReductionData(const ValueDecl *D, SourceRange &SR,\n                                   const Expr *&ReductionRef,\n                                   Expr *&TaskgroupDescriptor) const;\n  /// Return reduction reference expression for the current taskgroup or\n  /// parallel/worksharing directives with task reductions.\n  Expr *getTaskgroupReductionRef() const {\n    assert((getTopOfStack().Directive == OMPD_taskgroup ||\n            ((isOpenMPParallelDirective(getTopOfStack().Directive) ||\n              isOpenMPWorksharingDirective(getTopOfStack().Directive)) &&\n             !isOpenMPSimdDirective(getTopOfStack().Directive))) &&\n           \"taskgroup reference expression requested for non taskgroup or \"\n           \"parallel/worksharing directive.\");\n    return getTopOfStack().TaskgroupReductionRef;\n  }\n  /// Checks if the given \\p VD declaration is actually a taskgroup reduction\n  /// descriptor variable at the \\p Level of OpenMP regions.\n  bool isTaskgroupReductionRef(const ValueDecl *VD, unsigned Level) const {\n    return getStackElemAtLevel(Level).TaskgroupReductionRef &&\n           cast<DeclRefExpr>(getStackElemAtLevel(Level).TaskgroupReductionRef)\n                   ->getDecl() == VD;\n  }\n\n  /// Returns data sharing attributes from top of the stack for the\n  /// specified declaration.\n  const DSAVarData getTopDSA(ValueDecl *D, bool FromParent);\n  /// Returns data-sharing attributes for the specified declaration.\n  const DSAVarData getImplicitDSA(ValueDecl *D, bool FromParent) const;\n  /// Returns data-sharing attributes for the specified declaration.\n  const DSAVarData getImplicitDSA(ValueDecl *D, unsigned Level) const;\n  /// Checks if the specified variables has data-sharing attributes which\n  /// match specified \\a CPred predicate in any directive which matches \\a DPred\n  /// predicate.\n  const DSAVarData\n  hasDSA(ValueDecl *D,\n         const llvm::function_ref<bool(OpenMPClauseKind, bool)> CPred,\n         const llvm::function_ref<bool(OpenMPDirectiveKind)> DPred,\n         bool FromParent) const;\n  /// Checks if the specified variables has data-sharing attributes which\n  /// match specified \\a CPred predicate in any innermost directive which\n  /// matches \\a DPred predicate.\n  const DSAVarData\n  hasInnermostDSA(ValueDecl *D,\n                  const llvm::function_ref<bool(OpenMPClauseKind, bool)> CPred,\n                  const llvm::function_ref<bool(OpenMPDirectiveKind)> DPred,\n                  bool FromParent) const;\n  /// Checks if the specified variables has explicit data-sharing\n  /// attributes which match specified \\a CPred predicate at the specified\n  /// OpenMP region.\n  bool\n  hasExplicitDSA(const ValueDecl *D,\n                 const llvm::function_ref<bool(OpenMPClauseKind, bool)> CPred,\n                 unsigned Level, bool NotLastprivate = false) const;\n\n  /// Returns true if the directive at level \\Level matches in the\n  /// specified \\a DPred predicate.\n  bool hasExplicitDirective(\n      const llvm::function_ref<bool(OpenMPDirectiveKind)> DPred,\n      unsigned Level) const;\n\n  /// Finds a directive which matches specified \\a DPred predicate.\n  bool hasDirective(\n      const llvm::function_ref<bool(\n          OpenMPDirectiveKind, const DeclarationNameInfo &, SourceLocation)>\n          DPred,\n      bool FromParent) const;\n\n  /// Returns currently analyzed directive.\n  OpenMPDirectiveKind getCurrentDirective() const {\n    const SharingMapTy *Top = getTopOfStackOrNull();\n    return Top ? Top->Directive : OMPD_unknown;\n  }\n  /// Returns directive kind at specified level.\n  OpenMPDirectiveKind getDirective(unsigned Level) const {\n    assert(!isStackEmpty() && \"No directive at specified level.\");\n    return getStackElemAtLevel(Level).Directive;\n  }\n  /// Returns the capture region at the specified level.\n  OpenMPDirectiveKind getCaptureRegion(unsigned Level,\n                                       unsigned OpenMPCaptureLevel) const {\n    SmallVector<OpenMPDirectiveKind, 4> CaptureRegions;\n    getOpenMPCaptureRegions(CaptureRegions, getDirective(Level));\n    return CaptureRegions[OpenMPCaptureLevel];\n  }\n  /// Returns parent directive.\n  OpenMPDirectiveKind getParentDirective() const {\n    const SharingMapTy *Parent = getSecondOnStackOrNull();\n    return Parent ? Parent->Directive : OMPD_unknown;\n  }\n\n  /// Add requires decl to internal vector\n  void addRequiresDecl(OMPRequiresDecl *RD) {\n    RequiresDecls.push_back(RD);\n  }\n\n  /// Checks if the defined 'requires' directive has specified type of clause.\n  template <typename ClauseType>\n  bool hasRequiresDeclWithClause() const {\n    return llvm::any_of(RequiresDecls, [](const OMPRequiresDecl *D) {\n      return llvm::any_of(D->clauselists(), [](const OMPClause *C) {\n        return isa<ClauseType>(C);\n      });\n    });\n  }\n\n  /// Checks for a duplicate clause amongst previously declared requires\n  /// directives\n  bool hasDuplicateRequiresClause(ArrayRef<OMPClause *> ClauseList) const {\n    bool IsDuplicate = false;\n    for (OMPClause *CNew : ClauseList) {\n      for (const OMPRequiresDecl *D : RequiresDecls) {\n        for (const OMPClause *CPrev : D->clauselists()) {\n          if (CNew->getClauseKind() == CPrev->getClauseKind()) {\n            SemaRef.Diag(CNew->getBeginLoc(),\n                         diag::err_omp_requires_clause_redeclaration)\n                << getOpenMPClauseName(CNew->getClauseKind());\n            SemaRef.Diag(CPrev->getBeginLoc(),\n                         diag::note_omp_requires_previous_clause)\n                << getOpenMPClauseName(CPrev->getClauseKind());\n            IsDuplicate = true;\n          }\n        }\n      }\n    }\n    return IsDuplicate;\n  }\n\n  /// Add location of previously encountered target to internal vector\n  void addTargetDirLocation(SourceLocation LocStart) {\n    TargetLocations.push_back(LocStart);\n  }\n\n  /// Add location for the first encountered atomicc directive.\n  void addAtomicDirectiveLoc(SourceLocation Loc) {\n    if (AtomicLocation.isInvalid())\n      AtomicLocation = Loc;\n  }\n\n  /// Returns the location of the first encountered atomic directive in the\n  /// module.\n  SourceLocation getAtomicDirectiveLoc() const {\n    return AtomicLocation;\n  }\n\n  // Return previously encountered target region locations.\n  ArrayRef<SourceLocation> getEncounteredTargetLocs() const {\n    return TargetLocations;\n  }\n\n  /// Set default data sharing attribute to none.\n  void setDefaultDSANone(SourceLocation Loc) {\n    getTopOfStack().DefaultAttr = DSA_none;\n    getTopOfStack().DefaultAttrLoc = Loc;\n  }\n  /// Set default data sharing attribute to shared.\n  void setDefaultDSAShared(SourceLocation Loc) {\n    getTopOfStack().DefaultAttr = DSA_shared;\n    getTopOfStack().DefaultAttrLoc = Loc;\n  }\n  /// Set default data sharing attribute to firstprivate.\n  void setDefaultDSAFirstPrivate(SourceLocation Loc) {\n    getTopOfStack().DefaultAttr = DSA_firstprivate;\n    getTopOfStack().DefaultAttrLoc = Loc;\n  }\n  /// Set default data mapping attribute to Modifier:Kind\n  void setDefaultDMAAttr(OpenMPDefaultmapClauseModifier M,\n                         OpenMPDefaultmapClauseKind Kind,\n                         SourceLocation Loc) {\n    DefaultmapInfo &DMI = getTopOfStack().DefaultmapMap[Kind];\n    DMI.ImplicitBehavior = M;\n    DMI.SLoc = Loc;\n  }\n  /// Check whether the implicit-behavior has been set in defaultmap\n  bool checkDefaultmapCategory(OpenMPDefaultmapClauseKind VariableCategory) {\n    if (VariableCategory == OMPC_DEFAULTMAP_unknown)\n      return getTopOfStack()\n                     .DefaultmapMap[OMPC_DEFAULTMAP_aggregate]\n                     .ImplicitBehavior != OMPC_DEFAULTMAP_MODIFIER_unknown ||\n             getTopOfStack()\n                     .DefaultmapMap[OMPC_DEFAULTMAP_scalar]\n                     .ImplicitBehavior != OMPC_DEFAULTMAP_MODIFIER_unknown ||\n             getTopOfStack()\n                     .DefaultmapMap[OMPC_DEFAULTMAP_pointer]\n                     .ImplicitBehavior != OMPC_DEFAULTMAP_MODIFIER_unknown;\n    return getTopOfStack().DefaultmapMap[VariableCategory].ImplicitBehavior !=\n           OMPC_DEFAULTMAP_MODIFIER_unknown;\n  }\n\n  DefaultDataSharingAttributes getDefaultDSA(unsigned Level) const {\n    return getStackSize() <= Level ? DSA_unspecified\n                                   : getStackElemAtLevel(Level).DefaultAttr;\n  }\n  DefaultDataSharingAttributes getDefaultDSA() const {\n    return isStackEmpty() ? DSA_unspecified\n                          : getTopOfStack().DefaultAttr;\n  }\n  SourceLocation getDefaultDSALocation() const {\n    return isStackEmpty() ? SourceLocation()\n                          : getTopOfStack().DefaultAttrLoc;\n  }\n  OpenMPDefaultmapClauseModifier\n  getDefaultmapModifier(OpenMPDefaultmapClauseKind Kind) const {\n    return isStackEmpty()\n               ? OMPC_DEFAULTMAP_MODIFIER_unknown\n               : getTopOfStack().DefaultmapMap[Kind].ImplicitBehavior;\n  }\n  OpenMPDefaultmapClauseModifier\n  getDefaultmapModifierAtLevel(unsigned Level,\n                               OpenMPDefaultmapClauseKind Kind) const {\n    return getStackElemAtLevel(Level).DefaultmapMap[Kind].ImplicitBehavior;\n  }\n  bool isDefaultmapCapturedByRef(unsigned Level,\n                                 OpenMPDefaultmapClauseKind Kind) const {\n    OpenMPDefaultmapClauseModifier M =\n        getDefaultmapModifierAtLevel(Level, Kind);\n    if (Kind == OMPC_DEFAULTMAP_scalar || Kind == OMPC_DEFAULTMAP_pointer) {\n      return (M == OMPC_DEFAULTMAP_MODIFIER_alloc) ||\n             (M == OMPC_DEFAULTMAP_MODIFIER_to) ||\n             (M == OMPC_DEFAULTMAP_MODIFIER_from) ||\n             (M == OMPC_DEFAULTMAP_MODIFIER_tofrom);\n    }\n    return true;\n  }\n  static bool mustBeFirstprivateBase(OpenMPDefaultmapClauseModifier M,\n                                     OpenMPDefaultmapClauseKind Kind) {\n    switch (Kind) {\n    case OMPC_DEFAULTMAP_scalar:\n    case OMPC_DEFAULTMAP_pointer:\n      return (M == OMPC_DEFAULTMAP_MODIFIER_unknown) ||\n             (M == OMPC_DEFAULTMAP_MODIFIER_firstprivate) ||\n             (M == OMPC_DEFAULTMAP_MODIFIER_default);\n    case OMPC_DEFAULTMAP_aggregate:\n      return M == OMPC_DEFAULTMAP_MODIFIER_firstprivate;\n    default:\n      break;\n    }\n    llvm_unreachable(\"Unexpected OpenMPDefaultmapClauseKind enum\");\n  }\n  bool mustBeFirstprivateAtLevel(unsigned Level,\n                                 OpenMPDefaultmapClauseKind Kind) const {\n    OpenMPDefaultmapClauseModifier M =\n        getDefaultmapModifierAtLevel(Level, Kind);\n    return mustBeFirstprivateBase(M, Kind);\n  }\n  bool mustBeFirstprivate(OpenMPDefaultmapClauseKind Kind) const {\n    OpenMPDefaultmapClauseModifier M = getDefaultmapModifier(Kind);\n    return mustBeFirstprivateBase(M, Kind);\n  }\n\n  /// Checks if the specified variable is a threadprivate.\n  bool isThreadPrivate(VarDecl *D) {\n    const DSAVarData DVar = getTopDSA(D, false);\n    return isOpenMPThreadPrivate(DVar.CKind);\n  }\n\n  /// Marks current region as ordered (it has an 'ordered' clause).\n  void setOrderedRegion(bool IsOrdered, const Expr *Param,\n                        OMPOrderedClause *Clause) {\n    if (IsOrdered)\n      getTopOfStack().OrderedRegion.emplace(Param, Clause);\n    else\n      getTopOfStack().OrderedRegion.reset();\n  }\n  /// Returns true, if region is ordered (has associated 'ordered' clause),\n  /// false - otherwise.\n  bool isOrderedRegion() const {\n    if (const SharingMapTy *Top = getTopOfStackOrNull())\n      return Top->OrderedRegion.hasValue();\n    return false;\n  }\n  /// Returns optional parameter for the ordered region.\n  std::pair<const Expr *, OMPOrderedClause *> getOrderedRegionParam() const {\n    if (const SharingMapTy *Top = getTopOfStackOrNull())\n      if (Top->OrderedRegion.hasValue())\n        return Top->OrderedRegion.getValue();\n    return std::make_pair(nullptr, nullptr);\n  }\n  /// Returns true, if parent region is ordered (has associated\n  /// 'ordered' clause), false - otherwise.\n  bool isParentOrderedRegion() const {\n    if (const SharingMapTy *Parent = getSecondOnStackOrNull())\n      return Parent->OrderedRegion.hasValue();\n    return false;\n  }\n  /// Returns optional parameter for the ordered region.\n  std::pair<const Expr *, OMPOrderedClause *>\n  getParentOrderedRegionParam() const {\n    if (const SharingMapTy *Parent = getSecondOnStackOrNull())\n      if (Parent->OrderedRegion.hasValue())\n        return Parent->OrderedRegion.getValue();\n    return std::make_pair(nullptr, nullptr);\n  }\n  /// Marks current region as nowait (it has a 'nowait' clause).\n  void setNowaitRegion(bool IsNowait = true) {\n    getTopOfStack().NowaitRegion = IsNowait;\n  }\n  /// Returns true, if parent region is nowait (has associated\n  /// 'nowait' clause), false - otherwise.\n  bool isParentNowaitRegion() const {\n    if (const SharingMapTy *Parent = getSecondOnStackOrNull())\n      return Parent->NowaitRegion;\n    return false;\n  }\n  /// Marks parent region as cancel region.\n  void setParentCancelRegion(bool Cancel = true) {\n    if (SharingMapTy *Parent = getSecondOnStackOrNull())\n      Parent->CancelRegion |= Cancel;\n  }\n  /// Return true if current region has inner cancel construct.\n  bool isCancelRegion() const {\n    const SharingMapTy *Top = getTopOfStackOrNull();\n    return Top ? Top->CancelRegion : false;\n  }\n\n  /// Mark that parent region already has scan directive.\n  void setParentHasScanDirective(SourceLocation Loc) {\n    if (SharingMapTy *Parent = getSecondOnStackOrNull())\n      Parent->PrevScanLocation = Loc;\n  }\n  /// Return true if current region has inner cancel construct.\n  bool doesParentHasScanDirective() const {\n    const SharingMapTy *Top = getSecondOnStackOrNull();\n    return Top ? Top->PrevScanLocation.isValid() : false;\n  }\n  /// Return true if current region has inner cancel construct.\n  SourceLocation getParentScanDirectiveLoc() const {\n    const SharingMapTy *Top = getSecondOnStackOrNull();\n    return Top ? Top->PrevScanLocation : SourceLocation();\n  }\n  /// Mark that parent region already has ordered directive.\n  void setParentHasOrderedDirective(SourceLocation Loc) {\n    if (SharingMapTy *Parent = getSecondOnStackOrNull())\n      Parent->PrevOrderedLocation = Loc;\n  }\n  /// Return true if current region has inner ordered construct.\n  bool doesParentHasOrderedDirective() const {\n    const SharingMapTy *Top = getSecondOnStackOrNull();\n    return Top ? Top->PrevOrderedLocation.isValid() : false;\n  }\n  /// Returns the location of the previously specified ordered directive.\n  SourceLocation getParentOrderedDirectiveLoc() const {\n    const SharingMapTy *Top = getSecondOnStackOrNull();\n    return Top ? Top->PrevOrderedLocation : SourceLocation();\n  }\n\n  /// Set collapse value for the region.\n  void setAssociatedLoops(unsigned Val) {\n    getTopOfStack().AssociatedLoops = Val;\n    if (Val > 1)\n      getTopOfStack().HasMutipleLoops = true;\n  }\n  /// Return collapse value for region.\n  unsigned getAssociatedLoops() const {\n    const SharingMapTy *Top = getTopOfStackOrNull();\n    return Top ? Top->AssociatedLoops : 0;\n  }\n  /// Returns true if the construct is associated with multiple loops.\n  bool hasMutipleLoops() const {\n    const SharingMapTy *Top = getTopOfStackOrNull();\n    return Top ? Top->HasMutipleLoops : false;\n  }\n\n  /// Marks current target region as one with closely nested teams\n  /// region.\n  void setParentTeamsRegionLoc(SourceLocation TeamsRegionLoc) {\n    if (SharingMapTy *Parent = getSecondOnStackOrNull())\n      Parent->InnerTeamsRegionLoc = TeamsRegionLoc;\n  }\n  /// Returns true, if current region has closely nested teams region.\n  bool hasInnerTeamsRegion() const {\n    return getInnerTeamsRegionLoc().isValid();\n  }\n  /// Returns location of the nested teams region (if any).\n  SourceLocation getInnerTeamsRegionLoc() const {\n    const SharingMapTy *Top = getTopOfStackOrNull();\n    return Top ? Top->InnerTeamsRegionLoc : SourceLocation();\n  }\n\n  Scope *getCurScope() const {\n    const SharingMapTy *Top = getTopOfStackOrNull();\n    return Top ? Top->CurScope : nullptr;\n  }\n  void setContext(DeclContext *DC) { getTopOfStack().Context = DC; }\n  SourceLocation getConstructLoc() const {\n    const SharingMapTy *Top = getTopOfStackOrNull();\n    return Top ? Top->ConstructLoc : SourceLocation();\n  }\n\n  /// Do the check specified in \\a Check to all component lists and return true\n  /// if any issue is found.\n  bool checkMappableExprComponentListsForDecl(\n      const ValueDecl *VD, bool CurrentRegionOnly,\n      const llvm::function_ref<\n          bool(OMPClauseMappableExprCommon::MappableExprComponentListRef,\n               OpenMPClauseKind)>\n          Check) const {\n    if (isStackEmpty())\n      return false;\n    auto SI = begin();\n    auto SE = end();\n\n    if (SI == SE)\n      return false;\n\n    if (CurrentRegionOnly)\n      SE = std::next(SI);\n    else\n      std::advance(SI, 1);\n\n    for (; SI != SE; ++SI) {\n      auto MI = SI->MappedExprComponents.find(VD);\n      if (MI != SI->MappedExprComponents.end())\n        for (OMPClauseMappableExprCommon::MappableExprComponentListRef L :\n             MI->second.Components)\n          if (Check(L, MI->second.Kind))\n            return true;\n    }\n    return false;\n  }\n\n  /// Do the check specified in \\a Check to all component lists at a given level\n  /// and return true if any issue is found.\n  bool checkMappableExprComponentListsForDeclAtLevel(\n      const ValueDecl *VD, unsigned Level,\n      const llvm::function_ref<\n          bool(OMPClauseMappableExprCommon::MappableExprComponentListRef,\n               OpenMPClauseKind)>\n          Check) const {\n    if (getStackSize() <= Level)\n      return false;\n\n    const SharingMapTy &StackElem = getStackElemAtLevel(Level);\n    auto MI = StackElem.MappedExprComponents.find(VD);\n    if (MI != StackElem.MappedExprComponents.end())\n      for (OMPClauseMappableExprCommon::MappableExprComponentListRef L :\n           MI->second.Components)\n        if (Check(L, MI->second.Kind))\n          return true;\n    return false;\n  }\n\n  /// Create a new mappable expression component list associated with a given\n  /// declaration and initialize it with the provided list of components.\n  void addMappableExpressionComponents(\n      const ValueDecl *VD,\n      OMPClauseMappableExprCommon::MappableExprComponentListRef Components,\n      OpenMPClauseKind WhereFoundClauseKind) {\n    MappedExprComponentTy &MEC = getTopOfStack().MappedExprComponents[VD];\n    // Create new entry and append the new components there.\n    MEC.Components.resize(MEC.Components.size() + 1);\n    MEC.Components.back().append(Components.begin(), Components.end());\n    MEC.Kind = WhereFoundClauseKind;\n  }\n\n  unsigned getNestingLevel() const {\n    assert(!isStackEmpty());\n    return getStackSize() - 1;\n  }\n  void addDoacrossDependClause(OMPDependClause *C,\n                               const OperatorOffsetTy &OpsOffs) {\n    SharingMapTy *Parent = getSecondOnStackOrNull();\n    assert(Parent && isOpenMPWorksharingDirective(Parent->Directive));\n    Parent->DoacrossDepends.try_emplace(C, OpsOffs);\n  }\n  llvm::iterator_range<DoacrossDependMapTy::const_iterator>\n  getDoacrossDependClauses() const {\n    const SharingMapTy &StackElem = getTopOfStack();\n    if (isOpenMPWorksharingDirective(StackElem.Directive)) {\n      const DoacrossDependMapTy &Ref = StackElem.DoacrossDepends;\n      return llvm::make_range(Ref.begin(), Ref.end());\n    }\n    return llvm::make_range(StackElem.DoacrossDepends.end(),\n                            StackElem.DoacrossDepends.end());\n  }\n\n  // Store types of classes which have been explicitly mapped\n  void addMappedClassesQualTypes(QualType QT) {\n    SharingMapTy &StackElem = getTopOfStack();\n    StackElem.MappedClassesQualTypes.insert(QT);\n  }\n\n  // Return set of mapped classes types\n  bool isClassPreviouslyMapped(QualType QT) const {\n    const SharingMapTy &StackElem = getTopOfStack();\n    return StackElem.MappedClassesQualTypes.count(QT) != 0;\n  }\n\n  /// Adds global declare target to the parent target region.\n  void addToParentTargetRegionLinkGlobals(DeclRefExpr *E) {\n    assert(*OMPDeclareTargetDeclAttr::isDeclareTargetDeclaration(\n               E->getDecl()) == OMPDeclareTargetDeclAttr::MT_Link &&\n           \"Expected declare target link global.\");\n    for (auto &Elem : *this) {\n      if (isOpenMPTargetExecutionDirective(Elem.Directive)) {\n        Elem.DeclareTargetLinkVarDecls.push_back(E);\n        return;\n      }\n    }\n  }\n\n  /// Returns the list of globals with declare target link if current directive\n  /// is target.\n  ArrayRef<DeclRefExpr *> getLinkGlobals() const {\n    assert(isOpenMPTargetExecutionDirective(getCurrentDirective()) &&\n           \"Expected target executable directive.\");\n    return getTopOfStack().DeclareTargetLinkVarDecls;\n  }\n\n  /// Adds list of allocators expressions.\n  void addInnerAllocatorExpr(Expr *E) {\n    getTopOfStack().InnerUsedAllocators.push_back(E);\n  }\n  /// Return list of used allocators.\n  ArrayRef<Expr *> getInnerAllocators() const {\n    return getTopOfStack().InnerUsedAllocators;\n  }\n  /// Marks the declaration as implicitly firstprivate nin the task-based\n  /// regions.\n  void addImplicitTaskFirstprivate(unsigned Level, Decl *D) {\n    getStackElemAtLevel(Level).ImplicitTaskFirstprivates.insert(D);\n  }\n  /// Checks if the decl is implicitly firstprivate in the task-based region.\n  bool isImplicitTaskFirstprivate(Decl *D) const {\n    return getTopOfStack().ImplicitTaskFirstprivates.count(D) > 0;\n  }\n\n  /// Marks decl as used in uses_allocators clause as the allocator.\n  void addUsesAllocatorsDecl(const Decl *D, UsesAllocatorsDeclKind Kind) {\n    getTopOfStack().UsesAllocatorsDecls.try_emplace(D, Kind);\n  }\n  /// Checks if specified decl is used in uses allocator clause as the\n  /// allocator.\n  Optional<UsesAllocatorsDeclKind> isUsesAllocatorsDecl(unsigned Level,\n                                                        const Decl *D) const {\n    const SharingMapTy &StackElem = getTopOfStack();\n    auto I = StackElem.UsesAllocatorsDecls.find(D);\n    if (I == StackElem.UsesAllocatorsDecls.end())\n      return None;\n    return I->getSecond();\n  }\n  Optional<UsesAllocatorsDeclKind> isUsesAllocatorsDecl(const Decl *D) const {\n    const SharingMapTy &StackElem = getTopOfStack();\n    auto I = StackElem.UsesAllocatorsDecls.find(D);\n    if (I == StackElem.UsesAllocatorsDecls.end())\n      return None;\n    return I->getSecond();\n  }\n\n  void addDeclareMapperVarRef(Expr *Ref) {\n    SharingMapTy &StackElem = getTopOfStack();\n    StackElem.DeclareMapperVar = Ref;\n  }\n  const Expr *getDeclareMapperVarRef() const {\n    const SharingMapTy *Top = getTopOfStackOrNull();\n    return Top ? Top->DeclareMapperVar : nullptr;\n  }\n};\n\nbool isImplicitTaskingRegion(OpenMPDirectiveKind DKind) {\n  return isOpenMPParallelDirective(DKind) || isOpenMPTeamsDirective(DKind);\n}\n\nbool isImplicitOrExplicitTaskingRegion(OpenMPDirectiveKind DKind) {\n  return isImplicitTaskingRegion(DKind) || isOpenMPTaskingDirective(DKind) ||\n         DKind == OMPD_unknown;\n}\n\n} // namespace\n\nstatic const Expr *getExprAsWritten(const Expr *E) {\n  if (const auto *FE = dyn_cast<FullExpr>(E))\n    E = FE->getSubExpr();\n\n  if (const auto *MTE = dyn_cast<MaterializeTemporaryExpr>(E))\n    E = MTE->getSubExpr();\n\n  while (const auto *Binder = dyn_cast<CXXBindTemporaryExpr>(E))\n    E = Binder->getSubExpr();\n\n  if (const auto *ICE = dyn_cast<ImplicitCastExpr>(E))\n    E = ICE->getSubExprAsWritten();\n  return E->IgnoreParens();\n}\n\nstatic Expr *getExprAsWritten(Expr *E) {\n  return const_cast<Expr *>(getExprAsWritten(const_cast<const Expr *>(E)));\n}\n\nstatic const ValueDecl *getCanonicalDecl(const ValueDecl *D) {\n  if (const auto *CED = dyn_cast<OMPCapturedExprDecl>(D))\n    if (const auto *ME = dyn_cast<MemberExpr>(getExprAsWritten(CED->getInit())))\n      D = ME->getMemberDecl();\n  const auto *VD = dyn_cast<VarDecl>(D);\n  const auto *FD = dyn_cast<FieldDecl>(D);\n  if (VD != nullptr) {\n    VD = VD->getCanonicalDecl();\n    D = VD;\n  } else {\n    assert(FD);\n    FD = FD->getCanonicalDecl();\n    D = FD;\n  }\n  return D;\n}\n\nstatic ValueDecl *getCanonicalDecl(ValueDecl *D) {\n  return const_cast<ValueDecl *>(\n      getCanonicalDecl(const_cast<const ValueDecl *>(D)));\n}\n\nDSAStackTy::DSAVarData DSAStackTy::getDSA(const_iterator &Iter,\n                                          ValueDecl *D) const {\n  D = getCanonicalDecl(D);\n  auto *VD = dyn_cast<VarDecl>(D);\n  const auto *FD = dyn_cast<FieldDecl>(D);\n  DSAVarData DVar;\n  if (Iter == end()) {\n    // OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced\n    // in a region but not in construct]\n    //  File-scope or namespace-scope variables referenced in called routines\n    //  in the region are shared unless they appear in a threadprivate\n    //  directive.\n    if (VD && !VD->isFunctionOrMethodVarDecl() && !isa<ParmVarDecl>(VD))\n      DVar.CKind = OMPC_shared;\n\n    // OpenMP [2.9.1.2, Data-sharing Attribute Rules for Variables Referenced\n    // in a region but not in construct]\n    //  Variables with static storage duration that are declared in called\n    //  routines in the region are shared.\n    if (VD && VD->hasGlobalStorage())\n      DVar.CKind = OMPC_shared;\n\n    // Non-static data members are shared by default.\n    if (FD)\n      DVar.CKind = OMPC_shared;\n\n    return DVar;\n  }\n\n  // OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced\n  // in a Construct, C/C++, predetermined, p.1]\n  // Variables with automatic storage duration that are declared in a scope\n  // inside the construct are private.\n  if (VD && isOpenMPLocal(VD, Iter) && VD->isLocalVarDecl() &&\n      (VD->getStorageClass() == SC_Auto || VD->getStorageClass() == SC_None)) {\n    DVar.CKind = OMPC_private;\n    return DVar;\n  }\n\n  DVar.DKind = Iter->Directive;\n  // Explicitly specified attributes and local variables with predetermined\n  // attributes.\n  if (Iter->SharingMap.count(D)) {\n    const DSAInfo &Data = Iter->SharingMap.lookup(D);\n    DVar.RefExpr = Data.RefExpr.getPointer();\n    DVar.PrivateCopy = Data.PrivateCopy;\n    DVar.CKind = Data.Attributes;\n    DVar.ImplicitDSALoc = Iter->DefaultAttrLoc;\n    DVar.Modifier = Data.Modifier;\n    DVar.AppliedToPointee = Data.AppliedToPointee;\n    return DVar;\n  }\n\n  // OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced\n  // in a Construct, C/C++, implicitly determined, p.1]\n  //  In a parallel or task construct, the data-sharing attributes of these\n  //  variables are determined by the default clause, if present.\n  switch (Iter->DefaultAttr) {\n  case DSA_shared:\n    DVar.CKind = OMPC_shared;\n    DVar.ImplicitDSALoc = Iter->DefaultAttrLoc;\n    return DVar;\n  case DSA_none:\n    return DVar;\n  case DSA_firstprivate:\n    if (VD->getStorageDuration() == SD_Static &&\n        VD->getDeclContext()->isFileContext()) {\n      DVar.CKind = OMPC_unknown;\n    } else {\n      DVar.CKind = OMPC_firstprivate;\n    }\n    DVar.ImplicitDSALoc = Iter->DefaultAttrLoc;\n    return DVar;\n  case DSA_unspecified:\n    // OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced\n    // in a Construct, implicitly determined, p.2]\n    //  In a parallel construct, if no default clause is present, these\n    //  variables are shared.\n    DVar.ImplicitDSALoc = Iter->DefaultAttrLoc;\n    if ((isOpenMPParallelDirective(DVar.DKind) &&\n         !isOpenMPTaskLoopDirective(DVar.DKind)) ||\n        isOpenMPTeamsDirective(DVar.DKind)) {\n      DVar.CKind = OMPC_shared;\n      return DVar;\n    }\n\n    // OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced\n    // in a Construct, implicitly determined, p.4]\n    //  In a task construct, if no default clause is present, a variable that in\n    //  the enclosing context is determined to be shared by all implicit tasks\n    //  bound to the current team is shared.\n    if (isOpenMPTaskingDirective(DVar.DKind)) {\n      DSAVarData DVarTemp;\n      const_iterator I = Iter, E = end();\n      do {\n        ++I;\n        // OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables\n        // Referenced in a Construct, implicitly determined, p.6]\n        //  In a task construct, if no default clause is present, a variable\n        //  whose data-sharing attribute is not determined by the rules above is\n        //  firstprivate.\n        DVarTemp = getDSA(I, D);\n        if (DVarTemp.CKind != OMPC_shared) {\n          DVar.RefExpr = nullptr;\n          DVar.CKind = OMPC_firstprivate;\n          return DVar;\n        }\n      } while (I != E && !isImplicitTaskingRegion(I->Directive));\n      DVar.CKind =\n          (DVarTemp.CKind == OMPC_unknown) ? OMPC_firstprivate : OMPC_shared;\n      return DVar;\n    }\n  }\n  // OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced\n  // in a Construct, implicitly determined, p.3]\n  //  For constructs other than task, if no default clause is present, these\n  //  variables inherit their data-sharing attributes from the enclosing\n  //  context.\n  return getDSA(++Iter, D);\n}\n\nconst Expr *DSAStackTy::addUniqueAligned(const ValueDecl *D,\n                                         const Expr *NewDE) {\n  assert(!isStackEmpty() && \"Data sharing attributes stack is empty\");\n  D = getCanonicalDecl(D);\n  SharingMapTy &StackElem = getTopOfStack();\n  auto It = StackElem.AlignedMap.find(D);\n  if (It == StackElem.AlignedMap.end()) {\n    assert(NewDE && \"Unexpected nullptr expr to be added into aligned map\");\n    StackElem.AlignedMap[D] = NewDE;\n    return nullptr;\n  }\n  assert(It->second && \"Unexpected nullptr expr in the aligned map\");\n  return It->second;\n}\n\nconst Expr *DSAStackTy::addUniqueNontemporal(const ValueDecl *D,\n                                             const Expr *NewDE) {\n  assert(!isStackEmpty() && \"Data sharing attributes stack is empty\");\n  D = getCanonicalDecl(D);\n  SharingMapTy &StackElem = getTopOfStack();\n  auto It = StackElem.NontemporalMap.find(D);\n  if (It == StackElem.NontemporalMap.end()) {\n    assert(NewDE && \"Unexpected nullptr expr to be added into aligned map\");\n    StackElem.NontemporalMap[D] = NewDE;\n    return nullptr;\n  }\n  assert(It->second && \"Unexpected nullptr expr in the aligned map\");\n  return It->second;\n}\n\nvoid DSAStackTy::addLoopControlVariable(const ValueDecl *D, VarDecl *Capture) {\n  assert(!isStackEmpty() && \"Data-sharing attributes stack is empty\");\n  D = getCanonicalDecl(D);\n  SharingMapTy &StackElem = getTopOfStack();\n  StackElem.LCVMap.try_emplace(\n      D, LCDeclInfo(StackElem.LCVMap.size() + 1, Capture));\n}\n\nconst DSAStackTy::LCDeclInfo\nDSAStackTy::isLoopControlVariable(const ValueDecl *D) const {\n  assert(!isStackEmpty() && \"Data-sharing attributes stack is empty\");\n  D = getCanonicalDecl(D);\n  const SharingMapTy &StackElem = getTopOfStack();\n  auto It = StackElem.LCVMap.find(D);\n  if (It != StackElem.LCVMap.end())\n    return It->second;\n  return {0, nullptr};\n}\n\nconst DSAStackTy::LCDeclInfo\nDSAStackTy::isLoopControlVariable(const ValueDecl *D, unsigned Level) const {\n  assert(!isStackEmpty() && \"Data-sharing attributes stack is empty\");\n  D = getCanonicalDecl(D);\n  for (unsigned I = Level + 1; I > 0; --I) {\n    const SharingMapTy &StackElem = getStackElemAtLevel(I - 1);\n    auto It = StackElem.LCVMap.find(D);\n    if (It != StackElem.LCVMap.end())\n      return It->second;\n  }\n  return {0, nullptr};\n}\n\nconst DSAStackTy::LCDeclInfo\nDSAStackTy::isParentLoopControlVariable(const ValueDecl *D) const {\n  const SharingMapTy *Parent = getSecondOnStackOrNull();\n  assert(Parent && \"Data-sharing attributes stack is empty\");\n  D = getCanonicalDecl(D);\n  auto It = Parent->LCVMap.find(D);\n  if (It != Parent->LCVMap.end())\n    return It->second;\n  return {0, nullptr};\n}\n\nconst ValueDecl *DSAStackTy::getParentLoopControlVariable(unsigned I) const {\n  const SharingMapTy *Parent = getSecondOnStackOrNull();\n  assert(Parent && \"Data-sharing attributes stack is empty\");\n  if (Parent->LCVMap.size() < I)\n    return nullptr;\n  for (const auto &Pair : Parent->LCVMap)\n    if (Pair.second.first == I)\n      return Pair.first;\n  return nullptr;\n}\n\nvoid DSAStackTy::addDSA(const ValueDecl *D, const Expr *E, OpenMPClauseKind A,\n                        DeclRefExpr *PrivateCopy, unsigned Modifier,\n                        bool AppliedToPointee) {\n  D = getCanonicalDecl(D);\n  if (A == OMPC_threadprivate) {\n    DSAInfo &Data = Threadprivates[D];\n    Data.Attributes = A;\n    Data.RefExpr.setPointer(E);\n    Data.PrivateCopy = nullptr;\n    Data.Modifier = Modifier;\n  } else {\n    DSAInfo &Data = getTopOfStack().SharingMap[D];\n    assert(Data.Attributes == OMPC_unknown || (A == Data.Attributes) ||\n           (A == OMPC_firstprivate && Data.Attributes == OMPC_lastprivate) ||\n           (A == OMPC_lastprivate && Data.Attributes == OMPC_firstprivate) ||\n           (isLoopControlVariable(D).first && A == OMPC_private));\n    Data.Modifier = Modifier;\n    if (A == OMPC_lastprivate && Data.Attributes == OMPC_firstprivate) {\n      Data.RefExpr.setInt(/*IntVal=*/true);\n      return;\n    }\n    const bool IsLastprivate =\n        A == OMPC_lastprivate || Data.Attributes == OMPC_lastprivate;\n    Data.Attributes = A;\n    Data.RefExpr.setPointerAndInt(E, IsLastprivate);\n    Data.PrivateCopy = PrivateCopy;\n    Data.AppliedToPointee = AppliedToPointee;\n    if (PrivateCopy) {\n      DSAInfo &Data = getTopOfStack().SharingMap[PrivateCopy->getDecl()];\n      Data.Modifier = Modifier;\n      Data.Attributes = A;\n      Data.RefExpr.setPointerAndInt(PrivateCopy, IsLastprivate);\n      Data.PrivateCopy = nullptr;\n      Data.AppliedToPointee = AppliedToPointee;\n    }\n  }\n}\n\n/// Build a variable declaration for OpenMP loop iteration variable.\nstatic VarDecl *buildVarDecl(Sema &SemaRef, SourceLocation Loc, QualType Type,\n                             StringRef Name, const AttrVec *Attrs = nullptr,\n                             DeclRefExpr *OrigRef = nullptr) {\n  DeclContext *DC = SemaRef.CurContext;\n  IdentifierInfo *II = &SemaRef.PP.getIdentifierTable().get(Name);\n  TypeSourceInfo *TInfo = SemaRef.Context.getTrivialTypeSourceInfo(Type, Loc);\n  auto *Decl =\n      VarDecl::Create(SemaRef.Context, DC, Loc, Loc, II, Type, TInfo, SC_None);\n  if (Attrs) {\n    for (specific_attr_iterator<AlignedAttr> I(Attrs->begin()), E(Attrs->end());\n         I != E; ++I)\n      Decl->addAttr(*I);\n  }\n  Decl->setImplicit();\n  if (OrigRef) {\n    Decl->addAttr(\n        OMPReferencedVarAttr::CreateImplicit(SemaRef.Context, OrigRef));\n  }\n  return Decl;\n}\n\nstatic DeclRefExpr *buildDeclRefExpr(Sema &S, VarDecl *D, QualType Ty,\n                                     SourceLocation Loc,\n                                     bool RefersToCapture = false) {\n  D->setReferenced();\n  D->markUsed(S.Context);\n  return DeclRefExpr::Create(S.getASTContext(), NestedNameSpecifierLoc(),\n                             SourceLocation(), D, RefersToCapture, Loc, Ty,\n                             VK_LValue);\n}\n\nvoid DSAStackTy::addTaskgroupReductionData(const ValueDecl *D, SourceRange SR,\n                                           BinaryOperatorKind BOK) {\n  D = getCanonicalDecl(D);\n  assert(!isStackEmpty() && \"Data-sharing attributes stack is empty\");\n  assert(\n      getTopOfStack().SharingMap[D].Attributes == OMPC_reduction &&\n      \"Additional reduction info may be specified only for reduction items.\");\n  ReductionData &ReductionData = getTopOfStack().ReductionMap[D];\n  assert(ReductionData.ReductionRange.isInvalid() &&\n         (getTopOfStack().Directive == OMPD_taskgroup ||\n          ((isOpenMPParallelDirective(getTopOfStack().Directive) ||\n            isOpenMPWorksharingDirective(getTopOfStack().Directive)) &&\n           !isOpenMPSimdDirective(getTopOfStack().Directive))) &&\n         \"Additional reduction info may be specified only once for reduction \"\n         \"items.\");\n  ReductionData.set(BOK, SR);\n  Expr *&TaskgroupReductionRef =\n      getTopOfStack().TaskgroupReductionRef;\n  if (!TaskgroupReductionRef) {\n    VarDecl *VD = buildVarDecl(SemaRef, SR.getBegin(),\n                               SemaRef.Context.VoidPtrTy, \".task_red.\");\n    TaskgroupReductionRef =\n        buildDeclRefExpr(SemaRef, VD, SemaRef.Context.VoidPtrTy, SR.getBegin());\n  }\n}\n\nvoid DSAStackTy::addTaskgroupReductionData(const ValueDecl *D, SourceRange SR,\n                                           const Expr *ReductionRef) {\n  D = getCanonicalDecl(D);\n  assert(!isStackEmpty() && \"Data-sharing attributes stack is empty\");\n  assert(\n      getTopOfStack().SharingMap[D].Attributes == OMPC_reduction &&\n      \"Additional reduction info may be specified only for reduction items.\");\n  ReductionData &ReductionData = getTopOfStack().ReductionMap[D];\n  assert(ReductionData.ReductionRange.isInvalid() &&\n         (getTopOfStack().Directive == OMPD_taskgroup ||\n          ((isOpenMPParallelDirective(getTopOfStack().Directive) ||\n            isOpenMPWorksharingDirective(getTopOfStack().Directive)) &&\n           !isOpenMPSimdDirective(getTopOfStack().Directive))) &&\n         \"Additional reduction info may be specified only once for reduction \"\n         \"items.\");\n  ReductionData.set(ReductionRef, SR);\n  Expr *&TaskgroupReductionRef =\n      getTopOfStack().TaskgroupReductionRef;\n  if (!TaskgroupReductionRef) {\n    VarDecl *VD = buildVarDecl(SemaRef, SR.getBegin(),\n                               SemaRef.Context.VoidPtrTy, \".task_red.\");\n    TaskgroupReductionRef =\n        buildDeclRefExpr(SemaRef, VD, SemaRef.Context.VoidPtrTy, SR.getBegin());\n  }\n}\n\nconst DSAStackTy::DSAVarData DSAStackTy::getTopMostTaskgroupReductionData(\n    const ValueDecl *D, SourceRange &SR, BinaryOperatorKind &BOK,\n    Expr *&TaskgroupDescriptor) const {\n  D = getCanonicalDecl(D);\n  assert(!isStackEmpty() && \"Data-sharing attributes stack is empty.\");\n  for (const_iterator I = begin() + 1, E = end(); I != E; ++I) {\n    const DSAInfo &Data = I->SharingMap.lookup(D);\n    if (Data.Attributes != OMPC_reduction ||\n        Data.Modifier != OMPC_REDUCTION_task)\n      continue;\n    const ReductionData &ReductionData = I->ReductionMap.lookup(D);\n    if (!ReductionData.ReductionOp ||\n        ReductionData.ReductionOp.is<const Expr *>())\n      return DSAVarData();\n    SR = ReductionData.ReductionRange;\n    BOK = ReductionData.ReductionOp.get<ReductionData::BOKPtrType>();\n    assert(I->TaskgroupReductionRef && \"taskgroup reduction reference \"\n                                       \"expression for the descriptor is not \"\n                                       \"set.\");\n    TaskgroupDescriptor = I->TaskgroupReductionRef;\n    return DSAVarData(I->Directive, OMPC_reduction, Data.RefExpr.getPointer(),\n                      Data.PrivateCopy, I->DefaultAttrLoc, OMPC_REDUCTION_task,\n                      /*AppliedToPointee=*/false);\n  }\n  return DSAVarData();\n}\n\nconst DSAStackTy::DSAVarData DSAStackTy::getTopMostTaskgroupReductionData(\n    const ValueDecl *D, SourceRange &SR, const Expr *&ReductionRef,\n    Expr *&TaskgroupDescriptor) const {\n  D = getCanonicalDecl(D);\n  assert(!isStackEmpty() && \"Data-sharing attributes stack is empty.\");\n  for (const_iterator I = begin() + 1, E = end(); I != E; ++I) {\n    const DSAInfo &Data = I->SharingMap.lookup(D);\n    if (Data.Attributes != OMPC_reduction ||\n        Data.Modifier != OMPC_REDUCTION_task)\n      continue;\n    const ReductionData &ReductionData = I->ReductionMap.lookup(D);\n    if (!ReductionData.ReductionOp ||\n        !ReductionData.ReductionOp.is<const Expr *>())\n      return DSAVarData();\n    SR = ReductionData.ReductionRange;\n    ReductionRef = ReductionData.ReductionOp.get<const Expr *>();\n    assert(I->TaskgroupReductionRef && \"taskgroup reduction reference \"\n                                       \"expression for the descriptor is not \"\n                                       \"set.\");\n    TaskgroupDescriptor = I->TaskgroupReductionRef;\n    return DSAVarData(I->Directive, OMPC_reduction, Data.RefExpr.getPointer(),\n                      Data.PrivateCopy, I->DefaultAttrLoc, OMPC_REDUCTION_task,\n                      /*AppliedToPointee=*/false);\n  }\n  return DSAVarData();\n}\n\nbool DSAStackTy::isOpenMPLocal(VarDecl *D, const_iterator I) const {\n  D = D->getCanonicalDecl();\n  for (const_iterator E = end(); I != E; ++I) {\n    if (isImplicitOrExplicitTaskingRegion(I->Directive) ||\n        isOpenMPTargetExecutionDirective(I->Directive)) {\n      if (I->CurScope) {\n        Scope *TopScope = I->CurScope->getParent();\n        Scope *CurScope = getCurScope();\n        while (CurScope && CurScope != TopScope && !CurScope->isDeclScope(D))\n          CurScope = CurScope->getParent();\n        return CurScope != TopScope;\n      }\n      for (DeclContext *DC = D->getDeclContext(); DC; DC = DC->getParent())\n        if (I->Context == DC)\n          return true;\n      return false;\n    }\n  }\n  return false;\n}\n\nstatic bool isConstNotMutableType(Sema &SemaRef, QualType Type,\n                                  bool AcceptIfMutable = true,\n                                  bool *IsClassType = nullptr) {\n  ASTContext &Context = SemaRef.getASTContext();\n  Type = Type.getNonReferenceType().getCanonicalType();\n  bool IsConstant = Type.isConstant(Context);\n  Type = Context.getBaseElementType(Type);\n  const CXXRecordDecl *RD = AcceptIfMutable && SemaRef.getLangOpts().CPlusPlus\n                                ? Type->getAsCXXRecordDecl()\n                                : nullptr;\n  if (const auto *CTSD = dyn_cast_or_null<ClassTemplateSpecializationDecl>(RD))\n    if (const ClassTemplateDecl *CTD = CTSD->getSpecializedTemplate())\n      RD = CTD->getTemplatedDecl();\n  if (IsClassType)\n    *IsClassType = RD;\n  return IsConstant && !(SemaRef.getLangOpts().CPlusPlus && RD &&\n                         RD->hasDefinition() && RD->hasMutableFields());\n}\n\nstatic bool rejectConstNotMutableType(Sema &SemaRef, const ValueDecl *D,\n                                      QualType Type, OpenMPClauseKind CKind,\n                                      SourceLocation ELoc,\n                                      bool AcceptIfMutable = true,\n                                      bool ListItemNotVar = false) {\n  ASTContext &Context = SemaRef.getASTContext();\n  bool IsClassType;\n  if (isConstNotMutableType(SemaRef, Type, AcceptIfMutable, &IsClassType)) {\n    unsigned Diag = ListItemNotVar\n                        ? diag::err_omp_const_list_item\n                        : IsClassType ? diag::err_omp_const_not_mutable_variable\n                                      : diag::err_omp_const_variable;\n    SemaRef.Diag(ELoc, Diag) << getOpenMPClauseName(CKind);\n    if (!ListItemNotVar && D) {\n      const VarDecl *VD = dyn_cast<VarDecl>(D);\n      bool IsDecl = !VD || VD->isThisDeclarationADefinition(Context) ==\n                               VarDecl::DeclarationOnly;\n      SemaRef.Diag(D->getLocation(),\n                   IsDecl ? diag::note_previous_decl : diag::note_defined_here)\n          << D;\n    }\n    return true;\n  }\n  return false;\n}\n\nconst DSAStackTy::DSAVarData DSAStackTy::getTopDSA(ValueDecl *D,\n                                                   bool FromParent) {\n  D = getCanonicalDecl(D);\n  DSAVarData DVar;\n\n  auto *VD = dyn_cast<VarDecl>(D);\n  auto TI = Threadprivates.find(D);\n  if (TI != Threadprivates.end()) {\n    DVar.RefExpr = TI->getSecond().RefExpr.getPointer();\n    DVar.CKind = OMPC_threadprivate;\n    DVar.Modifier = TI->getSecond().Modifier;\n    return DVar;\n  }\n  if (VD && VD->hasAttr<OMPThreadPrivateDeclAttr>()) {\n    DVar.RefExpr = buildDeclRefExpr(\n        SemaRef, VD, D->getType().getNonReferenceType(),\n        VD->getAttr<OMPThreadPrivateDeclAttr>()->getLocation());\n    DVar.CKind = OMPC_threadprivate;\n    addDSA(D, DVar.RefExpr, OMPC_threadprivate);\n    return DVar;\n  }\n  // OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced\n  // in a Construct, C/C++, predetermined, p.1]\n  //  Variables appearing in threadprivate directives are threadprivate.\n  if ((VD && VD->getTLSKind() != VarDecl::TLS_None &&\n       !(VD->hasAttr<OMPThreadPrivateDeclAttr>() &&\n         SemaRef.getLangOpts().OpenMPUseTLS &&\n         SemaRef.getASTContext().getTargetInfo().isTLSSupported())) ||\n      (VD && VD->getStorageClass() == SC_Register &&\n       VD->hasAttr<AsmLabelAttr>() && !VD->isLocalVarDecl())) {\n    DVar.RefExpr = buildDeclRefExpr(\n        SemaRef, VD, D->getType().getNonReferenceType(), D->getLocation());\n    DVar.CKind = OMPC_threadprivate;\n    addDSA(D, DVar.RefExpr, OMPC_threadprivate);\n    return DVar;\n  }\n  if (SemaRef.getLangOpts().OpenMPCUDAMode && VD &&\n      VD->isLocalVarDeclOrParm() && !isStackEmpty() &&\n      !isLoopControlVariable(D).first) {\n    const_iterator IterTarget =\n        std::find_if(begin(), end(), [](const SharingMapTy &Data) {\n          return isOpenMPTargetExecutionDirective(Data.Directive);\n        });\n    if (IterTarget != end()) {\n      const_iterator ParentIterTarget = IterTarget + 1;\n      for (const_iterator Iter = begin();\n           Iter != ParentIterTarget; ++Iter) {\n        if (isOpenMPLocal(VD, Iter)) {\n          DVar.RefExpr =\n              buildDeclRefExpr(SemaRef, VD, D->getType().getNonReferenceType(),\n                               D->getLocation());\n          DVar.CKind = OMPC_threadprivate;\n          return DVar;\n        }\n      }\n      if (!isClauseParsingMode() || IterTarget != begin()) {\n        auto DSAIter = IterTarget->SharingMap.find(D);\n        if (DSAIter != IterTarget->SharingMap.end() &&\n            isOpenMPPrivate(DSAIter->getSecond().Attributes)) {\n          DVar.RefExpr = DSAIter->getSecond().RefExpr.getPointer();\n          DVar.CKind = OMPC_threadprivate;\n          return DVar;\n        }\n        const_iterator End = end();\n        if (!SemaRef.isOpenMPCapturedByRef(\n                D, std::distance(ParentIterTarget, End),\n                /*OpenMPCaptureLevel=*/0)) {\n          DVar.RefExpr =\n              buildDeclRefExpr(SemaRef, VD, D->getType().getNonReferenceType(),\n                               IterTarget->ConstructLoc);\n          DVar.CKind = OMPC_threadprivate;\n          return DVar;\n        }\n      }\n    }\n  }\n\n  if (isStackEmpty())\n    // Not in OpenMP execution region and top scope was already checked.\n    return DVar;\n\n  // OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced\n  // in a Construct, C/C++, predetermined, p.4]\n  //  Static data members are shared.\n  // OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced\n  // in a Construct, C/C++, predetermined, p.7]\n  //  Variables with static storage duration that are declared in a scope\n  //  inside the construct are shared.\n  if (VD && VD->isStaticDataMember()) {\n    // Check for explicitly specified attributes.\n    const_iterator I = begin();\n    const_iterator EndI = end();\n    if (FromParent && I != EndI)\n      ++I;\n    if (I != EndI) {\n      auto It = I->SharingMap.find(D);\n      if (It != I->SharingMap.end()) {\n        const DSAInfo &Data = It->getSecond();\n        DVar.RefExpr = Data.RefExpr.getPointer();\n        DVar.PrivateCopy = Data.PrivateCopy;\n        DVar.CKind = Data.Attributes;\n        DVar.ImplicitDSALoc = I->DefaultAttrLoc;\n        DVar.DKind = I->Directive;\n        DVar.Modifier = Data.Modifier;\n        DVar.AppliedToPointee = Data.AppliedToPointee;\n        return DVar;\n      }\n    }\n\n    DVar.CKind = OMPC_shared;\n    return DVar;\n  }\n\n  auto &&MatchesAlways = [](OpenMPDirectiveKind) { return true; };\n  // The predetermined shared attribute for const-qualified types having no\n  // mutable members was removed after OpenMP 3.1.\n  if (SemaRef.LangOpts.OpenMP <= 31) {\n    // OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced\n    // in a Construct, C/C++, predetermined, p.6]\n    //  Variables with const qualified type having no mutable member are\n    //  shared.\n    if (isConstNotMutableType(SemaRef, D->getType())) {\n      // Variables with const-qualified type having no mutable member may be\n      // listed in a firstprivate clause, even if they are static data members.\n      DSAVarData DVarTemp = hasInnermostDSA(\n          D,\n          [](OpenMPClauseKind C, bool) {\n            return C == OMPC_firstprivate || C == OMPC_shared;\n          },\n          MatchesAlways, FromParent);\n      if (DVarTemp.CKind != OMPC_unknown && DVarTemp.RefExpr)\n        return DVarTemp;\n\n      DVar.CKind = OMPC_shared;\n      return DVar;\n    }\n  }\n\n  // Explicitly specified attributes and local variables with predetermined\n  // attributes.\n  const_iterator I = begin();\n  const_iterator EndI = end();\n  if (FromParent && I != EndI)\n    ++I;\n  if (I == EndI)\n    return DVar;\n  auto It = I->SharingMap.find(D);\n  if (It != I->SharingMap.end()) {\n    const DSAInfo &Data = It->getSecond();\n    DVar.RefExpr = Data.RefExpr.getPointer();\n    DVar.PrivateCopy = Data.PrivateCopy;\n    DVar.CKind = Data.Attributes;\n    DVar.ImplicitDSALoc = I->DefaultAttrLoc;\n    DVar.DKind = I->Directive;\n    DVar.Modifier = Data.Modifier;\n    DVar.AppliedToPointee = Data.AppliedToPointee;\n  }\n\n  return DVar;\n}\n\nconst DSAStackTy::DSAVarData DSAStackTy::getImplicitDSA(ValueDecl *D,\n                                                        bool FromParent) const {\n  if (isStackEmpty()) {\n    const_iterator I;\n    return getDSA(I, D);\n  }\n  D = getCanonicalDecl(D);\n  const_iterator StartI = begin();\n  const_iterator EndI = end();\n  if (FromParent && StartI != EndI)\n    ++StartI;\n  return getDSA(StartI, D);\n}\n\nconst DSAStackTy::DSAVarData DSAStackTy::getImplicitDSA(ValueDecl *D,\n                                                        unsigned Level) const {\n  if (getStackSize() <= Level)\n    return DSAVarData();\n  D = getCanonicalDecl(D);\n  const_iterator StartI = std::next(begin(), getStackSize() - 1 - Level);\n  return getDSA(StartI, D);\n}\n\nconst DSAStackTy::DSAVarData\nDSAStackTy::hasDSA(ValueDecl *D,\n                   const llvm::function_ref<bool(OpenMPClauseKind, bool)> CPred,\n                   const llvm::function_ref<bool(OpenMPDirectiveKind)> DPred,\n                   bool FromParent) const {\n  if (isStackEmpty())\n    return {};\n  D = getCanonicalDecl(D);\n  const_iterator I = begin();\n  const_iterator EndI = end();\n  if (FromParent && I != EndI)\n    ++I;\n  for (; I != EndI; ++I) {\n    if (!DPred(I->Directive) &&\n        !isImplicitOrExplicitTaskingRegion(I->Directive))\n      continue;\n    const_iterator NewI = I;\n    DSAVarData DVar = getDSA(NewI, D);\n    if (I == NewI && CPred(DVar.CKind, DVar.AppliedToPointee))\n      return DVar;\n  }\n  return {};\n}\n\nconst DSAStackTy::DSAVarData DSAStackTy::hasInnermostDSA(\n    ValueDecl *D, const llvm::function_ref<bool(OpenMPClauseKind, bool)> CPred,\n    const llvm::function_ref<bool(OpenMPDirectiveKind)> DPred,\n    bool FromParent) const {\n  if (isStackEmpty())\n    return {};\n  D = getCanonicalDecl(D);\n  const_iterator StartI = begin();\n  const_iterator EndI = end();\n  if (FromParent && StartI != EndI)\n    ++StartI;\n  if (StartI == EndI || !DPred(StartI->Directive))\n    return {};\n  const_iterator NewI = StartI;\n  DSAVarData DVar = getDSA(NewI, D);\n  return (NewI == StartI && CPred(DVar.CKind, DVar.AppliedToPointee))\n             ? DVar\n             : DSAVarData();\n}\n\nbool DSAStackTy::hasExplicitDSA(\n    const ValueDecl *D,\n    const llvm::function_ref<bool(OpenMPClauseKind, bool)> CPred,\n    unsigned Level, bool NotLastprivate) const {\n  if (getStackSize() <= Level)\n    return false;\n  D = getCanonicalDecl(D);\n  const SharingMapTy &StackElem = getStackElemAtLevel(Level);\n  auto I = StackElem.SharingMap.find(D);\n  if (I != StackElem.SharingMap.end() && I->getSecond().RefExpr.getPointer() &&\n      CPred(I->getSecond().Attributes, I->getSecond().AppliedToPointee) &&\n      (!NotLastprivate || !I->getSecond().RefExpr.getInt()))\n    return true;\n  // Check predetermined rules for the loop control variables.\n  auto LI = StackElem.LCVMap.find(D);\n  if (LI != StackElem.LCVMap.end())\n    return CPred(OMPC_private, /*AppliedToPointee=*/false);\n  return false;\n}\n\nbool DSAStackTy::hasExplicitDirective(\n    const llvm::function_ref<bool(OpenMPDirectiveKind)> DPred,\n    unsigned Level) const {\n  if (getStackSize() <= Level)\n    return false;\n  const SharingMapTy &StackElem = getStackElemAtLevel(Level);\n  return DPred(StackElem.Directive);\n}\n\nbool DSAStackTy::hasDirective(\n    const llvm::function_ref<bool(OpenMPDirectiveKind,\n                                  const DeclarationNameInfo &, SourceLocation)>\n        DPred,\n    bool FromParent) const {\n  // We look only in the enclosing region.\n  size_t Skip = FromParent ? 2 : 1;\n  for (const_iterator I = begin() + std::min(Skip, getStackSize()), E = end();\n       I != E; ++I) {\n    if (DPred(I->Directive, I->DirectiveName, I->ConstructLoc))\n      return true;\n  }\n  return false;\n}\n\nvoid Sema::InitDataSharingAttributesStack() {\n  VarDataSharingAttributesStack = new DSAStackTy(*this);\n}\n\n#define DSAStack static_cast<DSAStackTy *>(VarDataSharingAttributesStack)\n\nvoid Sema::pushOpenMPFunctionRegion() {\n  DSAStack->pushFunction();\n}\n\nvoid Sema::popOpenMPFunctionRegion(const FunctionScopeInfo *OldFSI) {\n  DSAStack->popFunction(OldFSI);\n}\n\nstatic bool isOpenMPDeviceDelayedContext(Sema &S) {\n  assert(S.LangOpts.OpenMP && S.LangOpts.OpenMPIsDevice &&\n         \"Expected OpenMP device compilation.\");\n  return !S.isInOpenMPTargetExecutionDirective();\n}\n\nnamespace {\n/// Status of the function emission on the host/device.\nenum class FunctionEmissionStatus {\n  Emitted,\n  Discarded,\n  Unknown,\n};\n} // anonymous namespace\n\nSema::SemaDiagnosticBuilder Sema::diagIfOpenMPDeviceCode(SourceLocation Loc,\n                                                         unsigned DiagID,\n                                                         FunctionDecl *FD) {\n  assert(LangOpts.OpenMP && LangOpts.OpenMPIsDevice &&\n         \"Expected OpenMP device compilation.\");\n\n  SemaDiagnosticBuilder::Kind Kind = SemaDiagnosticBuilder::K_Nop;\n  if (FD) {\n    FunctionEmissionStatus FES = getEmissionStatus(FD);\n    switch (FES) {\n    case FunctionEmissionStatus::Emitted:\n      Kind = SemaDiagnosticBuilder::K_Immediate;\n      break;\n    case FunctionEmissionStatus::Unknown:\n      // TODO: We should always delay diagnostics here in case a target\n      //       region is in a function we do not emit. However, as the\n      //       current diagnostics are associated with the function containing\n      //       the target region and we do not emit that one, we would miss out\n      //       on diagnostics for the target region itself. We need to anchor\n      //       the diagnostics with the new generated function *or* ensure we\n      //       emit diagnostics associated with the surrounding function.\n      Kind = isOpenMPDeviceDelayedContext(*this)\n                 ? SemaDiagnosticBuilder::K_Deferred\n                 : SemaDiagnosticBuilder::K_Immediate;\n      break;\n    case FunctionEmissionStatus::TemplateDiscarded:\n    case FunctionEmissionStatus::OMPDiscarded:\n      Kind = SemaDiagnosticBuilder::K_Nop;\n      break;\n    case FunctionEmissionStatus::CUDADiscarded:\n      llvm_unreachable(\"CUDADiscarded unexpected in OpenMP device compilation\");\n      break;\n    }\n  }\n\n  return SemaDiagnosticBuilder(Kind, Loc, DiagID, FD, *this);\n}\n\nSema::SemaDiagnosticBuilder Sema::diagIfOpenMPHostCode(SourceLocation Loc,\n                                                       unsigned DiagID,\n                                                       FunctionDecl *FD) {\n  assert(LangOpts.OpenMP && !LangOpts.OpenMPIsDevice &&\n         \"Expected OpenMP host compilation.\");\n  FunctionEmissionStatus FES = getEmissionStatus(FD);\n  SemaDiagnosticBuilder::Kind Kind = SemaDiagnosticBuilder::K_Nop;\n  switch (FES) {\n  case FunctionEmissionStatus::Emitted:\n    Kind = SemaDiagnosticBuilder::K_Immediate;\n    break;\n  case FunctionEmissionStatus::Unknown:\n    Kind = SemaDiagnosticBuilder::K_Deferred;\n    break;\n  case FunctionEmissionStatus::TemplateDiscarded:\n  case FunctionEmissionStatus::OMPDiscarded:\n  case FunctionEmissionStatus::CUDADiscarded:\n    Kind = SemaDiagnosticBuilder::K_Nop;\n    break;\n  }\n\n  return SemaDiagnosticBuilder(Kind, Loc, DiagID, FD, *this);\n}\n\nstatic OpenMPDefaultmapClauseKind\ngetVariableCategoryFromDecl(const LangOptions &LO, const ValueDecl *VD) {\n  if (LO.OpenMP <= 45) {\n    if (VD->getType().getNonReferenceType()->isScalarType())\n      return OMPC_DEFAULTMAP_scalar;\n    return OMPC_DEFAULTMAP_aggregate;\n  }\n  if (VD->getType().getNonReferenceType()->isAnyPointerType())\n    return OMPC_DEFAULTMAP_pointer;\n  if (VD->getType().getNonReferenceType()->isScalarType())\n    return OMPC_DEFAULTMAP_scalar;\n  return OMPC_DEFAULTMAP_aggregate;\n}\n\nbool Sema::isOpenMPCapturedByRef(const ValueDecl *D, unsigned Level,\n                                 unsigned OpenMPCaptureLevel) const {\n  assert(LangOpts.OpenMP && \"OpenMP is not allowed\");\n\n  ASTContext &Ctx = getASTContext();\n  bool IsByRef = true;\n\n  // Find the directive that is associated with the provided scope.\n  D = cast<ValueDecl>(D->getCanonicalDecl());\n  QualType Ty = D->getType();\n\n  bool IsVariableUsedInMapClause = false;\n  if (DSAStack->hasExplicitDirective(isOpenMPTargetExecutionDirective, Level)) {\n    // This table summarizes how a given variable should be passed to the device\n    // given its type and the clauses where it appears. This table is based on\n    // the description in OpenMP 4.5 [2.10.4, target Construct] and\n    // OpenMP 4.5 [2.15.5, Data-mapping Attribute Rules and Clauses].\n    //\n    // =========================================================================\n    // | type |  defaultmap   | pvt | first | is_device_ptr |    map   | res.  |\n    // |      |(tofrom:scalar)|     |  pvt  |               |          |       |\n    // =========================================================================\n    // | scl  |               |     |       |       -       |          | bycopy|\n    // | scl  |               |  -  |   x   |       -       |     -    | bycopy|\n    // | scl  |               |  x  |   -   |       -       |     -    | null  |\n    // | scl  |       x       |     |       |       -       |          | byref |\n    // | scl  |       x       |  -  |   x   |       -       |     -    | bycopy|\n    // | scl  |       x       |  x  |   -   |       -       |     -    | null  |\n    // | scl  |               |  -  |   -   |       -       |     x    | byref |\n    // | scl  |       x       |  -  |   -   |       -       |     x    | byref |\n    //\n    // | agg  |      n.a.     |     |       |       -       |          | byref |\n    // | agg  |      n.a.     |  -  |   x   |       -       |     -    | byref |\n    // | agg  |      n.a.     |  x  |   -   |       -       |     -    | null  |\n    // | agg  |      n.a.     |  -  |   -   |       -       |     x    | byref |\n    // | agg  |      n.a.     |  -  |   -   |       -       |    x[]   | byref |\n    //\n    // | ptr  |      n.a.     |     |       |       -       |          | bycopy|\n    // | ptr  |      n.a.     |  -  |   x   |       -       |     -    | bycopy|\n    // | ptr  |      n.a.     |  x  |   -   |       -       |     -    | null  |\n    // | ptr  |      n.a.     |  -  |   -   |       -       |     x    | byref |\n    // | ptr  |      n.a.     |  -  |   -   |       -       |    x[]   | bycopy|\n    // | ptr  |      n.a.     |  -  |   -   |       x       |          | bycopy|\n    // | ptr  |      n.a.     |  -  |   -   |       x       |     x    | bycopy|\n    // | ptr  |      n.a.     |  -  |   -   |       x       |    x[]   | bycopy|\n    // =========================================================================\n    // Legend:\n    //  scl - scalar\n    //  ptr - pointer\n    //  agg - aggregate\n    //  x - applies\n    //  - - invalid in this combination\n    //  [] - mapped with an array section\n    //  byref - should be mapped by reference\n    //  byval - should be mapped by value\n    //  null - initialize a local variable to null on the device\n    //\n    // Observations:\n    //  - All scalar declarations that show up in a map clause have to be passed\n    //    by reference, because they may have been mapped in the enclosing data\n    //    environment.\n    //  - If the scalar value does not fit the size of uintptr, it has to be\n    //    passed by reference, regardless the result in the table above.\n    //  - For pointers mapped by value that have either an implicit map or an\n    //    array section, the runtime library may pass the NULL value to the\n    //    device instead of the value passed to it by the compiler.\n\n    if (Ty->isReferenceType())\n      Ty = Ty->castAs<ReferenceType>()->getPointeeType();\n\n    // Locate map clauses and see if the variable being captured is referred to\n    // in any of those clauses. Here we only care about variables, not fields,\n    // because fields are part of aggregates.\n    bool IsVariableAssociatedWithSection = false;\n\n    DSAStack->checkMappableExprComponentListsForDeclAtLevel(\n        D, Level,\n        [&IsVariableUsedInMapClause, &IsVariableAssociatedWithSection, D](\n            OMPClauseMappableExprCommon::MappableExprComponentListRef\n                MapExprComponents,\n            OpenMPClauseKind WhereFoundClauseKind) {\n          // Only the map clause information influences how a variable is\n          // captured. E.g. is_device_ptr does not require changing the default\n          // behavior.\n          if (WhereFoundClauseKind != OMPC_map)\n            return false;\n\n          auto EI = MapExprComponents.rbegin();\n          auto EE = MapExprComponents.rend();\n\n          assert(EI != EE && \"Invalid map expression!\");\n\n          if (isa<DeclRefExpr>(EI->getAssociatedExpression()))\n            IsVariableUsedInMapClause |= EI->getAssociatedDeclaration() == D;\n\n          ++EI;\n          if (EI == EE)\n            return false;\n\n          if (isa<ArraySubscriptExpr>(EI->getAssociatedExpression()) ||\n              isa<OMPArraySectionExpr>(EI->getAssociatedExpression()) ||\n              isa<MemberExpr>(EI->getAssociatedExpression()) ||\n              isa<OMPArrayShapingExpr>(EI->getAssociatedExpression())) {\n            IsVariableAssociatedWithSection = true;\n            // There is nothing more we need to know about this variable.\n            return true;\n          }\n\n          // Keep looking for more map info.\n          return false;\n        });\n\n    if (IsVariableUsedInMapClause) {\n      // If variable is identified in a map clause it is always captured by\n      // reference except if it is a pointer that is dereferenced somehow.\n      IsByRef = !(Ty->isPointerType() && IsVariableAssociatedWithSection);\n    } else {\n      // By default, all the data that has a scalar type is mapped by copy\n      // (except for reduction variables).\n      // Defaultmap scalar is mutual exclusive to defaultmap pointer\n      IsByRef = (DSAStack->isForceCaptureByReferenceInTargetExecutable() &&\n                 !Ty->isAnyPointerType()) ||\n                !Ty->isScalarType() ||\n                DSAStack->isDefaultmapCapturedByRef(\n                    Level, getVariableCategoryFromDecl(LangOpts, D)) ||\n                DSAStack->hasExplicitDSA(\n                    D,\n                    [](OpenMPClauseKind K, bool AppliedToPointee) {\n                      return K == OMPC_reduction && !AppliedToPointee;\n                    },\n                    Level);\n    }\n  }\n\n  if (IsByRef && Ty.getNonReferenceType()->isScalarType()) {\n    IsByRef =\n        ((IsVariableUsedInMapClause &&\n          DSAStack->getCaptureRegion(Level, OpenMPCaptureLevel) ==\n              OMPD_target) ||\n         !(DSAStack->hasExplicitDSA(\n               D,\n               [](OpenMPClauseKind K, bool AppliedToPointee) -> bool {\n                 return K == OMPC_firstprivate ||\n                        (K == OMPC_reduction && AppliedToPointee);\n               },\n               Level, /*NotLastprivate=*/true) ||\n           DSAStack->isUsesAllocatorsDecl(Level, D))) &&\n        // If the variable is artificial and must be captured by value - try to\n        // capture by value.\n        !(isa<OMPCapturedExprDecl>(D) && !D->hasAttr<OMPCaptureNoInitAttr>() &&\n          !cast<OMPCapturedExprDecl>(D)->getInit()->isGLValue()) &&\n        // If the variable is implicitly firstprivate and scalar - capture by\n        // copy\n        !(DSAStack->getDefaultDSA() == DSA_firstprivate &&\n          !DSAStack->hasExplicitDSA(\n              D, [](OpenMPClauseKind K, bool) { return K != OMPC_unknown; },\n              Level) &&\n          !DSAStack->isLoopControlVariable(D, Level).first);\n  }\n\n  // When passing data by copy, we need to make sure it fits the uintptr size\n  // and alignment, because the runtime library only deals with uintptr types.\n  // If it does not fit the uintptr size, we need to pass the data by reference\n  // instead.\n  if (!IsByRef &&\n      (Ctx.getTypeSizeInChars(Ty) >\n           Ctx.getTypeSizeInChars(Ctx.getUIntPtrType()) ||\n       Ctx.getDeclAlign(D) > Ctx.getTypeAlignInChars(Ctx.getUIntPtrType()))) {\n    IsByRef = true;\n  }\n\n  return IsByRef;\n}\n\nunsigned Sema::getOpenMPNestingLevel() const {\n  assert(getLangOpts().OpenMP);\n  return DSAStack->getNestingLevel();\n}\n\nbool Sema::isInOpenMPTargetExecutionDirective() const {\n  return (isOpenMPTargetExecutionDirective(DSAStack->getCurrentDirective()) &&\n          !DSAStack->isClauseParsingMode()) ||\n         DSAStack->hasDirective(\n             [](OpenMPDirectiveKind K, const DeclarationNameInfo &,\n                SourceLocation) -> bool {\n               return isOpenMPTargetExecutionDirective(K);\n             },\n             false);\n}\n\nVarDecl *Sema::isOpenMPCapturedDecl(ValueDecl *D, bool CheckScopeInfo,\n                                    unsigned StopAt) {\n  assert(LangOpts.OpenMP && \"OpenMP is not allowed\");\n  D = getCanonicalDecl(D);\n\n  auto *VD = dyn_cast<VarDecl>(D);\n  // Do not capture constexpr variables.\n  if (VD && VD->isConstexpr())\n    return nullptr;\n\n  // If we want to determine whether the variable should be captured from the\n  // perspective of the current capturing scope, and we've already left all the\n  // capturing scopes of the top directive on the stack, check from the\n  // perspective of its parent directive (if any) instead.\n  DSAStackTy::ParentDirectiveScope InParentDirectiveRAII(\n      *DSAStack, CheckScopeInfo && DSAStack->isBodyComplete());\n\n  // If we are attempting to capture a global variable in a directive with\n  // 'target' we return true so that this global is also mapped to the device.\n  //\n  if (VD && !VD->hasLocalStorage() &&\n      (getCurCapturedRegion() || getCurBlock() || getCurLambda())) {\n    if (isInOpenMPDeclareTargetContext()) {\n      // Try to mark variable as declare target if it is used in capturing\n      // regions.\n      if (LangOpts.OpenMP <= 45 &&\n          !OMPDeclareTargetDeclAttr::isDeclareTargetDeclaration(VD))\n        checkDeclIsAllowedInOpenMPTarget(nullptr, VD);\n      return nullptr;\n    }\n    if (isInOpenMPTargetExecutionDirective()) {\n      // If the declaration is enclosed in a 'declare target' directive,\n      // then it should not be captured.\n      //\n      if (OMPDeclareTargetDeclAttr::isDeclareTargetDeclaration(VD))\n        return nullptr;\n      CapturedRegionScopeInfo *CSI = nullptr;\n      for (FunctionScopeInfo *FSI : llvm::drop_begin(\n               llvm::reverse(FunctionScopes),\n               CheckScopeInfo ? (FunctionScopes.size() - (StopAt + 1)) : 0)) {\n        if (!isa<CapturingScopeInfo>(FSI))\n          return nullptr;\n        if (auto *RSI = dyn_cast<CapturedRegionScopeInfo>(FSI))\n          if (RSI->CapRegionKind == CR_OpenMP) {\n            CSI = RSI;\n            break;\n          }\n      }\n      assert(CSI && \"Failed to find CapturedRegionScopeInfo\");\n      SmallVector<OpenMPDirectiveKind, 4> Regions;\n      getOpenMPCaptureRegions(Regions,\n                              DSAStack->getDirective(CSI->OpenMPLevel));\n      if (Regions[CSI->OpenMPCaptureLevel] != OMPD_task)\n        return VD;\n    }\n  }\n\n  if (CheckScopeInfo) {\n    bool OpenMPFound = false;\n    for (unsigned I = StopAt + 1; I > 0; --I) {\n      FunctionScopeInfo *FSI = FunctionScopes[I - 1];\n      if(!isa<CapturingScopeInfo>(FSI))\n        return nullptr;\n      if (auto *RSI = dyn_cast<CapturedRegionScopeInfo>(FSI))\n        if (RSI->CapRegionKind == CR_OpenMP) {\n          OpenMPFound = true;\n          break;\n        }\n    }\n    if (!OpenMPFound)\n      return nullptr;\n  }\n\n  if (DSAStack->getCurrentDirective() != OMPD_unknown &&\n      (!DSAStack->isClauseParsingMode() ||\n       DSAStack->getParentDirective() != OMPD_unknown)) {\n    auto &&Info = DSAStack->isLoopControlVariable(D);\n    if (Info.first ||\n        (VD && VD->hasLocalStorage() &&\n         isImplicitOrExplicitTaskingRegion(DSAStack->getCurrentDirective())) ||\n        (VD && DSAStack->isForceVarCapturing()))\n      return VD ? VD : Info.second;\n    DSAStackTy::DSAVarData DVarTop =\n        DSAStack->getTopDSA(D, DSAStack->isClauseParsingMode());\n    if (DVarTop.CKind != OMPC_unknown && isOpenMPPrivate(DVarTop.CKind) &&\n        (!VD || VD->hasLocalStorage() || !DVarTop.AppliedToPointee))\n      return VD ? VD : cast<VarDecl>(DVarTop.PrivateCopy->getDecl());\n    // Threadprivate variables must not be captured.\n    if (isOpenMPThreadPrivate(DVarTop.CKind))\n      return nullptr;\n    // The variable is not private or it is the variable in the directive with\n    // default(none) clause and not used in any clause.\n    DSAStackTy::DSAVarData DVarPrivate = DSAStack->hasDSA(\n        D,\n        [](OpenMPClauseKind C, bool AppliedToPointee) {\n          return isOpenMPPrivate(C) && !AppliedToPointee;\n        },\n        [](OpenMPDirectiveKind) { return true; },\n        DSAStack->isClauseParsingMode());\n    // Global shared must not be captured.\n    if (VD && !VD->hasLocalStorage() && DVarPrivate.CKind == OMPC_unknown &&\n        ((DSAStack->getDefaultDSA() != DSA_none &&\n          DSAStack->getDefaultDSA() != DSA_firstprivate) ||\n         DVarTop.CKind == OMPC_shared))\n      return nullptr;\n    if (DVarPrivate.CKind != OMPC_unknown ||\n        (VD && (DSAStack->getDefaultDSA() == DSA_none ||\n                DSAStack->getDefaultDSA() == DSA_firstprivate)))\n      return VD ? VD : cast<VarDecl>(DVarPrivate.PrivateCopy->getDecl());\n  }\n  return nullptr;\n}\n\nvoid Sema::adjustOpenMPTargetScopeIndex(unsigned &FunctionScopesIndex,\n                                        unsigned Level) const {\n  FunctionScopesIndex -= getOpenMPCaptureLevels(DSAStack->getDirective(Level));\n}\n\nvoid Sema::startOpenMPLoop() {\n  assert(LangOpts.OpenMP && \"OpenMP must be enabled.\");\n  if (isOpenMPLoopDirective(DSAStack->getCurrentDirective()))\n    DSAStack->loopInit();\n}\n\nvoid Sema::startOpenMPCXXRangeFor() {\n  assert(LangOpts.OpenMP && \"OpenMP must be enabled.\");\n  if (isOpenMPLoopDirective(DSAStack->getCurrentDirective())) {\n    DSAStack->resetPossibleLoopCounter();\n    DSAStack->loopStart();\n  }\n}\n\nOpenMPClauseKind Sema::isOpenMPPrivateDecl(ValueDecl *D, unsigned Level,\n                                           unsigned CapLevel) const {\n  assert(LangOpts.OpenMP && \"OpenMP is not allowed\");\n  if (DSAStack->hasExplicitDirective(\n          [](OpenMPDirectiveKind K) { return isOpenMPTaskingDirective(K); },\n          Level)) {\n    bool IsTriviallyCopyable =\n        D->getType().getNonReferenceType().isTriviallyCopyableType(Context) &&\n        !D->getType()\n             .getNonReferenceType()\n             .getCanonicalType()\n             ->getAsCXXRecordDecl();\n    OpenMPDirectiveKind DKind = DSAStack->getDirective(Level);\n    SmallVector<OpenMPDirectiveKind, 4> CaptureRegions;\n    getOpenMPCaptureRegions(CaptureRegions, DKind);\n    if (isOpenMPTaskingDirective(CaptureRegions[CapLevel]) &&\n        (IsTriviallyCopyable ||\n         !isOpenMPTaskLoopDirective(CaptureRegions[CapLevel]))) {\n      if (DSAStack->hasExplicitDSA(\n              D,\n              [](OpenMPClauseKind K, bool) { return K == OMPC_firstprivate; },\n              Level, /*NotLastprivate=*/true))\n        return OMPC_firstprivate;\n      DSAStackTy::DSAVarData DVar = DSAStack->getImplicitDSA(D, Level);\n      if (DVar.CKind != OMPC_shared &&\n          !DSAStack->isLoopControlVariable(D, Level).first && !DVar.RefExpr) {\n        DSAStack->addImplicitTaskFirstprivate(Level, D);\n        return OMPC_firstprivate;\n      }\n    }\n  }\n  if (isOpenMPLoopDirective(DSAStack->getCurrentDirective())) {\n    if (DSAStack->getAssociatedLoops() > 0 &&\n        !DSAStack->isLoopStarted()) {\n      DSAStack->resetPossibleLoopCounter(D);\n      DSAStack->loopStart();\n      return OMPC_private;\n    }\n    if ((DSAStack->getPossiblyLoopCunter() == D->getCanonicalDecl() ||\n         DSAStack->isLoopControlVariable(D).first) &&\n        !DSAStack->hasExplicitDSA(\n            D, [](OpenMPClauseKind K, bool) { return K != OMPC_private; },\n            Level) &&\n        !isOpenMPSimdDirective(DSAStack->getCurrentDirective()))\n      return OMPC_private;\n  }\n  if (const auto *VD = dyn_cast<VarDecl>(D)) {\n    if (DSAStack->isThreadPrivate(const_cast<VarDecl *>(VD)) &&\n        DSAStack->isForceVarCapturing() &&\n        !DSAStack->hasExplicitDSA(\n            D, [](OpenMPClauseKind K, bool) { return K == OMPC_copyin; },\n            Level))\n      return OMPC_private;\n  }\n  // User-defined allocators are private since they must be defined in the\n  // context of target region.\n  if (DSAStack->hasExplicitDirective(isOpenMPTargetExecutionDirective, Level) &&\n      DSAStack->isUsesAllocatorsDecl(Level, D).getValueOr(\n          DSAStackTy::UsesAllocatorsDeclKind::AllocatorTrait) ==\n          DSAStackTy::UsesAllocatorsDeclKind::UserDefinedAllocator)\n    return OMPC_private;\n  return (DSAStack->hasExplicitDSA(\n              D, [](OpenMPClauseKind K, bool) { return K == OMPC_private; },\n              Level) ||\n          (DSAStack->isClauseParsingMode() &&\n           DSAStack->getClauseParsingMode() == OMPC_private) ||\n          // Consider taskgroup reduction descriptor variable a private\n          // to avoid possible capture in the region.\n          (DSAStack->hasExplicitDirective(\n               [](OpenMPDirectiveKind K) {\n                 return K == OMPD_taskgroup ||\n                        ((isOpenMPParallelDirective(K) ||\n                          isOpenMPWorksharingDirective(K)) &&\n                         !isOpenMPSimdDirective(K));\n               },\n               Level) &&\n           DSAStack->isTaskgroupReductionRef(D, Level)))\n             ? OMPC_private\n             : OMPC_unknown;\n}\n\nvoid Sema::setOpenMPCaptureKind(FieldDecl *FD, const ValueDecl *D,\n                                unsigned Level) {\n  assert(LangOpts.OpenMP && \"OpenMP is not allowed\");\n  D = getCanonicalDecl(D);\n  OpenMPClauseKind OMPC = OMPC_unknown;\n  for (unsigned I = DSAStack->getNestingLevel() + 1; I > Level; --I) {\n    const unsigned NewLevel = I - 1;\n    if (DSAStack->hasExplicitDSA(\n            D,\n            [&OMPC](const OpenMPClauseKind K, bool AppliedToPointee) {\n              if (isOpenMPPrivate(K) && !AppliedToPointee) {\n                OMPC = K;\n                return true;\n              }\n              return false;\n            },\n            NewLevel))\n      break;\n    if (DSAStack->checkMappableExprComponentListsForDeclAtLevel(\n            D, NewLevel,\n            [](OMPClauseMappableExprCommon::MappableExprComponentListRef,\n               OpenMPClauseKind) { return true; })) {\n      OMPC = OMPC_map;\n      break;\n    }\n    if (DSAStack->hasExplicitDirective(isOpenMPTargetExecutionDirective,\n                                       NewLevel)) {\n      OMPC = OMPC_map;\n      if (DSAStack->mustBeFirstprivateAtLevel(\n              NewLevel, getVariableCategoryFromDecl(LangOpts, D)))\n        OMPC = OMPC_firstprivate;\n      break;\n    }\n  }\n  if (OMPC != OMPC_unknown)\n    FD->addAttr(OMPCaptureKindAttr::CreateImplicit(Context, unsigned(OMPC)));\n}\n\nbool Sema::isOpenMPTargetCapturedDecl(const ValueDecl *D, unsigned Level,\n                                      unsigned CaptureLevel) const {\n  assert(LangOpts.OpenMP && \"OpenMP is not allowed\");\n  // Return true if the current level is no longer enclosed in a target region.\n\n  SmallVector<OpenMPDirectiveKind, 4> Regions;\n  getOpenMPCaptureRegions(Regions, DSAStack->getDirective(Level));\n  const auto *VD = dyn_cast<VarDecl>(D);\n  return VD && !VD->hasLocalStorage() &&\n         DSAStack->hasExplicitDirective(isOpenMPTargetExecutionDirective,\n                                        Level) &&\n         Regions[CaptureLevel] != OMPD_task;\n}\n\nbool Sema::isOpenMPGlobalCapturedDecl(ValueDecl *D, unsigned Level,\n                                      unsigned CaptureLevel) const {\n  assert(LangOpts.OpenMP && \"OpenMP is not allowed\");\n  // Return true if the current level is no longer enclosed in a target region.\n\n  if (const auto *VD = dyn_cast<VarDecl>(D)) {\n    if (!VD->hasLocalStorage()) {\n      if (isInOpenMPTargetExecutionDirective())\n        return true;\n      DSAStackTy::DSAVarData TopDVar =\n          DSAStack->getTopDSA(D, /*FromParent=*/false);\n      unsigned NumLevels =\n          getOpenMPCaptureLevels(DSAStack->getDirective(Level));\n      if (Level == 0)\n        return (NumLevels == CaptureLevel + 1) && TopDVar.CKind != OMPC_shared;\n      do {\n        --Level;\n        DSAStackTy::DSAVarData DVar = DSAStack->getImplicitDSA(D, Level);\n        if (DVar.CKind != OMPC_shared)\n          return true;\n      } while (Level > 0);\n    }\n  }\n  return true;\n}\n\nvoid Sema::DestroyDataSharingAttributesStack() { delete DSAStack; }\n\nvoid Sema::ActOnOpenMPBeginDeclareVariant(SourceLocation Loc,\n                                          OMPTraitInfo &TI) {\n  OMPDeclareVariantScopes.push_back(OMPDeclareVariantScope(TI));\n}\n\nvoid Sema::ActOnOpenMPEndDeclareVariant() {\n  assert(isInOpenMPDeclareVariantScope() &&\n         \"Not in OpenMP declare variant scope!\");\n\n  OMPDeclareVariantScopes.pop_back();\n}\n\nvoid Sema::finalizeOpenMPDelayedAnalysis(const FunctionDecl *Caller,\n                                         const FunctionDecl *Callee,\n                                         SourceLocation Loc) {\n  assert(LangOpts.OpenMP && \"Expected OpenMP compilation mode.\");\n  Optional<OMPDeclareTargetDeclAttr::DevTypeTy> DevTy =\n      OMPDeclareTargetDeclAttr::getDeviceType(Caller->getMostRecentDecl());\n  // Ignore host functions during device analyzis.\n  if (LangOpts.OpenMPIsDevice && DevTy &&\n      *DevTy == OMPDeclareTargetDeclAttr::DT_Host)\n    return;\n  // Ignore nohost functions during host analyzis.\n  if (!LangOpts.OpenMPIsDevice && DevTy &&\n      *DevTy == OMPDeclareTargetDeclAttr::DT_NoHost)\n    return;\n  const FunctionDecl *FD = Callee->getMostRecentDecl();\n  DevTy = OMPDeclareTargetDeclAttr::getDeviceType(FD);\n  if (LangOpts.OpenMPIsDevice && DevTy &&\n      *DevTy == OMPDeclareTargetDeclAttr::DT_Host) {\n    // Diagnose host function called during device codegen.\n    StringRef HostDevTy =\n        getOpenMPSimpleClauseTypeName(OMPC_device_type, OMPC_DEVICE_TYPE_host);\n    Diag(Loc, diag::err_omp_wrong_device_function_call) << HostDevTy << 0;\n    Diag(*OMPDeclareTargetDeclAttr::getLocation(FD),\n         diag::note_omp_marked_device_type_here)\n        << HostDevTy;\n    return;\n  }\n      if (!LangOpts.OpenMPIsDevice && DevTy &&\n          *DevTy == OMPDeclareTargetDeclAttr::DT_NoHost) {\n        // Diagnose nohost function called during host codegen.\n        StringRef NoHostDevTy = getOpenMPSimpleClauseTypeName(\n            OMPC_device_type, OMPC_DEVICE_TYPE_nohost);\n        Diag(Loc, diag::err_omp_wrong_device_function_call) << NoHostDevTy << 1;\n        Diag(*OMPDeclareTargetDeclAttr::getLocation(FD),\n             diag::note_omp_marked_device_type_here)\n            << NoHostDevTy;\n      }\n}\n\nvoid Sema::StartOpenMPDSABlock(OpenMPDirectiveKind DKind,\n                               const DeclarationNameInfo &DirName,\n                               Scope *CurScope, SourceLocation Loc) {\n  DSAStack->push(DKind, DirName, CurScope, Loc);\n  PushExpressionEvaluationContext(\n      ExpressionEvaluationContext::PotentiallyEvaluated);\n}\n\nvoid Sema::StartOpenMPClause(OpenMPClauseKind K) {\n  DSAStack->setClauseParsingMode(K);\n}\n\nvoid Sema::EndOpenMPClause() {\n  DSAStack->setClauseParsingMode(/*K=*/OMPC_unknown);\n}\n\nstatic std::pair<ValueDecl *, bool>\ngetPrivateItem(Sema &S, Expr *&RefExpr, SourceLocation &ELoc,\n               SourceRange &ERange, bool AllowArraySection = false);\n\n/// Check consistency of the reduction clauses.\nstatic void checkReductionClauses(Sema &S, DSAStackTy *Stack,\n                                  ArrayRef<OMPClause *> Clauses) {\n  bool InscanFound = false;\n  SourceLocation InscanLoc;\n  // OpenMP 5.0, 2.19.5.4 reduction Clause, Restrictions.\n  // A reduction clause without the inscan reduction-modifier may not appear on\n  // a construct on which a reduction clause with the inscan reduction-modifier\n  // appears.\n  for (OMPClause *C : Clauses) {\n    if (C->getClauseKind() != OMPC_reduction)\n      continue;\n    auto *RC = cast<OMPReductionClause>(C);\n    if (RC->getModifier() == OMPC_REDUCTION_inscan) {\n      InscanFound = true;\n      InscanLoc = RC->getModifierLoc();\n      continue;\n    }\n    if (RC->getModifier() == OMPC_REDUCTION_task) {\n      // OpenMP 5.0, 2.19.5.4 reduction Clause.\n      // A reduction clause with the task reduction-modifier may only appear on\n      // a parallel construct, a worksharing construct or a combined or\n      // composite construct for which any of the aforementioned constructs is a\n      // constituent construct and simd or loop are not constituent constructs.\n      OpenMPDirectiveKind CurDir = Stack->getCurrentDirective();\n      if (!(isOpenMPParallelDirective(CurDir) ||\n            isOpenMPWorksharingDirective(CurDir)) ||\n          isOpenMPSimdDirective(CurDir))\n        S.Diag(RC->getModifierLoc(),\n               diag::err_omp_reduction_task_not_parallel_or_worksharing);\n      continue;\n    }\n  }\n  if (InscanFound) {\n    for (OMPClause *C : Clauses) {\n      if (C->getClauseKind() != OMPC_reduction)\n        continue;\n      auto *RC = cast<OMPReductionClause>(C);\n      if (RC->getModifier() != OMPC_REDUCTION_inscan) {\n        S.Diag(RC->getModifier() == OMPC_REDUCTION_unknown\n                   ? RC->getBeginLoc()\n                   : RC->getModifierLoc(),\n               diag::err_omp_inscan_reduction_expected);\n        S.Diag(InscanLoc, diag::note_omp_previous_inscan_reduction);\n        continue;\n      }\n      for (Expr *Ref : RC->varlists()) {\n        assert(Ref && \"NULL expr in OpenMP nontemporal clause.\");\n        SourceLocation ELoc;\n        SourceRange ERange;\n        Expr *SimpleRefExpr = Ref;\n        auto Res = getPrivateItem(S, SimpleRefExpr, ELoc, ERange,\n                                  /*AllowArraySection=*/true);\n        ValueDecl *D = Res.first;\n        if (!D)\n          continue;\n        if (!Stack->isUsedInScanDirective(getCanonicalDecl(D))) {\n          S.Diag(Ref->getExprLoc(),\n                 diag::err_omp_reduction_not_inclusive_exclusive)\n              << Ref->getSourceRange();\n        }\n      }\n    }\n  }\n}\n\nstatic void checkAllocateClauses(Sema &S, DSAStackTy *Stack,\n                                 ArrayRef<OMPClause *> Clauses);\nstatic DeclRefExpr *buildCapture(Sema &S, ValueDecl *D, Expr *CaptureExpr,\n                                 bool WithInit);\n\nstatic void reportOriginalDsa(Sema &SemaRef, const DSAStackTy *Stack,\n                              const ValueDecl *D,\n                              const DSAStackTy::DSAVarData &DVar,\n                              bool IsLoopIterVar = false);\n\nvoid Sema::EndOpenMPDSABlock(Stmt *CurDirective) {\n  // OpenMP [2.14.3.5, Restrictions, C/C++, p.1]\n  //  A variable of class type (or array thereof) that appears in a lastprivate\n  //  clause requires an accessible, unambiguous default constructor for the\n  //  class type, unless the list item is also specified in a firstprivate\n  //  clause.\n  if (const auto *D = dyn_cast_or_null<OMPExecutableDirective>(CurDirective)) {\n    for (OMPClause *C : D->clauses()) {\n      if (auto *Clause = dyn_cast<OMPLastprivateClause>(C)) {\n        SmallVector<Expr *, 8> PrivateCopies;\n        for (Expr *DE : Clause->varlists()) {\n          if (DE->isValueDependent() || DE->isTypeDependent()) {\n            PrivateCopies.push_back(nullptr);\n            continue;\n          }\n          auto *DRE = cast<DeclRefExpr>(DE->IgnoreParens());\n          auto *VD = cast<VarDecl>(DRE->getDecl());\n          QualType Type = VD->getType().getNonReferenceType();\n          const DSAStackTy::DSAVarData DVar =\n              DSAStack->getTopDSA(VD, /*FromParent=*/false);\n          if (DVar.CKind == OMPC_lastprivate) {\n            // Generate helper private variable and initialize it with the\n            // default value. The address of the original variable is replaced\n            // by the address of the new private variable in CodeGen. This new\n            // variable is not added to IdResolver, so the code in the OpenMP\n            // region uses original variable for proper diagnostics.\n            VarDecl *VDPrivate = buildVarDecl(\n                *this, DE->getExprLoc(), Type.getUnqualifiedType(),\n                VD->getName(), VD->hasAttrs() ? &VD->getAttrs() : nullptr, DRE);\n            ActOnUninitializedDecl(VDPrivate);\n            if (VDPrivate->isInvalidDecl()) {\n              PrivateCopies.push_back(nullptr);\n              continue;\n            }\n            PrivateCopies.push_back(buildDeclRefExpr(\n                *this, VDPrivate, DE->getType(), DE->getExprLoc()));\n          } else {\n            // The variable is also a firstprivate, so initialization sequence\n            // for private copy is generated already.\n            PrivateCopies.push_back(nullptr);\n          }\n        }\n        Clause->setPrivateCopies(PrivateCopies);\n        continue;\n      }\n      // Finalize nontemporal clause by handling private copies, if any.\n      if (auto *Clause = dyn_cast<OMPNontemporalClause>(C)) {\n        SmallVector<Expr *, 8> PrivateRefs;\n        for (Expr *RefExpr : Clause->varlists()) {\n          assert(RefExpr && \"NULL expr in OpenMP nontemporal clause.\");\n          SourceLocation ELoc;\n          SourceRange ERange;\n          Expr *SimpleRefExpr = RefExpr;\n          auto Res = getPrivateItem(*this, SimpleRefExpr, ELoc, ERange);\n          if (Res.second)\n            // It will be analyzed later.\n            PrivateRefs.push_back(RefExpr);\n          ValueDecl *D = Res.first;\n          if (!D)\n            continue;\n\n          const DSAStackTy::DSAVarData DVar =\n              DSAStack->getTopDSA(D, /*FromParent=*/false);\n          PrivateRefs.push_back(DVar.PrivateCopy ? DVar.PrivateCopy\n                                                 : SimpleRefExpr);\n        }\n        Clause->setPrivateRefs(PrivateRefs);\n        continue;\n      }\n      if (auto *Clause = dyn_cast<OMPUsesAllocatorsClause>(C)) {\n        for (unsigned I = 0, E = Clause->getNumberOfAllocators(); I < E; ++I) {\n          OMPUsesAllocatorsClause::Data D = Clause->getAllocatorData(I);\n          auto *DRE = dyn_cast<DeclRefExpr>(D.Allocator->IgnoreParenImpCasts());\n          if (!DRE)\n            continue;\n          ValueDecl *VD = DRE->getDecl();\n          if (!VD || !isa<VarDecl>(VD))\n            continue;\n          DSAStackTy::DSAVarData DVar =\n              DSAStack->getTopDSA(VD, /*FromParent=*/false);\n          // OpenMP [2.12.5, target Construct]\n          // Memory allocators that appear in a uses_allocators clause cannot\n          // appear in other data-sharing attribute clauses or data-mapping\n          // attribute clauses in the same construct.\n          Expr *MapExpr = nullptr;\n          if (DVar.RefExpr ||\n              DSAStack->checkMappableExprComponentListsForDecl(\n                  VD, /*CurrentRegionOnly=*/true,\n                  [VD, &MapExpr](\n                      OMPClauseMappableExprCommon::MappableExprComponentListRef\n                          MapExprComponents,\n                      OpenMPClauseKind C) {\n                    auto MI = MapExprComponents.rbegin();\n                    auto ME = MapExprComponents.rend();\n                    if (MI != ME &&\n                        MI->getAssociatedDeclaration()->getCanonicalDecl() ==\n                            VD->getCanonicalDecl()) {\n                      MapExpr = MI->getAssociatedExpression();\n                      return true;\n                    }\n                    return false;\n                  })) {\n            Diag(D.Allocator->getExprLoc(),\n                 diag::err_omp_allocator_used_in_clauses)\n                << D.Allocator->getSourceRange();\n            if (DVar.RefExpr)\n              reportOriginalDsa(*this, DSAStack, VD, DVar);\n            else\n              Diag(MapExpr->getExprLoc(), diag::note_used_here)\n                  << MapExpr->getSourceRange();\n          }\n        }\n        continue;\n      }\n    }\n    // Check allocate clauses.\n    if (!CurContext->isDependentContext())\n      checkAllocateClauses(*this, DSAStack, D->clauses());\n    checkReductionClauses(*this, DSAStack, D->clauses());\n  }\n\n  DSAStack->pop();\n  DiscardCleanupsInEvaluationContext();\n  PopExpressionEvaluationContext();\n}\n\nstatic bool FinishOpenMPLinearClause(OMPLinearClause &Clause, DeclRefExpr *IV,\n                                     Expr *NumIterations, Sema &SemaRef,\n                                     Scope *S, DSAStackTy *Stack);\n\nnamespace {\n\nclass VarDeclFilterCCC final : public CorrectionCandidateCallback {\nprivate:\n  Sema &SemaRef;\n\npublic:\n  explicit VarDeclFilterCCC(Sema &S) : SemaRef(S) {}\n  bool ValidateCandidate(const TypoCorrection &Candidate) override {\n    NamedDecl *ND = Candidate.getCorrectionDecl();\n    if (const auto *VD = dyn_cast_or_null<VarDecl>(ND)) {\n      return VD->hasGlobalStorage() &&\n             SemaRef.isDeclInScope(ND, SemaRef.getCurLexicalContext(),\n                                   SemaRef.getCurScope());\n    }\n    return false;\n  }\n\n  std::unique_ptr<CorrectionCandidateCallback> clone() override {\n    return std::make_unique<VarDeclFilterCCC>(*this);\n  }\n\n};\n\nclass VarOrFuncDeclFilterCCC final : public CorrectionCandidateCallback {\nprivate:\n  Sema &SemaRef;\n\npublic:\n  explicit VarOrFuncDeclFilterCCC(Sema &S) : SemaRef(S) {}\n  bool ValidateCandidate(const TypoCorrection &Candidate) override {\n    NamedDecl *ND = Candidate.getCorrectionDecl();\n    if (ND && ((isa<VarDecl>(ND) && ND->getKind() == Decl::Var) ||\n               isa<FunctionDecl>(ND))) {\n      return SemaRef.isDeclInScope(ND, SemaRef.getCurLexicalContext(),\n                                   SemaRef.getCurScope());\n    }\n    return false;\n  }\n\n  std::unique_ptr<CorrectionCandidateCallback> clone() override {\n    return std::make_unique<VarOrFuncDeclFilterCCC>(*this);\n  }\n};\n\n} // namespace\n\nExprResult Sema::ActOnOpenMPIdExpression(Scope *CurScope,\n                                         CXXScopeSpec &ScopeSpec,\n                                         const DeclarationNameInfo &Id,\n                                         OpenMPDirectiveKind Kind) {\n  LookupResult Lookup(*this, Id, LookupOrdinaryName);\n  LookupParsedName(Lookup, CurScope, &ScopeSpec, true);\n\n  if (Lookup.isAmbiguous())\n    return ExprError();\n\n  VarDecl *VD;\n  if (!Lookup.isSingleResult()) {\n    VarDeclFilterCCC CCC(*this);\n    if (TypoCorrection Corrected =\n            CorrectTypo(Id, LookupOrdinaryName, CurScope, nullptr, CCC,\n                        CTK_ErrorRecovery)) {\n      diagnoseTypo(Corrected,\n                   PDiag(Lookup.empty()\n                             ? diag::err_undeclared_var_use_suggest\n                             : diag::err_omp_expected_var_arg_suggest)\n                       << Id.getName());\n      VD = Corrected.getCorrectionDeclAs<VarDecl>();\n    } else {\n      Diag(Id.getLoc(), Lookup.empty() ? diag::err_undeclared_var_use\n                                       : diag::err_omp_expected_var_arg)\n          << Id.getName();\n      return ExprError();\n    }\n  } else if (!(VD = Lookup.getAsSingle<VarDecl>())) {\n    Diag(Id.getLoc(), diag::err_omp_expected_var_arg) << Id.getName();\n    Diag(Lookup.getFoundDecl()->getLocation(), diag::note_declared_at);\n    return ExprError();\n  }\n  Lookup.suppressDiagnostics();\n\n  // OpenMP [2.9.2, Syntax, C/C++]\n  //   Variables must be file-scope, namespace-scope, or static block-scope.\n  if (Kind == OMPD_threadprivate && !VD->hasGlobalStorage()) {\n    Diag(Id.getLoc(), diag::err_omp_global_var_arg)\n        << getOpenMPDirectiveName(Kind) << !VD->isStaticLocal();\n    bool IsDecl =\n        VD->isThisDeclarationADefinition(Context) == VarDecl::DeclarationOnly;\n    Diag(VD->getLocation(),\n         IsDecl ? diag::note_previous_decl : diag::note_defined_here)\n        << VD;\n    return ExprError();\n  }\n\n  VarDecl *CanonicalVD = VD->getCanonicalDecl();\n  NamedDecl *ND = CanonicalVD;\n  // OpenMP [2.9.2, Restrictions, C/C++, p.2]\n  //   A threadprivate directive for file-scope variables must appear outside\n  //   any definition or declaration.\n  if (CanonicalVD->getDeclContext()->isTranslationUnit() &&\n      !getCurLexicalContext()->isTranslationUnit()) {\n    Diag(Id.getLoc(), diag::err_omp_var_scope)\n        << getOpenMPDirectiveName(Kind) << VD;\n    bool IsDecl =\n        VD->isThisDeclarationADefinition(Context) == VarDecl::DeclarationOnly;\n    Diag(VD->getLocation(),\n         IsDecl ? diag::note_previous_decl : diag::note_defined_here)\n        << VD;\n    return ExprError();\n  }\n  // OpenMP [2.9.2, Restrictions, C/C++, p.3]\n  //   A threadprivate directive for static class member variables must appear\n  //   in the class definition, in the same scope in which the member\n  //   variables are declared.\n  if (CanonicalVD->isStaticDataMember() &&\n      !CanonicalVD->getDeclContext()->Equals(getCurLexicalContext())) {\n    Diag(Id.getLoc(), diag::err_omp_var_scope)\n        << getOpenMPDirectiveName(Kind) << VD;\n    bool IsDecl =\n        VD->isThisDeclarationADefinition(Context) == VarDecl::DeclarationOnly;\n    Diag(VD->getLocation(),\n         IsDecl ? diag::note_previous_decl : diag::note_defined_here)\n        << VD;\n    return ExprError();\n  }\n  // OpenMP [2.9.2, Restrictions, C/C++, p.4]\n  //   A threadprivate directive for namespace-scope variables must appear\n  //   outside any definition or declaration other than the namespace\n  //   definition itself.\n  if (CanonicalVD->getDeclContext()->isNamespace() &&\n      (!getCurLexicalContext()->isFileContext() ||\n       !getCurLexicalContext()->Encloses(CanonicalVD->getDeclContext()))) {\n    Diag(Id.getLoc(), diag::err_omp_var_scope)\n        << getOpenMPDirectiveName(Kind) << VD;\n    bool IsDecl =\n        VD->isThisDeclarationADefinition(Context) == VarDecl::DeclarationOnly;\n    Diag(VD->getLocation(),\n         IsDecl ? diag::note_previous_decl : diag::note_defined_here)\n        << VD;\n    return ExprError();\n  }\n  // OpenMP [2.9.2, Restrictions, C/C++, p.6]\n  //   A threadprivate directive for static block-scope variables must appear\n  //   in the scope of the variable and not in a nested scope.\n  if (CanonicalVD->isLocalVarDecl() && CurScope &&\n      !isDeclInScope(ND, getCurLexicalContext(), CurScope)) {\n    Diag(Id.getLoc(), diag::err_omp_var_scope)\n        << getOpenMPDirectiveName(Kind) << VD;\n    bool IsDecl =\n        VD->isThisDeclarationADefinition(Context) == VarDecl::DeclarationOnly;\n    Diag(VD->getLocation(),\n         IsDecl ? diag::note_previous_decl : diag::note_defined_here)\n        << VD;\n    return ExprError();\n  }\n\n  // OpenMP [2.9.2, Restrictions, C/C++, p.2-6]\n  //   A threadprivate directive must lexically precede all references to any\n  //   of the variables in its list.\n  if (Kind == OMPD_threadprivate && VD->isUsed() &&\n      !DSAStack->isThreadPrivate(VD)) {\n    Diag(Id.getLoc(), diag::err_omp_var_used)\n        << getOpenMPDirectiveName(Kind) << VD;\n    return ExprError();\n  }\n\n  QualType ExprType = VD->getType().getNonReferenceType();\n  return DeclRefExpr::Create(Context, NestedNameSpecifierLoc(),\n                             SourceLocation(), VD,\n                             /*RefersToEnclosingVariableOrCapture=*/false,\n                             Id.getLoc(), ExprType, VK_LValue);\n}\n\nSema::DeclGroupPtrTy\nSema::ActOnOpenMPThreadprivateDirective(SourceLocation Loc,\n                                        ArrayRef<Expr *> VarList) {\n  if (OMPThreadPrivateDecl *D = CheckOMPThreadPrivateDecl(Loc, VarList)) {\n    CurContext->addDecl(D);\n    return DeclGroupPtrTy::make(DeclGroupRef(D));\n  }\n  return nullptr;\n}\n\nnamespace {\nclass LocalVarRefChecker final\n    : public ConstStmtVisitor<LocalVarRefChecker, bool> {\n  Sema &SemaRef;\n\npublic:\n  bool VisitDeclRefExpr(const DeclRefExpr *E) {\n    if (const auto *VD = dyn_cast<VarDecl>(E->getDecl())) {\n      if (VD->hasLocalStorage()) {\n        SemaRef.Diag(E->getBeginLoc(),\n                     diag::err_omp_local_var_in_threadprivate_init)\n            << E->getSourceRange();\n        SemaRef.Diag(VD->getLocation(), diag::note_defined_here)\n            << VD << VD->getSourceRange();\n        return true;\n      }\n    }\n    return false;\n  }\n  bool VisitStmt(const Stmt *S) {\n    for (const Stmt *Child : S->children()) {\n      if (Child && Visit(Child))\n        return true;\n    }\n    return false;\n  }\n  explicit LocalVarRefChecker(Sema &SemaRef) : SemaRef(SemaRef) {}\n};\n} // namespace\n\nOMPThreadPrivateDecl *\nSema::CheckOMPThreadPrivateDecl(SourceLocation Loc, ArrayRef<Expr *> VarList) {\n  SmallVector<Expr *, 8> Vars;\n  for (Expr *RefExpr : VarList) {\n    auto *DE = cast<DeclRefExpr>(RefExpr);\n    auto *VD = cast<VarDecl>(DE->getDecl());\n    SourceLocation ILoc = DE->getExprLoc();\n\n    // Mark variable as used.\n    VD->setReferenced();\n    VD->markUsed(Context);\n\n    QualType QType = VD->getType();\n    if (QType->isDependentType() || QType->isInstantiationDependentType()) {\n      // It will be analyzed later.\n      Vars.push_back(DE);\n      continue;\n    }\n\n    // OpenMP [2.9.2, Restrictions, C/C++, p.10]\n    //   A threadprivate variable must not have an incomplete type.\n    if (RequireCompleteType(ILoc, VD->getType(),\n                            diag::err_omp_threadprivate_incomplete_type)) {\n      continue;\n    }\n\n    // OpenMP [2.9.2, Restrictions, C/C++, p.10]\n    //   A threadprivate variable must not have a reference type.\n    if (VD->getType()->isReferenceType()) {\n      Diag(ILoc, diag::err_omp_ref_type_arg)\n          << getOpenMPDirectiveName(OMPD_threadprivate) << VD->getType();\n      bool IsDecl =\n          VD->isThisDeclarationADefinition(Context) == VarDecl::DeclarationOnly;\n      Diag(VD->getLocation(),\n           IsDecl ? diag::note_previous_decl : diag::note_defined_here)\n          << VD;\n      continue;\n    }\n\n    // Check if this is a TLS variable. If TLS is not being supported, produce\n    // the corresponding diagnostic.\n    if ((VD->getTLSKind() != VarDecl::TLS_None &&\n         !(VD->hasAttr<OMPThreadPrivateDeclAttr>() &&\n           getLangOpts().OpenMPUseTLS &&\n           getASTContext().getTargetInfo().isTLSSupported())) ||\n        (VD->getStorageClass() == SC_Register && VD->hasAttr<AsmLabelAttr>() &&\n         !VD->isLocalVarDecl())) {\n      Diag(ILoc, diag::err_omp_var_thread_local)\n          << VD << ((VD->getTLSKind() != VarDecl::TLS_None) ? 0 : 1);\n      bool IsDecl =\n          VD->isThisDeclarationADefinition(Context) == VarDecl::DeclarationOnly;\n      Diag(VD->getLocation(),\n           IsDecl ? diag::note_previous_decl : diag::note_defined_here)\n          << VD;\n      continue;\n    }\n\n    // Check if initial value of threadprivate variable reference variable with\n    // local storage (it is not supported by runtime).\n    if (const Expr *Init = VD->getAnyInitializer()) {\n      LocalVarRefChecker Checker(*this);\n      if (Checker.Visit(Init))\n        continue;\n    }\n\n    Vars.push_back(RefExpr);\n    DSAStack->addDSA(VD, DE, OMPC_threadprivate);\n    VD->addAttr(OMPThreadPrivateDeclAttr::CreateImplicit(\n        Context, SourceRange(Loc, Loc)));\n    if (ASTMutationListener *ML = Context.getASTMutationListener())\n      ML->DeclarationMarkedOpenMPThreadPrivate(VD);\n  }\n  OMPThreadPrivateDecl *D = nullptr;\n  if (!Vars.empty()) {\n    D = OMPThreadPrivateDecl::Create(Context, getCurLexicalContext(), Loc,\n                                     Vars);\n    D->setAccess(AS_public);\n  }\n  return D;\n}\n\nstatic OMPAllocateDeclAttr::AllocatorTypeTy\ngetAllocatorKind(Sema &S, DSAStackTy *Stack, Expr *Allocator) {\n  if (!Allocator)\n    return OMPAllocateDeclAttr::OMPNullMemAlloc;\n  if (Allocator->isTypeDependent() || Allocator->isValueDependent() ||\n      Allocator->isInstantiationDependent() ||\n      Allocator->containsUnexpandedParameterPack())\n    return OMPAllocateDeclAttr::OMPUserDefinedMemAlloc;\n  auto AllocatorKindRes = OMPAllocateDeclAttr::OMPUserDefinedMemAlloc;\n  const Expr *AE = Allocator->IgnoreParenImpCasts();\n  for (int I = 0; I < OMPAllocateDeclAttr::OMPUserDefinedMemAlloc; ++I) {\n    auto AllocatorKind = static_cast<OMPAllocateDeclAttr::AllocatorTypeTy>(I);\n    const Expr *DefAllocator = Stack->getAllocator(AllocatorKind);\n    llvm::FoldingSetNodeID AEId, DAEId;\n    AE->Profile(AEId, S.getASTContext(), /*Canonical=*/true);\n    DefAllocator->Profile(DAEId, S.getASTContext(), /*Canonical=*/true);\n    if (AEId == DAEId) {\n      AllocatorKindRes = AllocatorKind;\n      break;\n    }\n  }\n  return AllocatorKindRes;\n}\n\nstatic bool checkPreviousOMPAllocateAttribute(\n    Sema &S, DSAStackTy *Stack, Expr *RefExpr, VarDecl *VD,\n    OMPAllocateDeclAttr::AllocatorTypeTy AllocatorKind, Expr *Allocator) {\n  if (!VD->hasAttr<OMPAllocateDeclAttr>())\n    return false;\n  const auto *A = VD->getAttr<OMPAllocateDeclAttr>();\n  Expr *PrevAllocator = A->getAllocator();\n  OMPAllocateDeclAttr::AllocatorTypeTy PrevAllocatorKind =\n      getAllocatorKind(S, Stack, PrevAllocator);\n  bool AllocatorsMatch = AllocatorKind == PrevAllocatorKind;\n  if (AllocatorsMatch &&\n      AllocatorKind == OMPAllocateDeclAttr::OMPUserDefinedMemAlloc &&\n      Allocator && PrevAllocator) {\n    const Expr *AE = Allocator->IgnoreParenImpCasts();\n    const Expr *PAE = PrevAllocator->IgnoreParenImpCasts();\n    llvm::FoldingSetNodeID AEId, PAEId;\n    AE->Profile(AEId, S.Context, /*Canonical=*/true);\n    PAE->Profile(PAEId, S.Context, /*Canonical=*/true);\n    AllocatorsMatch = AEId == PAEId;\n  }\n  if (!AllocatorsMatch) {\n    SmallString<256> AllocatorBuffer;\n    llvm::raw_svector_ostream AllocatorStream(AllocatorBuffer);\n    if (Allocator)\n      Allocator->printPretty(AllocatorStream, nullptr, S.getPrintingPolicy());\n    SmallString<256> PrevAllocatorBuffer;\n    llvm::raw_svector_ostream PrevAllocatorStream(PrevAllocatorBuffer);\n    if (PrevAllocator)\n      PrevAllocator->printPretty(PrevAllocatorStream, nullptr,\n                                 S.getPrintingPolicy());\n\n    SourceLocation AllocatorLoc =\n        Allocator ? Allocator->getExprLoc() : RefExpr->getExprLoc();\n    SourceRange AllocatorRange =\n        Allocator ? Allocator->getSourceRange() : RefExpr->getSourceRange();\n    SourceLocation PrevAllocatorLoc =\n        PrevAllocator ? PrevAllocator->getExprLoc() : A->getLocation();\n    SourceRange PrevAllocatorRange =\n        PrevAllocator ? PrevAllocator->getSourceRange() : A->getRange();\n    S.Diag(AllocatorLoc, diag::warn_omp_used_different_allocator)\n        << (Allocator ? 1 : 0) << AllocatorStream.str()\n        << (PrevAllocator ? 1 : 0) << PrevAllocatorStream.str()\n        << AllocatorRange;\n    S.Diag(PrevAllocatorLoc, diag::note_omp_previous_allocator)\n        << PrevAllocatorRange;\n    return true;\n  }\n  return false;\n}\n\nstatic void\napplyOMPAllocateAttribute(Sema &S, VarDecl *VD,\n                          OMPAllocateDeclAttr::AllocatorTypeTy AllocatorKind,\n                          Expr *Allocator, SourceRange SR) {\n  if (VD->hasAttr<OMPAllocateDeclAttr>())\n    return;\n  if (Allocator &&\n      (Allocator->isTypeDependent() || Allocator->isValueDependent() ||\n       Allocator->isInstantiationDependent() ||\n       Allocator->containsUnexpandedParameterPack()))\n    return;\n  auto *A = OMPAllocateDeclAttr::CreateImplicit(S.Context, AllocatorKind,\n                                                Allocator, SR);\n  VD->addAttr(A);\n  if (ASTMutationListener *ML = S.Context.getASTMutationListener())\n    ML->DeclarationMarkedOpenMPAllocate(VD, A);\n}\n\nSema::DeclGroupPtrTy Sema::ActOnOpenMPAllocateDirective(\n    SourceLocation Loc, ArrayRef<Expr *> VarList,\n    ArrayRef<OMPClause *> Clauses, DeclContext *Owner) {\n  assert(Clauses.size() <= 1 && \"Expected at most one clause.\");\n  Expr *Allocator = nullptr;\n  if (Clauses.empty()) {\n    // OpenMP 5.0, 2.11.3 allocate Directive, Restrictions.\n    // allocate directives that appear in a target region must specify an\n    // allocator clause unless a requires directive with the dynamic_allocators\n    // clause is present in the same compilation unit.\n    if (LangOpts.OpenMPIsDevice &&\n        !DSAStack->hasRequiresDeclWithClause<OMPDynamicAllocatorsClause>())\n      targetDiag(Loc, diag::err_expected_allocator_clause);\n  } else {\n    Allocator = cast<OMPAllocatorClause>(Clauses.back())->getAllocator();\n  }\n  OMPAllocateDeclAttr::AllocatorTypeTy AllocatorKind =\n      getAllocatorKind(*this, DSAStack, Allocator);\n  SmallVector<Expr *, 8> Vars;\n  for (Expr *RefExpr : VarList) {\n    auto *DE = cast<DeclRefExpr>(RefExpr);\n    auto *VD = cast<VarDecl>(DE->getDecl());\n\n    // Check if this is a TLS variable or global register.\n    if (VD->getTLSKind() != VarDecl::TLS_None ||\n        VD->hasAttr<OMPThreadPrivateDeclAttr>() ||\n        (VD->getStorageClass() == SC_Register && VD->hasAttr<AsmLabelAttr>() &&\n         !VD->isLocalVarDecl()))\n      continue;\n\n    // If the used several times in the allocate directive, the same allocator\n    // must be used.\n    if (checkPreviousOMPAllocateAttribute(*this, DSAStack, RefExpr, VD,\n                                          AllocatorKind, Allocator))\n      continue;\n\n    // OpenMP, 2.11.3 allocate Directive, Restrictions, C / C++\n    // If a list item has a static storage type, the allocator expression in the\n    // allocator clause must be a constant expression that evaluates to one of\n    // the predefined memory allocator values.\n    if (Allocator && VD->hasGlobalStorage()) {\n      if (AllocatorKind == OMPAllocateDeclAttr::OMPUserDefinedMemAlloc) {\n        Diag(Allocator->getExprLoc(),\n             diag::err_omp_expected_predefined_allocator)\n            << Allocator->getSourceRange();\n        bool IsDecl = VD->isThisDeclarationADefinition(Context) ==\n                      VarDecl::DeclarationOnly;\n        Diag(VD->getLocation(),\n             IsDecl ? diag::note_previous_decl : diag::note_defined_here)\n            << VD;\n        continue;\n      }\n    }\n\n    Vars.push_back(RefExpr);\n    applyOMPAllocateAttribute(*this, VD, AllocatorKind, Allocator,\n                              DE->getSourceRange());\n  }\n  if (Vars.empty())\n    return nullptr;\n  if (!Owner)\n    Owner = getCurLexicalContext();\n  auto *D = OMPAllocateDecl::Create(Context, Owner, Loc, Vars, Clauses);\n  D->setAccess(AS_public);\n  Owner->addDecl(D);\n  return DeclGroupPtrTy::make(DeclGroupRef(D));\n}\n\nSema::DeclGroupPtrTy\nSema::ActOnOpenMPRequiresDirective(SourceLocation Loc,\n                                   ArrayRef<OMPClause *> ClauseList) {\n  OMPRequiresDecl *D = nullptr;\n  if (!CurContext->isFileContext()) {\n    Diag(Loc, diag::err_omp_invalid_scope) << \"requires\";\n  } else {\n    D = CheckOMPRequiresDecl(Loc, ClauseList);\n    if (D) {\n      CurContext->addDecl(D);\n      DSAStack->addRequiresDecl(D);\n    }\n  }\n  return DeclGroupPtrTy::make(DeclGroupRef(D));\n}\n\nvoid Sema::ActOnOpenMPAssumesDirective(SourceLocation Loc,\n                                       OpenMPDirectiveKind DKind,\n                                       ArrayRef<StringRef> Assumptions,\n                                       bool SkippedClauses) {\n  if (!SkippedClauses && Assumptions.empty())\n    Diag(Loc, diag::err_omp_no_clause_for_directive)\n        << llvm::omp::getAllAssumeClauseOptions()\n        << llvm::omp::getOpenMPDirectiveName(DKind);\n\n  auto *AA = AssumptionAttr::Create(Context, llvm::join(Assumptions, \",\"), Loc);\n  if (DKind == llvm::omp::Directive::OMPD_begin_assumes) {\n    OMPAssumeScoped.push_back(AA);\n    return;\n  }\n\n  // Global assumes without assumption clauses are ignored.\n  if (Assumptions.empty())\n    return;\n\n  assert(DKind == llvm::omp::Directive::OMPD_assumes &&\n         \"Unexpected omp assumption directive!\");\n  OMPAssumeGlobal.push_back(AA);\n\n  // The OMPAssumeGlobal scope above will take care of new declarations but\n  // we also want to apply the assumption to existing ones, e.g., to\n  // declarations in included headers. To this end, we traverse all existing\n  // declaration contexts and annotate function declarations here.\n  SmallVector<DeclContext *, 8> DeclContexts;\n  auto *Ctx = CurContext;\n  while (Ctx->getLexicalParent())\n    Ctx = Ctx->getLexicalParent();\n  DeclContexts.push_back(Ctx);\n  while (!DeclContexts.empty()) {\n    DeclContext *DC = DeclContexts.pop_back_val();\n    for (auto *SubDC : DC->decls()) {\n      if (SubDC->isInvalidDecl())\n        continue;\n      if (auto *CTD = dyn_cast<ClassTemplateDecl>(SubDC)) {\n        DeclContexts.push_back(CTD->getTemplatedDecl());\n        for (auto *S : CTD->specializations())\n          DeclContexts.push_back(S);\n        continue;\n      }\n      if (auto *DC = dyn_cast<DeclContext>(SubDC))\n        DeclContexts.push_back(DC);\n      if (auto *F = dyn_cast<FunctionDecl>(SubDC)) {\n        F->addAttr(AA);\n        continue;\n      }\n    }\n  }\n}\n\nvoid Sema::ActOnOpenMPEndAssumesDirective() {\n  assert(isInOpenMPAssumeScope() && \"Not in OpenMP assumes scope!\");\n  OMPAssumeScoped.pop_back();\n}\n\nOMPRequiresDecl *Sema::CheckOMPRequiresDecl(SourceLocation Loc,\n                                            ArrayRef<OMPClause *> ClauseList) {\n  /// For target specific clauses, the requires directive cannot be\n  /// specified after the handling of any of the target regions in the\n  /// current compilation unit.\n  ArrayRef<SourceLocation> TargetLocations =\n      DSAStack->getEncounteredTargetLocs();\n  SourceLocation AtomicLoc = DSAStack->getAtomicDirectiveLoc();\n  if (!TargetLocations.empty() || !AtomicLoc.isInvalid()) {\n    for (const OMPClause *CNew : ClauseList) {\n      // Check if any of the requires clauses affect target regions.\n      if (isa<OMPUnifiedSharedMemoryClause>(CNew) ||\n          isa<OMPUnifiedAddressClause>(CNew) ||\n          isa<OMPReverseOffloadClause>(CNew) ||\n          isa<OMPDynamicAllocatorsClause>(CNew)) {\n        Diag(Loc, diag::err_omp_directive_before_requires)\n            << \"target\" << getOpenMPClauseName(CNew->getClauseKind());\n        for (SourceLocation TargetLoc : TargetLocations) {\n          Diag(TargetLoc, diag::note_omp_requires_encountered_directive)\n              << \"target\";\n        }\n      } else if (!AtomicLoc.isInvalid() &&\n                 isa<OMPAtomicDefaultMemOrderClause>(CNew)) {\n        Diag(Loc, diag::err_omp_directive_before_requires)\n            << \"atomic\" << getOpenMPClauseName(CNew->getClauseKind());\n        Diag(AtomicLoc, diag::note_omp_requires_encountered_directive)\n            << \"atomic\";\n      }\n    }\n  }\n\n  if (!DSAStack->hasDuplicateRequiresClause(ClauseList))\n    return OMPRequiresDecl::Create(Context, getCurLexicalContext(), Loc,\n                                   ClauseList);\n  return nullptr;\n}\n\nstatic void reportOriginalDsa(Sema &SemaRef, const DSAStackTy *Stack,\n                              const ValueDecl *D,\n                              const DSAStackTy::DSAVarData &DVar,\n                              bool IsLoopIterVar) {\n  if (DVar.RefExpr) {\n    SemaRef.Diag(DVar.RefExpr->getExprLoc(), diag::note_omp_explicit_dsa)\n        << getOpenMPClauseName(DVar.CKind);\n    return;\n  }\n  enum {\n    PDSA_StaticMemberShared,\n    PDSA_StaticLocalVarShared,\n    PDSA_LoopIterVarPrivate,\n    PDSA_LoopIterVarLinear,\n    PDSA_LoopIterVarLastprivate,\n    PDSA_ConstVarShared,\n    PDSA_GlobalVarShared,\n    PDSA_TaskVarFirstprivate,\n    PDSA_LocalVarPrivate,\n    PDSA_Implicit\n  } Reason = PDSA_Implicit;\n  bool ReportHint = false;\n  auto ReportLoc = D->getLocation();\n  auto *VD = dyn_cast<VarDecl>(D);\n  if (IsLoopIterVar) {\n    if (DVar.CKind == OMPC_private)\n      Reason = PDSA_LoopIterVarPrivate;\n    else if (DVar.CKind == OMPC_lastprivate)\n      Reason = PDSA_LoopIterVarLastprivate;\n    else\n      Reason = PDSA_LoopIterVarLinear;\n  } else if (isOpenMPTaskingDirective(DVar.DKind) &&\n             DVar.CKind == OMPC_firstprivate) {\n    Reason = PDSA_TaskVarFirstprivate;\n    ReportLoc = DVar.ImplicitDSALoc;\n  } else if (VD && VD->isStaticLocal())\n    Reason = PDSA_StaticLocalVarShared;\n  else if (VD && VD->isStaticDataMember())\n    Reason = PDSA_StaticMemberShared;\n  else if (VD && VD->isFileVarDecl())\n    Reason = PDSA_GlobalVarShared;\n  else if (D->getType().isConstant(SemaRef.getASTContext()))\n    Reason = PDSA_ConstVarShared;\n  else if (VD && VD->isLocalVarDecl() && DVar.CKind == OMPC_private) {\n    ReportHint = true;\n    Reason = PDSA_LocalVarPrivate;\n  }\n  if (Reason != PDSA_Implicit) {\n    SemaRef.Diag(ReportLoc, diag::note_omp_predetermined_dsa)\n        << Reason << ReportHint\n        << getOpenMPDirectiveName(Stack->getCurrentDirective());\n  } else if (DVar.ImplicitDSALoc.isValid()) {\n    SemaRef.Diag(DVar.ImplicitDSALoc, diag::note_omp_implicit_dsa)\n        << getOpenMPClauseName(DVar.CKind);\n  }\n}\n\nstatic OpenMPMapClauseKind\ngetMapClauseKindFromModifier(OpenMPDefaultmapClauseModifier M,\n                             bool IsAggregateOrDeclareTarget) {\n  OpenMPMapClauseKind Kind = OMPC_MAP_unknown;\n  switch (M) {\n  case OMPC_DEFAULTMAP_MODIFIER_alloc:\n    Kind = OMPC_MAP_alloc;\n    break;\n  case OMPC_DEFAULTMAP_MODIFIER_to:\n    Kind = OMPC_MAP_to;\n    break;\n  case OMPC_DEFAULTMAP_MODIFIER_from:\n    Kind = OMPC_MAP_from;\n    break;\n  case OMPC_DEFAULTMAP_MODIFIER_tofrom:\n    Kind = OMPC_MAP_tofrom;\n    break;\n  case OMPC_DEFAULTMAP_MODIFIER_present:\n    // OpenMP 5.1 [2.21.7.3] defaultmap clause, Description]\n    // If implicit-behavior is present, each variable referenced in the\n    // construct in the category specified by variable-category is treated as if\n    // it had been listed in a map clause with the map-type of alloc and\n    // map-type-modifier of present.\n    Kind = OMPC_MAP_alloc;\n    break;\n  case OMPC_DEFAULTMAP_MODIFIER_firstprivate:\n  case OMPC_DEFAULTMAP_MODIFIER_last:\n    llvm_unreachable(\"Unexpected defaultmap implicit behavior\");\n  case OMPC_DEFAULTMAP_MODIFIER_none:\n  case OMPC_DEFAULTMAP_MODIFIER_default:\n  case OMPC_DEFAULTMAP_MODIFIER_unknown:\n    // IsAggregateOrDeclareTarget could be true if:\n    // 1. the implicit behavior for aggregate is tofrom\n    // 2. it's a declare target link\n    if (IsAggregateOrDeclareTarget) {\n      Kind = OMPC_MAP_tofrom;\n      break;\n    }\n    llvm_unreachable(\"Unexpected defaultmap implicit behavior\");\n  }\n  assert(Kind != OMPC_MAP_unknown && \"Expect map kind to be known\");\n  return Kind;\n}\n\nnamespace {\nclass DSAAttrChecker final : public StmtVisitor<DSAAttrChecker, void> {\n  DSAStackTy *Stack;\n  Sema &SemaRef;\n  bool ErrorFound = false;\n  bool TryCaptureCXXThisMembers = false;\n  CapturedStmt *CS = nullptr;\n  const static unsigned DefaultmapKindNum = OMPC_DEFAULTMAP_pointer + 1;\n  llvm::SmallVector<Expr *, 4> ImplicitFirstprivate;\n  llvm::SmallVector<Expr *, 4> ImplicitMap[DefaultmapKindNum][OMPC_MAP_delete];\n  llvm::SmallVector<OpenMPMapModifierKind, NumberOfOMPMapClauseModifiers>\n      ImplicitMapModifier[DefaultmapKindNum];\n  Sema::VarsWithInheritedDSAType VarsWithInheritedDSA;\n  llvm::SmallDenseSet<const ValueDecl *, 4> ImplicitDeclarations;\n\n  void VisitSubCaptures(OMPExecutableDirective *S) {\n    // Check implicitly captured variables.\n    if (!S->hasAssociatedStmt() || !S->getAssociatedStmt())\n      return;\n    if (S->getDirectiveKind() == OMPD_atomic ||\n        S->getDirectiveKind() == OMPD_critical ||\n        S->getDirectiveKind() == OMPD_section ||\n        S->getDirectiveKind() == OMPD_master ||\n        isOpenMPLoopTransformationDirective(S->getDirectiveKind())) {\n      Visit(S->getAssociatedStmt());\n      return;\n    }\n    visitSubCaptures(S->getInnermostCapturedStmt());\n    // Try to capture inner this->member references to generate correct mappings\n    // and diagnostics.\n    if (TryCaptureCXXThisMembers ||\n        (isOpenMPTargetExecutionDirective(Stack->getCurrentDirective()) &&\n         llvm::any_of(S->getInnermostCapturedStmt()->captures(),\n                      [](const CapturedStmt::Capture &C) {\n                        return C.capturesThis();\n                      }))) {\n      bool SavedTryCaptureCXXThisMembers = TryCaptureCXXThisMembers;\n      TryCaptureCXXThisMembers = true;\n      Visit(S->getInnermostCapturedStmt()->getCapturedStmt());\n      TryCaptureCXXThisMembers = SavedTryCaptureCXXThisMembers;\n    }\n    // In tasks firstprivates are not captured anymore, need to analyze them\n    // explicitly.\n    if (isOpenMPTaskingDirective(S->getDirectiveKind()) &&\n        !isOpenMPTaskLoopDirective(S->getDirectiveKind())) {\n      for (OMPClause *C : S->clauses())\n        if (auto *FC = dyn_cast<OMPFirstprivateClause>(C)) {\n          for (Expr *Ref : FC->varlists())\n            Visit(Ref);\n        }\n    }\n  }\n\npublic:\n  void VisitDeclRefExpr(DeclRefExpr *E) {\n    if (TryCaptureCXXThisMembers || E->isTypeDependent() ||\n        E->isValueDependent() || E->containsUnexpandedParameterPack() ||\n        E->isInstantiationDependent())\n      return;\n    if (auto *VD = dyn_cast<VarDecl>(E->getDecl())) {\n      // Check the datasharing rules for the expressions in the clauses.\n      if (!CS) {\n        if (auto *CED = dyn_cast<OMPCapturedExprDecl>(VD))\n          if (!CED->hasAttr<OMPCaptureNoInitAttr>()) {\n            Visit(CED->getInit());\n            return;\n          }\n      } else if (VD->isImplicit() || isa<OMPCapturedExprDecl>(VD))\n        // Do not analyze internal variables and do not enclose them into\n        // implicit clauses.\n        return;\n      VD = VD->getCanonicalDecl();\n      // Skip internally declared variables.\n      if (VD->hasLocalStorage() && CS && !CS->capturesVariable(VD) &&\n          !Stack->isImplicitTaskFirstprivate(VD))\n        return;\n      // Skip allocators in uses_allocators clauses.\n      if (Stack->isUsesAllocatorsDecl(VD).hasValue())\n        return;\n\n      DSAStackTy::DSAVarData DVar = Stack->getTopDSA(VD, /*FromParent=*/false);\n      // Check if the variable has explicit DSA set and stop analysis if it so.\n      if (DVar.RefExpr || !ImplicitDeclarations.insert(VD).second)\n        return;\n\n      // Skip internally declared static variables.\n      llvm::Optional<OMPDeclareTargetDeclAttr::MapTypeTy> Res =\n          OMPDeclareTargetDeclAttr::isDeclareTargetDeclaration(VD);\n      if (VD->hasGlobalStorage() && CS && !CS->capturesVariable(VD) &&\n          (Stack->hasRequiresDeclWithClause<OMPUnifiedSharedMemoryClause>() ||\n           !Res || *Res != OMPDeclareTargetDeclAttr::MT_Link) &&\n          !Stack->isImplicitTaskFirstprivate(VD))\n        return;\n\n      SourceLocation ELoc = E->getExprLoc();\n      OpenMPDirectiveKind DKind = Stack->getCurrentDirective();\n      // The default(none) clause requires that each variable that is referenced\n      // in the construct, and does not have a predetermined data-sharing\n      // attribute, must have its data-sharing attribute explicitly determined\n      // by being listed in a data-sharing attribute clause.\n      if (DVar.CKind == OMPC_unknown &&\n          (Stack->getDefaultDSA() == DSA_none ||\n           Stack->getDefaultDSA() == DSA_firstprivate) &&\n          isImplicitOrExplicitTaskingRegion(DKind) &&\n          VarsWithInheritedDSA.count(VD) == 0) {\n        bool InheritedDSA = Stack->getDefaultDSA() == DSA_none;\n        if (!InheritedDSA && Stack->getDefaultDSA() == DSA_firstprivate) {\n          DSAStackTy::DSAVarData DVar =\n              Stack->getImplicitDSA(VD, /*FromParent=*/false);\n          InheritedDSA = DVar.CKind == OMPC_unknown;\n        }\n        if (InheritedDSA)\n          VarsWithInheritedDSA[VD] = E;\n        return;\n      }\n\n      // OpenMP 5.0 [2.19.7.2, defaultmap clause, Description]\n      // If implicit-behavior is none, each variable referenced in the\n      // construct that does not have a predetermined data-sharing attribute\n      // and does not appear in a to or link clause on a declare target\n      // directive must be listed in a data-mapping attribute clause, a\n      // data-haring attribute clause (including a data-sharing attribute\n      // clause on a combined construct where target. is one of the\n      // constituent constructs), or an is_device_ptr clause.\n      OpenMPDefaultmapClauseKind ClauseKind =\n          getVariableCategoryFromDecl(SemaRef.getLangOpts(), VD);\n      if (SemaRef.getLangOpts().OpenMP >= 50) {\n        bool IsModifierNone = Stack->getDefaultmapModifier(ClauseKind) ==\n                              OMPC_DEFAULTMAP_MODIFIER_none;\n        if (DVar.CKind == OMPC_unknown && IsModifierNone &&\n            VarsWithInheritedDSA.count(VD) == 0 && !Res) {\n          // Only check for data-mapping attribute and is_device_ptr here\n          // since we have already make sure that the declaration does not\n          // have a data-sharing attribute above\n          if (!Stack->checkMappableExprComponentListsForDecl(\n                  VD, /*CurrentRegionOnly=*/true,\n                  [VD](OMPClauseMappableExprCommon::MappableExprComponentListRef\n                           MapExprComponents,\n                       OpenMPClauseKind) {\n                    auto MI = MapExprComponents.rbegin();\n                    auto ME = MapExprComponents.rend();\n                    return MI != ME && MI->getAssociatedDeclaration() == VD;\n                  })) {\n            VarsWithInheritedDSA[VD] = E;\n            return;\n          }\n        }\n      }\n      if (SemaRef.getLangOpts().OpenMP > 50) {\n        bool IsModifierPresent = Stack->getDefaultmapModifier(ClauseKind) ==\n                                 OMPC_DEFAULTMAP_MODIFIER_present;\n        if (IsModifierPresent) {\n          if (llvm::find(ImplicitMapModifier[ClauseKind],\n                         OMPC_MAP_MODIFIER_present) ==\n              std::end(ImplicitMapModifier[ClauseKind])) {\n            ImplicitMapModifier[ClauseKind].push_back(\n                OMPC_MAP_MODIFIER_present);\n          }\n        }\n      }\n\n      if (isOpenMPTargetExecutionDirective(DKind) &&\n          !Stack->isLoopControlVariable(VD).first) {\n        if (!Stack->checkMappableExprComponentListsForDecl(\n                VD, /*CurrentRegionOnly=*/true,\n                [this](OMPClauseMappableExprCommon::MappableExprComponentListRef\n                           StackComponents,\n                       OpenMPClauseKind) {\n                  if (SemaRef.LangOpts.OpenMP >= 50)\n                    return !StackComponents.empty();\n                  // Variable is used if it has been marked as an array, array\n                  // section, array shaping or the variable iself.\n                  return StackComponents.size() == 1 ||\n                         std::all_of(\n                             std::next(StackComponents.rbegin()),\n                             StackComponents.rend(),\n                             [](const OMPClauseMappableExprCommon::\n                                    MappableComponent &MC) {\n                               return MC.getAssociatedDeclaration() ==\n                                          nullptr &&\n                                      (isa<OMPArraySectionExpr>(\n                                           MC.getAssociatedExpression()) ||\n                                       isa<OMPArrayShapingExpr>(\n                                           MC.getAssociatedExpression()) ||\n                                       isa<ArraySubscriptExpr>(\n                                           MC.getAssociatedExpression()));\n                             });\n                })) {\n          bool IsFirstprivate = false;\n          // By default lambdas are captured as firstprivates.\n          if (const auto *RD =\n                  VD->getType().getNonReferenceType()->getAsCXXRecordDecl())\n            IsFirstprivate = RD->isLambda();\n          IsFirstprivate =\n              IsFirstprivate || (Stack->mustBeFirstprivate(ClauseKind) && !Res);\n          if (IsFirstprivate) {\n            ImplicitFirstprivate.emplace_back(E);\n          } else {\n            OpenMPDefaultmapClauseModifier M =\n                Stack->getDefaultmapModifier(ClauseKind);\n            OpenMPMapClauseKind Kind = getMapClauseKindFromModifier(\n                M, ClauseKind == OMPC_DEFAULTMAP_aggregate || Res);\n            ImplicitMap[ClauseKind][Kind].emplace_back(E);\n          }\n          return;\n        }\n      }\n\n      // OpenMP [2.9.3.6, Restrictions, p.2]\n      //  A list item that appears in a reduction clause of the innermost\n      //  enclosing worksharing or parallel construct may not be accessed in an\n      //  explicit task.\n      DVar = Stack->hasInnermostDSA(\n          VD,\n          [](OpenMPClauseKind C, bool AppliedToPointee) {\n            return C == OMPC_reduction && !AppliedToPointee;\n          },\n          [](OpenMPDirectiveKind K) {\n            return isOpenMPParallelDirective(K) ||\n                   isOpenMPWorksharingDirective(K) || isOpenMPTeamsDirective(K);\n          },\n          /*FromParent=*/true);\n      if (isOpenMPTaskingDirective(DKind) && DVar.CKind == OMPC_reduction) {\n        ErrorFound = true;\n        SemaRef.Diag(ELoc, diag::err_omp_reduction_in_task);\n        reportOriginalDsa(SemaRef, Stack, VD, DVar);\n        return;\n      }\n\n      // Define implicit data-sharing attributes for task.\n      DVar = Stack->getImplicitDSA(VD, /*FromParent=*/false);\n      if (((isOpenMPTaskingDirective(DKind) && DVar.CKind != OMPC_shared) ||\n           (Stack->getDefaultDSA() == DSA_firstprivate &&\n            DVar.CKind == OMPC_firstprivate && !DVar.RefExpr)) &&\n          !Stack->isLoopControlVariable(VD).first) {\n        ImplicitFirstprivate.push_back(E);\n        return;\n      }\n\n      // Store implicitly used globals with declare target link for parent\n      // target.\n      if (!isOpenMPTargetExecutionDirective(DKind) && Res &&\n          *Res == OMPDeclareTargetDeclAttr::MT_Link) {\n        Stack->addToParentTargetRegionLinkGlobals(E);\n        return;\n      }\n    }\n  }\n  void VisitMemberExpr(MemberExpr *E) {\n    if (E->isTypeDependent() || E->isValueDependent() ||\n        E->containsUnexpandedParameterPack() || E->isInstantiationDependent())\n      return;\n    auto *FD = dyn_cast<FieldDecl>(E->getMemberDecl());\n    OpenMPDirectiveKind DKind = Stack->getCurrentDirective();\n    if (auto *TE = dyn_cast<CXXThisExpr>(E->getBase()->IgnoreParenCasts())) {\n      if (!FD)\n        return;\n      DSAStackTy::DSAVarData DVar = Stack->getTopDSA(FD, /*FromParent=*/false);\n      // Check if the variable has explicit DSA set and stop analysis if it\n      // so.\n      if (DVar.RefExpr || !ImplicitDeclarations.insert(FD).second)\n        return;\n\n      if (isOpenMPTargetExecutionDirective(DKind) &&\n          !Stack->isLoopControlVariable(FD).first &&\n          !Stack->checkMappableExprComponentListsForDecl(\n              FD, /*CurrentRegionOnly=*/true,\n              [](OMPClauseMappableExprCommon::MappableExprComponentListRef\n                     StackComponents,\n                 OpenMPClauseKind) {\n                return isa<CXXThisExpr>(\n                    cast<MemberExpr>(\n                        StackComponents.back().getAssociatedExpression())\n                        ->getBase()\n                        ->IgnoreParens());\n              })) {\n        // OpenMP 4.5 [2.15.5.1, map Clause, Restrictions, C/C++, p.3]\n        //  A bit-field cannot appear in a map clause.\n        //\n        if (FD->isBitField())\n          return;\n\n        // Check to see if the member expression is referencing a class that\n        // has already been explicitly mapped\n        if (Stack->isClassPreviouslyMapped(TE->getType()))\n          return;\n\n        OpenMPDefaultmapClauseModifier Modifier =\n            Stack->getDefaultmapModifier(OMPC_DEFAULTMAP_aggregate);\n        OpenMPDefaultmapClauseKind ClauseKind =\n            getVariableCategoryFromDecl(SemaRef.getLangOpts(), FD);\n        OpenMPMapClauseKind Kind = getMapClauseKindFromModifier(\n            Modifier, /*IsAggregateOrDeclareTarget*/ true);\n        ImplicitMap[ClauseKind][Kind].emplace_back(E);\n        return;\n      }\n\n      SourceLocation ELoc = E->getExprLoc();\n      // OpenMP [2.9.3.6, Restrictions, p.2]\n      //  A list item that appears in a reduction clause of the innermost\n      //  enclosing worksharing or parallel construct may not be accessed in\n      //  an  explicit task.\n      DVar = Stack->hasInnermostDSA(\n          FD,\n          [](OpenMPClauseKind C, bool AppliedToPointee) {\n            return C == OMPC_reduction && !AppliedToPointee;\n          },\n          [](OpenMPDirectiveKind K) {\n            return isOpenMPParallelDirective(K) ||\n                   isOpenMPWorksharingDirective(K) || isOpenMPTeamsDirective(K);\n          },\n          /*FromParent=*/true);\n      if (isOpenMPTaskingDirective(DKind) && DVar.CKind == OMPC_reduction) {\n        ErrorFound = true;\n        SemaRef.Diag(ELoc, diag::err_omp_reduction_in_task);\n        reportOriginalDsa(SemaRef, Stack, FD, DVar);\n        return;\n      }\n\n      // Define implicit data-sharing attributes for task.\n      DVar = Stack->getImplicitDSA(FD, /*FromParent=*/false);\n      if (isOpenMPTaskingDirective(DKind) && DVar.CKind != OMPC_shared &&\n          !Stack->isLoopControlVariable(FD).first) {\n        // Check if there is a captured expression for the current field in the\n        // region. Do not mark it as firstprivate unless there is no captured\n        // expression.\n        // TODO: try to make it firstprivate.\n        if (DVar.CKind != OMPC_unknown)\n          ImplicitFirstprivate.push_back(E);\n      }\n      return;\n    }\n    if (isOpenMPTargetExecutionDirective(DKind)) {\n      OMPClauseMappableExprCommon::MappableExprComponentList CurComponents;\n      if (!checkMapClauseExpressionBase(SemaRef, E, CurComponents, OMPC_map,\n                                        Stack->getCurrentDirective(),\n                                        /*NoDiagnose=*/true))\n        return;\n      const auto *VD = cast<ValueDecl>(\n          CurComponents.back().getAssociatedDeclaration()->getCanonicalDecl());\n      if (!Stack->checkMappableExprComponentListsForDecl(\n              VD, /*CurrentRegionOnly=*/true,\n              [&CurComponents](\n                  OMPClauseMappableExprCommon::MappableExprComponentListRef\n                      StackComponents,\n                  OpenMPClauseKind) {\n                auto CCI = CurComponents.rbegin();\n                auto CCE = CurComponents.rend();\n                for (const auto &SC : llvm::reverse(StackComponents)) {\n                  // Do both expressions have the same kind?\n                  if (CCI->getAssociatedExpression()->getStmtClass() !=\n                      SC.getAssociatedExpression()->getStmtClass())\n                    if (!((isa<OMPArraySectionExpr>(\n                               SC.getAssociatedExpression()) ||\n                           isa<OMPArrayShapingExpr>(\n                               SC.getAssociatedExpression())) &&\n                          isa<ArraySubscriptExpr>(\n                              CCI->getAssociatedExpression())))\n                      return false;\n\n                  const Decl *CCD = CCI->getAssociatedDeclaration();\n                  const Decl *SCD = SC.getAssociatedDeclaration();\n                  CCD = CCD ? CCD->getCanonicalDecl() : nullptr;\n                  SCD = SCD ? SCD->getCanonicalDecl() : nullptr;\n                  if (SCD != CCD)\n                    return false;\n                  std::advance(CCI, 1);\n                  if (CCI == CCE)\n                    break;\n                }\n                return true;\n              })) {\n        Visit(E->getBase());\n      }\n    } else if (!TryCaptureCXXThisMembers) {\n      Visit(E->getBase());\n    }\n  }\n  void VisitOMPExecutableDirective(OMPExecutableDirective *S) {\n    for (OMPClause *C : S->clauses()) {\n      // Skip analysis of arguments of implicitly defined firstprivate clause\n      // for task|target directives.\n      // Skip analysis of arguments of implicitly defined map clause for target\n      // directives.\n      if (C && !((isa<OMPFirstprivateClause>(C) || isa<OMPMapClause>(C)) &&\n                 C->isImplicit() &&\n                 !isOpenMPTaskingDirective(Stack->getCurrentDirective()))) {\n        for (Stmt *CC : C->children()) {\n          if (CC)\n            Visit(CC);\n        }\n      }\n    }\n    // Check implicitly captured variables.\n    VisitSubCaptures(S);\n  }\n\n  void VisitOMPTileDirective(OMPTileDirective *S) {\n    // #pragma omp tile does not introduce data sharing.\n    VisitStmt(S);\n  }\n\n  void VisitStmt(Stmt *S) {\n    for (Stmt *C : S->children()) {\n      if (C) {\n        // Check implicitly captured variables in the task-based directives to\n        // check if they must be firstprivatized.\n        Visit(C);\n      }\n    }\n  }\n\n  void visitSubCaptures(CapturedStmt *S) {\n    for (const CapturedStmt::Capture &Cap : S->captures()) {\n      if (!Cap.capturesVariable() && !Cap.capturesVariableByCopy())\n        continue;\n      VarDecl *VD = Cap.getCapturedVar();\n      // Do not try to map the variable if it or its sub-component was mapped\n      // already.\n      if (isOpenMPTargetExecutionDirective(Stack->getCurrentDirective()) &&\n          Stack->checkMappableExprComponentListsForDecl(\n              VD, /*CurrentRegionOnly=*/true,\n              [](OMPClauseMappableExprCommon::MappableExprComponentListRef,\n                 OpenMPClauseKind) { return true; }))\n        continue;\n      DeclRefExpr *DRE = buildDeclRefExpr(\n          SemaRef, VD, VD->getType().getNonLValueExprType(SemaRef.Context),\n          Cap.getLocation(), /*RefersToCapture=*/true);\n      Visit(DRE);\n    }\n  }\n  bool isErrorFound() const { return ErrorFound; }\n  ArrayRef<Expr *> getImplicitFirstprivate() const {\n    return ImplicitFirstprivate;\n  }\n  ArrayRef<Expr *> getImplicitMap(OpenMPDefaultmapClauseKind DK,\n                                  OpenMPMapClauseKind MK) const {\n    return ImplicitMap[DK][MK];\n  }\n  ArrayRef<OpenMPMapModifierKind>\n  getImplicitMapModifier(OpenMPDefaultmapClauseKind Kind) const {\n    return ImplicitMapModifier[Kind];\n  }\n  const Sema::VarsWithInheritedDSAType &getVarsWithInheritedDSA() const {\n    return VarsWithInheritedDSA;\n  }\n\n  DSAAttrChecker(DSAStackTy *S, Sema &SemaRef, CapturedStmt *CS)\n      : Stack(S), SemaRef(SemaRef), ErrorFound(false), CS(CS) {\n    // Process declare target link variables for the target directives.\n    if (isOpenMPTargetExecutionDirective(S->getCurrentDirective())) {\n      for (DeclRefExpr *E : Stack->getLinkGlobals())\n        Visit(E);\n    }\n  }\n};\n} // namespace\n\nvoid Sema::ActOnOpenMPRegionStart(OpenMPDirectiveKind DKind, Scope *CurScope) {\n  switch (DKind) {\n  case OMPD_parallel:\n  case OMPD_parallel_for:\n  case OMPD_parallel_for_simd:\n  case OMPD_parallel_sections:\n  case OMPD_parallel_master:\n  case OMPD_teams:\n  case OMPD_teams_distribute:\n  case OMPD_teams_distribute_simd: {\n    QualType KmpInt32Ty = Context.getIntTypeForBitwidth(32, 1).withConst();\n    QualType KmpInt32PtrTy =\n        Context.getPointerType(KmpInt32Ty).withConst().withRestrict();\n    Sema::CapturedParamNameType Params[] = {\n        std::make_pair(\".global_tid.\", KmpInt32PtrTy),\n        std::make_pair(\".bound_tid.\", KmpInt32PtrTy),\n        std::make_pair(StringRef(), QualType()) // __context with shared vars\n    };\n    ActOnCapturedRegionStart(DSAStack->getConstructLoc(), CurScope, CR_OpenMP,\n                             Params);\n    break;\n  }\n  case OMPD_target_teams:\n  case OMPD_target_parallel:\n  case OMPD_target_parallel_for:\n  case OMPD_target_parallel_for_simd:\n  case OMPD_target_teams_distribute:\n  case OMPD_target_teams_distribute_simd: {\n    QualType KmpInt32Ty = Context.getIntTypeForBitwidth(32, 1).withConst();\n    QualType VoidPtrTy = Context.VoidPtrTy.withConst().withRestrict();\n    QualType KmpInt32PtrTy =\n        Context.getPointerType(KmpInt32Ty).withConst().withRestrict();\n    QualType Args[] = {VoidPtrTy};\n    FunctionProtoType::ExtProtoInfo EPI;\n    EPI.Variadic = true;\n    QualType CopyFnType = Context.getFunctionType(Context.VoidTy, Args, EPI);\n    Sema::CapturedParamNameType Params[] = {\n        std::make_pair(\".global_tid.\", KmpInt32Ty),\n        std::make_pair(\".part_id.\", KmpInt32PtrTy),\n        std::make_pair(\".privates.\", VoidPtrTy),\n        std::make_pair(\n            \".copy_fn.\",\n            Context.getPointerType(CopyFnType).withConst().withRestrict()),\n        std::make_pair(\".task_t.\", Context.VoidPtrTy.withConst()),\n        std::make_pair(StringRef(), QualType()) // __context with shared vars\n    };\n    ActOnCapturedRegionStart(DSAStack->getConstructLoc(), CurScope, CR_OpenMP,\n                             Params, /*OpenMPCaptureLevel=*/0);\n    // Mark this captured region as inlined, because we don't use outlined\n    // function directly.\n    getCurCapturedRegion()->TheCapturedDecl->addAttr(\n        AlwaysInlineAttr::CreateImplicit(\n            Context, {}, AttributeCommonInfo::AS_Keyword,\n            AlwaysInlineAttr::Keyword_forceinline));\n    Sema::CapturedParamNameType ParamsTarget[] = {\n        std::make_pair(StringRef(), QualType()) // __context with shared vars\n    };\n    // Start a captured region for 'target' with no implicit parameters.\n    ActOnCapturedRegionStart(DSAStack->getConstructLoc(), CurScope, CR_OpenMP,\n                             ParamsTarget, /*OpenMPCaptureLevel=*/1);\n    Sema::CapturedParamNameType ParamsTeamsOrParallel[] = {\n        std::make_pair(\".global_tid.\", KmpInt32PtrTy),\n        std::make_pair(\".bound_tid.\", KmpInt32PtrTy),\n        std::make_pair(StringRef(), QualType()) // __context with shared vars\n    };\n    // Start a captured region for 'teams' or 'parallel'.  Both regions have\n    // the same implicit parameters.\n    ActOnCapturedRegionStart(DSAStack->getConstructLoc(), CurScope, CR_OpenMP,\n                             ParamsTeamsOrParallel, /*OpenMPCaptureLevel=*/2);\n    break;\n  }\n  case OMPD_target:\n  case OMPD_target_simd: {\n    QualType KmpInt32Ty = Context.getIntTypeForBitwidth(32, 1).withConst();\n    QualType VoidPtrTy = Context.VoidPtrTy.withConst().withRestrict();\n    QualType KmpInt32PtrTy =\n        Context.getPointerType(KmpInt32Ty).withConst().withRestrict();\n    QualType Args[] = {VoidPtrTy};\n    FunctionProtoType::ExtProtoInfo EPI;\n    EPI.Variadic = true;\n    QualType CopyFnType = Context.getFunctionType(Context.VoidTy, Args, EPI);\n    Sema::CapturedParamNameType Params[] = {\n        std::make_pair(\".global_tid.\", KmpInt32Ty),\n        std::make_pair(\".part_id.\", KmpInt32PtrTy),\n        std::make_pair(\".privates.\", VoidPtrTy),\n        std::make_pair(\n            \".copy_fn.\",\n            Context.getPointerType(CopyFnType).withConst().withRestrict()),\n        std::make_pair(\".task_t.\", Context.VoidPtrTy.withConst()),\n        std::make_pair(StringRef(), QualType()) // __context with shared vars\n    };\n    ActOnCapturedRegionStart(DSAStack->getConstructLoc(), CurScope, CR_OpenMP,\n                             Params, /*OpenMPCaptureLevel=*/0);\n    // Mark this captured region as inlined, because we don't use outlined\n    // function directly.\n    getCurCapturedRegion()->TheCapturedDecl->addAttr(\n        AlwaysInlineAttr::CreateImplicit(\n            Context, {}, AttributeCommonInfo::AS_Keyword,\n            AlwaysInlineAttr::Keyword_forceinline));\n    ActOnCapturedRegionStart(DSAStack->getConstructLoc(), CurScope, CR_OpenMP,\n                             std::make_pair(StringRef(), QualType()),\n                             /*OpenMPCaptureLevel=*/1);\n    break;\n  }\n  case OMPD_atomic:\n  case OMPD_critical:\n  case OMPD_section:\n  case OMPD_master:\n  case OMPD_tile:\n    break;\n  case OMPD_simd:\n  case OMPD_for:\n  case OMPD_for_simd:\n  case OMPD_sections:\n  case OMPD_single:\n  case OMPD_taskgroup:\n  case OMPD_distribute:\n  case OMPD_distribute_simd:\n  case OMPD_ordered:\n  case OMPD_target_data: {\n    Sema::CapturedParamNameType Params[] = {\n        std::make_pair(StringRef(), QualType()) // __context with shared vars\n    };\n    ActOnCapturedRegionStart(DSAStack->getConstructLoc(), CurScope, CR_OpenMP,\n                             Params);\n    break;\n  }\n  case OMPD_task: {\n    QualType KmpInt32Ty = Context.getIntTypeForBitwidth(32, 1).withConst();\n    QualType VoidPtrTy = Context.VoidPtrTy.withConst().withRestrict();\n    QualType KmpInt32PtrTy =\n        Context.getPointerType(KmpInt32Ty).withConst().withRestrict();\n    QualType Args[] = {VoidPtrTy};\n    FunctionProtoType::ExtProtoInfo EPI;\n    EPI.Variadic = true;\n    QualType CopyFnType = Context.getFunctionType(Context.VoidTy, Args, EPI);\n    Sema::CapturedParamNameType Params[] = {\n        std::make_pair(\".global_tid.\", KmpInt32Ty),\n        std::make_pair(\".part_id.\", KmpInt32PtrTy),\n        std::make_pair(\".privates.\", VoidPtrTy),\n        std::make_pair(\n            \".copy_fn.\",\n            Context.getPointerType(CopyFnType).withConst().withRestrict()),\n        std::make_pair(\".task_t.\", Context.VoidPtrTy.withConst()),\n        std::make_pair(StringRef(), QualType()) // __context with shared vars\n    };\n    ActOnCapturedRegionStart(DSAStack->getConstructLoc(), CurScope, CR_OpenMP,\n                             Params);\n    // Mark this captured region as inlined, because we don't use outlined\n    // function directly.\n    getCurCapturedRegion()->TheCapturedDecl->addAttr(\n        AlwaysInlineAttr::CreateImplicit(\n            Context, {}, AttributeCommonInfo::AS_Keyword,\n            AlwaysInlineAttr::Keyword_forceinline));\n    break;\n  }\n  case OMPD_taskloop:\n  case OMPD_taskloop_simd:\n  case OMPD_master_taskloop:\n  case OMPD_master_taskloop_simd: {\n    QualType KmpInt32Ty =\n        Context.getIntTypeForBitwidth(/*DestWidth=*/32, /*Signed=*/1)\n            .withConst();\n    QualType KmpUInt64Ty =\n        Context.getIntTypeForBitwidth(/*DestWidth=*/64, /*Signed=*/0)\n            .withConst();\n    QualType KmpInt64Ty =\n        Context.getIntTypeForBitwidth(/*DestWidth=*/64, /*Signed=*/1)\n            .withConst();\n    QualType VoidPtrTy = Context.VoidPtrTy.withConst().withRestrict();\n    QualType KmpInt32PtrTy =\n        Context.getPointerType(KmpInt32Ty).withConst().withRestrict();\n    QualType Args[] = {VoidPtrTy};\n    FunctionProtoType::ExtProtoInfo EPI;\n    EPI.Variadic = true;\n    QualType CopyFnType = Context.getFunctionType(Context.VoidTy, Args, EPI);\n    Sema::CapturedParamNameType Params[] = {\n        std::make_pair(\".global_tid.\", KmpInt32Ty),\n        std::make_pair(\".part_id.\", KmpInt32PtrTy),\n        std::make_pair(\".privates.\", VoidPtrTy),\n        std::make_pair(\n            \".copy_fn.\",\n            Context.getPointerType(CopyFnType).withConst().withRestrict()),\n        std::make_pair(\".task_t.\", Context.VoidPtrTy.withConst()),\n        std::make_pair(\".lb.\", KmpUInt64Ty),\n        std::make_pair(\".ub.\", KmpUInt64Ty),\n        std::make_pair(\".st.\", KmpInt64Ty),\n        std::make_pair(\".liter.\", KmpInt32Ty),\n        std::make_pair(\".reductions.\", VoidPtrTy),\n        std::make_pair(StringRef(), QualType()) // __context with shared vars\n    };\n    ActOnCapturedRegionStart(DSAStack->getConstructLoc(), CurScope, CR_OpenMP,\n                             Params);\n    // Mark this captured region as inlined, because we don't use outlined\n    // function directly.\n    getCurCapturedRegion()->TheCapturedDecl->addAttr(\n        AlwaysInlineAttr::CreateImplicit(\n            Context, {}, AttributeCommonInfo::AS_Keyword,\n            AlwaysInlineAttr::Keyword_forceinline));\n    break;\n  }\n  case OMPD_parallel_master_taskloop:\n  case OMPD_parallel_master_taskloop_simd: {\n    QualType KmpInt32Ty =\n        Context.getIntTypeForBitwidth(/*DestWidth=*/32, /*Signed=*/1)\n            .withConst();\n    QualType KmpUInt64Ty =\n        Context.getIntTypeForBitwidth(/*DestWidth=*/64, /*Signed=*/0)\n            .withConst();\n    QualType KmpInt64Ty =\n        Context.getIntTypeForBitwidth(/*DestWidth=*/64, /*Signed=*/1)\n            .withConst();\n    QualType VoidPtrTy = Context.VoidPtrTy.withConst().withRestrict();\n    QualType KmpInt32PtrTy =\n        Context.getPointerType(KmpInt32Ty).withConst().withRestrict();\n    Sema::CapturedParamNameType ParamsParallel[] = {\n        std::make_pair(\".global_tid.\", KmpInt32PtrTy),\n        std::make_pair(\".bound_tid.\", KmpInt32PtrTy),\n        std::make_pair(StringRef(), QualType()) // __context with shared vars\n    };\n    // Start a captured region for 'parallel'.\n    ActOnCapturedRegionStart(DSAStack->getConstructLoc(), CurScope, CR_OpenMP,\n                             ParamsParallel, /*OpenMPCaptureLevel=*/0);\n    QualType Args[] = {VoidPtrTy};\n    FunctionProtoType::ExtProtoInfo EPI;\n    EPI.Variadic = true;\n    QualType CopyFnType = Context.getFunctionType(Context.VoidTy, Args, EPI);\n    Sema::CapturedParamNameType Params[] = {\n        std::make_pair(\".global_tid.\", KmpInt32Ty),\n        std::make_pair(\".part_id.\", KmpInt32PtrTy),\n        std::make_pair(\".privates.\", VoidPtrTy),\n        std::make_pair(\n            \".copy_fn.\",\n            Context.getPointerType(CopyFnType).withConst().withRestrict()),\n        std::make_pair(\".task_t.\", Context.VoidPtrTy.withConst()),\n        std::make_pair(\".lb.\", KmpUInt64Ty),\n        std::make_pair(\".ub.\", KmpUInt64Ty),\n        std::make_pair(\".st.\", KmpInt64Ty),\n        std::make_pair(\".liter.\", KmpInt32Ty),\n        std::make_pair(\".reductions.\", VoidPtrTy),\n        std::make_pair(StringRef(), QualType()) // __context with shared vars\n    };\n    ActOnCapturedRegionStart(DSAStack->getConstructLoc(), CurScope, CR_OpenMP,\n                             Params, /*OpenMPCaptureLevel=*/1);\n    // Mark this captured region as inlined, because we don't use outlined\n    // function directly.\n    getCurCapturedRegion()->TheCapturedDecl->addAttr(\n        AlwaysInlineAttr::CreateImplicit(\n            Context, {}, AttributeCommonInfo::AS_Keyword,\n            AlwaysInlineAttr::Keyword_forceinline));\n    break;\n  }\n  case OMPD_distribute_parallel_for_simd:\n  case OMPD_distribute_parallel_for: {\n    QualType KmpInt32Ty = Context.getIntTypeForBitwidth(32, 1).withConst();\n    QualType KmpInt32PtrTy =\n        Context.getPointerType(KmpInt32Ty).withConst().withRestrict();\n    Sema::CapturedParamNameType Params[] = {\n        std::make_pair(\".global_tid.\", KmpInt32PtrTy),\n        std::make_pair(\".bound_tid.\", KmpInt32PtrTy),\n        std::make_pair(\".previous.lb.\", Context.getSizeType().withConst()),\n        std::make_pair(\".previous.ub.\", Context.getSizeType().withConst()),\n        std::make_pair(StringRef(), QualType()) // __context with shared vars\n    };\n    ActOnCapturedRegionStart(DSAStack->getConstructLoc(), CurScope, CR_OpenMP,\n                             Params);\n    break;\n  }\n  case OMPD_target_teams_distribute_parallel_for:\n  case OMPD_target_teams_distribute_parallel_for_simd: {\n    QualType KmpInt32Ty = Context.getIntTypeForBitwidth(32, 1).withConst();\n    QualType KmpInt32PtrTy =\n        Context.getPointerType(KmpInt32Ty).withConst().withRestrict();\n    QualType VoidPtrTy = Context.VoidPtrTy.withConst().withRestrict();\n\n    QualType Args[] = {VoidPtrTy};\n    FunctionProtoType::ExtProtoInfo EPI;\n    EPI.Variadic = true;\n    QualType CopyFnType = Context.getFunctionType(Context.VoidTy, Args, EPI);\n    Sema::CapturedParamNameType Params[] = {\n        std::make_pair(\".global_tid.\", KmpInt32Ty),\n        std::make_pair(\".part_id.\", KmpInt32PtrTy),\n        std::make_pair(\".privates.\", VoidPtrTy),\n        std::make_pair(\n            \".copy_fn.\",\n            Context.getPointerType(CopyFnType).withConst().withRestrict()),\n        std::make_pair(\".task_t.\", Context.VoidPtrTy.withConst()),\n        std::make_pair(StringRef(), QualType()) // __context with shared vars\n    };\n    ActOnCapturedRegionStart(DSAStack->getConstructLoc(), CurScope, CR_OpenMP,\n                             Params, /*OpenMPCaptureLevel=*/0);\n    // Mark this captured region as inlined, because we don't use outlined\n    // function directly.\n    getCurCapturedRegion()->TheCapturedDecl->addAttr(\n        AlwaysInlineAttr::CreateImplicit(\n            Context, {}, AttributeCommonInfo::AS_Keyword,\n            AlwaysInlineAttr::Keyword_forceinline));\n    Sema::CapturedParamNameType ParamsTarget[] = {\n        std::make_pair(StringRef(), QualType()) // __context with shared vars\n    };\n    // Start a captured region for 'target' with no implicit parameters.\n    ActOnCapturedRegionStart(DSAStack->getConstructLoc(), CurScope, CR_OpenMP,\n                             ParamsTarget, /*OpenMPCaptureLevel=*/1);\n\n    Sema::CapturedParamNameType ParamsTeams[] = {\n        std::make_pair(\".global_tid.\", KmpInt32PtrTy),\n        std::make_pair(\".bound_tid.\", KmpInt32PtrTy),\n        std::make_pair(StringRef(), QualType()) // __context with shared vars\n    };\n    // Start a captured region for 'target' with no implicit parameters.\n    ActOnCapturedRegionStart(DSAStack->getConstructLoc(), CurScope, CR_OpenMP,\n                             ParamsTeams, /*OpenMPCaptureLevel=*/2);\n\n    Sema::CapturedParamNameType ParamsParallel[] = {\n        std::make_pair(\".global_tid.\", KmpInt32PtrTy),\n        std::make_pair(\".bound_tid.\", KmpInt32PtrTy),\n        std::make_pair(\".previous.lb.\", Context.getSizeType().withConst()),\n        std::make_pair(\".previous.ub.\", Context.getSizeType().withConst()),\n        std::make_pair(StringRef(), QualType()) // __context with shared vars\n    };\n    // Start a captured region for 'teams' or 'parallel'.  Both regions have\n    // the same implicit parameters.\n    ActOnCapturedRegionStart(DSAStack->getConstructLoc(), CurScope, CR_OpenMP,\n                             ParamsParallel, /*OpenMPCaptureLevel=*/3);\n    break;\n  }\n\n  case OMPD_teams_distribute_parallel_for:\n  case OMPD_teams_distribute_parallel_for_simd: {\n    QualType KmpInt32Ty = Context.getIntTypeForBitwidth(32, 1).withConst();\n    QualType KmpInt32PtrTy =\n        Context.getPointerType(KmpInt32Ty).withConst().withRestrict();\n\n    Sema::CapturedParamNameType ParamsTeams[] = {\n        std::make_pair(\".global_tid.\", KmpInt32PtrTy),\n        std::make_pair(\".bound_tid.\", KmpInt32PtrTy),\n        std::make_pair(StringRef(), QualType()) // __context with shared vars\n    };\n    // Start a captured region for 'target' with no implicit parameters.\n    ActOnCapturedRegionStart(DSAStack->getConstructLoc(), CurScope, CR_OpenMP,\n                             ParamsTeams, /*OpenMPCaptureLevel=*/0);\n\n    Sema::CapturedParamNameType ParamsParallel[] = {\n        std::make_pair(\".global_tid.\", KmpInt32PtrTy),\n        std::make_pair(\".bound_tid.\", KmpInt32PtrTy),\n        std::make_pair(\".previous.lb.\", Context.getSizeType().withConst()),\n        std::make_pair(\".previous.ub.\", Context.getSizeType().withConst()),\n        std::make_pair(StringRef(), QualType()) // __context with shared vars\n    };\n    // Start a captured region for 'teams' or 'parallel'.  Both regions have\n    // the same implicit parameters.\n    ActOnCapturedRegionStart(DSAStack->getConstructLoc(), CurScope, CR_OpenMP,\n                             ParamsParallel, /*OpenMPCaptureLevel=*/1);\n    break;\n  }\n  case OMPD_target_update:\n  case OMPD_target_enter_data:\n  case OMPD_target_exit_data: {\n    QualType KmpInt32Ty = Context.getIntTypeForBitwidth(32, 1).withConst();\n    QualType VoidPtrTy = Context.VoidPtrTy.withConst().withRestrict();\n    QualType KmpInt32PtrTy =\n        Context.getPointerType(KmpInt32Ty).withConst().withRestrict();\n    QualType Args[] = {VoidPtrTy};\n    FunctionProtoType::ExtProtoInfo EPI;\n    EPI.Variadic = true;\n    QualType CopyFnType = Context.getFunctionType(Context.VoidTy, Args, EPI);\n    Sema::CapturedParamNameType Params[] = {\n        std::make_pair(\".global_tid.\", KmpInt32Ty),\n        std::make_pair(\".part_id.\", KmpInt32PtrTy),\n        std::make_pair(\".privates.\", VoidPtrTy),\n        std::make_pair(\n            \".copy_fn.\",\n            Context.getPointerType(CopyFnType).withConst().withRestrict()),\n        std::make_pair(\".task_t.\", Context.VoidPtrTy.withConst()),\n        std::make_pair(StringRef(), QualType()) // __context with shared vars\n    };\n    ActOnCapturedRegionStart(DSAStack->getConstructLoc(), CurScope, CR_OpenMP,\n                             Params);\n    // Mark this captured region as inlined, because we don't use outlined\n    // function directly.\n    getCurCapturedRegion()->TheCapturedDecl->addAttr(\n        AlwaysInlineAttr::CreateImplicit(\n            Context, {}, AttributeCommonInfo::AS_Keyword,\n            AlwaysInlineAttr::Keyword_forceinline));\n    break;\n  }\n  case OMPD_threadprivate:\n  case OMPD_allocate:\n  case OMPD_taskyield:\n  case OMPD_barrier:\n  case OMPD_taskwait:\n  case OMPD_cancellation_point:\n  case OMPD_cancel:\n  case OMPD_flush:\n  case OMPD_depobj:\n  case OMPD_scan:\n  case OMPD_declare_reduction:\n  case OMPD_declare_mapper:\n  case OMPD_declare_simd:\n  case OMPD_declare_target:\n  case OMPD_end_declare_target:\n  case OMPD_requires:\n  case OMPD_declare_variant:\n  case OMPD_begin_declare_variant:\n  case OMPD_end_declare_variant:\n    llvm_unreachable(\"OpenMP Directive is not allowed\");\n  case OMPD_unknown:\n  default:\n    llvm_unreachable(\"Unknown OpenMP directive\");\n  }\n  DSAStack->setContext(CurContext);\n}\n\nint Sema::getNumberOfConstructScopes(unsigned Level) const {\n  return getOpenMPCaptureLevels(DSAStack->getDirective(Level));\n}\n\nint Sema::getOpenMPCaptureLevels(OpenMPDirectiveKind DKind) {\n  SmallVector<OpenMPDirectiveKind, 4> CaptureRegions;\n  getOpenMPCaptureRegions(CaptureRegions, DKind);\n  return CaptureRegions.size();\n}\n\nstatic OMPCapturedExprDecl *buildCaptureDecl(Sema &S, IdentifierInfo *Id,\n                                             Expr *CaptureExpr, bool WithInit,\n                                             bool AsExpression) {\n  assert(CaptureExpr);\n  ASTContext &C = S.getASTContext();\n  Expr *Init = AsExpression ? CaptureExpr : CaptureExpr->IgnoreImpCasts();\n  QualType Ty = Init->getType();\n  if (CaptureExpr->getObjectKind() == OK_Ordinary && CaptureExpr->isGLValue()) {\n    if (S.getLangOpts().CPlusPlus) {\n      Ty = C.getLValueReferenceType(Ty);\n    } else {\n      Ty = C.getPointerType(Ty);\n      ExprResult Res =\n          S.CreateBuiltinUnaryOp(CaptureExpr->getExprLoc(), UO_AddrOf, Init);\n      if (!Res.isUsable())\n        return nullptr;\n      Init = Res.get();\n    }\n    WithInit = true;\n  }\n  auto *CED = OMPCapturedExprDecl::Create(C, S.CurContext, Id, Ty,\n                                          CaptureExpr->getBeginLoc());\n  if (!WithInit)\n    CED->addAttr(OMPCaptureNoInitAttr::CreateImplicit(C));\n  S.CurContext->addHiddenDecl(CED);\n  Sema::TentativeAnalysisScope Trap(S);\n  S.AddInitializerToDecl(CED, Init, /*DirectInit=*/false);\n  return CED;\n}\n\nstatic DeclRefExpr *buildCapture(Sema &S, ValueDecl *D, Expr *CaptureExpr,\n                                 bool WithInit) {\n  OMPCapturedExprDecl *CD;\n  if (VarDecl *VD = S.isOpenMPCapturedDecl(D))\n    CD = cast<OMPCapturedExprDecl>(VD);\n  else\n    CD = buildCaptureDecl(S, D->getIdentifier(), CaptureExpr, WithInit,\n                          /*AsExpression=*/false);\n  return buildDeclRefExpr(S, CD, CD->getType().getNonReferenceType(),\n                          CaptureExpr->getExprLoc());\n}\n\nstatic ExprResult buildCapture(Sema &S, Expr *CaptureExpr, DeclRefExpr *&Ref) {\n  CaptureExpr = S.DefaultLvalueConversion(CaptureExpr).get();\n  if (!Ref) {\n    OMPCapturedExprDecl *CD = buildCaptureDecl(\n        S, &S.getASTContext().Idents.get(\".capture_expr.\"), CaptureExpr,\n        /*WithInit=*/true, /*AsExpression=*/true);\n    Ref = buildDeclRefExpr(S, CD, CD->getType().getNonReferenceType(),\n                           CaptureExpr->getExprLoc());\n  }\n  ExprResult Res = Ref;\n  if (!S.getLangOpts().CPlusPlus &&\n      CaptureExpr->getObjectKind() == OK_Ordinary && CaptureExpr->isGLValue() &&\n      Ref->getType()->isPointerType()) {\n    Res = S.CreateBuiltinUnaryOp(CaptureExpr->getExprLoc(), UO_Deref, Ref);\n    if (!Res.isUsable())\n      return ExprError();\n  }\n  return S.DefaultLvalueConversion(Res.get());\n}\n\nnamespace {\n// OpenMP directives parsed in this section are represented as a\n// CapturedStatement with an associated statement.  If a syntax error\n// is detected during the parsing of the associated statement, the\n// compiler must abort processing and close the CapturedStatement.\n//\n// Combined directives such as 'target parallel' have more than one\n// nested CapturedStatements.  This RAII ensures that we unwind out\n// of all the nested CapturedStatements when an error is found.\nclass CaptureRegionUnwinderRAII {\nprivate:\n  Sema &S;\n  bool &ErrorFound;\n  OpenMPDirectiveKind DKind = OMPD_unknown;\n\npublic:\n  CaptureRegionUnwinderRAII(Sema &S, bool &ErrorFound,\n                            OpenMPDirectiveKind DKind)\n      : S(S), ErrorFound(ErrorFound), DKind(DKind) {}\n  ~CaptureRegionUnwinderRAII() {\n    if (ErrorFound) {\n      int ThisCaptureLevel = S.getOpenMPCaptureLevels(DKind);\n      while (--ThisCaptureLevel >= 0)\n        S.ActOnCapturedRegionError();\n    }\n  }\n};\n} // namespace\n\nvoid Sema::tryCaptureOpenMPLambdas(ValueDecl *V) {\n  // Capture variables captured by reference in lambdas for target-based\n  // directives.\n  if (!CurContext->isDependentContext() &&\n      (isOpenMPTargetExecutionDirective(DSAStack->getCurrentDirective()) ||\n       isOpenMPTargetDataManagementDirective(\n           DSAStack->getCurrentDirective()))) {\n    QualType Type = V->getType();\n    if (const auto *RD = Type.getCanonicalType()\n                             .getNonReferenceType()\n                             ->getAsCXXRecordDecl()) {\n      bool SavedForceCaptureByReferenceInTargetExecutable =\n          DSAStack->isForceCaptureByReferenceInTargetExecutable();\n      DSAStack->setForceCaptureByReferenceInTargetExecutable(\n          /*V=*/true);\n      if (RD->isLambda()) {\n        llvm::DenseMap<const VarDecl *, FieldDecl *> Captures;\n        FieldDecl *ThisCapture;\n        RD->getCaptureFields(Captures, ThisCapture);\n        for (const LambdaCapture &LC : RD->captures()) {\n          if (LC.getCaptureKind() == LCK_ByRef) {\n            VarDecl *VD = LC.getCapturedVar();\n            DeclContext *VDC = VD->getDeclContext();\n            if (!VDC->Encloses(CurContext))\n              continue;\n            MarkVariableReferenced(LC.getLocation(), VD);\n          } else if (LC.getCaptureKind() == LCK_This) {\n            QualType ThisTy = getCurrentThisType();\n            if (!ThisTy.isNull() &&\n                Context.typesAreCompatible(ThisTy, ThisCapture->getType()))\n              CheckCXXThisCapture(LC.getLocation());\n          }\n        }\n      }\n      DSAStack->setForceCaptureByReferenceInTargetExecutable(\n          SavedForceCaptureByReferenceInTargetExecutable);\n    }\n  }\n}\n\nstatic bool checkOrderedOrderSpecified(Sema &S,\n                                       const ArrayRef<OMPClause *> Clauses) {\n  const OMPOrderedClause *Ordered = nullptr;\n  const OMPOrderClause *Order = nullptr;\n\n  for (const OMPClause *Clause : Clauses) {\n    if (Clause->getClauseKind() == OMPC_ordered)\n      Ordered = cast<OMPOrderedClause>(Clause);\n    else if (Clause->getClauseKind() == OMPC_order) {\n      Order = cast<OMPOrderClause>(Clause);\n      if (Order->getKind() != OMPC_ORDER_concurrent)\n        Order = nullptr;\n    }\n    if (Ordered && Order)\n      break;\n  }\n\n  if (Ordered && Order) {\n    S.Diag(Order->getKindKwLoc(),\n           diag::err_omp_simple_clause_incompatible_with_ordered)\n        << getOpenMPClauseName(OMPC_order)\n        << getOpenMPSimpleClauseTypeName(OMPC_order, OMPC_ORDER_concurrent)\n        << SourceRange(Order->getBeginLoc(), Order->getEndLoc());\n    S.Diag(Ordered->getBeginLoc(), diag::note_omp_ordered_param)\n        << 0 << SourceRange(Ordered->getBeginLoc(), Ordered->getEndLoc());\n    return true;\n  }\n  return false;\n}\n\nStmtResult Sema::ActOnOpenMPRegionEnd(StmtResult S,\n                                      ArrayRef<OMPClause *> Clauses) {\n  if (DSAStack->getCurrentDirective() == OMPD_atomic ||\n      DSAStack->getCurrentDirective() == OMPD_critical ||\n      DSAStack->getCurrentDirective() == OMPD_section ||\n      DSAStack->getCurrentDirective() == OMPD_master)\n    return S;\n\n  bool ErrorFound = false;\n  CaptureRegionUnwinderRAII CaptureRegionUnwinder(\n      *this, ErrorFound, DSAStack->getCurrentDirective());\n  if (!S.isUsable()) {\n    ErrorFound = true;\n    return StmtError();\n  }\n\n  SmallVector<OpenMPDirectiveKind, 4> CaptureRegions;\n  getOpenMPCaptureRegions(CaptureRegions, DSAStack->getCurrentDirective());\n  OMPOrderedClause *OC = nullptr;\n  OMPScheduleClause *SC = nullptr;\n  SmallVector<const OMPLinearClause *, 4> LCs;\n  SmallVector<const OMPClauseWithPreInit *, 4> PICs;\n  // This is required for proper codegen.\n  for (OMPClause *Clause : Clauses) {\n    if (!LangOpts.OpenMPSimd &&\n        isOpenMPTaskingDirective(DSAStack->getCurrentDirective()) &&\n        Clause->getClauseKind() == OMPC_in_reduction) {\n      // Capture taskgroup task_reduction descriptors inside the tasking regions\n      // with the corresponding in_reduction items.\n      auto *IRC = cast<OMPInReductionClause>(Clause);\n      for (Expr *E : IRC->taskgroup_descriptors())\n        if (E)\n          MarkDeclarationsReferencedInExpr(E);\n    }\n    if (isOpenMPPrivate(Clause->getClauseKind()) ||\n        Clause->getClauseKind() == OMPC_copyprivate ||\n        (getLangOpts().OpenMPUseTLS &&\n         getASTContext().getTargetInfo().isTLSSupported() &&\n         Clause->getClauseKind() == OMPC_copyin)) {\n      DSAStack->setForceVarCapturing(Clause->getClauseKind() == OMPC_copyin);\n      // Mark all variables in private list clauses as used in inner region.\n      for (Stmt *VarRef : Clause->children()) {\n        if (auto *E = cast_or_null<Expr>(VarRef)) {\n          MarkDeclarationsReferencedInExpr(E);\n        }\n      }\n      DSAStack->setForceVarCapturing(/*V=*/false);\n    } else if (isOpenMPLoopTransformationDirective(\n                   DSAStack->getCurrentDirective())) {\n      assert(CaptureRegions.empty() &&\n             \"No captured regions in loop transformation directives.\");\n    } else if (CaptureRegions.size() > 1 ||\n               CaptureRegions.back() != OMPD_unknown) {\n      if (auto *C = OMPClauseWithPreInit::get(Clause))\n        PICs.push_back(C);\n      if (auto *C = OMPClauseWithPostUpdate::get(Clause)) {\n        if (Expr *E = C->getPostUpdateExpr())\n          MarkDeclarationsReferencedInExpr(E);\n      }\n    }\n    if (Clause->getClauseKind() == OMPC_schedule)\n      SC = cast<OMPScheduleClause>(Clause);\n    else if (Clause->getClauseKind() == OMPC_ordered)\n      OC = cast<OMPOrderedClause>(Clause);\n    else if (Clause->getClauseKind() == OMPC_linear)\n      LCs.push_back(cast<OMPLinearClause>(Clause));\n  }\n  // Capture allocator expressions if used.\n  for (Expr *E : DSAStack->getInnerAllocators())\n    MarkDeclarationsReferencedInExpr(E);\n  // OpenMP, 2.7.1 Loop Construct, Restrictions\n  // The nonmonotonic modifier cannot be specified if an ordered clause is\n  // specified.\n  if (SC &&\n      (SC->getFirstScheduleModifier() == OMPC_SCHEDULE_MODIFIER_nonmonotonic ||\n       SC->getSecondScheduleModifier() ==\n           OMPC_SCHEDULE_MODIFIER_nonmonotonic) &&\n      OC) {\n    Diag(SC->getFirstScheduleModifier() == OMPC_SCHEDULE_MODIFIER_nonmonotonic\n             ? SC->getFirstScheduleModifierLoc()\n             : SC->getSecondScheduleModifierLoc(),\n         diag::err_omp_simple_clause_incompatible_with_ordered)\n        << getOpenMPClauseName(OMPC_schedule)\n        << getOpenMPSimpleClauseTypeName(OMPC_schedule,\n                                         OMPC_SCHEDULE_MODIFIER_nonmonotonic)\n        << SourceRange(OC->getBeginLoc(), OC->getEndLoc());\n    ErrorFound = true;\n  }\n  // OpenMP 5.0, 2.9.2 Worksharing-Loop Construct, Restrictions.\n  // If an order(concurrent) clause is present, an ordered clause may not appear\n  // on the same directive.\n  if (checkOrderedOrderSpecified(*this, Clauses))\n    ErrorFound = true;\n  if (!LCs.empty() && OC && OC->getNumForLoops()) {\n    for (const OMPLinearClause *C : LCs) {\n      Diag(C->getBeginLoc(), diag::err_omp_linear_ordered)\n          << SourceRange(OC->getBeginLoc(), OC->getEndLoc());\n    }\n    ErrorFound = true;\n  }\n  if (isOpenMPWorksharingDirective(DSAStack->getCurrentDirective()) &&\n      isOpenMPSimdDirective(DSAStack->getCurrentDirective()) && OC &&\n      OC->getNumForLoops()) {\n    Diag(OC->getBeginLoc(), diag::err_omp_ordered_simd)\n        << getOpenMPDirectiveName(DSAStack->getCurrentDirective());\n    ErrorFound = true;\n  }\n  if (ErrorFound) {\n    return StmtError();\n  }\n  StmtResult SR = S;\n  unsigned CompletedRegions = 0;\n  for (OpenMPDirectiveKind ThisCaptureRegion : llvm::reverse(CaptureRegions)) {\n    // Mark all variables in private list clauses as used in inner region.\n    // Required for proper codegen of combined directives.\n    // TODO: add processing for other clauses.\n    if (ThisCaptureRegion != OMPD_unknown) {\n      for (const clang::OMPClauseWithPreInit *C : PICs) {\n        OpenMPDirectiveKind CaptureRegion = C->getCaptureRegion();\n        // Find the particular capture region for the clause if the\n        // directive is a combined one with multiple capture regions.\n        // If the directive is not a combined one, the capture region\n        // associated with the clause is OMPD_unknown and is generated\n        // only once.\n        if (CaptureRegion == ThisCaptureRegion ||\n            CaptureRegion == OMPD_unknown) {\n          if (auto *DS = cast_or_null<DeclStmt>(C->getPreInitStmt())) {\n            for (Decl *D : DS->decls())\n              MarkVariableReferenced(D->getLocation(), cast<VarDecl>(D));\n          }\n        }\n      }\n    }\n    if (ThisCaptureRegion == OMPD_target) {\n      // Capture allocator traits in the target region. They are used implicitly\n      // and, thus, are not captured by default.\n      for (OMPClause *C : Clauses) {\n        if (const auto *UAC = dyn_cast<OMPUsesAllocatorsClause>(C)) {\n          for (unsigned I = 0, End = UAC->getNumberOfAllocators(); I < End;\n               ++I) {\n            OMPUsesAllocatorsClause::Data D = UAC->getAllocatorData(I);\n            if (Expr *E = D.AllocatorTraits)\n              MarkDeclarationsReferencedInExpr(E);\n          }\n          continue;\n        }\n      }\n    }\n    if (++CompletedRegions == CaptureRegions.size())\n      DSAStack->setBodyComplete();\n    SR = ActOnCapturedRegionEnd(SR.get());\n  }\n  return SR;\n}\n\nstatic bool checkCancelRegion(Sema &SemaRef, OpenMPDirectiveKind CurrentRegion,\n                              OpenMPDirectiveKind CancelRegion,\n                              SourceLocation StartLoc) {\n  // CancelRegion is only needed for cancel and cancellation_point.\n  if (CurrentRegion != OMPD_cancel && CurrentRegion != OMPD_cancellation_point)\n    return false;\n\n  if (CancelRegion == OMPD_parallel || CancelRegion == OMPD_for ||\n      CancelRegion == OMPD_sections || CancelRegion == OMPD_taskgroup)\n    return false;\n\n  SemaRef.Diag(StartLoc, diag::err_omp_wrong_cancel_region)\n      << getOpenMPDirectiveName(CancelRegion);\n  return true;\n}\n\nstatic bool checkNestingOfRegions(Sema &SemaRef, const DSAStackTy *Stack,\n                                  OpenMPDirectiveKind CurrentRegion,\n                                  const DeclarationNameInfo &CurrentName,\n                                  OpenMPDirectiveKind CancelRegion,\n                                  SourceLocation StartLoc) {\n  if (Stack->getCurScope()) {\n    OpenMPDirectiveKind ParentRegion = Stack->getParentDirective();\n    OpenMPDirectiveKind OffendingRegion = ParentRegion;\n    bool NestingProhibited = false;\n    bool CloseNesting = true;\n    bool OrphanSeen = false;\n    enum {\n      NoRecommend,\n      ShouldBeInParallelRegion,\n      ShouldBeInOrderedRegion,\n      ShouldBeInTargetRegion,\n      ShouldBeInTeamsRegion,\n      ShouldBeInLoopSimdRegion,\n    } Recommend = NoRecommend;\n    if (isOpenMPSimdDirective(ParentRegion) &&\n        ((SemaRef.LangOpts.OpenMP <= 45 && CurrentRegion != OMPD_ordered) ||\n         (SemaRef.LangOpts.OpenMP >= 50 && CurrentRegion != OMPD_ordered &&\n          CurrentRegion != OMPD_simd && CurrentRegion != OMPD_atomic &&\n          CurrentRegion != OMPD_scan))) {\n      // OpenMP [2.16, Nesting of Regions]\n      // OpenMP constructs may not be nested inside a simd region.\n      // OpenMP [2.8.1,simd Construct, Restrictions]\n      // An ordered construct with the simd clause is the only OpenMP\n      // construct that can appear in the simd region.\n      // Allowing a SIMD construct nested in another SIMD construct is an\n      // extension. The OpenMP 4.5 spec does not allow it. Issue a warning\n      // message.\n      // OpenMP 5.0 [2.9.3.1, simd Construct, Restrictions]\n      // The only OpenMP constructs that can be encountered during execution of\n      // a simd region are the atomic construct, the loop construct, the simd\n      // construct and the ordered construct with the simd clause.\n      SemaRef.Diag(StartLoc, (CurrentRegion != OMPD_simd)\n                                 ? diag::err_omp_prohibited_region_simd\n                                 : diag::warn_omp_nesting_simd)\n          << (SemaRef.LangOpts.OpenMP >= 50 ? 1 : 0);\n      return CurrentRegion != OMPD_simd;\n    }\n    if (ParentRegion == OMPD_atomic) {\n      // OpenMP [2.16, Nesting of Regions]\n      // OpenMP constructs may not be nested inside an atomic region.\n      SemaRef.Diag(StartLoc, diag::err_omp_prohibited_region_atomic);\n      return true;\n    }\n    if (CurrentRegion == OMPD_section) {\n      // OpenMP [2.7.2, sections Construct, Restrictions]\n      // Orphaned section directives are prohibited. That is, the section\n      // directives must appear within the sections construct and must not be\n      // encountered elsewhere in the sections region.\n      if (ParentRegion != OMPD_sections &&\n          ParentRegion != OMPD_parallel_sections) {\n        SemaRef.Diag(StartLoc, diag::err_omp_orphaned_section_directive)\n            << (ParentRegion != OMPD_unknown)\n            << getOpenMPDirectiveName(ParentRegion);\n        return true;\n      }\n      return false;\n    }\n    // Allow some constructs (except teams and cancellation constructs) to be\n    // orphaned (they could be used in functions, called from OpenMP regions\n    // with the required preconditions).\n    if (ParentRegion == OMPD_unknown &&\n        !isOpenMPNestingTeamsDirective(CurrentRegion) &&\n        CurrentRegion != OMPD_cancellation_point &&\n        CurrentRegion != OMPD_cancel && CurrentRegion != OMPD_scan)\n      return false;\n    if (CurrentRegion == OMPD_cancellation_point ||\n        CurrentRegion == OMPD_cancel) {\n      // OpenMP [2.16, Nesting of Regions]\n      // A cancellation point construct for which construct-type-clause is\n      // taskgroup must be nested inside a task construct. A cancellation\n      // point construct for which construct-type-clause is not taskgroup must\n      // be closely nested inside an OpenMP construct that matches the type\n      // specified in construct-type-clause.\n      // A cancel construct for which construct-type-clause is taskgroup must be\n      // nested inside a task construct. A cancel construct for which\n      // construct-type-clause is not taskgroup must be closely nested inside an\n      // OpenMP construct that matches the type specified in\n      // construct-type-clause.\n      NestingProhibited =\n          !((CancelRegion == OMPD_parallel &&\n             (ParentRegion == OMPD_parallel ||\n              ParentRegion == OMPD_target_parallel)) ||\n            (CancelRegion == OMPD_for &&\n             (ParentRegion == OMPD_for || ParentRegion == OMPD_parallel_for ||\n              ParentRegion == OMPD_target_parallel_for ||\n              ParentRegion == OMPD_distribute_parallel_for ||\n              ParentRegion == OMPD_teams_distribute_parallel_for ||\n              ParentRegion == OMPD_target_teams_distribute_parallel_for)) ||\n            (CancelRegion == OMPD_taskgroup &&\n             (ParentRegion == OMPD_task ||\n              (SemaRef.getLangOpts().OpenMP >= 50 &&\n               (ParentRegion == OMPD_taskloop ||\n                ParentRegion == OMPD_master_taskloop ||\n                ParentRegion == OMPD_parallel_master_taskloop)))) ||\n            (CancelRegion == OMPD_sections &&\n             (ParentRegion == OMPD_section || ParentRegion == OMPD_sections ||\n              ParentRegion == OMPD_parallel_sections)));\n      OrphanSeen = ParentRegion == OMPD_unknown;\n    } else if (CurrentRegion == OMPD_master) {\n      // OpenMP [2.16, Nesting of Regions]\n      // A master region may not be closely nested inside a worksharing,\n      // atomic, or explicit task region.\n      NestingProhibited = isOpenMPWorksharingDirective(ParentRegion) ||\n                          isOpenMPTaskingDirective(ParentRegion);\n    } else if (CurrentRegion == OMPD_critical && CurrentName.getName()) {\n      // OpenMP [2.16, Nesting of Regions]\n      // A critical region may not be nested (closely or otherwise) inside a\n      // critical region with the same name. Note that this restriction is not\n      // sufficient to prevent deadlock.\n      SourceLocation PreviousCriticalLoc;\n      bool DeadLock = Stack->hasDirective(\n          [CurrentName, &PreviousCriticalLoc](OpenMPDirectiveKind K,\n                                              const DeclarationNameInfo &DNI,\n                                              SourceLocation Loc) {\n            if (K == OMPD_critical && DNI.getName() == CurrentName.getName()) {\n              PreviousCriticalLoc = Loc;\n              return true;\n            }\n            return false;\n          },\n          false /* skip top directive */);\n      if (DeadLock) {\n        SemaRef.Diag(StartLoc,\n                     diag::err_omp_prohibited_region_critical_same_name)\n            << CurrentName.getName();\n        if (PreviousCriticalLoc.isValid())\n          SemaRef.Diag(PreviousCriticalLoc,\n                       diag::note_omp_previous_critical_region);\n        return true;\n      }\n    } else if (CurrentRegion == OMPD_barrier) {\n      // OpenMP [2.16, Nesting of Regions]\n      // A barrier region may not be closely nested inside a worksharing,\n      // explicit task, critical, ordered, atomic, or master region.\n      NestingProhibited = isOpenMPWorksharingDirective(ParentRegion) ||\n                          isOpenMPTaskingDirective(ParentRegion) ||\n                          ParentRegion == OMPD_master ||\n                          ParentRegion == OMPD_parallel_master ||\n                          ParentRegion == OMPD_critical ||\n                          ParentRegion == OMPD_ordered;\n    } else if (isOpenMPWorksharingDirective(CurrentRegion) &&\n               !isOpenMPParallelDirective(CurrentRegion) &&\n               !isOpenMPTeamsDirective(CurrentRegion)) {\n      // OpenMP [2.16, Nesting of Regions]\n      // A worksharing region may not be closely nested inside a worksharing,\n      // explicit task, critical, ordered, atomic, or master region.\n      NestingProhibited = isOpenMPWorksharingDirective(ParentRegion) ||\n                          isOpenMPTaskingDirective(ParentRegion) ||\n                          ParentRegion == OMPD_master ||\n                          ParentRegion == OMPD_parallel_master ||\n                          ParentRegion == OMPD_critical ||\n                          ParentRegion == OMPD_ordered;\n      Recommend = ShouldBeInParallelRegion;\n    } else if (CurrentRegion == OMPD_ordered) {\n      // OpenMP [2.16, Nesting of Regions]\n      // An ordered region may not be closely nested inside a critical,\n      // atomic, or explicit task region.\n      // An ordered region must be closely nested inside a loop region (or\n      // parallel loop region) with an ordered clause.\n      // OpenMP [2.8.1,simd Construct, Restrictions]\n      // An ordered construct with the simd clause is the only OpenMP construct\n      // that can appear in the simd region.\n      NestingProhibited = ParentRegion == OMPD_critical ||\n                          isOpenMPTaskingDirective(ParentRegion) ||\n                          !(isOpenMPSimdDirective(ParentRegion) ||\n                            Stack->isParentOrderedRegion());\n      Recommend = ShouldBeInOrderedRegion;\n    } else if (isOpenMPNestingTeamsDirective(CurrentRegion)) {\n      // OpenMP [2.16, Nesting of Regions]\n      // If specified, a teams construct must be contained within a target\n      // construct.\n      NestingProhibited =\n          (SemaRef.LangOpts.OpenMP <= 45 && ParentRegion != OMPD_target) ||\n          (SemaRef.LangOpts.OpenMP >= 50 && ParentRegion != OMPD_unknown &&\n           ParentRegion != OMPD_target);\n      OrphanSeen = ParentRegion == OMPD_unknown;\n      Recommend = ShouldBeInTargetRegion;\n    } else if (CurrentRegion == OMPD_scan) {\n      // OpenMP [2.16, Nesting of Regions]\n      // If specified, a teams construct must be contained within a target\n      // construct.\n      NestingProhibited =\n          SemaRef.LangOpts.OpenMP < 50 ||\n          (ParentRegion != OMPD_simd && ParentRegion != OMPD_for &&\n           ParentRegion != OMPD_for_simd && ParentRegion != OMPD_parallel_for &&\n           ParentRegion != OMPD_parallel_for_simd);\n      OrphanSeen = ParentRegion == OMPD_unknown;\n      Recommend = ShouldBeInLoopSimdRegion;\n    }\n    if (!NestingProhibited &&\n        !isOpenMPTargetExecutionDirective(CurrentRegion) &&\n        !isOpenMPTargetDataManagementDirective(CurrentRegion) &&\n        (ParentRegion == OMPD_teams || ParentRegion == OMPD_target_teams)) {\n      // OpenMP [2.16, Nesting of Regions]\n      // distribute, parallel, parallel sections, parallel workshare, and the\n      // parallel loop and parallel loop SIMD constructs are the only OpenMP\n      // constructs that can be closely nested in the teams region.\n      NestingProhibited = !isOpenMPParallelDirective(CurrentRegion) &&\n                          !isOpenMPDistributeDirective(CurrentRegion);\n      Recommend = ShouldBeInParallelRegion;\n    }\n    if (!NestingProhibited &&\n        isOpenMPNestingDistributeDirective(CurrentRegion)) {\n      // OpenMP 4.5 [2.17 Nesting of Regions]\n      // The region associated with the distribute construct must be strictly\n      // nested inside a teams region\n      NestingProhibited =\n          (ParentRegion != OMPD_teams && ParentRegion != OMPD_target_teams);\n      Recommend = ShouldBeInTeamsRegion;\n    }\n    if (!NestingProhibited &&\n        (isOpenMPTargetExecutionDirective(CurrentRegion) ||\n         isOpenMPTargetDataManagementDirective(CurrentRegion))) {\n      // OpenMP 4.5 [2.17 Nesting of Regions]\n      // If a target, target update, target data, target enter data, or\n      // target exit data construct is encountered during execution of a\n      // target region, the behavior is unspecified.\n      NestingProhibited = Stack->hasDirective(\n          [&OffendingRegion](OpenMPDirectiveKind K, const DeclarationNameInfo &,\n                             SourceLocation) {\n            if (isOpenMPTargetExecutionDirective(K)) {\n              OffendingRegion = K;\n              return true;\n            }\n            return false;\n          },\n          false /* don't skip top directive */);\n      CloseNesting = false;\n    }\n    if (NestingProhibited) {\n      if (OrphanSeen) {\n        SemaRef.Diag(StartLoc, diag::err_omp_orphaned_device_directive)\n            << getOpenMPDirectiveName(CurrentRegion) << Recommend;\n      } else {\n        SemaRef.Diag(StartLoc, diag::err_omp_prohibited_region)\n            << CloseNesting << getOpenMPDirectiveName(OffendingRegion)\n            << Recommend << getOpenMPDirectiveName(CurrentRegion);\n      }\n      return true;\n    }\n  }\n  return false;\n}\n\nstruct Kind2Unsigned {\n  using argument_type = OpenMPDirectiveKind;\n  unsigned operator()(argument_type DK) { return unsigned(DK); }\n};\nstatic bool checkIfClauses(Sema &S, OpenMPDirectiveKind Kind,\n                           ArrayRef<OMPClause *> Clauses,\n                           ArrayRef<OpenMPDirectiveKind> AllowedNameModifiers) {\n  bool ErrorFound = false;\n  unsigned NamedModifiersNumber = 0;\n  llvm::IndexedMap<const OMPIfClause *, Kind2Unsigned> FoundNameModifiers;\n  FoundNameModifiers.resize(llvm::omp::Directive_enumSize + 1);\n  SmallVector<SourceLocation, 4> NameModifierLoc;\n  for (const OMPClause *C : Clauses) {\n    if (const auto *IC = dyn_cast_or_null<OMPIfClause>(C)) {\n      // At most one if clause without a directive-name-modifier can appear on\n      // the directive.\n      OpenMPDirectiveKind CurNM = IC->getNameModifier();\n      if (FoundNameModifiers[CurNM]) {\n        S.Diag(C->getBeginLoc(), diag::err_omp_more_one_clause)\n            << getOpenMPDirectiveName(Kind) << getOpenMPClauseName(OMPC_if)\n            << (CurNM != OMPD_unknown) << getOpenMPDirectiveName(CurNM);\n        ErrorFound = true;\n      } else if (CurNM != OMPD_unknown) {\n        NameModifierLoc.push_back(IC->getNameModifierLoc());\n        ++NamedModifiersNumber;\n      }\n      FoundNameModifiers[CurNM] = IC;\n      if (CurNM == OMPD_unknown)\n        continue;\n      // Check if the specified name modifier is allowed for the current\n      // directive.\n      // At most one if clause with the particular directive-name-modifier can\n      // appear on the directive.\n      bool MatchFound = false;\n      for (auto NM : AllowedNameModifiers) {\n        if (CurNM == NM) {\n          MatchFound = true;\n          break;\n        }\n      }\n      if (!MatchFound) {\n        S.Diag(IC->getNameModifierLoc(),\n               diag::err_omp_wrong_if_directive_name_modifier)\n            << getOpenMPDirectiveName(CurNM) << getOpenMPDirectiveName(Kind);\n        ErrorFound = true;\n      }\n    }\n  }\n  // If any if clause on the directive includes a directive-name-modifier then\n  // all if clauses on the directive must include a directive-name-modifier.\n  if (FoundNameModifiers[OMPD_unknown] && NamedModifiersNumber > 0) {\n    if (NamedModifiersNumber == AllowedNameModifiers.size()) {\n      S.Diag(FoundNameModifiers[OMPD_unknown]->getBeginLoc(),\n             diag::err_omp_no_more_if_clause);\n    } else {\n      std::string Values;\n      std::string Sep(\", \");\n      unsigned AllowedCnt = 0;\n      unsigned TotalAllowedNum =\n          AllowedNameModifiers.size() - NamedModifiersNumber;\n      for (unsigned Cnt = 0, End = AllowedNameModifiers.size(); Cnt < End;\n           ++Cnt) {\n        OpenMPDirectiveKind NM = AllowedNameModifiers[Cnt];\n        if (!FoundNameModifiers[NM]) {\n          Values += \"'\";\n          Values += getOpenMPDirectiveName(NM);\n          Values += \"'\";\n          if (AllowedCnt + 2 == TotalAllowedNum)\n            Values += \" or \";\n          else if (AllowedCnt + 1 != TotalAllowedNum)\n            Values += Sep;\n          ++AllowedCnt;\n        }\n      }\n      S.Diag(FoundNameModifiers[OMPD_unknown]->getCondition()->getBeginLoc(),\n             diag::err_omp_unnamed_if_clause)\n          << (TotalAllowedNum > 1) << Values;\n    }\n    for (SourceLocation Loc : NameModifierLoc) {\n      S.Diag(Loc, diag::note_omp_previous_named_if_clause);\n    }\n    ErrorFound = true;\n  }\n  return ErrorFound;\n}\n\nstatic std::pair<ValueDecl *, bool> getPrivateItem(Sema &S, Expr *&RefExpr,\n                                                   SourceLocation &ELoc,\n                                                   SourceRange &ERange,\n                                                   bool AllowArraySection) {\n  if (RefExpr->isTypeDependent() || RefExpr->isValueDependent() ||\n      RefExpr->containsUnexpandedParameterPack())\n    return std::make_pair(nullptr, true);\n\n  // OpenMP [3.1, C/C++]\n  //  A list item is a variable name.\n  // OpenMP  [2.9.3.3, Restrictions, p.1]\n  //  A variable that is part of another variable (as an array or\n  //  structure element) cannot appear in a private clause.\n  RefExpr = RefExpr->IgnoreParens();\n  enum {\n    NoArrayExpr = -1,\n    ArraySubscript = 0,\n    OMPArraySection = 1\n  } IsArrayExpr = NoArrayExpr;\n  if (AllowArraySection) {\n    if (auto *ASE = dyn_cast_or_null<ArraySubscriptExpr>(RefExpr)) {\n      Expr *Base = ASE->getBase()->IgnoreParenImpCasts();\n      while (auto *TempASE = dyn_cast<ArraySubscriptExpr>(Base))\n        Base = TempASE->getBase()->IgnoreParenImpCasts();\n      RefExpr = Base;\n      IsArrayExpr = ArraySubscript;\n    } else if (auto *OASE = dyn_cast_or_null<OMPArraySectionExpr>(RefExpr)) {\n      Expr *Base = OASE->getBase()->IgnoreParenImpCasts();\n      while (auto *TempOASE = dyn_cast<OMPArraySectionExpr>(Base))\n        Base = TempOASE->getBase()->IgnoreParenImpCasts();\n      while (auto *TempASE = dyn_cast<ArraySubscriptExpr>(Base))\n        Base = TempASE->getBase()->IgnoreParenImpCasts();\n      RefExpr = Base;\n      IsArrayExpr = OMPArraySection;\n    }\n  }\n  ELoc = RefExpr->getExprLoc();\n  ERange = RefExpr->getSourceRange();\n  RefExpr = RefExpr->IgnoreParenImpCasts();\n  auto *DE = dyn_cast_or_null<DeclRefExpr>(RefExpr);\n  auto *ME = dyn_cast_or_null<MemberExpr>(RefExpr);\n  if ((!DE || !isa<VarDecl>(DE->getDecl())) &&\n      (S.getCurrentThisType().isNull() || !ME ||\n       !isa<CXXThisExpr>(ME->getBase()->IgnoreParenImpCasts()) ||\n       !isa<FieldDecl>(ME->getMemberDecl()))) {\n    if (IsArrayExpr != NoArrayExpr) {\n      S.Diag(ELoc, diag::err_omp_expected_base_var_name) << IsArrayExpr\n                                                         << ERange;\n    } else {\n      S.Diag(ELoc,\n             AllowArraySection\n                 ? diag::err_omp_expected_var_name_member_expr_or_array_item\n                 : diag::err_omp_expected_var_name_member_expr)\n          << (S.getCurrentThisType().isNull() ? 0 : 1) << ERange;\n    }\n    return std::make_pair(nullptr, false);\n  }\n  return std::make_pair(\n      getCanonicalDecl(DE ? DE->getDecl() : ME->getMemberDecl()), false);\n}\n\nnamespace {\n/// Checks if the allocator is used in uses_allocators clause to be allowed in\n/// target regions.\nclass AllocatorChecker final : public ConstStmtVisitor<AllocatorChecker, bool> {\n  DSAStackTy *S = nullptr;\n\npublic:\n  bool VisitDeclRefExpr(const DeclRefExpr *E) {\n    return S->isUsesAllocatorsDecl(E->getDecl())\n               .getValueOr(\n                   DSAStackTy::UsesAllocatorsDeclKind::AllocatorTrait) ==\n           DSAStackTy::UsesAllocatorsDeclKind::AllocatorTrait;\n  }\n  bool VisitStmt(const Stmt *S) {\n    for (const Stmt *Child : S->children()) {\n      if (Child && Visit(Child))\n        return true;\n    }\n    return false;\n  }\n  explicit AllocatorChecker(DSAStackTy *S) : S(S) {}\n};\n} // namespace\n\nstatic void checkAllocateClauses(Sema &S, DSAStackTy *Stack,\n                                 ArrayRef<OMPClause *> Clauses) {\n  assert(!S.CurContext->isDependentContext() &&\n         \"Expected non-dependent context.\");\n  auto AllocateRange =\n      llvm::make_filter_range(Clauses, OMPAllocateClause::classof);\n  llvm::DenseMap<CanonicalDeclPtr<Decl>, CanonicalDeclPtr<VarDecl>>\n      DeclToCopy;\n  auto PrivateRange = llvm::make_filter_range(Clauses, [](const OMPClause *C) {\n    return isOpenMPPrivate(C->getClauseKind());\n  });\n  for (OMPClause *Cl : PrivateRange) {\n    MutableArrayRef<Expr *>::iterator I, It, Et;\n    if (Cl->getClauseKind() == OMPC_private) {\n      auto *PC = cast<OMPPrivateClause>(Cl);\n      I = PC->private_copies().begin();\n      It = PC->varlist_begin();\n      Et = PC->varlist_end();\n    } else if (Cl->getClauseKind() == OMPC_firstprivate) {\n      auto *PC = cast<OMPFirstprivateClause>(Cl);\n      I = PC->private_copies().begin();\n      It = PC->varlist_begin();\n      Et = PC->varlist_end();\n    } else if (Cl->getClauseKind() == OMPC_lastprivate) {\n      auto *PC = cast<OMPLastprivateClause>(Cl);\n      I = PC->private_copies().begin();\n      It = PC->varlist_begin();\n      Et = PC->varlist_end();\n    } else if (Cl->getClauseKind() == OMPC_linear) {\n      auto *PC = cast<OMPLinearClause>(Cl);\n      I = PC->privates().begin();\n      It = PC->varlist_begin();\n      Et = PC->varlist_end();\n    } else if (Cl->getClauseKind() == OMPC_reduction) {\n      auto *PC = cast<OMPReductionClause>(Cl);\n      I = PC->privates().begin();\n      It = PC->varlist_begin();\n      Et = PC->varlist_end();\n    } else if (Cl->getClauseKind() == OMPC_task_reduction) {\n      auto *PC = cast<OMPTaskReductionClause>(Cl);\n      I = PC->privates().begin();\n      It = PC->varlist_begin();\n      Et = PC->varlist_end();\n    } else if (Cl->getClauseKind() == OMPC_in_reduction) {\n      auto *PC = cast<OMPInReductionClause>(Cl);\n      I = PC->privates().begin();\n      It = PC->varlist_begin();\n      Et = PC->varlist_end();\n    } else {\n      llvm_unreachable(\"Expected private clause.\");\n    }\n    for (Expr *E : llvm::make_range(It, Et)) {\n      if (!*I) {\n        ++I;\n        continue;\n      }\n      SourceLocation ELoc;\n      SourceRange ERange;\n      Expr *SimpleRefExpr = E;\n      auto Res = getPrivateItem(S, SimpleRefExpr, ELoc, ERange,\n                                /*AllowArraySection=*/true);\n      DeclToCopy.try_emplace(Res.first,\n                             cast<VarDecl>(cast<DeclRefExpr>(*I)->getDecl()));\n      ++I;\n    }\n  }\n  for (OMPClause *C : AllocateRange) {\n    auto *AC = cast<OMPAllocateClause>(C);\n    if (S.getLangOpts().OpenMP >= 50 &&\n        !Stack->hasRequiresDeclWithClause<OMPDynamicAllocatorsClause>() &&\n        isOpenMPTargetExecutionDirective(Stack->getCurrentDirective()) &&\n        AC->getAllocator()) {\n      Expr *Allocator = AC->getAllocator();\n      // OpenMP, 2.12.5 target Construct\n      // Memory allocators that do not appear in a uses_allocators clause cannot\n      // appear as an allocator in an allocate clause or be used in the target\n      // region unless a requires directive with the dynamic_allocators clause\n      // is present in the same compilation unit.\n      AllocatorChecker Checker(Stack);\n      if (Checker.Visit(Allocator))\n        S.Diag(Allocator->getExprLoc(),\n               diag::err_omp_allocator_not_in_uses_allocators)\n            << Allocator->getSourceRange();\n    }\n    OMPAllocateDeclAttr::AllocatorTypeTy AllocatorKind =\n        getAllocatorKind(S, Stack, AC->getAllocator());\n    // OpenMP, 2.11.4 allocate Clause, Restrictions.\n    // For task, taskloop or target directives, allocation requests to memory\n    // allocators with the trait access set to thread result in unspecified\n    // behavior.\n    if (AllocatorKind == OMPAllocateDeclAttr::OMPThreadMemAlloc &&\n        (isOpenMPTaskingDirective(Stack->getCurrentDirective()) ||\n         isOpenMPTargetExecutionDirective(Stack->getCurrentDirective()))) {\n      S.Diag(AC->getAllocator()->getExprLoc(),\n             diag::warn_omp_allocate_thread_on_task_target_directive)\n          << getOpenMPDirectiveName(Stack->getCurrentDirective());\n    }\n    for (Expr *E : AC->varlists()) {\n      SourceLocation ELoc;\n      SourceRange ERange;\n      Expr *SimpleRefExpr = E;\n      auto Res = getPrivateItem(S, SimpleRefExpr, ELoc, ERange);\n      ValueDecl *VD = Res.first;\n      DSAStackTy::DSAVarData Data = Stack->getTopDSA(VD, /*FromParent=*/false);\n      if (!isOpenMPPrivate(Data.CKind)) {\n        S.Diag(E->getExprLoc(),\n               diag::err_omp_expected_private_copy_for_allocate);\n        continue;\n      }\n      VarDecl *PrivateVD = DeclToCopy[VD];\n      if (checkPreviousOMPAllocateAttribute(S, Stack, E, PrivateVD,\n                                            AllocatorKind, AC->getAllocator()))\n        continue;\n      applyOMPAllocateAttribute(S, PrivateVD, AllocatorKind, AC->getAllocator(),\n                                E->getSourceRange());\n    }\n  }\n}\n\nStmtResult Sema::ActOnOpenMPExecutableDirective(\n    OpenMPDirectiveKind Kind, const DeclarationNameInfo &DirName,\n    OpenMPDirectiveKind CancelRegion, ArrayRef<OMPClause *> Clauses,\n    Stmt *AStmt, SourceLocation StartLoc, SourceLocation EndLoc) {\n  StmtResult Res = StmtError();\n  // First check CancelRegion which is then used in checkNestingOfRegions.\n  if (checkCancelRegion(*this, Kind, CancelRegion, StartLoc) ||\n      checkNestingOfRegions(*this, DSAStack, Kind, DirName, CancelRegion,\n                            StartLoc))\n    return StmtError();\n\n  llvm::SmallVector<OMPClause *, 8> ClausesWithImplicit;\n  VarsWithInheritedDSAType VarsWithInheritedDSA;\n  bool ErrorFound = false;\n  ClausesWithImplicit.append(Clauses.begin(), Clauses.end());\n  if (AStmt && !CurContext->isDependentContext() && Kind != OMPD_atomic &&\n      Kind != OMPD_critical && Kind != OMPD_section && Kind != OMPD_master &&\n      !isOpenMPLoopTransformationDirective(Kind)) {\n    assert(isa<CapturedStmt>(AStmt) && \"Captured statement expected\");\n\n    // Check default data sharing attributes for referenced variables.\n    DSAAttrChecker DSAChecker(DSAStack, *this, cast<CapturedStmt>(AStmt));\n    int ThisCaptureLevel = getOpenMPCaptureLevels(Kind);\n    Stmt *S = AStmt;\n    while (--ThisCaptureLevel >= 0)\n      S = cast<CapturedStmt>(S)->getCapturedStmt();\n    DSAChecker.Visit(S);\n    if (!isOpenMPTargetDataManagementDirective(Kind) &&\n        !isOpenMPTaskingDirective(Kind)) {\n      // Visit subcaptures to generate implicit clauses for captured vars.\n      auto *CS = cast<CapturedStmt>(AStmt);\n      SmallVector<OpenMPDirectiveKind, 4> CaptureRegions;\n      getOpenMPCaptureRegions(CaptureRegions, Kind);\n      // Ignore outer tasking regions for target directives.\n      if (CaptureRegions.size() > 1 && CaptureRegions.front() == OMPD_task)\n        CS = cast<CapturedStmt>(CS->getCapturedStmt());\n      DSAChecker.visitSubCaptures(CS);\n    }\n    if (DSAChecker.isErrorFound())\n      return StmtError();\n    // Generate list of implicitly defined firstprivate variables.\n    VarsWithInheritedDSA = DSAChecker.getVarsWithInheritedDSA();\n\n    SmallVector<Expr *, 4> ImplicitFirstprivates(\n        DSAChecker.getImplicitFirstprivate().begin(),\n        DSAChecker.getImplicitFirstprivate().end());\n    const unsigned DefaultmapKindNum = OMPC_DEFAULTMAP_pointer + 1;\n    SmallVector<Expr *, 4> ImplicitMaps[DefaultmapKindNum][OMPC_MAP_delete];\n    SmallVector<OpenMPMapModifierKind, NumberOfOMPMapClauseModifiers>\n        ImplicitMapModifiers[DefaultmapKindNum];\n    SmallVector<SourceLocation, NumberOfOMPMapClauseModifiers>\n        ImplicitMapModifiersLoc[DefaultmapKindNum];\n    // Get the original location of present modifier from Defaultmap clause.\n    SourceLocation PresentModifierLocs[DefaultmapKindNum];\n    for (OMPClause *C : Clauses) {\n      if (auto *DMC = dyn_cast<OMPDefaultmapClause>(C))\n        if (DMC->getDefaultmapModifier() == OMPC_DEFAULTMAP_MODIFIER_present)\n          PresentModifierLocs[DMC->getDefaultmapKind()] =\n              DMC->getDefaultmapModifierLoc();\n    }\n    for (unsigned VC = 0; VC < DefaultmapKindNum; ++VC) {\n      auto Kind = static_cast<OpenMPDefaultmapClauseKind>(VC);\n      for (unsigned I = 0; I < OMPC_MAP_delete; ++I) {\n        ArrayRef<Expr *> ImplicitMap = DSAChecker.getImplicitMap(\n            Kind, static_cast<OpenMPMapClauseKind>(I));\n        ImplicitMaps[VC][I].append(ImplicitMap.begin(), ImplicitMap.end());\n      }\n      ArrayRef<OpenMPMapModifierKind> ImplicitModifier =\n          DSAChecker.getImplicitMapModifier(Kind);\n      ImplicitMapModifiers[VC].append(ImplicitModifier.begin(),\n                                      ImplicitModifier.end());\n      std::fill_n(std::back_inserter(ImplicitMapModifiersLoc[VC]),\n                  ImplicitModifier.size(), PresentModifierLocs[VC]);\n    }\n    // Mark taskgroup task_reduction descriptors as implicitly firstprivate.\n    for (OMPClause *C : Clauses) {\n      if (auto *IRC = dyn_cast<OMPInReductionClause>(C)) {\n        for (Expr *E : IRC->taskgroup_descriptors())\n          if (E)\n            ImplicitFirstprivates.emplace_back(E);\n      }\n      // OpenMP 5.0, 2.10.1 task Construct\n      // [detach clause]... The event-handle will be considered as if it was\n      // specified on a firstprivate clause.\n      if (auto *DC = dyn_cast<OMPDetachClause>(C))\n        ImplicitFirstprivates.push_back(DC->getEventHandler());\n    }\n    if (!ImplicitFirstprivates.empty()) {\n      if (OMPClause *Implicit = ActOnOpenMPFirstprivateClause(\n              ImplicitFirstprivates, SourceLocation(), SourceLocation(),\n              SourceLocation())) {\n        ClausesWithImplicit.push_back(Implicit);\n        ErrorFound = cast<OMPFirstprivateClause>(Implicit)->varlist_size() !=\n                     ImplicitFirstprivates.size();\n      } else {\n        ErrorFound = true;\n      }\n    }\n    for (unsigned I = 0, E = DefaultmapKindNum; I < E; ++I) {\n      int ClauseKindCnt = -1;\n      for (ArrayRef<Expr *> ImplicitMap : ImplicitMaps[I]) {\n        ++ClauseKindCnt;\n        if (ImplicitMap.empty())\n          continue;\n        CXXScopeSpec MapperIdScopeSpec;\n        DeclarationNameInfo MapperId;\n        auto Kind = static_cast<OpenMPMapClauseKind>(ClauseKindCnt);\n        if (OMPClause *Implicit = ActOnOpenMPMapClause(\n                ImplicitMapModifiers[I], ImplicitMapModifiersLoc[I],\n                MapperIdScopeSpec, MapperId, Kind, /*IsMapTypeImplicit=*/true,\n                SourceLocation(), SourceLocation(), ImplicitMap,\n                OMPVarListLocTy())) {\n          ClausesWithImplicit.emplace_back(Implicit);\n          ErrorFound |= cast<OMPMapClause>(Implicit)->varlist_size() !=\n                        ImplicitMap.size();\n        } else {\n          ErrorFound = true;\n        }\n      }\n    }\n  }\n\n  llvm::SmallVector<OpenMPDirectiveKind, 4> AllowedNameModifiers;\n  switch (Kind) {\n  case OMPD_parallel:\n    Res = ActOnOpenMPParallelDirective(ClausesWithImplicit, AStmt, StartLoc,\n                                       EndLoc);\n    AllowedNameModifiers.push_back(OMPD_parallel);\n    break;\n  case OMPD_simd:\n    Res = ActOnOpenMPSimdDirective(ClausesWithImplicit, AStmt, StartLoc, EndLoc,\n                                   VarsWithInheritedDSA);\n    if (LangOpts.OpenMP >= 50)\n      AllowedNameModifiers.push_back(OMPD_simd);\n    break;\n  case OMPD_tile:\n    Res =\n        ActOnOpenMPTileDirective(ClausesWithImplicit, AStmt, StartLoc, EndLoc);\n    break;\n  case OMPD_for:\n    Res = ActOnOpenMPForDirective(ClausesWithImplicit, AStmt, StartLoc, EndLoc,\n                                  VarsWithInheritedDSA);\n    break;\n  case OMPD_for_simd:\n    Res = ActOnOpenMPForSimdDirective(ClausesWithImplicit, AStmt, StartLoc,\n                                      EndLoc, VarsWithInheritedDSA);\n    if (LangOpts.OpenMP >= 50)\n      AllowedNameModifiers.push_back(OMPD_simd);\n    break;\n  case OMPD_sections:\n    Res = ActOnOpenMPSectionsDirective(ClausesWithImplicit, AStmt, StartLoc,\n                                       EndLoc);\n    break;\n  case OMPD_section:\n    assert(ClausesWithImplicit.empty() &&\n           \"No clauses are allowed for 'omp section' directive\");\n    Res = ActOnOpenMPSectionDirective(AStmt, StartLoc, EndLoc);\n    break;\n  case OMPD_single:\n    Res = ActOnOpenMPSingleDirective(ClausesWithImplicit, AStmt, StartLoc,\n                                     EndLoc);\n    break;\n  case OMPD_master:\n    assert(ClausesWithImplicit.empty() &&\n           \"No clauses are allowed for 'omp master' directive\");\n    Res = ActOnOpenMPMasterDirective(AStmt, StartLoc, EndLoc);\n    break;\n  case OMPD_critical:\n    Res = ActOnOpenMPCriticalDirective(DirName, ClausesWithImplicit, AStmt,\n                                       StartLoc, EndLoc);\n    break;\n  case OMPD_parallel_for:\n    Res = ActOnOpenMPParallelForDirective(ClausesWithImplicit, AStmt, StartLoc,\n                                          EndLoc, VarsWithInheritedDSA);\n    AllowedNameModifiers.push_back(OMPD_parallel);\n    break;\n  case OMPD_parallel_for_simd:\n    Res = ActOnOpenMPParallelForSimdDirective(\n        ClausesWithImplicit, AStmt, StartLoc, EndLoc, VarsWithInheritedDSA);\n    AllowedNameModifiers.push_back(OMPD_parallel);\n    if (LangOpts.OpenMP >= 50)\n      AllowedNameModifiers.push_back(OMPD_simd);\n    break;\n  case OMPD_parallel_master:\n    Res = ActOnOpenMPParallelMasterDirective(ClausesWithImplicit, AStmt,\n                                               StartLoc, EndLoc);\n    AllowedNameModifiers.push_back(OMPD_parallel);\n    break;\n  case OMPD_parallel_sections:\n    Res = ActOnOpenMPParallelSectionsDirective(ClausesWithImplicit, AStmt,\n                                               StartLoc, EndLoc);\n    AllowedNameModifiers.push_back(OMPD_parallel);\n    break;\n  case OMPD_task:\n    Res =\n        ActOnOpenMPTaskDirective(ClausesWithImplicit, AStmt, StartLoc, EndLoc);\n    AllowedNameModifiers.push_back(OMPD_task);\n    break;\n  case OMPD_taskyield:\n    assert(ClausesWithImplicit.empty() &&\n           \"No clauses are allowed for 'omp taskyield' directive\");\n    assert(AStmt == nullptr &&\n           \"No associated statement allowed for 'omp taskyield' directive\");\n    Res = ActOnOpenMPTaskyieldDirective(StartLoc, EndLoc);\n    break;\n  case OMPD_barrier:\n    assert(ClausesWithImplicit.empty() &&\n           \"No clauses are allowed for 'omp barrier' directive\");\n    assert(AStmt == nullptr &&\n           \"No associated statement allowed for 'omp barrier' directive\");\n    Res = ActOnOpenMPBarrierDirective(StartLoc, EndLoc);\n    break;\n  case OMPD_taskwait:\n    assert(ClausesWithImplicit.empty() &&\n           \"No clauses are allowed for 'omp taskwait' directive\");\n    assert(AStmt == nullptr &&\n           \"No associated statement allowed for 'omp taskwait' directive\");\n    Res = ActOnOpenMPTaskwaitDirective(StartLoc, EndLoc);\n    break;\n  case OMPD_taskgroup:\n    Res = ActOnOpenMPTaskgroupDirective(ClausesWithImplicit, AStmt, StartLoc,\n                                        EndLoc);\n    break;\n  case OMPD_flush:\n    assert(AStmt == nullptr &&\n           \"No associated statement allowed for 'omp flush' directive\");\n    Res = ActOnOpenMPFlushDirective(ClausesWithImplicit, StartLoc, EndLoc);\n    break;\n  case OMPD_depobj:\n    assert(AStmt == nullptr &&\n           \"No associated statement allowed for 'omp depobj' directive\");\n    Res = ActOnOpenMPDepobjDirective(ClausesWithImplicit, StartLoc, EndLoc);\n    break;\n  case OMPD_scan:\n    assert(AStmt == nullptr &&\n           \"No associated statement allowed for 'omp scan' directive\");\n    Res = ActOnOpenMPScanDirective(ClausesWithImplicit, StartLoc, EndLoc);\n    break;\n  case OMPD_ordered:\n    Res = ActOnOpenMPOrderedDirective(ClausesWithImplicit, AStmt, StartLoc,\n                                      EndLoc);\n    break;\n  case OMPD_atomic:\n    Res = ActOnOpenMPAtomicDirective(ClausesWithImplicit, AStmt, StartLoc,\n                                     EndLoc);\n    break;\n  case OMPD_teams:\n    Res =\n        ActOnOpenMPTeamsDirective(ClausesWithImplicit, AStmt, StartLoc, EndLoc);\n    break;\n  case OMPD_target:\n    Res = ActOnOpenMPTargetDirective(ClausesWithImplicit, AStmt, StartLoc,\n                                     EndLoc);\n    AllowedNameModifiers.push_back(OMPD_target);\n    break;\n  case OMPD_target_parallel:\n    Res = ActOnOpenMPTargetParallelDirective(ClausesWithImplicit, AStmt,\n                                             StartLoc, EndLoc);\n    AllowedNameModifiers.push_back(OMPD_target);\n    AllowedNameModifiers.push_back(OMPD_parallel);\n    break;\n  case OMPD_target_parallel_for:\n    Res = ActOnOpenMPTargetParallelForDirective(\n        ClausesWithImplicit, AStmt, StartLoc, EndLoc, VarsWithInheritedDSA);\n    AllowedNameModifiers.push_back(OMPD_target);\n    AllowedNameModifiers.push_back(OMPD_parallel);\n    break;\n  case OMPD_cancellation_point:\n    assert(ClausesWithImplicit.empty() &&\n           \"No clauses are allowed for 'omp cancellation point' directive\");\n    assert(AStmt == nullptr && \"No associated statement allowed for 'omp \"\n                               \"cancellation point' directive\");\n    Res = ActOnOpenMPCancellationPointDirective(StartLoc, EndLoc, CancelRegion);\n    break;\n  case OMPD_cancel:\n    assert(AStmt == nullptr &&\n           \"No associated statement allowed for 'omp cancel' directive\");\n    Res = ActOnOpenMPCancelDirective(ClausesWithImplicit, StartLoc, EndLoc,\n                                     CancelRegion);\n    AllowedNameModifiers.push_back(OMPD_cancel);\n    break;\n  case OMPD_target_data:\n    Res = ActOnOpenMPTargetDataDirective(ClausesWithImplicit, AStmt, StartLoc,\n                                         EndLoc);\n    AllowedNameModifiers.push_back(OMPD_target_data);\n    break;\n  case OMPD_target_enter_data:\n    Res = ActOnOpenMPTargetEnterDataDirective(ClausesWithImplicit, StartLoc,\n                                              EndLoc, AStmt);\n    AllowedNameModifiers.push_back(OMPD_target_enter_data);\n    break;\n  case OMPD_target_exit_data:\n    Res = ActOnOpenMPTargetExitDataDirective(ClausesWithImplicit, StartLoc,\n                                             EndLoc, AStmt);\n    AllowedNameModifiers.push_back(OMPD_target_exit_data);\n    break;\n  case OMPD_taskloop:\n    Res = ActOnOpenMPTaskLoopDirective(ClausesWithImplicit, AStmt, StartLoc,\n                                       EndLoc, VarsWithInheritedDSA);\n    AllowedNameModifiers.push_back(OMPD_taskloop);\n    break;\n  case OMPD_taskloop_simd:\n    Res = ActOnOpenMPTaskLoopSimdDirective(ClausesWithImplicit, AStmt, StartLoc,\n                                           EndLoc, VarsWithInheritedDSA);\n    AllowedNameModifiers.push_back(OMPD_taskloop);\n    if (LangOpts.OpenMP >= 50)\n      AllowedNameModifiers.push_back(OMPD_simd);\n    break;\n  case OMPD_master_taskloop:\n    Res = ActOnOpenMPMasterTaskLoopDirective(\n        ClausesWithImplicit, AStmt, StartLoc, EndLoc, VarsWithInheritedDSA);\n    AllowedNameModifiers.push_back(OMPD_taskloop);\n    break;\n  case OMPD_master_taskloop_simd:\n    Res = ActOnOpenMPMasterTaskLoopSimdDirective(\n        ClausesWithImplicit, AStmt, StartLoc, EndLoc, VarsWithInheritedDSA);\n    AllowedNameModifiers.push_back(OMPD_taskloop);\n    if (LangOpts.OpenMP >= 50)\n      AllowedNameModifiers.push_back(OMPD_simd);\n    break;\n  case OMPD_parallel_master_taskloop:\n    Res = ActOnOpenMPParallelMasterTaskLoopDirective(\n        ClausesWithImplicit, AStmt, StartLoc, EndLoc, VarsWithInheritedDSA);\n    AllowedNameModifiers.push_back(OMPD_taskloop);\n    AllowedNameModifiers.push_back(OMPD_parallel);\n    break;\n  case OMPD_parallel_master_taskloop_simd:\n    Res = ActOnOpenMPParallelMasterTaskLoopSimdDirective(\n        ClausesWithImplicit, AStmt, StartLoc, EndLoc, VarsWithInheritedDSA);\n    AllowedNameModifiers.push_back(OMPD_taskloop);\n    AllowedNameModifiers.push_back(OMPD_parallel);\n    if (LangOpts.OpenMP >= 50)\n      AllowedNameModifiers.push_back(OMPD_simd);\n    break;\n  case OMPD_distribute:\n    Res = ActOnOpenMPDistributeDirective(ClausesWithImplicit, AStmt, StartLoc,\n                                         EndLoc, VarsWithInheritedDSA);\n    break;\n  case OMPD_target_update:\n    Res = ActOnOpenMPTargetUpdateDirective(ClausesWithImplicit, StartLoc,\n                                           EndLoc, AStmt);\n    AllowedNameModifiers.push_back(OMPD_target_update);\n    break;\n  case OMPD_distribute_parallel_for:\n    Res = ActOnOpenMPDistributeParallelForDirective(\n        ClausesWithImplicit, AStmt, StartLoc, EndLoc, VarsWithInheritedDSA);\n    AllowedNameModifiers.push_back(OMPD_parallel);\n    break;\n  case OMPD_distribute_parallel_for_simd:\n    Res = ActOnOpenMPDistributeParallelForSimdDirective(\n        ClausesWithImplicit, AStmt, StartLoc, EndLoc, VarsWithInheritedDSA);\n    AllowedNameModifiers.push_back(OMPD_parallel);\n    if (LangOpts.OpenMP >= 50)\n      AllowedNameModifiers.push_back(OMPD_simd);\n    break;\n  case OMPD_distribute_simd:\n    Res = ActOnOpenMPDistributeSimdDirective(\n        ClausesWithImplicit, AStmt, StartLoc, EndLoc, VarsWithInheritedDSA);\n    if (LangOpts.OpenMP >= 50)\n      AllowedNameModifiers.push_back(OMPD_simd);\n    break;\n  case OMPD_target_parallel_for_simd:\n    Res = ActOnOpenMPTargetParallelForSimdDirective(\n        ClausesWithImplicit, AStmt, StartLoc, EndLoc, VarsWithInheritedDSA);\n    AllowedNameModifiers.push_back(OMPD_target);\n    AllowedNameModifiers.push_back(OMPD_parallel);\n    if (LangOpts.OpenMP >= 50)\n      AllowedNameModifiers.push_back(OMPD_simd);\n    break;\n  case OMPD_target_simd:\n    Res = ActOnOpenMPTargetSimdDirective(ClausesWithImplicit, AStmt, StartLoc,\n                                         EndLoc, VarsWithInheritedDSA);\n    AllowedNameModifiers.push_back(OMPD_target);\n    if (LangOpts.OpenMP >= 50)\n      AllowedNameModifiers.push_back(OMPD_simd);\n    break;\n  case OMPD_teams_distribute:\n    Res = ActOnOpenMPTeamsDistributeDirective(\n        ClausesWithImplicit, AStmt, StartLoc, EndLoc, VarsWithInheritedDSA);\n    break;\n  case OMPD_teams_distribute_simd:\n    Res = ActOnOpenMPTeamsDistributeSimdDirective(\n        ClausesWithImplicit, AStmt, StartLoc, EndLoc, VarsWithInheritedDSA);\n    if (LangOpts.OpenMP >= 50)\n      AllowedNameModifiers.push_back(OMPD_simd);\n    break;\n  case OMPD_teams_distribute_parallel_for_simd:\n    Res = ActOnOpenMPTeamsDistributeParallelForSimdDirective(\n        ClausesWithImplicit, AStmt, StartLoc, EndLoc, VarsWithInheritedDSA);\n    AllowedNameModifiers.push_back(OMPD_parallel);\n    if (LangOpts.OpenMP >= 50)\n      AllowedNameModifiers.push_back(OMPD_simd);\n    break;\n  case OMPD_teams_distribute_parallel_for:\n    Res = ActOnOpenMPTeamsDistributeParallelForDirective(\n        ClausesWithImplicit, AStmt, StartLoc, EndLoc, VarsWithInheritedDSA);\n    AllowedNameModifiers.push_back(OMPD_parallel);\n    break;\n  case OMPD_target_teams:\n    Res = ActOnOpenMPTargetTeamsDirective(ClausesWithImplicit, AStmt, StartLoc,\n                                          EndLoc);\n    AllowedNameModifiers.push_back(OMPD_target);\n    break;\n  case OMPD_target_teams_distribute:\n    Res = ActOnOpenMPTargetTeamsDistributeDirective(\n        ClausesWithImplicit, AStmt, StartLoc, EndLoc, VarsWithInheritedDSA);\n    AllowedNameModifiers.push_back(OMPD_target);\n    break;\n  case OMPD_target_teams_distribute_parallel_for:\n    Res = ActOnOpenMPTargetTeamsDistributeParallelForDirective(\n        ClausesWithImplicit, AStmt, StartLoc, EndLoc, VarsWithInheritedDSA);\n    AllowedNameModifiers.push_back(OMPD_target);\n    AllowedNameModifiers.push_back(OMPD_parallel);\n    break;\n  case OMPD_target_teams_distribute_parallel_for_simd:\n    Res = ActOnOpenMPTargetTeamsDistributeParallelForSimdDirective(\n        ClausesWithImplicit, AStmt, StartLoc, EndLoc, VarsWithInheritedDSA);\n    AllowedNameModifiers.push_back(OMPD_target);\n    AllowedNameModifiers.push_back(OMPD_parallel);\n    if (LangOpts.OpenMP >= 50)\n      AllowedNameModifiers.push_back(OMPD_simd);\n    break;\n  case OMPD_target_teams_distribute_simd:\n    Res = ActOnOpenMPTargetTeamsDistributeSimdDirective(\n        ClausesWithImplicit, AStmt, StartLoc, EndLoc, VarsWithInheritedDSA);\n    AllowedNameModifiers.push_back(OMPD_target);\n    if (LangOpts.OpenMP >= 50)\n      AllowedNameModifiers.push_back(OMPD_simd);\n    break;\n  case OMPD_declare_target:\n  case OMPD_end_declare_target:\n  case OMPD_threadprivate:\n  case OMPD_allocate:\n  case OMPD_declare_reduction:\n  case OMPD_declare_mapper:\n  case OMPD_declare_simd:\n  case OMPD_requires:\n  case OMPD_declare_variant:\n  case OMPD_begin_declare_variant:\n  case OMPD_end_declare_variant:\n    llvm_unreachable(\"OpenMP Directive is not allowed\");\n  case OMPD_unknown:\n  default:\n    llvm_unreachable(\"Unknown OpenMP directive\");\n  }\n\n  ErrorFound = Res.isInvalid() || ErrorFound;\n\n  // Check variables in the clauses if default(none) or\n  // default(firstprivate) was specified.\n  if (DSAStack->getDefaultDSA() == DSA_none ||\n      DSAStack->getDefaultDSA() == DSA_firstprivate) {\n    DSAAttrChecker DSAChecker(DSAStack, *this, nullptr);\n    for (OMPClause *C : Clauses) {\n      switch (C->getClauseKind()) {\n      case OMPC_num_threads:\n      case OMPC_dist_schedule:\n        // Do not analyse if no parent teams directive.\n        if (isOpenMPTeamsDirective(Kind))\n          break;\n        continue;\n      case OMPC_if:\n        if (isOpenMPTeamsDirective(Kind) &&\n            cast<OMPIfClause>(C)->getNameModifier() != OMPD_target)\n          break;\n        if (isOpenMPParallelDirective(Kind) &&\n            isOpenMPTaskLoopDirective(Kind) &&\n            cast<OMPIfClause>(C)->getNameModifier() != OMPD_parallel)\n          break;\n        continue;\n      case OMPC_schedule:\n      case OMPC_detach:\n        break;\n      case OMPC_grainsize:\n      case OMPC_num_tasks:\n      case OMPC_final:\n      case OMPC_priority:\n        // Do not analyze if no parent parallel directive.\n        if (isOpenMPParallelDirective(Kind))\n          break;\n        continue;\n      case OMPC_ordered:\n      case OMPC_device:\n      case OMPC_num_teams:\n      case OMPC_thread_limit:\n      case OMPC_hint:\n      case OMPC_collapse:\n      case OMPC_safelen:\n      case OMPC_simdlen:\n      case OMPC_sizes:\n      case OMPC_default:\n      case OMPC_proc_bind:\n      case OMPC_private:\n      case OMPC_firstprivate:\n      case OMPC_lastprivate:\n      case OMPC_shared:\n      case OMPC_reduction:\n      case OMPC_task_reduction:\n      case OMPC_in_reduction:\n      case OMPC_linear:\n      case OMPC_aligned:\n      case OMPC_copyin:\n      case OMPC_copyprivate:\n      case OMPC_nowait:\n      case OMPC_untied:\n      case OMPC_mergeable:\n      case OMPC_allocate:\n      case OMPC_read:\n      case OMPC_write:\n      case OMPC_update:\n      case OMPC_capture:\n      case OMPC_seq_cst:\n      case OMPC_acq_rel:\n      case OMPC_acquire:\n      case OMPC_release:\n      case OMPC_relaxed:\n      case OMPC_depend:\n      case OMPC_threads:\n      case OMPC_simd:\n      case OMPC_map:\n      case OMPC_nogroup:\n      case OMPC_defaultmap:\n      case OMPC_to:\n      case OMPC_from:\n      case OMPC_use_device_ptr:\n      case OMPC_use_device_addr:\n      case OMPC_is_device_ptr:\n      case OMPC_nontemporal:\n      case OMPC_order:\n      case OMPC_destroy:\n      case OMPC_inclusive:\n      case OMPC_exclusive:\n      case OMPC_uses_allocators:\n      case OMPC_affinity:\n        continue;\n      case OMPC_allocator:\n      case OMPC_flush:\n      case OMPC_depobj:\n      case OMPC_threadprivate:\n      case OMPC_uniform:\n      case OMPC_unknown:\n      case OMPC_unified_address:\n      case OMPC_unified_shared_memory:\n      case OMPC_reverse_offload:\n      case OMPC_dynamic_allocators:\n      case OMPC_atomic_default_mem_order:\n      case OMPC_device_type:\n      case OMPC_match:\n      default:\n        llvm_unreachable(\"Unexpected clause\");\n      }\n      for (Stmt *CC : C->children()) {\n        if (CC)\n          DSAChecker.Visit(CC);\n      }\n    }\n    for (const auto &P : DSAChecker.getVarsWithInheritedDSA())\n      VarsWithInheritedDSA[P.getFirst()] = P.getSecond();\n  }\n  for (const auto &P : VarsWithInheritedDSA) {\n    if (P.getFirst()->isImplicit() || isa<OMPCapturedExprDecl>(P.getFirst()))\n      continue;\n    ErrorFound = true;\n    if (DSAStack->getDefaultDSA() == DSA_none ||\n        DSAStack->getDefaultDSA() == DSA_firstprivate) {\n      Diag(P.second->getExprLoc(), diag::err_omp_no_dsa_for_variable)\n          << P.first << P.second->getSourceRange();\n      Diag(DSAStack->getDefaultDSALocation(), diag::note_omp_default_dsa_none);\n    } else if (getLangOpts().OpenMP >= 50) {\n      Diag(P.second->getExprLoc(),\n           diag::err_omp_defaultmap_no_attr_for_variable)\n          << P.first << P.second->getSourceRange();\n      Diag(DSAStack->getDefaultDSALocation(),\n           diag::note_omp_defaultmap_attr_none);\n    }\n  }\n\n  if (!AllowedNameModifiers.empty())\n    ErrorFound = checkIfClauses(*this, Kind, Clauses, AllowedNameModifiers) ||\n                 ErrorFound;\n\n  if (ErrorFound)\n    return StmtError();\n\n  if (!CurContext->isDependentContext() &&\n      isOpenMPTargetExecutionDirective(Kind) &&\n      !(DSAStack->hasRequiresDeclWithClause<OMPUnifiedSharedMemoryClause>() ||\n        DSAStack->hasRequiresDeclWithClause<OMPUnifiedAddressClause>() ||\n        DSAStack->hasRequiresDeclWithClause<OMPReverseOffloadClause>() ||\n        DSAStack->hasRequiresDeclWithClause<OMPDynamicAllocatorsClause>())) {\n    // Register target to DSA Stack.\n    DSAStack->addTargetDirLocation(StartLoc);\n  }\n\n  return Res;\n}\n\nSema::DeclGroupPtrTy Sema::ActOnOpenMPDeclareSimdDirective(\n    DeclGroupPtrTy DG, OMPDeclareSimdDeclAttr::BranchStateTy BS, Expr *Simdlen,\n    ArrayRef<Expr *> Uniforms, ArrayRef<Expr *> Aligneds,\n    ArrayRef<Expr *> Alignments, ArrayRef<Expr *> Linears,\n    ArrayRef<unsigned> LinModifiers, ArrayRef<Expr *> Steps, SourceRange SR) {\n  assert(Aligneds.size() == Alignments.size());\n  assert(Linears.size() == LinModifiers.size());\n  assert(Linears.size() == Steps.size());\n  if (!DG || DG.get().isNull())\n    return DeclGroupPtrTy();\n\n  const int SimdId = 0;\n  if (!DG.get().isSingleDecl()) {\n    Diag(SR.getBegin(), diag::err_omp_single_decl_in_declare_simd_variant)\n        << SimdId;\n    return DG;\n  }\n  Decl *ADecl = DG.get().getSingleDecl();\n  if (auto *FTD = dyn_cast<FunctionTemplateDecl>(ADecl))\n    ADecl = FTD->getTemplatedDecl();\n\n  auto *FD = dyn_cast<FunctionDecl>(ADecl);\n  if (!FD) {\n    Diag(ADecl->getLocation(), diag::err_omp_function_expected) << SimdId;\n    return DeclGroupPtrTy();\n  }\n\n  // OpenMP [2.8.2, declare simd construct, Description]\n  // The parameter of the simdlen clause must be a constant positive integer\n  // expression.\n  ExprResult SL;\n  if (Simdlen)\n    SL = VerifyPositiveIntegerConstantInClause(Simdlen, OMPC_simdlen);\n  // OpenMP [2.8.2, declare simd construct, Description]\n  // The special this pointer can be used as if was one of the arguments to the\n  // function in any of the linear, aligned, or uniform clauses.\n  // The uniform clause declares one or more arguments to have an invariant\n  // value for all concurrent invocations of the function in the execution of a\n  // single SIMD loop.\n  llvm::DenseMap<const Decl *, const Expr *> UniformedArgs;\n  const Expr *UniformedLinearThis = nullptr;\n  for (const Expr *E : Uniforms) {\n    E = E->IgnoreParenImpCasts();\n    if (const auto *DRE = dyn_cast<DeclRefExpr>(E))\n      if (const auto *PVD = dyn_cast<ParmVarDecl>(DRE->getDecl()))\n        if (FD->getNumParams() > PVD->getFunctionScopeIndex() &&\n            FD->getParamDecl(PVD->getFunctionScopeIndex())\n                    ->getCanonicalDecl() == PVD->getCanonicalDecl()) {\n          UniformedArgs.try_emplace(PVD->getCanonicalDecl(), E);\n          continue;\n        }\n    if (isa<CXXThisExpr>(E)) {\n      UniformedLinearThis = E;\n      continue;\n    }\n    Diag(E->getExprLoc(), diag::err_omp_param_or_this_in_clause)\n        << FD->getDeclName() << (isa<CXXMethodDecl>(ADecl) ? 1 : 0);\n  }\n  // OpenMP [2.8.2, declare simd construct, Description]\n  // The aligned clause declares that the object to which each list item points\n  // is aligned to the number of bytes expressed in the optional parameter of\n  // the aligned clause.\n  // The special this pointer can be used as if was one of the arguments to the\n  // function in any of the linear, aligned, or uniform clauses.\n  // The type of list items appearing in the aligned clause must be array,\n  // pointer, reference to array, or reference to pointer.\n  llvm::DenseMap<const Decl *, const Expr *> AlignedArgs;\n  const Expr *AlignedThis = nullptr;\n  for (const Expr *E : Aligneds) {\n    E = E->IgnoreParenImpCasts();\n    if (const auto *DRE = dyn_cast<DeclRefExpr>(E))\n      if (const auto *PVD = dyn_cast<ParmVarDecl>(DRE->getDecl())) {\n        const VarDecl *CanonPVD = PVD->getCanonicalDecl();\n        if (FD->getNumParams() > PVD->getFunctionScopeIndex() &&\n            FD->getParamDecl(PVD->getFunctionScopeIndex())\n                    ->getCanonicalDecl() == CanonPVD) {\n          // OpenMP  [2.8.1, simd construct, Restrictions]\n          // A list-item cannot appear in more than one aligned clause.\n          if (AlignedArgs.count(CanonPVD) > 0) {\n            Diag(E->getExprLoc(), diag::err_omp_used_in_clause_twice)\n                << 1 << getOpenMPClauseName(OMPC_aligned)\n                << E->getSourceRange();\n            Diag(AlignedArgs[CanonPVD]->getExprLoc(),\n                 diag::note_omp_explicit_dsa)\n                << getOpenMPClauseName(OMPC_aligned);\n            continue;\n          }\n          AlignedArgs[CanonPVD] = E;\n          QualType QTy = PVD->getType()\n                             .getNonReferenceType()\n                             .getUnqualifiedType()\n                             .getCanonicalType();\n          const Type *Ty = QTy.getTypePtrOrNull();\n          if (!Ty || (!Ty->isArrayType() && !Ty->isPointerType())) {\n            Diag(E->getExprLoc(), diag::err_omp_aligned_expected_array_or_ptr)\n                << QTy << getLangOpts().CPlusPlus << E->getSourceRange();\n            Diag(PVD->getLocation(), diag::note_previous_decl) << PVD;\n          }\n          continue;\n        }\n      }\n    if (isa<CXXThisExpr>(E)) {\n      if (AlignedThis) {\n        Diag(E->getExprLoc(), diag::err_omp_used_in_clause_twice)\n            << 2 << getOpenMPClauseName(OMPC_aligned) << E->getSourceRange();\n        Diag(AlignedThis->getExprLoc(), diag::note_omp_explicit_dsa)\n            << getOpenMPClauseName(OMPC_aligned);\n      }\n      AlignedThis = E;\n      continue;\n    }\n    Diag(E->getExprLoc(), diag::err_omp_param_or_this_in_clause)\n        << FD->getDeclName() << (isa<CXXMethodDecl>(ADecl) ? 1 : 0);\n  }\n  // The optional parameter of the aligned clause, alignment, must be a constant\n  // positive integer expression. If no optional parameter is specified,\n  // implementation-defined default alignments for SIMD instructions on the\n  // target platforms are assumed.\n  SmallVector<const Expr *, 4> NewAligns;\n  for (Expr *E : Alignments) {\n    ExprResult Align;\n    if (E)\n      Align = VerifyPositiveIntegerConstantInClause(E, OMPC_aligned);\n    NewAligns.push_back(Align.get());\n  }\n  // OpenMP [2.8.2, declare simd construct, Description]\n  // The linear clause declares one or more list items to be private to a SIMD\n  // lane and to have a linear relationship with respect to the iteration space\n  // of a loop.\n  // The special this pointer can be used as if was one of the arguments to the\n  // function in any of the linear, aligned, or uniform clauses.\n  // When a linear-step expression is specified in a linear clause it must be\n  // either a constant integer expression or an integer-typed parameter that is\n  // specified in a uniform clause on the directive.\n  llvm::DenseMap<const Decl *, const Expr *> LinearArgs;\n  const bool IsUniformedThis = UniformedLinearThis != nullptr;\n  auto MI = LinModifiers.begin();\n  for (const Expr *E : Linears) {\n    auto LinKind = static_cast<OpenMPLinearClauseKind>(*MI);\n    ++MI;\n    E = E->IgnoreParenImpCasts();\n    if (const auto *DRE = dyn_cast<DeclRefExpr>(E))\n      if (const auto *PVD = dyn_cast<ParmVarDecl>(DRE->getDecl())) {\n        const VarDecl *CanonPVD = PVD->getCanonicalDecl();\n        if (FD->getNumParams() > PVD->getFunctionScopeIndex() &&\n            FD->getParamDecl(PVD->getFunctionScopeIndex())\n                    ->getCanonicalDecl() == CanonPVD) {\n          // OpenMP  [2.15.3.7, linear Clause, Restrictions]\n          // A list-item cannot appear in more than one linear clause.\n          if (LinearArgs.count(CanonPVD) > 0) {\n            Diag(E->getExprLoc(), diag::err_omp_wrong_dsa)\n                << getOpenMPClauseName(OMPC_linear)\n                << getOpenMPClauseName(OMPC_linear) << E->getSourceRange();\n            Diag(LinearArgs[CanonPVD]->getExprLoc(),\n                 diag::note_omp_explicit_dsa)\n                << getOpenMPClauseName(OMPC_linear);\n            continue;\n          }\n          // Each argument can appear in at most one uniform or linear clause.\n          if (UniformedArgs.count(CanonPVD) > 0) {\n            Diag(E->getExprLoc(), diag::err_omp_wrong_dsa)\n                << getOpenMPClauseName(OMPC_linear)\n                << getOpenMPClauseName(OMPC_uniform) << E->getSourceRange();\n            Diag(UniformedArgs[CanonPVD]->getExprLoc(),\n                 diag::note_omp_explicit_dsa)\n                << getOpenMPClauseName(OMPC_uniform);\n            continue;\n          }\n          LinearArgs[CanonPVD] = E;\n          if (E->isValueDependent() || E->isTypeDependent() ||\n              E->isInstantiationDependent() ||\n              E->containsUnexpandedParameterPack())\n            continue;\n          (void)CheckOpenMPLinearDecl(CanonPVD, E->getExprLoc(), LinKind,\n                                      PVD->getOriginalType(),\n                                      /*IsDeclareSimd=*/true);\n          continue;\n        }\n      }\n    if (isa<CXXThisExpr>(E)) {\n      if (UniformedLinearThis) {\n        Diag(E->getExprLoc(), diag::err_omp_wrong_dsa)\n            << getOpenMPClauseName(OMPC_linear)\n            << getOpenMPClauseName(IsUniformedThis ? OMPC_uniform : OMPC_linear)\n            << E->getSourceRange();\n        Diag(UniformedLinearThis->getExprLoc(), diag::note_omp_explicit_dsa)\n            << getOpenMPClauseName(IsUniformedThis ? OMPC_uniform\n                                                   : OMPC_linear);\n        continue;\n      }\n      UniformedLinearThis = E;\n      if (E->isValueDependent() || E->isTypeDependent() ||\n          E->isInstantiationDependent() || E->containsUnexpandedParameterPack())\n        continue;\n      (void)CheckOpenMPLinearDecl(/*D=*/nullptr, E->getExprLoc(), LinKind,\n                                  E->getType(), /*IsDeclareSimd=*/true);\n      continue;\n    }\n    Diag(E->getExprLoc(), diag::err_omp_param_or_this_in_clause)\n        << FD->getDeclName() << (isa<CXXMethodDecl>(ADecl) ? 1 : 0);\n  }\n  Expr *Step = nullptr;\n  Expr *NewStep = nullptr;\n  SmallVector<Expr *, 4> NewSteps;\n  for (Expr *E : Steps) {\n    // Skip the same step expression, it was checked already.\n    if (Step == E || !E) {\n      NewSteps.push_back(E ? NewStep : nullptr);\n      continue;\n    }\n    Step = E;\n    if (const auto *DRE = dyn_cast<DeclRefExpr>(Step))\n      if (const auto *PVD = dyn_cast<ParmVarDecl>(DRE->getDecl())) {\n        const VarDecl *CanonPVD = PVD->getCanonicalDecl();\n        if (UniformedArgs.count(CanonPVD) == 0) {\n          Diag(Step->getExprLoc(), diag::err_omp_expected_uniform_param)\n              << Step->getSourceRange();\n        } else if (E->isValueDependent() || E->isTypeDependent() ||\n                   E->isInstantiationDependent() ||\n                   E->containsUnexpandedParameterPack() ||\n                   CanonPVD->getType()->hasIntegerRepresentation()) {\n          NewSteps.push_back(Step);\n        } else {\n          Diag(Step->getExprLoc(), diag::err_omp_expected_int_param)\n              << Step->getSourceRange();\n        }\n        continue;\n      }\n    NewStep = Step;\n    if (Step && !Step->isValueDependent() && !Step->isTypeDependent() &&\n        !Step->isInstantiationDependent() &&\n        !Step->containsUnexpandedParameterPack()) {\n      NewStep = PerformOpenMPImplicitIntegerConversion(Step->getExprLoc(), Step)\n                    .get();\n      if (NewStep)\n        NewStep =\n            VerifyIntegerConstantExpression(NewStep, /*FIXME*/ AllowFold).get();\n    }\n    NewSteps.push_back(NewStep);\n  }\n  auto *NewAttr = OMPDeclareSimdDeclAttr::CreateImplicit(\n      Context, BS, SL.get(), const_cast<Expr **>(Uniforms.data()),\n      Uniforms.size(), const_cast<Expr **>(Aligneds.data()), Aligneds.size(),\n      const_cast<Expr **>(NewAligns.data()), NewAligns.size(),\n      const_cast<Expr **>(Linears.data()), Linears.size(),\n      const_cast<unsigned *>(LinModifiers.data()), LinModifiers.size(),\n      NewSteps.data(), NewSteps.size(), SR);\n  ADecl->addAttr(NewAttr);\n  return DG;\n}\n\nstatic void setPrototype(Sema &S, FunctionDecl *FD, FunctionDecl *FDWithProto,\n                         QualType NewType) {\n  assert(NewType->isFunctionProtoType() &&\n         \"Expected function type with prototype.\");\n  assert(FD->getType()->isFunctionNoProtoType() &&\n         \"Expected function with type with no prototype.\");\n  assert(FDWithProto->getType()->isFunctionProtoType() &&\n         \"Expected function with prototype.\");\n  // Synthesize parameters with the same types.\n  FD->setType(NewType);\n  SmallVector<ParmVarDecl *, 16> Params;\n  for (const ParmVarDecl *P : FDWithProto->parameters()) {\n    auto *Param = ParmVarDecl::Create(S.getASTContext(), FD, SourceLocation(),\n                                      SourceLocation(), nullptr, P->getType(),\n                                      /*TInfo=*/nullptr, SC_None, nullptr);\n    Param->setScopeInfo(0, Params.size());\n    Param->setImplicit();\n    Params.push_back(Param);\n  }\n\n  FD->setParams(Params);\n}\n\nvoid Sema::ActOnFinishedFunctionDefinitionInOpenMPAssumeScope(Decl *D) {\n  if (D->isInvalidDecl())\n    return;\n  FunctionDecl *FD = nullptr;\n  if (auto *UTemplDecl = dyn_cast<FunctionTemplateDecl>(D))\n    FD = UTemplDecl->getTemplatedDecl();\n  else\n    FD = cast<FunctionDecl>(D);\n  assert(FD && \"Expected a function declaration!\");\n\n  // If we are intantiating templates we do *not* apply scoped assumptions but\n  // only global ones. We apply scoped assumption to the template definition\n  // though.\n  if (!inTemplateInstantiation()) {\n    for (AssumptionAttr *AA : OMPAssumeScoped)\n      FD->addAttr(AA);\n  }\n  for (AssumptionAttr *AA : OMPAssumeGlobal)\n    FD->addAttr(AA);\n}\n\nSema::OMPDeclareVariantScope::OMPDeclareVariantScope(OMPTraitInfo &TI)\n    : TI(&TI), NameSuffix(TI.getMangledName()) {}\n\nvoid Sema::ActOnStartOfFunctionDefinitionInOpenMPDeclareVariantScope(\n    Scope *S, Declarator &D, MultiTemplateParamsArg TemplateParamLists,\n    SmallVectorImpl<FunctionDecl *> &Bases) {\n  if (!D.getIdentifier())\n    return;\n\n  OMPDeclareVariantScope &DVScope = OMPDeclareVariantScopes.back();\n\n  // Template specialization is an extension, check if we do it.\n  bool IsTemplated = !TemplateParamLists.empty();\n  if (IsTemplated &\n      !DVScope.TI->isExtensionActive(\n          llvm::omp::TraitProperty::implementation_extension_allow_templates))\n    return;\n\n  IdentifierInfo *BaseII = D.getIdentifier();\n  LookupResult Lookup(*this, DeclarationName(BaseII), D.getIdentifierLoc(),\n                      LookupOrdinaryName);\n  LookupParsedName(Lookup, S, &D.getCXXScopeSpec());\n\n  TypeSourceInfo *TInfo = GetTypeForDeclarator(D, S);\n  QualType FType = TInfo->getType();\n\n  bool IsConstexpr =\n      D.getDeclSpec().getConstexprSpecifier() == ConstexprSpecKind::Constexpr;\n  bool IsConsteval =\n      D.getDeclSpec().getConstexprSpecifier() == ConstexprSpecKind::Consteval;\n\n  for (auto *Candidate : Lookup) {\n    auto *CandidateDecl = Candidate->getUnderlyingDecl();\n    FunctionDecl *UDecl = nullptr;\n    if (IsTemplated && isa<FunctionTemplateDecl>(CandidateDecl))\n      UDecl = cast<FunctionTemplateDecl>(CandidateDecl)->getTemplatedDecl();\n    else if (!IsTemplated)\n      UDecl = dyn_cast<FunctionDecl>(CandidateDecl);\n    if (!UDecl)\n      continue;\n\n    // Don't specialize constexpr/consteval functions with\n    // non-constexpr/consteval functions.\n    if (UDecl->isConstexpr() && !IsConstexpr)\n      continue;\n    if (UDecl->isConsteval() && !IsConsteval)\n      continue;\n\n    QualType UDeclTy = UDecl->getType();\n    if (!UDeclTy->isDependentType()) {\n      QualType NewType = Context.mergeFunctionTypes(\n          FType, UDeclTy, /* OfBlockPointer */ false,\n          /* Unqualified */ false, /* AllowCXX */ true);\n      if (NewType.isNull())\n        continue;\n    }\n\n    // Found a base!\n    Bases.push_back(UDecl);\n  }\n\n  bool UseImplicitBase = !DVScope.TI->isExtensionActive(\n      llvm::omp::TraitProperty::implementation_extension_disable_implicit_base);\n  // If no base was found we create a declaration that we use as base.\n  if (Bases.empty() && UseImplicitBase) {\n    D.setFunctionDefinitionKind(FunctionDefinitionKind::Declaration);\n    Decl *BaseD = HandleDeclarator(S, D, TemplateParamLists);\n    BaseD->setImplicit(true);\n    if (auto *BaseTemplD = dyn_cast<FunctionTemplateDecl>(BaseD))\n      Bases.push_back(BaseTemplD->getTemplatedDecl());\n    else\n      Bases.push_back(cast<FunctionDecl>(BaseD));\n  }\n\n  std::string MangledName;\n  MangledName += D.getIdentifier()->getName();\n  MangledName += getOpenMPVariantManglingSeparatorStr();\n  MangledName += DVScope.NameSuffix;\n  IdentifierInfo &VariantII = Context.Idents.get(MangledName);\n\n  VariantII.setMangledOpenMPVariantName(true);\n  D.SetIdentifier(&VariantII, D.getBeginLoc());\n}\n\nvoid Sema::ActOnFinishedFunctionDefinitionInOpenMPDeclareVariantScope(\n    Decl *D, SmallVectorImpl<FunctionDecl *> &Bases) {\n  // Do not mark function as is used to prevent its emission if this is the\n  // only place where it is used.\n  EnterExpressionEvaluationContext Unevaluated(\n      *this, Sema::ExpressionEvaluationContext::Unevaluated);\n\n  FunctionDecl *FD = nullptr;\n  if (auto *UTemplDecl = dyn_cast<FunctionTemplateDecl>(D))\n    FD = UTemplDecl->getTemplatedDecl();\n  else\n    FD = cast<FunctionDecl>(D);\n  auto *VariantFuncRef = DeclRefExpr::Create(\n      Context, NestedNameSpecifierLoc(), SourceLocation(), FD,\n      /* RefersToEnclosingVariableOrCapture */ false,\n      /* NameLoc */ FD->getLocation(), FD->getType(), ExprValueKind::VK_RValue);\n\n  OMPDeclareVariantScope &DVScope = OMPDeclareVariantScopes.back();\n  auto *OMPDeclareVariantA = OMPDeclareVariantAttr::CreateImplicit(\n      Context, VariantFuncRef, DVScope.TI);\n  for (FunctionDecl *BaseFD : Bases)\n    BaseFD->addAttr(OMPDeclareVariantA);\n}\n\nExprResult Sema::ActOnOpenMPCall(ExprResult Call, Scope *Scope,\n                                 SourceLocation LParenLoc,\n                                 MultiExprArg ArgExprs,\n                                 SourceLocation RParenLoc, Expr *ExecConfig) {\n  // The common case is a regular call we do not want to specialize at all. Try\n  // to make that case fast by bailing early.\n  CallExpr *CE = dyn_cast<CallExpr>(Call.get());\n  if (!CE)\n    return Call;\n\n  FunctionDecl *CalleeFnDecl = CE->getDirectCallee();\n  if (!CalleeFnDecl)\n    return Call;\n\n  if (!CalleeFnDecl->hasAttr<OMPDeclareVariantAttr>())\n    return Call;\n\n  ASTContext &Context = getASTContext();\n  std::function<void(StringRef)> DiagUnknownTrait = [this,\n                                                     CE](StringRef ISATrait) {\n    // TODO Track the selector locations in a way that is accessible here to\n    // improve the diagnostic location.\n    Diag(CE->getBeginLoc(), diag::warn_unknown_declare_variant_isa_trait)\n        << ISATrait;\n  };\n  TargetOMPContext OMPCtx(Context, std::move(DiagUnknownTrait),\n                          getCurFunctionDecl());\n\n  QualType CalleeFnType = CalleeFnDecl->getType();\n\n  SmallVector<Expr *, 4> Exprs;\n  SmallVector<VariantMatchInfo, 4> VMIs;\n  while (CalleeFnDecl) {\n    for (OMPDeclareVariantAttr *A :\n         CalleeFnDecl->specific_attrs<OMPDeclareVariantAttr>()) {\n      Expr *VariantRef = A->getVariantFuncRef();\n\n      VariantMatchInfo VMI;\n      OMPTraitInfo &TI = A->getTraitInfo();\n      TI.getAsVariantMatchInfo(Context, VMI);\n      if (!isVariantApplicableInContext(VMI, OMPCtx,\n                                        /* DeviceSetOnly */ false))\n        continue;\n\n      VMIs.push_back(VMI);\n      Exprs.push_back(VariantRef);\n    }\n\n    CalleeFnDecl = CalleeFnDecl->getPreviousDecl();\n  }\n\n  ExprResult NewCall;\n  do {\n    int BestIdx = getBestVariantMatchForContext(VMIs, OMPCtx);\n    if (BestIdx < 0)\n      return Call;\n    Expr *BestExpr = cast<DeclRefExpr>(Exprs[BestIdx]);\n    Decl *BestDecl = cast<DeclRefExpr>(BestExpr)->getDecl();\n\n    {\n      // Try to build a (member) call expression for the current best applicable\n      // variant expression. We allow this to fail in which case we continue\n      // with the next best variant expression. The fail case is part of the\n      // implementation defined behavior in the OpenMP standard when it talks\n      // about what differences in the function prototypes: \"Any differences\n      // that the specific OpenMP context requires in the prototype of the\n      // variant from the base function prototype are implementation defined.\"\n      // This wording is there to allow the specialized variant to have a\n      // different type than the base function. This is intended and OK but if\n      // we cannot create a call the difference is not in the \"implementation\n      // defined range\" we allow.\n      Sema::TentativeAnalysisScope Trap(*this);\n\n      if (auto *SpecializedMethod = dyn_cast<CXXMethodDecl>(BestDecl)) {\n        auto *MemberCall = dyn_cast<CXXMemberCallExpr>(CE);\n        BestExpr = MemberExpr::CreateImplicit(\n            Context, MemberCall->getImplicitObjectArgument(),\n            /* IsArrow */ false, SpecializedMethod, Context.BoundMemberTy,\n            MemberCall->getValueKind(), MemberCall->getObjectKind());\n      }\n      NewCall = BuildCallExpr(Scope, BestExpr, LParenLoc, ArgExprs, RParenLoc,\n                              ExecConfig);\n      if (NewCall.isUsable()) {\n        if (CallExpr *NCE = dyn_cast<CallExpr>(NewCall.get())) {\n          FunctionDecl *NewCalleeFnDecl = NCE->getDirectCallee();\n          QualType NewType = Context.mergeFunctionTypes(\n              CalleeFnType, NewCalleeFnDecl->getType(),\n              /* OfBlockPointer */ false,\n              /* Unqualified */ false, /* AllowCXX */ true);\n          if (!NewType.isNull())\n            break;\n          // Don't use the call if the function type was not compatible.\n          NewCall = nullptr;\n        }\n      }\n    }\n\n    VMIs.erase(VMIs.begin() + BestIdx);\n    Exprs.erase(Exprs.begin() + BestIdx);\n  } while (!VMIs.empty());\n\n  if (!NewCall.isUsable())\n    return Call;\n  return PseudoObjectExpr::Create(Context, CE, {NewCall.get()}, 0);\n}\n\nOptional<std::pair<FunctionDecl *, Expr *>>\nSema::checkOpenMPDeclareVariantFunction(Sema::DeclGroupPtrTy DG,\n                                        Expr *VariantRef, OMPTraitInfo &TI,\n                                        SourceRange SR) {\n  if (!DG || DG.get().isNull())\n    return None;\n\n  const int VariantId = 1;\n  // Must be applied only to single decl.\n  if (!DG.get().isSingleDecl()) {\n    Diag(SR.getBegin(), diag::err_omp_single_decl_in_declare_simd_variant)\n        << VariantId << SR;\n    return None;\n  }\n  Decl *ADecl = DG.get().getSingleDecl();\n  if (auto *FTD = dyn_cast<FunctionTemplateDecl>(ADecl))\n    ADecl = FTD->getTemplatedDecl();\n\n  // Decl must be a function.\n  auto *FD = dyn_cast<FunctionDecl>(ADecl);\n  if (!FD) {\n    Diag(ADecl->getLocation(), diag::err_omp_function_expected)\n        << VariantId << SR;\n    return None;\n  }\n\n  auto &&HasMultiVersionAttributes = [](const FunctionDecl *FD) {\n    return FD->hasAttrs() &&\n           (FD->hasAttr<CPUDispatchAttr>() || FD->hasAttr<CPUSpecificAttr>() ||\n            FD->hasAttr<TargetAttr>());\n  };\n  // OpenMP is not compatible with CPU-specific attributes.\n  if (HasMultiVersionAttributes(FD)) {\n    Diag(FD->getLocation(), diag::err_omp_declare_variant_incompat_attributes)\n        << SR;\n    return None;\n  }\n\n  // Allow #pragma omp declare variant only if the function is not used.\n  if (FD->isUsed(false))\n    Diag(SR.getBegin(), diag::warn_omp_declare_variant_after_used)\n        << FD->getLocation();\n\n  // Check if the function was emitted already.\n  const FunctionDecl *Definition;\n  if (!FD->isThisDeclarationADefinition() && FD->isDefined(Definition) &&\n      (LangOpts.EmitAllDecls || Context.DeclMustBeEmitted(Definition)))\n    Diag(SR.getBegin(), diag::warn_omp_declare_variant_after_emitted)\n        << FD->getLocation();\n\n  // The VariantRef must point to function.\n  if (!VariantRef) {\n    Diag(SR.getBegin(), diag::err_omp_function_expected) << VariantId;\n    return None;\n  }\n\n  auto ShouldDelayChecks = [](Expr *&E, bool) {\n    return E && (E->isTypeDependent() || E->isValueDependent() ||\n                 E->containsUnexpandedParameterPack() ||\n                 E->isInstantiationDependent());\n  };\n  // Do not check templates, wait until instantiation.\n  if (FD->isDependentContext() || ShouldDelayChecks(VariantRef, false) ||\n      TI.anyScoreOrCondition(ShouldDelayChecks))\n    return std::make_pair(FD, VariantRef);\n\n  // Deal with non-constant score and user condition expressions.\n  auto HandleNonConstantScoresAndConditions = [this](Expr *&E,\n                                                     bool IsScore) -> bool {\n    if (!E || E->isIntegerConstantExpr(Context))\n      return false;\n\n    if (IsScore) {\n      // We warn on non-constant scores and pretend they were not present.\n      Diag(E->getExprLoc(), diag::warn_omp_declare_variant_score_not_constant)\n          << E;\n      E = nullptr;\n    } else {\n      // We could replace a non-constant user condition with \"false\" but we\n      // will soon need to handle these anyway for the dynamic version of\n      // OpenMP context selectors.\n      Diag(E->getExprLoc(),\n           diag::err_omp_declare_variant_user_condition_not_constant)\n          << E;\n    }\n    return true;\n  };\n  if (TI.anyScoreOrCondition(HandleNonConstantScoresAndConditions))\n    return None;\n\n  // Convert VariantRef expression to the type of the original function to\n  // resolve possible conflicts.\n  ExprResult VariantRefCast = VariantRef;\n  if (LangOpts.CPlusPlus) {\n    QualType FnPtrType;\n    auto *Method = dyn_cast<CXXMethodDecl>(FD);\n    if (Method && !Method->isStatic()) {\n      const Type *ClassType =\n          Context.getTypeDeclType(Method->getParent()).getTypePtr();\n      FnPtrType = Context.getMemberPointerType(FD->getType(), ClassType);\n      ExprResult ER;\n      {\n        // Build adrr_of unary op to correctly handle type checks for member\n        // functions.\n        Sema::TentativeAnalysisScope Trap(*this);\n        ER = CreateBuiltinUnaryOp(VariantRef->getBeginLoc(), UO_AddrOf,\n                                  VariantRef);\n      }\n      if (!ER.isUsable()) {\n        Diag(VariantRef->getExprLoc(), diag::err_omp_function_expected)\n            << VariantId << VariantRef->getSourceRange();\n        return None;\n      }\n      VariantRef = ER.get();\n    } else {\n      FnPtrType = Context.getPointerType(FD->getType());\n    }\n    QualType VarianPtrType = Context.getPointerType(VariantRef->getType());\n    if (VarianPtrType.getUnqualifiedType() != FnPtrType.getUnqualifiedType()) {\n      ImplicitConversionSequence ICS = TryImplicitConversion(\n          VariantRef, FnPtrType.getUnqualifiedType(),\n          /*SuppressUserConversions=*/false, AllowedExplicit::None,\n          /*InOverloadResolution=*/false,\n          /*CStyle=*/false,\n          /*AllowObjCWritebackConversion=*/false);\n      if (ICS.isFailure()) {\n        Diag(VariantRef->getExprLoc(),\n             diag::err_omp_declare_variant_incompat_types)\n            << VariantRef->getType()\n            << ((Method && !Method->isStatic()) ? FnPtrType : FD->getType())\n            << VariantRef->getSourceRange();\n        return None;\n      }\n      VariantRefCast = PerformImplicitConversion(\n          VariantRef, FnPtrType.getUnqualifiedType(), AA_Converting);\n      if (!VariantRefCast.isUsable())\n        return None;\n    }\n    // Drop previously built artificial addr_of unary op for member functions.\n    if (Method && !Method->isStatic()) {\n      Expr *PossibleAddrOfVariantRef = VariantRefCast.get();\n      if (auto *UO = dyn_cast<UnaryOperator>(\n              PossibleAddrOfVariantRef->IgnoreImplicit()))\n        VariantRefCast = UO->getSubExpr();\n    }\n  }\n\n  ExprResult ER = CheckPlaceholderExpr(VariantRefCast.get());\n  if (!ER.isUsable() ||\n      !ER.get()->IgnoreParenImpCasts()->getType()->isFunctionType()) {\n    Diag(VariantRef->getExprLoc(), diag::err_omp_function_expected)\n        << VariantId << VariantRef->getSourceRange();\n    return None;\n  }\n\n  // The VariantRef must point to function.\n  auto *DRE = dyn_cast<DeclRefExpr>(ER.get()->IgnoreParenImpCasts());\n  if (!DRE) {\n    Diag(VariantRef->getExprLoc(), diag::err_omp_function_expected)\n        << VariantId << VariantRef->getSourceRange();\n    return None;\n  }\n  auto *NewFD = dyn_cast_or_null<FunctionDecl>(DRE->getDecl());\n  if (!NewFD) {\n    Diag(VariantRef->getExprLoc(), diag::err_omp_function_expected)\n        << VariantId << VariantRef->getSourceRange();\n    return None;\n  }\n\n  // Check if function types are compatible in C.\n  if (!LangOpts.CPlusPlus) {\n    QualType NewType =\n        Context.mergeFunctionTypes(FD->getType(), NewFD->getType());\n    if (NewType.isNull()) {\n      Diag(VariantRef->getExprLoc(),\n           diag::err_omp_declare_variant_incompat_types)\n          << NewFD->getType() << FD->getType() << VariantRef->getSourceRange();\n      return None;\n    }\n    if (NewType->isFunctionProtoType()) {\n      if (FD->getType()->isFunctionNoProtoType())\n        setPrototype(*this, FD, NewFD, NewType);\n      else if (NewFD->getType()->isFunctionNoProtoType())\n        setPrototype(*this, NewFD, FD, NewType);\n    }\n  }\n\n  // Check if variant function is not marked with declare variant directive.\n  if (NewFD->hasAttrs() && NewFD->hasAttr<OMPDeclareVariantAttr>()) {\n    Diag(VariantRef->getExprLoc(),\n         diag::warn_omp_declare_variant_marked_as_declare_variant)\n        << VariantRef->getSourceRange();\n    SourceRange SR =\n        NewFD->specific_attr_begin<OMPDeclareVariantAttr>()->getRange();\n    Diag(SR.getBegin(), diag::note_omp_marked_declare_variant_here) << SR;\n    return None;\n  }\n\n  enum DoesntSupport {\n    VirtFuncs = 1,\n    Constructors = 3,\n    Destructors = 4,\n    DeletedFuncs = 5,\n    DefaultedFuncs = 6,\n    ConstexprFuncs = 7,\n    ConstevalFuncs = 8,\n  };\n  if (const auto *CXXFD = dyn_cast<CXXMethodDecl>(FD)) {\n    if (CXXFD->isVirtual()) {\n      Diag(FD->getLocation(), diag::err_omp_declare_variant_doesnt_support)\n          << VirtFuncs;\n      return None;\n    }\n\n    if (isa<CXXConstructorDecl>(FD)) {\n      Diag(FD->getLocation(), diag::err_omp_declare_variant_doesnt_support)\n          << Constructors;\n      return None;\n    }\n\n    if (isa<CXXDestructorDecl>(FD)) {\n      Diag(FD->getLocation(), diag::err_omp_declare_variant_doesnt_support)\n          << Destructors;\n      return None;\n    }\n  }\n\n  if (FD->isDeleted()) {\n    Diag(FD->getLocation(), diag::err_omp_declare_variant_doesnt_support)\n        << DeletedFuncs;\n    return None;\n  }\n\n  if (FD->isDefaulted()) {\n    Diag(FD->getLocation(), diag::err_omp_declare_variant_doesnt_support)\n        << DefaultedFuncs;\n    return None;\n  }\n\n  if (FD->isConstexpr()) {\n    Diag(FD->getLocation(), diag::err_omp_declare_variant_doesnt_support)\n        << (NewFD->isConsteval() ? ConstevalFuncs : ConstexprFuncs);\n    return None;\n  }\n\n  // Check general compatibility.\n  if (areMultiversionVariantFunctionsCompatible(\n          FD, NewFD, PartialDiagnostic::NullDiagnostic(),\n          PartialDiagnosticAt(SourceLocation(),\n                              PartialDiagnostic::NullDiagnostic()),\n          PartialDiagnosticAt(\n              VariantRef->getExprLoc(),\n              PDiag(diag::err_omp_declare_variant_doesnt_support)),\n          PartialDiagnosticAt(VariantRef->getExprLoc(),\n                              PDiag(diag::err_omp_declare_variant_diff)\n                                  << FD->getLocation()),\n          /*TemplatesSupported=*/true, /*ConstexprSupported=*/false,\n          /*CLinkageMayDiffer=*/true))\n    return None;\n  return std::make_pair(FD, cast<Expr>(DRE));\n}\n\nvoid Sema::ActOnOpenMPDeclareVariantDirective(FunctionDecl *FD,\n                                              Expr *VariantRef,\n                                              OMPTraitInfo &TI,\n                                              SourceRange SR) {\n  auto *NewAttr =\n      OMPDeclareVariantAttr::CreateImplicit(Context, VariantRef, &TI, SR);\n  FD->addAttr(NewAttr);\n}\n\nStmtResult Sema::ActOnOpenMPParallelDirective(ArrayRef<OMPClause *> Clauses,\n                                              Stmt *AStmt,\n                                              SourceLocation StartLoc,\n                                              SourceLocation EndLoc) {\n  if (!AStmt)\n    return StmtError();\n\n  auto *CS = cast<CapturedStmt>(AStmt);\n  // 1.2.2 OpenMP Language Terminology\n  // Structured block - An executable statement with a single entry at the\n  // top and a single exit at the bottom.\n  // The point of exit cannot be a branch out of the structured block.\n  // longjmp() and throw() must not violate the entry/exit criteria.\n  CS->getCapturedDecl()->setNothrow();\n\n  setFunctionHasBranchProtectedScope();\n\n  return OMPParallelDirective::Create(Context, StartLoc, EndLoc, Clauses, AStmt,\n                                      DSAStack->getTaskgroupReductionRef(),\n                                      DSAStack->isCancelRegion());\n}\n\nnamespace {\n/// Iteration space of a single for loop.\nstruct LoopIterationSpace final {\n  /// True if the condition operator is the strict compare operator (<, > or\n  /// !=).\n  bool IsStrictCompare = false;\n  /// Condition of the loop.\n  Expr *PreCond = nullptr;\n  /// This expression calculates the number of iterations in the loop.\n  /// It is always possible to calculate it before starting the loop.\n  Expr *NumIterations = nullptr;\n  /// The loop counter variable.\n  Expr *CounterVar = nullptr;\n  /// Private loop counter variable.\n  Expr *PrivateCounterVar = nullptr;\n  /// This is initializer for the initial value of #CounterVar.\n  Expr *CounterInit = nullptr;\n  /// This is step for the #CounterVar used to generate its update:\n  /// #CounterVar = #CounterInit + #CounterStep * CurrentIteration.\n  Expr *CounterStep = nullptr;\n  /// Should step be subtracted?\n  bool Subtract = false;\n  /// Source range of the loop init.\n  SourceRange InitSrcRange;\n  /// Source range of the loop condition.\n  SourceRange CondSrcRange;\n  /// Source range of the loop increment.\n  SourceRange IncSrcRange;\n  /// Minimum value that can have the loop control variable. Used to support\n  /// non-rectangular loops. Applied only for LCV with the non-iterator types,\n  /// since only such variables can be used in non-loop invariant expressions.\n  Expr *MinValue = nullptr;\n  /// Maximum value that can have the loop control variable. Used to support\n  /// non-rectangular loops. Applied only for LCV with the non-iterator type,\n  /// since only such variables can be used in non-loop invariant expressions.\n  Expr *MaxValue = nullptr;\n  /// true, if the lower bound depends on the outer loop control var.\n  bool IsNonRectangularLB = false;\n  /// true, if the upper bound depends on the outer loop control var.\n  bool IsNonRectangularUB = false;\n  /// Index of the loop this loop depends on and forms non-rectangular loop\n  /// nest.\n  unsigned LoopDependentIdx = 0;\n  /// Final condition for the non-rectangular loop nest support. It is used to\n  /// check that the number of iterations for this particular counter must be\n  /// finished.\n  Expr *FinalCondition = nullptr;\n};\n\n/// Helper class for checking canonical form of the OpenMP loops and\n/// extracting iteration space of each loop in the loop nest, that will be used\n/// for IR generation.\nclass OpenMPIterationSpaceChecker {\n  /// Reference to Sema.\n  Sema &SemaRef;\n  /// Does the loop associated directive support non-rectangular loops?\n  bool SupportsNonRectangular;\n  /// Data-sharing stack.\n  DSAStackTy &Stack;\n  /// A location for diagnostics (when there is no some better location).\n  SourceLocation DefaultLoc;\n  /// A location for diagnostics (when increment is not compatible).\n  SourceLocation ConditionLoc;\n  /// A source location for referring to loop init later.\n  SourceRange InitSrcRange;\n  /// A source location for referring to condition later.\n  SourceRange ConditionSrcRange;\n  /// A source location for referring to increment later.\n  SourceRange IncrementSrcRange;\n  /// Loop variable.\n  ValueDecl *LCDecl = nullptr;\n  /// Reference to loop variable.\n  Expr *LCRef = nullptr;\n  /// Lower bound (initializer for the var).\n  Expr *LB = nullptr;\n  /// Upper bound.\n  Expr *UB = nullptr;\n  /// Loop step (increment).\n  Expr *Step = nullptr;\n  /// This flag is true when condition is one of:\n  ///   Var <  UB\n  ///   Var <= UB\n  ///   UB  >  Var\n  ///   UB  >= Var\n  /// This will have no value when the condition is !=\n  llvm::Optional<bool> TestIsLessOp;\n  /// This flag is true when condition is strict ( < or > ).\n  bool TestIsStrictOp = false;\n  /// This flag is true when step is subtracted on each iteration.\n  bool SubtractStep = false;\n  /// The outer loop counter this loop depends on (if any).\n  const ValueDecl *DepDecl = nullptr;\n  /// Contains number of loop (starts from 1) on which loop counter init\n  /// expression of this loop depends on.\n  Optional<unsigned> InitDependOnLC;\n  /// Contains number of loop (starts from 1) on which loop counter condition\n  /// expression of this loop depends on.\n  Optional<unsigned> CondDependOnLC;\n  /// Checks if the provide statement depends on the loop counter.\n  Optional<unsigned> doesDependOnLoopCounter(const Stmt *S, bool IsInitializer);\n  /// Original condition required for checking of the exit condition for\n  /// non-rectangular loop.\n  Expr *Condition = nullptr;\n\npublic:\n  OpenMPIterationSpaceChecker(Sema &SemaRef, bool SupportsNonRectangular,\n                              DSAStackTy &Stack, SourceLocation DefaultLoc)\n      : SemaRef(SemaRef), SupportsNonRectangular(SupportsNonRectangular),\n        Stack(Stack), DefaultLoc(DefaultLoc), ConditionLoc(DefaultLoc) {}\n  /// Check init-expr for canonical loop form and save loop counter\n  /// variable - #Var and its initialization value - #LB.\n  bool checkAndSetInit(Stmt *S, bool EmitDiags = true);\n  /// Check test-expr for canonical form, save upper-bound (#UB), flags\n  /// for less/greater and for strict/non-strict comparison.\n  bool checkAndSetCond(Expr *S);\n  /// Check incr-expr for canonical loop form and return true if it\n  /// does not conform, otherwise save loop step (#Step).\n  bool checkAndSetInc(Expr *S);\n  /// Return the loop counter variable.\n  ValueDecl *getLoopDecl() const { return LCDecl; }\n  /// Return the reference expression to loop counter variable.\n  Expr *getLoopDeclRefExpr() const { return LCRef; }\n  /// Source range of the loop init.\n  SourceRange getInitSrcRange() const { return InitSrcRange; }\n  /// Source range of the loop condition.\n  SourceRange getConditionSrcRange() const { return ConditionSrcRange; }\n  /// Source range of the loop increment.\n  SourceRange getIncrementSrcRange() const { return IncrementSrcRange; }\n  /// True if the step should be subtracted.\n  bool shouldSubtractStep() const { return SubtractStep; }\n  /// True, if the compare operator is strict (<, > or !=).\n  bool isStrictTestOp() const { return TestIsStrictOp; }\n  /// Build the expression to calculate the number of iterations.\n  Expr *buildNumIterations(\n      Scope *S, ArrayRef<LoopIterationSpace> ResultIterSpaces, bool LimitedType,\n      llvm::MapVector<const Expr *, DeclRefExpr *> &Captures) const;\n  /// Build the precondition expression for the loops.\n  Expr *\n  buildPreCond(Scope *S, Expr *Cond,\n               llvm::MapVector<const Expr *, DeclRefExpr *> &Captures) const;\n  /// Build reference expression to the counter be used for codegen.\n  DeclRefExpr *\n  buildCounterVar(llvm::MapVector<const Expr *, DeclRefExpr *> &Captures,\n                  DSAStackTy &DSA) const;\n  /// Build reference expression to the private counter be used for\n  /// codegen.\n  Expr *buildPrivateCounterVar() const;\n  /// Build initialization of the counter be used for codegen.\n  Expr *buildCounterInit() const;\n  /// Build step of the counter be used for codegen.\n  Expr *buildCounterStep() const;\n  /// Build loop data with counter value for depend clauses in ordered\n  /// directives.\n  Expr *\n  buildOrderedLoopData(Scope *S, Expr *Counter,\n                       llvm::MapVector<const Expr *, DeclRefExpr *> &Captures,\n                       SourceLocation Loc, Expr *Inc = nullptr,\n                       OverloadedOperatorKind OOK = OO_Amp);\n  /// Builds the minimum value for the loop counter.\n  std::pair<Expr *, Expr *> buildMinMaxValues(\n      Scope *S, llvm::MapVector<const Expr *, DeclRefExpr *> &Captures) const;\n  /// Builds final condition for the non-rectangular loops.\n  Expr *buildFinalCondition(Scope *S) const;\n  /// Return true if any expression is dependent.\n  bool dependent() const;\n  /// Returns true if the initializer forms non-rectangular loop.\n  bool doesInitDependOnLC() const { return InitDependOnLC.hasValue(); }\n  /// Returns true if the condition forms non-rectangular loop.\n  bool doesCondDependOnLC() const { return CondDependOnLC.hasValue(); }\n  /// Returns index of the loop we depend on (starting from 1), or 0 otherwise.\n  unsigned getLoopDependentIdx() const {\n    return InitDependOnLC.getValueOr(CondDependOnLC.getValueOr(0));\n  }\n\nprivate:\n  /// Check the right-hand side of an assignment in the increment\n  /// expression.\n  bool checkAndSetIncRHS(Expr *RHS);\n  /// Helper to set loop counter variable and its initializer.\n  bool setLCDeclAndLB(ValueDecl *NewLCDecl, Expr *NewDeclRefExpr, Expr *NewLB,\n                      bool EmitDiags);\n  /// Helper to set upper bound.\n  bool setUB(Expr *NewUB, llvm::Optional<bool> LessOp, bool StrictOp,\n             SourceRange SR, SourceLocation SL);\n  /// Helper to set loop increment.\n  bool setStep(Expr *NewStep, bool Subtract);\n};\n\nbool OpenMPIterationSpaceChecker::dependent() const {\n  if (!LCDecl) {\n    assert(!LB && !UB && !Step);\n    return false;\n  }\n  return LCDecl->getType()->isDependentType() ||\n         (LB && LB->isValueDependent()) || (UB && UB->isValueDependent()) ||\n         (Step && Step->isValueDependent());\n}\n\nbool OpenMPIterationSpaceChecker::setLCDeclAndLB(ValueDecl *NewLCDecl,\n                                                 Expr *NewLCRefExpr,\n                                                 Expr *NewLB, bool EmitDiags) {\n  // State consistency checking to ensure correct usage.\n  assert(LCDecl == nullptr && LB == nullptr && LCRef == nullptr &&\n         UB == nullptr && Step == nullptr && !TestIsLessOp && !TestIsStrictOp);\n  if (!NewLCDecl || !NewLB)\n    return true;\n  LCDecl = getCanonicalDecl(NewLCDecl);\n  LCRef = NewLCRefExpr;\n  if (auto *CE = dyn_cast_or_null<CXXConstructExpr>(NewLB))\n    if (const CXXConstructorDecl *Ctor = CE->getConstructor())\n      if ((Ctor->isCopyOrMoveConstructor() ||\n           Ctor->isConvertingConstructor(/*AllowExplicit=*/false)) &&\n          CE->getNumArgs() > 0 && CE->getArg(0) != nullptr)\n        NewLB = CE->getArg(0)->IgnoreParenImpCasts();\n  LB = NewLB;\n  if (EmitDiags)\n    InitDependOnLC = doesDependOnLoopCounter(LB, /*IsInitializer=*/true);\n  return false;\n}\n\nbool OpenMPIterationSpaceChecker::setUB(Expr *NewUB,\n                                        llvm::Optional<bool> LessOp,\n                                        bool StrictOp, SourceRange SR,\n                                        SourceLocation SL) {\n  // State consistency checking to ensure correct usage.\n  assert(LCDecl != nullptr && LB != nullptr && UB == nullptr &&\n         Step == nullptr && !TestIsLessOp && !TestIsStrictOp);\n  if (!NewUB)\n    return true;\n  UB = NewUB;\n  if (LessOp)\n    TestIsLessOp = LessOp;\n  TestIsStrictOp = StrictOp;\n  ConditionSrcRange = SR;\n  ConditionLoc = SL;\n  CondDependOnLC = doesDependOnLoopCounter(UB, /*IsInitializer=*/false);\n  return false;\n}\n\nbool OpenMPIterationSpaceChecker::setStep(Expr *NewStep, bool Subtract) {\n  // State consistency checking to ensure correct usage.\n  assert(LCDecl != nullptr && LB != nullptr && Step == nullptr);\n  if (!NewStep)\n    return true;\n  if (!NewStep->isValueDependent()) {\n    // Check that the step is integer expression.\n    SourceLocation StepLoc = NewStep->getBeginLoc();\n    ExprResult Val = SemaRef.PerformOpenMPImplicitIntegerConversion(\n        StepLoc, getExprAsWritten(NewStep));\n    if (Val.isInvalid())\n      return true;\n    NewStep = Val.get();\n\n    // OpenMP [2.6, Canonical Loop Form, Restrictions]\n    //  If test-expr is of form var relational-op b and relational-op is < or\n    //  <= then incr-expr must cause var to increase on each iteration of the\n    //  loop. If test-expr is of form var relational-op b and relational-op is\n    //  > or >= then incr-expr must cause var to decrease on each iteration of\n    //  the loop.\n    //  If test-expr is of form b relational-op var and relational-op is < or\n    //  <= then incr-expr must cause var to decrease on each iteration of the\n    //  loop. If test-expr is of form b relational-op var and relational-op is\n    //  > or >= then incr-expr must cause var to increase on each iteration of\n    //  the loop.\n    Optional<llvm::APSInt> Result =\n        NewStep->getIntegerConstantExpr(SemaRef.Context);\n    bool IsUnsigned = !NewStep->getType()->hasSignedIntegerRepresentation();\n    bool IsConstNeg =\n        Result && Result->isSigned() && (Subtract != Result->isNegative());\n    bool IsConstPos =\n        Result && Result->isSigned() && (Subtract == Result->isNegative());\n    bool IsConstZero = Result && !Result->getBoolValue();\n\n    // != with increment is treated as <; != with decrement is treated as >\n    if (!TestIsLessOp.hasValue())\n      TestIsLessOp = IsConstPos || (IsUnsigned && !Subtract);\n    if (UB && (IsConstZero ||\n               (TestIsLessOp.getValue() ?\n                  (IsConstNeg || (IsUnsigned && Subtract)) :\n                  (IsConstPos || (IsUnsigned && !Subtract))))) {\n      SemaRef.Diag(NewStep->getExprLoc(),\n                   diag::err_omp_loop_incr_not_compatible)\n          << LCDecl << TestIsLessOp.getValue() << NewStep->getSourceRange();\n      SemaRef.Diag(ConditionLoc,\n                   diag::note_omp_loop_cond_requres_compatible_incr)\n          << TestIsLessOp.getValue() << ConditionSrcRange;\n      return true;\n    }\n    if (TestIsLessOp.getValue() == Subtract) {\n      NewStep =\n          SemaRef.CreateBuiltinUnaryOp(NewStep->getExprLoc(), UO_Minus, NewStep)\n              .get();\n      Subtract = !Subtract;\n    }\n  }\n\n  Step = NewStep;\n  SubtractStep = Subtract;\n  return false;\n}\n\nnamespace {\n/// Checker for the non-rectangular loops. Checks if the initializer or\n/// condition expression references loop counter variable.\nclass LoopCounterRefChecker final\n    : public ConstStmtVisitor<LoopCounterRefChecker, bool> {\n  Sema &SemaRef;\n  DSAStackTy &Stack;\n  const ValueDecl *CurLCDecl = nullptr;\n  const ValueDecl *DepDecl = nullptr;\n  const ValueDecl *PrevDepDecl = nullptr;\n  bool IsInitializer = true;\n  bool SupportsNonRectangular;\n  unsigned BaseLoopId = 0;\n  bool checkDecl(const Expr *E, const ValueDecl *VD) {\n    if (getCanonicalDecl(VD) == getCanonicalDecl(CurLCDecl)) {\n      SemaRef.Diag(E->getExprLoc(), diag::err_omp_stmt_depends_on_loop_counter)\n          << (IsInitializer ? 0 : 1);\n      return false;\n    }\n    const auto &&Data = Stack.isLoopControlVariable(VD);\n    // OpenMP, 2.9.1 Canonical Loop Form, Restrictions.\n    // The type of the loop iterator on which we depend may not have a random\n    // access iterator type.\n    if (Data.first && VD->getType()->isRecordType()) {\n      SmallString<128> Name;\n      llvm::raw_svector_ostream OS(Name);\n      VD->getNameForDiagnostic(OS, SemaRef.getPrintingPolicy(),\n                               /*Qualified=*/true);\n      SemaRef.Diag(E->getExprLoc(),\n                   diag::err_omp_wrong_dependency_iterator_type)\n          << OS.str();\n      SemaRef.Diag(VD->getLocation(), diag::note_previous_decl) << VD;\n      return false;\n    }\n    if (Data.first && !SupportsNonRectangular) {\n      SemaRef.Diag(E->getExprLoc(), diag::err_omp_invariant_dependency);\n      return false;\n    }\n    if (Data.first &&\n        (DepDecl || (PrevDepDecl &&\n                     getCanonicalDecl(VD) != getCanonicalDecl(PrevDepDecl)))) {\n      if (!DepDecl && PrevDepDecl)\n        DepDecl = PrevDepDecl;\n      SmallString<128> Name;\n      llvm::raw_svector_ostream OS(Name);\n      DepDecl->getNameForDiagnostic(OS, SemaRef.getPrintingPolicy(),\n                                    /*Qualified=*/true);\n      SemaRef.Diag(E->getExprLoc(),\n                   diag::err_omp_invariant_or_linear_dependency)\n          << OS.str();\n      return false;\n    }\n    if (Data.first) {\n      DepDecl = VD;\n      BaseLoopId = Data.first;\n    }\n    return Data.first;\n  }\n\npublic:\n  bool VisitDeclRefExpr(const DeclRefExpr *E) {\n    const ValueDecl *VD = E->getDecl();\n    if (isa<VarDecl>(VD))\n      return checkDecl(E, VD);\n    return false;\n  }\n  bool VisitMemberExpr(const MemberExpr *E) {\n    if (isa<CXXThisExpr>(E->getBase()->IgnoreParens())) {\n      const ValueDecl *VD = E->getMemberDecl();\n      if (isa<VarDecl>(VD) || isa<FieldDecl>(VD))\n        return checkDecl(E, VD);\n    }\n    return false;\n  }\n  bool VisitStmt(const Stmt *S) {\n    bool Res = false;\n    for (const Stmt *Child : S->children())\n      Res = (Child && Visit(Child)) || Res;\n    return Res;\n  }\n  explicit LoopCounterRefChecker(Sema &SemaRef, DSAStackTy &Stack,\n                                 const ValueDecl *CurLCDecl, bool IsInitializer,\n                                 const ValueDecl *PrevDepDecl = nullptr,\n                                 bool SupportsNonRectangular = true)\n      : SemaRef(SemaRef), Stack(Stack), CurLCDecl(CurLCDecl),\n        PrevDepDecl(PrevDepDecl), IsInitializer(IsInitializer),\n        SupportsNonRectangular(SupportsNonRectangular) {}\n  unsigned getBaseLoopId() const {\n    assert(CurLCDecl && \"Expected loop dependency.\");\n    return BaseLoopId;\n  }\n  const ValueDecl *getDepDecl() const {\n    assert(CurLCDecl && \"Expected loop dependency.\");\n    return DepDecl;\n  }\n};\n} // namespace\n\nOptional<unsigned>\nOpenMPIterationSpaceChecker::doesDependOnLoopCounter(const Stmt *S,\n                                                     bool IsInitializer) {\n  // Check for the non-rectangular loops.\n  LoopCounterRefChecker LoopStmtChecker(SemaRef, Stack, LCDecl, IsInitializer,\n                                        DepDecl, SupportsNonRectangular);\n  if (LoopStmtChecker.Visit(S)) {\n    DepDecl = LoopStmtChecker.getDepDecl();\n    return LoopStmtChecker.getBaseLoopId();\n  }\n  return llvm::None;\n}\n\nbool OpenMPIterationSpaceChecker::checkAndSetInit(Stmt *S, bool EmitDiags) {\n  // Check init-expr for canonical loop form and save loop counter\n  // variable - #Var and its initialization value - #LB.\n  // OpenMP [2.6] Canonical loop form. init-expr may be one of the following:\n  //   var = lb\n  //   integer-type var = lb\n  //   random-access-iterator-type var = lb\n  //   pointer-type var = lb\n  //\n  if (!S) {\n    if (EmitDiags) {\n      SemaRef.Diag(DefaultLoc, diag::err_omp_loop_not_canonical_init);\n    }\n    return true;\n  }\n  if (auto *ExprTemp = dyn_cast<ExprWithCleanups>(S))\n    if (!ExprTemp->cleanupsHaveSideEffects())\n      S = ExprTemp->getSubExpr();\n\n  InitSrcRange = S->getSourceRange();\n  if (Expr *E = dyn_cast<Expr>(S))\n    S = E->IgnoreParens();\n  if (auto *BO = dyn_cast<BinaryOperator>(S)) {\n    if (BO->getOpcode() == BO_Assign) {\n      Expr *LHS = BO->getLHS()->IgnoreParens();\n      if (auto *DRE = dyn_cast<DeclRefExpr>(LHS)) {\n        if (auto *CED = dyn_cast<OMPCapturedExprDecl>(DRE->getDecl()))\n          if (auto *ME = dyn_cast<MemberExpr>(getExprAsWritten(CED->getInit())))\n            return setLCDeclAndLB(ME->getMemberDecl(), ME, BO->getRHS(),\n                                  EmitDiags);\n        return setLCDeclAndLB(DRE->getDecl(), DRE, BO->getRHS(), EmitDiags);\n      }\n      if (auto *ME = dyn_cast<MemberExpr>(LHS)) {\n        if (ME->isArrow() &&\n            isa<CXXThisExpr>(ME->getBase()->IgnoreParenImpCasts()))\n          return setLCDeclAndLB(ME->getMemberDecl(), ME, BO->getRHS(),\n                                EmitDiags);\n      }\n    }\n  } else if (auto *DS = dyn_cast<DeclStmt>(S)) {\n    if (DS->isSingleDecl()) {\n      if (auto *Var = dyn_cast_or_null<VarDecl>(DS->getSingleDecl())) {\n        if (Var->hasInit() && !Var->getType()->isReferenceType()) {\n          // Accept non-canonical init form here but emit ext. warning.\n          if (Var->getInitStyle() != VarDecl::CInit && EmitDiags)\n            SemaRef.Diag(S->getBeginLoc(),\n                         diag::ext_omp_loop_not_canonical_init)\n                << S->getSourceRange();\n          return setLCDeclAndLB(\n              Var,\n              buildDeclRefExpr(SemaRef, Var,\n                               Var->getType().getNonReferenceType(),\n                               DS->getBeginLoc()),\n              Var->getInit(), EmitDiags);\n        }\n      }\n    }\n  } else if (auto *CE = dyn_cast<CXXOperatorCallExpr>(S)) {\n    if (CE->getOperator() == OO_Equal) {\n      Expr *LHS = CE->getArg(0);\n      if (auto *DRE = dyn_cast<DeclRefExpr>(LHS)) {\n        if (auto *CED = dyn_cast<OMPCapturedExprDecl>(DRE->getDecl()))\n          if (auto *ME = dyn_cast<MemberExpr>(getExprAsWritten(CED->getInit())))\n            return setLCDeclAndLB(ME->getMemberDecl(), ME, BO->getRHS(),\n                                  EmitDiags);\n        return setLCDeclAndLB(DRE->getDecl(), DRE, CE->getArg(1), EmitDiags);\n      }\n      if (auto *ME = dyn_cast<MemberExpr>(LHS)) {\n        if (ME->isArrow() &&\n            isa<CXXThisExpr>(ME->getBase()->IgnoreParenImpCasts()))\n          return setLCDeclAndLB(ME->getMemberDecl(), ME, BO->getRHS(),\n                                EmitDiags);\n      }\n    }\n  }\n\n  if (dependent() || SemaRef.CurContext->isDependentContext())\n    return false;\n  if (EmitDiags) {\n    SemaRef.Diag(S->getBeginLoc(), diag::err_omp_loop_not_canonical_init)\n        << S->getSourceRange();\n  }\n  return true;\n}\n\n/// Ignore parenthesizes, implicit casts, copy constructor and return the\n/// variable (which may be the loop variable) if possible.\nstatic const ValueDecl *getInitLCDecl(const Expr *E) {\n  if (!E)\n    return nullptr;\n  E = getExprAsWritten(E);\n  if (const auto *CE = dyn_cast_or_null<CXXConstructExpr>(E))\n    if (const CXXConstructorDecl *Ctor = CE->getConstructor())\n      if ((Ctor->isCopyOrMoveConstructor() ||\n           Ctor->isConvertingConstructor(/*AllowExplicit=*/false)) &&\n          CE->getNumArgs() > 0 && CE->getArg(0) != nullptr)\n        E = CE->getArg(0)->IgnoreParenImpCasts();\n  if (const auto *DRE = dyn_cast_or_null<DeclRefExpr>(E)) {\n    if (const auto *VD = dyn_cast<VarDecl>(DRE->getDecl()))\n      return getCanonicalDecl(VD);\n  }\n  if (const auto *ME = dyn_cast_or_null<MemberExpr>(E))\n    if (ME->isArrow() && isa<CXXThisExpr>(ME->getBase()->IgnoreParenImpCasts()))\n      return getCanonicalDecl(ME->getMemberDecl());\n  return nullptr;\n}\n\nbool OpenMPIterationSpaceChecker::checkAndSetCond(Expr *S) {\n  // Check test-expr for canonical form, save upper-bound UB, flags for\n  // less/greater and for strict/non-strict comparison.\n  // OpenMP [2.9] Canonical loop form. Test-expr may be one of the following:\n  //   var relational-op b\n  //   b relational-op var\n  //\n  bool IneqCondIsCanonical = SemaRef.getLangOpts().OpenMP >= 50;\n  if (!S) {\n    SemaRef.Diag(DefaultLoc, diag::err_omp_loop_not_canonical_cond)\n        << (IneqCondIsCanonical ? 1 : 0) << LCDecl;\n    return true;\n  }\n  Condition = S;\n  S = getExprAsWritten(S);\n  SourceLocation CondLoc = S->getBeginLoc();\n  if (auto *BO = dyn_cast<BinaryOperator>(S)) {\n    if (BO->isRelationalOp()) {\n      if (getInitLCDecl(BO->getLHS()) == LCDecl)\n        return setUB(BO->getRHS(),\n                     (BO->getOpcode() == BO_LT || BO->getOpcode() == BO_LE),\n                     (BO->getOpcode() == BO_LT || BO->getOpcode() == BO_GT),\n                     BO->getSourceRange(), BO->getOperatorLoc());\n      if (getInitLCDecl(BO->getRHS()) == LCDecl)\n        return setUB(BO->getLHS(),\n                     (BO->getOpcode() == BO_GT || BO->getOpcode() == BO_GE),\n                     (BO->getOpcode() == BO_LT || BO->getOpcode() == BO_GT),\n                     BO->getSourceRange(), BO->getOperatorLoc());\n    } else if (IneqCondIsCanonical && BO->getOpcode() == BO_NE)\n      return setUB(\n          getInitLCDecl(BO->getLHS()) == LCDecl ? BO->getRHS() : BO->getLHS(),\n          /*LessOp=*/llvm::None,\n          /*StrictOp=*/true, BO->getSourceRange(), BO->getOperatorLoc());\n  } else if (auto *CE = dyn_cast<CXXOperatorCallExpr>(S)) {\n    if (CE->getNumArgs() == 2) {\n      auto Op = CE->getOperator();\n      switch (Op) {\n      case OO_Greater:\n      case OO_GreaterEqual:\n      case OO_Less:\n      case OO_LessEqual:\n        if (getInitLCDecl(CE->getArg(0)) == LCDecl)\n          return setUB(CE->getArg(1), Op == OO_Less || Op == OO_LessEqual,\n                       Op == OO_Less || Op == OO_Greater, CE->getSourceRange(),\n                       CE->getOperatorLoc());\n        if (getInitLCDecl(CE->getArg(1)) == LCDecl)\n          return setUB(CE->getArg(0), Op == OO_Greater || Op == OO_GreaterEqual,\n                       Op == OO_Less || Op == OO_Greater, CE->getSourceRange(),\n                       CE->getOperatorLoc());\n        break;\n      case OO_ExclaimEqual:\n        if (IneqCondIsCanonical)\n          return setUB(getInitLCDecl(CE->getArg(0)) == LCDecl ? CE->getArg(1)\n                                                              : CE->getArg(0),\n                       /*LessOp=*/llvm::None,\n                       /*StrictOp=*/true, CE->getSourceRange(),\n                       CE->getOperatorLoc());\n        break;\n      default:\n        break;\n      }\n    }\n  }\n  if (dependent() || SemaRef.CurContext->isDependentContext())\n    return false;\n  SemaRef.Diag(CondLoc, diag::err_omp_loop_not_canonical_cond)\n      << (IneqCondIsCanonical ? 1 : 0) << S->getSourceRange() << LCDecl;\n  return true;\n}\n\nbool OpenMPIterationSpaceChecker::checkAndSetIncRHS(Expr *RHS) {\n  // RHS of canonical loop form increment can be:\n  //   var + incr\n  //   incr + var\n  //   var - incr\n  //\n  RHS = RHS->IgnoreParenImpCasts();\n  if (auto *BO = dyn_cast<BinaryOperator>(RHS)) {\n    if (BO->isAdditiveOp()) {\n      bool IsAdd = BO->getOpcode() == BO_Add;\n      if (getInitLCDecl(BO->getLHS()) == LCDecl)\n        return setStep(BO->getRHS(), !IsAdd);\n      if (IsAdd && getInitLCDecl(BO->getRHS()) == LCDecl)\n        return setStep(BO->getLHS(), /*Subtract=*/false);\n    }\n  } else if (auto *CE = dyn_cast<CXXOperatorCallExpr>(RHS)) {\n    bool IsAdd = CE->getOperator() == OO_Plus;\n    if ((IsAdd || CE->getOperator() == OO_Minus) && CE->getNumArgs() == 2) {\n      if (getInitLCDecl(CE->getArg(0)) == LCDecl)\n        return setStep(CE->getArg(1), !IsAdd);\n      if (IsAdd && getInitLCDecl(CE->getArg(1)) == LCDecl)\n        return setStep(CE->getArg(0), /*Subtract=*/false);\n    }\n  }\n  if (dependent() || SemaRef.CurContext->isDependentContext())\n    return false;\n  SemaRef.Diag(RHS->getBeginLoc(), diag::err_omp_loop_not_canonical_incr)\n      << RHS->getSourceRange() << LCDecl;\n  return true;\n}\n\nbool OpenMPIterationSpaceChecker::checkAndSetInc(Expr *S) {\n  // Check incr-expr for canonical loop form and return true if it\n  // does not conform.\n  // OpenMP [2.6] Canonical loop form. Test-expr may be one of the following:\n  //   ++var\n  //   var++\n  //   --var\n  //   var--\n  //   var += incr\n  //   var -= incr\n  //   var = var + incr\n  //   var = incr + var\n  //   var = var - incr\n  //\n  if (!S) {\n    SemaRef.Diag(DefaultLoc, diag::err_omp_loop_not_canonical_incr) << LCDecl;\n    return true;\n  }\n  if (auto *ExprTemp = dyn_cast<ExprWithCleanups>(S))\n    if (!ExprTemp->cleanupsHaveSideEffects())\n      S = ExprTemp->getSubExpr();\n\n  IncrementSrcRange = S->getSourceRange();\n  S = S->IgnoreParens();\n  if (auto *UO = dyn_cast<UnaryOperator>(S)) {\n    if (UO->isIncrementDecrementOp() &&\n        getInitLCDecl(UO->getSubExpr()) == LCDecl)\n      return setStep(SemaRef\n                         .ActOnIntegerConstant(UO->getBeginLoc(),\n                                               (UO->isDecrementOp() ? -1 : 1))\n                         .get(),\n                     /*Subtract=*/false);\n  } else if (auto *BO = dyn_cast<BinaryOperator>(S)) {\n    switch (BO->getOpcode()) {\n    case BO_AddAssign:\n    case BO_SubAssign:\n      if (getInitLCDecl(BO->getLHS()) == LCDecl)\n        return setStep(BO->getRHS(), BO->getOpcode() == BO_SubAssign);\n      break;\n    case BO_Assign:\n      if (getInitLCDecl(BO->getLHS()) == LCDecl)\n        return checkAndSetIncRHS(BO->getRHS());\n      break;\n    default:\n      break;\n    }\n  } else if (auto *CE = dyn_cast<CXXOperatorCallExpr>(S)) {\n    switch (CE->getOperator()) {\n    case OO_PlusPlus:\n    case OO_MinusMinus:\n      if (getInitLCDecl(CE->getArg(0)) == LCDecl)\n        return setStep(SemaRef\n                           .ActOnIntegerConstant(\n                               CE->getBeginLoc(),\n                               ((CE->getOperator() == OO_MinusMinus) ? -1 : 1))\n                           .get(),\n                       /*Subtract=*/false);\n      break;\n    case OO_PlusEqual:\n    case OO_MinusEqual:\n      if (getInitLCDecl(CE->getArg(0)) == LCDecl)\n        return setStep(CE->getArg(1), CE->getOperator() == OO_MinusEqual);\n      break;\n    case OO_Equal:\n      if (getInitLCDecl(CE->getArg(0)) == LCDecl)\n        return checkAndSetIncRHS(CE->getArg(1));\n      break;\n    default:\n      break;\n    }\n  }\n  if (dependent() || SemaRef.CurContext->isDependentContext())\n    return false;\n  SemaRef.Diag(S->getBeginLoc(), diag::err_omp_loop_not_canonical_incr)\n      << S->getSourceRange() << LCDecl;\n  return true;\n}\n\nstatic ExprResult\ntryBuildCapture(Sema &SemaRef, Expr *Capture,\n                llvm::MapVector<const Expr *, DeclRefExpr *> &Captures) {\n  if (SemaRef.CurContext->isDependentContext() || Capture->containsErrors())\n    return Capture;\n  if (Capture->isEvaluatable(SemaRef.Context, Expr::SE_AllowSideEffects))\n    return SemaRef.PerformImplicitConversion(\n        Capture->IgnoreImpCasts(), Capture->getType(), Sema::AA_Converting,\n        /*AllowExplicit=*/true);\n  auto I = Captures.find(Capture);\n  if (I != Captures.end())\n    return buildCapture(SemaRef, Capture, I->second);\n  DeclRefExpr *Ref = nullptr;\n  ExprResult Res = buildCapture(SemaRef, Capture, Ref);\n  Captures[Capture] = Ref;\n  return Res;\n}\n\n/// Calculate number of iterations, transforming to unsigned, if number of\n/// iterations may be larger than the original type.\nstatic Expr *\ncalculateNumIters(Sema &SemaRef, Scope *S, SourceLocation DefaultLoc,\n                  Expr *Lower, Expr *Upper, Expr *Step, QualType LCTy,\n                  bool TestIsStrictOp, bool RoundToStep,\n                  llvm::MapVector<const Expr *, DeclRefExpr *> &Captures) {\n  ExprResult NewStep = tryBuildCapture(SemaRef, Step, Captures);\n  if (!NewStep.isUsable())\n    return nullptr;\n  llvm::APSInt LRes, SRes;\n  bool IsLowerConst = false, IsStepConst = false;\n  if (Optional<llvm::APSInt> Res = Lower->getIntegerConstantExpr(SemaRef.Context)) {\n    LRes = *Res;\n    IsLowerConst = true;\n  }\n  if (Optional<llvm::APSInt> Res = Step->getIntegerConstantExpr(SemaRef.Context)) {\n    SRes = *Res;\n    IsStepConst = true;\n  }\n  bool NoNeedToConvert = IsLowerConst && !RoundToStep &&\n                         ((!TestIsStrictOp && LRes.isNonNegative()) ||\n                          (TestIsStrictOp && LRes.isStrictlyPositive()));\n  bool NeedToReorganize = false;\n  // Check if any subexpressions in Lower -Step [+ 1] lead to overflow.\n  if (!NoNeedToConvert && IsLowerConst &&\n      (TestIsStrictOp || (RoundToStep && IsStepConst))) {\n    NoNeedToConvert = true;\n    if (RoundToStep) {\n      unsigned BW = LRes.getBitWidth() > SRes.getBitWidth()\n                        ? LRes.getBitWidth()\n                        : SRes.getBitWidth();\n      LRes = LRes.extend(BW + 1);\n      LRes.setIsSigned(true);\n      SRes = SRes.extend(BW + 1);\n      SRes.setIsSigned(true);\n      LRes -= SRes;\n      NoNeedToConvert = LRes.trunc(BW).extend(BW + 1) == LRes;\n      LRes = LRes.trunc(BW);\n    }\n    if (TestIsStrictOp) {\n      unsigned BW = LRes.getBitWidth();\n      LRes = LRes.extend(BW + 1);\n      LRes.setIsSigned(true);\n      ++LRes;\n      NoNeedToConvert =\n          NoNeedToConvert && LRes.trunc(BW).extend(BW + 1) == LRes;\n      // truncate to the original bitwidth.\n      LRes = LRes.trunc(BW);\n    }\n    NeedToReorganize = NoNeedToConvert;\n  }\n  llvm::APSInt URes;\n  bool IsUpperConst = false;\n  if (Optional<llvm::APSInt> Res = Upper->getIntegerConstantExpr(SemaRef.Context)) {\n    URes = *Res;\n    IsUpperConst = true;\n  }\n  if (NoNeedToConvert && IsLowerConst && IsUpperConst &&\n      (!RoundToStep || IsStepConst)) {\n    unsigned BW = LRes.getBitWidth() > URes.getBitWidth() ? LRes.getBitWidth()\n                                                          : URes.getBitWidth();\n    LRes = LRes.extend(BW + 1);\n    LRes.setIsSigned(true);\n    URes = URes.extend(BW + 1);\n    URes.setIsSigned(true);\n    URes -= LRes;\n    NoNeedToConvert = URes.trunc(BW).extend(BW + 1) == URes;\n    NeedToReorganize = NoNeedToConvert;\n  }\n  // If the boundaries are not constant or (Lower - Step [+ 1]) is not constant\n  // or less than zero (Upper - (Lower - Step [+ 1]) may overflow) - promote to\n  // unsigned.\n  if ((!NoNeedToConvert || (LRes.isNegative() && !IsUpperConst)) &&\n      !LCTy->isDependentType() && LCTy->isIntegerType()) {\n    QualType LowerTy = Lower->getType();\n    QualType UpperTy = Upper->getType();\n    uint64_t LowerSize = SemaRef.Context.getTypeSize(LowerTy);\n    uint64_t UpperSize = SemaRef.Context.getTypeSize(UpperTy);\n    if ((LowerSize <= UpperSize && UpperTy->hasSignedIntegerRepresentation()) ||\n        (LowerSize > UpperSize && LowerTy->hasSignedIntegerRepresentation())) {\n      QualType CastType = SemaRef.Context.getIntTypeForBitwidth(\n          LowerSize > UpperSize ? LowerSize : UpperSize, /*Signed=*/0);\n      Upper =\n          SemaRef\n              .PerformImplicitConversion(\n                  SemaRef.ActOnParenExpr(DefaultLoc, DefaultLoc, Upper).get(),\n                  CastType, Sema::AA_Converting)\n              .get();\n      Lower = SemaRef.ActOnParenExpr(DefaultLoc, DefaultLoc, Lower).get();\n      NewStep = SemaRef.ActOnParenExpr(DefaultLoc, DefaultLoc, NewStep.get());\n    }\n  }\n  if (!Lower || !Upper || NewStep.isInvalid())\n    return nullptr;\n\n  ExprResult Diff;\n  // If need to reorganize, then calculate the form as Upper - (Lower - Step [+\n  // 1]).\n  if (NeedToReorganize) {\n    Diff = Lower;\n\n    if (RoundToStep) {\n      // Lower - Step\n      Diff =\n          SemaRef.BuildBinOp(S, DefaultLoc, BO_Sub, Diff.get(), NewStep.get());\n      if (!Diff.isUsable())\n        return nullptr;\n    }\n\n    // Lower - Step [+ 1]\n    if (TestIsStrictOp)\n      Diff = SemaRef.BuildBinOp(\n          S, DefaultLoc, BO_Add, Diff.get(),\n          SemaRef.ActOnIntegerConstant(SourceLocation(), 1).get());\n    if (!Diff.isUsable())\n      return nullptr;\n\n    Diff = SemaRef.ActOnParenExpr(DefaultLoc, DefaultLoc, Diff.get());\n    if (!Diff.isUsable())\n      return nullptr;\n\n    // Upper - (Lower - Step [+ 1]).\n    Diff = SemaRef.BuildBinOp(S, DefaultLoc, BO_Sub, Upper, Diff.get());\n    if (!Diff.isUsable())\n      return nullptr;\n  } else {\n    Diff = SemaRef.BuildBinOp(S, DefaultLoc, BO_Sub, Upper, Lower);\n\n    if (!Diff.isUsable() && LCTy->getAsCXXRecordDecl()) {\n      // BuildBinOp already emitted error, this one is to point user to upper\n      // and lower bound, and to tell what is passed to 'operator-'.\n      SemaRef.Diag(Upper->getBeginLoc(), diag::err_omp_loop_diff_cxx)\n          << Upper->getSourceRange() << Lower->getSourceRange();\n      return nullptr;\n    }\n\n    if (!Diff.isUsable())\n      return nullptr;\n\n    // Upper - Lower [- 1]\n    if (TestIsStrictOp)\n      Diff = SemaRef.BuildBinOp(\n          S, DefaultLoc, BO_Sub, Diff.get(),\n          SemaRef.ActOnIntegerConstant(SourceLocation(), 1).get());\n    if (!Diff.isUsable())\n      return nullptr;\n\n    if (RoundToStep) {\n      // Upper - Lower [- 1] + Step\n      Diff =\n          SemaRef.BuildBinOp(S, DefaultLoc, BO_Add, Diff.get(), NewStep.get());\n      if (!Diff.isUsable())\n        return nullptr;\n    }\n  }\n\n  // Parentheses (for dumping/debugging purposes only).\n  Diff = SemaRef.ActOnParenExpr(DefaultLoc, DefaultLoc, Diff.get());\n  if (!Diff.isUsable())\n    return nullptr;\n\n  // (Upper - Lower [- 1] + Step) / Step or (Upper - Lower) / Step\n  Diff = SemaRef.BuildBinOp(S, DefaultLoc, BO_Div, Diff.get(), NewStep.get());\n  if (!Diff.isUsable())\n    return nullptr;\n\n  return Diff.get();\n}\n\n/// Build the expression to calculate the number of iterations.\nExpr *OpenMPIterationSpaceChecker::buildNumIterations(\n    Scope *S, ArrayRef<LoopIterationSpace> ResultIterSpaces, bool LimitedType,\n    llvm::MapVector<const Expr *, DeclRefExpr *> &Captures) const {\n  QualType VarType = LCDecl->getType().getNonReferenceType();\n  if (!VarType->isIntegerType() && !VarType->isPointerType() &&\n      !SemaRef.getLangOpts().CPlusPlus)\n    return nullptr;\n  Expr *LBVal = LB;\n  Expr *UBVal = UB;\n  // LB = TestIsLessOp.getValue() ? min(LB(MinVal), LB(MaxVal)) :\n  // max(LB(MinVal), LB(MaxVal))\n  if (InitDependOnLC) {\n    const LoopIterationSpace &IS = ResultIterSpaces[*InitDependOnLC - 1];\n    if (!IS.MinValue || !IS.MaxValue)\n      return nullptr;\n    // OuterVar = Min\n    ExprResult MinValue =\n        SemaRef.ActOnParenExpr(DefaultLoc, DefaultLoc, IS.MinValue);\n    if (!MinValue.isUsable())\n      return nullptr;\n\n    ExprResult LBMinVal = SemaRef.BuildBinOp(S, DefaultLoc, BO_Assign,\n                                             IS.CounterVar, MinValue.get());\n    if (!LBMinVal.isUsable())\n      return nullptr;\n    // OuterVar = Min, LBVal\n    LBMinVal =\n        SemaRef.BuildBinOp(S, DefaultLoc, BO_Comma, LBMinVal.get(), LBVal);\n    if (!LBMinVal.isUsable())\n      return nullptr;\n    // (OuterVar = Min, LBVal)\n    LBMinVal = SemaRef.ActOnParenExpr(DefaultLoc, DefaultLoc, LBMinVal.get());\n    if (!LBMinVal.isUsable())\n      return nullptr;\n\n    // OuterVar = Max\n    ExprResult MaxValue =\n        SemaRef.ActOnParenExpr(DefaultLoc, DefaultLoc, IS.MaxValue);\n    if (!MaxValue.isUsable())\n      return nullptr;\n\n    ExprResult LBMaxVal = SemaRef.BuildBinOp(S, DefaultLoc, BO_Assign,\n                                             IS.CounterVar, MaxValue.get());\n    if (!LBMaxVal.isUsable())\n      return nullptr;\n    // OuterVar = Max, LBVal\n    LBMaxVal =\n        SemaRef.BuildBinOp(S, DefaultLoc, BO_Comma, LBMaxVal.get(), LBVal);\n    if (!LBMaxVal.isUsable())\n      return nullptr;\n    // (OuterVar = Max, LBVal)\n    LBMaxVal = SemaRef.ActOnParenExpr(DefaultLoc, DefaultLoc, LBMaxVal.get());\n    if (!LBMaxVal.isUsable())\n      return nullptr;\n\n    Expr *LBMin = tryBuildCapture(SemaRef, LBMinVal.get(), Captures).get();\n    Expr *LBMax = tryBuildCapture(SemaRef, LBMaxVal.get(), Captures).get();\n    if (!LBMin || !LBMax)\n      return nullptr;\n    // LB(MinVal) < LB(MaxVal)\n    ExprResult MinLessMaxRes =\n        SemaRef.BuildBinOp(S, DefaultLoc, BO_LT, LBMin, LBMax);\n    if (!MinLessMaxRes.isUsable())\n      return nullptr;\n    Expr *MinLessMax =\n        tryBuildCapture(SemaRef, MinLessMaxRes.get(), Captures).get();\n    if (!MinLessMax)\n      return nullptr;\n    if (TestIsLessOp.getValue()) {\n      // LB(MinVal) < LB(MaxVal) ? LB(MinVal) : LB(MaxVal) - min(LB(MinVal),\n      // LB(MaxVal))\n      ExprResult MinLB = SemaRef.ActOnConditionalOp(DefaultLoc, DefaultLoc,\n                                                    MinLessMax, LBMin, LBMax);\n      if (!MinLB.isUsable())\n        return nullptr;\n      LBVal = MinLB.get();\n    } else {\n      // LB(MinVal) < LB(MaxVal) ? LB(MaxVal) : LB(MinVal) - max(LB(MinVal),\n      // LB(MaxVal))\n      ExprResult MaxLB = SemaRef.ActOnConditionalOp(DefaultLoc, DefaultLoc,\n                                                    MinLessMax, LBMax, LBMin);\n      if (!MaxLB.isUsable())\n        return nullptr;\n      LBVal = MaxLB.get();\n    }\n  }\n  // UB = TestIsLessOp.getValue() ? max(UB(MinVal), UB(MaxVal)) :\n  // min(UB(MinVal), UB(MaxVal))\n  if (CondDependOnLC) {\n    const LoopIterationSpace &IS = ResultIterSpaces[*CondDependOnLC - 1];\n    if (!IS.MinValue || !IS.MaxValue)\n      return nullptr;\n    // OuterVar = Min\n    ExprResult MinValue =\n        SemaRef.ActOnParenExpr(DefaultLoc, DefaultLoc, IS.MinValue);\n    if (!MinValue.isUsable())\n      return nullptr;\n\n    ExprResult UBMinVal = SemaRef.BuildBinOp(S, DefaultLoc, BO_Assign,\n                                             IS.CounterVar, MinValue.get());\n    if (!UBMinVal.isUsable())\n      return nullptr;\n    // OuterVar = Min, UBVal\n    UBMinVal =\n        SemaRef.BuildBinOp(S, DefaultLoc, BO_Comma, UBMinVal.get(), UBVal);\n    if (!UBMinVal.isUsable())\n      return nullptr;\n    // (OuterVar = Min, UBVal)\n    UBMinVal = SemaRef.ActOnParenExpr(DefaultLoc, DefaultLoc, UBMinVal.get());\n    if (!UBMinVal.isUsable())\n      return nullptr;\n\n    // OuterVar = Max\n    ExprResult MaxValue =\n        SemaRef.ActOnParenExpr(DefaultLoc, DefaultLoc, IS.MaxValue);\n    if (!MaxValue.isUsable())\n      return nullptr;\n\n    ExprResult UBMaxVal = SemaRef.BuildBinOp(S, DefaultLoc, BO_Assign,\n                                             IS.CounterVar, MaxValue.get());\n    if (!UBMaxVal.isUsable())\n      return nullptr;\n    // OuterVar = Max, UBVal\n    UBMaxVal =\n        SemaRef.BuildBinOp(S, DefaultLoc, BO_Comma, UBMaxVal.get(), UBVal);\n    if (!UBMaxVal.isUsable())\n      return nullptr;\n    // (OuterVar = Max, UBVal)\n    UBMaxVal = SemaRef.ActOnParenExpr(DefaultLoc, DefaultLoc, UBMaxVal.get());\n    if (!UBMaxVal.isUsable())\n      return nullptr;\n\n    Expr *UBMin = tryBuildCapture(SemaRef, UBMinVal.get(), Captures).get();\n    Expr *UBMax = tryBuildCapture(SemaRef, UBMaxVal.get(), Captures).get();\n    if (!UBMin || !UBMax)\n      return nullptr;\n    // UB(MinVal) > UB(MaxVal)\n    ExprResult MinGreaterMaxRes =\n        SemaRef.BuildBinOp(S, DefaultLoc, BO_GT, UBMin, UBMax);\n    if (!MinGreaterMaxRes.isUsable())\n      return nullptr;\n    Expr *MinGreaterMax =\n        tryBuildCapture(SemaRef, MinGreaterMaxRes.get(), Captures).get();\n    if (!MinGreaterMax)\n      return nullptr;\n    if (TestIsLessOp.getValue()) {\n      // UB(MinVal) > UB(MaxVal) ? UB(MinVal) : UB(MaxVal) - max(UB(MinVal),\n      // UB(MaxVal))\n      ExprResult MaxUB = SemaRef.ActOnConditionalOp(\n          DefaultLoc, DefaultLoc, MinGreaterMax, UBMin, UBMax);\n      if (!MaxUB.isUsable())\n        return nullptr;\n      UBVal = MaxUB.get();\n    } else {\n      // UB(MinVal) > UB(MaxVal) ? UB(MaxVal) : UB(MinVal) - min(UB(MinVal),\n      // UB(MaxVal))\n      ExprResult MinUB = SemaRef.ActOnConditionalOp(\n          DefaultLoc, DefaultLoc, MinGreaterMax, UBMax, UBMin);\n      if (!MinUB.isUsable())\n        return nullptr;\n      UBVal = MinUB.get();\n    }\n  }\n  Expr *UBExpr = TestIsLessOp.getValue() ? UBVal : LBVal;\n  Expr *LBExpr = TestIsLessOp.getValue() ? LBVal : UBVal;\n  Expr *Upper = tryBuildCapture(SemaRef, UBExpr, Captures).get();\n  Expr *Lower = tryBuildCapture(SemaRef, LBExpr, Captures).get();\n  if (!Upper || !Lower)\n    return nullptr;\n\n  ExprResult Diff = calculateNumIters(SemaRef, S, DefaultLoc, Lower, Upper,\n                                      Step, VarType, TestIsStrictOp,\n                                      /*RoundToStep=*/true, Captures);\n  if (!Diff.isUsable())\n    return nullptr;\n\n  // OpenMP runtime requires 32-bit or 64-bit loop variables.\n  QualType Type = Diff.get()->getType();\n  ASTContext &C = SemaRef.Context;\n  bool UseVarType = VarType->hasIntegerRepresentation() &&\n                    C.getTypeSize(Type) > C.getTypeSize(VarType);\n  if (!Type->isIntegerType() || UseVarType) {\n    unsigned NewSize =\n        UseVarType ? C.getTypeSize(VarType) : C.getTypeSize(Type);\n    bool IsSigned = UseVarType ? VarType->hasSignedIntegerRepresentation()\n                               : Type->hasSignedIntegerRepresentation();\n    Type = C.getIntTypeForBitwidth(NewSize, IsSigned);\n    if (!SemaRef.Context.hasSameType(Diff.get()->getType(), Type)) {\n      Diff = SemaRef.PerformImplicitConversion(\n          Diff.get(), Type, Sema::AA_Converting, /*AllowExplicit=*/true);\n      if (!Diff.isUsable())\n        return nullptr;\n    }\n  }\n  if (LimitedType) {\n    unsigned NewSize = (C.getTypeSize(Type) > 32) ? 64 : 32;\n    if (NewSize != C.getTypeSize(Type)) {\n      if (NewSize < C.getTypeSize(Type)) {\n        assert(NewSize == 64 && \"incorrect loop var size\");\n        SemaRef.Diag(DefaultLoc, diag::warn_omp_loop_64_bit_var)\n            << InitSrcRange << ConditionSrcRange;\n      }\n      QualType NewType = C.getIntTypeForBitwidth(\n          NewSize, Type->hasSignedIntegerRepresentation() ||\n                       C.getTypeSize(Type) < NewSize);\n      if (!SemaRef.Context.hasSameType(Diff.get()->getType(), NewType)) {\n        Diff = SemaRef.PerformImplicitConversion(Diff.get(), NewType,\n                                                 Sema::AA_Converting, true);\n        if (!Diff.isUsable())\n          return nullptr;\n      }\n    }\n  }\n\n  return Diff.get();\n}\n\nstd::pair<Expr *, Expr *> OpenMPIterationSpaceChecker::buildMinMaxValues(\n    Scope *S, llvm::MapVector<const Expr *, DeclRefExpr *> &Captures) const {\n  // Do not build for iterators, they cannot be used in non-rectangular loop\n  // nests.\n  if (LCDecl->getType()->isRecordType())\n    return std::make_pair(nullptr, nullptr);\n  // If we subtract, the min is in the condition, otherwise the min is in the\n  // init value.\n  Expr *MinExpr = nullptr;\n  Expr *MaxExpr = nullptr;\n  Expr *LBExpr = TestIsLessOp.getValue() ? LB : UB;\n  Expr *UBExpr = TestIsLessOp.getValue() ? UB : LB;\n  bool LBNonRect = TestIsLessOp.getValue() ? InitDependOnLC.hasValue()\n                                           : CondDependOnLC.hasValue();\n  bool UBNonRect = TestIsLessOp.getValue() ? CondDependOnLC.hasValue()\n                                           : InitDependOnLC.hasValue();\n  Expr *Lower =\n      LBNonRect ? LBExpr : tryBuildCapture(SemaRef, LBExpr, Captures).get();\n  Expr *Upper =\n      UBNonRect ? UBExpr : tryBuildCapture(SemaRef, UBExpr, Captures).get();\n  if (!Upper || !Lower)\n    return std::make_pair(nullptr, nullptr);\n\n  if (TestIsLessOp.getValue())\n    MinExpr = Lower;\n  else\n    MaxExpr = Upper;\n\n  // Build minimum/maximum value based on number of iterations.\n  QualType VarType = LCDecl->getType().getNonReferenceType();\n\n  ExprResult Diff = calculateNumIters(SemaRef, S, DefaultLoc, Lower, Upper,\n                                      Step, VarType, TestIsStrictOp,\n                                      /*RoundToStep=*/false, Captures);\n  if (!Diff.isUsable())\n    return std::make_pair(nullptr, nullptr);\n\n  // ((Upper - Lower [- 1]) / Step) * Step\n  // Parentheses (for dumping/debugging purposes only).\n  Diff = SemaRef.ActOnParenExpr(DefaultLoc, DefaultLoc, Diff.get());\n  if (!Diff.isUsable())\n    return std::make_pair(nullptr, nullptr);\n\n  ExprResult NewStep = tryBuildCapture(SemaRef, Step, Captures);\n  if (!NewStep.isUsable())\n    return std::make_pair(nullptr, nullptr);\n  Diff = SemaRef.BuildBinOp(S, DefaultLoc, BO_Mul, Diff.get(), NewStep.get());\n  if (!Diff.isUsable())\n    return std::make_pair(nullptr, nullptr);\n\n  // Parentheses (for dumping/debugging purposes only).\n  Diff = SemaRef.ActOnParenExpr(DefaultLoc, DefaultLoc, Diff.get());\n  if (!Diff.isUsable())\n    return std::make_pair(nullptr, nullptr);\n\n  // Convert to the ptrdiff_t, if original type is pointer.\n  if (VarType->isAnyPointerType() &&\n      !SemaRef.Context.hasSameType(\n          Diff.get()->getType(),\n          SemaRef.Context.getUnsignedPointerDiffType())) {\n    Diff = SemaRef.PerformImplicitConversion(\n        Diff.get(), SemaRef.Context.getUnsignedPointerDiffType(),\n        Sema::AA_Converting, /*AllowExplicit=*/true);\n  }\n  if (!Diff.isUsable())\n    return std::make_pair(nullptr, nullptr);\n\n  if (TestIsLessOp.getValue()) {\n    // MinExpr = Lower;\n    // MaxExpr = Lower + (((Upper - Lower [- 1]) / Step) * Step)\n    Diff = SemaRef.BuildBinOp(\n        S, DefaultLoc, BO_Add,\n        SemaRef.ActOnParenExpr(DefaultLoc, DefaultLoc, Lower).get(),\n        Diff.get());\n    if (!Diff.isUsable())\n      return std::make_pair(nullptr, nullptr);\n  } else {\n    // MaxExpr = Upper;\n    // MinExpr = Upper - (((Upper - Lower [- 1]) / Step) * Step)\n    Diff = SemaRef.BuildBinOp(\n        S, DefaultLoc, BO_Sub,\n        SemaRef.ActOnParenExpr(DefaultLoc, DefaultLoc, Upper).get(),\n        Diff.get());\n    if (!Diff.isUsable())\n      return std::make_pair(nullptr, nullptr);\n  }\n\n  // Convert to the original type.\n  if (SemaRef.Context.hasSameType(Diff.get()->getType(), VarType))\n    Diff = SemaRef.PerformImplicitConversion(Diff.get(), VarType,\n                                             Sema::AA_Converting,\n                                             /*AllowExplicit=*/true);\n  if (!Diff.isUsable())\n    return std::make_pair(nullptr, nullptr);\n\n  Sema::TentativeAnalysisScope Trap(SemaRef);\n  Diff = SemaRef.ActOnFinishFullExpr(Diff.get(), /*DiscardedValue=*/false);\n  if (!Diff.isUsable())\n    return std::make_pair(nullptr, nullptr);\n\n  if (TestIsLessOp.getValue())\n    MaxExpr = Diff.get();\n  else\n    MinExpr = Diff.get();\n\n  return std::make_pair(MinExpr, MaxExpr);\n}\n\nExpr *OpenMPIterationSpaceChecker::buildFinalCondition(Scope *S) const {\n  if (InitDependOnLC || CondDependOnLC)\n    return Condition;\n  return nullptr;\n}\n\nExpr *OpenMPIterationSpaceChecker::buildPreCond(\n    Scope *S, Expr *Cond,\n    llvm::MapVector<const Expr *, DeclRefExpr *> &Captures) const {\n  // Do not build a precondition when the condition/initialization is dependent\n  // to prevent pessimistic early loop exit.\n  // TODO: this can be improved by calculating min/max values but not sure that\n  // it will be very effective.\n  if (CondDependOnLC || InitDependOnLC)\n    return SemaRef.PerformImplicitConversion(\n        SemaRef.ActOnIntegerConstant(SourceLocation(), 1).get(),\n        SemaRef.Context.BoolTy, /*Action=*/Sema::AA_Casting,\n        /*AllowExplicit=*/true).get();\n\n  // Try to build LB <op> UB, where <op> is <, >, <=, or >=.\n  Sema::TentativeAnalysisScope Trap(SemaRef);\n\n  ExprResult NewLB = tryBuildCapture(SemaRef, LB, Captures);\n  ExprResult NewUB = tryBuildCapture(SemaRef, UB, Captures);\n  if (!NewLB.isUsable() || !NewUB.isUsable())\n    return nullptr;\n\n  ExprResult CondExpr =\n      SemaRef.BuildBinOp(S, DefaultLoc,\n                         TestIsLessOp.getValue() ?\n                           (TestIsStrictOp ? BO_LT : BO_LE) :\n                           (TestIsStrictOp ? BO_GT : BO_GE),\n                         NewLB.get(), NewUB.get());\n  if (CondExpr.isUsable()) {\n    if (!SemaRef.Context.hasSameUnqualifiedType(CondExpr.get()->getType(),\n                                                SemaRef.Context.BoolTy))\n      CondExpr = SemaRef.PerformImplicitConversion(\n          CondExpr.get(), SemaRef.Context.BoolTy, /*Action=*/Sema::AA_Casting,\n          /*AllowExplicit=*/true);\n  }\n\n  // Otherwise use original loop condition and evaluate it in runtime.\n  return CondExpr.isUsable() ? CondExpr.get() : Cond;\n}\n\n/// Build reference expression to the counter be used for codegen.\nDeclRefExpr *OpenMPIterationSpaceChecker::buildCounterVar(\n    llvm::MapVector<const Expr *, DeclRefExpr *> &Captures,\n    DSAStackTy &DSA) const {\n  auto *VD = dyn_cast<VarDecl>(LCDecl);\n  if (!VD) {\n    VD = SemaRef.isOpenMPCapturedDecl(LCDecl);\n    DeclRefExpr *Ref = buildDeclRefExpr(\n        SemaRef, VD, VD->getType().getNonReferenceType(), DefaultLoc);\n    const DSAStackTy::DSAVarData Data =\n        DSA.getTopDSA(LCDecl, /*FromParent=*/false);\n    // If the loop control decl is explicitly marked as private, do not mark it\n    // as captured again.\n    if (!isOpenMPPrivate(Data.CKind) || !Data.RefExpr)\n      Captures.insert(std::make_pair(LCRef, Ref));\n    return Ref;\n  }\n  return cast<DeclRefExpr>(LCRef);\n}\n\nExpr *OpenMPIterationSpaceChecker::buildPrivateCounterVar() const {\n  if (LCDecl && !LCDecl->isInvalidDecl()) {\n    QualType Type = LCDecl->getType().getNonReferenceType();\n    VarDecl *PrivateVar = buildVarDecl(\n        SemaRef, DefaultLoc, Type, LCDecl->getName(),\n        LCDecl->hasAttrs() ? &LCDecl->getAttrs() : nullptr,\n        isa<VarDecl>(LCDecl)\n            ? buildDeclRefExpr(SemaRef, cast<VarDecl>(LCDecl), Type, DefaultLoc)\n            : nullptr);\n    if (PrivateVar->isInvalidDecl())\n      return nullptr;\n    return buildDeclRefExpr(SemaRef, PrivateVar, Type, DefaultLoc);\n  }\n  return nullptr;\n}\n\n/// Build initialization of the counter to be used for codegen.\nExpr *OpenMPIterationSpaceChecker::buildCounterInit() const { return LB; }\n\n/// Build step of the counter be used for codegen.\nExpr *OpenMPIterationSpaceChecker::buildCounterStep() const { return Step; }\n\nExpr *OpenMPIterationSpaceChecker::buildOrderedLoopData(\n    Scope *S, Expr *Counter,\n    llvm::MapVector<const Expr *, DeclRefExpr *> &Captures, SourceLocation Loc,\n    Expr *Inc, OverloadedOperatorKind OOK) {\n  Expr *Cnt = SemaRef.DefaultLvalueConversion(Counter).get();\n  if (!Cnt)\n    return nullptr;\n  if (Inc) {\n    assert((OOK == OO_Plus || OOK == OO_Minus) &&\n           \"Expected only + or - operations for depend clauses.\");\n    BinaryOperatorKind BOK = (OOK == OO_Plus) ? BO_Add : BO_Sub;\n    Cnt = SemaRef.BuildBinOp(S, Loc, BOK, Cnt, Inc).get();\n    if (!Cnt)\n      return nullptr;\n  }\n  QualType VarType = LCDecl->getType().getNonReferenceType();\n  if (!VarType->isIntegerType() && !VarType->isPointerType() &&\n      !SemaRef.getLangOpts().CPlusPlus)\n    return nullptr;\n  // Upper - Lower\n  Expr *Upper = TestIsLessOp.getValue()\n                    ? Cnt\n                    : tryBuildCapture(SemaRef, LB, Captures).get();\n  Expr *Lower = TestIsLessOp.getValue()\n                    ? tryBuildCapture(SemaRef, LB, Captures).get()\n                    : Cnt;\n  if (!Upper || !Lower)\n    return nullptr;\n\n  ExprResult Diff = calculateNumIters(\n      SemaRef, S, DefaultLoc, Lower, Upper, Step, VarType,\n      /*TestIsStrictOp=*/false, /*RoundToStep=*/false, Captures);\n  if (!Diff.isUsable())\n    return nullptr;\n\n  return Diff.get();\n}\n} // namespace\n\nvoid Sema::ActOnOpenMPLoopInitialization(SourceLocation ForLoc, Stmt *Init) {\n  assert(getLangOpts().OpenMP && \"OpenMP is not active.\");\n  assert(Init && \"Expected loop in canonical form.\");\n  unsigned AssociatedLoops = DSAStack->getAssociatedLoops();\n  if (AssociatedLoops > 0 &&\n      isOpenMPLoopDirective(DSAStack->getCurrentDirective())) {\n    DSAStack->loopStart();\n    OpenMPIterationSpaceChecker ISC(*this, /*SupportsNonRectangular=*/true,\n                                    *DSAStack, ForLoc);\n    if (!ISC.checkAndSetInit(Init, /*EmitDiags=*/false)) {\n      if (ValueDecl *D = ISC.getLoopDecl()) {\n        auto *VD = dyn_cast<VarDecl>(D);\n        DeclRefExpr *PrivateRef = nullptr;\n        if (!VD) {\n          if (VarDecl *Private = isOpenMPCapturedDecl(D)) {\n            VD = Private;\n          } else {\n            PrivateRef = buildCapture(*this, D, ISC.getLoopDeclRefExpr(),\n                                      /*WithInit=*/false);\n            VD = cast<VarDecl>(PrivateRef->getDecl());\n          }\n        }\n        DSAStack->addLoopControlVariable(D, VD);\n        const Decl *LD = DSAStack->getPossiblyLoopCunter();\n        if (LD != D->getCanonicalDecl()) {\n          DSAStack->resetPossibleLoopCounter();\n          if (auto *Var = dyn_cast_or_null<VarDecl>(LD))\n            MarkDeclarationsReferencedInExpr(\n                buildDeclRefExpr(*this, const_cast<VarDecl *>(Var),\n                                 Var->getType().getNonLValueExprType(Context),\n                                 ForLoc, /*RefersToCapture=*/true));\n        }\n        OpenMPDirectiveKind DKind = DSAStack->getCurrentDirective();\n        // OpenMP [2.14.1.1, Data-sharing Attribute Rules for Variables\n        // Referenced in a Construct, C/C++]. The loop iteration variable in the\n        // associated for-loop of a simd construct with just one associated\n        // for-loop may be listed in a linear clause with a constant-linear-step\n        // that is the increment of the associated for-loop. The loop iteration\n        // variable(s) in the associated for-loop(s) of a for or parallel for\n        // construct may be listed in a private or lastprivate clause.\n        DSAStackTy::DSAVarData DVar =\n            DSAStack->getTopDSA(D, /*FromParent=*/false);\n        // If LoopVarRefExpr is nullptr it means the corresponding loop variable\n        // is declared in the loop and it is predetermined as a private.\n        Expr *LoopDeclRefExpr = ISC.getLoopDeclRefExpr();\n        OpenMPClauseKind PredeterminedCKind =\n            isOpenMPSimdDirective(DKind)\n                ? (DSAStack->hasMutipleLoops() ? OMPC_lastprivate : OMPC_linear)\n                : OMPC_private;\n        if (((isOpenMPSimdDirective(DKind) && DVar.CKind != OMPC_unknown &&\n              DVar.CKind != PredeterminedCKind && DVar.RefExpr &&\n              (LangOpts.OpenMP <= 45 || (DVar.CKind != OMPC_lastprivate &&\n                                         DVar.CKind != OMPC_private))) ||\n             ((isOpenMPWorksharingDirective(DKind) || DKind == OMPD_taskloop ||\n               DKind == OMPD_master_taskloop ||\n               DKind == OMPD_parallel_master_taskloop ||\n               isOpenMPDistributeDirective(DKind)) &&\n              !isOpenMPSimdDirective(DKind) && DVar.CKind != OMPC_unknown &&\n              DVar.CKind != OMPC_private && DVar.CKind != OMPC_lastprivate)) &&\n            (DVar.CKind != OMPC_private || DVar.RefExpr)) {\n          Diag(Init->getBeginLoc(), diag::err_omp_loop_var_dsa)\n              << getOpenMPClauseName(DVar.CKind)\n              << getOpenMPDirectiveName(DKind)\n              << getOpenMPClauseName(PredeterminedCKind);\n          if (DVar.RefExpr == nullptr)\n            DVar.CKind = PredeterminedCKind;\n          reportOriginalDsa(*this, DSAStack, D, DVar,\n                            /*IsLoopIterVar=*/true);\n        } else if (LoopDeclRefExpr) {\n          // Make the loop iteration variable private (for worksharing\n          // constructs), linear (for simd directives with the only one\n          // associated loop) or lastprivate (for simd directives with several\n          // collapsed or ordered loops).\n          if (DVar.CKind == OMPC_unknown)\n            DSAStack->addDSA(D, LoopDeclRefExpr, PredeterminedCKind,\n                             PrivateRef);\n        }\n      }\n    }\n    DSAStack->setAssociatedLoops(AssociatedLoops - 1);\n  }\n}\n\n/// Called on a for stmt to check and extract its iteration space\n/// for further processing (such as collapsing).\nstatic bool checkOpenMPIterationSpace(\n    OpenMPDirectiveKind DKind, Stmt *S, Sema &SemaRef, DSAStackTy &DSA,\n    unsigned CurrentNestedLoopCount, unsigned NestedLoopCount,\n    unsigned TotalNestedLoopCount, Expr *CollapseLoopCountExpr,\n    Expr *OrderedLoopCountExpr,\n    Sema::VarsWithInheritedDSAType &VarsWithImplicitDSA,\n    llvm::MutableArrayRef<LoopIterationSpace> ResultIterSpaces,\n    llvm::MapVector<const Expr *, DeclRefExpr *> &Captures) {\n  bool SupportsNonRectangular = !isOpenMPLoopTransformationDirective(DKind);\n  // OpenMP [2.9.1, Canonical Loop Form]\n  //   for (init-expr; test-expr; incr-expr) structured-block\n  //   for (range-decl: range-expr) structured-block\n  auto *For = dyn_cast_or_null<ForStmt>(S);\n  auto *CXXFor = dyn_cast_or_null<CXXForRangeStmt>(S);\n  // Ranged for is supported only in OpenMP 5.0.\n  if (!For && (SemaRef.LangOpts.OpenMP <= 45 || !CXXFor)) {\n    SemaRef.Diag(S->getBeginLoc(), diag::err_omp_not_for)\n        << (CollapseLoopCountExpr != nullptr || OrderedLoopCountExpr != nullptr)\n        << getOpenMPDirectiveName(DKind) << TotalNestedLoopCount\n        << (CurrentNestedLoopCount > 0) << CurrentNestedLoopCount;\n    if (TotalNestedLoopCount > 1) {\n      if (CollapseLoopCountExpr && OrderedLoopCountExpr)\n        SemaRef.Diag(DSA.getConstructLoc(),\n                     diag::note_omp_collapse_ordered_expr)\n            << 2 << CollapseLoopCountExpr->getSourceRange()\n            << OrderedLoopCountExpr->getSourceRange();\n      else if (CollapseLoopCountExpr)\n        SemaRef.Diag(CollapseLoopCountExpr->getExprLoc(),\n                     diag::note_omp_collapse_ordered_expr)\n            << 0 << CollapseLoopCountExpr->getSourceRange();\n      else\n        SemaRef.Diag(OrderedLoopCountExpr->getExprLoc(),\n                     diag::note_omp_collapse_ordered_expr)\n            << 1 << OrderedLoopCountExpr->getSourceRange();\n    }\n    return true;\n  }\n  assert(((For && For->getBody()) || (CXXFor && CXXFor->getBody())) &&\n         \"No loop body.\");\n\n  OpenMPIterationSpaceChecker ISC(SemaRef, SupportsNonRectangular, DSA,\n                                  For ? For->getForLoc() : CXXFor->getForLoc());\n\n  // Check init.\n  Stmt *Init = For ? For->getInit() : CXXFor->getBeginStmt();\n  if (ISC.checkAndSetInit(Init))\n    return true;\n\n  bool HasErrors = false;\n\n  // Check loop variable's type.\n  if (ValueDecl *LCDecl = ISC.getLoopDecl()) {\n    // OpenMP [2.6, Canonical Loop Form]\n    // Var is one of the following:\n    //   A variable of signed or unsigned integer type.\n    //   For C++, a variable of a random access iterator type.\n    //   For C, a variable of a pointer type.\n    QualType VarType = LCDecl->getType().getNonReferenceType();\n    if (!VarType->isDependentType() && !VarType->isIntegerType() &&\n        !VarType->isPointerType() &&\n        !(SemaRef.getLangOpts().CPlusPlus && VarType->isOverloadableType())) {\n      SemaRef.Diag(Init->getBeginLoc(), diag::err_omp_loop_variable_type)\n          << SemaRef.getLangOpts().CPlusPlus;\n      HasErrors = true;\n    }\n\n    // OpenMP, 2.14.1.1 Data-sharing Attribute Rules for Variables Referenced in\n    // a Construct\n    // The loop iteration variable(s) in the associated for-loop(s) of a for or\n    // parallel for construct is (are) private.\n    // The loop iteration variable in the associated for-loop of a simd\n    // construct with just one associated for-loop is linear with a\n    // constant-linear-step that is the increment of the associated for-loop.\n    // Exclude loop var from the list of variables with implicitly defined data\n    // sharing attributes.\n    VarsWithImplicitDSA.erase(LCDecl);\n\n    assert(isOpenMPLoopDirective(DKind) && \"DSA for non-loop vars\");\n\n    // Check test-expr.\n    HasErrors |= ISC.checkAndSetCond(For ? For->getCond() : CXXFor->getCond());\n\n    // Check incr-expr.\n    HasErrors |= ISC.checkAndSetInc(For ? For->getInc() : CXXFor->getInc());\n  }\n\n  if (ISC.dependent() || SemaRef.CurContext->isDependentContext() || HasErrors)\n    return HasErrors;\n\n  // Build the loop's iteration space representation.\n  ResultIterSpaces[CurrentNestedLoopCount].PreCond = ISC.buildPreCond(\n      DSA.getCurScope(), For ? For->getCond() : CXXFor->getCond(), Captures);\n  ResultIterSpaces[CurrentNestedLoopCount].NumIterations =\n      ISC.buildNumIterations(DSA.getCurScope(), ResultIterSpaces,\n                             (isOpenMPWorksharingDirective(DKind) ||\n                              isOpenMPTaskLoopDirective(DKind) ||\n                              isOpenMPDistributeDirective(DKind) ||\n                              isOpenMPLoopTransformationDirective(DKind)),\n                             Captures);\n  ResultIterSpaces[CurrentNestedLoopCount].CounterVar =\n      ISC.buildCounterVar(Captures, DSA);\n  ResultIterSpaces[CurrentNestedLoopCount].PrivateCounterVar =\n      ISC.buildPrivateCounterVar();\n  ResultIterSpaces[CurrentNestedLoopCount].CounterInit = ISC.buildCounterInit();\n  ResultIterSpaces[CurrentNestedLoopCount].CounterStep = ISC.buildCounterStep();\n  ResultIterSpaces[CurrentNestedLoopCount].InitSrcRange = ISC.getInitSrcRange();\n  ResultIterSpaces[CurrentNestedLoopCount].CondSrcRange =\n      ISC.getConditionSrcRange();\n  ResultIterSpaces[CurrentNestedLoopCount].IncSrcRange =\n      ISC.getIncrementSrcRange();\n  ResultIterSpaces[CurrentNestedLoopCount].Subtract = ISC.shouldSubtractStep();\n  ResultIterSpaces[CurrentNestedLoopCount].IsStrictCompare =\n      ISC.isStrictTestOp();\n  std::tie(ResultIterSpaces[CurrentNestedLoopCount].MinValue,\n           ResultIterSpaces[CurrentNestedLoopCount].MaxValue) =\n      ISC.buildMinMaxValues(DSA.getCurScope(), Captures);\n  ResultIterSpaces[CurrentNestedLoopCount].FinalCondition =\n      ISC.buildFinalCondition(DSA.getCurScope());\n  ResultIterSpaces[CurrentNestedLoopCount].IsNonRectangularLB =\n      ISC.doesInitDependOnLC();\n  ResultIterSpaces[CurrentNestedLoopCount].IsNonRectangularUB =\n      ISC.doesCondDependOnLC();\n  ResultIterSpaces[CurrentNestedLoopCount].LoopDependentIdx =\n      ISC.getLoopDependentIdx();\n\n  HasErrors |=\n      (ResultIterSpaces[CurrentNestedLoopCount].PreCond == nullptr ||\n       ResultIterSpaces[CurrentNestedLoopCount].NumIterations == nullptr ||\n       ResultIterSpaces[CurrentNestedLoopCount].CounterVar == nullptr ||\n       ResultIterSpaces[CurrentNestedLoopCount].PrivateCounterVar == nullptr ||\n       ResultIterSpaces[CurrentNestedLoopCount].CounterInit == nullptr ||\n       ResultIterSpaces[CurrentNestedLoopCount].CounterStep == nullptr);\n  if (!HasErrors && DSA.isOrderedRegion()) {\n    if (DSA.getOrderedRegionParam().second->getNumForLoops()) {\n      if (CurrentNestedLoopCount <\n          DSA.getOrderedRegionParam().second->getLoopNumIterations().size()) {\n        DSA.getOrderedRegionParam().second->setLoopNumIterations(\n            CurrentNestedLoopCount,\n            ResultIterSpaces[CurrentNestedLoopCount].NumIterations);\n        DSA.getOrderedRegionParam().second->setLoopCounter(\n            CurrentNestedLoopCount,\n            ResultIterSpaces[CurrentNestedLoopCount].CounterVar);\n      }\n    }\n    for (auto &Pair : DSA.getDoacrossDependClauses()) {\n      if (CurrentNestedLoopCount >= Pair.first->getNumLoops()) {\n        // Erroneous case - clause has some problems.\n        continue;\n      }\n      if (Pair.first->getDependencyKind() == OMPC_DEPEND_sink &&\n          Pair.second.size() <= CurrentNestedLoopCount) {\n        // Erroneous case - clause has some problems.\n        Pair.first->setLoopData(CurrentNestedLoopCount, nullptr);\n        continue;\n      }\n      Expr *CntValue;\n      if (Pair.first->getDependencyKind() == OMPC_DEPEND_source)\n        CntValue = ISC.buildOrderedLoopData(\n            DSA.getCurScope(),\n            ResultIterSpaces[CurrentNestedLoopCount].CounterVar, Captures,\n            Pair.first->getDependencyLoc());\n      else\n        CntValue = ISC.buildOrderedLoopData(\n            DSA.getCurScope(),\n            ResultIterSpaces[CurrentNestedLoopCount].CounterVar, Captures,\n            Pair.first->getDependencyLoc(),\n            Pair.second[CurrentNestedLoopCount].first,\n            Pair.second[CurrentNestedLoopCount].second);\n      Pair.first->setLoopData(CurrentNestedLoopCount, CntValue);\n    }\n  }\n\n  return HasErrors;\n}\n\n/// Build 'VarRef = Start.\nstatic ExprResult\nbuildCounterInit(Sema &SemaRef, Scope *S, SourceLocation Loc, ExprResult VarRef,\n                 ExprResult Start, bool IsNonRectangularLB,\n                 llvm::MapVector<const Expr *, DeclRefExpr *> &Captures) {\n  // Build 'VarRef = Start.\n  ExprResult NewStart = IsNonRectangularLB\n                            ? Start.get()\n                            : tryBuildCapture(SemaRef, Start.get(), Captures);\n  if (!NewStart.isUsable())\n    return ExprError();\n  if (!SemaRef.Context.hasSameType(NewStart.get()->getType(),\n                                   VarRef.get()->getType())) {\n    NewStart = SemaRef.PerformImplicitConversion(\n        NewStart.get(), VarRef.get()->getType(), Sema::AA_Converting,\n        /*AllowExplicit=*/true);\n    if (!NewStart.isUsable())\n      return ExprError();\n  }\n\n  ExprResult Init =\n      SemaRef.BuildBinOp(S, Loc, BO_Assign, VarRef.get(), NewStart.get());\n  return Init;\n}\n\n/// Build 'VarRef = Start + Iter * Step'.\nstatic ExprResult buildCounterUpdate(\n    Sema &SemaRef, Scope *S, SourceLocation Loc, ExprResult VarRef,\n    ExprResult Start, ExprResult Iter, ExprResult Step, bool Subtract,\n    bool IsNonRectangularLB,\n    llvm::MapVector<const Expr *, DeclRefExpr *> *Captures = nullptr) {\n  // Add parentheses (for debugging purposes only).\n  Iter = SemaRef.ActOnParenExpr(Loc, Loc, Iter.get());\n  if (!VarRef.isUsable() || !Start.isUsable() || !Iter.isUsable() ||\n      !Step.isUsable())\n    return ExprError();\n\n  ExprResult NewStep = Step;\n  if (Captures)\n    NewStep = tryBuildCapture(SemaRef, Step.get(), *Captures);\n  if (NewStep.isInvalid())\n    return ExprError();\n  ExprResult Update =\n      SemaRef.BuildBinOp(S, Loc, BO_Mul, Iter.get(), NewStep.get());\n  if (!Update.isUsable())\n    return ExprError();\n\n  // Try to build 'VarRef = Start, VarRef (+|-)= Iter * Step' or\n  // 'VarRef = Start (+|-) Iter * Step'.\n  if (!Start.isUsable())\n    return ExprError();\n  ExprResult NewStart = SemaRef.ActOnParenExpr(Loc, Loc, Start.get());\n  if (!NewStart.isUsable())\n    return ExprError();\n  if (Captures && !IsNonRectangularLB)\n    NewStart = tryBuildCapture(SemaRef, Start.get(), *Captures);\n  if (NewStart.isInvalid())\n    return ExprError();\n\n  // First attempt: try to build 'VarRef = Start, VarRef += Iter * Step'.\n  ExprResult SavedUpdate = Update;\n  ExprResult UpdateVal;\n  if (VarRef.get()->getType()->isOverloadableType() ||\n      NewStart.get()->getType()->isOverloadableType() ||\n      Update.get()->getType()->isOverloadableType()) {\n    Sema::TentativeAnalysisScope Trap(SemaRef);\n\n    Update =\n        SemaRef.BuildBinOp(S, Loc, BO_Assign, VarRef.get(), NewStart.get());\n    if (Update.isUsable()) {\n      UpdateVal =\n          SemaRef.BuildBinOp(S, Loc, Subtract ? BO_SubAssign : BO_AddAssign,\n                             VarRef.get(), SavedUpdate.get());\n      if (UpdateVal.isUsable()) {\n        Update = SemaRef.CreateBuiltinBinOp(Loc, BO_Comma, Update.get(),\n                                            UpdateVal.get());\n      }\n    }\n  }\n\n  // Second attempt: try to build 'VarRef = Start (+|-) Iter * Step'.\n  if (!Update.isUsable() || !UpdateVal.isUsable()) {\n    Update = SemaRef.BuildBinOp(S, Loc, Subtract ? BO_Sub : BO_Add,\n                                NewStart.get(), SavedUpdate.get());\n    if (!Update.isUsable())\n      return ExprError();\n\n    if (!SemaRef.Context.hasSameType(Update.get()->getType(),\n                                     VarRef.get()->getType())) {\n      Update = SemaRef.PerformImplicitConversion(\n          Update.get(), VarRef.get()->getType(), Sema::AA_Converting, true);\n      if (!Update.isUsable())\n        return ExprError();\n    }\n\n    Update = SemaRef.BuildBinOp(S, Loc, BO_Assign, VarRef.get(), Update.get());\n  }\n  return Update;\n}\n\n/// Convert integer expression \\a E to make it have at least \\a Bits\n/// bits.\nstatic ExprResult widenIterationCount(unsigned Bits, Expr *E, Sema &SemaRef) {\n  if (E == nullptr)\n    return ExprError();\n  ASTContext &C = SemaRef.Context;\n  QualType OldType = E->getType();\n  unsigned HasBits = C.getTypeSize(OldType);\n  if (HasBits >= Bits)\n    return ExprResult(E);\n  // OK to convert to signed, because new type has more bits than old.\n  QualType NewType = C.getIntTypeForBitwidth(Bits, /* Signed */ true);\n  return SemaRef.PerformImplicitConversion(E, NewType, Sema::AA_Converting,\n                                           true);\n}\n\n/// Check if the given expression \\a E is a constant integer that fits\n/// into \\a Bits bits.\nstatic bool fitsInto(unsigned Bits, bool Signed, const Expr *E, Sema &SemaRef) {\n  if (E == nullptr)\n    return false;\n  if (Optional<llvm::APSInt> Result =\n          E->getIntegerConstantExpr(SemaRef.Context))\n    return Signed ? Result->isSignedIntN(Bits) : Result->isIntN(Bits);\n  return false;\n}\n\n/// Build preinits statement for the given declarations.\nstatic Stmt *buildPreInits(ASTContext &Context,\n                           MutableArrayRef<Decl *> PreInits) {\n  if (!PreInits.empty()) {\n    return new (Context) DeclStmt(\n        DeclGroupRef::Create(Context, PreInits.begin(), PreInits.size()),\n        SourceLocation(), SourceLocation());\n  }\n  return nullptr;\n}\n\n/// Build preinits statement for the given declarations.\nstatic Stmt *\nbuildPreInits(ASTContext &Context,\n              const llvm::MapVector<const Expr *, DeclRefExpr *> &Captures) {\n  if (!Captures.empty()) {\n    SmallVector<Decl *, 16> PreInits;\n    for (const auto &Pair : Captures)\n      PreInits.push_back(Pair.second->getDecl());\n    return buildPreInits(Context, PreInits);\n  }\n  return nullptr;\n}\n\n/// Build postupdate expression for the given list of postupdates expressions.\nstatic Expr *buildPostUpdate(Sema &S, ArrayRef<Expr *> PostUpdates) {\n  Expr *PostUpdate = nullptr;\n  if (!PostUpdates.empty()) {\n    for (Expr *E : PostUpdates) {\n      Expr *ConvE = S.BuildCStyleCastExpr(\n                         E->getExprLoc(),\n                         S.Context.getTrivialTypeSourceInfo(S.Context.VoidTy),\n                         E->getExprLoc(), E)\n                        .get();\n      PostUpdate = PostUpdate\n                       ? S.CreateBuiltinBinOp(ConvE->getExprLoc(), BO_Comma,\n                                              PostUpdate, ConvE)\n                             .get()\n                       : ConvE;\n    }\n  }\n  return PostUpdate;\n}\n\n/// Called on a for stmt to check itself and nested loops (if any).\n/// \\return Returns 0 if one of the collapsed stmts is not canonical for loop,\n/// number of collapsed loops otherwise.\nstatic unsigned\ncheckOpenMPLoop(OpenMPDirectiveKind DKind, Expr *CollapseLoopCountExpr,\n                Expr *OrderedLoopCountExpr, Stmt *AStmt, Sema &SemaRef,\n                DSAStackTy &DSA,\n                Sema::VarsWithInheritedDSAType &VarsWithImplicitDSA,\n                OMPLoopBasedDirective::HelperExprs &Built) {\n  unsigned NestedLoopCount = 1;\n  bool SupportsNonPerfectlyNested = (SemaRef.LangOpts.OpenMP >= 50) &&\n                                    !isOpenMPLoopTransformationDirective(DKind);\n\n  if (CollapseLoopCountExpr) {\n    // Found 'collapse' clause - calculate collapse number.\n    Expr::EvalResult Result;\n    if (!CollapseLoopCountExpr->isValueDependent() &&\n        CollapseLoopCountExpr->EvaluateAsInt(Result, SemaRef.getASTContext())) {\n      NestedLoopCount = Result.Val.getInt().getLimitedValue();\n    } else {\n      Built.clear(/*Size=*/1);\n      return 1;\n    }\n  }\n  unsigned OrderedLoopCount = 1;\n  if (OrderedLoopCountExpr) {\n    // Found 'ordered' clause - calculate collapse number.\n    Expr::EvalResult EVResult;\n    if (!OrderedLoopCountExpr->isValueDependent() &&\n        OrderedLoopCountExpr->EvaluateAsInt(EVResult,\n                                            SemaRef.getASTContext())) {\n      llvm::APSInt Result = EVResult.Val.getInt();\n      if (Result.getLimitedValue() < NestedLoopCount) {\n        SemaRef.Diag(OrderedLoopCountExpr->getExprLoc(),\n                     diag::err_omp_wrong_ordered_loop_count)\n            << OrderedLoopCountExpr->getSourceRange();\n        SemaRef.Diag(CollapseLoopCountExpr->getExprLoc(),\n                     diag::note_collapse_loop_count)\n            << CollapseLoopCountExpr->getSourceRange();\n      }\n      OrderedLoopCount = Result.getLimitedValue();\n    } else {\n      Built.clear(/*Size=*/1);\n      return 1;\n    }\n  }\n  // This is helper routine for loop directives (e.g., 'for', 'simd',\n  // 'for simd', etc.).\n  llvm::MapVector<const Expr *, DeclRefExpr *> Captures;\n  unsigned NumLoops = std::max(OrderedLoopCount, NestedLoopCount);\n  SmallVector<LoopIterationSpace, 4> IterSpaces(NumLoops);\n  if (!OMPLoopBasedDirective::doForAllLoops(\n          AStmt->IgnoreContainers(!isOpenMPLoopTransformationDirective(DKind)),\n          SupportsNonPerfectlyNested, NumLoops,\n          [DKind, &SemaRef, &DSA, NumLoops, NestedLoopCount,\n           CollapseLoopCountExpr, OrderedLoopCountExpr, &VarsWithImplicitDSA,\n           &IterSpaces, &Captures](unsigned Cnt, Stmt *CurStmt) {\n            if (checkOpenMPIterationSpace(\n                    DKind, CurStmt, SemaRef, DSA, Cnt, NestedLoopCount,\n                    NumLoops, CollapseLoopCountExpr, OrderedLoopCountExpr,\n                    VarsWithImplicitDSA, IterSpaces, Captures))\n              return true;\n            if (Cnt > 0 && Cnt >= NestedLoopCount &&\n                IterSpaces[Cnt].CounterVar) {\n              // Handle initialization of captured loop iterator variables.\n              auto *DRE = cast<DeclRefExpr>(IterSpaces[Cnt].CounterVar);\n              if (isa<OMPCapturedExprDecl>(DRE->getDecl())) {\n                Captures[DRE] = DRE;\n              }\n            }\n            return false;\n          }))\n    return 0;\n\n  Built.clear(/* size */ NestedLoopCount);\n\n  if (SemaRef.CurContext->isDependentContext())\n    return NestedLoopCount;\n\n  // An example of what is generated for the following code:\n  //\n  //   #pragma omp simd collapse(2) ordered(2)\n  //   for (i = 0; i < NI; ++i)\n  //     for (k = 0; k < NK; ++k)\n  //       for (j = J0; j < NJ; j+=2) {\n  //         <loop body>\n  //       }\n  //\n  // We generate the code below.\n  // Note: the loop body may be outlined in CodeGen.\n  // Note: some counters may be C++ classes, operator- is used to find number of\n  // iterations and operator+= to calculate counter value.\n  // Note: decltype(NumIterations) must be integer type (in 'omp for', only i32\n  // or i64 is currently supported).\n  //\n  //   #define NumIterations (NI * ((NJ - J0 - 1 + 2) / 2))\n  //   for (int[32|64]_t IV = 0; IV < NumIterations; ++IV ) {\n  //     .local.i = IV / ((NJ - J0 - 1 + 2) / 2);\n  //     .local.j = J0 + (IV % ((NJ - J0 - 1 + 2) / 2)) * 2;\n  //     // similar updates for vars in clauses (e.g. 'linear')\n  //     <loop body (using local i and j)>\n  //   }\n  //   i = NI; // assign final values of counters\n  //   j = NJ;\n  //\n\n  // Last iteration number is (I1 * I2 * ... In) - 1, where I1, I2 ... In are\n  // the iteration counts of the collapsed for loops.\n  // Precondition tests if there is at least one iteration (all conditions are\n  // true).\n  auto PreCond = ExprResult(IterSpaces[0].PreCond);\n  Expr *N0 = IterSpaces[0].NumIterations;\n  ExprResult LastIteration32 =\n      widenIterationCount(/*Bits=*/32,\n                          SemaRef\n                              .PerformImplicitConversion(\n                                  N0->IgnoreImpCasts(), N0->getType(),\n                                  Sema::AA_Converting, /*AllowExplicit=*/true)\n                              .get(),\n                          SemaRef);\n  ExprResult LastIteration64 = widenIterationCount(\n      /*Bits=*/64,\n      SemaRef\n          .PerformImplicitConversion(N0->IgnoreImpCasts(), N0->getType(),\n                                     Sema::AA_Converting,\n                                     /*AllowExplicit=*/true)\n          .get(),\n      SemaRef);\n\n  if (!LastIteration32.isUsable() || !LastIteration64.isUsable())\n    return NestedLoopCount;\n\n  ASTContext &C = SemaRef.Context;\n  bool AllCountsNeedLessThan32Bits = C.getTypeSize(N0->getType()) < 32;\n\n  Scope *CurScope = DSA.getCurScope();\n  for (unsigned Cnt = 1; Cnt < NestedLoopCount; ++Cnt) {\n    if (PreCond.isUsable()) {\n      PreCond =\n          SemaRef.BuildBinOp(CurScope, PreCond.get()->getExprLoc(), BO_LAnd,\n                             PreCond.get(), IterSpaces[Cnt].PreCond);\n    }\n    Expr *N = IterSpaces[Cnt].NumIterations;\n    SourceLocation Loc = N->getExprLoc();\n    AllCountsNeedLessThan32Bits &= C.getTypeSize(N->getType()) < 32;\n    if (LastIteration32.isUsable())\n      LastIteration32 = SemaRef.BuildBinOp(\n          CurScope, Loc, BO_Mul, LastIteration32.get(),\n          SemaRef\n              .PerformImplicitConversion(N->IgnoreImpCasts(), N->getType(),\n                                         Sema::AA_Converting,\n                                         /*AllowExplicit=*/true)\n              .get());\n    if (LastIteration64.isUsable())\n      LastIteration64 = SemaRef.BuildBinOp(\n          CurScope, Loc, BO_Mul, LastIteration64.get(),\n          SemaRef\n              .PerformImplicitConversion(N->IgnoreImpCasts(), N->getType(),\n                                         Sema::AA_Converting,\n                                         /*AllowExplicit=*/true)\n              .get());\n  }\n\n  // Choose either the 32-bit or 64-bit version.\n  ExprResult LastIteration = LastIteration64;\n  if (SemaRef.getLangOpts().OpenMPOptimisticCollapse ||\n      (LastIteration32.isUsable() &&\n       C.getTypeSize(LastIteration32.get()->getType()) == 32 &&\n       (AllCountsNeedLessThan32Bits || NestedLoopCount == 1 ||\n        fitsInto(\n            /*Bits=*/32,\n            LastIteration32.get()->getType()->hasSignedIntegerRepresentation(),\n            LastIteration64.get(), SemaRef))))\n    LastIteration = LastIteration32;\n  QualType VType = LastIteration.get()->getType();\n  QualType RealVType = VType;\n  QualType StrideVType = VType;\n  if (isOpenMPTaskLoopDirective(DKind)) {\n    VType =\n        SemaRef.Context.getIntTypeForBitwidth(/*DestWidth=*/64, /*Signed=*/0);\n    StrideVType =\n        SemaRef.Context.getIntTypeForBitwidth(/*DestWidth=*/64, /*Signed=*/1);\n  }\n\n  if (!LastIteration.isUsable())\n    return 0;\n\n  // Save the number of iterations.\n  ExprResult NumIterations = LastIteration;\n  {\n    LastIteration = SemaRef.BuildBinOp(\n        CurScope, LastIteration.get()->getExprLoc(), BO_Sub,\n        LastIteration.get(),\n        SemaRef.ActOnIntegerConstant(SourceLocation(), 1).get());\n    if (!LastIteration.isUsable())\n      return 0;\n  }\n\n  // Calculate the last iteration number beforehand instead of doing this on\n  // each iteration. Do not do this if the number of iterations may be kfold-ed.\n  bool IsConstant = LastIteration.get()->isIntegerConstantExpr(SemaRef.Context);\n  ExprResult CalcLastIteration;\n  if (!IsConstant) {\n    ExprResult SaveRef =\n        tryBuildCapture(SemaRef, LastIteration.get(), Captures);\n    LastIteration = SaveRef;\n\n    // Prepare SaveRef + 1.\n    NumIterations = SemaRef.BuildBinOp(\n        CurScope, SaveRef.get()->getExprLoc(), BO_Add, SaveRef.get(),\n        SemaRef.ActOnIntegerConstant(SourceLocation(), 1).get());\n    if (!NumIterations.isUsable())\n      return 0;\n  }\n\n  SourceLocation InitLoc = IterSpaces[0].InitSrcRange.getBegin();\n\n  // Build variables passed into runtime, necessary for worksharing directives.\n  ExprResult LB, UB, IL, ST, EUB, CombLB, CombUB, PrevLB, PrevUB, CombEUB;\n  if (isOpenMPWorksharingDirective(DKind) || isOpenMPTaskLoopDirective(DKind) ||\n      isOpenMPDistributeDirective(DKind) ||\n      isOpenMPLoopTransformationDirective(DKind)) {\n    // Lower bound variable, initialized with zero.\n    VarDecl *LBDecl = buildVarDecl(SemaRef, InitLoc, VType, \".omp.lb\");\n    LB = buildDeclRefExpr(SemaRef, LBDecl, VType, InitLoc);\n    SemaRef.AddInitializerToDecl(LBDecl,\n                                 SemaRef.ActOnIntegerConstant(InitLoc, 0).get(),\n                                 /*DirectInit*/ false);\n\n    // Upper bound variable, initialized with last iteration number.\n    VarDecl *UBDecl = buildVarDecl(SemaRef, InitLoc, VType, \".omp.ub\");\n    UB = buildDeclRefExpr(SemaRef, UBDecl, VType, InitLoc);\n    SemaRef.AddInitializerToDecl(UBDecl, LastIteration.get(),\n                                 /*DirectInit*/ false);\n\n    // A 32-bit variable-flag where runtime returns 1 for the last iteration.\n    // This will be used to implement clause 'lastprivate'.\n    QualType Int32Ty = SemaRef.Context.getIntTypeForBitwidth(32, true);\n    VarDecl *ILDecl = buildVarDecl(SemaRef, InitLoc, Int32Ty, \".omp.is_last\");\n    IL = buildDeclRefExpr(SemaRef, ILDecl, Int32Ty, InitLoc);\n    SemaRef.AddInitializerToDecl(ILDecl,\n                                 SemaRef.ActOnIntegerConstant(InitLoc, 0).get(),\n                                 /*DirectInit*/ false);\n\n    // Stride variable returned by runtime (we initialize it to 1 by default).\n    VarDecl *STDecl =\n        buildVarDecl(SemaRef, InitLoc, StrideVType, \".omp.stride\");\n    ST = buildDeclRefExpr(SemaRef, STDecl, StrideVType, InitLoc);\n    SemaRef.AddInitializerToDecl(STDecl,\n                                 SemaRef.ActOnIntegerConstant(InitLoc, 1).get(),\n                                 /*DirectInit*/ false);\n\n    // Build expression: UB = min(UB, LastIteration)\n    // It is necessary for CodeGen of directives with static scheduling.\n    ExprResult IsUBGreater = SemaRef.BuildBinOp(CurScope, InitLoc, BO_GT,\n                                                UB.get(), LastIteration.get());\n    ExprResult CondOp = SemaRef.ActOnConditionalOp(\n        LastIteration.get()->getExprLoc(), InitLoc, IsUBGreater.get(),\n        LastIteration.get(), UB.get());\n    EUB = SemaRef.BuildBinOp(CurScope, InitLoc, BO_Assign, UB.get(),\n                             CondOp.get());\n    EUB = SemaRef.ActOnFinishFullExpr(EUB.get(), /*DiscardedValue*/ false);\n\n    // If we have a combined directive that combines 'distribute', 'for' or\n    // 'simd' we need to be able to access the bounds of the schedule of the\n    // enclosing region. E.g. in 'distribute parallel for' the bounds obtained\n    // by scheduling 'distribute' have to be passed to the schedule of 'for'.\n    if (isOpenMPLoopBoundSharingDirective(DKind)) {\n      // Lower bound variable, initialized with zero.\n      VarDecl *CombLBDecl =\n          buildVarDecl(SemaRef, InitLoc, VType, \".omp.comb.lb\");\n      CombLB = buildDeclRefExpr(SemaRef, CombLBDecl, VType, InitLoc);\n      SemaRef.AddInitializerToDecl(\n          CombLBDecl, SemaRef.ActOnIntegerConstant(InitLoc, 0).get(),\n          /*DirectInit*/ false);\n\n      // Upper bound variable, initialized with last iteration number.\n      VarDecl *CombUBDecl =\n          buildVarDecl(SemaRef, InitLoc, VType, \".omp.comb.ub\");\n      CombUB = buildDeclRefExpr(SemaRef, CombUBDecl, VType, InitLoc);\n      SemaRef.AddInitializerToDecl(CombUBDecl, LastIteration.get(),\n                                   /*DirectInit*/ false);\n\n      ExprResult CombIsUBGreater = SemaRef.BuildBinOp(\n          CurScope, InitLoc, BO_GT, CombUB.get(), LastIteration.get());\n      ExprResult CombCondOp =\n          SemaRef.ActOnConditionalOp(InitLoc, InitLoc, CombIsUBGreater.get(),\n                                     LastIteration.get(), CombUB.get());\n      CombEUB = SemaRef.BuildBinOp(CurScope, InitLoc, BO_Assign, CombUB.get(),\n                                   CombCondOp.get());\n      CombEUB =\n          SemaRef.ActOnFinishFullExpr(CombEUB.get(), /*DiscardedValue*/ false);\n\n      const CapturedDecl *CD = cast<CapturedStmt>(AStmt)->getCapturedDecl();\n      // We expect to have at least 2 more parameters than the 'parallel'\n      // directive does - the lower and upper bounds of the previous schedule.\n      assert(CD->getNumParams() >= 4 &&\n             \"Unexpected number of parameters in loop combined directive\");\n\n      // Set the proper type for the bounds given what we learned from the\n      // enclosed loops.\n      ImplicitParamDecl *PrevLBDecl = CD->getParam(/*PrevLB=*/2);\n      ImplicitParamDecl *PrevUBDecl = CD->getParam(/*PrevUB=*/3);\n\n      // Previous lower and upper bounds are obtained from the region\n      // parameters.\n      PrevLB =\n          buildDeclRefExpr(SemaRef, PrevLBDecl, PrevLBDecl->getType(), InitLoc);\n      PrevUB =\n          buildDeclRefExpr(SemaRef, PrevUBDecl, PrevUBDecl->getType(), InitLoc);\n    }\n  }\n\n  // Build the iteration variable and its initialization before loop.\n  ExprResult IV;\n  ExprResult Init, CombInit;\n  {\n    VarDecl *IVDecl = buildVarDecl(SemaRef, InitLoc, RealVType, \".omp.iv\");\n    IV = buildDeclRefExpr(SemaRef, IVDecl, RealVType, InitLoc);\n    Expr *RHS = (isOpenMPWorksharingDirective(DKind) ||\n                 isOpenMPTaskLoopDirective(DKind) ||\n                 isOpenMPDistributeDirective(DKind) ||\n                 isOpenMPLoopTransformationDirective(DKind))\n                    ? LB.get()\n                    : SemaRef.ActOnIntegerConstant(SourceLocation(), 0).get();\n    Init = SemaRef.BuildBinOp(CurScope, InitLoc, BO_Assign, IV.get(), RHS);\n    Init = SemaRef.ActOnFinishFullExpr(Init.get(), /*DiscardedValue*/ false);\n\n    if (isOpenMPLoopBoundSharingDirective(DKind)) {\n      Expr *CombRHS =\n          (isOpenMPWorksharingDirective(DKind) ||\n           isOpenMPTaskLoopDirective(DKind) ||\n           isOpenMPDistributeDirective(DKind))\n              ? CombLB.get()\n              : SemaRef.ActOnIntegerConstant(SourceLocation(), 0).get();\n      CombInit =\n          SemaRef.BuildBinOp(CurScope, InitLoc, BO_Assign, IV.get(), CombRHS);\n      CombInit =\n          SemaRef.ActOnFinishFullExpr(CombInit.get(), /*DiscardedValue*/ false);\n    }\n  }\n\n  bool UseStrictCompare =\n      RealVType->hasUnsignedIntegerRepresentation() &&\n      llvm::all_of(IterSpaces, [](const LoopIterationSpace &LIS) {\n        return LIS.IsStrictCompare;\n      });\n  // Loop condition (IV < NumIterations) or (IV <= UB or IV < UB + 1 (for\n  // unsigned IV)) for worksharing loops.\n  SourceLocation CondLoc = AStmt->getBeginLoc();\n  Expr *BoundUB = UB.get();\n  if (UseStrictCompare) {\n    BoundUB =\n        SemaRef\n            .BuildBinOp(CurScope, CondLoc, BO_Add, BoundUB,\n                        SemaRef.ActOnIntegerConstant(SourceLocation(), 1).get())\n            .get();\n    BoundUB =\n        SemaRef.ActOnFinishFullExpr(BoundUB, /*DiscardedValue*/ false).get();\n  }\n  ExprResult Cond =\n      (isOpenMPWorksharingDirective(DKind) ||\n       isOpenMPTaskLoopDirective(DKind) || isOpenMPDistributeDirective(DKind) ||\n       isOpenMPLoopTransformationDirective(DKind))\n          ? SemaRef.BuildBinOp(CurScope, CondLoc,\n                               UseStrictCompare ? BO_LT : BO_LE, IV.get(),\n                               BoundUB)\n          : SemaRef.BuildBinOp(CurScope, CondLoc, BO_LT, IV.get(),\n                               NumIterations.get());\n  ExprResult CombDistCond;\n  if (isOpenMPLoopBoundSharingDirective(DKind)) {\n    CombDistCond = SemaRef.BuildBinOp(CurScope, CondLoc, BO_LT, IV.get(),\n                                      NumIterations.get());\n  }\n\n  ExprResult CombCond;\n  if (isOpenMPLoopBoundSharingDirective(DKind)) {\n    Expr *BoundCombUB = CombUB.get();\n    if (UseStrictCompare) {\n      BoundCombUB =\n          SemaRef\n              .BuildBinOp(\n                  CurScope, CondLoc, BO_Add, BoundCombUB,\n                  SemaRef.ActOnIntegerConstant(SourceLocation(), 1).get())\n              .get();\n      BoundCombUB =\n          SemaRef.ActOnFinishFullExpr(BoundCombUB, /*DiscardedValue*/ false)\n              .get();\n    }\n    CombCond =\n        SemaRef.BuildBinOp(CurScope, CondLoc, UseStrictCompare ? BO_LT : BO_LE,\n                           IV.get(), BoundCombUB);\n  }\n  // Loop increment (IV = IV + 1)\n  SourceLocation IncLoc = AStmt->getBeginLoc();\n  ExprResult Inc =\n      SemaRef.BuildBinOp(CurScope, IncLoc, BO_Add, IV.get(),\n                         SemaRef.ActOnIntegerConstant(IncLoc, 1).get());\n  if (!Inc.isUsable())\n    return 0;\n  Inc = SemaRef.BuildBinOp(CurScope, IncLoc, BO_Assign, IV.get(), Inc.get());\n  Inc = SemaRef.ActOnFinishFullExpr(Inc.get(), /*DiscardedValue*/ false);\n  if (!Inc.isUsable())\n    return 0;\n\n  // Increments for worksharing loops (LB = LB + ST; UB = UB + ST).\n  // Used for directives with static scheduling.\n  // In combined construct, add combined version that use CombLB and CombUB\n  // base variables for the update\n  ExprResult NextLB, NextUB, CombNextLB, CombNextUB;\n  if (isOpenMPWorksharingDirective(DKind) || isOpenMPTaskLoopDirective(DKind) ||\n      isOpenMPDistributeDirective(DKind) ||\n      isOpenMPLoopTransformationDirective(DKind)) {\n    // LB + ST\n    NextLB = SemaRef.BuildBinOp(CurScope, IncLoc, BO_Add, LB.get(), ST.get());\n    if (!NextLB.isUsable())\n      return 0;\n    // LB = LB + ST\n    NextLB =\n        SemaRef.BuildBinOp(CurScope, IncLoc, BO_Assign, LB.get(), NextLB.get());\n    NextLB =\n        SemaRef.ActOnFinishFullExpr(NextLB.get(), /*DiscardedValue*/ false);\n    if (!NextLB.isUsable())\n      return 0;\n    // UB + ST\n    NextUB = SemaRef.BuildBinOp(CurScope, IncLoc, BO_Add, UB.get(), ST.get());\n    if (!NextUB.isUsable())\n      return 0;\n    // UB = UB + ST\n    NextUB =\n        SemaRef.BuildBinOp(CurScope, IncLoc, BO_Assign, UB.get(), NextUB.get());\n    NextUB =\n        SemaRef.ActOnFinishFullExpr(NextUB.get(), /*DiscardedValue*/ false);\n    if (!NextUB.isUsable())\n      return 0;\n    if (isOpenMPLoopBoundSharingDirective(DKind)) {\n      CombNextLB =\n          SemaRef.BuildBinOp(CurScope, IncLoc, BO_Add, CombLB.get(), ST.get());\n      if (!NextLB.isUsable())\n        return 0;\n      // LB = LB + ST\n      CombNextLB = SemaRef.BuildBinOp(CurScope, IncLoc, BO_Assign, CombLB.get(),\n                                      CombNextLB.get());\n      CombNextLB = SemaRef.ActOnFinishFullExpr(CombNextLB.get(),\n                                               /*DiscardedValue*/ false);\n      if (!CombNextLB.isUsable())\n        return 0;\n      // UB + ST\n      CombNextUB =\n          SemaRef.BuildBinOp(CurScope, IncLoc, BO_Add, CombUB.get(), ST.get());\n      if (!CombNextUB.isUsable())\n        return 0;\n      // UB = UB + ST\n      CombNextUB = SemaRef.BuildBinOp(CurScope, IncLoc, BO_Assign, CombUB.get(),\n                                      CombNextUB.get());\n      CombNextUB = SemaRef.ActOnFinishFullExpr(CombNextUB.get(),\n                                               /*DiscardedValue*/ false);\n      if (!CombNextUB.isUsable())\n        return 0;\n    }\n  }\n\n  // Create increment expression for distribute loop when combined in a same\n  // directive with for as IV = IV + ST; ensure upper bound expression based\n  // on PrevUB instead of NumIterations - used to implement 'for' when found\n  // in combination with 'distribute', like in 'distribute parallel for'\n  SourceLocation DistIncLoc = AStmt->getBeginLoc();\n  ExprResult DistCond, DistInc, PrevEUB, ParForInDistCond;\n  if (isOpenMPLoopBoundSharingDirective(DKind)) {\n    DistCond = SemaRef.BuildBinOp(\n        CurScope, CondLoc, UseStrictCompare ? BO_LT : BO_LE, IV.get(), BoundUB);\n    assert(DistCond.isUsable() && \"distribute cond expr was not built\");\n\n    DistInc =\n        SemaRef.BuildBinOp(CurScope, DistIncLoc, BO_Add, IV.get(), ST.get());\n    assert(DistInc.isUsable() && \"distribute inc expr was not built\");\n    DistInc = SemaRef.BuildBinOp(CurScope, DistIncLoc, BO_Assign, IV.get(),\n                                 DistInc.get());\n    DistInc =\n        SemaRef.ActOnFinishFullExpr(DistInc.get(), /*DiscardedValue*/ false);\n    assert(DistInc.isUsable() && \"distribute inc expr was not built\");\n\n    // Build expression: UB = min(UB, prevUB) for #for in composite or combined\n    // construct\n    SourceLocation DistEUBLoc = AStmt->getBeginLoc();\n    ExprResult IsUBGreater =\n        SemaRef.BuildBinOp(CurScope, DistEUBLoc, BO_GT, UB.get(), PrevUB.get());\n    ExprResult CondOp = SemaRef.ActOnConditionalOp(\n        DistEUBLoc, DistEUBLoc, IsUBGreater.get(), PrevUB.get(), UB.get());\n    PrevEUB = SemaRef.BuildBinOp(CurScope, DistIncLoc, BO_Assign, UB.get(),\n                                 CondOp.get());\n    PrevEUB =\n        SemaRef.ActOnFinishFullExpr(PrevEUB.get(), /*DiscardedValue*/ false);\n\n    // Build IV <= PrevUB or IV < PrevUB + 1 for unsigned IV to be used in\n    // parallel for is in combination with a distribute directive with\n    // schedule(static, 1)\n    Expr *BoundPrevUB = PrevUB.get();\n    if (UseStrictCompare) {\n      BoundPrevUB =\n          SemaRef\n              .BuildBinOp(\n                  CurScope, CondLoc, BO_Add, BoundPrevUB,\n                  SemaRef.ActOnIntegerConstant(SourceLocation(), 1).get())\n              .get();\n      BoundPrevUB =\n          SemaRef.ActOnFinishFullExpr(BoundPrevUB, /*DiscardedValue*/ false)\n              .get();\n    }\n    ParForInDistCond =\n        SemaRef.BuildBinOp(CurScope, CondLoc, UseStrictCompare ? BO_LT : BO_LE,\n                           IV.get(), BoundPrevUB);\n  }\n\n  // Build updates and final values of the loop counters.\n  bool HasErrors = false;\n  Built.Counters.resize(NestedLoopCount);\n  Built.Inits.resize(NestedLoopCount);\n  Built.Updates.resize(NestedLoopCount);\n  Built.Finals.resize(NestedLoopCount);\n  Built.DependentCounters.resize(NestedLoopCount);\n  Built.DependentInits.resize(NestedLoopCount);\n  Built.FinalsConditions.resize(NestedLoopCount);\n  {\n    // We implement the following algorithm for obtaining the\n    // original loop iteration variable values based on the\n    // value of the collapsed loop iteration variable IV.\n    //\n    // Let n+1 be the number of collapsed loops in the nest.\n    // Iteration variables (I0, I1, .... In)\n    // Iteration counts (N0, N1, ... Nn)\n    //\n    // Acc = IV;\n    //\n    // To compute Ik for loop k, 0 <= k <= n, generate:\n    //    Prod = N(k+1) * N(k+2) * ... * Nn;\n    //    Ik = Acc / Prod;\n    //    Acc -= Ik * Prod;\n    //\n    ExprResult Acc = IV;\n    for (unsigned int Cnt = 0; Cnt < NestedLoopCount; ++Cnt) {\n      LoopIterationSpace &IS = IterSpaces[Cnt];\n      SourceLocation UpdLoc = IS.IncSrcRange.getBegin();\n      ExprResult Iter;\n\n      // Compute prod\n      ExprResult Prod =\n          SemaRef.ActOnIntegerConstant(SourceLocation(), 1).get();\n      for (unsigned int K = Cnt+1; K < NestedLoopCount; ++K)\n        Prod = SemaRef.BuildBinOp(CurScope, UpdLoc, BO_Mul, Prod.get(),\n                                  IterSpaces[K].NumIterations);\n\n      // Iter = Acc / Prod\n      // If there is at least one more inner loop to avoid\n      // multiplication by 1.\n      if (Cnt + 1 < NestedLoopCount)\n        Iter = SemaRef.BuildBinOp(CurScope, UpdLoc, BO_Div,\n                                  Acc.get(), Prod.get());\n      else\n        Iter = Acc;\n      if (!Iter.isUsable()) {\n        HasErrors = true;\n        break;\n      }\n\n      // Update Acc:\n      // Acc -= Iter * Prod\n      // Check if there is at least one more inner loop to avoid\n      // multiplication by 1.\n      if (Cnt + 1 < NestedLoopCount)\n        Prod = SemaRef.BuildBinOp(CurScope, UpdLoc, BO_Mul,\n                                  Iter.get(), Prod.get());\n      else\n        Prod = Iter;\n      Acc = SemaRef.BuildBinOp(CurScope, UpdLoc, BO_Sub,\n                               Acc.get(), Prod.get());\n\n      // Build update: IS.CounterVar(Private) = IS.Start + Iter * IS.Step\n      auto *VD = cast<VarDecl>(cast<DeclRefExpr>(IS.CounterVar)->getDecl());\n      DeclRefExpr *CounterVar = buildDeclRefExpr(\n          SemaRef, VD, IS.CounterVar->getType(), IS.CounterVar->getExprLoc(),\n          /*RefersToCapture=*/true);\n      ExprResult Init =\n          buildCounterInit(SemaRef, CurScope, UpdLoc, CounterVar,\n                           IS.CounterInit, IS.IsNonRectangularLB, Captures);\n      if (!Init.isUsable()) {\n        HasErrors = true;\n        break;\n      }\n      ExprResult Update = buildCounterUpdate(\n          SemaRef, CurScope, UpdLoc, CounterVar, IS.CounterInit, Iter,\n          IS.CounterStep, IS.Subtract, IS.IsNonRectangularLB, &Captures);\n      if (!Update.isUsable()) {\n        HasErrors = true;\n        break;\n      }\n\n      // Build final: IS.CounterVar = IS.Start + IS.NumIters * IS.Step\n      ExprResult Final =\n          buildCounterUpdate(SemaRef, CurScope, UpdLoc, CounterVar,\n                             IS.CounterInit, IS.NumIterations, IS.CounterStep,\n                             IS.Subtract, IS.IsNonRectangularLB, &Captures);\n      if (!Final.isUsable()) {\n        HasErrors = true;\n        break;\n      }\n\n      if (!Update.isUsable() || !Final.isUsable()) {\n        HasErrors = true;\n        break;\n      }\n      // Save results\n      Built.Counters[Cnt] = IS.CounterVar;\n      Built.PrivateCounters[Cnt] = IS.PrivateCounterVar;\n      Built.Inits[Cnt] = Init.get();\n      Built.Updates[Cnt] = Update.get();\n      Built.Finals[Cnt] = Final.get();\n      Built.DependentCounters[Cnt] = nullptr;\n      Built.DependentInits[Cnt] = nullptr;\n      Built.FinalsConditions[Cnt] = nullptr;\n      if (IS.IsNonRectangularLB || IS.IsNonRectangularUB) {\n        Built.DependentCounters[Cnt] =\n            Built.Counters[NestedLoopCount - 1 - IS.LoopDependentIdx];\n        Built.DependentInits[Cnt] =\n            Built.Inits[NestedLoopCount - 1 - IS.LoopDependentIdx];\n        Built.FinalsConditions[Cnt] = IS.FinalCondition;\n      }\n    }\n  }\n\n  if (HasErrors)\n    return 0;\n\n  // Save results\n  Built.IterationVarRef = IV.get();\n  Built.LastIteration = LastIteration.get();\n  Built.NumIterations = NumIterations.get();\n  Built.CalcLastIteration = SemaRef\n                                .ActOnFinishFullExpr(CalcLastIteration.get(),\n                                                     /*DiscardedValue=*/false)\n                                .get();\n  Built.PreCond = PreCond.get();\n  Built.PreInits = buildPreInits(C, Captures);\n  Built.Cond = Cond.get();\n  Built.Init = Init.get();\n  Built.Inc = Inc.get();\n  Built.LB = LB.get();\n  Built.UB = UB.get();\n  Built.IL = IL.get();\n  Built.ST = ST.get();\n  Built.EUB = EUB.get();\n  Built.NLB = NextLB.get();\n  Built.NUB = NextUB.get();\n  Built.PrevLB = PrevLB.get();\n  Built.PrevUB = PrevUB.get();\n  Built.DistInc = DistInc.get();\n  Built.PrevEUB = PrevEUB.get();\n  Built.DistCombinedFields.LB = CombLB.get();\n  Built.DistCombinedFields.UB = CombUB.get();\n  Built.DistCombinedFields.EUB = CombEUB.get();\n  Built.DistCombinedFields.Init = CombInit.get();\n  Built.DistCombinedFields.Cond = CombCond.get();\n  Built.DistCombinedFields.NLB = CombNextLB.get();\n  Built.DistCombinedFields.NUB = CombNextUB.get();\n  Built.DistCombinedFields.DistCond = CombDistCond.get();\n  Built.DistCombinedFields.ParForInDistCond = ParForInDistCond.get();\n\n  return NestedLoopCount;\n}\n\nstatic Expr *getCollapseNumberExpr(ArrayRef<OMPClause *> Clauses) {\n  auto CollapseClauses =\n      OMPExecutableDirective::getClausesOfKind<OMPCollapseClause>(Clauses);\n  if (CollapseClauses.begin() != CollapseClauses.end())\n    return (*CollapseClauses.begin())->getNumForLoops();\n  return nullptr;\n}\n\nstatic Expr *getOrderedNumberExpr(ArrayRef<OMPClause *> Clauses) {\n  auto OrderedClauses =\n      OMPExecutableDirective::getClausesOfKind<OMPOrderedClause>(Clauses);\n  if (OrderedClauses.begin() != OrderedClauses.end())\n    return (*OrderedClauses.begin())->getNumForLoops();\n  return nullptr;\n}\n\nstatic bool checkSimdlenSafelenSpecified(Sema &S,\n                                         const ArrayRef<OMPClause *> Clauses) {\n  const OMPSafelenClause *Safelen = nullptr;\n  const OMPSimdlenClause *Simdlen = nullptr;\n\n  for (const OMPClause *Clause : Clauses) {\n    if (Clause->getClauseKind() == OMPC_safelen)\n      Safelen = cast<OMPSafelenClause>(Clause);\n    else if (Clause->getClauseKind() == OMPC_simdlen)\n      Simdlen = cast<OMPSimdlenClause>(Clause);\n    if (Safelen && Simdlen)\n      break;\n  }\n\n  if (Simdlen && Safelen) {\n    const Expr *SimdlenLength = Simdlen->getSimdlen();\n    const Expr *SafelenLength = Safelen->getSafelen();\n    if (SimdlenLength->isValueDependent() || SimdlenLength->isTypeDependent() ||\n        SimdlenLength->isInstantiationDependent() ||\n        SimdlenLength->containsUnexpandedParameterPack())\n      return false;\n    if (SafelenLength->isValueDependent() || SafelenLength->isTypeDependent() ||\n        SafelenLength->isInstantiationDependent() ||\n        SafelenLength->containsUnexpandedParameterPack())\n      return false;\n    Expr::EvalResult SimdlenResult, SafelenResult;\n    SimdlenLength->EvaluateAsInt(SimdlenResult, S.Context);\n    SafelenLength->EvaluateAsInt(SafelenResult, S.Context);\n    llvm::APSInt SimdlenRes = SimdlenResult.Val.getInt();\n    llvm::APSInt SafelenRes = SafelenResult.Val.getInt();\n    // OpenMP 4.5 [2.8.1, simd Construct, Restrictions]\n    // If both simdlen and safelen clauses are specified, the value of the\n    // simdlen parameter must be less than or equal to the value of the safelen\n    // parameter.\n    if (SimdlenRes > SafelenRes) {\n      S.Diag(SimdlenLength->getExprLoc(),\n             diag::err_omp_wrong_simdlen_safelen_values)\n          << SimdlenLength->getSourceRange() << SafelenLength->getSourceRange();\n      return true;\n    }\n  }\n  return false;\n}\n\nStmtResult\nSema::ActOnOpenMPSimdDirective(ArrayRef<OMPClause *> Clauses, Stmt *AStmt,\n                               SourceLocation StartLoc, SourceLocation EndLoc,\n                               VarsWithInheritedDSAType &VarsWithImplicitDSA) {\n  if (!AStmt)\n    return StmtError();\n\n  assert(isa<CapturedStmt>(AStmt) && \"Captured statement expected\");\n  OMPLoopBasedDirective::HelperExprs B;\n  // In presence of clause 'collapse' or 'ordered' with number of loops, it will\n  // define the nested loops number.\n  unsigned NestedLoopCount = checkOpenMPLoop(\n      OMPD_simd, getCollapseNumberExpr(Clauses), getOrderedNumberExpr(Clauses),\n      AStmt, *this, *DSAStack, VarsWithImplicitDSA, B);\n  if (NestedLoopCount == 0)\n    return StmtError();\n\n  assert((CurContext->isDependentContext() || B.builtAll()) &&\n         \"omp simd loop exprs were not built\");\n\n  if (!CurContext->isDependentContext()) {\n    // Finalize the clauses that need pre-built expressions for CodeGen.\n    for (OMPClause *C : Clauses) {\n      if (auto *LC = dyn_cast<OMPLinearClause>(C))\n        if (FinishOpenMPLinearClause(*LC, cast<DeclRefExpr>(B.IterationVarRef),\n                                     B.NumIterations, *this, CurScope,\n                                     DSAStack))\n          return StmtError();\n    }\n  }\n\n  if (checkSimdlenSafelenSpecified(*this, Clauses))\n    return StmtError();\n\n  setFunctionHasBranchProtectedScope();\n  return OMPSimdDirective::Create(Context, StartLoc, EndLoc, NestedLoopCount,\n                                  Clauses, AStmt, B);\n}\n\nStmtResult\nSema::ActOnOpenMPForDirective(ArrayRef<OMPClause *> Clauses, Stmt *AStmt,\n                              SourceLocation StartLoc, SourceLocation EndLoc,\n                              VarsWithInheritedDSAType &VarsWithImplicitDSA) {\n  if (!AStmt)\n    return StmtError();\n\n  assert(isa<CapturedStmt>(AStmt) && \"Captured statement expected\");\n  OMPLoopBasedDirective::HelperExprs B;\n  // In presence of clause 'collapse' or 'ordered' with number of loops, it will\n  // define the nested loops number.\n  unsigned NestedLoopCount = checkOpenMPLoop(\n      OMPD_for, getCollapseNumberExpr(Clauses), getOrderedNumberExpr(Clauses),\n      AStmt, *this, *DSAStack, VarsWithImplicitDSA, B);\n  if (NestedLoopCount == 0)\n    return StmtError();\n\n  assert((CurContext->isDependentContext() || B.builtAll()) &&\n         \"omp for loop exprs were not built\");\n\n  if (!CurContext->isDependentContext()) {\n    // Finalize the clauses that need pre-built expressions for CodeGen.\n    for (OMPClause *C : Clauses) {\n      if (auto *LC = dyn_cast<OMPLinearClause>(C))\n        if (FinishOpenMPLinearClause(*LC, cast<DeclRefExpr>(B.IterationVarRef),\n                                     B.NumIterations, *this, CurScope,\n                                     DSAStack))\n          return StmtError();\n    }\n  }\n\n  setFunctionHasBranchProtectedScope();\n  return OMPForDirective::Create(\n      Context, StartLoc, EndLoc, NestedLoopCount, Clauses, AStmt, B,\n      DSAStack->getTaskgroupReductionRef(), DSAStack->isCancelRegion());\n}\n\nStmtResult Sema::ActOnOpenMPForSimdDirective(\n    ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n    SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA) {\n  if (!AStmt)\n    return StmtError();\n\n  assert(isa<CapturedStmt>(AStmt) && \"Captured statement expected\");\n  OMPLoopBasedDirective::HelperExprs B;\n  // In presence of clause 'collapse' or 'ordered' with number of loops, it will\n  // define the nested loops number.\n  unsigned NestedLoopCount =\n      checkOpenMPLoop(OMPD_for_simd, getCollapseNumberExpr(Clauses),\n                      getOrderedNumberExpr(Clauses), AStmt, *this, *DSAStack,\n                      VarsWithImplicitDSA, B);\n  if (NestedLoopCount == 0)\n    return StmtError();\n\n  assert((CurContext->isDependentContext() || B.builtAll()) &&\n         \"omp for simd loop exprs were not built\");\n\n  if (!CurContext->isDependentContext()) {\n    // Finalize the clauses that need pre-built expressions for CodeGen.\n    for (OMPClause *C : Clauses) {\n      if (auto *LC = dyn_cast<OMPLinearClause>(C))\n        if (FinishOpenMPLinearClause(*LC, cast<DeclRefExpr>(B.IterationVarRef),\n                                     B.NumIterations, *this, CurScope,\n                                     DSAStack))\n          return StmtError();\n    }\n  }\n\n  if (checkSimdlenSafelenSpecified(*this, Clauses))\n    return StmtError();\n\n  setFunctionHasBranchProtectedScope();\n  return OMPForSimdDirective::Create(Context, StartLoc, EndLoc, NestedLoopCount,\n                                     Clauses, AStmt, B);\n}\n\nStmtResult Sema::ActOnOpenMPSectionsDirective(ArrayRef<OMPClause *> Clauses,\n                                              Stmt *AStmt,\n                                              SourceLocation StartLoc,\n                                              SourceLocation EndLoc) {\n  if (!AStmt)\n    return StmtError();\n\n  assert(isa<CapturedStmt>(AStmt) && \"Captured statement expected\");\n  auto BaseStmt = AStmt;\n  while (auto *CS = dyn_cast_or_null<CapturedStmt>(BaseStmt))\n    BaseStmt = CS->getCapturedStmt();\n  if (auto *C = dyn_cast_or_null<CompoundStmt>(BaseStmt)) {\n    auto S = C->children();\n    if (S.begin() == S.end())\n      return StmtError();\n    // All associated statements must be '#pragma omp section' except for\n    // the first one.\n    for (Stmt *SectionStmt : llvm::make_range(std::next(S.begin()), S.end())) {\n      if (!SectionStmt || !isa<OMPSectionDirective>(SectionStmt)) {\n        if (SectionStmt)\n          Diag(SectionStmt->getBeginLoc(),\n               diag::err_omp_sections_substmt_not_section);\n        return StmtError();\n      }\n      cast<OMPSectionDirective>(SectionStmt)\n          ->setHasCancel(DSAStack->isCancelRegion());\n    }\n  } else {\n    Diag(AStmt->getBeginLoc(), diag::err_omp_sections_not_compound_stmt);\n    return StmtError();\n  }\n\n  setFunctionHasBranchProtectedScope();\n\n  return OMPSectionsDirective::Create(Context, StartLoc, EndLoc, Clauses, AStmt,\n                                      DSAStack->getTaskgroupReductionRef(),\n                                      DSAStack->isCancelRegion());\n}\n\nStmtResult Sema::ActOnOpenMPSectionDirective(Stmt *AStmt,\n                                             SourceLocation StartLoc,\n                                             SourceLocation EndLoc) {\n  if (!AStmt)\n    return StmtError();\n\n  setFunctionHasBranchProtectedScope();\n  DSAStack->setParentCancelRegion(DSAStack->isCancelRegion());\n\n  return OMPSectionDirective::Create(Context, StartLoc, EndLoc, AStmt,\n                                     DSAStack->isCancelRegion());\n}\n\nStmtResult Sema::ActOnOpenMPSingleDirective(ArrayRef<OMPClause *> Clauses,\n                                            Stmt *AStmt,\n                                            SourceLocation StartLoc,\n                                            SourceLocation EndLoc) {\n  if (!AStmt)\n    return StmtError();\n\n  assert(isa<CapturedStmt>(AStmt) && \"Captured statement expected\");\n\n  setFunctionHasBranchProtectedScope();\n\n  // OpenMP [2.7.3, single Construct, Restrictions]\n  // The copyprivate clause must not be used with the nowait clause.\n  const OMPClause *Nowait = nullptr;\n  const OMPClause *Copyprivate = nullptr;\n  for (const OMPClause *Clause : Clauses) {\n    if (Clause->getClauseKind() == OMPC_nowait)\n      Nowait = Clause;\n    else if (Clause->getClauseKind() == OMPC_copyprivate)\n      Copyprivate = Clause;\n    if (Copyprivate && Nowait) {\n      Diag(Copyprivate->getBeginLoc(),\n           diag::err_omp_single_copyprivate_with_nowait);\n      Diag(Nowait->getBeginLoc(), diag::note_omp_nowait_clause_here);\n      return StmtError();\n    }\n  }\n\n  return OMPSingleDirective::Create(Context, StartLoc, EndLoc, Clauses, AStmt);\n}\n\nStmtResult Sema::ActOnOpenMPMasterDirective(Stmt *AStmt,\n                                            SourceLocation StartLoc,\n                                            SourceLocation EndLoc) {\n  if (!AStmt)\n    return StmtError();\n\n  setFunctionHasBranchProtectedScope();\n\n  return OMPMasterDirective::Create(Context, StartLoc, EndLoc, AStmt);\n}\n\nStmtResult Sema::ActOnOpenMPCriticalDirective(\n    const DeclarationNameInfo &DirName, ArrayRef<OMPClause *> Clauses,\n    Stmt *AStmt, SourceLocation StartLoc, SourceLocation EndLoc) {\n  if (!AStmt)\n    return StmtError();\n\n  bool ErrorFound = false;\n  llvm::APSInt Hint;\n  SourceLocation HintLoc;\n  bool DependentHint = false;\n  for (const OMPClause *C : Clauses) {\n    if (C->getClauseKind() == OMPC_hint) {\n      if (!DirName.getName()) {\n        Diag(C->getBeginLoc(), diag::err_omp_hint_clause_no_name);\n        ErrorFound = true;\n      }\n      Expr *E = cast<OMPHintClause>(C)->getHint();\n      if (E->isTypeDependent() || E->isValueDependent() ||\n          E->isInstantiationDependent()) {\n        DependentHint = true;\n      } else {\n        Hint = E->EvaluateKnownConstInt(Context);\n        HintLoc = C->getBeginLoc();\n      }\n    }\n  }\n  if (ErrorFound)\n    return StmtError();\n  const auto Pair = DSAStack->getCriticalWithHint(DirName);\n  if (Pair.first && DirName.getName() && !DependentHint) {\n    if (llvm::APSInt::compareValues(Hint, Pair.second) != 0) {\n      Diag(StartLoc, diag::err_omp_critical_with_hint);\n      if (HintLoc.isValid())\n        Diag(HintLoc, diag::note_omp_critical_hint_here)\n            << 0 << Hint.toString(/*Radix=*/10, /*Signed=*/false);\n      else\n        Diag(StartLoc, diag::note_omp_critical_no_hint) << 0;\n      if (const auto *C = Pair.first->getSingleClause<OMPHintClause>()) {\n        Diag(C->getBeginLoc(), diag::note_omp_critical_hint_here)\n            << 1\n            << C->getHint()->EvaluateKnownConstInt(Context).toString(\n                   /*Radix=*/10, /*Signed=*/false);\n      } else {\n        Diag(Pair.first->getBeginLoc(), diag::note_omp_critical_no_hint) << 1;\n      }\n    }\n  }\n\n  setFunctionHasBranchProtectedScope();\n\n  auto *Dir = OMPCriticalDirective::Create(Context, DirName, StartLoc, EndLoc,\n                                           Clauses, AStmt);\n  if (!Pair.first && DirName.getName() && !DependentHint)\n    DSAStack->addCriticalWithHint(Dir, Hint);\n  return Dir;\n}\n\nStmtResult Sema::ActOnOpenMPParallelForDirective(\n    ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n    SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA) {\n  if (!AStmt)\n    return StmtError();\n\n  auto *CS = cast<CapturedStmt>(AStmt);\n  // 1.2.2 OpenMP Language Terminology\n  // Structured block - An executable statement with a single entry at the\n  // top and a single exit at the bottom.\n  // The point of exit cannot be a branch out of the structured block.\n  // longjmp() and throw() must not violate the entry/exit criteria.\n  CS->getCapturedDecl()->setNothrow();\n\n  OMPLoopBasedDirective::HelperExprs B;\n  // In presence of clause 'collapse' or 'ordered' with number of loops, it will\n  // define the nested loops number.\n  unsigned NestedLoopCount =\n      checkOpenMPLoop(OMPD_parallel_for, getCollapseNumberExpr(Clauses),\n                      getOrderedNumberExpr(Clauses), AStmt, *this, *DSAStack,\n                      VarsWithImplicitDSA, B);\n  if (NestedLoopCount == 0)\n    return StmtError();\n\n  assert((CurContext->isDependentContext() || B.builtAll()) &&\n         \"omp parallel for loop exprs were not built\");\n\n  if (!CurContext->isDependentContext()) {\n    // Finalize the clauses that need pre-built expressions for CodeGen.\n    for (OMPClause *C : Clauses) {\n      if (auto *LC = dyn_cast<OMPLinearClause>(C))\n        if (FinishOpenMPLinearClause(*LC, cast<DeclRefExpr>(B.IterationVarRef),\n                                     B.NumIterations, *this, CurScope,\n                                     DSAStack))\n          return StmtError();\n    }\n  }\n\n  setFunctionHasBranchProtectedScope();\n  return OMPParallelForDirective::Create(\n      Context, StartLoc, EndLoc, NestedLoopCount, Clauses, AStmt, B,\n      DSAStack->getTaskgroupReductionRef(), DSAStack->isCancelRegion());\n}\n\nStmtResult Sema::ActOnOpenMPParallelForSimdDirective(\n    ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n    SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA) {\n  if (!AStmt)\n    return StmtError();\n\n  auto *CS = cast<CapturedStmt>(AStmt);\n  // 1.2.2 OpenMP Language Terminology\n  // Structured block - An executable statement with a single entry at the\n  // top and a single exit at the bottom.\n  // The point of exit cannot be a branch out of the structured block.\n  // longjmp() and throw() must not violate the entry/exit criteria.\n  CS->getCapturedDecl()->setNothrow();\n\n  OMPLoopBasedDirective::HelperExprs B;\n  // In presence of clause 'collapse' or 'ordered' with number of loops, it will\n  // define the nested loops number.\n  unsigned NestedLoopCount =\n      checkOpenMPLoop(OMPD_parallel_for_simd, getCollapseNumberExpr(Clauses),\n                      getOrderedNumberExpr(Clauses), AStmt, *this, *DSAStack,\n                      VarsWithImplicitDSA, B);\n  if (NestedLoopCount == 0)\n    return StmtError();\n\n  if (!CurContext->isDependentContext()) {\n    // Finalize the clauses that need pre-built expressions for CodeGen.\n    for (OMPClause *C : Clauses) {\n      if (auto *LC = dyn_cast<OMPLinearClause>(C))\n        if (FinishOpenMPLinearClause(*LC, cast<DeclRefExpr>(B.IterationVarRef),\n                                     B.NumIterations, *this, CurScope,\n                                     DSAStack))\n          return StmtError();\n    }\n  }\n\n  if (checkSimdlenSafelenSpecified(*this, Clauses))\n    return StmtError();\n\n  setFunctionHasBranchProtectedScope();\n  return OMPParallelForSimdDirective::Create(\n      Context, StartLoc, EndLoc, NestedLoopCount, Clauses, AStmt, B);\n}\n\nStmtResult\nSema::ActOnOpenMPParallelMasterDirective(ArrayRef<OMPClause *> Clauses,\n                                         Stmt *AStmt, SourceLocation StartLoc,\n                                         SourceLocation EndLoc) {\n  if (!AStmt)\n    return StmtError();\n\n  assert(isa<CapturedStmt>(AStmt) && \"Captured statement expected\");\n  auto *CS = cast<CapturedStmt>(AStmt);\n  // 1.2.2 OpenMP Language Terminology\n  // Structured block - An executable statement with a single entry at the\n  // top and a single exit at the bottom.\n  // The point of exit cannot be a branch out of the structured block.\n  // longjmp() and throw() must not violate the entry/exit criteria.\n  CS->getCapturedDecl()->setNothrow();\n\n  setFunctionHasBranchProtectedScope();\n\n  return OMPParallelMasterDirective::Create(\n      Context, StartLoc, EndLoc, Clauses, AStmt,\n      DSAStack->getTaskgroupReductionRef());\n}\n\nStmtResult\nSema::ActOnOpenMPParallelSectionsDirective(ArrayRef<OMPClause *> Clauses,\n                                           Stmt *AStmt, SourceLocation StartLoc,\n                                           SourceLocation EndLoc) {\n  if (!AStmt)\n    return StmtError();\n\n  assert(isa<CapturedStmt>(AStmt) && \"Captured statement expected\");\n  auto BaseStmt = AStmt;\n  while (auto *CS = dyn_cast_or_null<CapturedStmt>(BaseStmt))\n    BaseStmt = CS->getCapturedStmt();\n  if (auto *C = dyn_cast_or_null<CompoundStmt>(BaseStmt)) {\n    auto S = C->children();\n    if (S.begin() == S.end())\n      return StmtError();\n    // All associated statements must be '#pragma omp section' except for\n    // the first one.\n    for (Stmt *SectionStmt : llvm::make_range(std::next(S.begin()), S.end())) {\n      if (!SectionStmt || !isa<OMPSectionDirective>(SectionStmt)) {\n        if (SectionStmt)\n          Diag(SectionStmt->getBeginLoc(),\n               diag::err_omp_parallel_sections_substmt_not_section);\n        return StmtError();\n      }\n      cast<OMPSectionDirective>(SectionStmt)\n          ->setHasCancel(DSAStack->isCancelRegion());\n    }\n  } else {\n    Diag(AStmt->getBeginLoc(),\n         diag::err_omp_parallel_sections_not_compound_stmt);\n    return StmtError();\n  }\n\n  setFunctionHasBranchProtectedScope();\n\n  return OMPParallelSectionsDirective::Create(\n      Context, StartLoc, EndLoc, Clauses, AStmt,\n      DSAStack->getTaskgroupReductionRef(), DSAStack->isCancelRegion());\n}\n\n/// detach and mergeable clauses are mutially exclusive, check for it.\nstatic bool checkDetachMergeableClauses(Sema &S,\n                                        ArrayRef<OMPClause *> Clauses) {\n  const OMPClause *PrevClause = nullptr;\n  bool ErrorFound = false;\n  for (const OMPClause *C : Clauses) {\n    if (C->getClauseKind() == OMPC_detach ||\n        C->getClauseKind() == OMPC_mergeable) {\n      if (!PrevClause) {\n        PrevClause = C;\n      } else if (PrevClause->getClauseKind() != C->getClauseKind()) {\n        S.Diag(C->getBeginLoc(), diag::err_omp_clauses_mutually_exclusive)\n            << getOpenMPClauseName(C->getClauseKind())\n            << getOpenMPClauseName(PrevClause->getClauseKind());\n        S.Diag(PrevClause->getBeginLoc(), diag::note_omp_previous_clause)\n            << getOpenMPClauseName(PrevClause->getClauseKind());\n        ErrorFound = true;\n      }\n    }\n  }\n  return ErrorFound;\n}\n\nStmtResult Sema::ActOnOpenMPTaskDirective(ArrayRef<OMPClause *> Clauses,\n                                          Stmt *AStmt, SourceLocation StartLoc,\n                                          SourceLocation EndLoc) {\n  if (!AStmt)\n    return StmtError();\n\n  // OpenMP 5.0, 2.10.1 task Construct\n  // If a detach clause appears on the directive, then a mergeable clause cannot\n  // appear on the same directive.\n  if (checkDetachMergeableClauses(*this, Clauses))\n    return StmtError();\n\n  auto *CS = cast<CapturedStmt>(AStmt);\n  // 1.2.2 OpenMP Language Terminology\n  // Structured block - An executable statement with a single entry at the\n  // top and a single exit at the bottom.\n  // The point of exit cannot be a branch out of the structured block.\n  // longjmp() and throw() must not violate the entry/exit criteria.\n  CS->getCapturedDecl()->setNothrow();\n\n  setFunctionHasBranchProtectedScope();\n\n  return OMPTaskDirective::Create(Context, StartLoc, EndLoc, Clauses, AStmt,\n                                  DSAStack->isCancelRegion());\n}\n\nStmtResult Sema::ActOnOpenMPTaskyieldDirective(SourceLocation StartLoc,\n                                               SourceLocation EndLoc) {\n  return OMPTaskyieldDirective::Create(Context, StartLoc, EndLoc);\n}\n\nStmtResult Sema::ActOnOpenMPBarrierDirective(SourceLocation StartLoc,\n                                             SourceLocation EndLoc) {\n  return OMPBarrierDirective::Create(Context, StartLoc, EndLoc);\n}\n\nStmtResult Sema::ActOnOpenMPTaskwaitDirective(SourceLocation StartLoc,\n                                              SourceLocation EndLoc) {\n  return OMPTaskwaitDirective::Create(Context, StartLoc, EndLoc);\n}\n\nStmtResult Sema::ActOnOpenMPTaskgroupDirective(ArrayRef<OMPClause *> Clauses,\n                                               Stmt *AStmt,\n                                               SourceLocation StartLoc,\n                                               SourceLocation EndLoc) {\n  if (!AStmt)\n    return StmtError();\n\n  assert(isa<CapturedStmt>(AStmt) && \"Captured statement expected\");\n\n  setFunctionHasBranchProtectedScope();\n\n  return OMPTaskgroupDirective::Create(Context, StartLoc, EndLoc, Clauses,\n                                       AStmt,\n                                       DSAStack->getTaskgroupReductionRef());\n}\n\nStmtResult Sema::ActOnOpenMPFlushDirective(ArrayRef<OMPClause *> Clauses,\n                                           SourceLocation StartLoc,\n                                           SourceLocation EndLoc) {\n  OMPFlushClause *FC = nullptr;\n  OMPClause *OrderClause = nullptr;\n  for (OMPClause *C : Clauses) {\n    if (C->getClauseKind() == OMPC_flush)\n      FC = cast<OMPFlushClause>(C);\n    else\n      OrderClause = C;\n  }\n  OpenMPClauseKind MemOrderKind = OMPC_unknown;\n  SourceLocation MemOrderLoc;\n  for (const OMPClause *C : Clauses) {\n    if (C->getClauseKind() == OMPC_acq_rel ||\n        C->getClauseKind() == OMPC_acquire ||\n        C->getClauseKind() == OMPC_release) {\n      if (MemOrderKind != OMPC_unknown) {\n        Diag(C->getBeginLoc(), diag::err_omp_several_mem_order_clauses)\n            << getOpenMPDirectiveName(OMPD_flush) << 1\n            << SourceRange(C->getBeginLoc(), C->getEndLoc());\n        Diag(MemOrderLoc, diag::note_omp_previous_mem_order_clause)\n            << getOpenMPClauseName(MemOrderKind);\n      } else {\n        MemOrderKind = C->getClauseKind();\n        MemOrderLoc = C->getBeginLoc();\n      }\n    }\n  }\n  if (FC && OrderClause) {\n    Diag(FC->getLParenLoc(), diag::err_omp_flush_order_clause_and_list)\n        << getOpenMPClauseName(OrderClause->getClauseKind());\n    Diag(OrderClause->getBeginLoc(), diag::note_omp_flush_order_clause_here)\n        << getOpenMPClauseName(OrderClause->getClauseKind());\n    return StmtError();\n  }\n  return OMPFlushDirective::Create(Context, StartLoc, EndLoc, Clauses);\n}\n\nStmtResult Sema::ActOnOpenMPDepobjDirective(ArrayRef<OMPClause *> Clauses,\n                                            SourceLocation StartLoc,\n                                            SourceLocation EndLoc) {\n  if (Clauses.empty()) {\n    Diag(StartLoc, diag::err_omp_depobj_expected);\n    return StmtError();\n  } else if (Clauses[0]->getClauseKind() != OMPC_depobj) {\n    Diag(Clauses[0]->getBeginLoc(), diag::err_omp_depobj_expected);\n    return StmtError();\n  }\n  // Only depobj expression and another single clause is allowed.\n  if (Clauses.size() > 2) {\n    Diag(Clauses[2]->getBeginLoc(),\n         diag::err_omp_depobj_single_clause_expected);\n    return StmtError();\n  } else if (Clauses.size() < 1) {\n    Diag(Clauses[0]->getEndLoc(), diag::err_omp_depobj_single_clause_expected);\n    return StmtError();\n  }\n  return OMPDepobjDirective::Create(Context, StartLoc, EndLoc, Clauses);\n}\n\nStmtResult Sema::ActOnOpenMPScanDirective(ArrayRef<OMPClause *> Clauses,\n                                          SourceLocation StartLoc,\n                                          SourceLocation EndLoc) {\n  // Check that exactly one clause is specified.\n  if (Clauses.size() != 1) {\n    Diag(Clauses.empty() ? EndLoc : Clauses[1]->getBeginLoc(),\n         diag::err_omp_scan_single_clause_expected);\n    return StmtError();\n  }\n  // Check that scan directive is used in the scopeof the OpenMP loop body.\n  if (Scope *S = DSAStack->getCurScope()) {\n    Scope *ParentS = S->getParent();\n    if (!ParentS || ParentS->getParent() != ParentS->getBreakParent() ||\n        !ParentS->getBreakParent()->isOpenMPLoopScope())\n      return StmtError(Diag(StartLoc, diag::err_omp_orphaned_device_directive)\n                       << getOpenMPDirectiveName(OMPD_scan) << 5);\n  }\n  // Check that only one instance of scan directives is used in the same outer\n  // region.\n  if (DSAStack->doesParentHasScanDirective()) {\n    Diag(StartLoc, diag::err_omp_several_directives_in_region) << \"scan\";\n    Diag(DSAStack->getParentScanDirectiveLoc(),\n         diag::note_omp_previous_directive)\n        << \"scan\";\n    return StmtError();\n  }\n  DSAStack->setParentHasScanDirective(StartLoc);\n  return OMPScanDirective::Create(Context, StartLoc, EndLoc, Clauses);\n}\n\nStmtResult Sema::ActOnOpenMPOrderedDirective(ArrayRef<OMPClause *> Clauses,\n                                             Stmt *AStmt,\n                                             SourceLocation StartLoc,\n                                             SourceLocation EndLoc) {\n  const OMPClause *DependFound = nullptr;\n  const OMPClause *DependSourceClause = nullptr;\n  const OMPClause *DependSinkClause = nullptr;\n  bool ErrorFound = false;\n  const OMPThreadsClause *TC = nullptr;\n  const OMPSIMDClause *SC = nullptr;\n  for (const OMPClause *C : Clauses) {\n    if (auto *DC = dyn_cast<OMPDependClause>(C)) {\n      DependFound = C;\n      if (DC->getDependencyKind() == OMPC_DEPEND_source) {\n        if (DependSourceClause) {\n          Diag(C->getBeginLoc(), diag::err_omp_more_one_clause)\n              << getOpenMPDirectiveName(OMPD_ordered)\n              << getOpenMPClauseName(OMPC_depend) << 2;\n          ErrorFound = true;\n        } else {\n          DependSourceClause = C;\n        }\n        if (DependSinkClause) {\n          Diag(C->getBeginLoc(), diag::err_omp_depend_sink_source_not_allowed)\n              << 0;\n          ErrorFound = true;\n        }\n      } else if (DC->getDependencyKind() == OMPC_DEPEND_sink) {\n        if (DependSourceClause) {\n          Diag(C->getBeginLoc(), diag::err_omp_depend_sink_source_not_allowed)\n              << 1;\n          ErrorFound = true;\n        }\n        DependSinkClause = C;\n      }\n    } else if (C->getClauseKind() == OMPC_threads) {\n      TC = cast<OMPThreadsClause>(C);\n    } else if (C->getClauseKind() == OMPC_simd) {\n      SC = cast<OMPSIMDClause>(C);\n    }\n  }\n  if (!ErrorFound && !SC &&\n      isOpenMPSimdDirective(DSAStack->getParentDirective())) {\n    // OpenMP [2.8.1,simd Construct, Restrictions]\n    // An ordered construct with the simd clause is the only OpenMP construct\n    // that can appear in the simd region.\n    Diag(StartLoc, diag::err_omp_prohibited_region_simd)\n        << (LangOpts.OpenMP >= 50 ? 1 : 0);\n    ErrorFound = true;\n  } else if (DependFound && (TC || SC)) {\n    Diag(DependFound->getBeginLoc(), diag::err_omp_depend_clause_thread_simd)\n        << getOpenMPClauseName(TC ? TC->getClauseKind() : SC->getClauseKind());\n    ErrorFound = true;\n  } else if (DependFound && !DSAStack->getParentOrderedRegionParam().first) {\n    Diag(DependFound->getBeginLoc(),\n         diag::err_omp_ordered_directive_without_param);\n    ErrorFound = true;\n  } else if (TC || Clauses.empty()) {\n    if (const Expr *Param = DSAStack->getParentOrderedRegionParam().first) {\n      SourceLocation ErrLoc = TC ? TC->getBeginLoc() : StartLoc;\n      Diag(ErrLoc, diag::err_omp_ordered_directive_with_param)\n          << (TC != nullptr);\n      Diag(Param->getBeginLoc(), diag::note_omp_ordered_param) << 1;\n      ErrorFound = true;\n    }\n  }\n  if ((!AStmt && !DependFound) || ErrorFound)\n    return StmtError();\n\n  // OpenMP 5.0, 2.17.9, ordered Construct, Restrictions.\n  // During execution of an iteration of a worksharing-loop or a loop nest\n  // within a worksharing-loop, simd, or worksharing-loop SIMD region, a thread\n  // must not execute more than one ordered region corresponding to an ordered\n  // construct without a depend clause.\n  if (!DependFound) {\n    if (DSAStack->doesParentHasOrderedDirective()) {\n      Diag(StartLoc, diag::err_omp_several_directives_in_region) << \"ordered\";\n      Diag(DSAStack->getParentOrderedDirectiveLoc(),\n           diag::note_omp_previous_directive)\n          << \"ordered\";\n      return StmtError();\n    }\n    DSAStack->setParentHasOrderedDirective(StartLoc);\n  }\n\n  if (AStmt) {\n    assert(isa<CapturedStmt>(AStmt) && \"Captured statement expected\");\n\n    setFunctionHasBranchProtectedScope();\n  }\n\n  return OMPOrderedDirective::Create(Context, StartLoc, EndLoc, Clauses, AStmt);\n}\n\nnamespace {\n/// Helper class for checking expression in 'omp atomic [update]'\n/// construct.\nclass OpenMPAtomicUpdateChecker {\n  /// Error results for atomic update expressions.\n  enum ExprAnalysisErrorCode {\n    /// A statement is not an expression statement.\n    NotAnExpression,\n    /// Expression is not builtin binary or unary operation.\n    NotABinaryOrUnaryExpression,\n    /// Unary operation is not post-/pre- increment/decrement operation.\n    NotAnUnaryIncDecExpression,\n    /// An expression is not of scalar type.\n    NotAScalarType,\n    /// A binary operation is not an assignment operation.\n    NotAnAssignmentOp,\n    /// RHS part of the binary operation is not a binary expression.\n    NotABinaryExpression,\n    /// RHS part is not additive/multiplicative/shift/biwise binary\n    /// expression.\n    NotABinaryOperator,\n    /// RHS binary operation does not have reference to the updated LHS\n    /// part.\n    NotAnUpdateExpression,\n    /// No errors is found.\n    NoError\n  };\n  /// Reference to Sema.\n  Sema &SemaRef;\n  /// A location for note diagnostics (when error is found).\n  SourceLocation NoteLoc;\n  /// 'x' lvalue part of the source atomic expression.\n  Expr *X;\n  /// 'expr' rvalue part of the source atomic expression.\n  Expr *E;\n  /// Helper expression of the form\n  /// 'OpaqueValueExpr(x) binop OpaqueValueExpr(expr)' or\n  /// 'OpaqueValueExpr(expr) binop OpaqueValueExpr(x)'.\n  Expr *UpdateExpr;\n  /// Is 'x' a LHS in a RHS part of full update expression. It is\n  /// important for non-associative operations.\n  bool IsXLHSInRHSPart;\n  BinaryOperatorKind Op;\n  SourceLocation OpLoc;\n  /// true if the source expression is a postfix unary operation, false\n  /// if it is a prefix unary operation.\n  bool IsPostfixUpdate;\n\npublic:\n  OpenMPAtomicUpdateChecker(Sema &SemaRef)\n      : SemaRef(SemaRef), X(nullptr), E(nullptr), UpdateExpr(nullptr),\n        IsXLHSInRHSPart(false), Op(BO_PtrMemD), IsPostfixUpdate(false) {}\n  /// Check specified statement that it is suitable for 'atomic update'\n  /// constructs and extract 'x', 'expr' and Operation from the original\n  /// expression. If DiagId and NoteId == 0, then only check is performed\n  /// without error notification.\n  /// \\param DiagId Diagnostic which should be emitted if error is found.\n  /// \\param NoteId Diagnostic note for the main error message.\n  /// \\return true if statement is not an update expression, false otherwise.\n  bool checkStatement(Stmt *S, unsigned DiagId = 0, unsigned NoteId = 0);\n  /// Return the 'x' lvalue part of the source atomic expression.\n  Expr *getX() const { return X; }\n  /// Return the 'expr' rvalue part of the source atomic expression.\n  Expr *getExpr() const { return E; }\n  /// Return the update expression used in calculation of the updated\n  /// value. Always has form 'OpaqueValueExpr(x) binop OpaqueValueExpr(expr)' or\n  /// 'OpaqueValueExpr(expr) binop OpaqueValueExpr(x)'.\n  Expr *getUpdateExpr() const { return UpdateExpr; }\n  /// Return true if 'x' is LHS in RHS part of full update expression,\n  /// false otherwise.\n  bool isXLHSInRHSPart() const { return IsXLHSInRHSPart; }\n\n  /// true if the source expression is a postfix unary operation, false\n  /// if it is a prefix unary operation.\n  bool isPostfixUpdate() const { return IsPostfixUpdate; }\n\nprivate:\n  bool checkBinaryOperation(BinaryOperator *AtomicBinOp, unsigned DiagId = 0,\n                            unsigned NoteId = 0);\n};\n} // namespace\n\nbool OpenMPAtomicUpdateChecker::checkBinaryOperation(\n    BinaryOperator *AtomicBinOp, unsigned DiagId, unsigned NoteId) {\n  ExprAnalysisErrorCode ErrorFound = NoError;\n  SourceLocation ErrorLoc, NoteLoc;\n  SourceRange ErrorRange, NoteRange;\n  // Allowed constructs are:\n  //  x = x binop expr;\n  //  x = expr binop x;\n  if (AtomicBinOp->getOpcode() == BO_Assign) {\n    X = AtomicBinOp->getLHS();\n    if (const auto *AtomicInnerBinOp = dyn_cast<BinaryOperator>(\n            AtomicBinOp->getRHS()->IgnoreParenImpCasts())) {\n      if (AtomicInnerBinOp->isMultiplicativeOp() ||\n          AtomicInnerBinOp->isAdditiveOp() || AtomicInnerBinOp->isShiftOp() ||\n          AtomicInnerBinOp->isBitwiseOp()) {\n        Op = AtomicInnerBinOp->getOpcode();\n        OpLoc = AtomicInnerBinOp->getOperatorLoc();\n        Expr *LHS = AtomicInnerBinOp->getLHS();\n        Expr *RHS = AtomicInnerBinOp->getRHS();\n        llvm::FoldingSetNodeID XId, LHSId, RHSId;\n        X->IgnoreParenImpCasts()->Profile(XId, SemaRef.getASTContext(),\n                                          /*Canonical=*/true);\n        LHS->IgnoreParenImpCasts()->Profile(LHSId, SemaRef.getASTContext(),\n                                            /*Canonical=*/true);\n        RHS->IgnoreParenImpCasts()->Profile(RHSId, SemaRef.getASTContext(),\n                                            /*Canonical=*/true);\n        if (XId == LHSId) {\n          E = RHS;\n          IsXLHSInRHSPart = true;\n        } else if (XId == RHSId) {\n          E = LHS;\n          IsXLHSInRHSPart = false;\n        } else {\n          ErrorLoc = AtomicInnerBinOp->getExprLoc();\n          ErrorRange = AtomicInnerBinOp->getSourceRange();\n          NoteLoc = X->getExprLoc();\n          NoteRange = X->getSourceRange();\n          ErrorFound = NotAnUpdateExpression;\n        }\n      } else {\n        ErrorLoc = AtomicInnerBinOp->getExprLoc();\n        ErrorRange = AtomicInnerBinOp->getSourceRange();\n        NoteLoc = AtomicInnerBinOp->getOperatorLoc();\n        NoteRange = SourceRange(NoteLoc, NoteLoc);\n        ErrorFound = NotABinaryOperator;\n      }\n    } else {\n      NoteLoc = ErrorLoc = AtomicBinOp->getRHS()->getExprLoc();\n      NoteRange = ErrorRange = AtomicBinOp->getRHS()->getSourceRange();\n      ErrorFound = NotABinaryExpression;\n    }\n  } else {\n    ErrorLoc = AtomicBinOp->getExprLoc();\n    ErrorRange = AtomicBinOp->getSourceRange();\n    NoteLoc = AtomicBinOp->getOperatorLoc();\n    NoteRange = SourceRange(NoteLoc, NoteLoc);\n    ErrorFound = NotAnAssignmentOp;\n  }\n  if (ErrorFound != NoError && DiagId != 0 && NoteId != 0) {\n    SemaRef.Diag(ErrorLoc, DiagId) << ErrorRange;\n    SemaRef.Diag(NoteLoc, NoteId) << ErrorFound << NoteRange;\n    return true;\n  }\n  if (SemaRef.CurContext->isDependentContext())\n    E = X = UpdateExpr = nullptr;\n  return ErrorFound != NoError;\n}\n\nbool OpenMPAtomicUpdateChecker::checkStatement(Stmt *S, unsigned DiagId,\n                                               unsigned NoteId) {\n  ExprAnalysisErrorCode ErrorFound = NoError;\n  SourceLocation ErrorLoc, NoteLoc;\n  SourceRange ErrorRange, NoteRange;\n  // Allowed constructs are:\n  //  x++;\n  //  x--;\n  //  ++x;\n  //  --x;\n  //  x binop= expr;\n  //  x = x binop expr;\n  //  x = expr binop x;\n  if (auto *AtomicBody = dyn_cast<Expr>(S)) {\n    AtomicBody = AtomicBody->IgnoreParenImpCasts();\n    if (AtomicBody->getType()->isScalarType() ||\n        AtomicBody->isInstantiationDependent()) {\n      if (const auto *AtomicCompAssignOp = dyn_cast<CompoundAssignOperator>(\n              AtomicBody->IgnoreParenImpCasts())) {\n        // Check for Compound Assignment Operation\n        Op = BinaryOperator::getOpForCompoundAssignment(\n            AtomicCompAssignOp->getOpcode());\n        OpLoc = AtomicCompAssignOp->getOperatorLoc();\n        E = AtomicCompAssignOp->getRHS();\n        X = AtomicCompAssignOp->getLHS()->IgnoreParens();\n        IsXLHSInRHSPart = true;\n      } else if (auto *AtomicBinOp = dyn_cast<BinaryOperator>(\n                     AtomicBody->IgnoreParenImpCasts())) {\n        // Check for Binary Operation\n        if (checkBinaryOperation(AtomicBinOp, DiagId, NoteId))\n          return true;\n      } else if (const auto *AtomicUnaryOp = dyn_cast<UnaryOperator>(\n                     AtomicBody->IgnoreParenImpCasts())) {\n        // Check for Unary Operation\n        if (AtomicUnaryOp->isIncrementDecrementOp()) {\n          IsPostfixUpdate = AtomicUnaryOp->isPostfix();\n          Op = AtomicUnaryOp->isIncrementOp() ? BO_Add : BO_Sub;\n          OpLoc = AtomicUnaryOp->getOperatorLoc();\n          X = AtomicUnaryOp->getSubExpr()->IgnoreParens();\n          E = SemaRef.ActOnIntegerConstant(OpLoc, /*uint64_t Val=*/1).get();\n          IsXLHSInRHSPart = true;\n        } else {\n          ErrorFound = NotAnUnaryIncDecExpression;\n          ErrorLoc = AtomicUnaryOp->getExprLoc();\n          ErrorRange = AtomicUnaryOp->getSourceRange();\n          NoteLoc = AtomicUnaryOp->getOperatorLoc();\n          NoteRange = SourceRange(NoteLoc, NoteLoc);\n        }\n      } else if (!AtomicBody->isInstantiationDependent()) {\n        ErrorFound = NotABinaryOrUnaryExpression;\n        NoteLoc = ErrorLoc = AtomicBody->getExprLoc();\n        NoteRange = ErrorRange = AtomicBody->getSourceRange();\n      }\n    } else {\n      ErrorFound = NotAScalarType;\n      NoteLoc = ErrorLoc = AtomicBody->getBeginLoc();\n      NoteRange = ErrorRange = SourceRange(NoteLoc, NoteLoc);\n    }\n  } else {\n    ErrorFound = NotAnExpression;\n    NoteLoc = ErrorLoc = S->getBeginLoc();\n    NoteRange = ErrorRange = SourceRange(NoteLoc, NoteLoc);\n  }\n  if (ErrorFound != NoError && DiagId != 0 && NoteId != 0) {\n    SemaRef.Diag(ErrorLoc, DiagId) << ErrorRange;\n    SemaRef.Diag(NoteLoc, NoteId) << ErrorFound << NoteRange;\n    return true;\n  }\n  if (SemaRef.CurContext->isDependentContext())\n    E = X = UpdateExpr = nullptr;\n  if (ErrorFound == NoError && E && X) {\n    // Build an update expression of form 'OpaqueValueExpr(x) binop\n    // OpaqueValueExpr(expr)' or 'OpaqueValueExpr(expr) binop\n    // OpaqueValueExpr(x)' and then cast it to the type of the 'x' expression.\n    auto *OVEX = new (SemaRef.getASTContext())\n        OpaqueValueExpr(X->getExprLoc(), X->getType(), VK_RValue);\n    auto *OVEExpr = new (SemaRef.getASTContext())\n        OpaqueValueExpr(E->getExprLoc(), E->getType(), VK_RValue);\n    ExprResult Update =\n        SemaRef.CreateBuiltinBinOp(OpLoc, Op, IsXLHSInRHSPart ? OVEX : OVEExpr,\n                                   IsXLHSInRHSPart ? OVEExpr : OVEX);\n    if (Update.isInvalid())\n      return true;\n    Update = SemaRef.PerformImplicitConversion(Update.get(), X->getType(),\n                                               Sema::AA_Casting);\n    if (Update.isInvalid())\n      return true;\n    UpdateExpr = Update.get();\n  }\n  return ErrorFound != NoError;\n}\n\nStmtResult Sema::ActOnOpenMPAtomicDirective(ArrayRef<OMPClause *> Clauses,\n                                            Stmt *AStmt,\n                                            SourceLocation StartLoc,\n                                            SourceLocation EndLoc) {\n  // Register location of the first atomic directive.\n  DSAStack->addAtomicDirectiveLoc(StartLoc);\n  if (!AStmt)\n    return StmtError();\n\n  // 1.2.2 OpenMP Language Terminology\n  // Structured block - An executable statement with a single entry at the\n  // top and a single exit at the bottom.\n  // The point of exit cannot be a branch out of the structured block.\n  // longjmp() and throw() must not violate the entry/exit criteria.\n  OpenMPClauseKind AtomicKind = OMPC_unknown;\n  SourceLocation AtomicKindLoc;\n  OpenMPClauseKind MemOrderKind = OMPC_unknown;\n  SourceLocation MemOrderLoc;\n  for (const OMPClause *C : Clauses) {\n    if (C->getClauseKind() == OMPC_read || C->getClauseKind() == OMPC_write ||\n        C->getClauseKind() == OMPC_update ||\n        C->getClauseKind() == OMPC_capture) {\n      if (AtomicKind != OMPC_unknown) {\n        Diag(C->getBeginLoc(), diag::err_omp_atomic_several_clauses)\n            << SourceRange(C->getBeginLoc(), C->getEndLoc());\n        Diag(AtomicKindLoc, diag::note_omp_previous_mem_order_clause)\n            << getOpenMPClauseName(AtomicKind);\n      } else {\n        AtomicKind = C->getClauseKind();\n        AtomicKindLoc = C->getBeginLoc();\n      }\n    }\n    if (C->getClauseKind() == OMPC_seq_cst ||\n        C->getClauseKind() == OMPC_acq_rel ||\n        C->getClauseKind() == OMPC_acquire ||\n        C->getClauseKind() == OMPC_release ||\n        C->getClauseKind() == OMPC_relaxed) {\n      if (MemOrderKind != OMPC_unknown) {\n        Diag(C->getBeginLoc(), diag::err_omp_several_mem_order_clauses)\n            << getOpenMPDirectiveName(OMPD_atomic) << 0\n            << SourceRange(C->getBeginLoc(), C->getEndLoc());\n        Diag(MemOrderLoc, diag::note_omp_previous_mem_order_clause)\n            << getOpenMPClauseName(MemOrderKind);\n      } else {\n        MemOrderKind = C->getClauseKind();\n        MemOrderLoc = C->getBeginLoc();\n      }\n    }\n  }\n  // OpenMP 5.0, 2.17.7 atomic Construct, Restrictions\n  // If atomic-clause is read then memory-order-clause must not be acq_rel or\n  // release.\n  // If atomic-clause is write then memory-order-clause must not be acq_rel or\n  // acquire.\n  // If atomic-clause is update or not present then memory-order-clause must not\n  // be acq_rel or acquire.\n  if ((AtomicKind == OMPC_read &&\n       (MemOrderKind == OMPC_acq_rel || MemOrderKind == OMPC_release)) ||\n      ((AtomicKind == OMPC_write || AtomicKind == OMPC_update ||\n        AtomicKind == OMPC_unknown) &&\n       (MemOrderKind == OMPC_acq_rel || MemOrderKind == OMPC_acquire))) {\n    SourceLocation Loc = AtomicKindLoc;\n    if (AtomicKind == OMPC_unknown)\n      Loc = StartLoc;\n    Diag(Loc, diag::err_omp_atomic_incompatible_mem_order_clause)\n        << getOpenMPClauseName(AtomicKind)\n        << (AtomicKind == OMPC_unknown ? 1 : 0)\n        << getOpenMPClauseName(MemOrderKind);\n    Diag(MemOrderLoc, diag::note_omp_previous_mem_order_clause)\n        << getOpenMPClauseName(MemOrderKind);\n  }\n\n  Stmt *Body = AStmt;\n  if (auto *EWC = dyn_cast<ExprWithCleanups>(Body))\n    Body = EWC->getSubExpr();\n\n  Expr *X = nullptr;\n  Expr *V = nullptr;\n  Expr *E = nullptr;\n  Expr *UE = nullptr;\n  bool IsXLHSInRHSPart = false;\n  bool IsPostfixUpdate = false;\n  // OpenMP [2.12.6, atomic Construct]\n  // In the next expressions:\n  // * x and v (as applicable) are both l-value expressions with scalar type.\n  // * During the execution of an atomic region, multiple syntactic\n  // occurrences of x must designate the same storage location.\n  // * Neither of v and expr (as applicable) may access the storage location\n  // designated by x.\n  // * Neither of x and expr (as applicable) may access the storage location\n  // designated by v.\n  // * expr is an expression with scalar type.\n  // * binop is one of +, *, -, /, &, ^, |, <<, or >>.\n  // * binop, binop=, ++, and -- are not overloaded operators.\n  // * The expression x binop expr must be numerically equivalent to x binop\n  // (expr). This requirement is satisfied if the operators in expr have\n  // precedence greater than binop, or by using parentheses around expr or\n  // subexpressions of expr.\n  // * The expression expr binop x must be numerically equivalent to (expr)\n  // binop x. This requirement is satisfied if the operators in expr have\n  // precedence equal to or greater than binop, or by using parentheses around\n  // expr or subexpressions of expr.\n  // * For forms that allow multiple occurrences of x, the number of times\n  // that x is evaluated is unspecified.\n  if (AtomicKind == OMPC_read) {\n    enum {\n      NotAnExpression,\n      NotAnAssignmentOp,\n      NotAScalarType,\n      NotAnLValue,\n      NoError\n    } ErrorFound = NoError;\n    SourceLocation ErrorLoc, NoteLoc;\n    SourceRange ErrorRange, NoteRange;\n    // If clause is read:\n    //  v = x;\n    if (const auto *AtomicBody = dyn_cast<Expr>(Body)) {\n      const auto *AtomicBinOp =\n          dyn_cast<BinaryOperator>(AtomicBody->IgnoreParenImpCasts());\n      if (AtomicBinOp && AtomicBinOp->getOpcode() == BO_Assign) {\n        X = AtomicBinOp->getRHS()->IgnoreParenImpCasts();\n        V = AtomicBinOp->getLHS()->IgnoreParenImpCasts();\n        if ((X->isInstantiationDependent() || X->getType()->isScalarType()) &&\n            (V->isInstantiationDependent() || V->getType()->isScalarType())) {\n          if (!X->isLValue() || !V->isLValue()) {\n            const Expr *NotLValueExpr = X->isLValue() ? V : X;\n            ErrorFound = NotAnLValue;\n            ErrorLoc = AtomicBinOp->getExprLoc();\n            ErrorRange = AtomicBinOp->getSourceRange();\n            NoteLoc = NotLValueExpr->getExprLoc();\n            NoteRange = NotLValueExpr->getSourceRange();\n          }\n        } else if (!X->isInstantiationDependent() ||\n                   !V->isInstantiationDependent()) {\n          const Expr *NotScalarExpr =\n              (X->isInstantiationDependent() || X->getType()->isScalarType())\n                  ? V\n                  : X;\n          ErrorFound = NotAScalarType;\n          ErrorLoc = AtomicBinOp->getExprLoc();\n          ErrorRange = AtomicBinOp->getSourceRange();\n          NoteLoc = NotScalarExpr->getExprLoc();\n          NoteRange = NotScalarExpr->getSourceRange();\n        }\n      } else if (!AtomicBody->isInstantiationDependent()) {\n        ErrorFound = NotAnAssignmentOp;\n        ErrorLoc = AtomicBody->getExprLoc();\n        ErrorRange = AtomicBody->getSourceRange();\n        NoteLoc = AtomicBinOp ? AtomicBinOp->getOperatorLoc()\n                              : AtomicBody->getExprLoc();\n        NoteRange = AtomicBinOp ? AtomicBinOp->getSourceRange()\n                                : AtomicBody->getSourceRange();\n      }\n    } else {\n      ErrorFound = NotAnExpression;\n      NoteLoc = ErrorLoc = Body->getBeginLoc();\n      NoteRange = ErrorRange = SourceRange(NoteLoc, NoteLoc);\n    }\n    if (ErrorFound != NoError) {\n      Diag(ErrorLoc, diag::err_omp_atomic_read_not_expression_statement)\n          << ErrorRange;\n      Diag(NoteLoc, diag::note_omp_atomic_read_write) << ErrorFound\n                                                      << NoteRange;\n      return StmtError();\n    }\n    if (CurContext->isDependentContext())\n      V = X = nullptr;\n  } else if (AtomicKind == OMPC_write) {\n    enum {\n      NotAnExpression,\n      NotAnAssignmentOp,\n      NotAScalarType,\n      NotAnLValue,\n      NoError\n    } ErrorFound = NoError;\n    SourceLocation ErrorLoc, NoteLoc;\n    SourceRange ErrorRange, NoteRange;\n    // If clause is write:\n    //  x = expr;\n    if (const auto *AtomicBody = dyn_cast<Expr>(Body)) {\n      const auto *AtomicBinOp =\n          dyn_cast<BinaryOperator>(AtomicBody->IgnoreParenImpCasts());\n      if (AtomicBinOp && AtomicBinOp->getOpcode() == BO_Assign) {\n        X = AtomicBinOp->getLHS();\n        E = AtomicBinOp->getRHS();\n        if ((X->isInstantiationDependent() || X->getType()->isScalarType()) &&\n            (E->isInstantiationDependent() || E->getType()->isScalarType())) {\n          if (!X->isLValue()) {\n            ErrorFound = NotAnLValue;\n            ErrorLoc = AtomicBinOp->getExprLoc();\n            ErrorRange = AtomicBinOp->getSourceRange();\n            NoteLoc = X->getExprLoc();\n            NoteRange = X->getSourceRange();\n          }\n        } else if (!X->isInstantiationDependent() ||\n                   !E->isInstantiationDependent()) {\n          const Expr *NotScalarExpr =\n              (X->isInstantiationDependent() || X->getType()->isScalarType())\n                  ? E\n                  : X;\n          ErrorFound = NotAScalarType;\n          ErrorLoc = AtomicBinOp->getExprLoc();\n          ErrorRange = AtomicBinOp->getSourceRange();\n          NoteLoc = NotScalarExpr->getExprLoc();\n          NoteRange = NotScalarExpr->getSourceRange();\n        }\n      } else if (!AtomicBody->isInstantiationDependent()) {\n        ErrorFound = NotAnAssignmentOp;\n        ErrorLoc = AtomicBody->getExprLoc();\n        ErrorRange = AtomicBody->getSourceRange();\n        NoteLoc = AtomicBinOp ? AtomicBinOp->getOperatorLoc()\n                              : AtomicBody->getExprLoc();\n        NoteRange = AtomicBinOp ? AtomicBinOp->getSourceRange()\n                                : AtomicBody->getSourceRange();\n      }\n    } else {\n      ErrorFound = NotAnExpression;\n      NoteLoc = ErrorLoc = Body->getBeginLoc();\n      NoteRange = ErrorRange = SourceRange(NoteLoc, NoteLoc);\n    }\n    if (ErrorFound != NoError) {\n      Diag(ErrorLoc, diag::err_omp_atomic_write_not_expression_statement)\n          << ErrorRange;\n      Diag(NoteLoc, diag::note_omp_atomic_read_write) << ErrorFound\n                                                      << NoteRange;\n      return StmtError();\n    }\n    if (CurContext->isDependentContext())\n      E = X = nullptr;\n  } else if (AtomicKind == OMPC_update || AtomicKind == OMPC_unknown) {\n    // If clause is update:\n    //  x++;\n    //  x--;\n    //  ++x;\n    //  --x;\n    //  x binop= expr;\n    //  x = x binop expr;\n    //  x = expr binop x;\n    OpenMPAtomicUpdateChecker Checker(*this);\n    if (Checker.checkStatement(\n            Body, (AtomicKind == OMPC_update)\n                      ? diag::err_omp_atomic_update_not_expression_statement\n                      : diag::err_omp_atomic_not_expression_statement,\n            diag::note_omp_atomic_update))\n      return StmtError();\n    if (!CurContext->isDependentContext()) {\n      E = Checker.getExpr();\n      X = Checker.getX();\n      UE = Checker.getUpdateExpr();\n      IsXLHSInRHSPart = Checker.isXLHSInRHSPart();\n    }\n  } else if (AtomicKind == OMPC_capture) {\n    enum {\n      NotAnAssignmentOp,\n      NotACompoundStatement,\n      NotTwoSubstatements,\n      NotASpecificExpression,\n      NoError\n    } ErrorFound = NoError;\n    SourceLocation ErrorLoc, NoteLoc;\n    SourceRange ErrorRange, NoteRange;\n    if (const auto *AtomicBody = dyn_cast<Expr>(Body)) {\n      // If clause is a capture:\n      //  v = x++;\n      //  v = x--;\n      //  v = ++x;\n      //  v = --x;\n      //  v = x binop= expr;\n      //  v = x = x binop expr;\n      //  v = x = expr binop x;\n      const auto *AtomicBinOp =\n          dyn_cast<BinaryOperator>(AtomicBody->IgnoreParenImpCasts());\n      if (AtomicBinOp && AtomicBinOp->getOpcode() == BO_Assign) {\n        V = AtomicBinOp->getLHS();\n        Body = AtomicBinOp->getRHS()->IgnoreParenImpCasts();\n        OpenMPAtomicUpdateChecker Checker(*this);\n        if (Checker.checkStatement(\n                Body, diag::err_omp_atomic_capture_not_expression_statement,\n                diag::note_omp_atomic_update))\n          return StmtError();\n        E = Checker.getExpr();\n        X = Checker.getX();\n        UE = Checker.getUpdateExpr();\n        IsXLHSInRHSPart = Checker.isXLHSInRHSPart();\n        IsPostfixUpdate = Checker.isPostfixUpdate();\n      } else if (!AtomicBody->isInstantiationDependent()) {\n        ErrorLoc = AtomicBody->getExprLoc();\n        ErrorRange = AtomicBody->getSourceRange();\n        NoteLoc = AtomicBinOp ? AtomicBinOp->getOperatorLoc()\n                              : AtomicBody->getExprLoc();\n        NoteRange = AtomicBinOp ? AtomicBinOp->getSourceRange()\n                                : AtomicBody->getSourceRange();\n        ErrorFound = NotAnAssignmentOp;\n      }\n      if (ErrorFound != NoError) {\n        Diag(ErrorLoc, diag::err_omp_atomic_capture_not_expression_statement)\n            << ErrorRange;\n        Diag(NoteLoc, diag::note_omp_atomic_capture) << ErrorFound << NoteRange;\n        return StmtError();\n      }\n      if (CurContext->isDependentContext())\n        UE = V = E = X = nullptr;\n    } else {\n      // If clause is a capture:\n      //  { v = x; x = expr; }\n      //  { v = x; x++; }\n      //  { v = x; x--; }\n      //  { v = x; ++x; }\n      //  { v = x; --x; }\n      //  { v = x; x binop= expr; }\n      //  { v = x; x = x binop expr; }\n      //  { v = x; x = expr binop x; }\n      //  { x++; v = x; }\n      //  { x--; v = x; }\n      //  { ++x; v = x; }\n      //  { --x; v = x; }\n      //  { x binop= expr; v = x; }\n      //  { x = x binop expr; v = x; }\n      //  { x = expr binop x; v = x; }\n      if (auto *CS = dyn_cast<CompoundStmt>(Body)) {\n        // Check that this is { expr1; expr2; }\n        if (CS->size() == 2) {\n          Stmt *First = CS->body_front();\n          Stmt *Second = CS->body_back();\n          if (auto *EWC = dyn_cast<ExprWithCleanups>(First))\n            First = EWC->getSubExpr()->IgnoreParenImpCasts();\n          if (auto *EWC = dyn_cast<ExprWithCleanups>(Second))\n            Second = EWC->getSubExpr()->IgnoreParenImpCasts();\n          // Need to find what subexpression is 'v' and what is 'x'.\n          OpenMPAtomicUpdateChecker Checker(*this);\n          bool IsUpdateExprFound = !Checker.checkStatement(Second);\n          BinaryOperator *BinOp = nullptr;\n          if (IsUpdateExprFound) {\n            BinOp = dyn_cast<BinaryOperator>(First);\n            IsUpdateExprFound = BinOp && BinOp->getOpcode() == BO_Assign;\n          }\n          if (IsUpdateExprFound && !CurContext->isDependentContext()) {\n            //  { v = x; x++; }\n            //  { v = x; x--; }\n            //  { v = x; ++x; }\n            //  { v = x; --x; }\n            //  { v = x; x binop= expr; }\n            //  { v = x; x = x binop expr; }\n            //  { v = x; x = expr binop x; }\n            // Check that the first expression has form v = x.\n            Expr *PossibleX = BinOp->getRHS()->IgnoreParenImpCasts();\n            llvm::FoldingSetNodeID XId, PossibleXId;\n            Checker.getX()->Profile(XId, Context, /*Canonical=*/true);\n            PossibleX->Profile(PossibleXId, Context, /*Canonical=*/true);\n            IsUpdateExprFound = XId == PossibleXId;\n            if (IsUpdateExprFound) {\n              V = BinOp->getLHS();\n              X = Checker.getX();\n              E = Checker.getExpr();\n              UE = Checker.getUpdateExpr();\n              IsXLHSInRHSPart = Checker.isXLHSInRHSPart();\n              IsPostfixUpdate = true;\n            }\n          }\n          if (!IsUpdateExprFound) {\n            IsUpdateExprFound = !Checker.checkStatement(First);\n            BinOp = nullptr;\n            if (IsUpdateExprFound) {\n              BinOp = dyn_cast<BinaryOperator>(Second);\n              IsUpdateExprFound = BinOp && BinOp->getOpcode() == BO_Assign;\n            }\n            if (IsUpdateExprFound && !CurContext->isDependentContext()) {\n              //  { x++; v = x; }\n              //  { x--; v = x; }\n              //  { ++x; v = x; }\n              //  { --x; v = x; }\n              //  { x binop= expr; v = x; }\n              //  { x = x binop expr; v = x; }\n              //  { x = expr binop x; v = x; }\n              // Check that the second expression has form v = x.\n              Expr *PossibleX = BinOp->getRHS()->IgnoreParenImpCasts();\n              llvm::FoldingSetNodeID XId, PossibleXId;\n              Checker.getX()->Profile(XId, Context, /*Canonical=*/true);\n              PossibleX->Profile(PossibleXId, Context, /*Canonical=*/true);\n              IsUpdateExprFound = XId == PossibleXId;\n              if (IsUpdateExprFound) {\n                V = BinOp->getLHS();\n                X = Checker.getX();\n                E = Checker.getExpr();\n                UE = Checker.getUpdateExpr();\n                IsXLHSInRHSPart = Checker.isXLHSInRHSPart();\n                IsPostfixUpdate = false;\n              }\n            }\n          }\n          if (!IsUpdateExprFound) {\n            //  { v = x; x = expr; }\n            auto *FirstExpr = dyn_cast<Expr>(First);\n            auto *SecondExpr = dyn_cast<Expr>(Second);\n            if (!FirstExpr || !SecondExpr ||\n                !(FirstExpr->isInstantiationDependent() ||\n                  SecondExpr->isInstantiationDependent())) {\n              auto *FirstBinOp = dyn_cast<BinaryOperator>(First);\n              if (!FirstBinOp || FirstBinOp->getOpcode() != BO_Assign) {\n                ErrorFound = NotAnAssignmentOp;\n                NoteLoc = ErrorLoc = FirstBinOp ? FirstBinOp->getOperatorLoc()\n                                                : First->getBeginLoc();\n                NoteRange = ErrorRange = FirstBinOp\n                                             ? FirstBinOp->getSourceRange()\n                                             : SourceRange(ErrorLoc, ErrorLoc);\n              } else {\n                auto *SecondBinOp = dyn_cast<BinaryOperator>(Second);\n                if (!SecondBinOp || SecondBinOp->getOpcode() != BO_Assign) {\n                  ErrorFound = NotAnAssignmentOp;\n                  NoteLoc = ErrorLoc = SecondBinOp\n                                           ? SecondBinOp->getOperatorLoc()\n                                           : Second->getBeginLoc();\n                  NoteRange = ErrorRange =\n                      SecondBinOp ? SecondBinOp->getSourceRange()\n                                  : SourceRange(ErrorLoc, ErrorLoc);\n                } else {\n                  Expr *PossibleXRHSInFirst =\n                      FirstBinOp->getRHS()->IgnoreParenImpCasts();\n                  Expr *PossibleXLHSInSecond =\n                      SecondBinOp->getLHS()->IgnoreParenImpCasts();\n                  llvm::FoldingSetNodeID X1Id, X2Id;\n                  PossibleXRHSInFirst->Profile(X1Id, Context,\n                                               /*Canonical=*/true);\n                  PossibleXLHSInSecond->Profile(X2Id, Context,\n                                                /*Canonical=*/true);\n                  IsUpdateExprFound = X1Id == X2Id;\n                  if (IsUpdateExprFound) {\n                    V = FirstBinOp->getLHS();\n                    X = SecondBinOp->getLHS();\n                    E = SecondBinOp->getRHS();\n                    UE = nullptr;\n                    IsXLHSInRHSPart = false;\n                    IsPostfixUpdate = true;\n                  } else {\n                    ErrorFound = NotASpecificExpression;\n                    ErrorLoc = FirstBinOp->getExprLoc();\n                    ErrorRange = FirstBinOp->getSourceRange();\n                    NoteLoc = SecondBinOp->getLHS()->getExprLoc();\n                    NoteRange = SecondBinOp->getRHS()->getSourceRange();\n                  }\n                }\n              }\n            }\n          }\n        } else {\n          NoteLoc = ErrorLoc = Body->getBeginLoc();\n          NoteRange = ErrorRange =\n              SourceRange(Body->getBeginLoc(), Body->getBeginLoc());\n          ErrorFound = NotTwoSubstatements;\n        }\n      } else {\n        NoteLoc = ErrorLoc = Body->getBeginLoc();\n        NoteRange = ErrorRange =\n            SourceRange(Body->getBeginLoc(), Body->getBeginLoc());\n        ErrorFound = NotACompoundStatement;\n      }\n      if (ErrorFound != NoError) {\n        Diag(ErrorLoc, diag::err_omp_atomic_capture_not_compound_statement)\n            << ErrorRange;\n        Diag(NoteLoc, diag::note_omp_atomic_capture) << ErrorFound << NoteRange;\n        return StmtError();\n      }\n      if (CurContext->isDependentContext())\n        UE = V = E = X = nullptr;\n    }\n  }\n\n  setFunctionHasBranchProtectedScope();\n\n  return OMPAtomicDirective::Create(Context, StartLoc, EndLoc, Clauses, AStmt,\n                                    X, V, E, UE, IsXLHSInRHSPart,\n                                    IsPostfixUpdate);\n}\n\nStmtResult Sema::ActOnOpenMPTargetDirective(ArrayRef<OMPClause *> Clauses,\n                                            Stmt *AStmt,\n                                            SourceLocation StartLoc,\n                                            SourceLocation EndLoc) {\n  if (!AStmt)\n    return StmtError();\n\n  auto *CS = cast<CapturedStmt>(AStmt);\n  // 1.2.2 OpenMP Language Terminology\n  // Structured block - An executable statement with a single entry at the\n  // top and a single exit at the bottom.\n  // The point of exit cannot be a branch out of the structured block.\n  // longjmp() and throw() must not violate the entry/exit criteria.\n  CS->getCapturedDecl()->setNothrow();\n  for (int ThisCaptureLevel = getOpenMPCaptureLevels(OMPD_target);\n       ThisCaptureLevel > 1; --ThisCaptureLevel) {\n    CS = cast<CapturedStmt>(CS->getCapturedStmt());\n    // 1.2.2 OpenMP Language Terminology\n    // Structured block - An executable statement with a single entry at the\n    // top and a single exit at the bottom.\n    // The point of exit cannot be a branch out of the structured block.\n    // longjmp() and throw() must not violate the entry/exit criteria.\n    CS->getCapturedDecl()->setNothrow();\n  }\n\n  // OpenMP [2.16, Nesting of Regions]\n  // If specified, a teams construct must be contained within a target\n  // construct. That target construct must contain no statements or directives\n  // outside of the teams construct.\n  if (DSAStack->hasInnerTeamsRegion()) {\n    const Stmt *S = CS->IgnoreContainers(/*IgnoreCaptured=*/true);\n    bool OMPTeamsFound = true;\n    if (const auto *CS = dyn_cast<CompoundStmt>(S)) {\n      auto I = CS->body_begin();\n      while (I != CS->body_end()) {\n        const auto *OED = dyn_cast<OMPExecutableDirective>(*I);\n        if (!OED || !isOpenMPTeamsDirective(OED->getDirectiveKind()) ||\n            OMPTeamsFound) {\n\n          OMPTeamsFound = false;\n          break;\n        }\n        ++I;\n      }\n      assert(I != CS->body_end() && \"Not found statement\");\n      S = *I;\n    } else {\n      const auto *OED = dyn_cast<OMPExecutableDirective>(S);\n      OMPTeamsFound = OED && isOpenMPTeamsDirective(OED->getDirectiveKind());\n    }\n    if (!OMPTeamsFound) {\n      Diag(StartLoc, diag::err_omp_target_contains_not_only_teams);\n      Diag(DSAStack->getInnerTeamsRegionLoc(),\n           diag::note_omp_nested_teams_construct_here);\n      Diag(S->getBeginLoc(), diag::note_omp_nested_statement_here)\n          << isa<OMPExecutableDirective>(S);\n      return StmtError();\n    }\n  }\n\n  setFunctionHasBranchProtectedScope();\n\n  return OMPTargetDirective::Create(Context, StartLoc, EndLoc, Clauses, AStmt);\n}\n\nStmtResult\nSema::ActOnOpenMPTargetParallelDirective(ArrayRef<OMPClause *> Clauses,\n                                         Stmt *AStmt, SourceLocation StartLoc,\n                                         SourceLocation EndLoc) {\n  if (!AStmt)\n    return StmtError();\n\n  auto *CS = cast<CapturedStmt>(AStmt);\n  // 1.2.2 OpenMP Language Terminology\n  // Structured block - An executable statement with a single entry at the\n  // top and a single exit at the bottom.\n  // The point of exit cannot be a branch out of the structured block.\n  // longjmp() and throw() must not violate the entry/exit criteria.\n  CS->getCapturedDecl()->setNothrow();\n  for (int ThisCaptureLevel = getOpenMPCaptureLevels(OMPD_target_parallel);\n       ThisCaptureLevel > 1; --ThisCaptureLevel) {\n    CS = cast<CapturedStmt>(CS->getCapturedStmt());\n    // 1.2.2 OpenMP Language Terminology\n    // Structured block - An executable statement with a single entry at the\n    // top and a single exit at the bottom.\n    // The point of exit cannot be a branch out of the structured block.\n    // longjmp() and throw() must not violate the entry/exit criteria.\n    CS->getCapturedDecl()->setNothrow();\n  }\n\n  setFunctionHasBranchProtectedScope();\n\n  return OMPTargetParallelDirective::Create(\n      Context, StartLoc, EndLoc, Clauses, AStmt,\n      DSAStack->getTaskgroupReductionRef(), DSAStack->isCancelRegion());\n}\n\nStmtResult Sema::ActOnOpenMPTargetParallelForDirective(\n    ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n    SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA) {\n  if (!AStmt)\n    return StmtError();\n\n  auto *CS = cast<CapturedStmt>(AStmt);\n  // 1.2.2 OpenMP Language Terminology\n  // Structured block - An executable statement with a single entry at the\n  // top and a single exit at the bottom.\n  // The point of exit cannot be a branch out of the structured block.\n  // longjmp() and throw() must not violate the entry/exit criteria.\n  CS->getCapturedDecl()->setNothrow();\n  for (int ThisCaptureLevel = getOpenMPCaptureLevels(OMPD_target_parallel_for);\n       ThisCaptureLevel > 1; --ThisCaptureLevel) {\n    CS = cast<CapturedStmt>(CS->getCapturedStmt());\n    // 1.2.2 OpenMP Language Terminology\n    // Structured block - An executable statement with a single entry at the\n    // top and a single exit at the bottom.\n    // The point of exit cannot be a branch out of the structured block.\n    // longjmp() and throw() must not violate the entry/exit criteria.\n    CS->getCapturedDecl()->setNothrow();\n  }\n\n  OMPLoopBasedDirective::HelperExprs B;\n  // In presence of clause 'collapse' or 'ordered' with number of loops, it will\n  // define the nested loops number.\n  unsigned NestedLoopCount =\n      checkOpenMPLoop(OMPD_target_parallel_for, getCollapseNumberExpr(Clauses),\n                      getOrderedNumberExpr(Clauses), CS, *this, *DSAStack,\n                      VarsWithImplicitDSA, B);\n  if (NestedLoopCount == 0)\n    return StmtError();\n\n  assert((CurContext->isDependentContext() || B.builtAll()) &&\n         \"omp target parallel for loop exprs were not built\");\n\n  if (!CurContext->isDependentContext()) {\n    // Finalize the clauses that need pre-built expressions for CodeGen.\n    for (OMPClause *C : Clauses) {\n      if (auto *LC = dyn_cast<OMPLinearClause>(C))\n        if (FinishOpenMPLinearClause(*LC, cast<DeclRefExpr>(B.IterationVarRef),\n                                     B.NumIterations, *this, CurScope,\n                                     DSAStack))\n          return StmtError();\n    }\n  }\n\n  setFunctionHasBranchProtectedScope();\n  return OMPTargetParallelForDirective::Create(\n      Context, StartLoc, EndLoc, NestedLoopCount, Clauses, AStmt, B,\n      DSAStack->getTaskgroupReductionRef(), DSAStack->isCancelRegion());\n}\n\n/// Check for existence of a map clause in the list of clauses.\nstatic bool hasClauses(ArrayRef<OMPClause *> Clauses,\n                       const OpenMPClauseKind K) {\n  return llvm::any_of(\n      Clauses, [K](const OMPClause *C) { return C->getClauseKind() == K; });\n}\n\ntemplate <typename... Params>\nstatic bool hasClauses(ArrayRef<OMPClause *> Clauses, const OpenMPClauseKind K,\n                       const Params... ClauseTypes) {\n  return hasClauses(Clauses, K) || hasClauses(Clauses, ClauseTypes...);\n}\n\nStmtResult Sema::ActOnOpenMPTargetDataDirective(ArrayRef<OMPClause *> Clauses,\n                                                Stmt *AStmt,\n                                                SourceLocation StartLoc,\n                                                SourceLocation EndLoc) {\n  if (!AStmt)\n    return StmtError();\n\n  assert(isa<CapturedStmt>(AStmt) && \"Captured statement expected\");\n\n  // OpenMP [2.12.2, target data Construct, Restrictions]\n  // At least one map, use_device_addr or use_device_ptr clause must appear on\n  // the directive.\n  if (!hasClauses(Clauses, OMPC_map, OMPC_use_device_ptr) &&\n      (LangOpts.OpenMP < 50 || !hasClauses(Clauses, OMPC_use_device_addr))) {\n    StringRef Expected;\n    if (LangOpts.OpenMP < 50)\n      Expected = \"'map' or 'use_device_ptr'\";\n    else\n      Expected = \"'map', 'use_device_ptr', or 'use_device_addr'\";\n    Diag(StartLoc, diag::err_omp_no_clause_for_directive)\n        << Expected << getOpenMPDirectiveName(OMPD_target_data);\n    return StmtError();\n  }\n\n  setFunctionHasBranchProtectedScope();\n\n  return OMPTargetDataDirective::Create(Context, StartLoc, EndLoc, Clauses,\n                                        AStmt);\n}\n\nStmtResult\nSema::ActOnOpenMPTargetEnterDataDirective(ArrayRef<OMPClause *> Clauses,\n                                          SourceLocation StartLoc,\n                                          SourceLocation EndLoc, Stmt *AStmt) {\n  if (!AStmt)\n    return StmtError();\n\n  auto *CS = cast<CapturedStmt>(AStmt);\n  // 1.2.2 OpenMP Language Terminology\n  // Structured block - An executable statement with a single entry at the\n  // top and a single exit at the bottom.\n  // The point of exit cannot be a branch out of the structured block.\n  // longjmp() and throw() must not violate the entry/exit criteria.\n  CS->getCapturedDecl()->setNothrow();\n  for (int ThisCaptureLevel = getOpenMPCaptureLevels(OMPD_target_enter_data);\n       ThisCaptureLevel > 1; --ThisCaptureLevel) {\n    CS = cast<CapturedStmt>(CS->getCapturedStmt());\n    // 1.2.2 OpenMP Language Terminology\n    // Structured block - An executable statement with a single entry at the\n    // top and a single exit at the bottom.\n    // The point of exit cannot be a branch out of the structured block.\n    // longjmp() and throw() must not violate the entry/exit criteria.\n    CS->getCapturedDecl()->setNothrow();\n  }\n\n  // OpenMP [2.10.2, Restrictions, p. 99]\n  // At least one map clause must appear on the directive.\n  if (!hasClauses(Clauses, OMPC_map)) {\n    Diag(StartLoc, diag::err_omp_no_clause_for_directive)\n        << \"'map'\" << getOpenMPDirectiveName(OMPD_target_enter_data);\n    return StmtError();\n  }\n\n  return OMPTargetEnterDataDirective::Create(Context, StartLoc, EndLoc, Clauses,\n                                             AStmt);\n}\n\nStmtResult\nSema::ActOnOpenMPTargetExitDataDirective(ArrayRef<OMPClause *> Clauses,\n                                         SourceLocation StartLoc,\n                                         SourceLocation EndLoc, Stmt *AStmt) {\n  if (!AStmt)\n    return StmtError();\n\n  auto *CS = cast<CapturedStmt>(AStmt);\n  // 1.2.2 OpenMP Language Terminology\n  // Structured block - An executable statement with a single entry at the\n  // top and a single exit at the bottom.\n  // The point of exit cannot be a branch out of the structured block.\n  // longjmp() and throw() must not violate the entry/exit criteria.\n  CS->getCapturedDecl()->setNothrow();\n  for (int ThisCaptureLevel = getOpenMPCaptureLevels(OMPD_target_exit_data);\n       ThisCaptureLevel > 1; --ThisCaptureLevel) {\n    CS = cast<CapturedStmt>(CS->getCapturedStmt());\n    // 1.2.2 OpenMP Language Terminology\n    // Structured block - An executable statement with a single entry at the\n    // top and a single exit at the bottom.\n    // The point of exit cannot be a branch out of the structured block.\n    // longjmp() and throw() must not violate the entry/exit criteria.\n    CS->getCapturedDecl()->setNothrow();\n  }\n\n  // OpenMP [2.10.3, Restrictions, p. 102]\n  // At least one map clause must appear on the directive.\n  if (!hasClauses(Clauses, OMPC_map)) {\n    Diag(StartLoc, diag::err_omp_no_clause_for_directive)\n        << \"'map'\" << getOpenMPDirectiveName(OMPD_target_exit_data);\n    return StmtError();\n  }\n\n  return OMPTargetExitDataDirective::Create(Context, StartLoc, EndLoc, Clauses,\n                                            AStmt);\n}\n\nStmtResult Sema::ActOnOpenMPTargetUpdateDirective(ArrayRef<OMPClause *> Clauses,\n                                                  SourceLocation StartLoc,\n                                                  SourceLocation EndLoc,\n                                                  Stmt *AStmt) {\n  if (!AStmt)\n    return StmtError();\n\n  auto *CS = cast<CapturedStmt>(AStmt);\n  // 1.2.2 OpenMP Language Terminology\n  // Structured block - An executable statement with a single entry at the\n  // top and a single exit at the bottom.\n  // The point of exit cannot be a branch out of the structured block.\n  // longjmp() and throw() must not violate the entry/exit criteria.\n  CS->getCapturedDecl()->setNothrow();\n  for (int ThisCaptureLevel = getOpenMPCaptureLevels(OMPD_target_update);\n       ThisCaptureLevel > 1; --ThisCaptureLevel) {\n    CS = cast<CapturedStmt>(CS->getCapturedStmt());\n    // 1.2.2 OpenMP Language Terminology\n    // Structured block - An executable statement with a single entry at the\n    // top and a single exit at the bottom.\n    // The point of exit cannot be a branch out of the structured block.\n    // longjmp() and throw() must not violate the entry/exit criteria.\n    CS->getCapturedDecl()->setNothrow();\n  }\n\n  if (!hasClauses(Clauses, OMPC_to, OMPC_from)) {\n    Diag(StartLoc, diag::err_omp_at_least_one_motion_clause_required);\n    return StmtError();\n  }\n  return OMPTargetUpdateDirective::Create(Context, StartLoc, EndLoc, Clauses,\n                                          AStmt);\n}\n\nStmtResult Sema::ActOnOpenMPTeamsDirective(ArrayRef<OMPClause *> Clauses,\n                                           Stmt *AStmt, SourceLocation StartLoc,\n                                           SourceLocation EndLoc) {\n  if (!AStmt)\n    return StmtError();\n\n  auto *CS = cast<CapturedStmt>(AStmt);\n  // 1.2.2 OpenMP Language Terminology\n  // Structured block - An executable statement with a single entry at the\n  // top and a single exit at the bottom.\n  // The point of exit cannot be a branch out of the structured block.\n  // longjmp() and throw() must not violate the entry/exit criteria.\n  CS->getCapturedDecl()->setNothrow();\n\n  setFunctionHasBranchProtectedScope();\n\n  DSAStack->setParentTeamsRegionLoc(StartLoc);\n\n  return OMPTeamsDirective::Create(Context, StartLoc, EndLoc, Clauses, AStmt);\n}\n\nStmtResult\nSema::ActOnOpenMPCancellationPointDirective(SourceLocation StartLoc,\n                                            SourceLocation EndLoc,\n                                            OpenMPDirectiveKind CancelRegion) {\n  if (DSAStack->isParentNowaitRegion()) {\n    Diag(StartLoc, diag::err_omp_parent_cancel_region_nowait) << 0;\n    return StmtError();\n  }\n  if (DSAStack->isParentOrderedRegion()) {\n    Diag(StartLoc, diag::err_omp_parent_cancel_region_ordered) << 0;\n    return StmtError();\n  }\n  return OMPCancellationPointDirective::Create(Context, StartLoc, EndLoc,\n                                               CancelRegion);\n}\n\nStmtResult Sema::ActOnOpenMPCancelDirective(ArrayRef<OMPClause *> Clauses,\n                                            SourceLocation StartLoc,\n                                            SourceLocation EndLoc,\n                                            OpenMPDirectiveKind CancelRegion) {\n  if (DSAStack->isParentNowaitRegion()) {\n    Diag(StartLoc, diag::err_omp_parent_cancel_region_nowait) << 1;\n    return StmtError();\n  }\n  if (DSAStack->isParentOrderedRegion()) {\n    Diag(StartLoc, diag::err_omp_parent_cancel_region_ordered) << 1;\n    return StmtError();\n  }\n  DSAStack->setParentCancelRegion(/*Cancel=*/true);\n  return OMPCancelDirective::Create(Context, StartLoc, EndLoc, Clauses,\n                                    CancelRegion);\n}\n\nstatic bool checkGrainsizeNumTasksClauses(Sema &S,\n                                          ArrayRef<OMPClause *> Clauses) {\n  const OMPClause *PrevClause = nullptr;\n  bool ErrorFound = false;\n  for (const OMPClause *C : Clauses) {\n    if (C->getClauseKind() == OMPC_grainsize ||\n        C->getClauseKind() == OMPC_num_tasks) {\n      if (!PrevClause)\n        PrevClause = C;\n      else if (PrevClause->getClauseKind() != C->getClauseKind()) {\n        S.Diag(C->getBeginLoc(), diag::err_omp_clauses_mutually_exclusive)\n            << getOpenMPClauseName(C->getClauseKind())\n            << getOpenMPClauseName(PrevClause->getClauseKind());\n        S.Diag(PrevClause->getBeginLoc(), diag::note_omp_previous_clause)\n            << getOpenMPClauseName(PrevClause->getClauseKind());\n        ErrorFound = true;\n      }\n    }\n  }\n  return ErrorFound;\n}\n\nstatic bool checkReductionClauseWithNogroup(Sema &S,\n                                            ArrayRef<OMPClause *> Clauses) {\n  const OMPClause *ReductionClause = nullptr;\n  const OMPClause *NogroupClause = nullptr;\n  for (const OMPClause *C : Clauses) {\n    if (C->getClauseKind() == OMPC_reduction) {\n      ReductionClause = C;\n      if (NogroupClause)\n        break;\n      continue;\n    }\n    if (C->getClauseKind() == OMPC_nogroup) {\n      NogroupClause = C;\n      if (ReductionClause)\n        break;\n      continue;\n    }\n  }\n  if (ReductionClause && NogroupClause) {\n    S.Diag(ReductionClause->getBeginLoc(), diag::err_omp_reduction_with_nogroup)\n        << SourceRange(NogroupClause->getBeginLoc(),\n                       NogroupClause->getEndLoc());\n    return true;\n  }\n  return false;\n}\n\nStmtResult Sema::ActOnOpenMPTaskLoopDirective(\n    ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n    SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA) {\n  if (!AStmt)\n    return StmtError();\n\n  assert(isa<CapturedStmt>(AStmt) && \"Captured statement expected\");\n  OMPLoopBasedDirective::HelperExprs B;\n  // In presence of clause 'collapse' or 'ordered' with number of loops, it will\n  // define the nested loops number.\n  unsigned NestedLoopCount =\n      checkOpenMPLoop(OMPD_taskloop, getCollapseNumberExpr(Clauses),\n                      /*OrderedLoopCountExpr=*/nullptr, AStmt, *this, *DSAStack,\n                      VarsWithImplicitDSA, B);\n  if (NestedLoopCount == 0)\n    return StmtError();\n\n  assert((CurContext->isDependentContext() || B.builtAll()) &&\n         \"omp for loop exprs were not built\");\n\n  // OpenMP, [2.9.2 taskloop Construct, Restrictions]\n  // The grainsize clause and num_tasks clause are mutually exclusive and may\n  // not appear on the same taskloop directive.\n  if (checkGrainsizeNumTasksClauses(*this, Clauses))\n    return StmtError();\n  // OpenMP, [2.9.2 taskloop Construct, Restrictions]\n  // If a reduction clause is present on the taskloop directive, the nogroup\n  // clause must not be specified.\n  if (checkReductionClauseWithNogroup(*this, Clauses))\n    return StmtError();\n\n  setFunctionHasBranchProtectedScope();\n  return OMPTaskLoopDirective::Create(Context, StartLoc, EndLoc,\n                                      NestedLoopCount, Clauses, AStmt, B,\n                                      DSAStack->isCancelRegion());\n}\n\nStmtResult Sema::ActOnOpenMPTaskLoopSimdDirective(\n    ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n    SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA) {\n  if (!AStmt)\n    return StmtError();\n\n  assert(isa<CapturedStmt>(AStmt) && \"Captured statement expected\");\n  OMPLoopBasedDirective::HelperExprs B;\n  // In presence of clause 'collapse' or 'ordered' with number of loops, it will\n  // define the nested loops number.\n  unsigned NestedLoopCount =\n      checkOpenMPLoop(OMPD_taskloop_simd, getCollapseNumberExpr(Clauses),\n                      /*OrderedLoopCountExpr=*/nullptr, AStmt, *this, *DSAStack,\n                      VarsWithImplicitDSA, B);\n  if (NestedLoopCount == 0)\n    return StmtError();\n\n  assert((CurContext->isDependentContext() || B.builtAll()) &&\n         \"omp for loop exprs were not built\");\n\n  if (!CurContext->isDependentContext()) {\n    // Finalize the clauses that need pre-built expressions for CodeGen.\n    for (OMPClause *C : Clauses) {\n      if (auto *LC = dyn_cast<OMPLinearClause>(C))\n        if (FinishOpenMPLinearClause(*LC, cast<DeclRefExpr>(B.IterationVarRef),\n                                     B.NumIterations, *this, CurScope,\n                                     DSAStack))\n          return StmtError();\n    }\n  }\n\n  // OpenMP, [2.9.2 taskloop Construct, Restrictions]\n  // The grainsize clause and num_tasks clause are mutually exclusive and may\n  // not appear on the same taskloop directive.\n  if (checkGrainsizeNumTasksClauses(*this, Clauses))\n    return StmtError();\n  // OpenMP, [2.9.2 taskloop Construct, Restrictions]\n  // If a reduction clause is present on the taskloop directive, the nogroup\n  // clause must not be specified.\n  if (checkReductionClauseWithNogroup(*this, Clauses))\n    return StmtError();\n  if (checkSimdlenSafelenSpecified(*this, Clauses))\n    return StmtError();\n\n  setFunctionHasBranchProtectedScope();\n  return OMPTaskLoopSimdDirective::Create(Context, StartLoc, EndLoc,\n                                          NestedLoopCount, Clauses, AStmt, B);\n}\n\nStmtResult Sema::ActOnOpenMPMasterTaskLoopDirective(\n    ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n    SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA) {\n  if (!AStmt)\n    return StmtError();\n\n  assert(isa<CapturedStmt>(AStmt) && \"Captured statement expected\");\n  OMPLoopBasedDirective::HelperExprs B;\n  // In presence of clause 'collapse' or 'ordered' with number of loops, it will\n  // define the nested loops number.\n  unsigned NestedLoopCount =\n      checkOpenMPLoop(OMPD_master_taskloop, getCollapseNumberExpr(Clauses),\n                      /*OrderedLoopCountExpr=*/nullptr, AStmt, *this, *DSAStack,\n                      VarsWithImplicitDSA, B);\n  if (NestedLoopCount == 0)\n    return StmtError();\n\n  assert((CurContext->isDependentContext() || B.builtAll()) &&\n         \"omp for loop exprs were not built\");\n\n  // OpenMP, [2.9.2 taskloop Construct, Restrictions]\n  // The grainsize clause and num_tasks clause are mutually exclusive and may\n  // not appear on the same taskloop directive.\n  if (checkGrainsizeNumTasksClauses(*this, Clauses))\n    return StmtError();\n  // OpenMP, [2.9.2 taskloop Construct, Restrictions]\n  // If a reduction clause is present on the taskloop directive, the nogroup\n  // clause must not be specified.\n  if (checkReductionClauseWithNogroup(*this, Clauses))\n    return StmtError();\n\n  setFunctionHasBranchProtectedScope();\n  return OMPMasterTaskLoopDirective::Create(Context, StartLoc, EndLoc,\n                                            NestedLoopCount, Clauses, AStmt, B,\n                                            DSAStack->isCancelRegion());\n}\n\nStmtResult Sema::ActOnOpenMPMasterTaskLoopSimdDirective(\n    ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n    SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA) {\n  if (!AStmt)\n    return StmtError();\n\n  assert(isa<CapturedStmt>(AStmt) && \"Captured statement expected\");\n  OMPLoopBasedDirective::HelperExprs B;\n  // In presence of clause 'collapse' or 'ordered' with number of loops, it will\n  // define the nested loops number.\n  unsigned NestedLoopCount =\n      checkOpenMPLoop(OMPD_master_taskloop_simd, getCollapseNumberExpr(Clauses),\n                      /*OrderedLoopCountExpr=*/nullptr, AStmt, *this, *DSAStack,\n                      VarsWithImplicitDSA, B);\n  if (NestedLoopCount == 0)\n    return StmtError();\n\n  assert((CurContext->isDependentContext() || B.builtAll()) &&\n         \"omp for loop exprs were not built\");\n\n  if (!CurContext->isDependentContext()) {\n    // Finalize the clauses that need pre-built expressions for CodeGen.\n    for (OMPClause *C : Clauses) {\n      if (auto *LC = dyn_cast<OMPLinearClause>(C))\n        if (FinishOpenMPLinearClause(*LC, cast<DeclRefExpr>(B.IterationVarRef),\n                                     B.NumIterations, *this, CurScope,\n                                     DSAStack))\n          return StmtError();\n    }\n  }\n\n  // OpenMP, [2.9.2 taskloop Construct, Restrictions]\n  // The grainsize clause and num_tasks clause are mutually exclusive and may\n  // not appear on the same taskloop directive.\n  if (checkGrainsizeNumTasksClauses(*this, Clauses))\n    return StmtError();\n  // OpenMP, [2.9.2 taskloop Construct, Restrictions]\n  // If a reduction clause is present on the taskloop directive, the nogroup\n  // clause must not be specified.\n  if (checkReductionClauseWithNogroup(*this, Clauses))\n    return StmtError();\n  if (checkSimdlenSafelenSpecified(*this, Clauses))\n    return StmtError();\n\n  setFunctionHasBranchProtectedScope();\n  return OMPMasterTaskLoopSimdDirective::Create(\n      Context, StartLoc, EndLoc, NestedLoopCount, Clauses, AStmt, B);\n}\n\nStmtResult Sema::ActOnOpenMPParallelMasterTaskLoopDirective(\n    ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n    SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA) {\n  if (!AStmt)\n    return StmtError();\n\n  assert(isa<CapturedStmt>(AStmt) && \"Captured statement expected\");\n  auto *CS = cast<CapturedStmt>(AStmt);\n  // 1.2.2 OpenMP Language Terminology\n  // Structured block - An executable statement with a single entry at the\n  // top and a single exit at the bottom.\n  // The point of exit cannot be a branch out of the structured block.\n  // longjmp() and throw() must not violate the entry/exit criteria.\n  CS->getCapturedDecl()->setNothrow();\n  for (int ThisCaptureLevel =\n           getOpenMPCaptureLevels(OMPD_parallel_master_taskloop);\n       ThisCaptureLevel > 1; --ThisCaptureLevel) {\n    CS = cast<CapturedStmt>(CS->getCapturedStmt());\n    // 1.2.2 OpenMP Language Terminology\n    // Structured block - An executable statement with a single entry at the\n    // top and a single exit at the bottom.\n    // The point of exit cannot be a branch out of the structured block.\n    // longjmp() and throw() must not violate the entry/exit criteria.\n    CS->getCapturedDecl()->setNothrow();\n  }\n\n  OMPLoopBasedDirective::HelperExprs B;\n  // In presence of clause 'collapse' or 'ordered' with number of loops, it will\n  // define the nested loops number.\n  unsigned NestedLoopCount = checkOpenMPLoop(\n      OMPD_parallel_master_taskloop, getCollapseNumberExpr(Clauses),\n      /*OrderedLoopCountExpr=*/nullptr, CS, *this, *DSAStack,\n      VarsWithImplicitDSA, B);\n  if (NestedLoopCount == 0)\n    return StmtError();\n\n  assert((CurContext->isDependentContext() || B.builtAll()) &&\n         \"omp for loop exprs were not built\");\n\n  // OpenMP, [2.9.2 taskloop Construct, Restrictions]\n  // The grainsize clause and num_tasks clause are mutually exclusive and may\n  // not appear on the same taskloop directive.\n  if (checkGrainsizeNumTasksClauses(*this, Clauses))\n    return StmtError();\n  // OpenMP, [2.9.2 taskloop Construct, Restrictions]\n  // If a reduction clause is present on the taskloop directive, the nogroup\n  // clause must not be specified.\n  if (checkReductionClauseWithNogroup(*this, Clauses))\n    return StmtError();\n\n  setFunctionHasBranchProtectedScope();\n  return OMPParallelMasterTaskLoopDirective::Create(\n      Context, StartLoc, EndLoc, NestedLoopCount, Clauses, AStmt, B,\n      DSAStack->isCancelRegion());\n}\n\nStmtResult Sema::ActOnOpenMPParallelMasterTaskLoopSimdDirective(\n    ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n    SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA) {\n  if (!AStmt)\n    return StmtError();\n\n  assert(isa<CapturedStmt>(AStmt) && \"Captured statement expected\");\n  auto *CS = cast<CapturedStmt>(AStmt);\n  // 1.2.2 OpenMP Language Terminology\n  // Structured block - An executable statement with a single entry at the\n  // top and a single exit at the bottom.\n  // The point of exit cannot be a branch out of the structured block.\n  // longjmp() and throw() must not violate the entry/exit criteria.\n  CS->getCapturedDecl()->setNothrow();\n  for (int ThisCaptureLevel =\n           getOpenMPCaptureLevels(OMPD_parallel_master_taskloop_simd);\n       ThisCaptureLevel > 1; --ThisCaptureLevel) {\n    CS = cast<CapturedStmt>(CS->getCapturedStmt());\n    // 1.2.2 OpenMP Language Terminology\n    // Structured block - An executable statement with a single entry at the\n    // top and a single exit at the bottom.\n    // The point of exit cannot be a branch out of the structured block.\n    // longjmp() and throw() must not violate the entry/exit criteria.\n    CS->getCapturedDecl()->setNothrow();\n  }\n\n  OMPLoopBasedDirective::HelperExprs B;\n  // In presence of clause 'collapse' or 'ordered' with number of loops, it will\n  // define the nested loops number.\n  unsigned NestedLoopCount = checkOpenMPLoop(\n      OMPD_parallel_master_taskloop_simd, getCollapseNumberExpr(Clauses),\n      /*OrderedLoopCountExpr=*/nullptr, CS, *this, *DSAStack,\n      VarsWithImplicitDSA, B);\n  if (NestedLoopCount == 0)\n    return StmtError();\n\n  assert((CurContext->isDependentContext() || B.builtAll()) &&\n         \"omp for loop exprs were not built\");\n\n  if (!CurContext->isDependentContext()) {\n    // Finalize the clauses that need pre-built expressions for CodeGen.\n    for (OMPClause *C : Clauses) {\n      if (auto *LC = dyn_cast<OMPLinearClause>(C))\n        if (FinishOpenMPLinearClause(*LC, cast<DeclRefExpr>(B.IterationVarRef),\n                                     B.NumIterations, *this, CurScope,\n                                     DSAStack))\n          return StmtError();\n    }\n  }\n\n  // OpenMP, [2.9.2 taskloop Construct, Restrictions]\n  // The grainsize clause and num_tasks clause are mutually exclusive and may\n  // not appear on the same taskloop directive.\n  if (checkGrainsizeNumTasksClauses(*this, Clauses))\n    return StmtError();\n  // OpenMP, [2.9.2 taskloop Construct, Restrictions]\n  // If a reduction clause is present on the taskloop directive, the nogroup\n  // clause must not be specified.\n  if (checkReductionClauseWithNogroup(*this, Clauses))\n    return StmtError();\n  if (checkSimdlenSafelenSpecified(*this, Clauses))\n    return StmtError();\n\n  setFunctionHasBranchProtectedScope();\n  return OMPParallelMasterTaskLoopSimdDirective::Create(\n      Context, StartLoc, EndLoc, NestedLoopCount, Clauses, AStmt, B);\n}\n\nStmtResult Sema::ActOnOpenMPDistributeDirective(\n    ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n    SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA) {\n  if (!AStmt)\n    return StmtError();\n\n  assert(isa<CapturedStmt>(AStmt) && \"Captured statement expected\");\n  OMPLoopBasedDirective::HelperExprs B;\n  // In presence of clause 'collapse' with number of loops, it will\n  // define the nested loops number.\n  unsigned NestedLoopCount =\n      checkOpenMPLoop(OMPD_distribute, getCollapseNumberExpr(Clauses),\n                      nullptr /*ordered not a clause on distribute*/, AStmt,\n                      *this, *DSAStack, VarsWithImplicitDSA, B);\n  if (NestedLoopCount == 0)\n    return StmtError();\n\n  assert((CurContext->isDependentContext() || B.builtAll()) &&\n         \"omp for loop exprs were not built\");\n\n  setFunctionHasBranchProtectedScope();\n  return OMPDistributeDirective::Create(Context, StartLoc, EndLoc,\n                                        NestedLoopCount, Clauses, AStmt, B);\n}\n\nStmtResult Sema::ActOnOpenMPDistributeParallelForDirective(\n    ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n    SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA) {\n  if (!AStmt)\n    return StmtError();\n\n  auto *CS = cast<CapturedStmt>(AStmt);\n  // 1.2.2 OpenMP Language Terminology\n  // Structured block - An executable statement with a single entry at the\n  // top and a single exit at the bottom.\n  // The point of exit cannot be a branch out of the structured block.\n  // longjmp() and throw() must not violate the entry/exit criteria.\n  CS->getCapturedDecl()->setNothrow();\n  for (int ThisCaptureLevel =\n           getOpenMPCaptureLevels(OMPD_distribute_parallel_for);\n       ThisCaptureLevel > 1; --ThisCaptureLevel) {\n    CS = cast<CapturedStmt>(CS->getCapturedStmt());\n    // 1.2.2 OpenMP Language Terminology\n    // Structured block - An executable statement with a single entry at the\n    // top and a single exit at the bottom.\n    // The point of exit cannot be a branch out of the structured block.\n    // longjmp() and throw() must not violate the entry/exit criteria.\n    CS->getCapturedDecl()->setNothrow();\n  }\n\n  OMPLoopBasedDirective::HelperExprs B;\n  // In presence of clause 'collapse' with number of loops, it will\n  // define the nested loops number.\n  unsigned NestedLoopCount = checkOpenMPLoop(\n      OMPD_distribute_parallel_for, getCollapseNumberExpr(Clauses),\n      nullptr /*ordered not a clause on distribute*/, CS, *this, *DSAStack,\n      VarsWithImplicitDSA, B);\n  if (NestedLoopCount == 0)\n    return StmtError();\n\n  assert((CurContext->isDependentContext() || B.builtAll()) &&\n         \"omp for loop exprs were not built\");\n\n  setFunctionHasBranchProtectedScope();\n  return OMPDistributeParallelForDirective::Create(\n      Context, StartLoc, EndLoc, NestedLoopCount, Clauses, AStmt, B,\n      DSAStack->getTaskgroupReductionRef(), DSAStack->isCancelRegion());\n}\n\nStmtResult Sema::ActOnOpenMPDistributeParallelForSimdDirective(\n    ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n    SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA) {\n  if (!AStmt)\n    return StmtError();\n\n  auto *CS = cast<CapturedStmt>(AStmt);\n  // 1.2.2 OpenMP Language Terminology\n  // Structured block - An executable statement with a single entry at the\n  // top and a single exit at the bottom.\n  // The point of exit cannot be a branch out of the structured block.\n  // longjmp() and throw() must not violate the entry/exit criteria.\n  CS->getCapturedDecl()->setNothrow();\n  for (int ThisCaptureLevel =\n           getOpenMPCaptureLevels(OMPD_distribute_parallel_for_simd);\n       ThisCaptureLevel > 1; --ThisCaptureLevel) {\n    CS = cast<CapturedStmt>(CS->getCapturedStmt());\n    // 1.2.2 OpenMP Language Terminology\n    // Structured block - An executable statement with a single entry at the\n    // top and a single exit at the bottom.\n    // The point of exit cannot be a branch out of the structured block.\n    // longjmp() and throw() must not violate the entry/exit criteria.\n    CS->getCapturedDecl()->setNothrow();\n  }\n\n  OMPLoopBasedDirective::HelperExprs B;\n  // In presence of clause 'collapse' with number of loops, it will\n  // define the nested loops number.\n  unsigned NestedLoopCount = checkOpenMPLoop(\n      OMPD_distribute_parallel_for_simd, getCollapseNumberExpr(Clauses),\n      nullptr /*ordered not a clause on distribute*/, CS, *this, *DSAStack,\n      VarsWithImplicitDSA, B);\n  if (NestedLoopCount == 0)\n    return StmtError();\n\n  assert((CurContext->isDependentContext() || B.builtAll()) &&\n         \"omp for loop exprs were not built\");\n\n  if (!CurContext->isDependentContext()) {\n    // Finalize the clauses that need pre-built expressions for CodeGen.\n    for (OMPClause *C : Clauses) {\n      if (auto *LC = dyn_cast<OMPLinearClause>(C))\n        if (FinishOpenMPLinearClause(*LC, cast<DeclRefExpr>(B.IterationVarRef),\n                                     B.NumIterations, *this, CurScope,\n                                     DSAStack))\n          return StmtError();\n    }\n  }\n\n  if (checkSimdlenSafelenSpecified(*this, Clauses))\n    return StmtError();\n\n  setFunctionHasBranchProtectedScope();\n  return OMPDistributeParallelForSimdDirective::Create(\n      Context, StartLoc, EndLoc, NestedLoopCount, Clauses, AStmt, B);\n}\n\nStmtResult Sema::ActOnOpenMPDistributeSimdDirective(\n    ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n    SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA) {\n  if (!AStmt)\n    return StmtError();\n\n  auto *CS = cast<CapturedStmt>(AStmt);\n  // 1.2.2 OpenMP Language Terminology\n  // Structured block - An executable statement with a single entry at the\n  // top and a single exit at the bottom.\n  // The point of exit cannot be a branch out of the structured block.\n  // longjmp() and throw() must not violate the entry/exit criteria.\n  CS->getCapturedDecl()->setNothrow();\n  for (int ThisCaptureLevel = getOpenMPCaptureLevels(OMPD_distribute_simd);\n       ThisCaptureLevel > 1; --ThisCaptureLevel) {\n    CS = cast<CapturedStmt>(CS->getCapturedStmt());\n    // 1.2.2 OpenMP Language Terminology\n    // Structured block - An executable statement with a single entry at the\n    // top and a single exit at the bottom.\n    // The point of exit cannot be a branch out of the structured block.\n    // longjmp() and throw() must not violate the entry/exit criteria.\n    CS->getCapturedDecl()->setNothrow();\n  }\n\n  OMPLoopBasedDirective::HelperExprs B;\n  // In presence of clause 'collapse' with number of loops, it will\n  // define the nested loops number.\n  unsigned NestedLoopCount =\n      checkOpenMPLoop(OMPD_distribute_simd, getCollapseNumberExpr(Clauses),\n                      nullptr /*ordered not a clause on distribute*/, CS, *this,\n                      *DSAStack, VarsWithImplicitDSA, B);\n  if (NestedLoopCount == 0)\n    return StmtError();\n\n  assert((CurContext->isDependentContext() || B.builtAll()) &&\n         \"omp for loop exprs were not built\");\n\n  if (!CurContext->isDependentContext()) {\n    // Finalize the clauses that need pre-built expressions for CodeGen.\n    for (OMPClause *C : Clauses) {\n      if (auto *LC = dyn_cast<OMPLinearClause>(C))\n        if (FinishOpenMPLinearClause(*LC, cast<DeclRefExpr>(B.IterationVarRef),\n                                     B.NumIterations, *this, CurScope,\n                                     DSAStack))\n          return StmtError();\n    }\n  }\n\n  if (checkSimdlenSafelenSpecified(*this, Clauses))\n    return StmtError();\n\n  setFunctionHasBranchProtectedScope();\n  return OMPDistributeSimdDirective::Create(Context, StartLoc, EndLoc,\n                                            NestedLoopCount, Clauses, AStmt, B);\n}\n\nStmtResult Sema::ActOnOpenMPTargetParallelForSimdDirective(\n    ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n    SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA) {\n  if (!AStmt)\n    return StmtError();\n\n  auto *CS = cast<CapturedStmt>(AStmt);\n  // 1.2.2 OpenMP Language Terminology\n  // Structured block - An executable statement with a single entry at the\n  // top and a single exit at the bottom.\n  // The point of exit cannot be a branch out of the structured block.\n  // longjmp() and throw() must not violate the entry/exit criteria.\n  CS->getCapturedDecl()->setNothrow();\n  for (int ThisCaptureLevel = getOpenMPCaptureLevels(OMPD_target_parallel_for);\n       ThisCaptureLevel > 1; --ThisCaptureLevel) {\n    CS = cast<CapturedStmt>(CS->getCapturedStmt());\n    // 1.2.2 OpenMP Language Terminology\n    // Structured block - An executable statement with a single entry at the\n    // top and a single exit at the bottom.\n    // The point of exit cannot be a branch out of the structured block.\n    // longjmp() and throw() must not violate the entry/exit criteria.\n    CS->getCapturedDecl()->setNothrow();\n  }\n\n  OMPLoopBasedDirective::HelperExprs B;\n  // In presence of clause 'collapse' or 'ordered' with number of loops, it will\n  // define the nested loops number.\n  unsigned NestedLoopCount = checkOpenMPLoop(\n      OMPD_target_parallel_for_simd, getCollapseNumberExpr(Clauses),\n      getOrderedNumberExpr(Clauses), CS, *this, *DSAStack,\n      VarsWithImplicitDSA, B);\n  if (NestedLoopCount == 0)\n    return StmtError();\n\n  assert((CurContext->isDependentContext() || B.builtAll()) &&\n         \"omp target parallel for simd loop exprs were not built\");\n\n  if (!CurContext->isDependentContext()) {\n    // Finalize the clauses that need pre-built expressions for CodeGen.\n    for (OMPClause *C : Clauses) {\n      if (auto *LC = dyn_cast<OMPLinearClause>(C))\n        if (FinishOpenMPLinearClause(*LC, cast<DeclRefExpr>(B.IterationVarRef),\n                                     B.NumIterations, *this, CurScope,\n                                     DSAStack))\n          return StmtError();\n    }\n  }\n  if (checkSimdlenSafelenSpecified(*this, Clauses))\n    return StmtError();\n\n  setFunctionHasBranchProtectedScope();\n  return OMPTargetParallelForSimdDirective::Create(\n      Context, StartLoc, EndLoc, NestedLoopCount, Clauses, AStmt, B);\n}\n\nStmtResult Sema::ActOnOpenMPTargetSimdDirective(\n    ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n    SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA) {\n  if (!AStmt)\n    return StmtError();\n\n  auto *CS = cast<CapturedStmt>(AStmt);\n  // 1.2.2 OpenMP Language Terminology\n  // Structured block - An executable statement with a single entry at the\n  // top and a single exit at the bottom.\n  // The point of exit cannot be a branch out of the structured block.\n  // longjmp() and throw() must not violate the entry/exit criteria.\n  CS->getCapturedDecl()->setNothrow();\n  for (int ThisCaptureLevel = getOpenMPCaptureLevels(OMPD_target_simd);\n       ThisCaptureLevel > 1; --ThisCaptureLevel) {\n    CS = cast<CapturedStmt>(CS->getCapturedStmt());\n    // 1.2.2 OpenMP Language Terminology\n    // Structured block - An executable statement with a single entry at the\n    // top and a single exit at the bottom.\n    // The point of exit cannot be a branch out of the structured block.\n    // longjmp() and throw() must not violate the entry/exit criteria.\n    CS->getCapturedDecl()->setNothrow();\n  }\n\n  OMPLoopBasedDirective::HelperExprs B;\n  // In presence of clause 'collapse' with number of loops, it will define the\n  // nested loops number.\n  unsigned NestedLoopCount =\n      checkOpenMPLoop(OMPD_target_simd, getCollapseNumberExpr(Clauses),\n                      getOrderedNumberExpr(Clauses), CS, *this, *DSAStack,\n                      VarsWithImplicitDSA, B);\n  if (NestedLoopCount == 0)\n    return StmtError();\n\n  assert((CurContext->isDependentContext() || B.builtAll()) &&\n         \"omp target simd loop exprs were not built\");\n\n  if (!CurContext->isDependentContext()) {\n    // Finalize the clauses that need pre-built expressions for CodeGen.\n    for (OMPClause *C : Clauses) {\n      if (auto *LC = dyn_cast<OMPLinearClause>(C))\n        if (FinishOpenMPLinearClause(*LC, cast<DeclRefExpr>(B.IterationVarRef),\n                                     B.NumIterations, *this, CurScope,\n                                     DSAStack))\n          return StmtError();\n    }\n  }\n\n  if (checkSimdlenSafelenSpecified(*this, Clauses))\n    return StmtError();\n\n  setFunctionHasBranchProtectedScope();\n  return OMPTargetSimdDirective::Create(Context, StartLoc, EndLoc,\n                                        NestedLoopCount, Clauses, AStmt, B);\n}\n\nStmtResult Sema::ActOnOpenMPTeamsDistributeDirective(\n    ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n    SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA) {\n  if (!AStmt)\n    return StmtError();\n\n  auto *CS = cast<CapturedStmt>(AStmt);\n  // 1.2.2 OpenMP Language Terminology\n  // Structured block - An executable statement with a single entry at the\n  // top and a single exit at the bottom.\n  // The point of exit cannot be a branch out of the structured block.\n  // longjmp() and throw() must not violate the entry/exit criteria.\n  CS->getCapturedDecl()->setNothrow();\n  for (int ThisCaptureLevel = getOpenMPCaptureLevels(OMPD_teams_distribute);\n       ThisCaptureLevel > 1; --ThisCaptureLevel) {\n    CS = cast<CapturedStmt>(CS->getCapturedStmt());\n    // 1.2.2 OpenMP Language Terminology\n    // Structured block - An executable statement with a single entry at the\n    // top and a single exit at the bottom.\n    // The point of exit cannot be a branch out of the structured block.\n    // longjmp() and throw() must not violate the entry/exit criteria.\n    CS->getCapturedDecl()->setNothrow();\n  }\n\n  OMPLoopBasedDirective::HelperExprs B;\n  // In presence of clause 'collapse' with number of loops, it will\n  // define the nested loops number.\n  unsigned NestedLoopCount =\n      checkOpenMPLoop(OMPD_teams_distribute, getCollapseNumberExpr(Clauses),\n                      nullptr /*ordered not a clause on distribute*/, CS, *this,\n                      *DSAStack, VarsWithImplicitDSA, B);\n  if (NestedLoopCount == 0)\n    return StmtError();\n\n  assert((CurContext->isDependentContext() || B.builtAll()) &&\n         \"omp teams distribute loop exprs were not built\");\n\n  setFunctionHasBranchProtectedScope();\n\n  DSAStack->setParentTeamsRegionLoc(StartLoc);\n\n  return OMPTeamsDistributeDirective::Create(\n      Context, StartLoc, EndLoc, NestedLoopCount, Clauses, AStmt, B);\n}\n\nStmtResult Sema::ActOnOpenMPTeamsDistributeSimdDirective(\n    ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n    SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA) {\n  if (!AStmt)\n    return StmtError();\n\n  auto *CS = cast<CapturedStmt>(AStmt);\n  // 1.2.2 OpenMP Language Terminology\n  // Structured block - An executable statement with a single entry at the\n  // top and a single exit at the bottom.\n  // The point of exit cannot be a branch out of the structured block.\n  // longjmp() and throw() must not violate the entry/exit criteria.\n  CS->getCapturedDecl()->setNothrow();\n  for (int ThisCaptureLevel =\n           getOpenMPCaptureLevels(OMPD_teams_distribute_simd);\n       ThisCaptureLevel > 1; --ThisCaptureLevel) {\n    CS = cast<CapturedStmt>(CS->getCapturedStmt());\n    // 1.2.2 OpenMP Language Terminology\n    // Structured block - An executable statement with a single entry at the\n    // top and a single exit at the bottom.\n    // The point of exit cannot be a branch out of the structured block.\n    // longjmp() and throw() must not violate the entry/exit criteria.\n    CS->getCapturedDecl()->setNothrow();\n  }\n\n  OMPLoopBasedDirective::HelperExprs B;\n  // In presence of clause 'collapse' with number of loops, it will\n  // define the nested loops number.\n  unsigned NestedLoopCount = checkOpenMPLoop(\n      OMPD_teams_distribute_simd, getCollapseNumberExpr(Clauses),\n      nullptr /*ordered not a clause on distribute*/, CS, *this, *DSAStack,\n      VarsWithImplicitDSA, B);\n\n  if (NestedLoopCount == 0)\n    return StmtError();\n\n  assert((CurContext->isDependentContext() || B.builtAll()) &&\n         \"omp teams distribute simd loop exprs were not built\");\n\n  if (!CurContext->isDependentContext()) {\n    // Finalize the clauses that need pre-built expressions for CodeGen.\n    for (OMPClause *C : Clauses) {\n      if (auto *LC = dyn_cast<OMPLinearClause>(C))\n        if (FinishOpenMPLinearClause(*LC, cast<DeclRefExpr>(B.IterationVarRef),\n                                     B.NumIterations, *this, CurScope,\n                                     DSAStack))\n          return StmtError();\n    }\n  }\n\n  if (checkSimdlenSafelenSpecified(*this, Clauses))\n    return StmtError();\n\n  setFunctionHasBranchProtectedScope();\n\n  DSAStack->setParentTeamsRegionLoc(StartLoc);\n\n  return OMPTeamsDistributeSimdDirective::Create(\n      Context, StartLoc, EndLoc, NestedLoopCount, Clauses, AStmt, B);\n}\n\nStmtResult Sema::ActOnOpenMPTeamsDistributeParallelForSimdDirective(\n    ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n    SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA) {\n  if (!AStmt)\n    return StmtError();\n\n  auto *CS = cast<CapturedStmt>(AStmt);\n  // 1.2.2 OpenMP Language Terminology\n  // Structured block - An executable statement with a single entry at the\n  // top and a single exit at the bottom.\n  // The point of exit cannot be a branch out of the structured block.\n  // longjmp() and throw() must not violate the entry/exit criteria.\n  CS->getCapturedDecl()->setNothrow();\n\n  for (int ThisCaptureLevel =\n           getOpenMPCaptureLevels(OMPD_teams_distribute_parallel_for_simd);\n       ThisCaptureLevel > 1; --ThisCaptureLevel) {\n    CS = cast<CapturedStmt>(CS->getCapturedStmt());\n    // 1.2.2 OpenMP Language Terminology\n    // Structured block - An executable statement with a single entry at the\n    // top and a single exit at the bottom.\n    // The point of exit cannot be a branch out of the structured block.\n    // longjmp() and throw() must not violate the entry/exit criteria.\n    CS->getCapturedDecl()->setNothrow();\n  }\n\n  OMPLoopBasedDirective::HelperExprs B;\n  // In presence of clause 'collapse' with number of loops, it will\n  // define the nested loops number.\n  unsigned NestedLoopCount = checkOpenMPLoop(\n      OMPD_teams_distribute_parallel_for_simd, getCollapseNumberExpr(Clauses),\n      nullptr /*ordered not a clause on distribute*/, CS, *this, *DSAStack,\n      VarsWithImplicitDSA, B);\n\n  if (NestedLoopCount == 0)\n    return StmtError();\n\n  assert((CurContext->isDependentContext() || B.builtAll()) &&\n         \"omp for loop exprs were not built\");\n\n  if (!CurContext->isDependentContext()) {\n    // Finalize the clauses that need pre-built expressions for CodeGen.\n    for (OMPClause *C : Clauses) {\n      if (auto *LC = dyn_cast<OMPLinearClause>(C))\n        if (FinishOpenMPLinearClause(*LC, cast<DeclRefExpr>(B.IterationVarRef),\n                                     B.NumIterations, *this, CurScope,\n                                     DSAStack))\n          return StmtError();\n    }\n  }\n\n  if (checkSimdlenSafelenSpecified(*this, Clauses))\n    return StmtError();\n\n  setFunctionHasBranchProtectedScope();\n\n  DSAStack->setParentTeamsRegionLoc(StartLoc);\n\n  return OMPTeamsDistributeParallelForSimdDirective::Create(\n      Context, StartLoc, EndLoc, NestedLoopCount, Clauses, AStmt, B);\n}\n\nStmtResult Sema::ActOnOpenMPTeamsDistributeParallelForDirective(\n    ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n    SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA) {\n  if (!AStmt)\n    return StmtError();\n\n  auto *CS = cast<CapturedStmt>(AStmt);\n  // 1.2.2 OpenMP Language Terminology\n  // Structured block - An executable statement with a single entry at the\n  // top and a single exit at the bottom.\n  // The point of exit cannot be a branch out of the structured block.\n  // longjmp() and throw() must not violate the entry/exit criteria.\n  CS->getCapturedDecl()->setNothrow();\n\n  for (int ThisCaptureLevel =\n           getOpenMPCaptureLevels(OMPD_teams_distribute_parallel_for);\n       ThisCaptureLevel > 1; --ThisCaptureLevel) {\n    CS = cast<CapturedStmt>(CS->getCapturedStmt());\n    // 1.2.2 OpenMP Language Terminology\n    // Structured block - An executable statement with a single entry at the\n    // top and a single exit at the bottom.\n    // The point of exit cannot be a branch out of the structured block.\n    // longjmp() and throw() must not violate the entry/exit criteria.\n    CS->getCapturedDecl()->setNothrow();\n  }\n\n  OMPLoopBasedDirective::HelperExprs B;\n  // In presence of clause 'collapse' with number of loops, it will\n  // define the nested loops number.\n  unsigned NestedLoopCount = checkOpenMPLoop(\n      OMPD_teams_distribute_parallel_for, getCollapseNumberExpr(Clauses),\n      nullptr /*ordered not a clause on distribute*/, CS, *this, *DSAStack,\n      VarsWithImplicitDSA, B);\n\n  if (NestedLoopCount == 0)\n    return StmtError();\n\n  assert((CurContext->isDependentContext() || B.builtAll()) &&\n         \"omp for loop exprs were not built\");\n\n  setFunctionHasBranchProtectedScope();\n\n  DSAStack->setParentTeamsRegionLoc(StartLoc);\n\n  return OMPTeamsDistributeParallelForDirective::Create(\n      Context, StartLoc, EndLoc, NestedLoopCount, Clauses, AStmt, B,\n      DSAStack->getTaskgroupReductionRef(), DSAStack->isCancelRegion());\n}\n\nStmtResult Sema::ActOnOpenMPTargetTeamsDirective(ArrayRef<OMPClause *> Clauses,\n                                                 Stmt *AStmt,\n                                                 SourceLocation StartLoc,\n                                                 SourceLocation EndLoc) {\n  if (!AStmt)\n    return StmtError();\n\n  auto *CS = cast<CapturedStmt>(AStmt);\n  // 1.2.2 OpenMP Language Terminology\n  // Structured block - An executable statement with a single entry at the\n  // top and a single exit at the bottom.\n  // The point of exit cannot be a branch out of the structured block.\n  // longjmp() and throw() must not violate the entry/exit criteria.\n  CS->getCapturedDecl()->setNothrow();\n\n  for (int ThisCaptureLevel = getOpenMPCaptureLevels(OMPD_target_teams);\n       ThisCaptureLevel > 1; --ThisCaptureLevel) {\n    CS = cast<CapturedStmt>(CS->getCapturedStmt());\n    // 1.2.2 OpenMP Language Terminology\n    // Structured block - An executable statement with a single entry at the\n    // top and a single exit at the bottom.\n    // The point of exit cannot be a branch out of the structured block.\n    // longjmp() and throw() must not violate the entry/exit criteria.\n    CS->getCapturedDecl()->setNothrow();\n  }\n  setFunctionHasBranchProtectedScope();\n\n  return OMPTargetTeamsDirective::Create(Context, StartLoc, EndLoc, Clauses,\n                                         AStmt);\n}\n\nStmtResult Sema::ActOnOpenMPTargetTeamsDistributeDirective(\n    ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n    SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA) {\n  if (!AStmt)\n    return StmtError();\n\n  auto *CS = cast<CapturedStmt>(AStmt);\n  // 1.2.2 OpenMP Language Terminology\n  // Structured block - An executable statement with a single entry at the\n  // top and a single exit at the bottom.\n  // The point of exit cannot be a branch out of the structured block.\n  // longjmp() and throw() must not violate the entry/exit criteria.\n  CS->getCapturedDecl()->setNothrow();\n  for (int ThisCaptureLevel =\n           getOpenMPCaptureLevels(OMPD_target_teams_distribute);\n       ThisCaptureLevel > 1; --ThisCaptureLevel) {\n    CS = cast<CapturedStmt>(CS->getCapturedStmt());\n    // 1.2.2 OpenMP Language Terminology\n    // Structured block - An executable statement with a single entry at the\n    // top and a single exit at the bottom.\n    // The point of exit cannot be a branch out of the structured block.\n    // longjmp() and throw() must not violate the entry/exit criteria.\n    CS->getCapturedDecl()->setNothrow();\n  }\n\n  OMPLoopBasedDirective::HelperExprs B;\n  // In presence of clause 'collapse' with number of loops, it will\n  // define the nested loops number.\n  unsigned NestedLoopCount = checkOpenMPLoop(\n      OMPD_target_teams_distribute, getCollapseNumberExpr(Clauses),\n      nullptr /*ordered not a clause on distribute*/, CS, *this, *DSAStack,\n      VarsWithImplicitDSA, B);\n  if (NestedLoopCount == 0)\n    return StmtError();\n\n  assert((CurContext->isDependentContext() || B.builtAll()) &&\n         \"omp target teams distribute loop exprs were not built\");\n\n  setFunctionHasBranchProtectedScope();\n  return OMPTargetTeamsDistributeDirective::Create(\n      Context, StartLoc, EndLoc, NestedLoopCount, Clauses, AStmt, B);\n}\n\nStmtResult Sema::ActOnOpenMPTargetTeamsDistributeParallelForDirective(\n    ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n    SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA) {\n  if (!AStmt)\n    return StmtError();\n\n  auto *CS = cast<CapturedStmt>(AStmt);\n  // 1.2.2 OpenMP Language Terminology\n  // Structured block - An executable statement with a single entry at the\n  // top and a single exit at the bottom.\n  // The point of exit cannot be a branch out of the structured block.\n  // longjmp() and throw() must not violate the entry/exit criteria.\n  CS->getCapturedDecl()->setNothrow();\n  for (int ThisCaptureLevel =\n           getOpenMPCaptureLevels(OMPD_target_teams_distribute_parallel_for);\n       ThisCaptureLevel > 1; --ThisCaptureLevel) {\n    CS = cast<CapturedStmt>(CS->getCapturedStmt());\n    // 1.2.2 OpenMP Language Terminology\n    // Structured block - An executable statement with a single entry at the\n    // top and a single exit at the bottom.\n    // The point of exit cannot be a branch out of the structured block.\n    // longjmp() and throw() must not violate the entry/exit criteria.\n    CS->getCapturedDecl()->setNothrow();\n  }\n\n  OMPLoopBasedDirective::HelperExprs B;\n  // In presence of clause 'collapse' with number of loops, it will\n  // define the nested loops number.\n  unsigned NestedLoopCount = checkOpenMPLoop(\n      OMPD_target_teams_distribute_parallel_for, getCollapseNumberExpr(Clauses),\n      nullptr /*ordered not a clause on distribute*/, CS, *this, *DSAStack,\n      VarsWithImplicitDSA, B);\n  if (NestedLoopCount == 0)\n    return StmtError();\n\n  assert((CurContext->isDependentContext() || B.builtAll()) &&\n         \"omp target teams distribute parallel for loop exprs were not built\");\n\n  if (!CurContext->isDependentContext()) {\n    // Finalize the clauses that need pre-built expressions for CodeGen.\n    for (OMPClause *C : Clauses) {\n      if (auto *LC = dyn_cast<OMPLinearClause>(C))\n        if (FinishOpenMPLinearClause(*LC, cast<DeclRefExpr>(B.IterationVarRef),\n                                     B.NumIterations, *this, CurScope,\n                                     DSAStack))\n          return StmtError();\n    }\n  }\n\n  setFunctionHasBranchProtectedScope();\n  return OMPTargetTeamsDistributeParallelForDirective::Create(\n      Context, StartLoc, EndLoc, NestedLoopCount, Clauses, AStmt, B,\n      DSAStack->getTaskgroupReductionRef(), DSAStack->isCancelRegion());\n}\n\nStmtResult Sema::ActOnOpenMPTargetTeamsDistributeParallelForSimdDirective(\n    ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n    SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA) {\n  if (!AStmt)\n    return StmtError();\n\n  auto *CS = cast<CapturedStmt>(AStmt);\n  // 1.2.2 OpenMP Language Terminology\n  // Structured block - An executable statement with a single entry at the\n  // top and a single exit at the bottom.\n  // The point of exit cannot be a branch out of the structured block.\n  // longjmp() and throw() must not violate the entry/exit criteria.\n  CS->getCapturedDecl()->setNothrow();\n  for (int ThisCaptureLevel = getOpenMPCaptureLevels(\n           OMPD_target_teams_distribute_parallel_for_simd);\n       ThisCaptureLevel > 1; --ThisCaptureLevel) {\n    CS = cast<CapturedStmt>(CS->getCapturedStmt());\n    // 1.2.2 OpenMP Language Terminology\n    // Structured block - An executable statement with a single entry at the\n    // top and a single exit at the bottom.\n    // The point of exit cannot be a branch out of the structured block.\n    // longjmp() and throw() must not violate the entry/exit criteria.\n    CS->getCapturedDecl()->setNothrow();\n  }\n\n  OMPLoopBasedDirective::HelperExprs B;\n  // In presence of clause 'collapse' with number of loops, it will\n  // define the nested loops number.\n  unsigned NestedLoopCount =\n      checkOpenMPLoop(OMPD_target_teams_distribute_parallel_for_simd,\n                      getCollapseNumberExpr(Clauses),\n                      nullptr /*ordered not a clause on distribute*/, CS, *this,\n                      *DSAStack, VarsWithImplicitDSA, B);\n  if (NestedLoopCount == 0)\n    return StmtError();\n\n  assert((CurContext->isDependentContext() || B.builtAll()) &&\n         \"omp target teams distribute parallel for simd loop exprs were not \"\n         \"built\");\n\n  if (!CurContext->isDependentContext()) {\n    // Finalize the clauses that need pre-built expressions for CodeGen.\n    for (OMPClause *C : Clauses) {\n      if (auto *LC = dyn_cast<OMPLinearClause>(C))\n        if (FinishOpenMPLinearClause(*LC, cast<DeclRefExpr>(B.IterationVarRef),\n                                     B.NumIterations, *this, CurScope,\n                                     DSAStack))\n          return StmtError();\n    }\n  }\n\n  if (checkSimdlenSafelenSpecified(*this, Clauses))\n    return StmtError();\n\n  setFunctionHasBranchProtectedScope();\n  return OMPTargetTeamsDistributeParallelForSimdDirective::Create(\n      Context, StartLoc, EndLoc, NestedLoopCount, Clauses, AStmt, B);\n}\n\nStmtResult Sema::ActOnOpenMPTargetTeamsDistributeSimdDirective(\n    ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n    SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA) {\n  if (!AStmt)\n    return StmtError();\n\n  auto *CS = cast<CapturedStmt>(AStmt);\n  // 1.2.2 OpenMP Language Terminology\n  // Structured block - An executable statement with a single entry at the\n  // top and a single exit at the bottom.\n  // The point of exit cannot be a branch out of the structured block.\n  // longjmp() and throw() must not violate the entry/exit criteria.\n  CS->getCapturedDecl()->setNothrow();\n  for (int ThisCaptureLevel =\n           getOpenMPCaptureLevels(OMPD_target_teams_distribute_simd);\n       ThisCaptureLevel > 1; --ThisCaptureLevel) {\n    CS = cast<CapturedStmt>(CS->getCapturedStmt());\n    // 1.2.2 OpenMP Language Terminology\n    // Structured block - An executable statement with a single entry at the\n    // top and a single exit at the bottom.\n    // The point of exit cannot be a branch out of the structured block.\n    // longjmp() and throw() must not violate the entry/exit criteria.\n    CS->getCapturedDecl()->setNothrow();\n  }\n\n  OMPLoopBasedDirective::HelperExprs B;\n  // In presence of clause 'collapse' with number of loops, it will\n  // define the nested loops number.\n  unsigned NestedLoopCount = checkOpenMPLoop(\n      OMPD_target_teams_distribute_simd, getCollapseNumberExpr(Clauses),\n      nullptr /*ordered not a clause on distribute*/, CS, *this, *DSAStack,\n      VarsWithImplicitDSA, B);\n  if (NestedLoopCount == 0)\n    return StmtError();\n\n  assert((CurContext->isDependentContext() || B.builtAll()) &&\n         \"omp target teams distribute simd loop exprs were not built\");\n\n  if (!CurContext->isDependentContext()) {\n    // Finalize the clauses that need pre-built expressions for CodeGen.\n    for (OMPClause *C : Clauses) {\n      if (auto *LC = dyn_cast<OMPLinearClause>(C))\n        if (FinishOpenMPLinearClause(*LC, cast<DeclRefExpr>(B.IterationVarRef),\n                                     B.NumIterations, *this, CurScope,\n                                     DSAStack))\n          return StmtError();\n    }\n  }\n\n  if (checkSimdlenSafelenSpecified(*this, Clauses))\n    return StmtError();\n\n  setFunctionHasBranchProtectedScope();\n  return OMPTargetTeamsDistributeSimdDirective::Create(\n      Context, StartLoc, EndLoc, NestedLoopCount, Clauses, AStmt, B);\n}\n\nStmtResult Sema::ActOnOpenMPTileDirective(ArrayRef<OMPClause *> Clauses,\n                                          Stmt *AStmt, SourceLocation StartLoc,\n                                          SourceLocation EndLoc) {\n  auto SizesClauses =\n      OMPExecutableDirective::getClausesOfKind<OMPSizesClause>(Clauses);\n  if (SizesClauses.empty()) {\n    // A missing 'sizes' clause is already reported by the parser.\n    return StmtError();\n  }\n  const OMPSizesClause *SizesClause = *SizesClauses.begin();\n  unsigned NumLoops = SizesClause->getNumSizes();\n\n  // Empty statement should only be possible if there already was an error.\n  if (!AStmt)\n    return StmtError();\n\n  // Verify and diagnose loop nest.\n  SmallVector<OMPLoopBasedDirective::HelperExprs, 4> LoopHelpers(NumLoops);\n  Stmt *Body = nullptr;\n  SmallVector<Stmt *, 4> OriginalInits;\n  if (!OMPLoopBasedDirective::doForAllLoops(\n          AStmt->IgnoreContainers(), /*TryImperfectlyNestedLoops=*/false,\n          NumLoops,\n          [this, &LoopHelpers, &Body, &OriginalInits](unsigned Cnt,\n                                                      Stmt *CurStmt) {\n            VarsWithInheritedDSAType TmpDSA;\n            unsigned SingleNumLoops =\n                checkOpenMPLoop(OMPD_tile, nullptr, nullptr, CurStmt, *this,\n                                *DSAStack, TmpDSA, LoopHelpers[Cnt]);\n            if (SingleNumLoops == 0)\n              return true;\n            assert(SingleNumLoops == 1 && \"Expect single loop iteration space\");\n            if (auto *For = dyn_cast<ForStmt>(CurStmt)) {\n              OriginalInits.push_back(For->getInit());\n              Body = For->getBody();\n            } else {\n              assert(isa<CXXForRangeStmt>(CurStmt) &&\n                     \"Expected canonical for or range-based for loops.\");\n              auto *CXXFor = cast<CXXForRangeStmt>(CurStmt);\n              OriginalInits.push_back(CXXFor->getBeginStmt());\n              Body = CXXFor->getBody();\n            }\n            return false;\n          }))\n    return StmtError();\n\n  // Delay tiling to when template is completely instantiated.\n  if (CurContext->isDependentContext())\n    return OMPTileDirective::Create(Context, StartLoc, EndLoc, Clauses,\n                                    NumLoops, AStmt, nullptr, nullptr);\n\n  // Collection of generated variable declaration.\n  SmallVector<Decl *, 4> PreInits;\n\n  // Create iteration variables for the generated loops.\n  SmallVector<VarDecl *, 4> FloorIndVars;\n  SmallVector<VarDecl *, 4> TileIndVars;\n  FloorIndVars.resize(NumLoops);\n  TileIndVars.resize(NumLoops);\n  for (unsigned I = 0; I < NumLoops; ++I) {\n    OMPLoopBasedDirective::HelperExprs &LoopHelper = LoopHelpers[I];\n    if (auto *PI = cast_or_null<DeclStmt>(LoopHelper.PreInits))\n      PreInits.append(PI->decl_begin(), PI->decl_end());\n    assert(LoopHelper.Counters.size() == 1 &&\n           \"Expect single-dimensional loop iteration space\");\n    auto *OrigCntVar = cast<DeclRefExpr>(LoopHelper.Counters.front());\n    std::string OrigVarName = OrigCntVar->getNameInfo().getAsString();\n    DeclRefExpr *IterVarRef = cast<DeclRefExpr>(LoopHelper.IterationVarRef);\n    QualType CntTy = IterVarRef->getType();\n\n    // Iteration variable for the floor (i.e. outer) loop.\n    {\n      std::string FloorCntName =\n          (Twine(\".floor_\") + llvm::utostr(I) + \".iv.\" + OrigVarName).str();\n      VarDecl *FloorCntDecl =\n          buildVarDecl(*this, {}, CntTy, FloorCntName, nullptr, OrigCntVar);\n      FloorIndVars[I] = FloorCntDecl;\n    }\n\n    // Iteration variable for the tile (i.e. inner) loop.\n    {\n      std::string TileCntName =\n          (Twine(\".tile_\") + llvm::utostr(I) + \".iv.\" + OrigVarName).str();\n\n      // Reuse the iteration variable created by checkOpenMPLoop. It is also\n      // used by the expressions to derive the original iteration variable's\n      // value from the logical iteration number.\n      auto *TileCntDecl = cast<VarDecl>(IterVarRef->getDecl());\n      TileCntDecl->setDeclName(&PP.getIdentifierTable().get(TileCntName));\n      TileIndVars[I] = TileCntDecl;\n    }\n    if (auto *PI = dyn_cast_or_null<DeclStmt>(OriginalInits[I]))\n      PreInits.append(PI->decl_begin(), PI->decl_end());\n    // Gather declarations for the data members used as counters.\n    for (Expr *CounterRef : LoopHelper.Counters) {\n      auto *CounterDecl = cast<DeclRefExpr>(CounterRef)->getDecl();\n      if (isa<OMPCapturedExprDecl>(CounterDecl))\n        PreInits.push_back(CounterDecl);\n    }\n  }\n\n  // Once the original iteration values are set, append the innermost body.\n  Stmt *Inner = Body;\n\n  // Create tile loops from the inside to the outside.\n  for (int I = NumLoops - 1; I >= 0; --I) {\n    OMPLoopBasedDirective::HelperExprs &LoopHelper = LoopHelpers[I];\n    Expr *NumIterations = LoopHelper.NumIterations;\n    auto *OrigCntVar = cast<DeclRefExpr>(LoopHelper.Counters[0]);\n    QualType CntTy = OrigCntVar->getType();\n    Expr *DimTileSize = SizesClause->getSizesRefs()[I];\n    Scope *CurScope = getCurScope();\n\n    // Commonly used variables.\n    DeclRefExpr *TileIV = buildDeclRefExpr(*this, TileIndVars[I], CntTy,\n                                           OrigCntVar->getExprLoc());\n    DeclRefExpr *FloorIV = buildDeclRefExpr(*this, FloorIndVars[I], CntTy,\n                                            OrigCntVar->getExprLoc());\n\n    // For init-statement: auto .tile.iv = .floor.iv\n    AddInitializerToDecl(TileIndVars[I], DefaultLvalueConversion(FloorIV).get(),\n                         /*DirectInit=*/false);\n    Decl *CounterDecl = TileIndVars[I];\n    StmtResult InitStmt = new (Context)\n        DeclStmt(DeclGroupRef::Create(Context, &CounterDecl, 1),\n                 OrigCntVar->getBeginLoc(), OrigCntVar->getEndLoc());\n    if (!InitStmt.isUsable())\n      return StmtError();\n\n    // For cond-expression: .tile.iv < min(.floor.iv + DimTileSize,\n    // NumIterations)\n    ExprResult EndOfTile = BuildBinOp(CurScope, LoopHelper.Cond->getExprLoc(),\n                                      BO_Add, FloorIV, DimTileSize);\n    if (!EndOfTile.isUsable())\n      return StmtError();\n    ExprResult IsPartialTile =\n        BuildBinOp(CurScope, LoopHelper.Cond->getExprLoc(), BO_LT,\n                   NumIterations, EndOfTile.get());\n    if (!IsPartialTile.isUsable())\n      return StmtError();\n    ExprResult MinTileAndIterSpace = ActOnConditionalOp(\n        LoopHelper.Cond->getBeginLoc(), LoopHelper.Cond->getEndLoc(),\n        IsPartialTile.get(), NumIterations, EndOfTile.get());\n    if (!MinTileAndIterSpace.isUsable())\n      return StmtError();\n    ExprResult CondExpr = BuildBinOp(CurScope, LoopHelper.Cond->getExprLoc(),\n                                     BO_LT, TileIV, MinTileAndIterSpace.get());\n    if (!CondExpr.isUsable())\n      return StmtError();\n\n    // For incr-statement: ++.tile.iv\n    ExprResult IncrStmt =\n        BuildUnaryOp(CurScope, LoopHelper.Inc->getExprLoc(), UO_PreInc, TileIV);\n    if (!IncrStmt.isUsable())\n      return StmtError();\n\n    // Statements to set the original iteration variable's value from the\n    // logical iteration number.\n    // Generated for loop is:\n    // Original_for_init;\n    // for (auto .tile.iv = .floor.iv; .tile.iv < min(.floor.iv + DimTileSize,\n    // NumIterations); ++.tile.iv) {\n    //   Original_Body;\n    //   Original_counter_update;\n    // }\n    // FIXME: If the innermost body is an loop itself, inserting these\n    // statements stops it being recognized  as a perfectly nested loop (e.g.\n    // for applying tiling again). If this is the case, sink the expressions\n    // further into the inner loop.\n    SmallVector<Stmt *, 4> BodyParts;\n    BodyParts.append(LoopHelper.Updates.begin(), LoopHelper.Updates.end());\n    BodyParts.push_back(Inner);\n    Inner = CompoundStmt::Create(Context, BodyParts, Inner->getBeginLoc(),\n                                 Inner->getEndLoc());\n    Inner = new (Context)\n        ForStmt(Context, InitStmt.get(), CondExpr.get(), nullptr,\n                IncrStmt.get(), Inner, LoopHelper.Init->getBeginLoc(),\n                LoopHelper.Init->getBeginLoc(), LoopHelper.Inc->getEndLoc());\n  }\n\n  // Create floor loops from the inside to the outside.\n  for (int I = NumLoops - 1; I >= 0; --I) {\n    auto &LoopHelper = LoopHelpers[I];\n    Expr *NumIterations = LoopHelper.NumIterations;\n    DeclRefExpr *OrigCntVar = cast<DeclRefExpr>(LoopHelper.Counters[0]);\n    QualType CntTy = OrigCntVar->getType();\n    Expr *DimTileSize = SizesClause->getSizesRefs()[I];\n    Scope *CurScope = getCurScope();\n\n    // Commonly used variables.\n    DeclRefExpr *FloorIV = buildDeclRefExpr(*this, FloorIndVars[I], CntTy,\n                                            OrigCntVar->getExprLoc());\n\n    // For init-statement: auto .floor.iv = 0\n    AddInitializerToDecl(\n        FloorIndVars[I],\n        ActOnIntegerConstant(LoopHelper.Init->getExprLoc(), 0).get(),\n        /*DirectInit=*/false);\n    Decl *CounterDecl = FloorIndVars[I];\n    StmtResult InitStmt = new (Context)\n        DeclStmt(DeclGroupRef::Create(Context, &CounterDecl, 1),\n                 OrigCntVar->getBeginLoc(), OrigCntVar->getEndLoc());\n    if (!InitStmt.isUsable())\n      return StmtError();\n\n    // For cond-expression: .floor.iv < NumIterations\n    ExprResult CondExpr = BuildBinOp(CurScope, LoopHelper.Cond->getExprLoc(),\n                                     BO_LT, FloorIV, NumIterations);\n    if (!CondExpr.isUsable())\n      return StmtError();\n\n    // For incr-statement: .floor.iv += DimTileSize\n    ExprResult IncrStmt = BuildBinOp(CurScope, LoopHelper.Inc->getExprLoc(),\n                                     BO_AddAssign, FloorIV, DimTileSize);\n    if (!IncrStmt.isUsable())\n      return StmtError();\n\n    Inner = new (Context)\n        ForStmt(Context, InitStmt.get(), CondExpr.get(), nullptr,\n                IncrStmt.get(), Inner, LoopHelper.Init->getBeginLoc(),\n                LoopHelper.Init->getBeginLoc(), LoopHelper.Inc->getEndLoc());\n  }\n\n  return OMPTileDirective::Create(Context, StartLoc, EndLoc, Clauses, NumLoops,\n                                  AStmt, Inner,\n                                  buildPreInits(Context, PreInits));\n}\n\nOMPClause *Sema::ActOnOpenMPSingleExprClause(OpenMPClauseKind Kind, Expr *Expr,\n                                             SourceLocation StartLoc,\n                                             SourceLocation LParenLoc,\n                                             SourceLocation EndLoc) {\n  OMPClause *Res = nullptr;\n  switch (Kind) {\n  case OMPC_final:\n    Res = ActOnOpenMPFinalClause(Expr, StartLoc, LParenLoc, EndLoc);\n    break;\n  case OMPC_num_threads:\n    Res = ActOnOpenMPNumThreadsClause(Expr, StartLoc, LParenLoc, EndLoc);\n    break;\n  case OMPC_safelen:\n    Res = ActOnOpenMPSafelenClause(Expr, StartLoc, LParenLoc, EndLoc);\n    break;\n  case OMPC_simdlen:\n    Res = ActOnOpenMPSimdlenClause(Expr, StartLoc, LParenLoc, EndLoc);\n    break;\n  case OMPC_allocator:\n    Res = ActOnOpenMPAllocatorClause(Expr, StartLoc, LParenLoc, EndLoc);\n    break;\n  case OMPC_collapse:\n    Res = ActOnOpenMPCollapseClause(Expr, StartLoc, LParenLoc, EndLoc);\n    break;\n  case OMPC_ordered:\n    Res = ActOnOpenMPOrderedClause(StartLoc, EndLoc, LParenLoc, Expr);\n    break;\n  case OMPC_num_teams:\n    Res = ActOnOpenMPNumTeamsClause(Expr, StartLoc, LParenLoc, EndLoc);\n    break;\n  case OMPC_thread_limit:\n    Res = ActOnOpenMPThreadLimitClause(Expr, StartLoc, LParenLoc, EndLoc);\n    break;\n  case OMPC_priority:\n    Res = ActOnOpenMPPriorityClause(Expr, StartLoc, LParenLoc, EndLoc);\n    break;\n  case OMPC_grainsize:\n    Res = ActOnOpenMPGrainsizeClause(Expr, StartLoc, LParenLoc, EndLoc);\n    break;\n  case OMPC_num_tasks:\n    Res = ActOnOpenMPNumTasksClause(Expr, StartLoc, LParenLoc, EndLoc);\n    break;\n  case OMPC_hint:\n    Res = ActOnOpenMPHintClause(Expr, StartLoc, LParenLoc, EndLoc);\n    break;\n  case OMPC_depobj:\n    Res = ActOnOpenMPDepobjClause(Expr, StartLoc, LParenLoc, EndLoc);\n    break;\n  case OMPC_detach:\n    Res = ActOnOpenMPDetachClause(Expr, StartLoc, LParenLoc, EndLoc);\n    break;\n  case OMPC_device:\n  case OMPC_if:\n  case OMPC_default:\n  case OMPC_proc_bind:\n  case OMPC_schedule:\n  case OMPC_private:\n  case OMPC_firstprivate:\n  case OMPC_lastprivate:\n  case OMPC_shared:\n  case OMPC_reduction:\n  case OMPC_task_reduction:\n  case OMPC_in_reduction:\n  case OMPC_linear:\n  case OMPC_aligned:\n  case OMPC_copyin:\n  case OMPC_copyprivate:\n  case OMPC_nowait:\n  case OMPC_untied:\n  case OMPC_mergeable:\n  case OMPC_threadprivate:\n  case OMPC_sizes:\n  case OMPC_allocate:\n  case OMPC_flush:\n  case OMPC_read:\n  case OMPC_write:\n  case OMPC_update:\n  case OMPC_capture:\n  case OMPC_seq_cst:\n  case OMPC_acq_rel:\n  case OMPC_acquire:\n  case OMPC_release:\n  case OMPC_relaxed:\n  case OMPC_depend:\n  case OMPC_threads:\n  case OMPC_simd:\n  case OMPC_map:\n  case OMPC_nogroup:\n  case OMPC_dist_schedule:\n  case OMPC_defaultmap:\n  case OMPC_unknown:\n  case OMPC_uniform:\n  case OMPC_to:\n  case OMPC_from:\n  case OMPC_use_device_ptr:\n  case OMPC_use_device_addr:\n  case OMPC_is_device_ptr:\n  case OMPC_unified_address:\n  case OMPC_unified_shared_memory:\n  case OMPC_reverse_offload:\n  case OMPC_dynamic_allocators:\n  case OMPC_atomic_default_mem_order:\n  case OMPC_device_type:\n  case OMPC_match:\n  case OMPC_nontemporal:\n  case OMPC_order:\n  case OMPC_destroy:\n  case OMPC_inclusive:\n  case OMPC_exclusive:\n  case OMPC_uses_allocators:\n  case OMPC_affinity:\n  default:\n    llvm_unreachable(\"Clause is not allowed.\");\n  }\n  return Res;\n}\n\n// An OpenMP directive such as 'target parallel' has two captured regions:\n// for the 'target' and 'parallel' respectively.  This function returns\n// the region in which to capture expressions associated with a clause.\n// A return value of OMPD_unknown signifies that the expression should not\n// be captured.\nstatic OpenMPDirectiveKind getOpenMPCaptureRegionForClause(\n    OpenMPDirectiveKind DKind, OpenMPClauseKind CKind, unsigned OpenMPVersion,\n    OpenMPDirectiveKind NameModifier = OMPD_unknown) {\n  OpenMPDirectiveKind CaptureRegion = OMPD_unknown;\n  switch (CKind) {\n  case OMPC_if:\n    switch (DKind) {\n    case OMPD_target_parallel_for_simd:\n      if (OpenMPVersion >= 50 &&\n          (NameModifier == OMPD_unknown || NameModifier == OMPD_simd)) {\n        CaptureRegion = OMPD_parallel;\n        break;\n      }\n      LLVM_FALLTHROUGH;\n    case OMPD_target_parallel:\n    case OMPD_target_parallel_for:\n      // If this clause applies to the nested 'parallel' region, capture within\n      // the 'target' region, otherwise do not capture.\n      if (NameModifier == OMPD_unknown || NameModifier == OMPD_parallel)\n        CaptureRegion = OMPD_target;\n      break;\n    case OMPD_target_teams_distribute_parallel_for_simd:\n      if (OpenMPVersion >= 50 &&\n          (NameModifier == OMPD_unknown || NameModifier == OMPD_simd)) {\n        CaptureRegion = OMPD_parallel;\n        break;\n      }\n      LLVM_FALLTHROUGH;\n    case OMPD_target_teams_distribute_parallel_for:\n      // If this clause applies to the nested 'parallel' region, capture within\n      // the 'teams' region, otherwise do not capture.\n      if (NameModifier == OMPD_unknown || NameModifier == OMPD_parallel)\n        CaptureRegion = OMPD_teams;\n      break;\n    case OMPD_teams_distribute_parallel_for_simd:\n      if (OpenMPVersion >= 50 &&\n          (NameModifier == OMPD_unknown || NameModifier == OMPD_simd)) {\n        CaptureRegion = OMPD_parallel;\n        break;\n      }\n      LLVM_FALLTHROUGH;\n    case OMPD_teams_distribute_parallel_for:\n      CaptureRegion = OMPD_teams;\n      break;\n    case OMPD_target_update:\n    case OMPD_target_enter_data:\n    case OMPD_target_exit_data:\n      CaptureRegion = OMPD_task;\n      break;\n    case OMPD_parallel_master_taskloop:\n      if (NameModifier == OMPD_unknown || NameModifier == OMPD_taskloop)\n        CaptureRegion = OMPD_parallel;\n      break;\n    case OMPD_parallel_master_taskloop_simd:\n      if ((OpenMPVersion <= 45 && NameModifier == OMPD_unknown) ||\n          NameModifier == OMPD_taskloop) {\n        CaptureRegion = OMPD_parallel;\n        break;\n      }\n      if (OpenMPVersion <= 45)\n        break;\n      if (NameModifier == OMPD_unknown || NameModifier == OMPD_simd)\n        CaptureRegion = OMPD_taskloop;\n      break;\n    case OMPD_parallel_for_simd:\n      if (OpenMPVersion <= 45)\n        break;\n      if (NameModifier == OMPD_unknown || NameModifier == OMPD_simd)\n        CaptureRegion = OMPD_parallel;\n      break;\n    case OMPD_taskloop_simd:\n    case OMPD_master_taskloop_simd:\n      if (OpenMPVersion <= 45)\n        break;\n      if (NameModifier == OMPD_unknown || NameModifier == OMPD_simd)\n        CaptureRegion = OMPD_taskloop;\n      break;\n    case OMPD_distribute_parallel_for_simd:\n      if (OpenMPVersion <= 45)\n        break;\n      if (NameModifier == OMPD_unknown || NameModifier == OMPD_simd)\n        CaptureRegion = OMPD_parallel;\n      break;\n    case OMPD_target_simd:\n      if (OpenMPVersion >= 50 &&\n          (NameModifier == OMPD_unknown || NameModifier == OMPD_simd))\n        CaptureRegion = OMPD_target;\n      break;\n    case OMPD_teams_distribute_simd:\n    case OMPD_target_teams_distribute_simd:\n      if (OpenMPVersion >= 50 &&\n          (NameModifier == OMPD_unknown || NameModifier == OMPD_simd))\n        CaptureRegion = OMPD_teams;\n      break;\n    case OMPD_cancel:\n    case OMPD_parallel:\n    case OMPD_parallel_master:\n    case OMPD_parallel_sections:\n    case OMPD_parallel_for:\n    case OMPD_target:\n    case OMPD_target_teams:\n    case OMPD_target_teams_distribute:\n    case OMPD_distribute_parallel_for:\n    case OMPD_task:\n    case OMPD_taskloop:\n    case OMPD_master_taskloop:\n    case OMPD_target_data:\n    case OMPD_simd:\n    case OMPD_for_simd:\n    case OMPD_distribute_simd:\n      // Do not capture if-clause expressions.\n      break;\n    case OMPD_threadprivate:\n    case OMPD_allocate:\n    case OMPD_taskyield:\n    case OMPD_barrier:\n    case OMPD_taskwait:\n    case OMPD_cancellation_point:\n    case OMPD_flush:\n    case OMPD_depobj:\n    case OMPD_scan:\n    case OMPD_declare_reduction:\n    case OMPD_declare_mapper:\n    case OMPD_declare_simd:\n    case OMPD_declare_variant:\n    case OMPD_begin_declare_variant:\n    case OMPD_end_declare_variant:\n    case OMPD_declare_target:\n    case OMPD_end_declare_target:\n    case OMPD_teams:\n    case OMPD_tile:\n    case OMPD_for:\n    case OMPD_sections:\n    case OMPD_section:\n    case OMPD_single:\n    case OMPD_master:\n    case OMPD_critical:\n    case OMPD_taskgroup:\n    case OMPD_distribute:\n    case OMPD_ordered:\n    case OMPD_atomic:\n    case OMPD_teams_distribute:\n    case OMPD_requires:\n      llvm_unreachable(\"Unexpected OpenMP directive with if-clause\");\n    case OMPD_unknown:\n    default:\n      llvm_unreachable(\"Unknown OpenMP directive\");\n    }\n    break;\n  case OMPC_num_threads:\n    switch (DKind) {\n    case OMPD_target_parallel:\n    case OMPD_target_parallel_for:\n    case OMPD_target_parallel_for_simd:\n      CaptureRegion = OMPD_target;\n      break;\n    case OMPD_teams_distribute_parallel_for:\n    case OMPD_teams_distribute_parallel_for_simd:\n    case OMPD_target_teams_distribute_parallel_for:\n    case OMPD_target_teams_distribute_parallel_for_simd:\n      CaptureRegion = OMPD_teams;\n      break;\n    case OMPD_parallel:\n    case OMPD_parallel_master:\n    case OMPD_parallel_sections:\n    case OMPD_parallel_for:\n    case OMPD_parallel_for_simd:\n    case OMPD_distribute_parallel_for:\n    case OMPD_distribute_parallel_for_simd:\n    case OMPD_parallel_master_taskloop:\n    case OMPD_parallel_master_taskloop_simd:\n      // Do not capture num_threads-clause expressions.\n      break;\n    case OMPD_target_data:\n    case OMPD_target_enter_data:\n    case OMPD_target_exit_data:\n    case OMPD_target_update:\n    case OMPD_target:\n    case OMPD_target_simd:\n    case OMPD_target_teams:\n    case OMPD_target_teams_distribute:\n    case OMPD_target_teams_distribute_simd:\n    case OMPD_cancel:\n    case OMPD_task:\n    case OMPD_taskloop:\n    case OMPD_taskloop_simd:\n    case OMPD_master_taskloop:\n    case OMPD_master_taskloop_simd:\n    case OMPD_threadprivate:\n    case OMPD_allocate:\n    case OMPD_taskyield:\n    case OMPD_barrier:\n    case OMPD_taskwait:\n    case OMPD_cancellation_point:\n    case OMPD_flush:\n    case OMPD_depobj:\n    case OMPD_scan:\n    case OMPD_declare_reduction:\n    case OMPD_declare_mapper:\n    case OMPD_declare_simd:\n    case OMPD_declare_variant:\n    case OMPD_begin_declare_variant:\n    case OMPD_end_declare_variant:\n    case OMPD_declare_target:\n    case OMPD_end_declare_target:\n    case OMPD_teams:\n    case OMPD_simd:\n    case OMPD_tile:\n    case OMPD_for:\n    case OMPD_for_simd:\n    case OMPD_sections:\n    case OMPD_section:\n    case OMPD_single:\n    case OMPD_master:\n    case OMPD_critical:\n    case OMPD_taskgroup:\n    case OMPD_distribute:\n    case OMPD_ordered:\n    case OMPD_atomic:\n    case OMPD_distribute_simd:\n    case OMPD_teams_distribute:\n    case OMPD_teams_distribute_simd:\n    case OMPD_requires:\n      llvm_unreachable(\"Unexpected OpenMP directive with num_threads-clause\");\n    case OMPD_unknown:\n    default:\n      llvm_unreachable(\"Unknown OpenMP directive\");\n    }\n    break;\n  case OMPC_num_teams:\n    switch (DKind) {\n    case OMPD_target_teams:\n    case OMPD_target_teams_distribute:\n    case OMPD_target_teams_distribute_simd:\n    case OMPD_target_teams_distribute_parallel_for:\n    case OMPD_target_teams_distribute_parallel_for_simd:\n      CaptureRegion = OMPD_target;\n      break;\n    case OMPD_teams_distribute_parallel_for:\n    case OMPD_teams_distribute_parallel_for_simd:\n    case OMPD_teams:\n    case OMPD_teams_distribute:\n    case OMPD_teams_distribute_simd:\n      // Do not capture num_teams-clause expressions.\n      break;\n    case OMPD_distribute_parallel_for:\n    case OMPD_distribute_parallel_for_simd:\n    case OMPD_task:\n    case OMPD_taskloop:\n    case OMPD_taskloop_simd:\n    case OMPD_master_taskloop:\n    case OMPD_master_taskloop_simd:\n    case OMPD_parallel_master_taskloop:\n    case OMPD_parallel_master_taskloop_simd:\n    case OMPD_target_data:\n    case OMPD_target_enter_data:\n    case OMPD_target_exit_data:\n    case OMPD_target_update:\n    case OMPD_cancel:\n    case OMPD_parallel:\n    case OMPD_parallel_master:\n    case OMPD_parallel_sections:\n    case OMPD_parallel_for:\n    case OMPD_parallel_for_simd:\n    case OMPD_target:\n    case OMPD_target_simd:\n    case OMPD_target_parallel:\n    case OMPD_target_parallel_for:\n    case OMPD_target_parallel_for_simd:\n    case OMPD_threadprivate:\n    case OMPD_allocate:\n    case OMPD_taskyield:\n    case OMPD_barrier:\n    case OMPD_taskwait:\n    case OMPD_cancellation_point:\n    case OMPD_flush:\n    case OMPD_depobj:\n    case OMPD_scan:\n    case OMPD_declare_reduction:\n    case OMPD_declare_mapper:\n    case OMPD_declare_simd:\n    case OMPD_declare_variant:\n    case OMPD_begin_declare_variant:\n    case OMPD_end_declare_variant:\n    case OMPD_declare_target:\n    case OMPD_end_declare_target:\n    case OMPD_simd:\n    case OMPD_tile:\n    case OMPD_for:\n    case OMPD_for_simd:\n    case OMPD_sections:\n    case OMPD_section:\n    case OMPD_single:\n    case OMPD_master:\n    case OMPD_critical:\n    case OMPD_taskgroup:\n    case OMPD_distribute:\n    case OMPD_ordered:\n    case OMPD_atomic:\n    case OMPD_distribute_simd:\n    case OMPD_requires:\n      llvm_unreachable(\"Unexpected OpenMP directive with num_teams-clause\");\n    case OMPD_unknown:\n    default:\n      llvm_unreachable(\"Unknown OpenMP directive\");\n    }\n    break;\n  case OMPC_thread_limit:\n    switch (DKind) {\n    case OMPD_target_teams:\n    case OMPD_target_teams_distribute:\n    case OMPD_target_teams_distribute_simd:\n    case OMPD_target_teams_distribute_parallel_for:\n    case OMPD_target_teams_distribute_parallel_for_simd:\n      CaptureRegion = OMPD_target;\n      break;\n    case OMPD_teams_distribute_parallel_for:\n    case OMPD_teams_distribute_parallel_for_simd:\n    case OMPD_teams:\n    case OMPD_teams_distribute:\n    case OMPD_teams_distribute_simd:\n      // Do not capture thread_limit-clause expressions.\n      break;\n    case OMPD_distribute_parallel_for:\n    case OMPD_distribute_parallel_for_simd:\n    case OMPD_task:\n    case OMPD_taskloop:\n    case OMPD_taskloop_simd:\n    case OMPD_master_taskloop:\n    case OMPD_master_taskloop_simd:\n    case OMPD_parallel_master_taskloop:\n    case OMPD_parallel_master_taskloop_simd:\n    case OMPD_target_data:\n    case OMPD_target_enter_data:\n    case OMPD_target_exit_data:\n    case OMPD_target_update:\n    case OMPD_cancel:\n    case OMPD_parallel:\n    case OMPD_parallel_master:\n    case OMPD_parallel_sections:\n    case OMPD_parallel_for:\n    case OMPD_parallel_for_simd:\n    case OMPD_target:\n    case OMPD_target_simd:\n    case OMPD_target_parallel:\n    case OMPD_target_parallel_for:\n    case OMPD_target_parallel_for_simd:\n    case OMPD_threadprivate:\n    case OMPD_allocate:\n    case OMPD_taskyield:\n    case OMPD_barrier:\n    case OMPD_taskwait:\n    case OMPD_cancellation_point:\n    case OMPD_flush:\n    case OMPD_depobj:\n    case OMPD_scan:\n    case OMPD_declare_reduction:\n    case OMPD_declare_mapper:\n    case OMPD_declare_simd:\n    case OMPD_declare_variant:\n    case OMPD_begin_declare_variant:\n    case OMPD_end_declare_variant:\n    case OMPD_declare_target:\n    case OMPD_end_declare_target:\n    case OMPD_simd:\n    case OMPD_tile:\n    case OMPD_for:\n    case OMPD_for_simd:\n    case OMPD_sections:\n    case OMPD_section:\n    case OMPD_single:\n    case OMPD_master:\n    case OMPD_critical:\n    case OMPD_taskgroup:\n    case OMPD_distribute:\n    case OMPD_ordered:\n    case OMPD_atomic:\n    case OMPD_distribute_simd:\n    case OMPD_requires:\n      llvm_unreachable(\"Unexpected OpenMP directive with thread_limit-clause\");\n    case OMPD_unknown:\n    default:\n      llvm_unreachable(\"Unknown OpenMP directive\");\n    }\n    break;\n  case OMPC_schedule:\n    switch (DKind) {\n    case OMPD_parallel_for:\n    case OMPD_parallel_for_simd:\n    case OMPD_distribute_parallel_for:\n    case OMPD_distribute_parallel_for_simd:\n    case OMPD_teams_distribute_parallel_for:\n    case OMPD_teams_distribute_parallel_for_simd:\n    case OMPD_target_parallel_for:\n    case OMPD_target_parallel_for_simd:\n    case OMPD_target_teams_distribute_parallel_for:\n    case OMPD_target_teams_distribute_parallel_for_simd:\n      CaptureRegion = OMPD_parallel;\n      break;\n    case OMPD_for:\n    case OMPD_for_simd:\n      // Do not capture schedule-clause expressions.\n      break;\n    case OMPD_task:\n    case OMPD_taskloop:\n    case OMPD_taskloop_simd:\n    case OMPD_master_taskloop:\n    case OMPD_master_taskloop_simd:\n    case OMPD_parallel_master_taskloop:\n    case OMPD_parallel_master_taskloop_simd:\n    case OMPD_target_data:\n    case OMPD_target_enter_data:\n    case OMPD_target_exit_data:\n    case OMPD_target_update:\n    case OMPD_teams:\n    case OMPD_teams_distribute:\n    case OMPD_teams_distribute_simd:\n    case OMPD_target_teams_distribute:\n    case OMPD_target_teams_distribute_simd:\n    case OMPD_target:\n    case OMPD_target_simd:\n    case OMPD_target_parallel:\n    case OMPD_cancel:\n    case OMPD_parallel:\n    case OMPD_parallel_master:\n    case OMPD_parallel_sections:\n    case OMPD_threadprivate:\n    case OMPD_allocate:\n    case OMPD_taskyield:\n    case OMPD_barrier:\n    case OMPD_taskwait:\n    case OMPD_cancellation_point:\n    case OMPD_flush:\n    case OMPD_depobj:\n    case OMPD_scan:\n    case OMPD_declare_reduction:\n    case OMPD_declare_mapper:\n    case OMPD_declare_simd:\n    case OMPD_declare_variant:\n    case OMPD_begin_declare_variant:\n    case OMPD_end_declare_variant:\n    case OMPD_declare_target:\n    case OMPD_end_declare_target:\n    case OMPD_simd:\n    case OMPD_tile:\n    case OMPD_sections:\n    case OMPD_section:\n    case OMPD_single:\n    case OMPD_master:\n    case OMPD_critical:\n    case OMPD_taskgroup:\n    case OMPD_distribute:\n    case OMPD_ordered:\n    case OMPD_atomic:\n    case OMPD_distribute_simd:\n    case OMPD_target_teams:\n    case OMPD_requires:\n      llvm_unreachable(\"Unexpected OpenMP directive with schedule clause\");\n    case OMPD_unknown:\n    default:\n      llvm_unreachable(\"Unknown OpenMP directive\");\n    }\n    break;\n  case OMPC_dist_schedule:\n    switch (DKind) {\n    case OMPD_teams_distribute_parallel_for:\n    case OMPD_teams_distribute_parallel_for_simd:\n    case OMPD_teams_distribute:\n    case OMPD_teams_distribute_simd:\n    case OMPD_target_teams_distribute_parallel_for:\n    case OMPD_target_teams_distribute_parallel_for_simd:\n    case OMPD_target_teams_distribute:\n    case OMPD_target_teams_distribute_simd:\n      CaptureRegion = OMPD_teams;\n      break;\n    case OMPD_distribute_parallel_for:\n    case OMPD_distribute_parallel_for_simd:\n    case OMPD_distribute:\n    case OMPD_distribute_simd:\n      // Do not capture dist_schedule-clause expressions.\n      break;\n    case OMPD_parallel_for:\n    case OMPD_parallel_for_simd:\n    case OMPD_target_parallel_for_simd:\n    case OMPD_target_parallel_for:\n    case OMPD_task:\n    case OMPD_taskloop:\n    case OMPD_taskloop_simd:\n    case OMPD_master_taskloop:\n    case OMPD_master_taskloop_simd:\n    case OMPD_parallel_master_taskloop:\n    case OMPD_parallel_master_taskloop_simd:\n    case OMPD_target_data:\n    case OMPD_target_enter_data:\n    case OMPD_target_exit_data:\n    case OMPD_target_update:\n    case OMPD_teams:\n    case OMPD_target:\n    case OMPD_target_simd:\n    case OMPD_target_parallel:\n    case OMPD_cancel:\n    case OMPD_parallel:\n    case OMPD_parallel_master:\n    case OMPD_parallel_sections:\n    case OMPD_threadprivate:\n    case OMPD_allocate:\n    case OMPD_taskyield:\n    case OMPD_barrier:\n    case OMPD_taskwait:\n    case OMPD_cancellation_point:\n    case OMPD_flush:\n    case OMPD_depobj:\n    case OMPD_scan:\n    case OMPD_declare_reduction:\n    case OMPD_declare_mapper:\n    case OMPD_declare_simd:\n    case OMPD_declare_variant:\n    case OMPD_begin_declare_variant:\n    case OMPD_end_declare_variant:\n    case OMPD_declare_target:\n    case OMPD_end_declare_target:\n    case OMPD_simd:\n    case OMPD_tile:\n    case OMPD_for:\n    case OMPD_for_simd:\n    case OMPD_sections:\n    case OMPD_section:\n    case OMPD_single:\n    case OMPD_master:\n    case OMPD_critical:\n    case OMPD_taskgroup:\n    case OMPD_ordered:\n    case OMPD_atomic:\n    case OMPD_target_teams:\n    case OMPD_requires:\n      llvm_unreachable(\"Unexpected OpenMP directive with dist_schedule clause\");\n    case OMPD_unknown:\n    default:\n      llvm_unreachable(\"Unknown OpenMP directive\");\n    }\n    break;\n  case OMPC_device:\n    switch (DKind) {\n    case OMPD_target_update:\n    case OMPD_target_enter_data:\n    case OMPD_target_exit_data:\n    case OMPD_target:\n    case OMPD_target_simd:\n    case OMPD_target_teams:\n    case OMPD_target_parallel:\n    case OMPD_target_teams_distribute:\n    case OMPD_target_teams_distribute_simd:\n    case OMPD_target_parallel_for:\n    case OMPD_target_parallel_for_simd:\n    case OMPD_target_teams_distribute_parallel_for:\n    case OMPD_target_teams_distribute_parallel_for_simd:\n      CaptureRegion = OMPD_task;\n      break;\n    case OMPD_target_data:\n      // Do not capture device-clause expressions.\n      break;\n    case OMPD_teams_distribute_parallel_for:\n    case OMPD_teams_distribute_parallel_for_simd:\n    case OMPD_teams:\n    case OMPD_teams_distribute:\n    case OMPD_teams_distribute_simd:\n    case OMPD_distribute_parallel_for:\n    case OMPD_distribute_parallel_for_simd:\n    case OMPD_task:\n    case OMPD_taskloop:\n    case OMPD_taskloop_simd:\n    case OMPD_master_taskloop:\n    case OMPD_master_taskloop_simd:\n    case OMPD_parallel_master_taskloop:\n    case OMPD_parallel_master_taskloop_simd:\n    case OMPD_cancel:\n    case OMPD_parallel:\n    case OMPD_parallel_master:\n    case OMPD_parallel_sections:\n    case OMPD_parallel_for:\n    case OMPD_parallel_for_simd:\n    case OMPD_threadprivate:\n    case OMPD_allocate:\n    case OMPD_taskyield:\n    case OMPD_barrier:\n    case OMPD_taskwait:\n    case OMPD_cancellation_point:\n    case OMPD_flush:\n    case OMPD_depobj:\n    case OMPD_scan:\n    case OMPD_declare_reduction:\n    case OMPD_declare_mapper:\n    case OMPD_declare_simd:\n    case OMPD_declare_variant:\n    case OMPD_begin_declare_variant:\n    case OMPD_end_declare_variant:\n    case OMPD_declare_target:\n    case OMPD_end_declare_target:\n    case OMPD_simd:\n    case OMPD_tile:\n    case OMPD_for:\n    case OMPD_for_simd:\n    case OMPD_sections:\n    case OMPD_section:\n    case OMPD_single:\n    case OMPD_master:\n    case OMPD_critical:\n    case OMPD_taskgroup:\n    case OMPD_distribute:\n    case OMPD_ordered:\n    case OMPD_atomic:\n    case OMPD_distribute_simd:\n    case OMPD_requires:\n      llvm_unreachable(\"Unexpected OpenMP directive with device-clause\");\n    case OMPD_unknown:\n    default:\n      llvm_unreachable(\"Unknown OpenMP directive\");\n    }\n    break;\n  case OMPC_grainsize:\n  case OMPC_num_tasks:\n  case OMPC_final:\n  case OMPC_priority:\n    switch (DKind) {\n    case OMPD_task:\n    case OMPD_taskloop:\n    case OMPD_taskloop_simd:\n    case OMPD_master_taskloop:\n    case OMPD_master_taskloop_simd:\n      break;\n    case OMPD_parallel_master_taskloop:\n    case OMPD_parallel_master_taskloop_simd:\n      CaptureRegion = OMPD_parallel;\n      break;\n    case OMPD_target_update:\n    case OMPD_target_enter_data:\n    case OMPD_target_exit_data:\n    case OMPD_target:\n    case OMPD_target_simd:\n    case OMPD_target_teams:\n    case OMPD_target_parallel:\n    case OMPD_target_teams_distribute:\n    case OMPD_target_teams_distribute_simd:\n    case OMPD_target_parallel_for:\n    case OMPD_target_parallel_for_simd:\n    case OMPD_target_teams_distribute_parallel_for:\n    case OMPD_target_teams_distribute_parallel_for_simd:\n    case OMPD_target_data:\n    case OMPD_teams_distribute_parallel_for:\n    case OMPD_teams_distribute_parallel_for_simd:\n    case OMPD_teams:\n    case OMPD_teams_distribute:\n    case OMPD_teams_distribute_simd:\n    case OMPD_distribute_parallel_for:\n    case OMPD_distribute_parallel_for_simd:\n    case OMPD_cancel:\n    case OMPD_parallel:\n    case OMPD_parallel_master:\n    case OMPD_parallel_sections:\n    case OMPD_parallel_for:\n    case OMPD_parallel_for_simd:\n    case OMPD_threadprivate:\n    case OMPD_allocate:\n    case OMPD_taskyield:\n    case OMPD_barrier:\n    case OMPD_taskwait:\n    case OMPD_cancellation_point:\n    case OMPD_flush:\n    case OMPD_depobj:\n    case OMPD_scan:\n    case OMPD_declare_reduction:\n    case OMPD_declare_mapper:\n    case OMPD_declare_simd:\n    case OMPD_declare_variant:\n    case OMPD_begin_declare_variant:\n    case OMPD_end_declare_variant:\n    case OMPD_declare_target:\n    case OMPD_end_declare_target:\n    case OMPD_simd:\n    case OMPD_tile:\n    case OMPD_for:\n    case OMPD_for_simd:\n    case OMPD_sections:\n    case OMPD_section:\n    case OMPD_single:\n    case OMPD_master:\n    case OMPD_critical:\n    case OMPD_taskgroup:\n    case OMPD_distribute:\n    case OMPD_ordered:\n    case OMPD_atomic:\n    case OMPD_distribute_simd:\n    case OMPD_requires:\n      llvm_unreachable(\"Unexpected OpenMP directive with grainsize-clause\");\n    case OMPD_unknown:\n    default:\n      llvm_unreachable(\"Unknown OpenMP directive\");\n    }\n    break;\n  case OMPC_firstprivate:\n  case OMPC_lastprivate:\n  case OMPC_reduction:\n  case OMPC_task_reduction:\n  case OMPC_in_reduction:\n  case OMPC_linear:\n  case OMPC_default:\n  case OMPC_proc_bind:\n  case OMPC_safelen:\n  case OMPC_simdlen:\n  case OMPC_sizes:\n  case OMPC_allocator:\n  case OMPC_collapse:\n  case OMPC_private:\n  case OMPC_shared:\n  case OMPC_aligned:\n  case OMPC_copyin:\n  case OMPC_copyprivate:\n  case OMPC_ordered:\n  case OMPC_nowait:\n  case OMPC_untied:\n  case OMPC_mergeable:\n  case OMPC_threadprivate:\n  case OMPC_allocate:\n  case OMPC_flush:\n  case OMPC_depobj:\n  case OMPC_read:\n  case OMPC_write:\n  case OMPC_update:\n  case OMPC_capture:\n  case OMPC_seq_cst:\n  case OMPC_acq_rel:\n  case OMPC_acquire:\n  case OMPC_release:\n  case OMPC_relaxed:\n  case OMPC_depend:\n  case OMPC_threads:\n  case OMPC_simd:\n  case OMPC_map:\n  case OMPC_nogroup:\n  case OMPC_hint:\n  case OMPC_defaultmap:\n  case OMPC_unknown:\n  case OMPC_uniform:\n  case OMPC_to:\n  case OMPC_from:\n  case OMPC_use_device_ptr:\n  case OMPC_use_device_addr:\n  case OMPC_is_device_ptr:\n  case OMPC_unified_address:\n  case OMPC_unified_shared_memory:\n  case OMPC_reverse_offload:\n  case OMPC_dynamic_allocators:\n  case OMPC_atomic_default_mem_order:\n  case OMPC_device_type:\n  case OMPC_match:\n  case OMPC_nontemporal:\n  case OMPC_order:\n  case OMPC_destroy:\n  case OMPC_detach:\n  case OMPC_inclusive:\n  case OMPC_exclusive:\n  case OMPC_uses_allocators:\n  case OMPC_affinity:\n  default:\n    llvm_unreachable(\"Unexpected OpenMP clause.\");\n  }\n  return CaptureRegion;\n}\n\nOMPClause *Sema::ActOnOpenMPIfClause(OpenMPDirectiveKind NameModifier,\n                                     Expr *Condition, SourceLocation StartLoc,\n                                     SourceLocation LParenLoc,\n                                     SourceLocation NameModifierLoc,\n                                     SourceLocation ColonLoc,\n                                     SourceLocation EndLoc) {\n  Expr *ValExpr = Condition;\n  Stmt *HelperValStmt = nullptr;\n  OpenMPDirectiveKind CaptureRegion = OMPD_unknown;\n  if (!Condition->isValueDependent() && !Condition->isTypeDependent() &&\n      !Condition->isInstantiationDependent() &&\n      !Condition->containsUnexpandedParameterPack()) {\n    ExprResult Val = CheckBooleanCondition(StartLoc, Condition);\n    if (Val.isInvalid())\n      return nullptr;\n\n    ValExpr = Val.get();\n\n    OpenMPDirectiveKind DKind = DSAStack->getCurrentDirective();\n    CaptureRegion = getOpenMPCaptureRegionForClause(\n        DKind, OMPC_if, LangOpts.OpenMP, NameModifier);\n    if (CaptureRegion != OMPD_unknown && !CurContext->isDependentContext()) {\n      ValExpr = MakeFullExpr(ValExpr).get();\n      llvm::MapVector<const Expr *, DeclRefExpr *> Captures;\n      ValExpr = tryBuildCapture(*this, ValExpr, Captures).get();\n      HelperValStmt = buildPreInits(Context, Captures);\n    }\n  }\n\n  return new (Context)\n      OMPIfClause(NameModifier, ValExpr, HelperValStmt, CaptureRegion, StartLoc,\n                  LParenLoc, NameModifierLoc, ColonLoc, EndLoc);\n}\n\nOMPClause *Sema::ActOnOpenMPFinalClause(Expr *Condition,\n                                        SourceLocation StartLoc,\n                                        SourceLocation LParenLoc,\n                                        SourceLocation EndLoc) {\n  Expr *ValExpr = Condition;\n  Stmt *HelperValStmt = nullptr;\n  OpenMPDirectiveKind CaptureRegion = OMPD_unknown;\n  if (!Condition->isValueDependent() && !Condition->isTypeDependent() &&\n      !Condition->isInstantiationDependent() &&\n      !Condition->containsUnexpandedParameterPack()) {\n    ExprResult Val = CheckBooleanCondition(StartLoc, Condition);\n    if (Val.isInvalid())\n      return nullptr;\n\n    ValExpr = MakeFullExpr(Val.get()).get();\n\n    OpenMPDirectiveKind DKind = DSAStack->getCurrentDirective();\n    CaptureRegion =\n        getOpenMPCaptureRegionForClause(DKind, OMPC_final, LangOpts.OpenMP);\n    if (CaptureRegion != OMPD_unknown && !CurContext->isDependentContext()) {\n      ValExpr = MakeFullExpr(ValExpr).get();\n      llvm::MapVector<const Expr *, DeclRefExpr *> Captures;\n      ValExpr = tryBuildCapture(*this, ValExpr, Captures).get();\n      HelperValStmt = buildPreInits(Context, Captures);\n    }\n  }\n\n  return new (Context) OMPFinalClause(ValExpr, HelperValStmt, CaptureRegion,\n                                      StartLoc, LParenLoc, EndLoc);\n}\n\nExprResult Sema::PerformOpenMPImplicitIntegerConversion(SourceLocation Loc,\n                                                        Expr *Op) {\n  if (!Op)\n    return ExprError();\n\n  class IntConvertDiagnoser : public ICEConvertDiagnoser {\n  public:\n    IntConvertDiagnoser()\n        : ICEConvertDiagnoser(/*AllowScopedEnumerations*/ false, false, true) {}\n    SemaDiagnosticBuilder diagnoseNotInt(Sema &S, SourceLocation Loc,\n                                         QualType T) override {\n      return S.Diag(Loc, diag::err_omp_not_integral) << T;\n    }\n    SemaDiagnosticBuilder diagnoseIncomplete(Sema &S, SourceLocation Loc,\n                                             QualType T) override {\n      return S.Diag(Loc, diag::err_omp_incomplete_type) << T;\n    }\n    SemaDiagnosticBuilder diagnoseExplicitConv(Sema &S, SourceLocation Loc,\n                                               QualType T,\n                                               QualType ConvTy) override {\n      return S.Diag(Loc, diag::err_omp_explicit_conversion) << T << ConvTy;\n    }\n    SemaDiagnosticBuilder noteExplicitConv(Sema &S, CXXConversionDecl *Conv,\n                                           QualType ConvTy) override {\n      return S.Diag(Conv->getLocation(), diag::note_omp_conversion_here)\n             << ConvTy->isEnumeralType() << ConvTy;\n    }\n    SemaDiagnosticBuilder diagnoseAmbiguous(Sema &S, SourceLocation Loc,\n                                            QualType T) override {\n      return S.Diag(Loc, diag::err_omp_ambiguous_conversion) << T;\n    }\n    SemaDiagnosticBuilder noteAmbiguous(Sema &S, CXXConversionDecl *Conv,\n                                        QualType ConvTy) override {\n      return S.Diag(Conv->getLocation(), diag::note_omp_conversion_here)\n             << ConvTy->isEnumeralType() << ConvTy;\n    }\n    SemaDiagnosticBuilder diagnoseConversion(Sema &, SourceLocation, QualType,\n                                             QualType) override {\n      llvm_unreachable(\"conversion functions are permitted\");\n    }\n  } ConvertDiagnoser;\n  return PerformContextualImplicitConversion(Loc, Op, ConvertDiagnoser);\n}\n\nstatic bool\nisNonNegativeIntegerValue(Expr *&ValExpr, Sema &SemaRef, OpenMPClauseKind CKind,\n                          bool StrictlyPositive, bool BuildCapture = false,\n                          OpenMPDirectiveKind DKind = OMPD_unknown,\n                          OpenMPDirectiveKind *CaptureRegion = nullptr,\n                          Stmt **HelperValStmt = nullptr) {\n  if (!ValExpr->isTypeDependent() && !ValExpr->isValueDependent() &&\n      !ValExpr->isInstantiationDependent()) {\n    SourceLocation Loc = ValExpr->getExprLoc();\n    ExprResult Value =\n        SemaRef.PerformOpenMPImplicitIntegerConversion(Loc, ValExpr);\n    if (Value.isInvalid())\n      return false;\n\n    ValExpr = Value.get();\n    // The expression must evaluate to a non-negative integer value.\n    if (Optional<llvm::APSInt> Result =\n            ValExpr->getIntegerConstantExpr(SemaRef.Context)) {\n      if (Result->isSigned() &&\n          !((!StrictlyPositive && Result->isNonNegative()) ||\n            (StrictlyPositive && Result->isStrictlyPositive()))) {\n        SemaRef.Diag(Loc, diag::err_omp_negative_expression_in_clause)\n            << getOpenMPClauseName(CKind) << (StrictlyPositive ? 1 : 0)\n            << ValExpr->getSourceRange();\n        return false;\n      }\n    }\n    if (!BuildCapture)\n      return true;\n    *CaptureRegion =\n        getOpenMPCaptureRegionForClause(DKind, CKind, SemaRef.LangOpts.OpenMP);\n    if (*CaptureRegion != OMPD_unknown &&\n        !SemaRef.CurContext->isDependentContext()) {\n      ValExpr = SemaRef.MakeFullExpr(ValExpr).get();\n      llvm::MapVector<const Expr *, DeclRefExpr *> Captures;\n      ValExpr = tryBuildCapture(SemaRef, ValExpr, Captures).get();\n      *HelperValStmt = buildPreInits(SemaRef.Context, Captures);\n    }\n  }\n  return true;\n}\n\nOMPClause *Sema::ActOnOpenMPNumThreadsClause(Expr *NumThreads,\n                                             SourceLocation StartLoc,\n                                             SourceLocation LParenLoc,\n                                             SourceLocation EndLoc) {\n  Expr *ValExpr = NumThreads;\n  Stmt *HelperValStmt = nullptr;\n\n  // OpenMP [2.5, Restrictions]\n  //  The num_threads expression must evaluate to a positive integer value.\n  if (!isNonNegativeIntegerValue(ValExpr, *this, OMPC_num_threads,\n                                 /*StrictlyPositive=*/true))\n    return nullptr;\n\n  OpenMPDirectiveKind DKind = DSAStack->getCurrentDirective();\n  OpenMPDirectiveKind CaptureRegion =\n      getOpenMPCaptureRegionForClause(DKind, OMPC_num_threads, LangOpts.OpenMP);\n  if (CaptureRegion != OMPD_unknown && !CurContext->isDependentContext()) {\n    ValExpr = MakeFullExpr(ValExpr).get();\n    llvm::MapVector<const Expr *, DeclRefExpr *> Captures;\n    ValExpr = tryBuildCapture(*this, ValExpr, Captures).get();\n    HelperValStmt = buildPreInits(Context, Captures);\n  }\n\n  return new (Context) OMPNumThreadsClause(\n      ValExpr, HelperValStmt, CaptureRegion, StartLoc, LParenLoc, EndLoc);\n}\n\nExprResult Sema::VerifyPositiveIntegerConstantInClause(Expr *E,\n                                                       OpenMPClauseKind CKind,\n                                                       bool StrictlyPositive) {\n  if (!E)\n    return ExprError();\n  if (E->isValueDependent() || E->isTypeDependent() ||\n      E->isInstantiationDependent() || E->containsUnexpandedParameterPack())\n    return E;\n  llvm::APSInt Result;\n  ExprResult ICE =\n      VerifyIntegerConstantExpression(E, &Result, /*FIXME*/ AllowFold);\n  if (ICE.isInvalid())\n    return ExprError();\n  if ((StrictlyPositive && !Result.isStrictlyPositive()) ||\n      (!StrictlyPositive && !Result.isNonNegative())) {\n    Diag(E->getExprLoc(), diag::err_omp_negative_expression_in_clause)\n        << getOpenMPClauseName(CKind) << (StrictlyPositive ? 1 : 0)\n        << E->getSourceRange();\n    return ExprError();\n  }\n  if (CKind == OMPC_aligned && !Result.isPowerOf2()) {\n    Diag(E->getExprLoc(), diag::warn_omp_alignment_not_power_of_two)\n        << E->getSourceRange();\n    return ExprError();\n  }\n  if (CKind == OMPC_collapse && DSAStack->getAssociatedLoops() == 1)\n    DSAStack->setAssociatedLoops(Result.getExtValue());\n  else if (CKind == OMPC_ordered)\n    DSAStack->setAssociatedLoops(Result.getExtValue());\n  return ICE;\n}\n\nOMPClause *Sema::ActOnOpenMPSafelenClause(Expr *Len, SourceLocation StartLoc,\n                                          SourceLocation LParenLoc,\n                                          SourceLocation EndLoc) {\n  // OpenMP [2.8.1, simd construct, Description]\n  // The parameter of the safelen clause must be a constant\n  // positive integer expression.\n  ExprResult Safelen = VerifyPositiveIntegerConstantInClause(Len, OMPC_safelen);\n  if (Safelen.isInvalid())\n    return nullptr;\n  return new (Context)\n      OMPSafelenClause(Safelen.get(), StartLoc, LParenLoc, EndLoc);\n}\n\nOMPClause *Sema::ActOnOpenMPSimdlenClause(Expr *Len, SourceLocation StartLoc,\n                                          SourceLocation LParenLoc,\n                                          SourceLocation EndLoc) {\n  // OpenMP [2.8.1, simd construct, Description]\n  // The parameter of the simdlen clause must be a constant\n  // positive integer expression.\n  ExprResult Simdlen = VerifyPositiveIntegerConstantInClause(Len, OMPC_simdlen);\n  if (Simdlen.isInvalid())\n    return nullptr;\n  return new (Context)\n      OMPSimdlenClause(Simdlen.get(), StartLoc, LParenLoc, EndLoc);\n}\n\n/// Tries to find omp_allocator_handle_t type.\nstatic bool findOMPAllocatorHandleT(Sema &S, SourceLocation Loc,\n                                    DSAStackTy *Stack) {\n  QualType OMPAllocatorHandleT = Stack->getOMPAllocatorHandleT();\n  if (!OMPAllocatorHandleT.isNull())\n    return true;\n  // Build the predefined allocator expressions.\n  bool ErrorFound = false;\n  for (int I = 0; I < OMPAllocateDeclAttr::OMPUserDefinedMemAlloc; ++I) {\n    auto AllocatorKind = static_cast<OMPAllocateDeclAttr::AllocatorTypeTy>(I);\n    StringRef Allocator =\n        OMPAllocateDeclAttr::ConvertAllocatorTypeTyToStr(AllocatorKind);\n    DeclarationName AllocatorName = &S.getASTContext().Idents.get(Allocator);\n    auto *VD = dyn_cast_or_null<ValueDecl>(\n        S.LookupSingleName(S.TUScope, AllocatorName, Loc, Sema::LookupAnyName));\n    if (!VD) {\n      ErrorFound = true;\n      break;\n    }\n    QualType AllocatorType =\n        VD->getType().getNonLValueExprType(S.getASTContext());\n    ExprResult Res = S.BuildDeclRefExpr(VD, AllocatorType, VK_LValue, Loc);\n    if (!Res.isUsable()) {\n      ErrorFound = true;\n      break;\n    }\n    if (OMPAllocatorHandleT.isNull())\n      OMPAllocatorHandleT = AllocatorType;\n    if (!S.getASTContext().hasSameType(OMPAllocatorHandleT, AllocatorType)) {\n      ErrorFound = true;\n      break;\n    }\n    Stack->setAllocator(AllocatorKind, Res.get());\n  }\n  if (ErrorFound) {\n    S.Diag(Loc, diag::err_omp_implied_type_not_found)\n        << \"omp_allocator_handle_t\";\n    return false;\n  }\n  OMPAllocatorHandleT.addConst();\n  Stack->setOMPAllocatorHandleT(OMPAllocatorHandleT);\n  return true;\n}\n\nOMPClause *Sema::ActOnOpenMPAllocatorClause(Expr *A, SourceLocation StartLoc,\n                                            SourceLocation LParenLoc,\n                                            SourceLocation EndLoc) {\n  // OpenMP [2.11.3, allocate Directive, Description]\n  // allocator is an expression of omp_allocator_handle_t type.\n  if (!findOMPAllocatorHandleT(*this, A->getExprLoc(), DSAStack))\n    return nullptr;\n\n  ExprResult Allocator = DefaultLvalueConversion(A);\n  if (Allocator.isInvalid())\n    return nullptr;\n  Allocator = PerformImplicitConversion(Allocator.get(),\n                                        DSAStack->getOMPAllocatorHandleT(),\n                                        Sema::AA_Initializing,\n                                        /*AllowExplicit=*/true);\n  if (Allocator.isInvalid())\n    return nullptr;\n  return new (Context)\n      OMPAllocatorClause(Allocator.get(), StartLoc, LParenLoc, EndLoc);\n}\n\nOMPClause *Sema::ActOnOpenMPCollapseClause(Expr *NumForLoops,\n                                           SourceLocation StartLoc,\n                                           SourceLocation LParenLoc,\n                                           SourceLocation EndLoc) {\n  // OpenMP [2.7.1, loop construct, Description]\n  // OpenMP [2.8.1, simd construct, Description]\n  // OpenMP [2.9.6, distribute construct, Description]\n  // The parameter of the collapse clause must be a constant\n  // positive integer expression.\n  ExprResult NumForLoopsResult =\n      VerifyPositiveIntegerConstantInClause(NumForLoops, OMPC_collapse);\n  if (NumForLoopsResult.isInvalid())\n    return nullptr;\n  return new (Context)\n      OMPCollapseClause(NumForLoopsResult.get(), StartLoc, LParenLoc, EndLoc);\n}\n\nOMPClause *Sema::ActOnOpenMPOrderedClause(SourceLocation StartLoc,\n                                          SourceLocation EndLoc,\n                                          SourceLocation LParenLoc,\n                                          Expr *NumForLoops) {\n  // OpenMP [2.7.1, loop construct, Description]\n  // OpenMP [2.8.1, simd construct, Description]\n  // OpenMP [2.9.6, distribute construct, Description]\n  // The parameter of the ordered clause must be a constant\n  // positive integer expression if any.\n  if (NumForLoops && LParenLoc.isValid()) {\n    ExprResult NumForLoopsResult =\n        VerifyPositiveIntegerConstantInClause(NumForLoops, OMPC_ordered);\n    if (NumForLoopsResult.isInvalid())\n      return nullptr;\n    NumForLoops = NumForLoopsResult.get();\n  } else {\n    NumForLoops = nullptr;\n  }\n  auto *Clause = OMPOrderedClause::Create(\n      Context, NumForLoops, NumForLoops ? DSAStack->getAssociatedLoops() : 0,\n      StartLoc, LParenLoc, EndLoc);\n  DSAStack->setOrderedRegion(/*IsOrdered=*/true, NumForLoops, Clause);\n  return Clause;\n}\n\nOMPClause *Sema::ActOnOpenMPSimpleClause(\n    OpenMPClauseKind Kind, unsigned Argument, SourceLocation ArgumentLoc,\n    SourceLocation StartLoc, SourceLocation LParenLoc, SourceLocation EndLoc) {\n  OMPClause *Res = nullptr;\n  switch (Kind) {\n  case OMPC_default:\n    Res = ActOnOpenMPDefaultClause(static_cast<DefaultKind>(Argument),\n                                   ArgumentLoc, StartLoc, LParenLoc, EndLoc);\n    break;\n  case OMPC_proc_bind:\n    Res = ActOnOpenMPProcBindClause(static_cast<ProcBindKind>(Argument),\n                                    ArgumentLoc, StartLoc, LParenLoc, EndLoc);\n    break;\n  case OMPC_atomic_default_mem_order:\n    Res = ActOnOpenMPAtomicDefaultMemOrderClause(\n        static_cast<OpenMPAtomicDefaultMemOrderClauseKind>(Argument),\n        ArgumentLoc, StartLoc, LParenLoc, EndLoc);\n    break;\n  case OMPC_order:\n    Res = ActOnOpenMPOrderClause(static_cast<OpenMPOrderClauseKind>(Argument),\n                                 ArgumentLoc, StartLoc, LParenLoc, EndLoc);\n    break;\n  case OMPC_update:\n    Res = ActOnOpenMPUpdateClause(static_cast<OpenMPDependClauseKind>(Argument),\n                                  ArgumentLoc, StartLoc, LParenLoc, EndLoc);\n    break;\n  case OMPC_if:\n  case OMPC_final:\n  case OMPC_num_threads:\n  case OMPC_safelen:\n  case OMPC_simdlen:\n  case OMPC_sizes:\n  case OMPC_allocator:\n  case OMPC_collapse:\n  case OMPC_schedule:\n  case OMPC_private:\n  case OMPC_firstprivate:\n  case OMPC_lastprivate:\n  case OMPC_shared:\n  case OMPC_reduction:\n  case OMPC_task_reduction:\n  case OMPC_in_reduction:\n  case OMPC_linear:\n  case OMPC_aligned:\n  case OMPC_copyin:\n  case OMPC_copyprivate:\n  case OMPC_ordered:\n  case OMPC_nowait:\n  case OMPC_untied:\n  case OMPC_mergeable:\n  case OMPC_threadprivate:\n  case OMPC_allocate:\n  case OMPC_flush:\n  case OMPC_depobj:\n  case OMPC_read:\n  case OMPC_write:\n  case OMPC_capture:\n  case OMPC_seq_cst:\n  case OMPC_acq_rel:\n  case OMPC_acquire:\n  case OMPC_release:\n  case OMPC_relaxed:\n  case OMPC_depend:\n  case OMPC_device:\n  case OMPC_threads:\n  case OMPC_simd:\n  case OMPC_map:\n  case OMPC_num_teams:\n  case OMPC_thread_limit:\n  case OMPC_priority:\n  case OMPC_grainsize:\n  case OMPC_nogroup:\n  case OMPC_num_tasks:\n  case OMPC_hint:\n  case OMPC_dist_schedule:\n  case OMPC_defaultmap:\n  case OMPC_unknown:\n  case OMPC_uniform:\n  case OMPC_to:\n  case OMPC_from:\n  case OMPC_use_device_ptr:\n  case OMPC_use_device_addr:\n  case OMPC_is_device_ptr:\n  case OMPC_unified_address:\n  case OMPC_unified_shared_memory:\n  case OMPC_reverse_offload:\n  case OMPC_dynamic_allocators:\n  case OMPC_device_type:\n  case OMPC_match:\n  case OMPC_nontemporal:\n  case OMPC_destroy:\n  case OMPC_detach:\n  case OMPC_inclusive:\n  case OMPC_exclusive:\n  case OMPC_uses_allocators:\n  case OMPC_affinity:\n  default:\n    llvm_unreachable(\"Clause is not allowed.\");\n  }\n  return Res;\n}\n\nstatic std::string\ngetListOfPossibleValues(OpenMPClauseKind K, unsigned First, unsigned Last,\n                        ArrayRef<unsigned> Exclude = llvm::None) {\n  SmallString<256> Buffer;\n  llvm::raw_svector_ostream Out(Buffer);\n  unsigned Skipped = Exclude.size();\n  auto S = Exclude.begin(), E = Exclude.end();\n  for (unsigned I = First; I < Last; ++I) {\n    if (std::find(S, E, I) != E) {\n      --Skipped;\n      continue;\n    }\n    Out << \"'\" << getOpenMPSimpleClauseTypeName(K, I) << \"'\";\n    if (I + Skipped + 2 == Last)\n      Out << \" or \";\n    else if (I + Skipped + 1 != Last)\n      Out << \", \";\n  }\n  return std::string(Out.str());\n}\n\nOMPClause *Sema::ActOnOpenMPDefaultClause(DefaultKind Kind,\n                                          SourceLocation KindKwLoc,\n                                          SourceLocation StartLoc,\n                                          SourceLocation LParenLoc,\n                                          SourceLocation EndLoc) {\n  if (Kind == OMP_DEFAULT_unknown) {\n    Diag(KindKwLoc, diag::err_omp_unexpected_clause_value)\n        << getListOfPossibleValues(OMPC_default, /*First=*/0,\n                                   /*Last=*/unsigned(OMP_DEFAULT_unknown))\n        << getOpenMPClauseName(OMPC_default);\n    return nullptr;\n  }\n\n  switch (Kind) {\n  case OMP_DEFAULT_none:\n    DSAStack->setDefaultDSANone(KindKwLoc);\n    break;\n  case OMP_DEFAULT_shared:\n    DSAStack->setDefaultDSAShared(KindKwLoc);\n    break;\n  case OMP_DEFAULT_firstprivate:\n    DSAStack->setDefaultDSAFirstPrivate(KindKwLoc);\n    break;\n  default:\n    llvm_unreachable(\"DSA unexpected in OpenMP default clause\");\n  }\n\n  return new (Context)\n      OMPDefaultClause(Kind, KindKwLoc, StartLoc, LParenLoc, EndLoc);\n}\n\nOMPClause *Sema::ActOnOpenMPProcBindClause(ProcBindKind Kind,\n                                           SourceLocation KindKwLoc,\n                                           SourceLocation StartLoc,\n                                           SourceLocation LParenLoc,\n                                           SourceLocation EndLoc) {\n  if (Kind == OMP_PROC_BIND_unknown) {\n    Diag(KindKwLoc, diag::err_omp_unexpected_clause_value)\n        << getListOfPossibleValues(OMPC_proc_bind,\n                                   /*First=*/unsigned(OMP_PROC_BIND_master),\n                                   /*Last=*/5)\n        << getOpenMPClauseName(OMPC_proc_bind);\n    return nullptr;\n  }\n  return new (Context)\n      OMPProcBindClause(Kind, KindKwLoc, StartLoc, LParenLoc, EndLoc);\n}\n\nOMPClause *Sema::ActOnOpenMPAtomicDefaultMemOrderClause(\n    OpenMPAtomicDefaultMemOrderClauseKind Kind, SourceLocation KindKwLoc,\n    SourceLocation StartLoc, SourceLocation LParenLoc, SourceLocation EndLoc) {\n  if (Kind == OMPC_ATOMIC_DEFAULT_MEM_ORDER_unknown) {\n    Diag(KindKwLoc, diag::err_omp_unexpected_clause_value)\n        << getListOfPossibleValues(\n               OMPC_atomic_default_mem_order, /*First=*/0,\n               /*Last=*/OMPC_ATOMIC_DEFAULT_MEM_ORDER_unknown)\n        << getOpenMPClauseName(OMPC_atomic_default_mem_order);\n    return nullptr;\n  }\n  return new (Context) OMPAtomicDefaultMemOrderClause(Kind, KindKwLoc, StartLoc,\n                                                      LParenLoc, EndLoc);\n}\n\nOMPClause *Sema::ActOnOpenMPOrderClause(OpenMPOrderClauseKind Kind,\n                                        SourceLocation KindKwLoc,\n                                        SourceLocation StartLoc,\n                                        SourceLocation LParenLoc,\n                                        SourceLocation EndLoc) {\n  if (Kind == OMPC_ORDER_unknown) {\n    static_assert(OMPC_ORDER_unknown > 0,\n                  \"OMPC_ORDER_unknown not greater than 0\");\n    Diag(KindKwLoc, diag::err_omp_unexpected_clause_value)\n        << getListOfPossibleValues(OMPC_order, /*First=*/0,\n                                   /*Last=*/OMPC_ORDER_unknown)\n        << getOpenMPClauseName(OMPC_order);\n    return nullptr;\n  }\n  return new (Context)\n      OMPOrderClause(Kind, KindKwLoc, StartLoc, LParenLoc, EndLoc);\n}\n\nOMPClause *Sema::ActOnOpenMPUpdateClause(OpenMPDependClauseKind Kind,\n                                         SourceLocation KindKwLoc,\n                                         SourceLocation StartLoc,\n                                         SourceLocation LParenLoc,\n                                         SourceLocation EndLoc) {\n  if (Kind == OMPC_DEPEND_unknown || Kind == OMPC_DEPEND_source ||\n      Kind == OMPC_DEPEND_sink || Kind == OMPC_DEPEND_depobj) {\n    unsigned Except[] = {OMPC_DEPEND_source, OMPC_DEPEND_sink,\n                         OMPC_DEPEND_depobj};\n    Diag(KindKwLoc, diag::err_omp_unexpected_clause_value)\n        << getListOfPossibleValues(OMPC_depend, /*First=*/0,\n                                   /*Last=*/OMPC_DEPEND_unknown, Except)\n        << getOpenMPClauseName(OMPC_update);\n    return nullptr;\n  }\n  return OMPUpdateClause::Create(Context, StartLoc, LParenLoc, KindKwLoc, Kind,\n                                 EndLoc);\n}\n\nOMPClause *Sema::ActOnOpenMPSizesClause(ArrayRef<Expr *> SizeExprs,\n                                        SourceLocation StartLoc,\n                                        SourceLocation LParenLoc,\n                                        SourceLocation EndLoc) {\n  for (Expr *SizeExpr : SizeExprs) {\n    ExprResult NumForLoopsResult = VerifyPositiveIntegerConstantInClause(\n        SizeExpr, OMPC_sizes, /*StrictlyPositive=*/true);\n    if (!NumForLoopsResult.isUsable())\n      return nullptr;\n  }\n\n  DSAStack->setAssociatedLoops(SizeExprs.size());\n  return OMPSizesClause::Create(Context, StartLoc, LParenLoc, EndLoc,\n                                SizeExprs);\n}\n\nOMPClause *Sema::ActOnOpenMPSingleExprWithArgClause(\n    OpenMPClauseKind Kind, ArrayRef<unsigned> Argument, Expr *Expr,\n    SourceLocation StartLoc, SourceLocation LParenLoc,\n    ArrayRef<SourceLocation> ArgumentLoc, SourceLocation DelimLoc,\n    SourceLocation EndLoc) {\n  OMPClause *Res = nullptr;\n  switch (Kind) {\n  case OMPC_schedule:\n    enum { Modifier1, Modifier2, ScheduleKind, NumberOfElements };\n    assert(Argument.size() == NumberOfElements &&\n           ArgumentLoc.size() == NumberOfElements);\n    Res = ActOnOpenMPScheduleClause(\n        static_cast<OpenMPScheduleClauseModifier>(Argument[Modifier1]),\n        static_cast<OpenMPScheduleClauseModifier>(Argument[Modifier2]),\n        static_cast<OpenMPScheduleClauseKind>(Argument[ScheduleKind]), Expr,\n        StartLoc, LParenLoc, ArgumentLoc[Modifier1], ArgumentLoc[Modifier2],\n        ArgumentLoc[ScheduleKind], DelimLoc, EndLoc);\n    break;\n  case OMPC_if:\n    assert(Argument.size() == 1 && ArgumentLoc.size() == 1);\n    Res = ActOnOpenMPIfClause(static_cast<OpenMPDirectiveKind>(Argument.back()),\n                              Expr, StartLoc, LParenLoc, ArgumentLoc.back(),\n                              DelimLoc, EndLoc);\n    break;\n  case OMPC_dist_schedule:\n    Res = ActOnOpenMPDistScheduleClause(\n        static_cast<OpenMPDistScheduleClauseKind>(Argument.back()), Expr,\n        StartLoc, LParenLoc, ArgumentLoc.back(), DelimLoc, EndLoc);\n    break;\n  case OMPC_defaultmap:\n    enum { Modifier, DefaultmapKind };\n    Res = ActOnOpenMPDefaultmapClause(\n        static_cast<OpenMPDefaultmapClauseModifier>(Argument[Modifier]),\n        static_cast<OpenMPDefaultmapClauseKind>(Argument[DefaultmapKind]),\n        StartLoc, LParenLoc, ArgumentLoc[Modifier], ArgumentLoc[DefaultmapKind],\n        EndLoc);\n    break;\n  case OMPC_device:\n    assert(Argument.size() == 1 && ArgumentLoc.size() == 1);\n    Res = ActOnOpenMPDeviceClause(\n        static_cast<OpenMPDeviceClauseModifier>(Argument.back()), Expr,\n        StartLoc, LParenLoc, ArgumentLoc.back(), EndLoc);\n    break;\n  case OMPC_final:\n  case OMPC_num_threads:\n  case OMPC_safelen:\n  case OMPC_simdlen:\n  case OMPC_sizes:\n  case OMPC_allocator:\n  case OMPC_collapse:\n  case OMPC_default:\n  case OMPC_proc_bind:\n  case OMPC_private:\n  case OMPC_firstprivate:\n  case OMPC_lastprivate:\n  case OMPC_shared:\n  case OMPC_reduction:\n  case OMPC_task_reduction:\n  case OMPC_in_reduction:\n  case OMPC_linear:\n  case OMPC_aligned:\n  case OMPC_copyin:\n  case OMPC_copyprivate:\n  case OMPC_ordered:\n  case OMPC_nowait:\n  case OMPC_untied:\n  case OMPC_mergeable:\n  case OMPC_threadprivate:\n  case OMPC_allocate:\n  case OMPC_flush:\n  case OMPC_depobj:\n  case OMPC_read:\n  case OMPC_write:\n  case OMPC_update:\n  case OMPC_capture:\n  case OMPC_seq_cst:\n  case OMPC_acq_rel:\n  case OMPC_acquire:\n  case OMPC_release:\n  case OMPC_relaxed:\n  case OMPC_depend:\n  case OMPC_threads:\n  case OMPC_simd:\n  case OMPC_map:\n  case OMPC_num_teams:\n  case OMPC_thread_limit:\n  case OMPC_priority:\n  case OMPC_grainsize:\n  case OMPC_nogroup:\n  case OMPC_num_tasks:\n  case OMPC_hint:\n  case OMPC_unknown:\n  case OMPC_uniform:\n  case OMPC_to:\n  case OMPC_from:\n  case OMPC_use_device_ptr:\n  case OMPC_use_device_addr:\n  case OMPC_is_device_ptr:\n  case OMPC_unified_address:\n  case OMPC_unified_shared_memory:\n  case OMPC_reverse_offload:\n  case OMPC_dynamic_allocators:\n  case OMPC_atomic_default_mem_order:\n  case OMPC_device_type:\n  case OMPC_match:\n  case OMPC_nontemporal:\n  case OMPC_order:\n  case OMPC_destroy:\n  case OMPC_detach:\n  case OMPC_inclusive:\n  case OMPC_exclusive:\n  case OMPC_uses_allocators:\n  case OMPC_affinity:\n  default:\n    llvm_unreachable(\"Clause is not allowed.\");\n  }\n  return Res;\n}\n\nstatic bool checkScheduleModifiers(Sema &S, OpenMPScheduleClauseModifier M1,\n                                   OpenMPScheduleClauseModifier M2,\n                                   SourceLocation M1Loc, SourceLocation M2Loc) {\n  if (M1 == OMPC_SCHEDULE_MODIFIER_unknown && M1Loc.isValid()) {\n    SmallVector<unsigned, 2> Excluded;\n    if (M2 != OMPC_SCHEDULE_MODIFIER_unknown)\n      Excluded.push_back(M2);\n    if (M2 == OMPC_SCHEDULE_MODIFIER_nonmonotonic)\n      Excluded.push_back(OMPC_SCHEDULE_MODIFIER_monotonic);\n    if (M2 == OMPC_SCHEDULE_MODIFIER_monotonic)\n      Excluded.push_back(OMPC_SCHEDULE_MODIFIER_nonmonotonic);\n    S.Diag(M1Loc, diag::err_omp_unexpected_clause_value)\n        << getListOfPossibleValues(OMPC_schedule,\n                                   /*First=*/OMPC_SCHEDULE_MODIFIER_unknown + 1,\n                                   /*Last=*/OMPC_SCHEDULE_MODIFIER_last,\n                                   Excluded)\n        << getOpenMPClauseName(OMPC_schedule);\n    return true;\n  }\n  return false;\n}\n\nOMPClause *Sema::ActOnOpenMPScheduleClause(\n    OpenMPScheduleClauseModifier M1, OpenMPScheduleClauseModifier M2,\n    OpenMPScheduleClauseKind Kind, Expr *ChunkSize, SourceLocation StartLoc,\n    SourceLocation LParenLoc, SourceLocation M1Loc, SourceLocation M2Loc,\n    SourceLocation KindLoc, SourceLocation CommaLoc, SourceLocation EndLoc) {\n  if (checkScheduleModifiers(*this, M1, M2, M1Loc, M2Loc) ||\n      checkScheduleModifiers(*this, M2, M1, M2Loc, M1Loc))\n    return nullptr;\n  // OpenMP, 2.7.1, Loop Construct, Restrictions\n  // Either the monotonic modifier or the nonmonotonic modifier can be specified\n  // but not both.\n  if ((M1 == M2 && M1 != OMPC_SCHEDULE_MODIFIER_unknown) ||\n      (M1 == OMPC_SCHEDULE_MODIFIER_monotonic &&\n       M2 == OMPC_SCHEDULE_MODIFIER_nonmonotonic) ||\n      (M1 == OMPC_SCHEDULE_MODIFIER_nonmonotonic &&\n       M2 == OMPC_SCHEDULE_MODIFIER_monotonic)) {\n    Diag(M2Loc, diag::err_omp_unexpected_schedule_modifier)\n        << getOpenMPSimpleClauseTypeName(OMPC_schedule, M2)\n        << getOpenMPSimpleClauseTypeName(OMPC_schedule, M1);\n    return nullptr;\n  }\n  if (Kind == OMPC_SCHEDULE_unknown) {\n    std::string Values;\n    if (M1Loc.isInvalid() && M2Loc.isInvalid()) {\n      unsigned Exclude[] = {OMPC_SCHEDULE_unknown};\n      Values = getListOfPossibleValues(OMPC_schedule, /*First=*/0,\n                                       /*Last=*/OMPC_SCHEDULE_MODIFIER_last,\n                                       Exclude);\n    } else {\n      Values = getListOfPossibleValues(OMPC_schedule, /*First=*/0,\n                                       /*Last=*/OMPC_SCHEDULE_unknown);\n    }\n    Diag(KindLoc, diag::err_omp_unexpected_clause_value)\n        << Values << getOpenMPClauseName(OMPC_schedule);\n    return nullptr;\n  }\n  // OpenMP, 2.7.1, Loop Construct, Restrictions\n  // The nonmonotonic modifier can only be specified with schedule(dynamic) or\n  // schedule(guided).\n  // OpenMP 5.0 does not have this restriction.\n  if (LangOpts.OpenMP < 50 &&\n      (M1 == OMPC_SCHEDULE_MODIFIER_nonmonotonic ||\n       M2 == OMPC_SCHEDULE_MODIFIER_nonmonotonic) &&\n      Kind != OMPC_SCHEDULE_dynamic && Kind != OMPC_SCHEDULE_guided) {\n    Diag(M1 == OMPC_SCHEDULE_MODIFIER_nonmonotonic ? M1Loc : M2Loc,\n         diag::err_omp_schedule_nonmonotonic_static);\n    return nullptr;\n  }\n  Expr *ValExpr = ChunkSize;\n  Stmt *HelperValStmt = nullptr;\n  if (ChunkSize) {\n    if (!ChunkSize->isValueDependent() && !ChunkSize->isTypeDependent() &&\n        !ChunkSize->isInstantiationDependent() &&\n        !ChunkSize->containsUnexpandedParameterPack()) {\n      SourceLocation ChunkSizeLoc = ChunkSize->getBeginLoc();\n      ExprResult Val =\n          PerformOpenMPImplicitIntegerConversion(ChunkSizeLoc, ChunkSize);\n      if (Val.isInvalid())\n        return nullptr;\n\n      ValExpr = Val.get();\n\n      // OpenMP [2.7.1, Restrictions]\n      //  chunk_size must be a loop invariant integer expression with a positive\n      //  value.\n      if (Optional<llvm::APSInt> Result =\n              ValExpr->getIntegerConstantExpr(Context)) {\n        if (Result->isSigned() && !Result->isStrictlyPositive()) {\n          Diag(ChunkSizeLoc, diag::err_omp_negative_expression_in_clause)\n              << \"schedule\" << 1 << ChunkSize->getSourceRange();\n          return nullptr;\n        }\n      } else if (getOpenMPCaptureRegionForClause(\n                     DSAStack->getCurrentDirective(), OMPC_schedule,\n                     LangOpts.OpenMP) != OMPD_unknown &&\n                 !CurContext->isDependentContext()) {\n        ValExpr = MakeFullExpr(ValExpr).get();\n        llvm::MapVector<const Expr *, DeclRefExpr *> Captures;\n        ValExpr = tryBuildCapture(*this, ValExpr, Captures).get();\n        HelperValStmt = buildPreInits(Context, Captures);\n      }\n    }\n  }\n\n  return new (Context)\n      OMPScheduleClause(StartLoc, LParenLoc, KindLoc, CommaLoc, EndLoc, Kind,\n                        ValExpr, HelperValStmt, M1, M1Loc, M2, M2Loc);\n}\n\nOMPClause *Sema::ActOnOpenMPClause(OpenMPClauseKind Kind,\n                                   SourceLocation StartLoc,\n                                   SourceLocation EndLoc) {\n  OMPClause *Res = nullptr;\n  switch (Kind) {\n  case OMPC_ordered:\n    Res = ActOnOpenMPOrderedClause(StartLoc, EndLoc);\n    break;\n  case OMPC_nowait:\n    Res = ActOnOpenMPNowaitClause(StartLoc, EndLoc);\n    break;\n  case OMPC_untied:\n    Res = ActOnOpenMPUntiedClause(StartLoc, EndLoc);\n    break;\n  case OMPC_mergeable:\n    Res = ActOnOpenMPMergeableClause(StartLoc, EndLoc);\n    break;\n  case OMPC_read:\n    Res = ActOnOpenMPReadClause(StartLoc, EndLoc);\n    break;\n  case OMPC_write:\n    Res = ActOnOpenMPWriteClause(StartLoc, EndLoc);\n    break;\n  case OMPC_update:\n    Res = ActOnOpenMPUpdateClause(StartLoc, EndLoc);\n    break;\n  case OMPC_capture:\n    Res = ActOnOpenMPCaptureClause(StartLoc, EndLoc);\n    break;\n  case OMPC_seq_cst:\n    Res = ActOnOpenMPSeqCstClause(StartLoc, EndLoc);\n    break;\n  case OMPC_acq_rel:\n    Res = ActOnOpenMPAcqRelClause(StartLoc, EndLoc);\n    break;\n  case OMPC_acquire:\n    Res = ActOnOpenMPAcquireClause(StartLoc, EndLoc);\n    break;\n  case OMPC_release:\n    Res = ActOnOpenMPReleaseClause(StartLoc, EndLoc);\n    break;\n  case OMPC_relaxed:\n    Res = ActOnOpenMPRelaxedClause(StartLoc, EndLoc);\n    break;\n  case OMPC_threads:\n    Res = ActOnOpenMPThreadsClause(StartLoc, EndLoc);\n    break;\n  case OMPC_simd:\n    Res = ActOnOpenMPSIMDClause(StartLoc, EndLoc);\n    break;\n  case OMPC_nogroup:\n    Res = ActOnOpenMPNogroupClause(StartLoc, EndLoc);\n    break;\n  case OMPC_unified_address:\n    Res = ActOnOpenMPUnifiedAddressClause(StartLoc, EndLoc);\n    break;\n  case OMPC_unified_shared_memory:\n    Res = ActOnOpenMPUnifiedSharedMemoryClause(StartLoc, EndLoc);\n    break;\n  case OMPC_reverse_offload:\n    Res = ActOnOpenMPReverseOffloadClause(StartLoc, EndLoc);\n    break;\n  case OMPC_dynamic_allocators:\n    Res = ActOnOpenMPDynamicAllocatorsClause(StartLoc, EndLoc);\n    break;\n  case OMPC_destroy:\n    Res = ActOnOpenMPDestroyClause(StartLoc, EndLoc);\n    break;\n  case OMPC_if:\n  case OMPC_final:\n  case OMPC_num_threads:\n  case OMPC_safelen:\n  case OMPC_simdlen:\n  case OMPC_sizes:\n  case OMPC_allocator:\n  case OMPC_collapse:\n  case OMPC_schedule:\n  case OMPC_private:\n  case OMPC_firstprivate:\n  case OMPC_lastprivate:\n  case OMPC_shared:\n  case OMPC_reduction:\n  case OMPC_task_reduction:\n  case OMPC_in_reduction:\n  case OMPC_linear:\n  case OMPC_aligned:\n  case OMPC_copyin:\n  case OMPC_copyprivate:\n  case OMPC_default:\n  case OMPC_proc_bind:\n  case OMPC_threadprivate:\n  case OMPC_allocate:\n  case OMPC_flush:\n  case OMPC_depobj:\n  case OMPC_depend:\n  case OMPC_device:\n  case OMPC_map:\n  case OMPC_num_teams:\n  case OMPC_thread_limit:\n  case OMPC_priority:\n  case OMPC_grainsize:\n  case OMPC_num_tasks:\n  case OMPC_hint:\n  case OMPC_dist_schedule:\n  case OMPC_defaultmap:\n  case OMPC_unknown:\n  case OMPC_uniform:\n  case OMPC_to:\n  case OMPC_from:\n  case OMPC_use_device_ptr:\n  case OMPC_use_device_addr:\n  case OMPC_is_device_ptr:\n  case OMPC_atomic_default_mem_order:\n  case OMPC_device_type:\n  case OMPC_match:\n  case OMPC_nontemporal:\n  case OMPC_order:\n  case OMPC_detach:\n  case OMPC_inclusive:\n  case OMPC_exclusive:\n  case OMPC_uses_allocators:\n  case OMPC_affinity:\n  default:\n    llvm_unreachable(\"Clause is not allowed.\");\n  }\n  return Res;\n}\n\nOMPClause *Sema::ActOnOpenMPNowaitClause(SourceLocation StartLoc,\n                                         SourceLocation EndLoc) {\n  DSAStack->setNowaitRegion();\n  return new (Context) OMPNowaitClause(StartLoc, EndLoc);\n}\n\nOMPClause *Sema::ActOnOpenMPUntiedClause(SourceLocation StartLoc,\n                                         SourceLocation EndLoc) {\n  return new (Context) OMPUntiedClause(StartLoc, EndLoc);\n}\n\nOMPClause *Sema::ActOnOpenMPMergeableClause(SourceLocation StartLoc,\n                                            SourceLocation EndLoc) {\n  return new (Context) OMPMergeableClause(StartLoc, EndLoc);\n}\n\nOMPClause *Sema::ActOnOpenMPReadClause(SourceLocation StartLoc,\n                                       SourceLocation EndLoc) {\n  return new (Context) OMPReadClause(StartLoc, EndLoc);\n}\n\nOMPClause *Sema::ActOnOpenMPWriteClause(SourceLocation StartLoc,\n                                        SourceLocation EndLoc) {\n  return new (Context) OMPWriteClause(StartLoc, EndLoc);\n}\n\nOMPClause *Sema::ActOnOpenMPUpdateClause(SourceLocation StartLoc,\n                                         SourceLocation EndLoc) {\n  return OMPUpdateClause::Create(Context, StartLoc, EndLoc);\n}\n\nOMPClause *Sema::ActOnOpenMPCaptureClause(SourceLocation StartLoc,\n                                          SourceLocation EndLoc) {\n  return new (Context) OMPCaptureClause(StartLoc, EndLoc);\n}\n\nOMPClause *Sema::ActOnOpenMPSeqCstClause(SourceLocation StartLoc,\n                                         SourceLocation EndLoc) {\n  return new (Context) OMPSeqCstClause(StartLoc, EndLoc);\n}\n\nOMPClause *Sema::ActOnOpenMPAcqRelClause(SourceLocation StartLoc,\n                                         SourceLocation EndLoc) {\n  return new (Context) OMPAcqRelClause(StartLoc, EndLoc);\n}\n\nOMPClause *Sema::ActOnOpenMPAcquireClause(SourceLocation StartLoc,\n                                          SourceLocation EndLoc) {\n  return new (Context) OMPAcquireClause(StartLoc, EndLoc);\n}\n\nOMPClause *Sema::ActOnOpenMPReleaseClause(SourceLocation StartLoc,\n                                          SourceLocation EndLoc) {\n  return new (Context) OMPReleaseClause(StartLoc, EndLoc);\n}\n\nOMPClause *Sema::ActOnOpenMPRelaxedClause(SourceLocation StartLoc,\n                                          SourceLocation EndLoc) {\n  return new (Context) OMPRelaxedClause(StartLoc, EndLoc);\n}\n\nOMPClause *Sema::ActOnOpenMPThreadsClause(SourceLocation StartLoc,\n                                          SourceLocation EndLoc) {\n  return new (Context) OMPThreadsClause(StartLoc, EndLoc);\n}\n\nOMPClause *Sema::ActOnOpenMPSIMDClause(SourceLocation StartLoc,\n                                       SourceLocation EndLoc) {\n  return new (Context) OMPSIMDClause(StartLoc, EndLoc);\n}\n\nOMPClause *Sema::ActOnOpenMPNogroupClause(SourceLocation StartLoc,\n                                          SourceLocation EndLoc) {\n  return new (Context) OMPNogroupClause(StartLoc, EndLoc);\n}\n\nOMPClause *Sema::ActOnOpenMPUnifiedAddressClause(SourceLocation StartLoc,\n                                                 SourceLocation EndLoc) {\n  return new (Context) OMPUnifiedAddressClause(StartLoc, EndLoc);\n}\n\nOMPClause *Sema::ActOnOpenMPUnifiedSharedMemoryClause(SourceLocation StartLoc,\n                                                      SourceLocation EndLoc) {\n  return new (Context) OMPUnifiedSharedMemoryClause(StartLoc, EndLoc);\n}\n\nOMPClause *Sema::ActOnOpenMPReverseOffloadClause(SourceLocation StartLoc,\n                                                 SourceLocation EndLoc) {\n  return new (Context) OMPReverseOffloadClause(StartLoc, EndLoc);\n}\n\nOMPClause *Sema::ActOnOpenMPDynamicAllocatorsClause(SourceLocation StartLoc,\n                                                    SourceLocation EndLoc) {\n  return new (Context) OMPDynamicAllocatorsClause(StartLoc, EndLoc);\n}\n\nOMPClause *Sema::ActOnOpenMPDestroyClause(SourceLocation StartLoc,\n                                          SourceLocation EndLoc) {\n  return new (Context) OMPDestroyClause(StartLoc, EndLoc);\n}\n\nOMPClause *Sema::ActOnOpenMPVarListClause(\n    OpenMPClauseKind Kind, ArrayRef<Expr *> VarList, Expr *DepModOrTailExpr,\n    const OMPVarListLocTy &Locs, SourceLocation ColonLoc,\n    CXXScopeSpec &ReductionOrMapperIdScopeSpec,\n    DeclarationNameInfo &ReductionOrMapperId, int ExtraModifier,\n    ArrayRef<OpenMPMapModifierKind> MapTypeModifiers,\n    ArrayRef<SourceLocation> MapTypeModifiersLoc, bool IsMapTypeImplicit,\n    SourceLocation ExtraModifierLoc,\n    ArrayRef<OpenMPMotionModifierKind> MotionModifiers,\n    ArrayRef<SourceLocation> MotionModifiersLoc) {\n  SourceLocation StartLoc = Locs.StartLoc;\n  SourceLocation LParenLoc = Locs.LParenLoc;\n  SourceLocation EndLoc = Locs.EndLoc;\n  OMPClause *Res = nullptr;\n  switch (Kind) {\n  case OMPC_private:\n    Res = ActOnOpenMPPrivateClause(VarList, StartLoc, LParenLoc, EndLoc);\n    break;\n  case OMPC_firstprivate:\n    Res = ActOnOpenMPFirstprivateClause(VarList, StartLoc, LParenLoc, EndLoc);\n    break;\n  case OMPC_lastprivate:\n    assert(0 <= ExtraModifier && ExtraModifier <= OMPC_LASTPRIVATE_unknown &&\n           \"Unexpected lastprivate modifier.\");\n    Res = ActOnOpenMPLastprivateClause(\n        VarList, static_cast<OpenMPLastprivateModifier>(ExtraModifier),\n        ExtraModifierLoc, ColonLoc, StartLoc, LParenLoc, EndLoc);\n    break;\n  case OMPC_shared:\n    Res = ActOnOpenMPSharedClause(VarList, StartLoc, LParenLoc, EndLoc);\n    break;\n  case OMPC_reduction:\n    assert(0 <= ExtraModifier && ExtraModifier <= OMPC_REDUCTION_unknown &&\n           \"Unexpected lastprivate modifier.\");\n    Res = ActOnOpenMPReductionClause(\n        VarList, static_cast<OpenMPReductionClauseModifier>(ExtraModifier),\n        StartLoc, LParenLoc, ExtraModifierLoc, ColonLoc, EndLoc,\n        ReductionOrMapperIdScopeSpec, ReductionOrMapperId);\n    break;\n  case OMPC_task_reduction:\n    Res = ActOnOpenMPTaskReductionClause(VarList, StartLoc, LParenLoc, ColonLoc,\n                                         EndLoc, ReductionOrMapperIdScopeSpec,\n                                         ReductionOrMapperId);\n    break;\n  case OMPC_in_reduction:\n    Res = ActOnOpenMPInReductionClause(VarList, StartLoc, LParenLoc, ColonLoc,\n                                       EndLoc, ReductionOrMapperIdScopeSpec,\n                                       ReductionOrMapperId);\n    break;\n  case OMPC_linear:\n    assert(0 <= ExtraModifier && ExtraModifier <= OMPC_LINEAR_unknown &&\n           \"Unexpected linear modifier.\");\n    Res = ActOnOpenMPLinearClause(\n        VarList, DepModOrTailExpr, StartLoc, LParenLoc,\n        static_cast<OpenMPLinearClauseKind>(ExtraModifier), ExtraModifierLoc,\n        ColonLoc, EndLoc);\n    break;\n  case OMPC_aligned:\n    Res = ActOnOpenMPAlignedClause(VarList, DepModOrTailExpr, StartLoc,\n                                   LParenLoc, ColonLoc, EndLoc);\n    break;\n  case OMPC_copyin:\n    Res = ActOnOpenMPCopyinClause(VarList, StartLoc, LParenLoc, EndLoc);\n    break;\n  case OMPC_copyprivate:\n    Res = ActOnOpenMPCopyprivateClause(VarList, StartLoc, LParenLoc, EndLoc);\n    break;\n  case OMPC_flush:\n    Res = ActOnOpenMPFlushClause(VarList, StartLoc, LParenLoc, EndLoc);\n    break;\n  case OMPC_depend:\n    assert(0 <= ExtraModifier && ExtraModifier <= OMPC_DEPEND_unknown &&\n           \"Unexpected depend modifier.\");\n    Res = ActOnOpenMPDependClause(\n        DepModOrTailExpr, static_cast<OpenMPDependClauseKind>(ExtraModifier),\n        ExtraModifierLoc, ColonLoc, VarList, StartLoc, LParenLoc, EndLoc);\n    break;\n  case OMPC_map:\n    assert(0 <= ExtraModifier && ExtraModifier <= OMPC_MAP_unknown &&\n           \"Unexpected map modifier.\");\n    Res = ActOnOpenMPMapClause(\n        MapTypeModifiers, MapTypeModifiersLoc, ReductionOrMapperIdScopeSpec,\n        ReductionOrMapperId, static_cast<OpenMPMapClauseKind>(ExtraModifier),\n        IsMapTypeImplicit, ExtraModifierLoc, ColonLoc, VarList, Locs);\n    break;\n  case OMPC_to:\n    Res = ActOnOpenMPToClause(MotionModifiers, MotionModifiersLoc,\n                              ReductionOrMapperIdScopeSpec, ReductionOrMapperId,\n                              ColonLoc, VarList, Locs);\n    break;\n  case OMPC_from:\n    Res = ActOnOpenMPFromClause(MotionModifiers, MotionModifiersLoc,\n                                ReductionOrMapperIdScopeSpec,\n                                ReductionOrMapperId, ColonLoc, VarList, Locs);\n    break;\n  case OMPC_use_device_ptr:\n    Res = ActOnOpenMPUseDevicePtrClause(VarList, Locs);\n    break;\n  case OMPC_use_device_addr:\n    Res = ActOnOpenMPUseDeviceAddrClause(VarList, Locs);\n    break;\n  case OMPC_is_device_ptr:\n    Res = ActOnOpenMPIsDevicePtrClause(VarList, Locs);\n    break;\n  case OMPC_allocate:\n    Res = ActOnOpenMPAllocateClause(DepModOrTailExpr, VarList, StartLoc,\n                                    LParenLoc, ColonLoc, EndLoc);\n    break;\n  case OMPC_nontemporal:\n    Res = ActOnOpenMPNontemporalClause(VarList, StartLoc, LParenLoc, EndLoc);\n    break;\n  case OMPC_inclusive:\n    Res = ActOnOpenMPInclusiveClause(VarList, StartLoc, LParenLoc, EndLoc);\n    break;\n  case OMPC_exclusive:\n    Res = ActOnOpenMPExclusiveClause(VarList, StartLoc, LParenLoc, EndLoc);\n    break;\n  case OMPC_affinity:\n    Res = ActOnOpenMPAffinityClause(StartLoc, LParenLoc, ColonLoc, EndLoc,\n                                    DepModOrTailExpr, VarList);\n    break;\n  case OMPC_if:\n  case OMPC_depobj:\n  case OMPC_final:\n  case OMPC_num_threads:\n  case OMPC_safelen:\n  case OMPC_simdlen:\n  case OMPC_sizes:\n  case OMPC_allocator:\n  case OMPC_collapse:\n  case OMPC_default:\n  case OMPC_proc_bind:\n  case OMPC_schedule:\n  case OMPC_ordered:\n  case OMPC_nowait:\n  case OMPC_untied:\n  case OMPC_mergeable:\n  case OMPC_threadprivate:\n  case OMPC_read:\n  case OMPC_write:\n  case OMPC_update:\n  case OMPC_capture:\n  case OMPC_seq_cst:\n  case OMPC_acq_rel:\n  case OMPC_acquire:\n  case OMPC_release:\n  case OMPC_relaxed:\n  case OMPC_device:\n  case OMPC_threads:\n  case OMPC_simd:\n  case OMPC_num_teams:\n  case OMPC_thread_limit:\n  case OMPC_priority:\n  case OMPC_grainsize:\n  case OMPC_nogroup:\n  case OMPC_num_tasks:\n  case OMPC_hint:\n  case OMPC_dist_schedule:\n  case OMPC_defaultmap:\n  case OMPC_unknown:\n  case OMPC_uniform:\n  case OMPC_unified_address:\n  case OMPC_unified_shared_memory:\n  case OMPC_reverse_offload:\n  case OMPC_dynamic_allocators:\n  case OMPC_atomic_default_mem_order:\n  case OMPC_device_type:\n  case OMPC_match:\n  case OMPC_order:\n  case OMPC_destroy:\n  case OMPC_detach:\n  case OMPC_uses_allocators:\n  default:\n    llvm_unreachable(\"Clause is not allowed.\");\n  }\n  return Res;\n}\n\nExprResult Sema::getOpenMPCapturedExpr(VarDecl *Capture, ExprValueKind VK,\n                                       ExprObjectKind OK, SourceLocation Loc) {\n  ExprResult Res = BuildDeclRefExpr(\n      Capture, Capture->getType().getNonReferenceType(), VK_LValue, Loc);\n  if (!Res.isUsable())\n    return ExprError();\n  if (OK == OK_Ordinary && !getLangOpts().CPlusPlus) {\n    Res = CreateBuiltinUnaryOp(Loc, UO_Deref, Res.get());\n    if (!Res.isUsable())\n      return ExprError();\n  }\n  if (VK != VK_LValue && Res.get()->isGLValue()) {\n    Res = DefaultLvalueConversion(Res.get());\n    if (!Res.isUsable())\n      return ExprError();\n  }\n  return Res;\n}\n\nOMPClause *Sema::ActOnOpenMPPrivateClause(ArrayRef<Expr *> VarList,\n                                          SourceLocation StartLoc,\n                                          SourceLocation LParenLoc,\n                                          SourceLocation EndLoc) {\n  SmallVector<Expr *, 8> Vars;\n  SmallVector<Expr *, 8> PrivateCopies;\n  for (Expr *RefExpr : VarList) {\n    assert(RefExpr && \"NULL expr in OpenMP private clause.\");\n    SourceLocation ELoc;\n    SourceRange ERange;\n    Expr *SimpleRefExpr = RefExpr;\n    auto Res = getPrivateItem(*this, SimpleRefExpr, ELoc, ERange);\n    if (Res.second) {\n      // It will be analyzed later.\n      Vars.push_back(RefExpr);\n      PrivateCopies.push_back(nullptr);\n    }\n    ValueDecl *D = Res.first;\n    if (!D)\n      continue;\n\n    QualType Type = D->getType();\n    auto *VD = dyn_cast<VarDecl>(D);\n\n    // OpenMP [2.9.3.3, Restrictions, C/C++, p.3]\n    //  A variable that appears in a private clause must not have an incomplete\n    //  type or a reference type.\n    if (RequireCompleteType(ELoc, Type, diag::err_omp_private_incomplete_type))\n      continue;\n    Type = Type.getNonReferenceType();\n\n    // OpenMP 5.0 [2.19.3, List Item Privatization, Restrictions]\n    // A variable that is privatized must not have a const-qualified type\n    // unless it is of class type with a mutable member. This restriction does\n    // not apply to the firstprivate clause.\n    //\n    // OpenMP 3.1 [2.9.3.3, private clause, Restrictions]\n    // A variable that appears in a private clause must not have a\n    // const-qualified type unless it is of class type with a mutable member.\n    if (rejectConstNotMutableType(*this, D, Type, OMPC_private, ELoc))\n      continue;\n\n    // OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced\n    // in a Construct]\n    //  Variables with the predetermined data-sharing attributes may not be\n    //  listed in data-sharing attributes clauses, except for the cases\n    //  listed below. For these exceptions only, listing a predetermined\n    //  variable in a data-sharing attribute clause is allowed and overrides\n    //  the variable's predetermined data-sharing attributes.\n    DSAStackTy::DSAVarData DVar = DSAStack->getTopDSA(D, /*FromParent=*/false);\n    if (DVar.CKind != OMPC_unknown && DVar.CKind != OMPC_private) {\n      Diag(ELoc, diag::err_omp_wrong_dsa) << getOpenMPClauseName(DVar.CKind)\n                                          << getOpenMPClauseName(OMPC_private);\n      reportOriginalDsa(*this, DSAStack, D, DVar);\n      continue;\n    }\n\n    OpenMPDirectiveKind CurrDir = DSAStack->getCurrentDirective();\n    // Variably modified types are not supported for tasks.\n    if (!Type->isAnyPointerType() && Type->isVariablyModifiedType() &&\n        isOpenMPTaskingDirective(CurrDir)) {\n      Diag(ELoc, diag::err_omp_variably_modified_type_not_supported)\n          << getOpenMPClauseName(OMPC_private) << Type\n          << getOpenMPDirectiveName(CurrDir);\n      bool IsDecl =\n          !VD ||\n          VD->isThisDeclarationADefinition(Context) == VarDecl::DeclarationOnly;\n      Diag(D->getLocation(),\n           IsDecl ? diag::note_previous_decl : diag::note_defined_here)\n          << D;\n      continue;\n    }\n\n    // OpenMP 4.5 [2.15.5.1, Restrictions, p.3]\n    // A list item cannot appear in both a map clause and a data-sharing\n    // attribute clause on the same construct\n    //\n    // OpenMP 5.0 [2.19.7.1, Restrictions, p.7]\n    // A list item cannot appear in both a map clause and a data-sharing\n    // attribute clause on the same construct unless the construct is a\n    // combined construct.\n    if ((LangOpts.OpenMP <= 45 && isOpenMPTargetExecutionDirective(CurrDir)) ||\n        CurrDir == OMPD_target) {\n      OpenMPClauseKind ConflictKind;\n      if (DSAStack->checkMappableExprComponentListsForDecl(\n              VD, /*CurrentRegionOnly=*/true,\n              [&](OMPClauseMappableExprCommon::MappableExprComponentListRef,\n                  OpenMPClauseKind WhereFoundClauseKind) -> bool {\n                ConflictKind = WhereFoundClauseKind;\n                return true;\n              })) {\n        Diag(ELoc, diag::err_omp_variable_in_given_clause_and_dsa)\n            << getOpenMPClauseName(OMPC_private)\n            << getOpenMPClauseName(ConflictKind)\n            << getOpenMPDirectiveName(CurrDir);\n        reportOriginalDsa(*this, DSAStack, D, DVar);\n        continue;\n      }\n    }\n\n    // OpenMP [2.9.3.3, Restrictions, C/C++, p.1]\n    //  A variable of class type (or array thereof) that appears in a private\n    //  clause requires an accessible, unambiguous default constructor for the\n    //  class type.\n    // Generate helper private variable and initialize it with the default\n    // value. The address of the original variable is replaced by the address of\n    // the new private variable in CodeGen. This new variable is not added to\n    // IdResolver, so the code in the OpenMP region uses original variable for\n    // proper diagnostics.\n    Type = Type.getUnqualifiedType();\n    VarDecl *VDPrivate =\n        buildVarDecl(*this, ELoc, Type, D->getName(),\n                     D->hasAttrs() ? &D->getAttrs() : nullptr,\n                     VD ? cast<DeclRefExpr>(SimpleRefExpr) : nullptr);\n    ActOnUninitializedDecl(VDPrivate);\n    if (VDPrivate->isInvalidDecl())\n      continue;\n    DeclRefExpr *VDPrivateRefExpr = buildDeclRefExpr(\n        *this, VDPrivate, RefExpr->getType().getUnqualifiedType(), ELoc);\n\n    DeclRefExpr *Ref = nullptr;\n    if (!VD && !CurContext->isDependentContext())\n      Ref = buildCapture(*this, D, SimpleRefExpr, /*WithInit=*/false);\n    DSAStack->addDSA(D, RefExpr->IgnoreParens(), OMPC_private, Ref);\n    Vars.push_back((VD || CurContext->isDependentContext())\n                       ? RefExpr->IgnoreParens()\n                       : Ref);\n    PrivateCopies.push_back(VDPrivateRefExpr);\n  }\n\n  if (Vars.empty())\n    return nullptr;\n\n  return OMPPrivateClause::Create(Context, StartLoc, LParenLoc, EndLoc, Vars,\n                                  PrivateCopies);\n}\n\nnamespace {\nclass DiagsUninitializedSeveretyRAII {\nprivate:\n  DiagnosticsEngine &Diags;\n  SourceLocation SavedLoc;\n  bool IsIgnored = false;\n\npublic:\n  DiagsUninitializedSeveretyRAII(DiagnosticsEngine &Diags, SourceLocation Loc,\n                                 bool IsIgnored)\n      : Diags(Diags), SavedLoc(Loc), IsIgnored(IsIgnored) {\n    if (!IsIgnored) {\n      Diags.setSeverity(/*Diag*/ diag::warn_uninit_self_reference_in_init,\n                        /*Map*/ diag::Severity::Ignored, Loc);\n    }\n  }\n  ~DiagsUninitializedSeveretyRAII() {\n    if (!IsIgnored)\n      Diags.popMappings(SavedLoc);\n  }\n};\n}\n\nOMPClause *Sema::ActOnOpenMPFirstprivateClause(ArrayRef<Expr *> VarList,\n                                               SourceLocation StartLoc,\n                                               SourceLocation LParenLoc,\n                                               SourceLocation EndLoc) {\n  SmallVector<Expr *, 8> Vars;\n  SmallVector<Expr *, 8> PrivateCopies;\n  SmallVector<Expr *, 8> Inits;\n  SmallVector<Decl *, 4> ExprCaptures;\n  bool IsImplicitClause =\n      StartLoc.isInvalid() && LParenLoc.isInvalid() && EndLoc.isInvalid();\n  SourceLocation ImplicitClauseLoc = DSAStack->getConstructLoc();\n\n  for (Expr *RefExpr : VarList) {\n    assert(RefExpr && \"NULL expr in OpenMP firstprivate clause.\");\n    SourceLocation ELoc;\n    SourceRange ERange;\n    Expr *SimpleRefExpr = RefExpr;\n    auto Res = getPrivateItem(*this, SimpleRefExpr, ELoc, ERange);\n    if (Res.second) {\n      // It will be analyzed later.\n      Vars.push_back(RefExpr);\n      PrivateCopies.push_back(nullptr);\n      Inits.push_back(nullptr);\n    }\n    ValueDecl *D = Res.first;\n    if (!D)\n      continue;\n\n    ELoc = IsImplicitClause ? ImplicitClauseLoc : ELoc;\n    QualType Type = D->getType();\n    auto *VD = dyn_cast<VarDecl>(D);\n\n    // OpenMP [2.9.3.3, Restrictions, C/C++, p.3]\n    //  A variable that appears in a private clause must not have an incomplete\n    //  type or a reference type.\n    if (RequireCompleteType(ELoc, Type,\n                            diag::err_omp_firstprivate_incomplete_type))\n      continue;\n    Type = Type.getNonReferenceType();\n\n    // OpenMP [2.9.3.4, Restrictions, C/C++, p.1]\n    //  A variable of class type (or array thereof) that appears in a private\n    //  clause requires an accessible, unambiguous copy constructor for the\n    //  class type.\n    QualType ElemType = Context.getBaseElementType(Type).getNonReferenceType();\n\n    // If an implicit firstprivate variable found it was checked already.\n    DSAStackTy::DSAVarData TopDVar;\n    if (!IsImplicitClause) {\n      DSAStackTy::DSAVarData DVar =\n          DSAStack->getTopDSA(D, /*FromParent=*/false);\n      TopDVar = DVar;\n      OpenMPDirectiveKind CurrDir = DSAStack->getCurrentDirective();\n      bool IsConstant = ElemType.isConstant(Context);\n      // OpenMP [2.4.13, Data-sharing Attribute Clauses]\n      //  A list item that specifies a given variable may not appear in more\n      // than one clause on the same directive, except that a variable may be\n      //  specified in both firstprivate and lastprivate clauses.\n      // OpenMP 4.5 [2.10.8, Distribute Construct, p.3]\n      // A list item may appear in a firstprivate or lastprivate clause but not\n      // both.\n      if (DVar.CKind != OMPC_unknown && DVar.CKind != OMPC_firstprivate &&\n          (isOpenMPDistributeDirective(CurrDir) ||\n           DVar.CKind != OMPC_lastprivate) &&\n          DVar.RefExpr) {\n        Diag(ELoc, diag::err_omp_wrong_dsa)\n            << getOpenMPClauseName(DVar.CKind)\n            << getOpenMPClauseName(OMPC_firstprivate);\n        reportOriginalDsa(*this, DSAStack, D, DVar);\n        continue;\n      }\n\n      // OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced\n      // in a Construct]\n      //  Variables with the predetermined data-sharing attributes may not be\n      //  listed in data-sharing attributes clauses, except for the cases\n      //  listed below. For these exceptions only, listing a predetermined\n      //  variable in a data-sharing attribute clause is allowed and overrides\n      //  the variable's predetermined data-sharing attributes.\n      // OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced\n      // in a Construct, C/C++, p.2]\n      //  Variables with const-qualified type having no mutable member may be\n      //  listed in a firstprivate clause, even if they are static data members.\n      if (!(IsConstant || (VD && VD->isStaticDataMember())) && !DVar.RefExpr &&\n          DVar.CKind != OMPC_unknown && DVar.CKind != OMPC_shared) {\n        Diag(ELoc, diag::err_omp_wrong_dsa)\n            << getOpenMPClauseName(DVar.CKind)\n            << getOpenMPClauseName(OMPC_firstprivate);\n        reportOriginalDsa(*this, DSAStack, D, DVar);\n        continue;\n      }\n\n      // OpenMP [2.9.3.4, Restrictions, p.2]\n      //  A list item that is private within a parallel region must not appear\n      //  in a firstprivate clause on a worksharing construct if any of the\n      //  worksharing regions arising from the worksharing construct ever bind\n      //  to any of the parallel regions arising from the parallel construct.\n      // OpenMP 4.5 [2.15.3.4, Restrictions, p.3]\n      // A list item that is private within a teams region must not appear in a\n      // firstprivate clause on a distribute construct if any of the distribute\n      // regions arising from the distribute construct ever bind to any of the\n      // teams regions arising from the teams construct.\n      // OpenMP 4.5 [2.15.3.4, Restrictions, p.3]\n      // A list item that appears in a reduction clause of a teams construct\n      // must not appear in a firstprivate clause on a distribute construct if\n      // any of the distribute regions arising from the distribute construct\n      // ever bind to any of the teams regions arising from the teams construct.\n      if ((isOpenMPWorksharingDirective(CurrDir) ||\n           isOpenMPDistributeDirective(CurrDir)) &&\n          !isOpenMPParallelDirective(CurrDir) &&\n          !isOpenMPTeamsDirective(CurrDir)) {\n        DVar = DSAStack->getImplicitDSA(D, true);\n        if (DVar.CKind != OMPC_shared &&\n            (isOpenMPParallelDirective(DVar.DKind) ||\n             isOpenMPTeamsDirective(DVar.DKind) ||\n             DVar.DKind == OMPD_unknown)) {\n          Diag(ELoc, diag::err_omp_required_access)\n              << getOpenMPClauseName(OMPC_firstprivate)\n              << getOpenMPClauseName(OMPC_shared);\n          reportOriginalDsa(*this, DSAStack, D, DVar);\n          continue;\n        }\n      }\n      // OpenMP [2.9.3.4, Restrictions, p.3]\n      //  A list item that appears in a reduction clause of a parallel construct\n      //  must not appear in a firstprivate clause on a worksharing or task\n      //  construct if any of the worksharing or task regions arising from the\n      //  worksharing or task construct ever bind to any of the parallel regions\n      //  arising from the parallel construct.\n      // OpenMP [2.9.3.4, Restrictions, p.4]\n      //  A list item that appears in a reduction clause in worksharing\n      //  construct must not appear in a firstprivate clause in a task construct\n      //  encountered during execution of any of the worksharing regions arising\n      //  from the worksharing construct.\n      if (isOpenMPTaskingDirective(CurrDir)) {\n        DVar = DSAStack->hasInnermostDSA(\n            D,\n            [](OpenMPClauseKind C, bool AppliedToPointee) {\n              return C == OMPC_reduction && !AppliedToPointee;\n            },\n            [](OpenMPDirectiveKind K) {\n              return isOpenMPParallelDirective(K) ||\n                     isOpenMPWorksharingDirective(K) ||\n                     isOpenMPTeamsDirective(K);\n            },\n            /*FromParent=*/true);\n        if (DVar.CKind == OMPC_reduction &&\n            (isOpenMPParallelDirective(DVar.DKind) ||\n             isOpenMPWorksharingDirective(DVar.DKind) ||\n             isOpenMPTeamsDirective(DVar.DKind))) {\n          Diag(ELoc, diag::err_omp_parallel_reduction_in_task_firstprivate)\n              << getOpenMPDirectiveName(DVar.DKind);\n          reportOriginalDsa(*this, DSAStack, D, DVar);\n          continue;\n        }\n      }\n\n      // OpenMP 4.5 [2.15.5.1, Restrictions, p.3]\n      // A list item cannot appear in both a map clause and a data-sharing\n      // attribute clause on the same construct\n      //\n      // OpenMP 5.0 [2.19.7.1, Restrictions, p.7]\n      // A list item cannot appear in both a map clause and a data-sharing\n      // attribute clause on the same construct unless the construct is a\n      // combined construct.\n      if ((LangOpts.OpenMP <= 45 &&\n           isOpenMPTargetExecutionDirective(CurrDir)) ||\n          CurrDir == OMPD_target) {\n        OpenMPClauseKind ConflictKind;\n        if (DSAStack->checkMappableExprComponentListsForDecl(\n                VD, /*CurrentRegionOnly=*/true,\n                [&ConflictKind](\n                    OMPClauseMappableExprCommon::MappableExprComponentListRef,\n                    OpenMPClauseKind WhereFoundClauseKind) {\n                  ConflictKind = WhereFoundClauseKind;\n                  return true;\n                })) {\n          Diag(ELoc, diag::err_omp_variable_in_given_clause_and_dsa)\n              << getOpenMPClauseName(OMPC_firstprivate)\n              << getOpenMPClauseName(ConflictKind)\n              << getOpenMPDirectiveName(DSAStack->getCurrentDirective());\n          reportOriginalDsa(*this, DSAStack, D, DVar);\n          continue;\n        }\n      }\n    }\n\n    // Variably modified types are not supported for tasks.\n    if (!Type->isAnyPointerType() && Type->isVariablyModifiedType() &&\n        isOpenMPTaskingDirective(DSAStack->getCurrentDirective())) {\n      Diag(ELoc, diag::err_omp_variably_modified_type_not_supported)\n          << getOpenMPClauseName(OMPC_firstprivate) << Type\n          << getOpenMPDirectiveName(DSAStack->getCurrentDirective());\n      bool IsDecl =\n          !VD ||\n          VD->isThisDeclarationADefinition(Context) == VarDecl::DeclarationOnly;\n      Diag(D->getLocation(),\n           IsDecl ? diag::note_previous_decl : diag::note_defined_here)\n          << D;\n      continue;\n    }\n\n    Type = Type.getUnqualifiedType();\n    VarDecl *VDPrivate =\n        buildVarDecl(*this, ELoc, Type, D->getName(),\n                     D->hasAttrs() ? &D->getAttrs() : nullptr,\n                     VD ? cast<DeclRefExpr>(SimpleRefExpr) : nullptr);\n    // Generate helper private variable and initialize it with the value of the\n    // original variable. The address of the original variable is replaced by\n    // the address of the new private variable in the CodeGen. This new variable\n    // is not added to IdResolver, so the code in the OpenMP region uses\n    // original variable for proper diagnostics and variable capturing.\n    Expr *VDInitRefExpr = nullptr;\n    // For arrays generate initializer for single element and replace it by the\n    // original array element in CodeGen.\n    if (Type->isArrayType()) {\n      VarDecl *VDInit =\n          buildVarDecl(*this, RefExpr->getExprLoc(), ElemType, D->getName());\n      VDInitRefExpr = buildDeclRefExpr(*this, VDInit, ElemType, ELoc);\n      Expr *Init = DefaultLvalueConversion(VDInitRefExpr).get();\n      ElemType = ElemType.getUnqualifiedType();\n      VarDecl *VDInitTemp = buildVarDecl(*this, RefExpr->getExprLoc(), ElemType,\n                                         \".firstprivate.temp\");\n      InitializedEntity Entity =\n          InitializedEntity::InitializeVariable(VDInitTemp);\n      InitializationKind Kind = InitializationKind::CreateCopy(ELoc, ELoc);\n\n      InitializationSequence InitSeq(*this, Entity, Kind, Init);\n      ExprResult Result = InitSeq.Perform(*this, Entity, Kind, Init);\n      if (Result.isInvalid())\n        VDPrivate->setInvalidDecl();\n      else\n        VDPrivate->setInit(Result.getAs<Expr>());\n      // Remove temp variable declaration.\n      Context.Deallocate(VDInitTemp);\n    } else {\n      VarDecl *VDInit = buildVarDecl(*this, RefExpr->getExprLoc(), Type,\n                                     \".firstprivate.temp\");\n      VDInitRefExpr = buildDeclRefExpr(*this, VDInit, RefExpr->getType(),\n                                       RefExpr->getExprLoc());\n      AddInitializerToDecl(VDPrivate,\n                           DefaultLvalueConversion(VDInitRefExpr).get(),\n                           /*DirectInit=*/false);\n    }\n    if (VDPrivate->isInvalidDecl()) {\n      if (IsImplicitClause) {\n        Diag(RefExpr->getExprLoc(),\n             diag::note_omp_task_predetermined_firstprivate_here);\n      }\n      continue;\n    }\n    CurContext->addDecl(VDPrivate);\n    DeclRefExpr *VDPrivateRefExpr = buildDeclRefExpr(\n        *this, VDPrivate, RefExpr->getType().getUnqualifiedType(),\n        RefExpr->getExprLoc());\n    DeclRefExpr *Ref = nullptr;\n    if (!VD && !CurContext->isDependentContext()) {\n      if (TopDVar.CKind == OMPC_lastprivate) {\n        Ref = TopDVar.PrivateCopy;\n      } else {\n        Ref = buildCapture(*this, D, SimpleRefExpr, /*WithInit=*/true);\n        if (!isOpenMPCapturedDecl(D))\n          ExprCaptures.push_back(Ref->getDecl());\n      }\n    }\n    if (!IsImplicitClause)\n      DSAStack->addDSA(D, RefExpr->IgnoreParens(), OMPC_firstprivate, Ref);\n    Vars.push_back((VD || CurContext->isDependentContext())\n                       ? RefExpr->IgnoreParens()\n                       : Ref);\n    PrivateCopies.push_back(VDPrivateRefExpr);\n    Inits.push_back(VDInitRefExpr);\n  }\n\n  if (Vars.empty())\n    return nullptr;\n\n  return OMPFirstprivateClause::Create(Context, StartLoc, LParenLoc, EndLoc,\n                                       Vars, PrivateCopies, Inits,\n                                       buildPreInits(Context, ExprCaptures));\n}\n\nOMPClause *Sema::ActOnOpenMPLastprivateClause(\n    ArrayRef<Expr *> VarList, OpenMPLastprivateModifier LPKind,\n    SourceLocation LPKindLoc, SourceLocation ColonLoc, SourceLocation StartLoc,\n    SourceLocation LParenLoc, SourceLocation EndLoc) {\n  if (LPKind == OMPC_LASTPRIVATE_unknown && LPKindLoc.isValid()) {\n    assert(ColonLoc.isValid() && \"Colon location must be valid.\");\n    Diag(LPKindLoc, diag::err_omp_unexpected_clause_value)\n        << getListOfPossibleValues(OMPC_lastprivate, /*First=*/0,\n                                   /*Last=*/OMPC_LASTPRIVATE_unknown)\n        << getOpenMPClauseName(OMPC_lastprivate);\n    return nullptr;\n  }\n\n  SmallVector<Expr *, 8> Vars;\n  SmallVector<Expr *, 8> SrcExprs;\n  SmallVector<Expr *, 8> DstExprs;\n  SmallVector<Expr *, 8> AssignmentOps;\n  SmallVector<Decl *, 4> ExprCaptures;\n  SmallVector<Expr *, 4> ExprPostUpdates;\n  for (Expr *RefExpr : VarList) {\n    assert(RefExpr && \"NULL expr in OpenMP lastprivate clause.\");\n    SourceLocation ELoc;\n    SourceRange ERange;\n    Expr *SimpleRefExpr = RefExpr;\n    auto Res = getPrivateItem(*this, SimpleRefExpr, ELoc, ERange);\n    if (Res.second) {\n      // It will be analyzed later.\n      Vars.push_back(RefExpr);\n      SrcExprs.push_back(nullptr);\n      DstExprs.push_back(nullptr);\n      AssignmentOps.push_back(nullptr);\n    }\n    ValueDecl *D = Res.first;\n    if (!D)\n      continue;\n\n    QualType Type = D->getType();\n    auto *VD = dyn_cast<VarDecl>(D);\n\n    // OpenMP [2.14.3.5, Restrictions, C/C++, p.2]\n    //  A variable that appears in a lastprivate clause must not have an\n    //  incomplete type or a reference type.\n    if (RequireCompleteType(ELoc, Type,\n                            diag::err_omp_lastprivate_incomplete_type))\n      continue;\n    Type = Type.getNonReferenceType();\n\n    // OpenMP 5.0 [2.19.3, List Item Privatization, Restrictions]\n    // A variable that is privatized must not have a const-qualified type\n    // unless it is of class type with a mutable member. This restriction does\n    // not apply to the firstprivate clause.\n    //\n    // OpenMP 3.1 [2.9.3.5, lastprivate clause, Restrictions]\n    // A variable that appears in a lastprivate clause must not have a\n    // const-qualified type unless it is of class type with a mutable member.\n    if (rejectConstNotMutableType(*this, D, Type, OMPC_lastprivate, ELoc))\n      continue;\n\n    // OpenMP 5.0 [2.19.4.5 lastprivate Clause, Restrictions]\n    // A list item that appears in a lastprivate clause with the conditional\n    // modifier must be a scalar variable.\n    if (LPKind == OMPC_LASTPRIVATE_conditional && !Type->isScalarType()) {\n      Diag(ELoc, diag::err_omp_lastprivate_conditional_non_scalar);\n      bool IsDecl = !VD || VD->isThisDeclarationADefinition(Context) ==\n                               VarDecl::DeclarationOnly;\n      Diag(D->getLocation(),\n           IsDecl ? diag::note_previous_decl : diag::note_defined_here)\n          << D;\n      continue;\n    }\n\n    OpenMPDirectiveKind CurrDir = DSAStack->getCurrentDirective();\n    // OpenMP [2.14.1.1, Data-sharing Attribute Rules for Variables Referenced\n    // in a Construct]\n    //  Variables with the predetermined data-sharing attributes may not be\n    //  listed in data-sharing attributes clauses, except for the cases\n    //  listed below.\n    // OpenMP 4.5 [2.10.8, Distribute Construct, p.3]\n    // A list item may appear in a firstprivate or lastprivate clause but not\n    // both.\n    DSAStackTy::DSAVarData DVar = DSAStack->getTopDSA(D, /*FromParent=*/false);\n    if (DVar.CKind != OMPC_unknown && DVar.CKind != OMPC_lastprivate &&\n        (isOpenMPDistributeDirective(CurrDir) ||\n         DVar.CKind != OMPC_firstprivate) &&\n        (DVar.CKind != OMPC_private || DVar.RefExpr != nullptr)) {\n      Diag(ELoc, diag::err_omp_wrong_dsa)\n          << getOpenMPClauseName(DVar.CKind)\n          << getOpenMPClauseName(OMPC_lastprivate);\n      reportOriginalDsa(*this, DSAStack, D, DVar);\n      continue;\n    }\n\n    // OpenMP [2.14.3.5, Restrictions, p.2]\n    // A list item that is private within a parallel region, or that appears in\n    // the reduction clause of a parallel construct, must not appear in a\n    // lastprivate clause on a worksharing construct if any of the corresponding\n    // worksharing regions ever binds to any of the corresponding parallel\n    // regions.\n    DSAStackTy::DSAVarData TopDVar = DVar;\n    if (isOpenMPWorksharingDirective(CurrDir) &&\n        !isOpenMPParallelDirective(CurrDir) &&\n        !isOpenMPTeamsDirective(CurrDir)) {\n      DVar = DSAStack->getImplicitDSA(D, true);\n      if (DVar.CKind != OMPC_shared) {\n        Diag(ELoc, diag::err_omp_required_access)\n            << getOpenMPClauseName(OMPC_lastprivate)\n            << getOpenMPClauseName(OMPC_shared);\n        reportOriginalDsa(*this, DSAStack, D, DVar);\n        continue;\n      }\n    }\n\n    // OpenMP [2.14.3.5, Restrictions, C++, p.1,2]\n    //  A variable of class type (or array thereof) that appears in a\n    //  lastprivate clause requires an accessible, unambiguous default\n    //  constructor for the class type, unless the list item is also specified\n    //  in a firstprivate clause.\n    //  A variable of class type (or array thereof) that appears in a\n    //  lastprivate clause requires an accessible, unambiguous copy assignment\n    //  operator for the class type.\n    Type = Context.getBaseElementType(Type).getNonReferenceType();\n    VarDecl *SrcVD = buildVarDecl(*this, ERange.getBegin(),\n                                  Type.getUnqualifiedType(), \".lastprivate.src\",\n                                  D->hasAttrs() ? &D->getAttrs() : nullptr);\n    DeclRefExpr *PseudoSrcExpr =\n        buildDeclRefExpr(*this, SrcVD, Type.getUnqualifiedType(), ELoc);\n    VarDecl *DstVD =\n        buildVarDecl(*this, ERange.getBegin(), Type, \".lastprivate.dst\",\n                     D->hasAttrs() ? &D->getAttrs() : nullptr);\n    DeclRefExpr *PseudoDstExpr = buildDeclRefExpr(*this, DstVD, Type, ELoc);\n    // For arrays generate assignment operation for single element and replace\n    // it by the original array element in CodeGen.\n    ExprResult AssignmentOp = BuildBinOp(/*S=*/nullptr, ELoc, BO_Assign,\n                                         PseudoDstExpr, PseudoSrcExpr);\n    if (AssignmentOp.isInvalid())\n      continue;\n    AssignmentOp =\n        ActOnFinishFullExpr(AssignmentOp.get(), ELoc, /*DiscardedValue*/ false);\n    if (AssignmentOp.isInvalid())\n      continue;\n\n    DeclRefExpr *Ref = nullptr;\n    if (!VD && !CurContext->isDependentContext()) {\n      if (TopDVar.CKind == OMPC_firstprivate) {\n        Ref = TopDVar.PrivateCopy;\n      } else {\n        Ref = buildCapture(*this, D, SimpleRefExpr, /*WithInit=*/false);\n        if (!isOpenMPCapturedDecl(D))\n          ExprCaptures.push_back(Ref->getDecl());\n      }\n      if ((TopDVar.CKind == OMPC_firstprivate && !TopDVar.PrivateCopy) ||\n          (!isOpenMPCapturedDecl(D) &&\n           Ref->getDecl()->hasAttr<OMPCaptureNoInitAttr>())) {\n        ExprResult RefRes = DefaultLvalueConversion(Ref);\n        if (!RefRes.isUsable())\n          continue;\n        ExprResult PostUpdateRes =\n            BuildBinOp(DSAStack->getCurScope(), ELoc, BO_Assign, SimpleRefExpr,\n                       RefRes.get());\n        if (!PostUpdateRes.isUsable())\n          continue;\n        ExprPostUpdates.push_back(\n            IgnoredValueConversions(PostUpdateRes.get()).get());\n      }\n    }\n    DSAStack->addDSA(D, RefExpr->IgnoreParens(), OMPC_lastprivate, Ref);\n    Vars.push_back((VD || CurContext->isDependentContext())\n                       ? RefExpr->IgnoreParens()\n                       : Ref);\n    SrcExprs.push_back(PseudoSrcExpr);\n    DstExprs.push_back(PseudoDstExpr);\n    AssignmentOps.push_back(AssignmentOp.get());\n  }\n\n  if (Vars.empty())\n    return nullptr;\n\n  return OMPLastprivateClause::Create(Context, StartLoc, LParenLoc, EndLoc,\n                                      Vars, SrcExprs, DstExprs, AssignmentOps,\n                                      LPKind, LPKindLoc, ColonLoc,\n                                      buildPreInits(Context, ExprCaptures),\n                                      buildPostUpdate(*this, ExprPostUpdates));\n}\n\nOMPClause *Sema::ActOnOpenMPSharedClause(ArrayRef<Expr *> VarList,\n                                         SourceLocation StartLoc,\n                                         SourceLocation LParenLoc,\n                                         SourceLocation EndLoc) {\n  SmallVector<Expr *, 8> Vars;\n  for (Expr *RefExpr : VarList) {\n    assert(RefExpr && \"NULL expr in OpenMP lastprivate clause.\");\n    SourceLocation ELoc;\n    SourceRange ERange;\n    Expr *SimpleRefExpr = RefExpr;\n    auto Res = getPrivateItem(*this, SimpleRefExpr, ELoc, ERange);\n    if (Res.second) {\n      // It will be analyzed later.\n      Vars.push_back(RefExpr);\n    }\n    ValueDecl *D = Res.first;\n    if (!D)\n      continue;\n\n    auto *VD = dyn_cast<VarDecl>(D);\n    // OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced\n    // in a Construct]\n    //  Variables with the predetermined data-sharing attributes may not be\n    //  listed in data-sharing attributes clauses, except for the cases\n    //  listed below. For these exceptions only, listing a predetermined\n    //  variable in a data-sharing attribute clause is allowed and overrides\n    //  the variable's predetermined data-sharing attributes.\n    DSAStackTy::DSAVarData DVar = DSAStack->getTopDSA(D, /*FromParent=*/false);\n    if (DVar.CKind != OMPC_unknown && DVar.CKind != OMPC_shared &&\n        DVar.RefExpr) {\n      Diag(ELoc, diag::err_omp_wrong_dsa) << getOpenMPClauseName(DVar.CKind)\n                                          << getOpenMPClauseName(OMPC_shared);\n      reportOriginalDsa(*this, DSAStack, D, DVar);\n      continue;\n    }\n\n    DeclRefExpr *Ref = nullptr;\n    if (!VD && isOpenMPCapturedDecl(D) && !CurContext->isDependentContext())\n      Ref = buildCapture(*this, D, SimpleRefExpr, /*WithInit=*/true);\n    DSAStack->addDSA(D, RefExpr->IgnoreParens(), OMPC_shared, Ref);\n    Vars.push_back((VD || !Ref || CurContext->isDependentContext())\n                       ? RefExpr->IgnoreParens()\n                       : Ref);\n  }\n\n  if (Vars.empty())\n    return nullptr;\n\n  return OMPSharedClause::Create(Context, StartLoc, LParenLoc, EndLoc, Vars);\n}\n\nnamespace {\nclass DSARefChecker : public StmtVisitor<DSARefChecker, bool> {\n  DSAStackTy *Stack;\n\npublic:\n  bool VisitDeclRefExpr(DeclRefExpr *E) {\n    if (auto *VD = dyn_cast<VarDecl>(E->getDecl())) {\n      DSAStackTy::DSAVarData DVar = Stack->getTopDSA(VD, /*FromParent=*/false);\n      if (DVar.CKind == OMPC_shared && !DVar.RefExpr)\n        return false;\n      if (DVar.CKind != OMPC_unknown)\n        return true;\n      DSAStackTy::DSAVarData DVarPrivate = Stack->hasDSA(\n          VD,\n          [](OpenMPClauseKind C, bool AppliedToPointee) {\n            return isOpenMPPrivate(C) && !AppliedToPointee;\n          },\n          [](OpenMPDirectiveKind) { return true; },\n          /*FromParent=*/true);\n      return DVarPrivate.CKind != OMPC_unknown;\n    }\n    return false;\n  }\n  bool VisitStmt(Stmt *S) {\n    for (Stmt *Child : S->children()) {\n      if (Child && Visit(Child))\n        return true;\n    }\n    return false;\n  }\n  explicit DSARefChecker(DSAStackTy *S) : Stack(S) {}\n};\n} // namespace\n\nnamespace {\n// Transform MemberExpression for specified FieldDecl of current class to\n// DeclRefExpr to specified OMPCapturedExprDecl.\nclass TransformExprToCaptures : public TreeTransform<TransformExprToCaptures> {\n  typedef TreeTransform<TransformExprToCaptures> BaseTransform;\n  ValueDecl *Field = nullptr;\n  DeclRefExpr *CapturedExpr = nullptr;\n\npublic:\n  TransformExprToCaptures(Sema &SemaRef, ValueDecl *FieldDecl)\n      : BaseTransform(SemaRef), Field(FieldDecl), CapturedExpr(nullptr) {}\n\n  ExprResult TransformMemberExpr(MemberExpr *E) {\n    if (isa<CXXThisExpr>(E->getBase()->IgnoreParenImpCasts()) &&\n        E->getMemberDecl() == Field) {\n      CapturedExpr = buildCapture(SemaRef, Field, E, /*WithInit=*/false);\n      return CapturedExpr;\n    }\n    return BaseTransform::TransformMemberExpr(E);\n  }\n  DeclRefExpr *getCapturedExpr() { return CapturedExpr; }\n};\n} // namespace\n\ntemplate <typename T, typename U>\nstatic T filterLookupForUDReductionAndMapper(\n    SmallVectorImpl<U> &Lookups, const llvm::function_ref<T(ValueDecl *)> Gen) {\n  for (U &Set : Lookups) {\n    for (auto *D : Set) {\n      if (T Res = Gen(cast<ValueDecl>(D)))\n        return Res;\n    }\n  }\n  return T();\n}\n\nstatic NamedDecl *findAcceptableDecl(Sema &SemaRef, NamedDecl *D) {\n  assert(!LookupResult::isVisible(SemaRef, D) && \"not in slow case\");\n\n  for (auto RD : D->redecls()) {\n    // Don't bother with extra checks if we already know this one isn't visible.\n    if (RD == D)\n      continue;\n\n    auto ND = cast<NamedDecl>(RD);\n    if (LookupResult::isVisible(SemaRef, ND))\n      return ND;\n  }\n\n  return nullptr;\n}\n\nstatic void\nargumentDependentLookup(Sema &SemaRef, const DeclarationNameInfo &Id,\n                        SourceLocation Loc, QualType Ty,\n                        SmallVectorImpl<UnresolvedSet<8>> &Lookups) {\n  // Find all of the associated namespaces and classes based on the\n  // arguments we have.\n  Sema::AssociatedNamespaceSet AssociatedNamespaces;\n  Sema::AssociatedClassSet AssociatedClasses;\n  OpaqueValueExpr OVE(Loc, Ty, VK_LValue);\n  SemaRef.FindAssociatedClassesAndNamespaces(Loc, &OVE, AssociatedNamespaces,\n                                             AssociatedClasses);\n\n  // C++ [basic.lookup.argdep]p3:\n  //   Let X be the lookup set produced by unqualified lookup (3.4.1)\n  //   and let Y be the lookup set produced by argument dependent\n  //   lookup (defined as follows). If X contains [...] then Y is\n  //   empty. Otherwise Y is the set of declarations found in the\n  //   namespaces associated with the argument types as described\n  //   below. The set of declarations found by the lookup of the name\n  //   is the union of X and Y.\n  //\n  // Here, we compute Y and add its members to the overloaded\n  // candidate set.\n  for (auto *NS : AssociatedNamespaces) {\n    //   When considering an associated namespace, the lookup is the\n    //   same as the lookup performed when the associated namespace is\n    //   used as a qualifier (3.4.3.2) except that:\n    //\n    //     -- Any using-directives in the associated namespace are\n    //        ignored.\n    //\n    //     -- Any namespace-scope friend functions declared in\n    //        associated classes are visible within their respective\n    //        namespaces even if they are not visible during an ordinary\n    //        lookup (11.4).\n    DeclContext::lookup_result R = NS->lookup(Id.getName());\n    for (auto *D : R) {\n      auto *Underlying = D;\n      if (auto *USD = dyn_cast<UsingShadowDecl>(D))\n        Underlying = USD->getTargetDecl();\n\n      if (!isa<OMPDeclareReductionDecl>(Underlying) &&\n          !isa<OMPDeclareMapperDecl>(Underlying))\n        continue;\n\n      if (!SemaRef.isVisible(D)) {\n        D = findAcceptableDecl(SemaRef, D);\n        if (!D)\n          continue;\n        if (auto *USD = dyn_cast<UsingShadowDecl>(D))\n          Underlying = USD->getTargetDecl();\n      }\n      Lookups.emplace_back();\n      Lookups.back().addDecl(Underlying);\n    }\n  }\n}\n\nstatic ExprResult\nbuildDeclareReductionRef(Sema &SemaRef, SourceLocation Loc, SourceRange Range,\n                         Scope *S, CXXScopeSpec &ReductionIdScopeSpec,\n                         const DeclarationNameInfo &ReductionId, QualType Ty,\n                         CXXCastPath &BasePath, Expr *UnresolvedReduction) {\n  if (ReductionIdScopeSpec.isInvalid())\n    return ExprError();\n  SmallVector<UnresolvedSet<8>, 4> Lookups;\n  if (S) {\n    LookupResult Lookup(SemaRef, ReductionId, Sema::LookupOMPReductionName);\n    Lookup.suppressDiagnostics();\n    while (S && SemaRef.LookupParsedName(Lookup, S, &ReductionIdScopeSpec)) {\n      NamedDecl *D = Lookup.getRepresentativeDecl();\n      do {\n        S = S->getParent();\n      } while (S && !S->isDeclScope(D));\n      if (S)\n        S = S->getParent();\n      Lookups.emplace_back();\n      Lookups.back().append(Lookup.begin(), Lookup.end());\n      Lookup.clear();\n    }\n  } else if (auto *ULE =\n                 cast_or_null<UnresolvedLookupExpr>(UnresolvedReduction)) {\n    Lookups.push_back(UnresolvedSet<8>());\n    Decl *PrevD = nullptr;\n    for (NamedDecl *D : ULE->decls()) {\n      if (D == PrevD)\n        Lookups.push_back(UnresolvedSet<8>());\n      else if (auto *DRD = dyn_cast<OMPDeclareReductionDecl>(D))\n        Lookups.back().addDecl(DRD);\n      PrevD = D;\n    }\n  }\n  if (SemaRef.CurContext->isDependentContext() || Ty->isDependentType() ||\n      Ty->isInstantiationDependentType() ||\n      Ty->containsUnexpandedParameterPack() ||\n      filterLookupForUDReductionAndMapper<bool>(Lookups, [](ValueDecl *D) {\n        return !D->isInvalidDecl() &&\n               (D->getType()->isDependentType() ||\n                D->getType()->isInstantiationDependentType() ||\n                D->getType()->containsUnexpandedParameterPack());\n      })) {\n    UnresolvedSet<8> ResSet;\n    for (const UnresolvedSet<8> &Set : Lookups) {\n      if (Set.empty())\n        continue;\n      ResSet.append(Set.begin(), Set.end());\n      // The last item marks the end of all declarations at the specified scope.\n      ResSet.addDecl(Set[Set.size() - 1]);\n    }\n    return UnresolvedLookupExpr::Create(\n        SemaRef.Context, /*NamingClass=*/nullptr,\n        ReductionIdScopeSpec.getWithLocInContext(SemaRef.Context), ReductionId,\n        /*ADL=*/true, /*Overloaded=*/true, ResSet.begin(), ResSet.end());\n  }\n  // Lookup inside the classes.\n  // C++ [over.match.oper]p3:\n  //   For a unary operator @ with an operand of a type whose\n  //   cv-unqualified version is T1, and for a binary operator @ with\n  //   a left operand of a type whose cv-unqualified version is T1 and\n  //   a right operand of a type whose cv-unqualified version is T2,\n  //   three sets of candidate functions, designated member\n  //   candidates, non-member candidates and built-in candidates, are\n  //   constructed as follows:\n  //     -- If T1 is a complete class type or a class currently being\n  //        defined, the set of member candidates is the result of the\n  //        qualified lookup of T1::operator@ (13.3.1.1.1); otherwise,\n  //        the set of member candidates is empty.\n  LookupResult Lookup(SemaRef, ReductionId, Sema::LookupOMPReductionName);\n  Lookup.suppressDiagnostics();\n  if (const auto *TyRec = Ty->getAs<RecordType>()) {\n    // Complete the type if it can be completed.\n    // If the type is neither complete nor being defined, bail out now.\n    if (SemaRef.isCompleteType(Loc, Ty) || TyRec->isBeingDefined() ||\n        TyRec->getDecl()->getDefinition()) {\n      Lookup.clear();\n      SemaRef.LookupQualifiedName(Lookup, TyRec->getDecl());\n      if (Lookup.empty()) {\n        Lookups.emplace_back();\n        Lookups.back().append(Lookup.begin(), Lookup.end());\n      }\n    }\n  }\n  // Perform ADL.\n  if (SemaRef.getLangOpts().CPlusPlus)\n    argumentDependentLookup(SemaRef, ReductionId, Loc, Ty, Lookups);\n  if (auto *VD = filterLookupForUDReductionAndMapper<ValueDecl *>(\n          Lookups, [&SemaRef, Ty](ValueDecl *D) -> ValueDecl * {\n            if (!D->isInvalidDecl() &&\n                SemaRef.Context.hasSameType(D->getType(), Ty))\n              return D;\n            return nullptr;\n          }))\n    return SemaRef.BuildDeclRefExpr(VD, VD->getType().getNonReferenceType(),\n                                    VK_LValue, Loc);\n  if (SemaRef.getLangOpts().CPlusPlus) {\n    if (auto *VD = filterLookupForUDReductionAndMapper<ValueDecl *>(\n            Lookups, [&SemaRef, Ty, Loc](ValueDecl *D) -> ValueDecl * {\n              if (!D->isInvalidDecl() &&\n                  SemaRef.IsDerivedFrom(Loc, Ty, D->getType()) &&\n                  !Ty.isMoreQualifiedThan(D->getType()))\n                return D;\n              return nullptr;\n            })) {\n      CXXBasePaths Paths(/*FindAmbiguities=*/true, /*RecordPaths=*/true,\n                         /*DetectVirtual=*/false);\n      if (SemaRef.IsDerivedFrom(Loc, Ty, VD->getType(), Paths)) {\n        if (!Paths.isAmbiguous(SemaRef.Context.getCanonicalType(\n                VD->getType().getUnqualifiedType()))) {\n          if (SemaRef.CheckBaseClassAccess(\n                  Loc, VD->getType(), Ty, Paths.front(),\n                  /*DiagID=*/0) != Sema::AR_inaccessible) {\n            SemaRef.BuildBasePathArray(Paths, BasePath);\n            return SemaRef.BuildDeclRefExpr(\n                VD, VD->getType().getNonReferenceType(), VK_LValue, Loc);\n          }\n        }\n      }\n    }\n  }\n  if (ReductionIdScopeSpec.isSet()) {\n    SemaRef.Diag(Loc, diag::err_omp_not_resolved_reduction_identifier)\n        << Ty << Range;\n    return ExprError();\n  }\n  return ExprEmpty();\n}\n\nnamespace {\n/// Data for the reduction-based clauses.\nstruct ReductionData {\n  /// List of original reduction items.\n  SmallVector<Expr *, 8> Vars;\n  /// List of private copies of the reduction items.\n  SmallVector<Expr *, 8> Privates;\n  /// LHS expressions for the reduction_op expressions.\n  SmallVector<Expr *, 8> LHSs;\n  /// RHS expressions for the reduction_op expressions.\n  SmallVector<Expr *, 8> RHSs;\n  /// Reduction operation expression.\n  SmallVector<Expr *, 8> ReductionOps;\n  /// inscan copy operation expressions.\n  SmallVector<Expr *, 8> InscanCopyOps;\n  /// inscan copy temp array expressions for prefix sums.\n  SmallVector<Expr *, 8> InscanCopyArrayTemps;\n  /// inscan copy temp array element expressions for prefix sums.\n  SmallVector<Expr *, 8> InscanCopyArrayElems;\n  /// Taskgroup descriptors for the corresponding reduction items in\n  /// in_reduction clauses.\n  SmallVector<Expr *, 8> TaskgroupDescriptors;\n  /// List of captures for clause.\n  SmallVector<Decl *, 4> ExprCaptures;\n  /// List of postupdate expressions.\n  SmallVector<Expr *, 4> ExprPostUpdates;\n  /// Reduction modifier.\n  unsigned RedModifier = 0;\n  ReductionData() = delete;\n  /// Reserves required memory for the reduction data.\n  ReductionData(unsigned Size, unsigned Modifier = 0) : RedModifier(Modifier) {\n    Vars.reserve(Size);\n    Privates.reserve(Size);\n    LHSs.reserve(Size);\n    RHSs.reserve(Size);\n    ReductionOps.reserve(Size);\n    if (RedModifier == OMPC_REDUCTION_inscan) {\n      InscanCopyOps.reserve(Size);\n      InscanCopyArrayTemps.reserve(Size);\n      InscanCopyArrayElems.reserve(Size);\n    }\n    TaskgroupDescriptors.reserve(Size);\n    ExprCaptures.reserve(Size);\n    ExprPostUpdates.reserve(Size);\n  }\n  /// Stores reduction item and reduction operation only (required for dependent\n  /// reduction item).\n  void push(Expr *Item, Expr *ReductionOp) {\n    Vars.emplace_back(Item);\n    Privates.emplace_back(nullptr);\n    LHSs.emplace_back(nullptr);\n    RHSs.emplace_back(nullptr);\n    ReductionOps.emplace_back(ReductionOp);\n    TaskgroupDescriptors.emplace_back(nullptr);\n    if (RedModifier == OMPC_REDUCTION_inscan) {\n      InscanCopyOps.push_back(nullptr);\n      InscanCopyArrayTemps.push_back(nullptr);\n      InscanCopyArrayElems.push_back(nullptr);\n    }\n  }\n  /// Stores reduction data.\n  void push(Expr *Item, Expr *Private, Expr *LHS, Expr *RHS, Expr *ReductionOp,\n            Expr *TaskgroupDescriptor, Expr *CopyOp, Expr *CopyArrayTemp,\n            Expr *CopyArrayElem) {\n    Vars.emplace_back(Item);\n    Privates.emplace_back(Private);\n    LHSs.emplace_back(LHS);\n    RHSs.emplace_back(RHS);\n    ReductionOps.emplace_back(ReductionOp);\n    TaskgroupDescriptors.emplace_back(TaskgroupDescriptor);\n    if (RedModifier == OMPC_REDUCTION_inscan) {\n      InscanCopyOps.push_back(CopyOp);\n      InscanCopyArrayTemps.push_back(CopyArrayTemp);\n      InscanCopyArrayElems.push_back(CopyArrayElem);\n    } else {\n      assert(CopyOp == nullptr && CopyArrayTemp == nullptr &&\n             CopyArrayElem == nullptr &&\n             \"Copy operation must be used for inscan reductions only.\");\n    }\n  }\n};\n} // namespace\n\nstatic bool checkOMPArraySectionConstantForReduction(\n    ASTContext &Context, const OMPArraySectionExpr *OASE, bool &SingleElement,\n    SmallVectorImpl<llvm::APSInt> &ArraySizes) {\n  const Expr *Length = OASE->getLength();\n  if (Length == nullptr) {\n    // For array sections of the form [1:] or [:], we would need to analyze\n    // the lower bound...\n    if (OASE->getColonLocFirst().isValid())\n      return false;\n\n    // This is an array subscript which has implicit length 1!\n    SingleElement = true;\n    ArraySizes.push_back(llvm::APSInt::get(1));\n  } else {\n    Expr::EvalResult Result;\n    if (!Length->EvaluateAsInt(Result, Context))\n      return false;\n\n    llvm::APSInt ConstantLengthValue = Result.Val.getInt();\n    SingleElement = (ConstantLengthValue.getSExtValue() == 1);\n    ArraySizes.push_back(ConstantLengthValue);\n  }\n\n  // Get the base of this array section and walk up from there.\n  const Expr *Base = OASE->getBase()->IgnoreParenImpCasts();\n\n  // We require length = 1 for all array sections except the right-most to\n  // guarantee that the memory region is contiguous and has no holes in it.\n  while (const auto *TempOASE = dyn_cast<OMPArraySectionExpr>(Base)) {\n    Length = TempOASE->getLength();\n    if (Length == nullptr) {\n      // For array sections of the form [1:] or [:], we would need to analyze\n      // the lower bound...\n      if (OASE->getColonLocFirst().isValid())\n        return false;\n\n      // This is an array subscript which has implicit length 1!\n      ArraySizes.push_back(llvm::APSInt::get(1));\n    } else {\n      Expr::EvalResult Result;\n      if (!Length->EvaluateAsInt(Result, Context))\n        return false;\n\n      llvm::APSInt ConstantLengthValue = Result.Val.getInt();\n      if (ConstantLengthValue.getSExtValue() != 1)\n        return false;\n\n      ArraySizes.push_back(ConstantLengthValue);\n    }\n    Base = TempOASE->getBase()->IgnoreParenImpCasts();\n  }\n\n  // If we have a single element, we don't need to add the implicit lengths.\n  if (!SingleElement) {\n    while (const auto *TempASE = dyn_cast<ArraySubscriptExpr>(Base)) {\n      // Has implicit length 1!\n      ArraySizes.push_back(llvm::APSInt::get(1));\n      Base = TempASE->getBase()->IgnoreParenImpCasts();\n    }\n  }\n\n  // This array section can be privatized as a single value or as a constant\n  // sized array.\n  return true;\n}\n\nstatic bool actOnOMPReductionKindClause(\n    Sema &S, DSAStackTy *Stack, OpenMPClauseKind ClauseKind,\n    ArrayRef<Expr *> VarList, SourceLocation StartLoc, SourceLocation LParenLoc,\n    SourceLocation ColonLoc, SourceLocation EndLoc,\n    CXXScopeSpec &ReductionIdScopeSpec, const DeclarationNameInfo &ReductionId,\n    ArrayRef<Expr *> UnresolvedReductions, ReductionData &RD) {\n  DeclarationName DN = ReductionId.getName();\n  OverloadedOperatorKind OOK = DN.getCXXOverloadedOperator();\n  BinaryOperatorKind BOK = BO_Comma;\n\n  ASTContext &Context = S.Context;\n  // OpenMP [2.14.3.6, reduction clause]\n  // C\n  // reduction-identifier is either an identifier or one of the following\n  // operators: +, -, *,  &, |, ^, && and ||\n  // C++\n  // reduction-identifier is either an id-expression or one of the following\n  // operators: +, -, *, &, |, ^, && and ||\n  switch (OOK) {\n  case OO_Plus:\n  case OO_Minus:\n    BOK = BO_Add;\n    break;\n  case OO_Star:\n    BOK = BO_Mul;\n    break;\n  case OO_Amp:\n    BOK = BO_And;\n    break;\n  case OO_Pipe:\n    BOK = BO_Or;\n    break;\n  case OO_Caret:\n    BOK = BO_Xor;\n    break;\n  case OO_AmpAmp:\n    BOK = BO_LAnd;\n    break;\n  case OO_PipePipe:\n    BOK = BO_LOr;\n    break;\n  case OO_New:\n  case OO_Delete:\n  case OO_Array_New:\n  case OO_Array_Delete:\n  case OO_Slash:\n  case OO_Percent:\n  case OO_Tilde:\n  case OO_Exclaim:\n  case OO_Equal:\n  case OO_Less:\n  case OO_Greater:\n  case OO_LessEqual:\n  case OO_GreaterEqual:\n  case OO_PlusEqual:\n  case OO_MinusEqual:\n  case OO_StarEqual:\n  case OO_SlashEqual:\n  case OO_PercentEqual:\n  case OO_CaretEqual:\n  case OO_AmpEqual:\n  case OO_PipeEqual:\n  case OO_LessLess:\n  case OO_GreaterGreater:\n  case OO_LessLessEqual:\n  case OO_GreaterGreaterEqual:\n  case OO_EqualEqual:\n  case OO_ExclaimEqual:\n  case OO_Spaceship:\n  case OO_PlusPlus:\n  case OO_MinusMinus:\n  case OO_Comma:\n  case OO_ArrowStar:\n  case OO_Arrow:\n  case OO_Call:\n  case OO_Subscript:\n  case OO_Conditional:\n  case OO_Coawait:\n  case NUM_OVERLOADED_OPERATORS:\n    llvm_unreachable(\"Unexpected reduction identifier\");\n  case OO_None:\n    if (IdentifierInfo *II = DN.getAsIdentifierInfo()) {\n      if (II->isStr(\"max\"))\n        BOK = BO_GT;\n      else if (II->isStr(\"min\"))\n        BOK = BO_LT;\n    }\n    break;\n  }\n  SourceRange ReductionIdRange;\n  if (ReductionIdScopeSpec.isValid())\n    ReductionIdRange.setBegin(ReductionIdScopeSpec.getBeginLoc());\n  else\n    ReductionIdRange.setBegin(ReductionId.getBeginLoc());\n  ReductionIdRange.setEnd(ReductionId.getEndLoc());\n\n  auto IR = UnresolvedReductions.begin(), ER = UnresolvedReductions.end();\n  bool FirstIter = true;\n  for (Expr *RefExpr : VarList) {\n    assert(RefExpr && \"nullptr expr in OpenMP reduction clause.\");\n    // OpenMP [2.1, C/C++]\n    //  A list item is a variable or array section, subject to the restrictions\n    //  specified in Section 2.4 on page 42 and in each of the sections\n    // describing clauses and directives for which a list appears.\n    // OpenMP  [2.14.3.3, Restrictions, p.1]\n    //  A variable that is part of another variable (as an array or\n    //  structure element) cannot appear in a private clause.\n    if (!FirstIter && IR != ER)\n      ++IR;\n    FirstIter = false;\n    SourceLocation ELoc;\n    SourceRange ERange;\n    Expr *SimpleRefExpr = RefExpr;\n    auto Res = getPrivateItem(S, SimpleRefExpr, ELoc, ERange,\n                              /*AllowArraySection=*/true);\n    if (Res.second) {\n      // Try to find 'declare reduction' corresponding construct before using\n      // builtin/overloaded operators.\n      QualType Type = Context.DependentTy;\n      CXXCastPath BasePath;\n      ExprResult DeclareReductionRef = buildDeclareReductionRef(\n          S, ELoc, ERange, Stack->getCurScope(), ReductionIdScopeSpec,\n          ReductionId, Type, BasePath, IR == ER ? nullptr : *IR);\n      Expr *ReductionOp = nullptr;\n      if (S.CurContext->isDependentContext() &&\n          (DeclareReductionRef.isUnset() ||\n           isa<UnresolvedLookupExpr>(DeclareReductionRef.get())))\n        ReductionOp = DeclareReductionRef.get();\n      // It will be analyzed later.\n      RD.push(RefExpr, ReductionOp);\n    }\n    ValueDecl *D = Res.first;\n    if (!D)\n      continue;\n\n    Expr *TaskgroupDescriptor = nullptr;\n    QualType Type;\n    auto *ASE = dyn_cast<ArraySubscriptExpr>(RefExpr->IgnoreParens());\n    auto *OASE = dyn_cast<OMPArraySectionExpr>(RefExpr->IgnoreParens());\n    if (ASE) {\n      Type = ASE->getType().getNonReferenceType();\n    } else if (OASE) {\n      QualType BaseType =\n          OMPArraySectionExpr::getBaseOriginalType(OASE->getBase());\n      if (const auto *ATy = BaseType->getAsArrayTypeUnsafe())\n        Type = ATy->getElementType();\n      else\n        Type = BaseType->getPointeeType();\n      Type = Type.getNonReferenceType();\n    } else {\n      Type = Context.getBaseElementType(D->getType().getNonReferenceType());\n    }\n    auto *VD = dyn_cast<VarDecl>(D);\n\n    // OpenMP [2.9.3.3, Restrictions, C/C++, p.3]\n    //  A variable that appears in a private clause must not have an incomplete\n    //  type or a reference type.\n    if (S.RequireCompleteType(ELoc, D->getType(),\n                              diag::err_omp_reduction_incomplete_type))\n      continue;\n    // OpenMP [2.14.3.6, reduction clause, Restrictions]\n    // A list item that appears in a reduction clause must not be\n    // const-qualified.\n    if (rejectConstNotMutableType(S, D, Type, ClauseKind, ELoc,\n                                  /*AcceptIfMutable*/ false, ASE || OASE))\n      continue;\n\n    OpenMPDirectiveKind CurrDir = Stack->getCurrentDirective();\n    // OpenMP [2.9.3.6, Restrictions, C/C++, p.4]\n    //  If a list-item is a reference type then it must bind to the same object\n    //  for all threads of the team.\n    if (!ASE && !OASE) {\n      if (VD) {\n        VarDecl *VDDef = VD->getDefinition();\n        if (VD->getType()->isReferenceType() && VDDef && VDDef->hasInit()) {\n          DSARefChecker Check(Stack);\n          if (Check.Visit(VDDef->getInit())) {\n            S.Diag(ELoc, diag::err_omp_reduction_ref_type_arg)\n                << getOpenMPClauseName(ClauseKind) << ERange;\n            S.Diag(VDDef->getLocation(), diag::note_defined_here) << VDDef;\n            continue;\n          }\n        }\n      }\n\n      // OpenMP [2.14.1.1, Data-sharing Attribute Rules for Variables Referenced\n      // in a Construct]\n      //  Variables with the predetermined data-sharing attributes may not be\n      //  listed in data-sharing attributes clauses, except for the cases\n      //  listed below. For these exceptions only, listing a predetermined\n      //  variable in a data-sharing attribute clause is allowed and overrides\n      //  the variable's predetermined data-sharing attributes.\n      // OpenMP [2.14.3.6, Restrictions, p.3]\n      //  Any number of reduction clauses can be specified on the directive,\n      //  but a list item can appear only once in the reduction clauses for that\n      //  directive.\n      DSAStackTy::DSAVarData DVar = Stack->getTopDSA(D, /*FromParent=*/false);\n      if (DVar.CKind == OMPC_reduction) {\n        S.Diag(ELoc, diag::err_omp_once_referenced)\n            << getOpenMPClauseName(ClauseKind);\n        if (DVar.RefExpr)\n          S.Diag(DVar.RefExpr->getExprLoc(), diag::note_omp_referenced);\n        continue;\n      }\n      if (DVar.CKind != OMPC_unknown) {\n        S.Diag(ELoc, diag::err_omp_wrong_dsa)\n            << getOpenMPClauseName(DVar.CKind)\n            << getOpenMPClauseName(OMPC_reduction);\n        reportOriginalDsa(S, Stack, D, DVar);\n        continue;\n      }\n\n      // OpenMP [2.14.3.6, Restrictions, p.1]\n      //  A list item that appears in a reduction clause of a worksharing\n      //  construct must be shared in the parallel regions to which any of the\n      //  worksharing regions arising from the worksharing construct bind.\n      if (isOpenMPWorksharingDirective(CurrDir) &&\n          !isOpenMPParallelDirective(CurrDir) &&\n          !isOpenMPTeamsDirective(CurrDir)) {\n        DVar = Stack->getImplicitDSA(D, true);\n        if (DVar.CKind != OMPC_shared) {\n          S.Diag(ELoc, diag::err_omp_required_access)\n              << getOpenMPClauseName(OMPC_reduction)\n              << getOpenMPClauseName(OMPC_shared);\n          reportOriginalDsa(S, Stack, D, DVar);\n          continue;\n        }\n      }\n    } else {\n      // Threadprivates cannot be shared between threads, so dignose if the base\n      // is a threadprivate variable.\n      DSAStackTy::DSAVarData DVar = Stack->getTopDSA(D, /*FromParent=*/false);\n      if (DVar.CKind == OMPC_threadprivate) {\n        S.Diag(ELoc, diag::err_omp_wrong_dsa)\n            << getOpenMPClauseName(DVar.CKind)\n            << getOpenMPClauseName(OMPC_reduction);\n        reportOriginalDsa(S, Stack, D, DVar);\n        continue;\n      }\n    }\n\n    // Try to find 'declare reduction' corresponding construct before using\n    // builtin/overloaded operators.\n    CXXCastPath BasePath;\n    ExprResult DeclareReductionRef = buildDeclareReductionRef(\n        S, ELoc, ERange, Stack->getCurScope(), ReductionIdScopeSpec,\n        ReductionId, Type, BasePath, IR == ER ? nullptr : *IR);\n    if (DeclareReductionRef.isInvalid())\n      continue;\n    if (S.CurContext->isDependentContext() &&\n        (DeclareReductionRef.isUnset() ||\n         isa<UnresolvedLookupExpr>(DeclareReductionRef.get()))) {\n      RD.push(RefExpr, DeclareReductionRef.get());\n      continue;\n    }\n    if (BOK == BO_Comma && DeclareReductionRef.isUnset()) {\n      // Not allowed reduction identifier is found.\n      S.Diag(ReductionId.getBeginLoc(),\n             diag::err_omp_unknown_reduction_identifier)\n          << Type << ReductionIdRange;\n      continue;\n    }\n\n    // OpenMP [2.14.3.6, reduction clause, Restrictions]\n    // The type of a list item that appears in a reduction clause must be valid\n    // for the reduction-identifier. For a max or min reduction in C, the type\n    // of the list item must be an allowed arithmetic data type: char, int,\n    // float, double, or _Bool, possibly modified with long, short, signed, or\n    // unsigned. For a max or min reduction in C++, the type of the list item\n    // must be an allowed arithmetic data type: char, wchar_t, int, float,\n    // double, or bool, possibly modified with long, short, signed, or unsigned.\n    if (DeclareReductionRef.isUnset()) {\n      if ((BOK == BO_GT || BOK == BO_LT) &&\n          !(Type->isScalarType() ||\n            (S.getLangOpts().CPlusPlus && Type->isArithmeticType()))) {\n        S.Diag(ELoc, diag::err_omp_clause_not_arithmetic_type_arg)\n            << getOpenMPClauseName(ClauseKind) << S.getLangOpts().CPlusPlus;\n        if (!ASE && !OASE) {\n          bool IsDecl = !VD || VD->isThisDeclarationADefinition(Context) ==\n                                   VarDecl::DeclarationOnly;\n          S.Diag(D->getLocation(),\n                 IsDecl ? diag::note_previous_decl : diag::note_defined_here)\n              << D;\n        }\n        continue;\n      }\n      if ((BOK == BO_OrAssign || BOK == BO_AndAssign || BOK == BO_XorAssign) &&\n          !S.getLangOpts().CPlusPlus && Type->isFloatingType()) {\n        S.Diag(ELoc, diag::err_omp_clause_floating_type_arg)\n            << getOpenMPClauseName(ClauseKind);\n        if (!ASE && !OASE) {\n          bool IsDecl = !VD || VD->isThisDeclarationADefinition(Context) ==\n                                   VarDecl::DeclarationOnly;\n          S.Diag(D->getLocation(),\n                 IsDecl ? diag::note_previous_decl : diag::note_defined_here)\n              << D;\n        }\n        continue;\n      }\n    }\n\n    Type = Type.getNonLValueExprType(Context).getUnqualifiedType();\n    VarDecl *LHSVD = buildVarDecl(S, ELoc, Type, \".reduction.lhs\",\n                                  D->hasAttrs() ? &D->getAttrs() : nullptr);\n    VarDecl *RHSVD = buildVarDecl(S, ELoc, Type, D->getName(),\n                                  D->hasAttrs() ? &D->getAttrs() : nullptr);\n    QualType PrivateTy = Type;\n\n    // Try if we can determine constant lengths for all array sections and avoid\n    // the VLA.\n    bool ConstantLengthOASE = false;\n    if (OASE) {\n      bool SingleElement;\n      llvm::SmallVector<llvm::APSInt, 4> ArraySizes;\n      ConstantLengthOASE = checkOMPArraySectionConstantForReduction(\n          Context, OASE, SingleElement, ArraySizes);\n\n      // If we don't have a single element, we must emit a constant array type.\n      if (ConstantLengthOASE && !SingleElement) {\n        for (llvm::APSInt &Size : ArraySizes)\n          PrivateTy = Context.getConstantArrayType(PrivateTy, Size, nullptr,\n                                                   ArrayType::Normal,\n                                                   /*IndexTypeQuals=*/0);\n      }\n    }\n\n    if ((OASE && !ConstantLengthOASE) ||\n        (!OASE && !ASE &&\n         D->getType().getNonReferenceType()->isVariablyModifiedType())) {\n      if (!Context.getTargetInfo().isVLASupported()) {\n        if (isOpenMPTargetExecutionDirective(Stack->getCurrentDirective())) {\n          S.Diag(ELoc, diag::err_omp_reduction_vla_unsupported) << !!OASE;\n          S.Diag(ELoc, diag::note_vla_unsupported);\n          continue;\n        } else {\n          S.targetDiag(ELoc, diag::err_omp_reduction_vla_unsupported) << !!OASE;\n          S.targetDiag(ELoc, diag::note_vla_unsupported);\n        }\n      }\n      // For arrays/array sections only:\n      // Create pseudo array type for private copy. The size for this array will\n      // be generated during codegen.\n      // For array subscripts or single variables Private Ty is the same as Type\n      // (type of the variable or single array element).\n      PrivateTy = Context.getVariableArrayType(\n          Type,\n          new (Context) OpaqueValueExpr(ELoc, Context.getSizeType(), VK_RValue),\n          ArrayType::Normal, /*IndexTypeQuals=*/0, SourceRange());\n    } else if (!ASE && !OASE &&\n               Context.getAsArrayType(D->getType().getNonReferenceType())) {\n      PrivateTy = D->getType().getNonReferenceType();\n    }\n    // Private copy.\n    VarDecl *PrivateVD =\n        buildVarDecl(S, ELoc, PrivateTy, D->getName(),\n                     D->hasAttrs() ? &D->getAttrs() : nullptr,\n                     VD ? cast<DeclRefExpr>(SimpleRefExpr) : nullptr);\n    // Add initializer for private variable.\n    Expr *Init = nullptr;\n    DeclRefExpr *LHSDRE = buildDeclRefExpr(S, LHSVD, Type, ELoc);\n    DeclRefExpr *RHSDRE = buildDeclRefExpr(S, RHSVD, Type, ELoc);\n    if (DeclareReductionRef.isUsable()) {\n      auto *DRDRef = DeclareReductionRef.getAs<DeclRefExpr>();\n      auto *DRD = cast<OMPDeclareReductionDecl>(DRDRef->getDecl());\n      if (DRD->getInitializer()) {\n        S.ActOnUninitializedDecl(PrivateVD);\n        Init = DRDRef;\n        RHSVD->setInit(DRDRef);\n        RHSVD->setInitStyle(VarDecl::CallInit);\n      }\n    } else {\n      switch (BOK) {\n      case BO_Add:\n      case BO_Xor:\n      case BO_Or:\n      case BO_LOr:\n        // '+', '-', '^', '|', '||' reduction ops - initializer is '0'.\n        if (Type->isScalarType() || Type->isAnyComplexType())\n          Init = S.ActOnIntegerConstant(ELoc, /*Val=*/0).get();\n        break;\n      case BO_Mul:\n      case BO_LAnd:\n        if (Type->isScalarType() || Type->isAnyComplexType()) {\n          // '*' and '&&' reduction ops - initializer is '1'.\n          Init = S.ActOnIntegerConstant(ELoc, /*Val=*/1).get();\n        }\n        break;\n      case BO_And: {\n        // '&' reduction op - initializer is '~0'.\n        QualType OrigType = Type;\n        if (auto *ComplexTy = OrigType->getAs<ComplexType>())\n          Type = ComplexTy->getElementType();\n        if (Type->isRealFloatingType()) {\n          llvm::APFloat InitValue = llvm::APFloat::getAllOnesValue(\n              Context.getFloatTypeSemantics(Type),\n              Context.getTypeSize(Type));\n          Init = FloatingLiteral::Create(Context, InitValue, /*isexact=*/true,\n                                         Type, ELoc);\n        } else if (Type->isScalarType()) {\n          uint64_t Size = Context.getTypeSize(Type);\n          QualType IntTy = Context.getIntTypeForBitwidth(Size, /*Signed=*/0);\n          llvm::APInt InitValue = llvm::APInt::getAllOnesValue(Size);\n          Init = IntegerLiteral::Create(Context, InitValue, IntTy, ELoc);\n        }\n        if (Init && OrigType->isAnyComplexType()) {\n          // Init = 0xFFFF + 0xFFFFi;\n          auto *Im = new (Context) ImaginaryLiteral(Init, OrigType);\n          Init = S.CreateBuiltinBinOp(ELoc, BO_Add, Init, Im).get();\n        }\n        Type = OrigType;\n        break;\n      }\n      case BO_LT:\n      case BO_GT: {\n        // 'min' reduction op - initializer is 'Largest representable number in\n        // the reduction list item type'.\n        // 'max' reduction op - initializer is 'Least representable number in\n        // the reduction list item type'.\n        if (Type->isIntegerType() || Type->isPointerType()) {\n          bool IsSigned = Type->hasSignedIntegerRepresentation();\n          uint64_t Size = Context.getTypeSize(Type);\n          QualType IntTy =\n              Context.getIntTypeForBitwidth(Size, /*Signed=*/IsSigned);\n          llvm::APInt InitValue =\n              (BOK != BO_LT) ? IsSigned ? llvm::APInt::getSignedMinValue(Size)\n                                        : llvm::APInt::getMinValue(Size)\n                             : IsSigned ? llvm::APInt::getSignedMaxValue(Size)\n                                        : llvm::APInt::getMaxValue(Size);\n          Init = IntegerLiteral::Create(Context, InitValue, IntTy, ELoc);\n          if (Type->isPointerType()) {\n            // Cast to pointer type.\n            ExprResult CastExpr = S.BuildCStyleCastExpr(\n                ELoc, Context.getTrivialTypeSourceInfo(Type, ELoc), ELoc, Init);\n            if (CastExpr.isInvalid())\n              continue;\n            Init = CastExpr.get();\n          }\n        } else if (Type->isRealFloatingType()) {\n          llvm::APFloat InitValue = llvm::APFloat::getLargest(\n              Context.getFloatTypeSemantics(Type), BOK != BO_LT);\n          Init = FloatingLiteral::Create(Context, InitValue, /*isexact=*/true,\n                                         Type, ELoc);\n        }\n        break;\n      }\n      case BO_PtrMemD:\n      case BO_PtrMemI:\n      case BO_MulAssign:\n      case BO_Div:\n      case BO_Rem:\n      case BO_Sub:\n      case BO_Shl:\n      case BO_Shr:\n      case BO_LE:\n      case BO_GE:\n      case BO_EQ:\n      case BO_NE:\n      case BO_Cmp:\n      case BO_AndAssign:\n      case BO_XorAssign:\n      case BO_OrAssign:\n      case BO_Assign:\n      case BO_AddAssign:\n      case BO_SubAssign:\n      case BO_DivAssign:\n      case BO_RemAssign:\n      case BO_ShlAssign:\n      case BO_ShrAssign:\n      case BO_Comma:\n        llvm_unreachable(\"Unexpected reduction operation\");\n      }\n    }\n    if (Init && DeclareReductionRef.isUnset()) {\n      S.AddInitializerToDecl(RHSVD, Init, /*DirectInit=*/false);\n      // Store initializer for single element in private copy. Will be used\n      // during codegen.\n      PrivateVD->setInit(RHSVD->getInit());\n      PrivateVD->setInitStyle(RHSVD->getInitStyle());\n    } else if (!Init) {\n      S.ActOnUninitializedDecl(RHSVD);\n      // Store initializer for single element in private copy. Will be used\n      // during codegen.\n      PrivateVD->setInit(RHSVD->getInit());\n      PrivateVD->setInitStyle(RHSVD->getInitStyle());\n    }\n    if (RHSVD->isInvalidDecl())\n      continue;\n    if (!RHSVD->hasInit() &&\n        (DeclareReductionRef.isUnset() || !S.LangOpts.CPlusPlus)) {\n      S.Diag(ELoc, diag::err_omp_reduction_id_not_compatible)\n          << Type << ReductionIdRange;\n      bool IsDecl = !VD || VD->isThisDeclarationADefinition(Context) ==\n                               VarDecl::DeclarationOnly;\n      S.Diag(D->getLocation(),\n             IsDecl ? diag::note_previous_decl : diag::note_defined_here)\n          << D;\n      continue;\n    }\n    DeclRefExpr *PrivateDRE = buildDeclRefExpr(S, PrivateVD, PrivateTy, ELoc);\n    ExprResult ReductionOp;\n    if (DeclareReductionRef.isUsable()) {\n      QualType RedTy = DeclareReductionRef.get()->getType();\n      QualType PtrRedTy = Context.getPointerType(RedTy);\n      ExprResult LHS = S.CreateBuiltinUnaryOp(ELoc, UO_AddrOf, LHSDRE);\n      ExprResult RHS = S.CreateBuiltinUnaryOp(ELoc, UO_AddrOf, RHSDRE);\n      if (!BasePath.empty()) {\n        LHS = S.DefaultLvalueConversion(LHS.get());\n        RHS = S.DefaultLvalueConversion(RHS.get());\n        LHS = ImplicitCastExpr::Create(\n            Context, PtrRedTy, CK_UncheckedDerivedToBase, LHS.get(), &BasePath,\n            LHS.get()->getValueKind(), FPOptionsOverride());\n        RHS = ImplicitCastExpr::Create(\n            Context, PtrRedTy, CK_UncheckedDerivedToBase, RHS.get(), &BasePath,\n            RHS.get()->getValueKind(), FPOptionsOverride());\n      }\n      FunctionProtoType::ExtProtoInfo EPI;\n      QualType Params[] = {PtrRedTy, PtrRedTy};\n      QualType FnTy = Context.getFunctionType(Context.VoidTy, Params, EPI);\n      auto *OVE = new (Context) OpaqueValueExpr(\n          ELoc, Context.getPointerType(FnTy), VK_RValue, OK_Ordinary,\n          S.DefaultLvalueConversion(DeclareReductionRef.get()).get());\n      Expr *Args[] = {LHS.get(), RHS.get()};\n      ReductionOp =\n          CallExpr::Create(Context, OVE, Args, Context.VoidTy, VK_RValue, ELoc,\n                           S.CurFPFeatureOverrides());\n    } else {\n      ReductionOp = S.BuildBinOp(\n          Stack->getCurScope(), ReductionId.getBeginLoc(), BOK, LHSDRE, RHSDRE);\n      if (ReductionOp.isUsable()) {\n        if (BOK != BO_LT && BOK != BO_GT) {\n          ReductionOp =\n              S.BuildBinOp(Stack->getCurScope(), ReductionId.getBeginLoc(),\n                           BO_Assign, LHSDRE, ReductionOp.get());\n        } else {\n          auto *ConditionalOp = new (Context)\n              ConditionalOperator(ReductionOp.get(), ELoc, LHSDRE, ELoc, RHSDRE,\n                                  Type, VK_LValue, OK_Ordinary);\n          ReductionOp =\n              S.BuildBinOp(Stack->getCurScope(), ReductionId.getBeginLoc(),\n                           BO_Assign, LHSDRE, ConditionalOp);\n        }\n        if (ReductionOp.isUsable())\n          ReductionOp = S.ActOnFinishFullExpr(ReductionOp.get(),\n                                              /*DiscardedValue*/ false);\n      }\n      if (!ReductionOp.isUsable())\n        continue;\n    }\n\n    // Add copy operations for inscan reductions.\n    // LHS = RHS;\n    ExprResult CopyOpRes, TempArrayRes, TempArrayElem;\n    if (ClauseKind == OMPC_reduction &&\n        RD.RedModifier == OMPC_REDUCTION_inscan) {\n      ExprResult RHS = S.DefaultLvalueConversion(RHSDRE);\n      CopyOpRes = S.BuildBinOp(Stack->getCurScope(), ELoc, BO_Assign, LHSDRE,\n                               RHS.get());\n      if (!CopyOpRes.isUsable())\n        continue;\n      CopyOpRes =\n          S.ActOnFinishFullExpr(CopyOpRes.get(), /*DiscardedValue=*/true);\n      if (!CopyOpRes.isUsable())\n        continue;\n      // For simd directive and simd-based directives in simd mode no need to\n      // construct temp array, need just a single temp element.\n      if (Stack->getCurrentDirective() == OMPD_simd ||\n          (S.getLangOpts().OpenMPSimd &&\n           isOpenMPSimdDirective(Stack->getCurrentDirective()))) {\n        VarDecl *TempArrayVD =\n            buildVarDecl(S, ELoc, PrivateTy, D->getName(),\n                         D->hasAttrs() ? &D->getAttrs() : nullptr);\n        // Add a constructor to the temp decl.\n        S.ActOnUninitializedDecl(TempArrayVD);\n        TempArrayRes = buildDeclRefExpr(S, TempArrayVD, PrivateTy, ELoc);\n      } else {\n        // Build temp array for prefix sum.\n        auto *Dim = new (S.Context)\n            OpaqueValueExpr(ELoc, S.Context.getSizeType(), VK_RValue);\n        QualType ArrayTy =\n            S.Context.getVariableArrayType(PrivateTy, Dim, ArrayType::Normal,\n                                           /*IndexTypeQuals=*/0, {ELoc, ELoc});\n        VarDecl *TempArrayVD =\n            buildVarDecl(S, ELoc, ArrayTy, D->getName(),\n                         D->hasAttrs() ? &D->getAttrs() : nullptr);\n        // Add a constructor to the temp decl.\n        S.ActOnUninitializedDecl(TempArrayVD);\n        TempArrayRes = buildDeclRefExpr(S, TempArrayVD, ArrayTy, ELoc);\n        TempArrayElem =\n            S.DefaultFunctionArrayLvalueConversion(TempArrayRes.get());\n        auto *Idx = new (S.Context)\n            OpaqueValueExpr(ELoc, S.Context.getSizeType(), VK_RValue);\n        TempArrayElem = S.CreateBuiltinArraySubscriptExpr(TempArrayElem.get(),\n                                                          ELoc, Idx, ELoc);\n      }\n    }\n\n    // OpenMP [2.15.4.6, Restrictions, p.2]\n    // A list item that appears in an in_reduction clause of a task construct\n    // must appear in a task_reduction clause of a construct associated with a\n    // taskgroup region that includes the participating task in its taskgroup\n    // set. The construct associated with the innermost region that meets this\n    // condition must specify the same reduction-identifier as the in_reduction\n    // clause.\n    if (ClauseKind == OMPC_in_reduction) {\n      SourceRange ParentSR;\n      BinaryOperatorKind ParentBOK;\n      const Expr *ParentReductionOp = nullptr;\n      Expr *ParentBOKTD = nullptr, *ParentReductionOpTD = nullptr;\n      DSAStackTy::DSAVarData ParentBOKDSA =\n          Stack->getTopMostTaskgroupReductionData(D, ParentSR, ParentBOK,\n                                                  ParentBOKTD);\n      DSAStackTy::DSAVarData ParentReductionOpDSA =\n          Stack->getTopMostTaskgroupReductionData(\n              D, ParentSR, ParentReductionOp, ParentReductionOpTD);\n      bool IsParentBOK = ParentBOKDSA.DKind != OMPD_unknown;\n      bool IsParentReductionOp = ParentReductionOpDSA.DKind != OMPD_unknown;\n      if ((DeclareReductionRef.isUnset() && IsParentReductionOp) ||\n          (DeclareReductionRef.isUsable() && IsParentBOK) ||\n          (IsParentBOK && BOK != ParentBOK) || IsParentReductionOp) {\n        bool EmitError = true;\n        if (IsParentReductionOp && DeclareReductionRef.isUsable()) {\n          llvm::FoldingSetNodeID RedId, ParentRedId;\n          ParentReductionOp->Profile(ParentRedId, Context, /*Canonical=*/true);\n          DeclareReductionRef.get()->Profile(RedId, Context,\n                                             /*Canonical=*/true);\n          EmitError = RedId != ParentRedId;\n        }\n        if (EmitError) {\n          S.Diag(ReductionId.getBeginLoc(),\n                 diag::err_omp_reduction_identifier_mismatch)\n              << ReductionIdRange << RefExpr->getSourceRange();\n          S.Diag(ParentSR.getBegin(),\n                 diag::note_omp_previous_reduction_identifier)\n              << ParentSR\n              << (IsParentBOK ? ParentBOKDSA.RefExpr\n                              : ParentReductionOpDSA.RefExpr)\n                     ->getSourceRange();\n          continue;\n        }\n      }\n      TaskgroupDescriptor = IsParentBOK ? ParentBOKTD : ParentReductionOpTD;\n    }\n\n    DeclRefExpr *Ref = nullptr;\n    Expr *VarsExpr = RefExpr->IgnoreParens();\n    if (!VD && !S.CurContext->isDependentContext()) {\n      if (ASE || OASE) {\n        TransformExprToCaptures RebuildToCapture(S, D);\n        VarsExpr =\n            RebuildToCapture.TransformExpr(RefExpr->IgnoreParens()).get();\n        Ref = RebuildToCapture.getCapturedExpr();\n      } else {\n        VarsExpr = Ref = buildCapture(S, D, SimpleRefExpr, /*WithInit=*/false);\n      }\n      if (!S.isOpenMPCapturedDecl(D)) {\n        RD.ExprCaptures.emplace_back(Ref->getDecl());\n        if (Ref->getDecl()->hasAttr<OMPCaptureNoInitAttr>()) {\n          ExprResult RefRes = S.DefaultLvalueConversion(Ref);\n          if (!RefRes.isUsable())\n            continue;\n          ExprResult PostUpdateRes =\n              S.BuildBinOp(Stack->getCurScope(), ELoc, BO_Assign, SimpleRefExpr,\n                           RefRes.get());\n          if (!PostUpdateRes.isUsable())\n            continue;\n          if (isOpenMPTaskingDirective(Stack->getCurrentDirective()) ||\n              Stack->getCurrentDirective() == OMPD_taskgroup) {\n            S.Diag(RefExpr->getExprLoc(),\n                   diag::err_omp_reduction_non_addressable_expression)\n                << RefExpr->getSourceRange();\n            continue;\n          }\n          RD.ExprPostUpdates.emplace_back(\n              S.IgnoredValueConversions(PostUpdateRes.get()).get());\n        }\n      }\n    }\n    // All reduction items are still marked as reduction (to do not increase\n    // code base size).\n    unsigned Modifier = RD.RedModifier;\n    // Consider task_reductions as reductions with task modifier. Required for\n    // correct analysis of in_reduction clauses.\n    if (CurrDir == OMPD_taskgroup && ClauseKind == OMPC_task_reduction)\n      Modifier = OMPC_REDUCTION_task;\n    Stack->addDSA(D, RefExpr->IgnoreParens(), OMPC_reduction, Ref, Modifier,\n                  ASE || OASE);\n    if (Modifier == OMPC_REDUCTION_task &&\n        (CurrDir == OMPD_taskgroup ||\n         ((isOpenMPParallelDirective(CurrDir) ||\n           isOpenMPWorksharingDirective(CurrDir)) &&\n          !isOpenMPSimdDirective(CurrDir)))) {\n      if (DeclareReductionRef.isUsable())\n        Stack->addTaskgroupReductionData(D, ReductionIdRange,\n                                         DeclareReductionRef.get());\n      else\n        Stack->addTaskgroupReductionData(D, ReductionIdRange, BOK);\n    }\n    RD.push(VarsExpr, PrivateDRE, LHSDRE, RHSDRE, ReductionOp.get(),\n            TaskgroupDescriptor, CopyOpRes.get(), TempArrayRes.get(),\n            TempArrayElem.get());\n  }\n  return RD.Vars.empty();\n}\n\nOMPClause *Sema::ActOnOpenMPReductionClause(\n    ArrayRef<Expr *> VarList, OpenMPReductionClauseModifier Modifier,\n    SourceLocation StartLoc, SourceLocation LParenLoc,\n    SourceLocation ModifierLoc, SourceLocation ColonLoc, SourceLocation EndLoc,\n    CXXScopeSpec &ReductionIdScopeSpec, const DeclarationNameInfo &ReductionId,\n    ArrayRef<Expr *> UnresolvedReductions) {\n  if (ModifierLoc.isValid() && Modifier == OMPC_REDUCTION_unknown) {\n    Diag(LParenLoc, diag::err_omp_unexpected_clause_value)\n        << getListOfPossibleValues(OMPC_reduction, /*First=*/0,\n                                   /*Last=*/OMPC_REDUCTION_unknown)\n        << getOpenMPClauseName(OMPC_reduction);\n    return nullptr;\n  }\n  // OpenMP 5.0, 2.19.5.4 reduction Clause, Restrictions\n  // A reduction clause with the inscan reduction-modifier may only appear on a\n  // worksharing-loop construct, a worksharing-loop SIMD construct, a simd\n  // construct, a parallel worksharing-loop construct or a parallel\n  // worksharing-loop SIMD construct.\n  if (Modifier == OMPC_REDUCTION_inscan &&\n      (DSAStack->getCurrentDirective() != OMPD_for &&\n       DSAStack->getCurrentDirective() != OMPD_for_simd &&\n       DSAStack->getCurrentDirective() != OMPD_simd &&\n       DSAStack->getCurrentDirective() != OMPD_parallel_for &&\n       DSAStack->getCurrentDirective() != OMPD_parallel_for_simd)) {\n    Diag(ModifierLoc, diag::err_omp_wrong_inscan_reduction);\n    return nullptr;\n  }\n\n  ReductionData RD(VarList.size(), Modifier);\n  if (actOnOMPReductionKindClause(*this, DSAStack, OMPC_reduction, VarList,\n                                  StartLoc, LParenLoc, ColonLoc, EndLoc,\n                                  ReductionIdScopeSpec, ReductionId,\n                                  UnresolvedReductions, RD))\n    return nullptr;\n\n  return OMPReductionClause::Create(\n      Context, StartLoc, LParenLoc, ModifierLoc, ColonLoc, EndLoc, Modifier,\n      RD.Vars, ReductionIdScopeSpec.getWithLocInContext(Context), ReductionId,\n      RD.Privates, RD.LHSs, RD.RHSs, RD.ReductionOps, RD.InscanCopyOps,\n      RD.InscanCopyArrayTemps, RD.InscanCopyArrayElems,\n      buildPreInits(Context, RD.ExprCaptures),\n      buildPostUpdate(*this, RD.ExprPostUpdates));\n}\n\nOMPClause *Sema::ActOnOpenMPTaskReductionClause(\n    ArrayRef<Expr *> VarList, SourceLocation StartLoc, SourceLocation LParenLoc,\n    SourceLocation ColonLoc, SourceLocation EndLoc,\n    CXXScopeSpec &ReductionIdScopeSpec, const DeclarationNameInfo &ReductionId,\n    ArrayRef<Expr *> UnresolvedReductions) {\n  ReductionData RD(VarList.size());\n  if (actOnOMPReductionKindClause(*this, DSAStack, OMPC_task_reduction, VarList,\n                                  StartLoc, LParenLoc, ColonLoc, EndLoc,\n                                  ReductionIdScopeSpec, ReductionId,\n                                  UnresolvedReductions, RD))\n    return nullptr;\n\n  return OMPTaskReductionClause::Create(\n      Context, StartLoc, LParenLoc, ColonLoc, EndLoc, RD.Vars,\n      ReductionIdScopeSpec.getWithLocInContext(Context), ReductionId,\n      RD.Privates, RD.LHSs, RD.RHSs, RD.ReductionOps,\n      buildPreInits(Context, RD.ExprCaptures),\n      buildPostUpdate(*this, RD.ExprPostUpdates));\n}\n\nOMPClause *Sema::ActOnOpenMPInReductionClause(\n    ArrayRef<Expr *> VarList, SourceLocation StartLoc, SourceLocation LParenLoc,\n    SourceLocation ColonLoc, SourceLocation EndLoc,\n    CXXScopeSpec &ReductionIdScopeSpec, const DeclarationNameInfo &ReductionId,\n    ArrayRef<Expr *> UnresolvedReductions) {\n  ReductionData RD(VarList.size());\n  if (actOnOMPReductionKindClause(*this, DSAStack, OMPC_in_reduction, VarList,\n                                  StartLoc, LParenLoc, ColonLoc, EndLoc,\n                                  ReductionIdScopeSpec, ReductionId,\n                                  UnresolvedReductions, RD))\n    return nullptr;\n\n  return OMPInReductionClause::Create(\n      Context, StartLoc, LParenLoc, ColonLoc, EndLoc, RD.Vars,\n      ReductionIdScopeSpec.getWithLocInContext(Context), ReductionId,\n      RD.Privates, RD.LHSs, RD.RHSs, RD.ReductionOps, RD.TaskgroupDescriptors,\n      buildPreInits(Context, RD.ExprCaptures),\n      buildPostUpdate(*this, RD.ExprPostUpdates));\n}\n\nbool Sema::CheckOpenMPLinearModifier(OpenMPLinearClauseKind LinKind,\n                                     SourceLocation LinLoc) {\n  if ((!LangOpts.CPlusPlus && LinKind != OMPC_LINEAR_val) ||\n      LinKind == OMPC_LINEAR_unknown) {\n    Diag(LinLoc, diag::err_omp_wrong_linear_modifier) << LangOpts.CPlusPlus;\n    return true;\n  }\n  return false;\n}\n\nbool Sema::CheckOpenMPLinearDecl(const ValueDecl *D, SourceLocation ELoc,\n                                 OpenMPLinearClauseKind LinKind, QualType Type,\n                                 bool IsDeclareSimd) {\n  const auto *VD = dyn_cast_or_null<VarDecl>(D);\n  // A variable must not have an incomplete type or a reference type.\n  if (RequireCompleteType(ELoc, Type, diag::err_omp_linear_incomplete_type))\n    return true;\n  if ((LinKind == OMPC_LINEAR_uval || LinKind == OMPC_LINEAR_ref) &&\n      !Type->isReferenceType()) {\n    Diag(ELoc, diag::err_omp_wrong_linear_modifier_non_reference)\n        << Type << getOpenMPSimpleClauseTypeName(OMPC_linear, LinKind);\n    return true;\n  }\n  Type = Type.getNonReferenceType();\n\n  // OpenMP 5.0 [2.19.3, List Item Privatization, Restrictions]\n  // A variable that is privatized must not have a const-qualified type\n  // unless it is of class type with a mutable member. This restriction does\n  // not apply to the firstprivate clause, nor to the linear clause on\n  // declarative directives (like declare simd).\n  if (!IsDeclareSimd &&\n      rejectConstNotMutableType(*this, D, Type, OMPC_linear, ELoc))\n    return true;\n\n  // A list item must be of integral or pointer type.\n  Type = Type.getUnqualifiedType().getCanonicalType();\n  const auto *Ty = Type.getTypePtrOrNull();\n  if (!Ty || (LinKind != OMPC_LINEAR_ref && !Ty->isDependentType() &&\n              !Ty->isIntegralType(Context) && !Ty->isPointerType())) {\n    Diag(ELoc, diag::err_omp_linear_expected_int_or_ptr) << Type;\n    if (D) {\n      bool IsDecl =\n          !VD ||\n          VD->isThisDeclarationADefinition(Context) == VarDecl::DeclarationOnly;\n      Diag(D->getLocation(),\n           IsDecl ? diag::note_previous_decl : diag::note_defined_here)\n          << D;\n    }\n    return true;\n  }\n  return false;\n}\n\nOMPClause *Sema::ActOnOpenMPLinearClause(\n    ArrayRef<Expr *> VarList, Expr *Step, SourceLocation StartLoc,\n    SourceLocation LParenLoc, OpenMPLinearClauseKind LinKind,\n    SourceLocation LinLoc, SourceLocation ColonLoc, SourceLocation EndLoc) {\n  SmallVector<Expr *, 8> Vars;\n  SmallVector<Expr *, 8> Privates;\n  SmallVector<Expr *, 8> Inits;\n  SmallVector<Decl *, 4> ExprCaptures;\n  SmallVector<Expr *, 4> ExprPostUpdates;\n  if (CheckOpenMPLinearModifier(LinKind, LinLoc))\n    LinKind = OMPC_LINEAR_val;\n  for (Expr *RefExpr : VarList) {\n    assert(RefExpr && \"NULL expr in OpenMP linear clause.\");\n    SourceLocation ELoc;\n    SourceRange ERange;\n    Expr *SimpleRefExpr = RefExpr;\n    auto Res = getPrivateItem(*this, SimpleRefExpr, ELoc, ERange);\n    if (Res.second) {\n      // It will be analyzed later.\n      Vars.push_back(RefExpr);\n      Privates.push_back(nullptr);\n      Inits.push_back(nullptr);\n    }\n    ValueDecl *D = Res.first;\n    if (!D)\n      continue;\n\n    QualType Type = D->getType();\n    auto *VD = dyn_cast<VarDecl>(D);\n\n    // OpenMP [2.14.3.7, linear clause]\n    //  A list-item cannot appear in more than one linear clause.\n    //  A list-item that appears in a linear clause cannot appear in any\n    //  other data-sharing attribute clause.\n    DSAStackTy::DSAVarData DVar = DSAStack->getTopDSA(D, /*FromParent=*/false);\n    if (DVar.RefExpr) {\n      Diag(ELoc, diag::err_omp_wrong_dsa) << getOpenMPClauseName(DVar.CKind)\n                                          << getOpenMPClauseName(OMPC_linear);\n      reportOriginalDsa(*this, DSAStack, D, DVar);\n      continue;\n    }\n\n    if (CheckOpenMPLinearDecl(D, ELoc, LinKind, Type))\n      continue;\n    Type = Type.getNonReferenceType().getUnqualifiedType().getCanonicalType();\n\n    // Build private copy of original var.\n    VarDecl *Private =\n        buildVarDecl(*this, ELoc, Type, D->getName(),\n                     D->hasAttrs() ? &D->getAttrs() : nullptr,\n                     VD ? cast<DeclRefExpr>(SimpleRefExpr) : nullptr);\n    DeclRefExpr *PrivateRef = buildDeclRefExpr(*this, Private, Type, ELoc);\n    // Build var to save initial value.\n    VarDecl *Init = buildVarDecl(*this, ELoc, Type, \".linear.start\");\n    Expr *InitExpr;\n    DeclRefExpr *Ref = nullptr;\n    if (!VD && !CurContext->isDependentContext()) {\n      Ref = buildCapture(*this, D, SimpleRefExpr, /*WithInit=*/false);\n      if (!isOpenMPCapturedDecl(D)) {\n        ExprCaptures.push_back(Ref->getDecl());\n        if (Ref->getDecl()->hasAttr<OMPCaptureNoInitAttr>()) {\n          ExprResult RefRes = DefaultLvalueConversion(Ref);\n          if (!RefRes.isUsable())\n            continue;\n          ExprResult PostUpdateRes =\n              BuildBinOp(DSAStack->getCurScope(), ELoc, BO_Assign,\n                         SimpleRefExpr, RefRes.get());\n          if (!PostUpdateRes.isUsable())\n            continue;\n          ExprPostUpdates.push_back(\n              IgnoredValueConversions(PostUpdateRes.get()).get());\n        }\n      }\n    }\n    if (LinKind == OMPC_LINEAR_uval)\n      InitExpr = VD ? VD->getInit() : SimpleRefExpr;\n    else\n      InitExpr = VD ? SimpleRefExpr : Ref;\n    AddInitializerToDecl(Init, DefaultLvalueConversion(InitExpr).get(),\n                         /*DirectInit=*/false);\n    DeclRefExpr *InitRef = buildDeclRefExpr(*this, Init, Type, ELoc);\n\n    DSAStack->addDSA(D, RefExpr->IgnoreParens(), OMPC_linear, Ref);\n    Vars.push_back((VD || CurContext->isDependentContext())\n                       ? RefExpr->IgnoreParens()\n                       : Ref);\n    Privates.push_back(PrivateRef);\n    Inits.push_back(InitRef);\n  }\n\n  if (Vars.empty())\n    return nullptr;\n\n  Expr *StepExpr = Step;\n  Expr *CalcStepExpr = nullptr;\n  if (Step && !Step->isValueDependent() && !Step->isTypeDependent() &&\n      !Step->isInstantiationDependent() &&\n      !Step->containsUnexpandedParameterPack()) {\n    SourceLocation StepLoc = Step->getBeginLoc();\n    ExprResult Val = PerformOpenMPImplicitIntegerConversion(StepLoc, Step);\n    if (Val.isInvalid())\n      return nullptr;\n    StepExpr = Val.get();\n\n    // Build var to save the step value.\n    VarDecl *SaveVar =\n        buildVarDecl(*this, StepLoc, StepExpr->getType(), \".linear.step\");\n    ExprResult SaveRef =\n        buildDeclRefExpr(*this, SaveVar, StepExpr->getType(), StepLoc);\n    ExprResult CalcStep =\n        BuildBinOp(CurScope, StepLoc, BO_Assign, SaveRef.get(), StepExpr);\n    CalcStep = ActOnFinishFullExpr(CalcStep.get(), /*DiscardedValue*/ false);\n\n    // Warn about zero linear step (it would be probably better specified as\n    // making corresponding variables 'const').\n    if (Optional<llvm::APSInt> Result =\n            StepExpr->getIntegerConstantExpr(Context)) {\n      if (!Result->isNegative() && !Result->isStrictlyPositive())\n        Diag(StepLoc, diag::warn_omp_linear_step_zero)\n            << Vars[0] << (Vars.size() > 1);\n    } else if (CalcStep.isUsable()) {\n      // Calculate the step beforehand instead of doing this on each iteration.\n      // (This is not used if the number of iterations may be kfold-ed).\n      CalcStepExpr = CalcStep.get();\n    }\n  }\n\n  return OMPLinearClause::Create(Context, StartLoc, LParenLoc, LinKind, LinLoc,\n                                 ColonLoc, EndLoc, Vars, Privates, Inits,\n                                 StepExpr, CalcStepExpr,\n                                 buildPreInits(Context, ExprCaptures),\n                                 buildPostUpdate(*this, ExprPostUpdates));\n}\n\nstatic bool FinishOpenMPLinearClause(OMPLinearClause &Clause, DeclRefExpr *IV,\n                                     Expr *NumIterations, Sema &SemaRef,\n                                     Scope *S, DSAStackTy *Stack) {\n  // Walk the vars and build update/final expressions for the CodeGen.\n  SmallVector<Expr *, 8> Updates;\n  SmallVector<Expr *, 8> Finals;\n  SmallVector<Expr *, 8> UsedExprs;\n  Expr *Step = Clause.getStep();\n  Expr *CalcStep = Clause.getCalcStep();\n  // OpenMP [2.14.3.7, linear clause]\n  // If linear-step is not specified it is assumed to be 1.\n  if (!Step)\n    Step = SemaRef.ActOnIntegerConstant(SourceLocation(), 1).get();\n  else if (CalcStep)\n    Step = cast<BinaryOperator>(CalcStep)->getLHS();\n  bool HasErrors = false;\n  auto CurInit = Clause.inits().begin();\n  auto CurPrivate = Clause.privates().begin();\n  OpenMPLinearClauseKind LinKind = Clause.getModifier();\n  for (Expr *RefExpr : Clause.varlists()) {\n    SourceLocation ELoc;\n    SourceRange ERange;\n    Expr *SimpleRefExpr = RefExpr;\n    auto Res = getPrivateItem(SemaRef, SimpleRefExpr, ELoc, ERange);\n    ValueDecl *D = Res.first;\n    if (Res.second || !D) {\n      Updates.push_back(nullptr);\n      Finals.push_back(nullptr);\n      HasErrors = true;\n      continue;\n    }\n    auto &&Info = Stack->isLoopControlVariable(D);\n    // OpenMP [2.15.11, distribute simd Construct]\n    // A list item may not appear in a linear clause, unless it is the loop\n    // iteration variable.\n    if (isOpenMPDistributeDirective(Stack->getCurrentDirective()) &&\n        isOpenMPSimdDirective(Stack->getCurrentDirective()) && !Info.first) {\n      SemaRef.Diag(ELoc,\n                   diag::err_omp_linear_distribute_var_non_loop_iteration);\n      Updates.push_back(nullptr);\n      Finals.push_back(nullptr);\n      HasErrors = true;\n      continue;\n    }\n    Expr *InitExpr = *CurInit;\n\n    // Build privatized reference to the current linear var.\n    auto *DE = cast<DeclRefExpr>(SimpleRefExpr);\n    Expr *CapturedRef;\n    if (LinKind == OMPC_LINEAR_uval)\n      CapturedRef = cast<VarDecl>(DE->getDecl())->getInit();\n    else\n      CapturedRef =\n          buildDeclRefExpr(SemaRef, cast<VarDecl>(DE->getDecl()),\n                           DE->getType().getUnqualifiedType(), DE->getExprLoc(),\n                           /*RefersToCapture=*/true);\n\n    // Build update: Var = InitExpr + IV * Step\n    ExprResult Update;\n    if (!Info.first)\n      Update = buildCounterUpdate(\n          SemaRef, S, RefExpr->getExprLoc(), *CurPrivate, InitExpr, IV, Step,\n          /*Subtract=*/false, /*IsNonRectangularLB=*/false);\n    else\n      Update = *CurPrivate;\n    Update = SemaRef.ActOnFinishFullExpr(Update.get(), DE->getBeginLoc(),\n                                         /*DiscardedValue*/ false);\n\n    // Build final: Var = InitExpr + NumIterations * Step\n    ExprResult Final;\n    if (!Info.first)\n      Final =\n          buildCounterUpdate(SemaRef, S, RefExpr->getExprLoc(), CapturedRef,\n                             InitExpr, NumIterations, Step, /*Subtract=*/false,\n                             /*IsNonRectangularLB=*/false);\n    else\n      Final = *CurPrivate;\n    Final = SemaRef.ActOnFinishFullExpr(Final.get(), DE->getBeginLoc(),\n                                        /*DiscardedValue*/ false);\n\n    if (!Update.isUsable() || !Final.isUsable()) {\n      Updates.push_back(nullptr);\n      Finals.push_back(nullptr);\n      UsedExprs.push_back(nullptr);\n      HasErrors = true;\n    } else {\n      Updates.push_back(Update.get());\n      Finals.push_back(Final.get());\n      if (!Info.first)\n        UsedExprs.push_back(SimpleRefExpr);\n    }\n    ++CurInit;\n    ++CurPrivate;\n  }\n  if (Expr *S = Clause.getStep())\n    UsedExprs.push_back(S);\n  // Fill the remaining part with the nullptr.\n  UsedExprs.append(Clause.varlist_size() + 1 - UsedExprs.size(), nullptr);\n  Clause.setUpdates(Updates);\n  Clause.setFinals(Finals);\n  Clause.setUsedExprs(UsedExprs);\n  return HasErrors;\n}\n\nOMPClause *Sema::ActOnOpenMPAlignedClause(\n    ArrayRef<Expr *> VarList, Expr *Alignment, SourceLocation StartLoc,\n    SourceLocation LParenLoc, SourceLocation ColonLoc, SourceLocation EndLoc) {\n  SmallVector<Expr *, 8> Vars;\n  for (Expr *RefExpr : VarList) {\n    assert(RefExpr && \"NULL expr in OpenMP linear clause.\");\n    SourceLocation ELoc;\n    SourceRange ERange;\n    Expr *SimpleRefExpr = RefExpr;\n    auto Res = getPrivateItem(*this, SimpleRefExpr, ELoc, ERange);\n    if (Res.second) {\n      // It will be analyzed later.\n      Vars.push_back(RefExpr);\n    }\n    ValueDecl *D = Res.first;\n    if (!D)\n      continue;\n\n    QualType QType = D->getType();\n    auto *VD = dyn_cast<VarDecl>(D);\n\n    // OpenMP  [2.8.1, simd construct, Restrictions]\n    // The type of list items appearing in the aligned clause must be\n    // array, pointer, reference to array, or reference to pointer.\n    QType = QType.getNonReferenceType().getUnqualifiedType().getCanonicalType();\n    const Type *Ty = QType.getTypePtrOrNull();\n    if (!Ty || (!Ty->isArrayType() && !Ty->isPointerType())) {\n      Diag(ELoc, diag::err_omp_aligned_expected_array_or_ptr)\n          << QType << getLangOpts().CPlusPlus << ERange;\n      bool IsDecl =\n          !VD ||\n          VD->isThisDeclarationADefinition(Context) == VarDecl::DeclarationOnly;\n      Diag(D->getLocation(),\n           IsDecl ? diag::note_previous_decl : diag::note_defined_here)\n          << D;\n      continue;\n    }\n\n    // OpenMP  [2.8.1, simd construct, Restrictions]\n    // A list-item cannot appear in more than one aligned clause.\n    if (const Expr *PrevRef = DSAStack->addUniqueAligned(D, SimpleRefExpr)) {\n      Diag(ELoc, diag::err_omp_used_in_clause_twice)\n          << 0 << getOpenMPClauseName(OMPC_aligned) << ERange;\n      Diag(PrevRef->getExprLoc(), diag::note_omp_explicit_dsa)\n          << getOpenMPClauseName(OMPC_aligned);\n      continue;\n    }\n\n    DeclRefExpr *Ref = nullptr;\n    if (!VD && isOpenMPCapturedDecl(D))\n      Ref = buildCapture(*this, D, SimpleRefExpr, /*WithInit=*/true);\n    Vars.push_back(DefaultFunctionArrayConversion(\n                       (VD || !Ref) ? RefExpr->IgnoreParens() : Ref)\n                       .get());\n  }\n\n  // OpenMP [2.8.1, simd construct, Description]\n  // The parameter of the aligned clause, alignment, must be a constant\n  // positive integer expression.\n  // If no optional parameter is specified, implementation-defined default\n  // alignments for SIMD instructions on the target platforms are assumed.\n  if (Alignment != nullptr) {\n    ExprResult AlignResult =\n        VerifyPositiveIntegerConstantInClause(Alignment, OMPC_aligned);\n    if (AlignResult.isInvalid())\n      return nullptr;\n    Alignment = AlignResult.get();\n  }\n  if (Vars.empty())\n    return nullptr;\n\n  return OMPAlignedClause::Create(Context, StartLoc, LParenLoc, ColonLoc,\n                                  EndLoc, Vars, Alignment);\n}\n\nOMPClause *Sema::ActOnOpenMPCopyinClause(ArrayRef<Expr *> VarList,\n                                         SourceLocation StartLoc,\n                                         SourceLocation LParenLoc,\n                                         SourceLocation EndLoc) {\n  SmallVector<Expr *, 8> Vars;\n  SmallVector<Expr *, 8> SrcExprs;\n  SmallVector<Expr *, 8> DstExprs;\n  SmallVector<Expr *, 8> AssignmentOps;\n  for (Expr *RefExpr : VarList) {\n    assert(RefExpr && \"NULL expr in OpenMP copyin clause.\");\n    if (isa<DependentScopeDeclRefExpr>(RefExpr)) {\n      // It will be analyzed later.\n      Vars.push_back(RefExpr);\n      SrcExprs.push_back(nullptr);\n      DstExprs.push_back(nullptr);\n      AssignmentOps.push_back(nullptr);\n      continue;\n    }\n\n    SourceLocation ELoc = RefExpr->getExprLoc();\n    // OpenMP [2.1, C/C++]\n    //  A list item is a variable name.\n    // OpenMP  [2.14.4.1, Restrictions, p.1]\n    //  A list item that appears in a copyin clause must be threadprivate.\n    auto *DE = dyn_cast<DeclRefExpr>(RefExpr);\n    if (!DE || !isa<VarDecl>(DE->getDecl())) {\n      Diag(ELoc, diag::err_omp_expected_var_name_member_expr)\n          << 0 << RefExpr->getSourceRange();\n      continue;\n    }\n\n    Decl *D = DE->getDecl();\n    auto *VD = cast<VarDecl>(D);\n\n    QualType Type = VD->getType();\n    if (Type->isDependentType() || Type->isInstantiationDependentType()) {\n      // It will be analyzed later.\n      Vars.push_back(DE);\n      SrcExprs.push_back(nullptr);\n      DstExprs.push_back(nullptr);\n      AssignmentOps.push_back(nullptr);\n      continue;\n    }\n\n    // OpenMP [2.14.4.1, Restrictions, C/C++, p.1]\n    //  A list item that appears in a copyin clause must be threadprivate.\n    if (!DSAStack->isThreadPrivate(VD)) {\n      Diag(ELoc, diag::err_omp_required_access)\n          << getOpenMPClauseName(OMPC_copyin)\n          << getOpenMPDirectiveName(OMPD_threadprivate);\n      continue;\n    }\n\n    // OpenMP [2.14.4.1, Restrictions, C/C++, p.2]\n    //  A variable of class type (or array thereof) that appears in a\n    //  copyin clause requires an accessible, unambiguous copy assignment\n    //  operator for the class type.\n    QualType ElemType = Context.getBaseElementType(Type).getNonReferenceType();\n    VarDecl *SrcVD =\n        buildVarDecl(*this, DE->getBeginLoc(), ElemType.getUnqualifiedType(),\n                     \".copyin.src\", VD->hasAttrs() ? &VD->getAttrs() : nullptr);\n    DeclRefExpr *PseudoSrcExpr = buildDeclRefExpr(\n        *this, SrcVD, ElemType.getUnqualifiedType(), DE->getExprLoc());\n    VarDecl *DstVD =\n        buildVarDecl(*this, DE->getBeginLoc(), ElemType, \".copyin.dst\",\n                     VD->hasAttrs() ? &VD->getAttrs() : nullptr);\n    DeclRefExpr *PseudoDstExpr =\n        buildDeclRefExpr(*this, DstVD, ElemType, DE->getExprLoc());\n    // For arrays generate assignment operation for single element and replace\n    // it by the original array element in CodeGen.\n    ExprResult AssignmentOp =\n        BuildBinOp(/*S=*/nullptr, DE->getExprLoc(), BO_Assign, PseudoDstExpr,\n                   PseudoSrcExpr);\n    if (AssignmentOp.isInvalid())\n      continue;\n    AssignmentOp = ActOnFinishFullExpr(AssignmentOp.get(), DE->getExprLoc(),\n                                       /*DiscardedValue*/ false);\n    if (AssignmentOp.isInvalid())\n      continue;\n\n    DSAStack->addDSA(VD, DE, OMPC_copyin);\n    Vars.push_back(DE);\n    SrcExprs.push_back(PseudoSrcExpr);\n    DstExprs.push_back(PseudoDstExpr);\n    AssignmentOps.push_back(AssignmentOp.get());\n  }\n\n  if (Vars.empty())\n    return nullptr;\n\n  return OMPCopyinClause::Create(Context, StartLoc, LParenLoc, EndLoc, Vars,\n                                 SrcExprs, DstExprs, AssignmentOps);\n}\n\nOMPClause *Sema::ActOnOpenMPCopyprivateClause(ArrayRef<Expr *> VarList,\n                                              SourceLocation StartLoc,\n                                              SourceLocation LParenLoc,\n                                              SourceLocation EndLoc) {\n  SmallVector<Expr *, 8> Vars;\n  SmallVector<Expr *, 8> SrcExprs;\n  SmallVector<Expr *, 8> DstExprs;\n  SmallVector<Expr *, 8> AssignmentOps;\n  for (Expr *RefExpr : VarList) {\n    assert(RefExpr && \"NULL expr in OpenMP linear clause.\");\n    SourceLocation ELoc;\n    SourceRange ERange;\n    Expr *SimpleRefExpr = RefExpr;\n    auto Res = getPrivateItem(*this, SimpleRefExpr, ELoc, ERange);\n    if (Res.second) {\n      // It will be analyzed later.\n      Vars.push_back(RefExpr);\n      SrcExprs.push_back(nullptr);\n      DstExprs.push_back(nullptr);\n      AssignmentOps.push_back(nullptr);\n    }\n    ValueDecl *D = Res.first;\n    if (!D)\n      continue;\n\n    QualType Type = D->getType();\n    auto *VD = dyn_cast<VarDecl>(D);\n\n    // OpenMP [2.14.4.2, Restrictions, p.2]\n    //  A list item that appears in a copyprivate clause may not appear in a\n    //  private or firstprivate clause on the single construct.\n    if (!VD || !DSAStack->isThreadPrivate(VD)) {\n      DSAStackTy::DSAVarData DVar =\n          DSAStack->getTopDSA(D, /*FromParent=*/false);\n      if (DVar.CKind != OMPC_unknown && DVar.CKind != OMPC_copyprivate &&\n          DVar.RefExpr) {\n        Diag(ELoc, diag::err_omp_wrong_dsa)\n            << getOpenMPClauseName(DVar.CKind)\n            << getOpenMPClauseName(OMPC_copyprivate);\n        reportOriginalDsa(*this, DSAStack, D, DVar);\n        continue;\n      }\n\n      // OpenMP [2.11.4.2, Restrictions, p.1]\n      //  All list items that appear in a copyprivate clause must be either\n      //  threadprivate or private in the enclosing context.\n      if (DVar.CKind == OMPC_unknown) {\n        DVar = DSAStack->getImplicitDSA(D, false);\n        if (DVar.CKind == OMPC_shared) {\n          Diag(ELoc, diag::err_omp_required_access)\n              << getOpenMPClauseName(OMPC_copyprivate)\n              << \"threadprivate or private in the enclosing context\";\n          reportOriginalDsa(*this, DSAStack, D, DVar);\n          continue;\n        }\n      }\n    }\n\n    // Variably modified types are not supported.\n    if (!Type->isAnyPointerType() && Type->isVariablyModifiedType()) {\n      Diag(ELoc, diag::err_omp_variably_modified_type_not_supported)\n          << getOpenMPClauseName(OMPC_copyprivate) << Type\n          << getOpenMPDirectiveName(DSAStack->getCurrentDirective());\n      bool IsDecl =\n          !VD ||\n          VD->isThisDeclarationADefinition(Context) == VarDecl::DeclarationOnly;\n      Diag(D->getLocation(),\n           IsDecl ? diag::note_previous_decl : diag::note_defined_here)\n          << D;\n      continue;\n    }\n\n    // OpenMP [2.14.4.1, Restrictions, C/C++, p.2]\n    //  A variable of class type (or array thereof) that appears in a\n    //  copyin clause requires an accessible, unambiguous copy assignment\n    //  operator for the class type.\n    Type = Context.getBaseElementType(Type.getNonReferenceType())\n               .getUnqualifiedType();\n    VarDecl *SrcVD =\n        buildVarDecl(*this, RefExpr->getBeginLoc(), Type, \".copyprivate.src\",\n                     D->hasAttrs() ? &D->getAttrs() : nullptr);\n    DeclRefExpr *PseudoSrcExpr = buildDeclRefExpr(*this, SrcVD, Type, ELoc);\n    VarDecl *DstVD =\n        buildVarDecl(*this, RefExpr->getBeginLoc(), Type, \".copyprivate.dst\",\n                     D->hasAttrs() ? &D->getAttrs() : nullptr);\n    DeclRefExpr *PseudoDstExpr = buildDeclRefExpr(*this, DstVD, Type, ELoc);\n    ExprResult AssignmentOp = BuildBinOp(\n        DSAStack->getCurScope(), ELoc, BO_Assign, PseudoDstExpr, PseudoSrcExpr);\n    if (AssignmentOp.isInvalid())\n      continue;\n    AssignmentOp =\n        ActOnFinishFullExpr(AssignmentOp.get(), ELoc, /*DiscardedValue*/ false);\n    if (AssignmentOp.isInvalid())\n      continue;\n\n    // No need to mark vars as copyprivate, they are already threadprivate or\n    // implicitly private.\n    assert(VD || isOpenMPCapturedDecl(D));\n    Vars.push_back(\n        VD ? RefExpr->IgnoreParens()\n           : buildCapture(*this, D, SimpleRefExpr, /*WithInit=*/false));\n    SrcExprs.push_back(PseudoSrcExpr);\n    DstExprs.push_back(PseudoDstExpr);\n    AssignmentOps.push_back(AssignmentOp.get());\n  }\n\n  if (Vars.empty())\n    return nullptr;\n\n  return OMPCopyprivateClause::Create(Context, StartLoc, LParenLoc, EndLoc,\n                                      Vars, SrcExprs, DstExprs, AssignmentOps);\n}\n\nOMPClause *Sema::ActOnOpenMPFlushClause(ArrayRef<Expr *> VarList,\n                                        SourceLocation StartLoc,\n                                        SourceLocation LParenLoc,\n                                        SourceLocation EndLoc) {\n  if (VarList.empty())\n    return nullptr;\n\n  return OMPFlushClause::Create(Context, StartLoc, LParenLoc, EndLoc, VarList);\n}\n\n/// Tries to find omp_depend_t. type.\nstatic bool findOMPDependT(Sema &S, SourceLocation Loc, DSAStackTy *Stack,\n                           bool Diagnose = true) {\n  QualType OMPDependT = Stack->getOMPDependT();\n  if (!OMPDependT.isNull())\n    return true;\n  IdentifierInfo *II = &S.PP.getIdentifierTable().get(\"omp_depend_t\");\n  ParsedType PT = S.getTypeName(*II, Loc, S.getCurScope());\n  if (!PT.getAsOpaquePtr() || PT.get().isNull()) {\n    if (Diagnose)\n      S.Diag(Loc, diag::err_omp_implied_type_not_found) << \"omp_depend_t\";\n    return false;\n  }\n  Stack->setOMPDependT(PT.get());\n  return true;\n}\n\nOMPClause *Sema::ActOnOpenMPDepobjClause(Expr *Depobj, SourceLocation StartLoc,\n                                         SourceLocation LParenLoc,\n                                         SourceLocation EndLoc) {\n  if (!Depobj)\n    return nullptr;\n\n  bool OMPDependTFound = findOMPDependT(*this, StartLoc, DSAStack);\n\n  // OpenMP 5.0, 2.17.10.1 depobj Construct\n  // depobj is an lvalue expression of type omp_depend_t.\n  if (!Depobj->isTypeDependent() && !Depobj->isValueDependent() &&\n      !Depobj->isInstantiationDependent() &&\n      !Depobj->containsUnexpandedParameterPack() &&\n      (OMPDependTFound &&\n       !Context.typesAreCompatible(DSAStack->getOMPDependT(), Depobj->getType(),\n                                   /*CompareUnqualified=*/true))) {\n    Diag(Depobj->getExprLoc(), diag::err_omp_expected_omp_depend_t_lvalue)\n        << 0 << Depobj->getType() << Depobj->getSourceRange();\n  }\n\n  if (!Depobj->isLValue()) {\n    Diag(Depobj->getExprLoc(), diag::err_omp_expected_omp_depend_t_lvalue)\n        << 1 << Depobj->getSourceRange();\n  }\n\n  return OMPDepobjClause::Create(Context, StartLoc, LParenLoc, EndLoc, Depobj);\n}\n\nOMPClause *\nSema::ActOnOpenMPDependClause(Expr *DepModifier, OpenMPDependClauseKind DepKind,\n                              SourceLocation DepLoc, SourceLocation ColonLoc,\n                              ArrayRef<Expr *> VarList, SourceLocation StartLoc,\n                              SourceLocation LParenLoc, SourceLocation EndLoc) {\n  if (DSAStack->getCurrentDirective() == OMPD_ordered &&\n      DepKind != OMPC_DEPEND_source && DepKind != OMPC_DEPEND_sink) {\n    Diag(DepLoc, diag::err_omp_unexpected_clause_value)\n        << \"'source' or 'sink'\" << getOpenMPClauseName(OMPC_depend);\n    return nullptr;\n  }\n  if ((DSAStack->getCurrentDirective() != OMPD_ordered ||\n       DSAStack->getCurrentDirective() == OMPD_depobj) &&\n      (DepKind == OMPC_DEPEND_unknown || DepKind == OMPC_DEPEND_source ||\n       DepKind == OMPC_DEPEND_sink ||\n       ((LangOpts.OpenMP < 50 ||\n         DSAStack->getCurrentDirective() == OMPD_depobj) &&\n        DepKind == OMPC_DEPEND_depobj))) {\n    SmallVector<unsigned, 3> Except;\n    Except.push_back(OMPC_DEPEND_source);\n    Except.push_back(OMPC_DEPEND_sink);\n    if (LangOpts.OpenMP < 50 || DSAStack->getCurrentDirective() == OMPD_depobj)\n      Except.push_back(OMPC_DEPEND_depobj);\n    std::string Expected = (LangOpts.OpenMP >= 50 && !DepModifier)\n                               ? \"depend modifier(iterator) or \"\n                               : \"\";\n    Diag(DepLoc, diag::err_omp_unexpected_clause_value)\n        << Expected + getListOfPossibleValues(OMPC_depend, /*First=*/0,\n                                              /*Last=*/OMPC_DEPEND_unknown,\n                                              Except)\n        << getOpenMPClauseName(OMPC_depend);\n    return nullptr;\n  }\n  if (DepModifier &&\n      (DepKind == OMPC_DEPEND_source || DepKind == OMPC_DEPEND_sink)) {\n    Diag(DepModifier->getExprLoc(),\n         diag::err_omp_depend_sink_source_with_modifier);\n    return nullptr;\n  }\n  if (DepModifier &&\n      !DepModifier->getType()->isSpecificBuiltinType(BuiltinType::OMPIterator))\n    Diag(DepModifier->getExprLoc(), diag::err_omp_depend_modifier_not_iterator);\n\n  SmallVector<Expr *, 8> Vars;\n  DSAStackTy::OperatorOffsetTy OpsOffs;\n  llvm::APSInt DepCounter(/*BitWidth=*/32);\n  llvm::APSInt TotalDepCount(/*BitWidth=*/32);\n  if (DepKind == OMPC_DEPEND_sink || DepKind == OMPC_DEPEND_source) {\n    if (const Expr *OrderedCountExpr =\n            DSAStack->getParentOrderedRegionParam().first) {\n      TotalDepCount = OrderedCountExpr->EvaluateKnownConstInt(Context);\n      TotalDepCount.setIsUnsigned(/*Val=*/true);\n    }\n  }\n  for (Expr *RefExpr : VarList) {\n    assert(RefExpr && \"NULL expr in OpenMP shared clause.\");\n    if (isa<DependentScopeDeclRefExpr>(RefExpr)) {\n      // It will be analyzed later.\n      Vars.push_back(RefExpr);\n      continue;\n    }\n\n    SourceLocation ELoc = RefExpr->getExprLoc();\n    Expr *SimpleExpr = RefExpr->IgnoreParenCasts();\n    if (DepKind == OMPC_DEPEND_sink) {\n      if (DSAStack->getParentOrderedRegionParam().first &&\n          DepCounter >= TotalDepCount) {\n        Diag(ELoc, diag::err_omp_depend_sink_unexpected_expr);\n        continue;\n      }\n      ++DepCounter;\n      // OpenMP  [2.13.9, Summary]\n      // depend(dependence-type : vec), where dependence-type is:\n      // 'sink' and where vec is the iteration vector, which has the form:\n      //  x1 [+- d1], x2 [+- d2 ], . . . , xn [+- dn]\n      // where n is the value specified by the ordered clause in the loop\n      // directive, xi denotes the loop iteration variable of the i-th nested\n      // loop associated with the loop directive, and di is a constant\n      // non-negative integer.\n      if (CurContext->isDependentContext()) {\n        // It will be analyzed later.\n        Vars.push_back(RefExpr);\n        continue;\n      }\n      SimpleExpr = SimpleExpr->IgnoreImplicit();\n      OverloadedOperatorKind OOK = OO_None;\n      SourceLocation OOLoc;\n      Expr *LHS = SimpleExpr;\n      Expr *RHS = nullptr;\n      if (auto *BO = dyn_cast<BinaryOperator>(SimpleExpr)) {\n        OOK = BinaryOperator::getOverloadedOperator(BO->getOpcode());\n        OOLoc = BO->getOperatorLoc();\n        LHS = BO->getLHS()->IgnoreParenImpCasts();\n        RHS = BO->getRHS()->IgnoreParenImpCasts();\n      } else if (auto *OCE = dyn_cast<CXXOperatorCallExpr>(SimpleExpr)) {\n        OOK = OCE->getOperator();\n        OOLoc = OCE->getOperatorLoc();\n        LHS = OCE->getArg(/*Arg=*/0)->IgnoreParenImpCasts();\n        RHS = OCE->getArg(/*Arg=*/1)->IgnoreParenImpCasts();\n      } else if (auto *MCE = dyn_cast<CXXMemberCallExpr>(SimpleExpr)) {\n        OOK = MCE->getMethodDecl()\n                  ->getNameInfo()\n                  .getName()\n                  .getCXXOverloadedOperator();\n        OOLoc = MCE->getCallee()->getExprLoc();\n        LHS = MCE->getImplicitObjectArgument()->IgnoreParenImpCasts();\n        RHS = MCE->getArg(/*Arg=*/0)->IgnoreParenImpCasts();\n      }\n      SourceLocation ELoc;\n      SourceRange ERange;\n      auto Res = getPrivateItem(*this, LHS, ELoc, ERange);\n      if (Res.second) {\n        // It will be analyzed later.\n        Vars.push_back(RefExpr);\n      }\n      ValueDecl *D = Res.first;\n      if (!D)\n        continue;\n\n      if (OOK != OO_Plus && OOK != OO_Minus && (RHS || OOK != OO_None)) {\n        Diag(OOLoc, diag::err_omp_depend_sink_expected_plus_minus);\n        continue;\n      }\n      if (RHS) {\n        ExprResult RHSRes = VerifyPositiveIntegerConstantInClause(\n            RHS, OMPC_depend, /*StrictlyPositive=*/false);\n        if (RHSRes.isInvalid())\n          continue;\n      }\n      if (!CurContext->isDependentContext() &&\n          DSAStack->getParentOrderedRegionParam().first &&\n          DepCounter != DSAStack->isParentLoopControlVariable(D).first) {\n        const ValueDecl *VD =\n            DSAStack->getParentLoopControlVariable(DepCounter.getZExtValue());\n        if (VD)\n          Diag(ELoc, diag::err_omp_depend_sink_expected_loop_iteration)\n              << 1 << VD;\n        else\n          Diag(ELoc, diag::err_omp_depend_sink_expected_loop_iteration) << 0;\n        continue;\n      }\n      OpsOffs.emplace_back(RHS, OOK);\n    } else {\n      bool OMPDependTFound = LangOpts.OpenMP >= 50;\n      if (OMPDependTFound)\n        OMPDependTFound = findOMPDependT(*this, StartLoc, DSAStack,\n                                         DepKind == OMPC_DEPEND_depobj);\n      if (DepKind == OMPC_DEPEND_depobj) {\n        // OpenMP 5.0, 2.17.11 depend Clause, Restrictions, C/C++\n        // List items used in depend clauses with the depobj dependence type\n        // must be expressions of the omp_depend_t type.\n        if (!RefExpr->isValueDependent() && !RefExpr->isTypeDependent() &&\n            !RefExpr->isInstantiationDependent() &&\n            !RefExpr->containsUnexpandedParameterPack() &&\n            (OMPDependTFound &&\n             !Context.hasSameUnqualifiedType(DSAStack->getOMPDependT(),\n                                             RefExpr->getType()))) {\n          Diag(ELoc, diag::err_omp_expected_omp_depend_t_lvalue)\n              << 0 << RefExpr->getType() << RefExpr->getSourceRange();\n          continue;\n        }\n        if (!RefExpr->isLValue()) {\n          Diag(ELoc, diag::err_omp_expected_omp_depend_t_lvalue)\n              << 1 << RefExpr->getType() << RefExpr->getSourceRange();\n          continue;\n        }\n      } else {\n        // OpenMP 5.0 [2.17.11, Restrictions]\n        // List items used in depend clauses cannot be zero-length array\n        // sections.\n        QualType ExprTy = RefExpr->getType().getNonReferenceType();\n        const auto *OASE = dyn_cast<OMPArraySectionExpr>(SimpleExpr);\n        if (OASE) {\n          QualType BaseType =\n              OMPArraySectionExpr::getBaseOriginalType(OASE->getBase());\n          if (const auto *ATy = BaseType->getAsArrayTypeUnsafe())\n            ExprTy = ATy->getElementType();\n          else\n            ExprTy = BaseType->getPointeeType();\n          ExprTy = ExprTy.getNonReferenceType();\n          const Expr *Length = OASE->getLength();\n          Expr::EvalResult Result;\n          if (Length && !Length->isValueDependent() &&\n              Length->EvaluateAsInt(Result, Context) &&\n              Result.Val.getInt().isNullValue()) {\n            Diag(ELoc,\n                 diag::err_omp_depend_zero_length_array_section_not_allowed)\n                << SimpleExpr->getSourceRange();\n            continue;\n          }\n        }\n\n        // OpenMP 5.0, 2.17.11 depend Clause, Restrictions, C/C++\n        // List items used in depend clauses with the in, out, inout or\n        // mutexinoutset dependence types cannot be expressions of the\n        // omp_depend_t type.\n        if (!RefExpr->isValueDependent() && !RefExpr->isTypeDependent() &&\n            !RefExpr->isInstantiationDependent() &&\n            !RefExpr->containsUnexpandedParameterPack() &&\n            (OMPDependTFound &&\n             DSAStack->getOMPDependT().getTypePtr() == ExprTy.getTypePtr())) {\n          Diag(ELoc, diag::err_omp_expected_addressable_lvalue_or_array_item)\n              << (LangOpts.OpenMP >= 50 ? 1 : 0) << 1\n              << RefExpr->getSourceRange();\n          continue;\n        }\n\n        auto *ASE = dyn_cast<ArraySubscriptExpr>(SimpleExpr);\n        if (!RefExpr->IgnoreParenImpCasts()->isLValue() ||\n            (ASE && !ASE->getBase()->isTypeDependent() &&\n             !ASE->getBase()\n                  ->getType()\n                  .getNonReferenceType()\n                  ->isPointerType() &&\n             !ASE->getBase()->getType().getNonReferenceType()->isArrayType())) {\n          Diag(ELoc, diag::err_omp_expected_addressable_lvalue_or_array_item)\n              << (LangOpts.OpenMP >= 50 ? 1 : 0)\n              << (LangOpts.OpenMP >= 50 ? 1 : 0) << RefExpr->getSourceRange();\n          continue;\n        }\n\n        ExprResult Res;\n        {\n          Sema::TentativeAnalysisScope Trap(*this);\n          Res = CreateBuiltinUnaryOp(ELoc, UO_AddrOf,\n                                     RefExpr->IgnoreParenImpCasts());\n        }\n        if (!Res.isUsable() && !isa<OMPArraySectionExpr>(SimpleExpr) &&\n            !isa<OMPArrayShapingExpr>(SimpleExpr)) {\n          Diag(ELoc, diag::err_omp_expected_addressable_lvalue_or_array_item)\n              << (LangOpts.OpenMP >= 50 ? 1 : 0)\n              << (LangOpts.OpenMP >= 50 ? 1 : 0) << RefExpr->getSourceRange();\n          continue;\n        }\n      }\n    }\n    Vars.push_back(RefExpr->IgnoreParenImpCasts());\n  }\n\n  if (!CurContext->isDependentContext() && DepKind == OMPC_DEPEND_sink &&\n      TotalDepCount > VarList.size() &&\n      DSAStack->getParentOrderedRegionParam().first &&\n      DSAStack->getParentLoopControlVariable(VarList.size() + 1)) {\n    Diag(EndLoc, diag::err_omp_depend_sink_expected_loop_iteration)\n        << 1 << DSAStack->getParentLoopControlVariable(VarList.size() + 1);\n  }\n  if (DepKind != OMPC_DEPEND_source && DepKind != OMPC_DEPEND_sink &&\n      Vars.empty())\n    return nullptr;\n\n  auto *C = OMPDependClause::Create(Context, StartLoc, LParenLoc, EndLoc,\n                                    DepModifier, DepKind, DepLoc, ColonLoc,\n                                    Vars, TotalDepCount.getZExtValue());\n  if ((DepKind == OMPC_DEPEND_sink || DepKind == OMPC_DEPEND_source) &&\n      DSAStack->isParentOrderedRegion())\n    DSAStack->addDoacrossDependClause(C, OpsOffs);\n  return C;\n}\n\nOMPClause *Sema::ActOnOpenMPDeviceClause(OpenMPDeviceClauseModifier Modifier,\n                                         Expr *Device, SourceLocation StartLoc,\n                                         SourceLocation LParenLoc,\n                                         SourceLocation ModifierLoc,\n                                         SourceLocation EndLoc) {\n  assert((ModifierLoc.isInvalid() || LangOpts.OpenMP >= 50) &&\n         \"Unexpected device modifier in OpenMP < 50.\");\n\n  bool ErrorFound = false;\n  if (ModifierLoc.isValid() && Modifier == OMPC_DEVICE_unknown) {\n    std::string Values =\n        getListOfPossibleValues(OMPC_device, /*First=*/0, OMPC_DEVICE_unknown);\n    Diag(ModifierLoc, diag::err_omp_unexpected_clause_value)\n        << Values << getOpenMPClauseName(OMPC_device);\n    ErrorFound = true;\n  }\n\n  Expr *ValExpr = Device;\n  Stmt *HelperValStmt = nullptr;\n\n  // OpenMP [2.9.1, Restrictions]\n  // The device expression must evaluate to a non-negative integer value.\n  ErrorFound = !isNonNegativeIntegerValue(ValExpr, *this, OMPC_device,\n                                          /*StrictlyPositive=*/false) ||\n               ErrorFound;\n  if (ErrorFound)\n    return nullptr;\n\n  OpenMPDirectiveKind DKind = DSAStack->getCurrentDirective();\n  OpenMPDirectiveKind CaptureRegion =\n      getOpenMPCaptureRegionForClause(DKind, OMPC_device, LangOpts.OpenMP);\n  if (CaptureRegion != OMPD_unknown && !CurContext->isDependentContext()) {\n    ValExpr = MakeFullExpr(ValExpr).get();\n    llvm::MapVector<const Expr *, DeclRefExpr *> Captures;\n    ValExpr = tryBuildCapture(*this, ValExpr, Captures).get();\n    HelperValStmt = buildPreInits(Context, Captures);\n  }\n\n  return new (Context)\n      OMPDeviceClause(Modifier, ValExpr, HelperValStmt, CaptureRegion, StartLoc,\n                      LParenLoc, ModifierLoc, EndLoc);\n}\n\nstatic bool checkTypeMappable(SourceLocation SL, SourceRange SR, Sema &SemaRef,\n                              DSAStackTy *Stack, QualType QTy,\n                              bool FullCheck = true) {\n  NamedDecl *ND;\n  if (QTy->isIncompleteType(&ND)) {\n    SemaRef.Diag(SL, diag::err_incomplete_type) << QTy << SR;\n    return false;\n  }\n  if (FullCheck && !SemaRef.CurContext->isDependentContext() &&\n      !QTy.isTriviallyCopyableType(SemaRef.Context))\n    SemaRef.Diag(SL, diag::warn_omp_non_trivial_type_mapped) << QTy << SR;\n  return true;\n}\n\n/// Return true if it can be proven that the provided array expression\n/// (array section or array subscript) does NOT specify the whole size of the\n/// array whose base type is \\a BaseQTy.\nstatic bool checkArrayExpressionDoesNotReferToWholeSize(Sema &SemaRef,\n                                                        const Expr *E,\n                                                        QualType BaseQTy) {\n  const auto *OASE = dyn_cast<OMPArraySectionExpr>(E);\n\n  // If this is an array subscript, it refers to the whole size if the size of\n  // the dimension is constant and equals 1. Also, an array section assumes the\n  // format of an array subscript if no colon is used.\n  if (isa<ArraySubscriptExpr>(E) ||\n      (OASE && OASE->getColonLocFirst().isInvalid())) {\n    if (const auto *ATy = dyn_cast<ConstantArrayType>(BaseQTy.getTypePtr()))\n      return ATy->getSize().getSExtValue() != 1;\n    // Size can't be evaluated statically.\n    return false;\n  }\n\n  assert(OASE && \"Expecting array section if not an array subscript.\");\n  const Expr *LowerBound = OASE->getLowerBound();\n  const Expr *Length = OASE->getLength();\n\n  // If there is a lower bound that does not evaluates to zero, we are not\n  // covering the whole dimension.\n  if (LowerBound) {\n    Expr::EvalResult Result;\n    if (!LowerBound->EvaluateAsInt(Result, SemaRef.getASTContext()))\n      return false; // Can't get the integer value as a constant.\n\n    llvm::APSInt ConstLowerBound = Result.Val.getInt();\n    if (ConstLowerBound.getSExtValue())\n      return true;\n  }\n\n  // If we don't have a length we covering the whole dimension.\n  if (!Length)\n    return false;\n\n  // If the base is a pointer, we don't have a way to get the size of the\n  // pointee.\n  if (BaseQTy->isPointerType())\n    return false;\n\n  // We can only check if the length is the same as the size of the dimension\n  // if we have a constant array.\n  const auto *CATy = dyn_cast<ConstantArrayType>(BaseQTy.getTypePtr());\n  if (!CATy)\n    return false;\n\n  Expr::EvalResult Result;\n  if (!Length->EvaluateAsInt(Result, SemaRef.getASTContext()))\n    return false; // Can't get the integer value as a constant.\n\n  llvm::APSInt ConstLength = Result.Val.getInt();\n  return CATy->getSize().getSExtValue() != ConstLength.getSExtValue();\n}\n\n// Return true if it can be proven that the provided array expression (array\n// section or array subscript) does NOT specify a single element of the array\n// whose base type is \\a BaseQTy.\nstatic bool checkArrayExpressionDoesNotReferToUnitySize(Sema &SemaRef,\n                                                        const Expr *E,\n                                                        QualType BaseQTy) {\n  const auto *OASE = dyn_cast<OMPArraySectionExpr>(E);\n\n  // An array subscript always refer to a single element. Also, an array section\n  // assumes the format of an array subscript if no colon is used.\n  if (isa<ArraySubscriptExpr>(E) ||\n      (OASE && OASE->getColonLocFirst().isInvalid()))\n    return false;\n\n  assert(OASE && \"Expecting array section if not an array subscript.\");\n  const Expr *Length = OASE->getLength();\n\n  // If we don't have a length we have to check if the array has unitary size\n  // for this dimension. Also, we should always expect a length if the base type\n  // is pointer.\n  if (!Length) {\n    if (const auto *ATy = dyn_cast<ConstantArrayType>(BaseQTy.getTypePtr()))\n      return ATy->getSize().getSExtValue() != 1;\n    // We cannot assume anything.\n    return false;\n  }\n\n  // Check if the length evaluates to 1.\n  Expr::EvalResult Result;\n  if (!Length->EvaluateAsInt(Result, SemaRef.getASTContext()))\n    return false; // Can't get the integer value as a constant.\n\n  llvm::APSInt ConstLength = Result.Val.getInt();\n  return ConstLength.getSExtValue() != 1;\n}\n\n// The base of elements of list in a map clause have to be either:\n//  - a reference to variable or field.\n//  - a member expression.\n//  - an array expression.\n//\n// E.g. if we have the expression 'r.S.Arr[:12]', we want to retrieve the\n// reference to 'r'.\n//\n// If we have:\n//\n// struct SS {\n//   Bla S;\n//   foo() {\n//     #pragma omp target map (S.Arr[:12]);\n//   }\n// }\n//\n// We want to retrieve the member expression 'this->S';\n\n// OpenMP 5.0 [2.19.7.1, map Clause, Restrictions, p.2]\n//  If a list item is an array section, it must specify contiguous storage.\n//\n// For this restriction it is sufficient that we make sure only references\n// to variables or fields and array expressions, and that no array sections\n// exist except in the rightmost expression (unless they cover the whole\n// dimension of the array). E.g. these would be invalid:\n//\n//   r.ArrS[3:5].Arr[6:7]\n//\n//   r.ArrS[3:5].x\n//\n// but these would be valid:\n//   r.ArrS[3].Arr[6:7]\n//\n//   r.ArrS[3].x\nnamespace {\nclass MapBaseChecker final : public StmtVisitor<MapBaseChecker, bool> {\n  Sema &SemaRef;\n  OpenMPClauseKind CKind = OMPC_unknown;\n  OpenMPDirectiveKind DKind = OMPD_unknown;\n  OMPClauseMappableExprCommon::MappableExprComponentList &Components;\n  bool IsNonContiguous = false;\n  bool NoDiagnose = false;\n  const Expr *RelevantExpr = nullptr;\n  bool AllowUnitySizeArraySection = true;\n  bool AllowWholeSizeArraySection = true;\n  bool AllowAnotherPtr = true;\n  SourceLocation ELoc;\n  SourceRange ERange;\n\n  void emitErrorMsg() {\n    // If nothing else worked, this is not a valid map clause expression.\n    if (SemaRef.getLangOpts().OpenMP < 50) {\n      SemaRef.Diag(ELoc,\n                   diag::err_omp_expected_named_var_member_or_array_expression)\n          << ERange;\n    } else {\n      SemaRef.Diag(ELoc, diag::err_omp_non_lvalue_in_map_or_motion_clauses)\n          << getOpenMPClauseName(CKind) << ERange;\n    }\n  }\n\npublic:\n  bool VisitDeclRefExpr(DeclRefExpr *DRE) {\n    if (!isa<VarDecl>(DRE->getDecl())) {\n      emitErrorMsg();\n      return false;\n    }\n    assert(!RelevantExpr && \"RelevantExpr is expected to be nullptr\");\n    RelevantExpr = DRE;\n    // Record the component.\n    Components.emplace_back(DRE, DRE->getDecl(), IsNonContiguous);\n    return true;\n  }\n\n  bool VisitMemberExpr(MemberExpr *ME) {\n    Expr *E = ME;\n    Expr *BaseE = ME->getBase()->IgnoreParenCasts();\n\n    if (isa<CXXThisExpr>(BaseE)) {\n      assert(!RelevantExpr && \"RelevantExpr is expected to be nullptr\");\n      // We found a base expression: this->Val.\n      RelevantExpr = ME;\n    } else {\n      E = BaseE;\n    }\n\n    if (!isa<FieldDecl>(ME->getMemberDecl())) {\n      if (!NoDiagnose) {\n        SemaRef.Diag(ELoc, diag::err_omp_expected_access_to_data_field)\n          << ME->getSourceRange();\n        return false;\n      }\n      if (RelevantExpr)\n        return false;\n      return Visit(E);\n    }\n\n    auto *FD = cast<FieldDecl>(ME->getMemberDecl());\n\n    // OpenMP 4.5 [2.15.5.1, map Clause, Restrictions, C/C++, p.3]\n    //  A bit-field cannot appear in a map clause.\n    //\n    if (FD->isBitField()) {\n      if (!NoDiagnose) {\n        SemaRef.Diag(ELoc, diag::err_omp_bit_fields_forbidden_in_clause)\n          << ME->getSourceRange() << getOpenMPClauseName(CKind);\n        return false;\n      }\n      if (RelevantExpr)\n        return false;\n      return Visit(E);\n    }\n\n    // OpenMP 4.5 [2.15.5.1, map Clause, Restrictions, C++, p.1]\n    //  If the type of a list item is a reference to a type T then the type\n    //  will be considered to be T for all purposes of this clause.\n    QualType CurType = BaseE->getType().getNonReferenceType();\n\n    // OpenMP 4.5 [2.15.5.1, map Clause, Restrictions, C/C++, p.2]\n    //  A list item cannot be a variable that is a member of a structure with\n    //  a union type.\n    //\n    if (CurType->isUnionType()) {\n      if (!NoDiagnose) {\n        SemaRef.Diag(ELoc, diag::err_omp_union_type_not_allowed)\n          << ME->getSourceRange();\n        return false;\n      }\n      return RelevantExpr || Visit(E);\n    }\n\n    // If we got a member expression, we should not expect any array section\n    // before that:\n    //\n    // OpenMP 4.5 [2.15.5.1, map Clause, Restrictions, p.7]\n    //  If a list item is an element of a structure, only the rightmost symbol\n    //  of the variable reference can be an array section.\n    //\n    AllowUnitySizeArraySection = false;\n    AllowWholeSizeArraySection = false;\n\n    // Record the component.\n    Components.emplace_back(ME, FD, IsNonContiguous);\n    return RelevantExpr || Visit(E);\n  }\n\n  bool VisitArraySubscriptExpr(ArraySubscriptExpr *AE) {\n    Expr *E = AE->getBase()->IgnoreParenImpCasts();\n\n    if (!E->getType()->isAnyPointerType() && !E->getType()->isArrayType()) {\n      if (!NoDiagnose) {\n        SemaRef.Diag(ELoc, diag::err_omp_expected_base_var_name)\n          << 0 << AE->getSourceRange();\n        return false;\n      }\n      return RelevantExpr || Visit(E);\n    }\n\n    // If we got an array subscript that express the whole dimension we\n    // can have any array expressions before. If it only expressing part of\n    // the dimension, we can only have unitary-size array expressions.\n    if (checkArrayExpressionDoesNotReferToWholeSize(SemaRef, AE,\n                                                    E->getType()))\n      AllowWholeSizeArraySection = false;\n\n    if (const auto *TE = dyn_cast<CXXThisExpr>(E->IgnoreParenCasts())) {\n      Expr::EvalResult Result;\n      if (!AE->getIdx()->isValueDependent() &&\n          AE->getIdx()->EvaluateAsInt(Result, SemaRef.getASTContext()) &&\n          !Result.Val.getInt().isNullValue()) {\n        SemaRef.Diag(AE->getIdx()->getExprLoc(),\n                     diag::err_omp_invalid_map_this_expr);\n        SemaRef.Diag(AE->getIdx()->getExprLoc(),\n                     diag::note_omp_invalid_subscript_on_this_ptr_map);\n      }\n      assert(!RelevantExpr && \"RelevantExpr is expected to be nullptr\");\n      RelevantExpr = TE;\n    }\n\n    // Record the component - we don't have any declaration associated.\n    Components.emplace_back(AE, nullptr, IsNonContiguous);\n\n    return RelevantExpr || Visit(E);\n  }\n\n  bool VisitOMPArraySectionExpr(OMPArraySectionExpr *OASE) {\n    assert(!NoDiagnose && \"Array sections cannot be implicitly mapped.\");\n    Expr *E = OASE->getBase()->IgnoreParenImpCasts();\n    QualType CurType =\n      OMPArraySectionExpr::getBaseOriginalType(E).getCanonicalType();\n\n    // OpenMP 4.5 [2.15.5.1, map Clause, Restrictions, C++, p.1]\n    //  If the type of a list item is a reference to a type T then the type\n    //  will be considered to be T for all purposes of this clause.\n    if (CurType->isReferenceType())\n      CurType = CurType->getPointeeType();\n\n    bool IsPointer = CurType->isAnyPointerType();\n\n    if (!IsPointer && !CurType->isArrayType()) {\n      SemaRef.Diag(ELoc, diag::err_omp_expected_base_var_name)\n        << 0 << OASE->getSourceRange();\n      return false;\n    }\n\n    bool NotWhole =\n      checkArrayExpressionDoesNotReferToWholeSize(SemaRef, OASE, CurType);\n    bool NotUnity =\n      checkArrayExpressionDoesNotReferToUnitySize(SemaRef, OASE, CurType);\n\n    if (AllowWholeSizeArraySection) {\n      // Any array section is currently allowed. Allowing a whole size array\n      // section implies allowing a unity array section as well.\n      //\n      // If this array section refers to the whole dimension we can still\n      // accept other array sections before this one, except if the base is a\n      // pointer. Otherwise, only unitary sections are accepted.\n      if (NotWhole || IsPointer)\n        AllowWholeSizeArraySection = false;\n    } else if (DKind == OMPD_target_update &&\n               SemaRef.getLangOpts().OpenMP >= 50) {\n      if (IsPointer && !AllowAnotherPtr)\n        SemaRef.Diag(ELoc, diag::err_omp_section_length_undefined)\n            << /*array of unknown bound */ 1;\n      else\n        IsNonContiguous = true;\n    } else if (AllowUnitySizeArraySection && NotUnity) {\n      // A unity or whole array section is not allowed and that is not\n      // compatible with the properties of the current array section.\n      SemaRef.Diag(\n        ELoc, diag::err_array_section_does_not_specify_contiguous_storage)\n        << OASE->getSourceRange();\n      return false;\n    }\n\n    if (IsPointer)\n      AllowAnotherPtr = false;\n\n    if (const auto *TE = dyn_cast<CXXThisExpr>(E)) {\n      Expr::EvalResult ResultR;\n      Expr::EvalResult ResultL;\n      if (!OASE->getLength()->isValueDependent() &&\n          OASE->getLength()->EvaluateAsInt(ResultR, SemaRef.getASTContext()) &&\n          !ResultR.Val.getInt().isOneValue()) {\n        SemaRef.Diag(OASE->getLength()->getExprLoc(),\n                     diag::err_omp_invalid_map_this_expr);\n        SemaRef.Diag(OASE->getLength()->getExprLoc(),\n                     diag::note_omp_invalid_length_on_this_ptr_mapping);\n      }\n      if (OASE->getLowerBound() && !OASE->getLowerBound()->isValueDependent() &&\n          OASE->getLowerBound()->EvaluateAsInt(ResultL,\n                                               SemaRef.getASTContext()) &&\n          !ResultL.Val.getInt().isNullValue()) {\n        SemaRef.Diag(OASE->getLowerBound()->getExprLoc(),\n                     diag::err_omp_invalid_map_this_expr);\n        SemaRef.Diag(OASE->getLowerBound()->getExprLoc(),\n                     diag::note_omp_invalid_lower_bound_on_this_ptr_mapping);\n      }\n      assert(!RelevantExpr && \"RelevantExpr is expected to be nullptr\");\n      RelevantExpr = TE;\n    }\n\n    // Record the component - we don't have any declaration associated.\n    Components.emplace_back(OASE, nullptr, /*IsNonContiguous=*/false);\n    return RelevantExpr || Visit(E);\n  }\n  bool VisitOMPArrayShapingExpr(OMPArrayShapingExpr *E) {\n    Expr *Base = E->getBase();\n\n    // Record the component - we don't have any declaration associated.\n    Components.emplace_back(E, nullptr, IsNonContiguous);\n\n    return Visit(Base->IgnoreParenImpCasts());\n  }\n\n  bool VisitUnaryOperator(UnaryOperator *UO) {\n    if (SemaRef.getLangOpts().OpenMP < 50 || !UO->isLValue() ||\n        UO->getOpcode() != UO_Deref) {\n      emitErrorMsg();\n      return false;\n    }\n    if (!RelevantExpr) {\n      // Record the component if haven't found base decl.\n      Components.emplace_back(UO, nullptr, /*IsNonContiguous=*/false);\n    }\n    return RelevantExpr || Visit(UO->getSubExpr()->IgnoreParenImpCasts());\n  }\n  bool VisitBinaryOperator(BinaryOperator *BO) {\n    if (SemaRef.getLangOpts().OpenMP < 50 || !BO->getType()->isPointerType()) {\n      emitErrorMsg();\n      return false;\n    }\n\n    // Pointer arithmetic is the only thing we expect to happen here so after we\n    // make sure the binary operator is a pointer type, the we only thing need\n    // to to is to visit the subtree that has the same type as root (so that we\n    // know the other subtree is just an offset)\n    Expr *LE = BO->getLHS()->IgnoreParenImpCasts();\n    Expr *RE = BO->getRHS()->IgnoreParenImpCasts();\n    Components.emplace_back(BO, nullptr, false);\n    assert((LE->getType().getTypePtr() == BO->getType().getTypePtr() ||\n            RE->getType().getTypePtr() == BO->getType().getTypePtr()) &&\n           \"Either LHS or RHS have base decl inside\");\n    if (BO->getType().getTypePtr() == LE->getType().getTypePtr())\n      return RelevantExpr || Visit(LE);\n    return RelevantExpr || Visit(RE);\n  }\n  bool VisitCXXThisExpr(CXXThisExpr *CTE) {\n    assert(!RelevantExpr && \"RelevantExpr is expected to be nullptr\");\n    RelevantExpr = CTE;\n    Components.emplace_back(CTE, nullptr, IsNonContiguous);\n    return true;\n  }\n  bool VisitCXXOperatorCallExpr(CXXOperatorCallExpr *COCE) {\n    assert(!RelevantExpr && \"RelevantExpr is expected to be nullptr\");\n    Components.emplace_back(COCE, nullptr, IsNonContiguous);\n    return true;\n  }\n  bool VisitStmt(Stmt *) {\n    emitErrorMsg();\n    return false;\n  }\n  const Expr *getFoundBase() const {\n    return RelevantExpr;\n  }\n  explicit MapBaseChecker(\n      Sema &SemaRef, OpenMPClauseKind CKind, OpenMPDirectiveKind DKind,\n      OMPClauseMappableExprCommon::MappableExprComponentList &Components,\n      bool NoDiagnose, SourceLocation &ELoc, SourceRange &ERange)\n      : SemaRef(SemaRef), CKind(CKind), DKind(DKind), Components(Components),\n        NoDiagnose(NoDiagnose), ELoc(ELoc), ERange(ERange) {}\n};\n} // namespace\n\n/// Return the expression of the base of the mappable expression or null if it\n/// cannot be determined and do all the necessary checks to see if the expression\n/// is valid as a standalone mappable expression. In the process, record all the\n/// components of the expression.\nstatic const Expr *checkMapClauseExpressionBase(\n    Sema &SemaRef, Expr *E,\n    OMPClauseMappableExprCommon::MappableExprComponentList &CurComponents,\n    OpenMPClauseKind CKind, OpenMPDirectiveKind DKind, bool NoDiagnose) {\n  SourceLocation ELoc = E->getExprLoc();\n  SourceRange ERange = E->getSourceRange();\n  MapBaseChecker Checker(SemaRef, CKind, DKind, CurComponents, NoDiagnose, ELoc,\n                         ERange);\n  if (Checker.Visit(E->IgnoreParens())) {\n    // Check if the highest dimension array section has length specified\n    if (SemaRef.getLangOpts().OpenMP >= 50 && !CurComponents.empty() &&\n        (CKind == OMPC_to || CKind == OMPC_from)) {\n      auto CI = CurComponents.rbegin();\n      auto CE = CurComponents.rend();\n      for (; CI != CE; ++CI) {\n        const auto *OASE =\n            dyn_cast<OMPArraySectionExpr>(CI->getAssociatedExpression());\n        if (!OASE)\n          continue;\n        if (OASE && OASE->getLength())\n          break;\n        SemaRef.Diag(ELoc, diag::err_array_section_does_not_specify_length)\n            << ERange;\n      }\n    }\n    return Checker.getFoundBase();\n  }\n  return nullptr;\n}\n\n// Return true if expression E associated with value VD has conflicts with other\n// map information.\nstatic bool checkMapConflicts(\n    Sema &SemaRef, DSAStackTy *DSAS, const ValueDecl *VD, const Expr *E,\n    bool CurrentRegionOnly,\n    OMPClauseMappableExprCommon::MappableExprComponentListRef CurComponents,\n    OpenMPClauseKind CKind) {\n  assert(VD && E);\n  SourceLocation ELoc = E->getExprLoc();\n  SourceRange ERange = E->getSourceRange();\n\n  // In order to easily check the conflicts we need to match each component of\n  // the expression under test with the components of the expressions that are\n  // already in the stack.\n\n  assert(!CurComponents.empty() && \"Map clause expression with no components!\");\n  assert(CurComponents.back().getAssociatedDeclaration() == VD &&\n         \"Map clause expression with unexpected base!\");\n\n  // Variables to help detecting enclosing problems in data environment nests.\n  bool IsEnclosedByDataEnvironmentExpr = false;\n  const Expr *EnclosingExpr = nullptr;\n\n  bool FoundError = DSAS->checkMappableExprComponentListsForDecl(\n      VD, CurrentRegionOnly,\n      [&IsEnclosedByDataEnvironmentExpr, &SemaRef, VD, CurrentRegionOnly, ELoc,\n       ERange, CKind, &EnclosingExpr,\n       CurComponents](OMPClauseMappableExprCommon::MappableExprComponentListRef\n                          StackComponents,\n                      OpenMPClauseKind Kind) {\n        if (CKind == Kind && SemaRef.LangOpts.OpenMP >= 50)\n          return false;\n        assert(!StackComponents.empty() &&\n               \"Map clause expression with no components!\");\n        assert(StackComponents.back().getAssociatedDeclaration() == VD &&\n               \"Map clause expression with unexpected base!\");\n        (void)VD;\n\n        // The whole expression in the stack.\n        const Expr *RE = StackComponents.front().getAssociatedExpression();\n\n        // Expressions must start from the same base. Here we detect at which\n        // point both expressions diverge from each other and see if we can\n        // detect if the memory referred to both expressions is contiguous and\n        // do not overlap.\n        auto CI = CurComponents.rbegin();\n        auto CE = CurComponents.rend();\n        auto SI = StackComponents.rbegin();\n        auto SE = StackComponents.rend();\n        for (; CI != CE && SI != SE; ++CI, ++SI) {\n\n          // OpenMP 4.5 [2.15.5.1, map Clause, Restrictions, p.3]\n          //  At most one list item can be an array item derived from a given\n          //  variable in map clauses of the same construct.\n          if (CurrentRegionOnly &&\n              (isa<ArraySubscriptExpr>(CI->getAssociatedExpression()) ||\n               isa<OMPArraySectionExpr>(CI->getAssociatedExpression()) ||\n               isa<OMPArrayShapingExpr>(CI->getAssociatedExpression())) &&\n              (isa<ArraySubscriptExpr>(SI->getAssociatedExpression()) ||\n               isa<OMPArraySectionExpr>(SI->getAssociatedExpression()) ||\n               isa<OMPArrayShapingExpr>(SI->getAssociatedExpression()))) {\n            SemaRef.Diag(CI->getAssociatedExpression()->getExprLoc(),\n                         diag::err_omp_multiple_array_items_in_map_clause)\n                << CI->getAssociatedExpression()->getSourceRange();\n            SemaRef.Diag(SI->getAssociatedExpression()->getExprLoc(),\n                         diag::note_used_here)\n                << SI->getAssociatedExpression()->getSourceRange();\n            return true;\n          }\n\n          // Do both expressions have the same kind?\n          if (CI->getAssociatedExpression()->getStmtClass() !=\n              SI->getAssociatedExpression()->getStmtClass())\n            break;\n\n          // Are we dealing with different variables/fields?\n          if (CI->getAssociatedDeclaration() != SI->getAssociatedDeclaration())\n            break;\n        }\n        // Check if the extra components of the expressions in the enclosing\n        // data environment are redundant for the current base declaration.\n        // If they are, the maps completely overlap, which is legal.\n        for (; SI != SE; ++SI) {\n          QualType Type;\n          if (const auto *ASE =\n                  dyn_cast<ArraySubscriptExpr>(SI->getAssociatedExpression())) {\n            Type = ASE->getBase()->IgnoreParenImpCasts()->getType();\n          } else if (const auto *OASE = dyn_cast<OMPArraySectionExpr>(\n                         SI->getAssociatedExpression())) {\n            const Expr *E = OASE->getBase()->IgnoreParenImpCasts();\n            Type =\n                OMPArraySectionExpr::getBaseOriginalType(E).getCanonicalType();\n          } else if (const auto *OASE = dyn_cast<OMPArrayShapingExpr>(\n                         SI->getAssociatedExpression())) {\n            Type = OASE->getBase()->getType()->getPointeeType();\n          }\n          if (Type.isNull() || Type->isAnyPointerType() ||\n              checkArrayExpressionDoesNotReferToWholeSize(\n                  SemaRef, SI->getAssociatedExpression(), Type))\n            break;\n        }\n\n        // OpenMP 4.5 [2.15.5.1, map Clause, Restrictions, p.4]\n        //  List items of map clauses in the same construct must not share\n        //  original storage.\n        //\n        // If the expressions are exactly the same or one is a subset of the\n        // other, it means they are sharing storage.\n        if (CI == CE && SI == SE) {\n          if (CurrentRegionOnly) {\n            if (CKind == OMPC_map) {\n              SemaRef.Diag(ELoc, diag::err_omp_map_shared_storage) << ERange;\n            } else {\n              assert(CKind == OMPC_to || CKind == OMPC_from);\n              SemaRef.Diag(ELoc, diag::err_omp_once_referenced_in_target_update)\n                  << ERange;\n            }\n            SemaRef.Diag(RE->getExprLoc(), diag::note_used_here)\n                << RE->getSourceRange();\n            return true;\n          }\n          // If we find the same expression in the enclosing data environment,\n          // that is legal.\n          IsEnclosedByDataEnvironmentExpr = true;\n          return false;\n        }\n\n        QualType DerivedType =\n            std::prev(CI)->getAssociatedDeclaration()->getType();\n        SourceLocation DerivedLoc =\n            std::prev(CI)->getAssociatedExpression()->getExprLoc();\n\n        // OpenMP 4.5 [2.15.5.1, map Clause, Restrictions, C++, p.1]\n        //  If the type of a list item is a reference to a type T then the type\n        //  will be considered to be T for all purposes of this clause.\n        DerivedType = DerivedType.getNonReferenceType();\n\n        // OpenMP 4.5 [2.15.5.1, map Clause, Restrictions, C/C++, p.1]\n        //  A variable for which the type is pointer and an array section\n        //  derived from that variable must not appear as list items of map\n        //  clauses of the same construct.\n        //\n        // Also, cover one of the cases in:\n        // OpenMP 4.5 [2.15.5.1, map Clause, Restrictions, p.5]\n        //  If any part of the original storage of a list item has corresponding\n        //  storage in the device data environment, all of the original storage\n        //  must have corresponding storage in the device data environment.\n        //\n        if (DerivedType->isAnyPointerType()) {\n          if (CI == CE || SI == SE) {\n            SemaRef.Diag(\n                DerivedLoc,\n                diag::err_omp_pointer_mapped_along_with_derived_section)\n                << DerivedLoc;\n            SemaRef.Diag(RE->getExprLoc(), diag::note_used_here)\n                << RE->getSourceRange();\n            return true;\n          }\n          if (CI->getAssociatedExpression()->getStmtClass() !=\n                         SI->getAssociatedExpression()->getStmtClass() ||\n                     CI->getAssociatedDeclaration()->getCanonicalDecl() ==\n                         SI->getAssociatedDeclaration()->getCanonicalDecl()) {\n            assert(CI != CE && SI != SE);\n            SemaRef.Diag(DerivedLoc, diag::err_omp_same_pointer_dereferenced)\n                << DerivedLoc;\n            SemaRef.Diag(RE->getExprLoc(), diag::note_used_here)\n                << RE->getSourceRange();\n            return true;\n          }\n        }\n\n        // OpenMP 4.5 [2.15.5.1, map Clause, Restrictions, p.4]\n        //  List items of map clauses in the same construct must not share\n        //  original storage.\n        //\n        // An expression is a subset of the other.\n        if (CurrentRegionOnly && (CI == CE || SI == SE)) {\n          if (CKind == OMPC_map) {\n            if (CI != CE || SI != SE) {\n              // Allow constructs like this: map(s, s.ptr[0:1]), where s.ptr is\n              // a pointer.\n              auto Begin =\n                  CI != CE ? CurComponents.begin() : StackComponents.begin();\n              auto End = CI != CE ? CurComponents.end() : StackComponents.end();\n              auto It = Begin;\n              while (It != End && !It->getAssociatedDeclaration())\n                std::advance(It, 1);\n              assert(It != End &&\n                     \"Expected at least one component with the declaration.\");\n              if (It != Begin && It->getAssociatedDeclaration()\n                                     ->getType()\n                                     .getCanonicalType()\n                                     ->isAnyPointerType()) {\n                IsEnclosedByDataEnvironmentExpr = false;\n                EnclosingExpr = nullptr;\n                return false;\n              }\n            }\n            SemaRef.Diag(ELoc, diag::err_omp_map_shared_storage) << ERange;\n          } else {\n            assert(CKind == OMPC_to || CKind == OMPC_from);\n            SemaRef.Diag(ELoc, diag::err_omp_once_referenced_in_target_update)\n                << ERange;\n          }\n          SemaRef.Diag(RE->getExprLoc(), diag::note_used_here)\n              << RE->getSourceRange();\n          return true;\n        }\n\n        // The current expression uses the same base as other expression in the\n        // data environment but does not contain it completely.\n        if (!CurrentRegionOnly && SI != SE)\n          EnclosingExpr = RE;\n\n        // The current expression is a subset of the expression in the data\n        // environment.\n        IsEnclosedByDataEnvironmentExpr |=\n            (!CurrentRegionOnly && CI != CE && SI == SE);\n\n        return false;\n      });\n\n  if (CurrentRegionOnly)\n    return FoundError;\n\n  // OpenMP 4.5 [2.15.5.1, map Clause, Restrictions, p.5]\n  //  If any part of the original storage of a list item has corresponding\n  //  storage in the device data environment, all of the original storage must\n  //  have corresponding storage in the device data environment.\n  // OpenMP 4.5 [2.15.5.1, map Clause, Restrictions, p.6]\n  //  If a list item is an element of a structure, and a different element of\n  //  the structure has a corresponding list item in the device data environment\n  //  prior to a task encountering the construct associated with the map clause,\n  //  then the list item must also have a corresponding list item in the device\n  //  data environment prior to the task encountering the construct.\n  //\n  if (EnclosingExpr && !IsEnclosedByDataEnvironmentExpr) {\n    SemaRef.Diag(ELoc,\n                 diag::err_omp_original_storage_is_shared_and_does_not_contain)\n        << ERange;\n    SemaRef.Diag(EnclosingExpr->getExprLoc(), diag::note_used_here)\n        << EnclosingExpr->getSourceRange();\n    return true;\n  }\n\n  return FoundError;\n}\n\n// Look up the user-defined mapper given the mapper name and mapped type, and\n// build a reference to it.\nstatic ExprResult buildUserDefinedMapperRef(Sema &SemaRef, Scope *S,\n                                            CXXScopeSpec &MapperIdScopeSpec,\n                                            const DeclarationNameInfo &MapperId,\n                                            QualType Type,\n                                            Expr *UnresolvedMapper) {\n  if (MapperIdScopeSpec.isInvalid())\n    return ExprError();\n  // Get the actual type for the array type.\n  if (Type->isArrayType()) {\n    assert(Type->getAsArrayTypeUnsafe() && \"Expect to get a valid array type\");\n    Type = Type->getAsArrayTypeUnsafe()->getElementType().getCanonicalType();\n  }\n  // Find all user-defined mappers with the given MapperId.\n  SmallVector<UnresolvedSet<8>, 4> Lookups;\n  LookupResult Lookup(SemaRef, MapperId, Sema::LookupOMPMapperName);\n  Lookup.suppressDiagnostics();\n  if (S) {\n    while (S && SemaRef.LookupParsedName(Lookup, S, &MapperIdScopeSpec)) {\n      NamedDecl *D = Lookup.getRepresentativeDecl();\n      while (S && !S->isDeclScope(D))\n        S = S->getParent();\n      if (S)\n        S = S->getParent();\n      Lookups.emplace_back();\n      Lookups.back().append(Lookup.begin(), Lookup.end());\n      Lookup.clear();\n    }\n  } else if (auto *ULE = cast_or_null<UnresolvedLookupExpr>(UnresolvedMapper)) {\n    // Extract the user-defined mappers with the given MapperId.\n    Lookups.push_back(UnresolvedSet<8>());\n    for (NamedDecl *D : ULE->decls()) {\n      auto *DMD = cast<OMPDeclareMapperDecl>(D);\n      assert(DMD && \"Expect valid OMPDeclareMapperDecl during instantiation.\");\n      Lookups.back().addDecl(DMD);\n    }\n  }\n  // Defer the lookup for dependent types. The results will be passed through\n  // UnresolvedMapper on instantiation.\n  if (SemaRef.CurContext->isDependentContext() || Type->isDependentType() ||\n      Type->isInstantiationDependentType() ||\n      Type->containsUnexpandedParameterPack() ||\n      filterLookupForUDReductionAndMapper<bool>(Lookups, [](ValueDecl *D) {\n        return !D->isInvalidDecl() &&\n               (D->getType()->isDependentType() ||\n                D->getType()->isInstantiationDependentType() ||\n                D->getType()->containsUnexpandedParameterPack());\n      })) {\n    UnresolvedSet<8> URS;\n    for (const UnresolvedSet<8> &Set : Lookups) {\n      if (Set.empty())\n        continue;\n      URS.append(Set.begin(), Set.end());\n    }\n    return UnresolvedLookupExpr::Create(\n        SemaRef.Context, /*NamingClass=*/nullptr,\n        MapperIdScopeSpec.getWithLocInContext(SemaRef.Context), MapperId,\n        /*ADL=*/false, /*Overloaded=*/true, URS.begin(), URS.end());\n  }\n  SourceLocation Loc = MapperId.getLoc();\n  // [OpenMP 5.0], 2.19.7.3 declare mapper Directive, Restrictions\n  //  The type must be of struct, union or class type in C and C++\n  if (!Type->isStructureOrClassType() && !Type->isUnionType() &&\n      (MapperIdScopeSpec.isSet() || MapperId.getAsString() != \"default\")) {\n    SemaRef.Diag(Loc, diag::err_omp_mapper_wrong_type);\n    return ExprError();\n  }\n  // Perform argument dependent lookup.\n  if (SemaRef.getLangOpts().CPlusPlus && !MapperIdScopeSpec.isSet())\n    argumentDependentLookup(SemaRef, MapperId, Loc, Type, Lookups);\n  // Return the first user-defined mapper with the desired type.\n  if (auto *VD = filterLookupForUDReductionAndMapper<ValueDecl *>(\n          Lookups, [&SemaRef, Type](ValueDecl *D) -> ValueDecl * {\n            if (!D->isInvalidDecl() &&\n                SemaRef.Context.hasSameType(D->getType(), Type))\n              return D;\n            return nullptr;\n          }))\n    return SemaRef.BuildDeclRefExpr(VD, Type, VK_LValue, Loc);\n  // Find the first user-defined mapper with a type derived from the desired\n  // type.\n  if (auto *VD = filterLookupForUDReductionAndMapper<ValueDecl *>(\n          Lookups, [&SemaRef, Type, Loc](ValueDecl *D) -> ValueDecl * {\n            if (!D->isInvalidDecl() &&\n                SemaRef.IsDerivedFrom(Loc, Type, D->getType()) &&\n                !Type.isMoreQualifiedThan(D->getType()))\n              return D;\n            return nullptr;\n          })) {\n    CXXBasePaths Paths(/*FindAmbiguities=*/true, /*RecordPaths=*/true,\n                       /*DetectVirtual=*/false);\n    if (SemaRef.IsDerivedFrom(Loc, Type, VD->getType(), Paths)) {\n      if (!Paths.isAmbiguous(SemaRef.Context.getCanonicalType(\n              VD->getType().getUnqualifiedType()))) {\n        if (SemaRef.CheckBaseClassAccess(\n                Loc, VD->getType(), Type, Paths.front(),\n                /*DiagID=*/0) != Sema::AR_inaccessible) {\n          return SemaRef.BuildDeclRefExpr(VD, Type, VK_LValue, Loc);\n        }\n      }\n    }\n  }\n  // Report error if a mapper is specified, but cannot be found.\n  if (MapperIdScopeSpec.isSet() || MapperId.getAsString() != \"default\") {\n    SemaRef.Diag(Loc, diag::err_omp_invalid_mapper)\n        << Type << MapperId.getName();\n    return ExprError();\n  }\n  return ExprEmpty();\n}\n\nnamespace {\n// Utility struct that gathers all the related lists associated with a mappable\n// expression.\nstruct MappableVarListInfo {\n  // The list of expressions.\n  ArrayRef<Expr *> VarList;\n  // The list of processed expressions.\n  SmallVector<Expr *, 16> ProcessedVarList;\n  // The mappble components for each expression.\n  OMPClauseMappableExprCommon::MappableExprComponentLists VarComponents;\n  // The base declaration of the variable.\n  SmallVector<ValueDecl *, 16> VarBaseDeclarations;\n  // The reference to the user-defined mapper associated with every expression.\n  SmallVector<Expr *, 16> UDMapperList;\n\n  MappableVarListInfo(ArrayRef<Expr *> VarList) : VarList(VarList) {\n    // We have a list of components and base declarations for each entry in the\n    // variable list.\n    VarComponents.reserve(VarList.size());\n    VarBaseDeclarations.reserve(VarList.size());\n  }\n};\n}\n\n// Check the validity of the provided variable list for the provided clause kind\n// \\a CKind. In the check process the valid expressions, mappable expression\n// components, variables, and user-defined mappers are extracted and used to\n// fill \\a ProcessedVarList, \\a VarComponents, \\a VarBaseDeclarations, and \\a\n// UDMapperList in MVLI. \\a MapType, \\a IsMapTypeImplicit, \\a MapperIdScopeSpec,\n// and \\a MapperId are expected to be valid if the clause kind is 'map'.\nstatic void checkMappableExpressionList(\n    Sema &SemaRef, DSAStackTy *DSAS, OpenMPClauseKind CKind,\n    MappableVarListInfo &MVLI, SourceLocation StartLoc,\n    CXXScopeSpec &MapperIdScopeSpec, DeclarationNameInfo MapperId,\n    ArrayRef<Expr *> UnresolvedMappers,\n    OpenMPMapClauseKind MapType = OMPC_MAP_unknown,\n    bool IsMapTypeImplicit = false) {\n  // We only expect mappable expressions in 'to', 'from', and 'map' clauses.\n  assert((CKind == OMPC_map || CKind == OMPC_to || CKind == OMPC_from) &&\n         \"Unexpected clause kind with mappable expressions!\");\n\n  // If the identifier of user-defined mapper is not specified, it is \"default\".\n  // We do not change the actual name in this clause to distinguish whether a\n  // mapper is specified explicitly, i.e., it is not explicitly specified when\n  // MapperId.getName() is empty.\n  if (!MapperId.getName() || MapperId.getName().isEmpty()) {\n    auto &DeclNames = SemaRef.getASTContext().DeclarationNames;\n    MapperId.setName(DeclNames.getIdentifier(\n        &SemaRef.getASTContext().Idents.get(\"default\")));\n    MapperId.setLoc(StartLoc);\n  }\n\n  // Iterators to find the current unresolved mapper expression.\n  auto UMIt = UnresolvedMappers.begin(), UMEnd = UnresolvedMappers.end();\n  bool UpdateUMIt = false;\n  Expr *UnresolvedMapper = nullptr;\n\n  // Keep track of the mappable components and base declarations in this clause.\n  // Each entry in the list is going to have a list of components associated. We\n  // record each set of the components so that we can build the clause later on.\n  // In the end we should have the same amount of declarations and component\n  // lists.\n\n  for (Expr *RE : MVLI.VarList) {\n    assert(RE && \"Null expr in omp to/from/map clause\");\n    SourceLocation ELoc = RE->getExprLoc();\n\n    // Find the current unresolved mapper expression.\n    if (UpdateUMIt && UMIt != UMEnd) {\n      UMIt++;\n      assert(\n          UMIt != UMEnd &&\n          \"Expect the size of UnresolvedMappers to match with that of VarList\");\n    }\n    UpdateUMIt = true;\n    if (UMIt != UMEnd)\n      UnresolvedMapper = *UMIt;\n\n    const Expr *VE = RE->IgnoreParenLValueCasts();\n\n    if (VE->isValueDependent() || VE->isTypeDependent() ||\n        VE->isInstantiationDependent() ||\n        VE->containsUnexpandedParameterPack()) {\n      // Try to find the associated user-defined mapper.\n      ExprResult ER = buildUserDefinedMapperRef(\n          SemaRef, DSAS->getCurScope(), MapperIdScopeSpec, MapperId,\n          VE->getType().getCanonicalType(), UnresolvedMapper);\n      if (ER.isInvalid())\n        continue;\n      MVLI.UDMapperList.push_back(ER.get());\n      // We can only analyze this information once the missing information is\n      // resolved.\n      MVLI.ProcessedVarList.push_back(RE);\n      continue;\n    }\n\n    Expr *SimpleExpr = RE->IgnoreParenCasts();\n\n    if (!RE->isLValue()) {\n      if (SemaRef.getLangOpts().OpenMP < 50) {\n        SemaRef.Diag(\n            ELoc, diag::err_omp_expected_named_var_member_or_array_expression)\n            << RE->getSourceRange();\n      } else {\n        SemaRef.Diag(ELoc, diag::err_omp_non_lvalue_in_map_or_motion_clauses)\n            << getOpenMPClauseName(CKind) << RE->getSourceRange();\n      }\n      continue;\n    }\n\n    OMPClauseMappableExprCommon::MappableExprComponentList CurComponents;\n    ValueDecl *CurDeclaration = nullptr;\n\n    // Obtain the array or member expression bases if required. Also, fill the\n    // components array with all the components identified in the process.\n    const Expr *BE = checkMapClauseExpressionBase(\n        SemaRef, SimpleExpr, CurComponents, CKind, DSAS->getCurrentDirective(),\n        /*NoDiagnose=*/false);\n    if (!BE)\n      continue;\n\n    assert(!CurComponents.empty() &&\n           \"Invalid mappable expression information.\");\n\n    if (const auto *TE = dyn_cast<CXXThisExpr>(BE)) {\n      // Add store \"this\" pointer to class in DSAStackTy for future checking\n      DSAS->addMappedClassesQualTypes(TE->getType());\n      // Try to find the associated user-defined mapper.\n      ExprResult ER = buildUserDefinedMapperRef(\n          SemaRef, DSAS->getCurScope(), MapperIdScopeSpec, MapperId,\n          VE->getType().getCanonicalType(), UnresolvedMapper);\n      if (ER.isInvalid())\n        continue;\n      MVLI.UDMapperList.push_back(ER.get());\n      // Skip restriction checking for variable or field declarations\n      MVLI.ProcessedVarList.push_back(RE);\n      MVLI.VarComponents.resize(MVLI.VarComponents.size() + 1);\n      MVLI.VarComponents.back().append(CurComponents.begin(),\n                                       CurComponents.end());\n      MVLI.VarBaseDeclarations.push_back(nullptr);\n      continue;\n    }\n\n    // For the following checks, we rely on the base declaration which is\n    // expected to be associated with the last component. The declaration is\n    // expected to be a variable or a field (if 'this' is being mapped).\n    CurDeclaration = CurComponents.back().getAssociatedDeclaration();\n    assert(CurDeclaration && \"Null decl on map clause.\");\n    assert(\n        CurDeclaration->isCanonicalDecl() &&\n        \"Expecting components to have associated only canonical declarations.\");\n\n    auto *VD = dyn_cast<VarDecl>(CurDeclaration);\n    const auto *FD = dyn_cast<FieldDecl>(CurDeclaration);\n\n    assert((VD || FD) && \"Only variables or fields are expected here!\");\n    (void)FD;\n\n    // OpenMP 4.5 [2.15.5.1, map Clause, Restrictions, p.10]\n    // threadprivate variables cannot appear in a map clause.\n    // OpenMP 4.5 [2.10.5, target update Construct]\n    // threadprivate variables cannot appear in a from clause.\n    if (VD && DSAS->isThreadPrivate(VD)) {\n      DSAStackTy::DSAVarData DVar = DSAS->getTopDSA(VD, /*FromParent=*/false);\n      SemaRef.Diag(ELoc, diag::err_omp_threadprivate_in_clause)\n          << getOpenMPClauseName(CKind);\n      reportOriginalDsa(SemaRef, DSAS, VD, DVar);\n      continue;\n    }\n\n    // OpenMP 4.5 [2.15.5.1, map Clause, Restrictions, p.9]\n    //  A list item cannot appear in both a map clause and a data-sharing\n    //  attribute clause on the same construct.\n\n    // Check conflicts with other map clause expressions. We check the conflicts\n    // with the current construct separately from the enclosing data\n    // environment, because the restrictions are different. We only have to\n    // check conflicts across regions for the map clauses.\n    if (checkMapConflicts(SemaRef, DSAS, CurDeclaration, SimpleExpr,\n                          /*CurrentRegionOnly=*/true, CurComponents, CKind))\n      break;\n    if (CKind == OMPC_map &&\n        (SemaRef.getLangOpts().OpenMP <= 45 || StartLoc.isValid()) &&\n        checkMapConflicts(SemaRef, DSAS, CurDeclaration, SimpleExpr,\n                          /*CurrentRegionOnly=*/false, CurComponents, CKind))\n      break;\n\n    // OpenMP 4.5 [2.10.5, target update Construct]\n    // OpenMP 4.5 [2.15.5.1, map Clause, Restrictions, C++, p.1]\n    //  If the type of a list item is a reference to a type T then the type will\n    //  be considered to be T for all purposes of this clause.\n    auto I = llvm::find_if(\n        CurComponents,\n        [](const OMPClauseMappableExprCommon::MappableComponent &MC) {\n          return MC.getAssociatedDeclaration();\n        });\n    assert(I != CurComponents.end() && \"Null decl on map clause.\");\n    (void)I;\n    QualType Type;\n    auto *ASE = dyn_cast<ArraySubscriptExpr>(VE->IgnoreParens());\n    auto *OASE = dyn_cast<OMPArraySectionExpr>(VE->IgnoreParens());\n    auto *OAShE = dyn_cast<OMPArrayShapingExpr>(VE->IgnoreParens());\n    if (ASE) {\n      Type = ASE->getType().getNonReferenceType();\n    } else if (OASE) {\n      QualType BaseType =\n          OMPArraySectionExpr::getBaseOriginalType(OASE->getBase());\n      if (const auto *ATy = BaseType->getAsArrayTypeUnsafe())\n        Type = ATy->getElementType();\n      else\n        Type = BaseType->getPointeeType();\n      Type = Type.getNonReferenceType();\n    } else if (OAShE) {\n      Type = OAShE->getBase()->getType()->getPointeeType();\n    } else {\n      Type = VE->getType();\n    }\n\n    // OpenMP 4.5 [2.10.5, target update Construct, Restrictions, p.4]\n    // A list item in a to or from clause must have a mappable type.\n    // OpenMP 4.5 [2.15.5.1, map Clause, Restrictions, p.9]\n    //  A list item must have a mappable type.\n    if (!checkTypeMappable(VE->getExprLoc(), VE->getSourceRange(), SemaRef,\n                           DSAS, Type))\n      continue;\n\n    if (CKind == OMPC_map) {\n      // target enter data\n      // OpenMP [2.10.2, Restrictions, p. 99]\n      // A map-type must be specified in all map clauses and must be either\n      // to or alloc.\n      OpenMPDirectiveKind DKind = DSAS->getCurrentDirective();\n      if (DKind == OMPD_target_enter_data &&\n          !(MapType == OMPC_MAP_to || MapType == OMPC_MAP_alloc)) {\n        SemaRef.Diag(StartLoc, diag::err_omp_invalid_map_type_for_directive)\n            << (IsMapTypeImplicit ? 1 : 0)\n            << getOpenMPSimpleClauseTypeName(OMPC_map, MapType)\n            << getOpenMPDirectiveName(DKind);\n        continue;\n      }\n\n      // target exit_data\n      // OpenMP [2.10.3, Restrictions, p. 102]\n      // A map-type must be specified in all map clauses and must be either\n      // from, release, or delete.\n      if (DKind == OMPD_target_exit_data &&\n          !(MapType == OMPC_MAP_from || MapType == OMPC_MAP_release ||\n            MapType == OMPC_MAP_delete)) {\n        SemaRef.Diag(StartLoc, diag::err_omp_invalid_map_type_for_directive)\n            << (IsMapTypeImplicit ? 1 : 0)\n            << getOpenMPSimpleClauseTypeName(OMPC_map, MapType)\n            << getOpenMPDirectiveName(DKind);\n        continue;\n      }\n\n      // target, target data\n      // OpenMP 5.0 [2.12.2, Restrictions, p. 163]\n      // OpenMP 5.0 [2.12.5, Restrictions, p. 174]\n      // A map-type in a map clause must be to, from, tofrom or alloc\n      if ((DKind == OMPD_target_data ||\n           isOpenMPTargetExecutionDirective(DKind)) &&\n          !(MapType == OMPC_MAP_to || MapType == OMPC_MAP_from ||\n            MapType == OMPC_MAP_tofrom || MapType == OMPC_MAP_alloc)) {\n        SemaRef.Diag(StartLoc, diag::err_omp_invalid_map_type_for_directive)\n            << (IsMapTypeImplicit ? 1 : 0)\n            << getOpenMPSimpleClauseTypeName(OMPC_map, MapType)\n            << getOpenMPDirectiveName(DKind);\n        continue;\n      }\n\n      // OpenMP 4.5 [2.15.5.1, Restrictions, p.3]\n      // A list item cannot appear in both a map clause and a data-sharing\n      // attribute clause on the same construct\n      //\n      // OpenMP 5.0 [2.19.7.1, Restrictions, p.7]\n      // A list item cannot appear in both a map clause and a data-sharing\n      // attribute clause on the same construct unless the construct is a\n      // combined construct.\n      if (VD && ((SemaRef.LangOpts.OpenMP <= 45 &&\n                  isOpenMPTargetExecutionDirective(DKind)) ||\n                 DKind == OMPD_target)) {\n        DSAStackTy::DSAVarData DVar = DSAS->getTopDSA(VD, /*FromParent=*/false);\n        if (isOpenMPPrivate(DVar.CKind)) {\n          SemaRef.Diag(ELoc, diag::err_omp_variable_in_given_clause_and_dsa)\n              << getOpenMPClauseName(DVar.CKind)\n              << getOpenMPClauseName(OMPC_map)\n              << getOpenMPDirectiveName(DSAS->getCurrentDirective());\n          reportOriginalDsa(SemaRef, DSAS, CurDeclaration, DVar);\n          continue;\n        }\n      }\n    }\n\n    // Try to find the associated user-defined mapper.\n    ExprResult ER = buildUserDefinedMapperRef(\n        SemaRef, DSAS->getCurScope(), MapperIdScopeSpec, MapperId,\n        Type.getCanonicalType(), UnresolvedMapper);\n    if (ER.isInvalid())\n      continue;\n    MVLI.UDMapperList.push_back(ER.get());\n\n    // Save the current expression.\n    MVLI.ProcessedVarList.push_back(RE);\n\n    // Store the components in the stack so that they can be used to check\n    // against other clauses later on.\n    DSAS->addMappableExpressionComponents(CurDeclaration, CurComponents,\n                                          /*WhereFoundClauseKind=*/OMPC_map);\n\n    // Save the components and declaration to create the clause. For purposes of\n    // the clause creation, any component list that has has base 'this' uses\n    // null as base declaration.\n    MVLI.VarComponents.resize(MVLI.VarComponents.size() + 1);\n    MVLI.VarComponents.back().append(CurComponents.begin(),\n                                     CurComponents.end());\n    MVLI.VarBaseDeclarations.push_back(isa<MemberExpr>(BE) ? nullptr\n                                                           : CurDeclaration);\n  }\n}\n\nOMPClause *Sema::ActOnOpenMPMapClause(\n    ArrayRef<OpenMPMapModifierKind> MapTypeModifiers,\n    ArrayRef<SourceLocation> MapTypeModifiersLoc,\n    CXXScopeSpec &MapperIdScopeSpec, DeclarationNameInfo &MapperId,\n    OpenMPMapClauseKind MapType, bool IsMapTypeImplicit, SourceLocation MapLoc,\n    SourceLocation ColonLoc, ArrayRef<Expr *> VarList,\n    const OMPVarListLocTy &Locs, ArrayRef<Expr *> UnresolvedMappers) {\n  OpenMPMapModifierKind Modifiers[] = {\n      OMPC_MAP_MODIFIER_unknown, OMPC_MAP_MODIFIER_unknown,\n      OMPC_MAP_MODIFIER_unknown, OMPC_MAP_MODIFIER_unknown};\n  SourceLocation ModifiersLoc[NumberOfOMPMapClauseModifiers];\n\n  // Process map-type-modifiers, flag errors for duplicate modifiers.\n  unsigned Count = 0;\n  for (unsigned I = 0, E = MapTypeModifiers.size(); I < E; ++I) {\n    if (MapTypeModifiers[I] != OMPC_MAP_MODIFIER_unknown &&\n        llvm::find(Modifiers, MapTypeModifiers[I]) != std::end(Modifiers)) {\n      Diag(MapTypeModifiersLoc[I], diag::err_omp_duplicate_map_type_modifier);\n      continue;\n    }\n    assert(Count < NumberOfOMPMapClauseModifiers &&\n           \"Modifiers exceed the allowed number of map type modifiers\");\n    Modifiers[Count] = MapTypeModifiers[I];\n    ModifiersLoc[Count] = MapTypeModifiersLoc[I];\n    ++Count;\n  }\n\n  MappableVarListInfo MVLI(VarList);\n  checkMappableExpressionList(*this, DSAStack, OMPC_map, MVLI, Locs.StartLoc,\n                              MapperIdScopeSpec, MapperId, UnresolvedMappers,\n                              MapType, IsMapTypeImplicit);\n\n  // We need to produce a map clause even if we don't have variables so that\n  // other diagnostics related with non-existing map clauses are accurate.\n  return OMPMapClause::Create(Context, Locs, MVLI.ProcessedVarList,\n                              MVLI.VarBaseDeclarations, MVLI.VarComponents,\n                              MVLI.UDMapperList, Modifiers, ModifiersLoc,\n                              MapperIdScopeSpec.getWithLocInContext(Context),\n                              MapperId, MapType, IsMapTypeImplicit, MapLoc);\n}\n\nQualType Sema::ActOnOpenMPDeclareReductionType(SourceLocation TyLoc,\n                                               TypeResult ParsedType) {\n  assert(ParsedType.isUsable());\n\n  QualType ReductionType = GetTypeFromParser(ParsedType.get());\n  if (ReductionType.isNull())\n    return QualType();\n\n  // [OpenMP 4.0], 2.15 declare reduction Directive, Restrictions, C\\C++\n  // A type name in a declare reduction directive cannot be a function type, an\n  // array type, a reference type, or a type qualified with const, volatile or\n  // restrict.\n  if (ReductionType.hasQualifiers()) {\n    Diag(TyLoc, diag::err_omp_reduction_wrong_type) << 0;\n    return QualType();\n  }\n\n  if (ReductionType->isFunctionType()) {\n    Diag(TyLoc, diag::err_omp_reduction_wrong_type) << 1;\n    return QualType();\n  }\n  if (ReductionType->isReferenceType()) {\n    Diag(TyLoc, diag::err_omp_reduction_wrong_type) << 2;\n    return QualType();\n  }\n  if (ReductionType->isArrayType()) {\n    Diag(TyLoc, diag::err_omp_reduction_wrong_type) << 3;\n    return QualType();\n  }\n  return ReductionType;\n}\n\nSema::DeclGroupPtrTy Sema::ActOnOpenMPDeclareReductionDirectiveStart(\n    Scope *S, DeclContext *DC, DeclarationName Name,\n    ArrayRef<std::pair<QualType, SourceLocation>> ReductionTypes,\n    AccessSpecifier AS, Decl *PrevDeclInScope) {\n  SmallVector<Decl *, 8> Decls;\n  Decls.reserve(ReductionTypes.size());\n\n  LookupResult Lookup(*this, Name, SourceLocation(), LookupOMPReductionName,\n                      forRedeclarationInCurContext());\n  // [OpenMP 4.0], 2.15 declare reduction Directive, Restrictions\n  // A reduction-identifier may not be re-declared in the current scope for the\n  // same type or for a type that is compatible according to the base language\n  // rules.\n  llvm::DenseMap<QualType, SourceLocation> PreviousRedeclTypes;\n  OMPDeclareReductionDecl *PrevDRD = nullptr;\n  bool InCompoundScope = true;\n  if (S != nullptr) {\n    // Find previous declaration with the same name not referenced in other\n    // declarations.\n    FunctionScopeInfo *ParentFn = getEnclosingFunction();\n    InCompoundScope =\n        (ParentFn != nullptr) && !ParentFn->CompoundScopes.empty();\n    LookupName(Lookup, S);\n    FilterLookupForScope(Lookup, DC, S, /*ConsiderLinkage=*/false,\n                         /*AllowInlineNamespace=*/false);\n    llvm::DenseMap<OMPDeclareReductionDecl *, bool> UsedAsPrevious;\n    LookupResult::Filter Filter = Lookup.makeFilter();\n    while (Filter.hasNext()) {\n      auto *PrevDecl = cast<OMPDeclareReductionDecl>(Filter.next());\n      if (InCompoundScope) {\n        auto I = UsedAsPrevious.find(PrevDecl);\n        if (I == UsedAsPrevious.end())\n          UsedAsPrevious[PrevDecl] = false;\n        if (OMPDeclareReductionDecl *D = PrevDecl->getPrevDeclInScope())\n          UsedAsPrevious[D] = true;\n      }\n      PreviousRedeclTypes[PrevDecl->getType().getCanonicalType()] =\n          PrevDecl->getLocation();\n    }\n    Filter.done();\n    if (InCompoundScope) {\n      for (const auto &PrevData : UsedAsPrevious) {\n        if (!PrevData.second) {\n          PrevDRD = PrevData.first;\n          break;\n        }\n      }\n    }\n  } else if (PrevDeclInScope != nullptr) {\n    auto *PrevDRDInScope = PrevDRD =\n        cast<OMPDeclareReductionDecl>(PrevDeclInScope);\n    do {\n      PreviousRedeclTypes[PrevDRDInScope->getType().getCanonicalType()] =\n          PrevDRDInScope->getLocation();\n      PrevDRDInScope = PrevDRDInScope->getPrevDeclInScope();\n    } while (PrevDRDInScope != nullptr);\n  }\n  for (const auto &TyData : ReductionTypes) {\n    const auto I = PreviousRedeclTypes.find(TyData.first.getCanonicalType());\n    bool Invalid = false;\n    if (I != PreviousRedeclTypes.end()) {\n      Diag(TyData.second, diag::err_omp_declare_reduction_redefinition)\n          << TyData.first;\n      Diag(I->second, diag::note_previous_definition);\n      Invalid = true;\n    }\n    PreviousRedeclTypes[TyData.first.getCanonicalType()] = TyData.second;\n    auto *DRD = OMPDeclareReductionDecl::Create(Context, DC, TyData.second,\n                                                Name, TyData.first, PrevDRD);\n    DC->addDecl(DRD);\n    DRD->setAccess(AS);\n    Decls.push_back(DRD);\n    if (Invalid)\n      DRD->setInvalidDecl();\n    else\n      PrevDRD = DRD;\n  }\n\n  return DeclGroupPtrTy::make(\n      DeclGroupRef::Create(Context, Decls.begin(), Decls.size()));\n}\n\nvoid Sema::ActOnOpenMPDeclareReductionCombinerStart(Scope *S, Decl *D) {\n  auto *DRD = cast<OMPDeclareReductionDecl>(D);\n\n  // Enter new function scope.\n  PushFunctionScope();\n  setFunctionHasBranchProtectedScope();\n  getCurFunction()->setHasOMPDeclareReductionCombiner();\n\n  if (S != nullptr)\n    PushDeclContext(S, DRD);\n  else\n    CurContext = DRD;\n\n  PushExpressionEvaluationContext(\n      ExpressionEvaluationContext::PotentiallyEvaluated);\n\n  QualType ReductionType = DRD->getType();\n  // Create 'T* omp_parm;T omp_in;'. All references to 'omp_in' will\n  // be replaced by '*omp_parm' during codegen. This required because 'omp_in'\n  // uses semantics of argument handles by value, but it should be passed by\n  // reference. C lang does not support references, so pass all parameters as\n  // pointers.\n  // Create 'T omp_in;' variable.\n  VarDecl *OmpInParm =\n      buildVarDecl(*this, D->getLocation(), ReductionType, \"omp_in\");\n  // Create 'T* omp_parm;T omp_out;'. All references to 'omp_out' will\n  // be replaced by '*omp_parm' during codegen. This required because 'omp_out'\n  // uses semantics of argument handles by value, but it should be passed by\n  // reference. C lang does not support references, so pass all parameters as\n  // pointers.\n  // Create 'T omp_out;' variable.\n  VarDecl *OmpOutParm =\n      buildVarDecl(*this, D->getLocation(), ReductionType, \"omp_out\");\n  if (S != nullptr) {\n    PushOnScopeChains(OmpInParm, S);\n    PushOnScopeChains(OmpOutParm, S);\n  } else {\n    DRD->addDecl(OmpInParm);\n    DRD->addDecl(OmpOutParm);\n  }\n  Expr *InE =\n      ::buildDeclRefExpr(*this, OmpInParm, ReductionType, D->getLocation());\n  Expr *OutE =\n      ::buildDeclRefExpr(*this, OmpOutParm, ReductionType, D->getLocation());\n  DRD->setCombinerData(InE, OutE);\n}\n\nvoid Sema::ActOnOpenMPDeclareReductionCombinerEnd(Decl *D, Expr *Combiner) {\n  auto *DRD = cast<OMPDeclareReductionDecl>(D);\n  DiscardCleanupsInEvaluationContext();\n  PopExpressionEvaluationContext();\n\n  PopDeclContext();\n  PopFunctionScopeInfo();\n\n  if (Combiner != nullptr)\n    DRD->setCombiner(Combiner);\n  else\n    DRD->setInvalidDecl();\n}\n\nVarDecl *Sema::ActOnOpenMPDeclareReductionInitializerStart(Scope *S, Decl *D) {\n  auto *DRD = cast<OMPDeclareReductionDecl>(D);\n\n  // Enter new function scope.\n  PushFunctionScope();\n  setFunctionHasBranchProtectedScope();\n\n  if (S != nullptr)\n    PushDeclContext(S, DRD);\n  else\n    CurContext = DRD;\n\n  PushExpressionEvaluationContext(\n      ExpressionEvaluationContext::PotentiallyEvaluated);\n\n  QualType ReductionType = DRD->getType();\n  // Create 'T* omp_parm;T omp_priv;'. All references to 'omp_priv' will\n  // be replaced by '*omp_parm' during codegen. This required because 'omp_priv'\n  // uses semantics of argument handles by value, but it should be passed by\n  // reference. C lang does not support references, so pass all parameters as\n  // pointers.\n  // Create 'T omp_priv;' variable.\n  VarDecl *OmpPrivParm =\n      buildVarDecl(*this, D->getLocation(), ReductionType, \"omp_priv\");\n  // Create 'T* omp_parm;T omp_orig;'. All references to 'omp_orig' will\n  // be replaced by '*omp_parm' during codegen. This required because 'omp_orig'\n  // uses semantics of argument handles by value, but it should be passed by\n  // reference. C lang does not support references, so pass all parameters as\n  // pointers.\n  // Create 'T omp_orig;' variable.\n  VarDecl *OmpOrigParm =\n      buildVarDecl(*this, D->getLocation(), ReductionType, \"omp_orig\");\n  if (S != nullptr) {\n    PushOnScopeChains(OmpPrivParm, S);\n    PushOnScopeChains(OmpOrigParm, S);\n  } else {\n    DRD->addDecl(OmpPrivParm);\n    DRD->addDecl(OmpOrigParm);\n  }\n  Expr *OrigE =\n      ::buildDeclRefExpr(*this, OmpOrigParm, ReductionType, D->getLocation());\n  Expr *PrivE =\n      ::buildDeclRefExpr(*this, OmpPrivParm, ReductionType, D->getLocation());\n  DRD->setInitializerData(OrigE, PrivE);\n  return OmpPrivParm;\n}\n\nvoid Sema::ActOnOpenMPDeclareReductionInitializerEnd(Decl *D, Expr *Initializer,\n                                                     VarDecl *OmpPrivParm) {\n  auto *DRD = cast<OMPDeclareReductionDecl>(D);\n  DiscardCleanupsInEvaluationContext();\n  PopExpressionEvaluationContext();\n\n  PopDeclContext();\n  PopFunctionScopeInfo();\n\n  if (Initializer != nullptr) {\n    DRD->setInitializer(Initializer, OMPDeclareReductionDecl::CallInit);\n  } else if (OmpPrivParm->hasInit()) {\n    DRD->setInitializer(OmpPrivParm->getInit(),\n                        OmpPrivParm->isDirectInit()\n                            ? OMPDeclareReductionDecl::DirectInit\n                            : OMPDeclareReductionDecl::CopyInit);\n  } else {\n    DRD->setInvalidDecl();\n  }\n}\n\nSema::DeclGroupPtrTy Sema::ActOnOpenMPDeclareReductionDirectiveEnd(\n    Scope *S, DeclGroupPtrTy DeclReductions, bool IsValid) {\n  for (Decl *D : DeclReductions.get()) {\n    if (IsValid) {\n      if (S)\n        PushOnScopeChains(cast<OMPDeclareReductionDecl>(D), S,\n                          /*AddToContext=*/false);\n    } else {\n      D->setInvalidDecl();\n    }\n  }\n  return DeclReductions;\n}\n\nTypeResult Sema::ActOnOpenMPDeclareMapperVarDecl(Scope *S, Declarator &D) {\n  TypeSourceInfo *TInfo = GetTypeForDeclarator(D, S);\n  QualType T = TInfo->getType();\n  if (D.isInvalidType())\n    return true;\n\n  if (getLangOpts().CPlusPlus) {\n    // Check that there are no default arguments (C++ only).\n    CheckExtraCXXDefaultArguments(D);\n  }\n\n  return CreateParsedType(T, TInfo);\n}\n\nQualType Sema::ActOnOpenMPDeclareMapperType(SourceLocation TyLoc,\n                                            TypeResult ParsedType) {\n  assert(ParsedType.isUsable() && \"Expect usable parsed mapper type\");\n\n  QualType MapperType = GetTypeFromParser(ParsedType.get());\n  assert(!MapperType.isNull() && \"Expect valid mapper type\");\n\n  // [OpenMP 5.0], 2.19.7.3 declare mapper Directive, Restrictions\n  //  The type must be of struct, union or class type in C and C++\n  if (!MapperType->isStructureOrClassType() && !MapperType->isUnionType()) {\n    Diag(TyLoc, diag::err_omp_mapper_wrong_type);\n    return QualType();\n  }\n  return MapperType;\n}\n\nSema::DeclGroupPtrTy Sema::ActOnOpenMPDeclareMapperDirective(\n    Scope *S, DeclContext *DC, DeclarationName Name, QualType MapperType,\n    SourceLocation StartLoc, DeclarationName VN, AccessSpecifier AS,\n    Expr *MapperVarRef, ArrayRef<OMPClause *> Clauses, Decl *PrevDeclInScope) {\n  LookupResult Lookup(*this, Name, SourceLocation(), LookupOMPMapperName,\n                      forRedeclarationInCurContext());\n  // [OpenMP 5.0], 2.19.7.3 declare mapper Directive, Restrictions\n  //  A mapper-identifier may not be redeclared in the current scope for the\n  //  same type or for a type that is compatible according to the base language\n  //  rules.\n  llvm::DenseMap<QualType, SourceLocation> PreviousRedeclTypes;\n  OMPDeclareMapperDecl *PrevDMD = nullptr;\n  bool InCompoundScope = true;\n  if (S != nullptr) {\n    // Find previous declaration with the same name not referenced in other\n    // declarations.\n    FunctionScopeInfo *ParentFn = getEnclosingFunction();\n    InCompoundScope =\n        (ParentFn != nullptr) && !ParentFn->CompoundScopes.empty();\n    LookupName(Lookup, S);\n    FilterLookupForScope(Lookup, DC, S, /*ConsiderLinkage=*/false,\n                         /*AllowInlineNamespace=*/false);\n    llvm::DenseMap<OMPDeclareMapperDecl *, bool> UsedAsPrevious;\n    LookupResult::Filter Filter = Lookup.makeFilter();\n    while (Filter.hasNext()) {\n      auto *PrevDecl = cast<OMPDeclareMapperDecl>(Filter.next());\n      if (InCompoundScope) {\n        auto I = UsedAsPrevious.find(PrevDecl);\n        if (I == UsedAsPrevious.end())\n          UsedAsPrevious[PrevDecl] = false;\n        if (OMPDeclareMapperDecl *D = PrevDecl->getPrevDeclInScope())\n          UsedAsPrevious[D] = true;\n      }\n      PreviousRedeclTypes[PrevDecl->getType().getCanonicalType()] =\n          PrevDecl->getLocation();\n    }\n    Filter.done();\n    if (InCompoundScope) {\n      for (const auto &PrevData : UsedAsPrevious) {\n        if (!PrevData.second) {\n          PrevDMD = PrevData.first;\n          break;\n        }\n      }\n    }\n  } else if (PrevDeclInScope) {\n    auto *PrevDMDInScope = PrevDMD =\n        cast<OMPDeclareMapperDecl>(PrevDeclInScope);\n    do {\n      PreviousRedeclTypes[PrevDMDInScope->getType().getCanonicalType()] =\n          PrevDMDInScope->getLocation();\n      PrevDMDInScope = PrevDMDInScope->getPrevDeclInScope();\n    } while (PrevDMDInScope != nullptr);\n  }\n  const auto I = PreviousRedeclTypes.find(MapperType.getCanonicalType());\n  bool Invalid = false;\n  if (I != PreviousRedeclTypes.end()) {\n    Diag(StartLoc, diag::err_omp_declare_mapper_redefinition)\n        << MapperType << Name;\n    Diag(I->second, diag::note_previous_definition);\n    Invalid = true;\n  }\n  auto *DMD = OMPDeclareMapperDecl::Create(Context, DC, StartLoc, Name,\n                                           MapperType, VN, Clauses, PrevDMD);\n  if (S)\n    PushOnScopeChains(DMD, S);\n  else\n    DC->addDecl(DMD);\n  DMD->setAccess(AS);\n  if (Invalid)\n    DMD->setInvalidDecl();\n\n  auto *VD = cast<DeclRefExpr>(MapperVarRef)->getDecl();\n  VD->setDeclContext(DMD);\n  VD->setLexicalDeclContext(DMD);\n  DMD->addDecl(VD);\n  DMD->setMapperVarRef(MapperVarRef);\n\n  return DeclGroupPtrTy::make(DeclGroupRef(DMD));\n}\n\nExprResult\nSema::ActOnOpenMPDeclareMapperDirectiveVarDecl(Scope *S, QualType MapperType,\n                                               SourceLocation StartLoc,\n                                               DeclarationName VN) {\n  TypeSourceInfo *TInfo =\n      Context.getTrivialTypeSourceInfo(MapperType, StartLoc);\n  auto *VD = VarDecl::Create(Context, Context.getTranslationUnitDecl(),\n                             StartLoc, StartLoc, VN.getAsIdentifierInfo(),\n                             MapperType, TInfo, SC_None);\n  if (S)\n    PushOnScopeChains(VD, S, /*AddToContext=*/false);\n  Expr *E = buildDeclRefExpr(*this, VD, MapperType, StartLoc);\n  DSAStack->addDeclareMapperVarRef(E);\n  return E;\n}\n\nbool Sema::isOpenMPDeclareMapperVarDeclAllowed(const VarDecl *VD) const {\n  assert(LangOpts.OpenMP && \"Expected OpenMP mode.\");\n  const Expr *Ref = DSAStack->getDeclareMapperVarRef();\n  if (const auto *DRE = cast_or_null<DeclRefExpr>(Ref))\n    return VD->getCanonicalDecl() == DRE->getDecl()->getCanonicalDecl();\n  return true;\n}\n\nconst ValueDecl *Sema::getOpenMPDeclareMapperVarName() const {\n  assert(LangOpts.OpenMP && \"Expected OpenMP mode.\");\n  return cast<DeclRefExpr>(DSAStack->getDeclareMapperVarRef())->getDecl();\n}\n\nOMPClause *Sema::ActOnOpenMPNumTeamsClause(Expr *NumTeams,\n                                           SourceLocation StartLoc,\n                                           SourceLocation LParenLoc,\n                                           SourceLocation EndLoc) {\n  Expr *ValExpr = NumTeams;\n  Stmt *HelperValStmt = nullptr;\n\n  // OpenMP [teams Constrcut, Restrictions]\n  // The num_teams expression must evaluate to a positive integer value.\n  if (!isNonNegativeIntegerValue(ValExpr, *this, OMPC_num_teams,\n                                 /*StrictlyPositive=*/true))\n    return nullptr;\n\n  OpenMPDirectiveKind DKind = DSAStack->getCurrentDirective();\n  OpenMPDirectiveKind CaptureRegion =\n      getOpenMPCaptureRegionForClause(DKind, OMPC_num_teams, LangOpts.OpenMP);\n  if (CaptureRegion != OMPD_unknown && !CurContext->isDependentContext()) {\n    ValExpr = MakeFullExpr(ValExpr).get();\n    llvm::MapVector<const Expr *, DeclRefExpr *> Captures;\n    ValExpr = tryBuildCapture(*this, ValExpr, Captures).get();\n    HelperValStmt = buildPreInits(Context, Captures);\n  }\n\n  return new (Context) OMPNumTeamsClause(ValExpr, HelperValStmt, CaptureRegion,\n                                         StartLoc, LParenLoc, EndLoc);\n}\n\nOMPClause *Sema::ActOnOpenMPThreadLimitClause(Expr *ThreadLimit,\n                                              SourceLocation StartLoc,\n                                              SourceLocation LParenLoc,\n                                              SourceLocation EndLoc) {\n  Expr *ValExpr = ThreadLimit;\n  Stmt *HelperValStmt = nullptr;\n\n  // OpenMP [teams Constrcut, Restrictions]\n  // The thread_limit expression must evaluate to a positive integer value.\n  if (!isNonNegativeIntegerValue(ValExpr, *this, OMPC_thread_limit,\n                                 /*StrictlyPositive=*/true))\n    return nullptr;\n\n  OpenMPDirectiveKind DKind = DSAStack->getCurrentDirective();\n  OpenMPDirectiveKind CaptureRegion = getOpenMPCaptureRegionForClause(\n      DKind, OMPC_thread_limit, LangOpts.OpenMP);\n  if (CaptureRegion != OMPD_unknown && !CurContext->isDependentContext()) {\n    ValExpr = MakeFullExpr(ValExpr).get();\n    llvm::MapVector<const Expr *, DeclRefExpr *> Captures;\n    ValExpr = tryBuildCapture(*this, ValExpr, Captures).get();\n    HelperValStmt = buildPreInits(Context, Captures);\n  }\n\n  return new (Context) OMPThreadLimitClause(\n      ValExpr, HelperValStmt, CaptureRegion, StartLoc, LParenLoc, EndLoc);\n}\n\nOMPClause *Sema::ActOnOpenMPPriorityClause(Expr *Priority,\n                                           SourceLocation StartLoc,\n                                           SourceLocation LParenLoc,\n                                           SourceLocation EndLoc) {\n  Expr *ValExpr = Priority;\n  Stmt *HelperValStmt = nullptr;\n  OpenMPDirectiveKind CaptureRegion = OMPD_unknown;\n\n  // OpenMP [2.9.1, task Constrcut]\n  // The priority-value is a non-negative numerical scalar expression.\n  if (!isNonNegativeIntegerValue(\n          ValExpr, *this, OMPC_priority,\n          /*StrictlyPositive=*/false, /*BuildCapture=*/true,\n          DSAStack->getCurrentDirective(), &CaptureRegion, &HelperValStmt))\n    return nullptr;\n\n  return new (Context) OMPPriorityClause(ValExpr, HelperValStmt, CaptureRegion,\n                                         StartLoc, LParenLoc, EndLoc);\n}\n\nOMPClause *Sema::ActOnOpenMPGrainsizeClause(Expr *Grainsize,\n                                            SourceLocation StartLoc,\n                                            SourceLocation LParenLoc,\n                                            SourceLocation EndLoc) {\n  Expr *ValExpr = Grainsize;\n  Stmt *HelperValStmt = nullptr;\n  OpenMPDirectiveKind CaptureRegion = OMPD_unknown;\n\n  // OpenMP [2.9.2, taskloop Constrcut]\n  // The parameter of the grainsize clause must be a positive integer\n  // expression.\n  if (!isNonNegativeIntegerValue(\n          ValExpr, *this, OMPC_grainsize,\n          /*StrictlyPositive=*/true, /*BuildCapture=*/true,\n          DSAStack->getCurrentDirective(), &CaptureRegion, &HelperValStmt))\n    return nullptr;\n\n  return new (Context) OMPGrainsizeClause(ValExpr, HelperValStmt, CaptureRegion,\n                                          StartLoc, LParenLoc, EndLoc);\n}\n\nOMPClause *Sema::ActOnOpenMPNumTasksClause(Expr *NumTasks,\n                                           SourceLocation StartLoc,\n                                           SourceLocation LParenLoc,\n                                           SourceLocation EndLoc) {\n  Expr *ValExpr = NumTasks;\n  Stmt *HelperValStmt = nullptr;\n  OpenMPDirectiveKind CaptureRegion = OMPD_unknown;\n\n  // OpenMP [2.9.2, taskloop Constrcut]\n  // The parameter of the num_tasks clause must be a positive integer\n  // expression.\n  if (!isNonNegativeIntegerValue(\n          ValExpr, *this, OMPC_num_tasks,\n          /*StrictlyPositive=*/true, /*BuildCapture=*/true,\n          DSAStack->getCurrentDirective(), &CaptureRegion, &HelperValStmt))\n    return nullptr;\n\n  return new (Context) OMPNumTasksClause(ValExpr, HelperValStmt, CaptureRegion,\n                                         StartLoc, LParenLoc, EndLoc);\n}\n\nOMPClause *Sema::ActOnOpenMPHintClause(Expr *Hint, SourceLocation StartLoc,\n                                       SourceLocation LParenLoc,\n                                       SourceLocation EndLoc) {\n  // OpenMP [2.13.2, critical construct, Description]\n  // ... where hint-expression is an integer constant expression that evaluates\n  // to a valid lock hint.\n  ExprResult HintExpr = VerifyPositiveIntegerConstantInClause(Hint, OMPC_hint);\n  if (HintExpr.isInvalid())\n    return nullptr;\n  return new (Context)\n      OMPHintClause(HintExpr.get(), StartLoc, LParenLoc, EndLoc);\n}\n\n/// Tries to find omp_event_handle_t type.\nstatic bool findOMPEventHandleT(Sema &S, SourceLocation Loc,\n                                DSAStackTy *Stack) {\n  QualType OMPEventHandleT = Stack->getOMPEventHandleT();\n  if (!OMPEventHandleT.isNull())\n    return true;\n  IdentifierInfo *II = &S.PP.getIdentifierTable().get(\"omp_event_handle_t\");\n  ParsedType PT = S.getTypeName(*II, Loc, S.getCurScope());\n  if (!PT.getAsOpaquePtr() || PT.get().isNull()) {\n    S.Diag(Loc, diag::err_omp_implied_type_not_found) << \"omp_event_handle_t\";\n    return false;\n  }\n  Stack->setOMPEventHandleT(PT.get());\n  return true;\n}\n\nOMPClause *Sema::ActOnOpenMPDetachClause(Expr *Evt, SourceLocation StartLoc,\n                                         SourceLocation LParenLoc,\n                                         SourceLocation EndLoc) {\n  if (!Evt->isValueDependent() && !Evt->isTypeDependent() &&\n      !Evt->isInstantiationDependent() &&\n      !Evt->containsUnexpandedParameterPack()) {\n    if (!findOMPEventHandleT(*this, Evt->getExprLoc(), DSAStack))\n      return nullptr;\n    // OpenMP 5.0, 2.10.1 task Construct.\n    // event-handle is a variable of the omp_event_handle_t type.\n    auto *Ref = dyn_cast<DeclRefExpr>(Evt->IgnoreParenImpCasts());\n    if (!Ref) {\n      Diag(Evt->getExprLoc(), diag::err_omp_var_expected)\n          << \"omp_event_handle_t\" << 0 << Evt->getSourceRange();\n      return nullptr;\n    }\n    auto *VD = dyn_cast_or_null<VarDecl>(Ref->getDecl());\n    if (!VD) {\n      Diag(Evt->getExprLoc(), diag::err_omp_var_expected)\n          << \"omp_event_handle_t\" << 0 << Evt->getSourceRange();\n      return nullptr;\n    }\n    if (!Context.hasSameUnqualifiedType(DSAStack->getOMPEventHandleT(),\n                                        VD->getType()) ||\n        VD->getType().isConstant(Context)) {\n      Diag(Evt->getExprLoc(), diag::err_omp_var_expected)\n          << \"omp_event_handle_t\" << 1 << VD->getType()\n          << Evt->getSourceRange();\n      return nullptr;\n    }\n    // OpenMP 5.0, 2.10.1 task Construct\n    // [detach clause]... The event-handle will be considered as if it was\n    // specified on a firstprivate clause.\n    DSAStackTy::DSAVarData DVar = DSAStack->getTopDSA(VD, /*FromParent=*/false);\n    if (DVar.CKind != OMPC_unknown && DVar.CKind != OMPC_firstprivate &&\n        DVar.RefExpr) {\n      Diag(Evt->getExprLoc(), diag::err_omp_wrong_dsa)\n          << getOpenMPClauseName(DVar.CKind)\n          << getOpenMPClauseName(OMPC_firstprivate);\n      reportOriginalDsa(*this, DSAStack, VD, DVar);\n      return nullptr;\n    }\n  }\n\n  return new (Context) OMPDetachClause(Evt, StartLoc, LParenLoc, EndLoc);\n}\n\nOMPClause *Sema::ActOnOpenMPDistScheduleClause(\n    OpenMPDistScheduleClauseKind Kind, Expr *ChunkSize, SourceLocation StartLoc,\n    SourceLocation LParenLoc, SourceLocation KindLoc, SourceLocation CommaLoc,\n    SourceLocation EndLoc) {\n  if (Kind == OMPC_DIST_SCHEDULE_unknown) {\n    std::string Values;\n    Values += \"'\";\n    Values += getOpenMPSimpleClauseTypeName(OMPC_dist_schedule, 0);\n    Values += \"'\";\n    Diag(KindLoc, diag::err_omp_unexpected_clause_value)\n        << Values << getOpenMPClauseName(OMPC_dist_schedule);\n    return nullptr;\n  }\n  Expr *ValExpr = ChunkSize;\n  Stmt *HelperValStmt = nullptr;\n  if (ChunkSize) {\n    if (!ChunkSize->isValueDependent() && !ChunkSize->isTypeDependent() &&\n        !ChunkSize->isInstantiationDependent() &&\n        !ChunkSize->containsUnexpandedParameterPack()) {\n      SourceLocation ChunkSizeLoc = ChunkSize->getBeginLoc();\n      ExprResult Val =\n          PerformOpenMPImplicitIntegerConversion(ChunkSizeLoc, ChunkSize);\n      if (Val.isInvalid())\n        return nullptr;\n\n      ValExpr = Val.get();\n\n      // OpenMP [2.7.1, Restrictions]\n      //  chunk_size must be a loop invariant integer expression with a positive\n      //  value.\n      if (Optional<llvm::APSInt> Result =\n              ValExpr->getIntegerConstantExpr(Context)) {\n        if (Result->isSigned() && !Result->isStrictlyPositive()) {\n          Diag(ChunkSizeLoc, diag::err_omp_negative_expression_in_clause)\n              << \"dist_schedule\" << ChunkSize->getSourceRange();\n          return nullptr;\n        }\n      } else if (getOpenMPCaptureRegionForClause(\n                     DSAStack->getCurrentDirective(), OMPC_dist_schedule,\n                     LangOpts.OpenMP) != OMPD_unknown &&\n                 !CurContext->isDependentContext()) {\n        ValExpr = MakeFullExpr(ValExpr).get();\n        llvm::MapVector<const Expr *, DeclRefExpr *> Captures;\n        ValExpr = tryBuildCapture(*this, ValExpr, Captures).get();\n        HelperValStmt = buildPreInits(Context, Captures);\n      }\n    }\n  }\n\n  return new (Context)\n      OMPDistScheduleClause(StartLoc, LParenLoc, KindLoc, CommaLoc, EndLoc,\n                            Kind, ValExpr, HelperValStmt);\n}\n\nOMPClause *Sema::ActOnOpenMPDefaultmapClause(\n    OpenMPDefaultmapClauseModifier M, OpenMPDefaultmapClauseKind Kind,\n    SourceLocation StartLoc, SourceLocation LParenLoc, SourceLocation MLoc,\n    SourceLocation KindLoc, SourceLocation EndLoc) {\n  if (getLangOpts().OpenMP < 50) {\n    if (M != OMPC_DEFAULTMAP_MODIFIER_tofrom ||\n        Kind != OMPC_DEFAULTMAP_scalar) {\n      std::string Value;\n      SourceLocation Loc;\n      Value += \"'\";\n      if (M != OMPC_DEFAULTMAP_MODIFIER_tofrom) {\n        Value += getOpenMPSimpleClauseTypeName(OMPC_defaultmap,\n                                               OMPC_DEFAULTMAP_MODIFIER_tofrom);\n        Loc = MLoc;\n      } else {\n        Value += getOpenMPSimpleClauseTypeName(OMPC_defaultmap,\n                                               OMPC_DEFAULTMAP_scalar);\n        Loc = KindLoc;\n      }\n      Value += \"'\";\n      Diag(Loc, diag::err_omp_unexpected_clause_value)\n          << Value << getOpenMPClauseName(OMPC_defaultmap);\n      return nullptr;\n    }\n  } else {\n    bool isDefaultmapModifier = (M != OMPC_DEFAULTMAP_MODIFIER_unknown);\n    bool isDefaultmapKind = (Kind != OMPC_DEFAULTMAP_unknown) ||\n                            (LangOpts.OpenMP >= 50 && KindLoc.isInvalid());\n    if (!isDefaultmapKind || !isDefaultmapModifier) {\n      StringRef KindValue = \"'scalar', 'aggregate', 'pointer'\";\n      if (LangOpts.OpenMP == 50) {\n        StringRef ModifierValue = \"'alloc', 'from', 'to', 'tofrom', \"\n                                  \"'firstprivate', 'none', 'default'\";\n        if (!isDefaultmapKind && isDefaultmapModifier) {\n          Diag(KindLoc, diag::err_omp_unexpected_clause_value)\n              << KindValue << getOpenMPClauseName(OMPC_defaultmap);\n        } else if (isDefaultmapKind && !isDefaultmapModifier) {\n          Diag(MLoc, diag::err_omp_unexpected_clause_value)\n              << ModifierValue << getOpenMPClauseName(OMPC_defaultmap);\n        } else {\n          Diag(MLoc, diag::err_omp_unexpected_clause_value)\n              << ModifierValue << getOpenMPClauseName(OMPC_defaultmap);\n          Diag(KindLoc, diag::err_omp_unexpected_clause_value)\n              << KindValue << getOpenMPClauseName(OMPC_defaultmap);\n        }\n      } else {\n        StringRef ModifierValue =\n            \"'alloc', 'from', 'to', 'tofrom', \"\n            \"'firstprivate', 'none', 'default', 'present'\";\n        if (!isDefaultmapKind && isDefaultmapModifier) {\n          Diag(KindLoc, diag::err_omp_unexpected_clause_value)\n              << KindValue << getOpenMPClauseName(OMPC_defaultmap);\n        } else if (isDefaultmapKind && !isDefaultmapModifier) {\n          Diag(MLoc, diag::err_omp_unexpected_clause_value)\n              << ModifierValue << getOpenMPClauseName(OMPC_defaultmap);\n        } else {\n          Diag(MLoc, diag::err_omp_unexpected_clause_value)\n              << ModifierValue << getOpenMPClauseName(OMPC_defaultmap);\n          Diag(KindLoc, diag::err_omp_unexpected_clause_value)\n              << KindValue << getOpenMPClauseName(OMPC_defaultmap);\n        }\n      }\n      return nullptr;\n    }\n\n    // OpenMP [5.0, 2.12.5, Restrictions, p. 174]\n    //  At most one defaultmap clause for each category can appear on the\n    //  directive.\n    if (DSAStack->checkDefaultmapCategory(Kind)) {\n      Diag(StartLoc, diag::err_omp_one_defaultmap_each_category);\n      return nullptr;\n    }\n  }\n  if (Kind == OMPC_DEFAULTMAP_unknown) {\n    // Variable category is not specified - mark all categories.\n    DSAStack->setDefaultDMAAttr(M, OMPC_DEFAULTMAP_aggregate, StartLoc);\n    DSAStack->setDefaultDMAAttr(M, OMPC_DEFAULTMAP_scalar, StartLoc);\n    DSAStack->setDefaultDMAAttr(M, OMPC_DEFAULTMAP_pointer, StartLoc);\n  } else {\n    DSAStack->setDefaultDMAAttr(M, Kind, StartLoc);\n  }\n\n  return new (Context)\n      OMPDefaultmapClause(StartLoc, LParenLoc, MLoc, KindLoc, EndLoc, Kind, M);\n}\n\nbool Sema::ActOnStartOpenMPDeclareTargetDirective(SourceLocation Loc) {\n  DeclContext *CurLexicalContext = getCurLexicalContext();\n  if (!CurLexicalContext->isFileContext() &&\n      !CurLexicalContext->isExternCContext() &&\n      !CurLexicalContext->isExternCXXContext() &&\n      !isa<CXXRecordDecl>(CurLexicalContext) &&\n      !isa<ClassTemplateDecl>(CurLexicalContext) &&\n      !isa<ClassTemplatePartialSpecializationDecl>(CurLexicalContext) &&\n      !isa<ClassTemplateSpecializationDecl>(CurLexicalContext)) {\n    Diag(Loc, diag::err_omp_region_not_file_context);\n    return false;\n  }\n  DeclareTargetNesting.push_back(Loc);\n  return true;\n}\n\nvoid Sema::ActOnFinishOpenMPDeclareTargetDirective() {\n  assert(!DeclareTargetNesting.empty() &&\n         \"Unexpected ActOnFinishOpenMPDeclareTargetDirective\");\n  DeclareTargetNesting.pop_back();\n}\n\nNamedDecl *\nSema::lookupOpenMPDeclareTargetName(Scope *CurScope, CXXScopeSpec &ScopeSpec,\n                                    const DeclarationNameInfo &Id,\n                                    NamedDeclSetType &SameDirectiveDecls) {\n  LookupResult Lookup(*this, Id, LookupOrdinaryName);\n  LookupParsedName(Lookup, CurScope, &ScopeSpec, true);\n\n  if (Lookup.isAmbiguous())\n    return nullptr;\n  Lookup.suppressDiagnostics();\n\n  if (!Lookup.isSingleResult()) {\n    VarOrFuncDeclFilterCCC CCC(*this);\n    if (TypoCorrection Corrected =\n            CorrectTypo(Id, LookupOrdinaryName, CurScope, nullptr, CCC,\n                        CTK_ErrorRecovery)) {\n      diagnoseTypo(Corrected, PDiag(diag::err_undeclared_var_use_suggest)\n                                  << Id.getName());\n      checkDeclIsAllowedInOpenMPTarget(nullptr, Corrected.getCorrectionDecl());\n      return nullptr;\n    }\n\n    Diag(Id.getLoc(), diag::err_undeclared_var_use) << Id.getName();\n    return nullptr;\n  }\n\n  NamedDecl *ND = Lookup.getAsSingle<NamedDecl>();\n  if (!isa<VarDecl>(ND) && !isa<FunctionDecl>(ND) &&\n      !isa<FunctionTemplateDecl>(ND)) {\n    Diag(Id.getLoc(), diag::err_omp_invalid_target_decl) << Id.getName();\n    return nullptr;\n  }\n  if (!SameDirectiveDecls.insert(cast<NamedDecl>(ND->getCanonicalDecl())))\n    Diag(Id.getLoc(), diag::err_omp_declare_target_multiple) << Id.getName();\n  return ND;\n}\n\nvoid Sema::ActOnOpenMPDeclareTargetName(\n    NamedDecl *ND, SourceLocation Loc, OMPDeclareTargetDeclAttr::MapTypeTy MT,\n    OMPDeclareTargetDeclAttr::DevTypeTy DT) {\n  assert((isa<VarDecl>(ND) || isa<FunctionDecl>(ND) ||\n          isa<FunctionTemplateDecl>(ND)) &&\n         \"Expected variable, function or function template.\");\n\n  // Diagnose marking after use as it may lead to incorrect diagnosis and\n  // codegen.\n  if (LangOpts.OpenMP >= 50 &&\n      (ND->isUsed(/*CheckUsedAttr=*/false) || ND->isReferenced()))\n    Diag(Loc, diag::warn_omp_declare_target_after_first_use);\n\n  auto *VD = cast<ValueDecl>(ND);\n  Optional<OMPDeclareTargetDeclAttr::DevTypeTy> DevTy =\n      OMPDeclareTargetDeclAttr::getDeviceType(VD);\n  Optional<SourceLocation> AttrLoc = OMPDeclareTargetDeclAttr::getLocation(VD);\n  if (DevTy.hasValue() && *DevTy != DT &&\n      (DeclareTargetNesting.empty() ||\n       *AttrLoc != DeclareTargetNesting.back())) {\n    Diag(Loc, diag::err_omp_device_type_mismatch)\n        << OMPDeclareTargetDeclAttr::ConvertDevTypeTyToStr(DT)\n        << OMPDeclareTargetDeclAttr::ConvertDevTypeTyToStr(*DevTy);\n    return;\n  }\n  Optional<OMPDeclareTargetDeclAttr::MapTypeTy> Res =\n      OMPDeclareTargetDeclAttr::isDeclareTargetDeclaration(VD);\n  if (!Res || (!DeclareTargetNesting.empty() &&\n               *AttrLoc == DeclareTargetNesting.back())) {\n    auto *A = OMPDeclareTargetDeclAttr::CreateImplicit(\n        Context, MT, DT, DeclareTargetNesting.size() + 1,\n        SourceRange(Loc, Loc));\n    ND->addAttr(A);\n    if (ASTMutationListener *ML = Context.getASTMutationListener())\n      ML->DeclarationMarkedOpenMPDeclareTarget(ND, A);\n    checkDeclIsAllowedInOpenMPTarget(nullptr, ND, Loc);\n  } else if (*Res != MT) {\n    Diag(Loc, diag::err_omp_declare_target_to_and_link) << ND;\n  }\n}\n\nstatic void checkDeclInTargetContext(SourceLocation SL, SourceRange SR,\n                                     Sema &SemaRef, Decl *D) {\n  if (!D || !isa<VarDecl>(D))\n    return;\n  auto *VD = cast<VarDecl>(D);\n  Optional<OMPDeclareTargetDeclAttr::MapTypeTy> MapTy =\n      OMPDeclareTargetDeclAttr::isDeclareTargetDeclaration(VD);\n  if (SemaRef.LangOpts.OpenMP >= 50 &&\n      (SemaRef.getCurLambda(/*IgnoreNonLambdaCapturingScope=*/true) ||\n       SemaRef.getCurBlock() || SemaRef.getCurCapturedRegion()) &&\n      VD->hasGlobalStorage()) {\n    llvm::Optional<OMPDeclareTargetDeclAttr::MapTypeTy> MapTy =\n        OMPDeclareTargetDeclAttr::isDeclareTargetDeclaration(VD);\n    if (!MapTy || *MapTy != OMPDeclareTargetDeclAttr::MT_To) {\n      // OpenMP 5.0, 2.12.7 declare target Directive, Restrictions\n      // If a lambda declaration and definition appears between a\n      // declare target directive and the matching end declare target\n      // directive, all variables that are captured by the lambda\n      // expression must also appear in a to clause.\n      SemaRef.Diag(VD->getLocation(),\n                   diag::err_omp_lambda_capture_in_declare_target_not_to);\n      SemaRef.Diag(SL, diag::note_var_explicitly_captured_here)\n          << VD << 0 << SR;\n      return;\n    }\n  }\n  if (MapTy.hasValue())\n    return;\n  SemaRef.Diag(VD->getLocation(), diag::warn_omp_not_in_target_context);\n  SemaRef.Diag(SL, diag::note_used_here) << SR;\n}\n\nstatic bool checkValueDeclInTarget(SourceLocation SL, SourceRange SR,\n                                   Sema &SemaRef, DSAStackTy *Stack,\n                                   ValueDecl *VD) {\n  return OMPDeclareTargetDeclAttr::isDeclareTargetDeclaration(VD) ||\n         checkTypeMappable(SL, SR, SemaRef, Stack, VD->getType(),\n                           /*FullCheck=*/false);\n}\n\nvoid Sema::checkDeclIsAllowedInOpenMPTarget(Expr *E, Decl *D,\n                                            SourceLocation IdLoc) {\n  if (!D || D->isInvalidDecl())\n    return;\n  SourceRange SR = E ? E->getSourceRange() : D->getSourceRange();\n  SourceLocation SL = E ? E->getBeginLoc() : D->getLocation();\n  if (auto *VD = dyn_cast<VarDecl>(D)) {\n    // Only global variables can be marked as declare target.\n    if (!VD->isFileVarDecl() && !VD->isStaticLocal() &&\n        !VD->isStaticDataMember())\n      return;\n    // 2.10.6: threadprivate variable cannot appear in a declare target\n    // directive.\n    if (DSAStack->isThreadPrivate(VD)) {\n      Diag(SL, diag::err_omp_threadprivate_in_target);\n      reportOriginalDsa(*this, DSAStack, VD, DSAStack->getTopDSA(VD, false));\n      return;\n    }\n  }\n  if (const auto *FTD = dyn_cast<FunctionTemplateDecl>(D))\n    D = FTD->getTemplatedDecl();\n  if (auto *FD = dyn_cast<FunctionDecl>(D)) {\n    llvm::Optional<OMPDeclareTargetDeclAttr::MapTypeTy> Res =\n        OMPDeclareTargetDeclAttr::isDeclareTargetDeclaration(FD);\n    if (IdLoc.isValid() && Res && *Res == OMPDeclareTargetDeclAttr::MT_Link) {\n      Diag(IdLoc, diag::err_omp_function_in_link_clause);\n      Diag(FD->getLocation(), diag::note_defined_here) << FD;\n      return;\n    }\n  }\n  if (auto *VD = dyn_cast<ValueDecl>(D)) {\n    // Problem if any with var declared with incomplete type will be reported\n    // as normal, so no need to check it here.\n    if ((E || !VD->getType()->isIncompleteType()) &&\n        !checkValueDeclInTarget(SL, SR, *this, DSAStack, VD))\n      return;\n    if (!E && !OMPDeclareTargetDeclAttr::isDeclareTargetDeclaration(VD)) {\n      // Checking declaration inside declare target region.\n      if (isa<VarDecl>(D) || isa<FunctionDecl>(D) ||\n          isa<FunctionTemplateDecl>(D)) {\n        auto *A = OMPDeclareTargetDeclAttr::CreateImplicit(\n            Context, OMPDeclareTargetDeclAttr::MT_To,\n            OMPDeclareTargetDeclAttr::DT_Any, DeclareTargetNesting.size(),\n            SourceRange(DeclareTargetNesting.back(),\n                        DeclareTargetNesting.back()));\n        D->addAttr(A);\n        if (ASTMutationListener *ML = Context.getASTMutationListener())\n          ML->DeclarationMarkedOpenMPDeclareTarget(D, A);\n      }\n      return;\n    }\n  }\n  if (!E)\n    return;\n  checkDeclInTargetContext(E->getExprLoc(), E->getSourceRange(), *this, D);\n}\n\nOMPClause *Sema::ActOnOpenMPToClause(\n    ArrayRef<OpenMPMotionModifierKind> MotionModifiers,\n    ArrayRef<SourceLocation> MotionModifiersLoc,\n    CXXScopeSpec &MapperIdScopeSpec, DeclarationNameInfo &MapperId,\n    SourceLocation ColonLoc, ArrayRef<Expr *> VarList,\n    const OMPVarListLocTy &Locs, ArrayRef<Expr *> UnresolvedMappers) {\n  OpenMPMotionModifierKind Modifiers[] = {OMPC_MOTION_MODIFIER_unknown,\n                                          OMPC_MOTION_MODIFIER_unknown};\n  SourceLocation ModifiersLoc[NumberOfOMPMotionModifiers];\n\n  // Process motion-modifiers, flag errors for duplicate modifiers.\n  unsigned Count = 0;\n  for (unsigned I = 0, E = MotionModifiers.size(); I < E; ++I) {\n    if (MotionModifiers[I] != OMPC_MOTION_MODIFIER_unknown &&\n        llvm::find(Modifiers, MotionModifiers[I]) != std::end(Modifiers)) {\n      Diag(MotionModifiersLoc[I], diag::err_omp_duplicate_motion_modifier);\n      continue;\n    }\n    assert(Count < NumberOfOMPMotionModifiers &&\n           \"Modifiers exceed the allowed number of motion modifiers\");\n    Modifiers[Count] = MotionModifiers[I];\n    ModifiersLoc[Count] = MotionModifiersLoc[I];\n    ++Count;\n  }\n\n  MappableVarListInfo MVLI(VarList);\n  checkMappableExpressionList(*this, DSAStack, OMPC_to, MVLI, Locs.StartLoc,\n                              MapperIdScopeSpec, MapperId, UnresolvedMappers);\n  if (MVLI.ProcessedVarList.empty())\n    return nullptr;\n\n  return OMPToClause::Create(\n      Context, Locs, MVLI.ProcessedVarList, MVLI.VarBaseDeclarations,\n      MVLI.VarComponents, MVLI.UDMapperList, Modifiers, ModifiersLoc,\n      MapperIdScopeSpec.getWithLocInContext(Context), MapperId);\n}\n\nOMPClause *Sema::ActOnOpenMPFromClause(\n    ArrayRef<OpenMPMotionModifierKind> MotionModifiers,\n    ArrayRef<SourceLocation> MotionModifiersLoc,\n    CXXScopeSpec &MapperIdScopeSpec, DeclarationNameInfo &MapperId,\n    SourceLocation ColonLoc, ArrayRef<Expr *> VarList,\n    const OMPVarListLocTy &Locs, ArrayRef<Expr *> UnresolvedMappers) {\n  OpenMPMotionModifierKind Modifiers[] = {OMPC_MOTION_MODIFIER_unknown,\n                                          OMPC_MOTION_MODIFIER_unknown};\n  SourceLocation ModifiersLoc[NumberOfOMPMotionModifiers];\n\n  // Process motion-modifiers, flag errors for duplicate modifiers.\n  unsigned Count = 0;\n  for (unsigned I = 0, E = MotionModifiers.size(); I < E; ++I) {\n    if (MotionModifiers[I] != OMPC_MOTION_MODIFIER_unknown &&\n        llvm::find(Modifiers, MotionModifiers[I]) != std::end(Modifiers)) {\n      Diag(MotionModifiersLoc[I], diag::err_omp_duplicate_motion_modifier);\n      continue;\n    }\n    assert(Count < NumberOfOMPMotionModifiers &&\n           \"Modifiers exceed the allowed number of motion modifiers\");\n    Modifiers[Count] = MotionModifiers[I];\n    ModifiersLoc[Count] = MotionModifiersLoc[I];\n    ++Count;\n  }\n\n  MappableVarListInfo MVLI(VarList);\n  checkMappableExpressionList(*this, DSAStack, OMPC_from, MVLI, Locs.StartLoc,\n                              MapperIdScopeSpec, MapperId, UnresolvedMappers);\n  if (MVLI.ProcessedVarList.empty())\n    return nullptr;\n\n  return OMPFromClause::Create(\n      Context, Locs, MVLI.ProcessedVarList, MVLI.VarBaseDeclarations,\n      MVLI.VarComponents, MVLI.UDMapperList, Modifiers, ModifiersLoc,\n      MapperIdScopeSpec.getWithLocInContext(Context), MapperId);\n}\n\nOMPClause *Sema::ActOnOpenMPUseDevicePtrClause(ArrayRef<Expr *> VarList,\n                                               const OMPVarListLocTy &Locs) {\n  MappableVarListInfo MVLI(VarList);\n  SmallVector<Expr *, 8> PrivateCopies;\n  SmallVector<Expr *, 8> Inits;\n\n  for (Expr *RefExpr : VarList) {\n    assert(RefExpr && \"NULL expr in OpenMP use_device_ptr clause.\");\n    SourceLocation ELoc;\n    SourceRange ERange;\n    Expr *SimpleRefExpr = RefExpr;\n    auto Res = getPrivateItem(*this, SimpleRefExpr, ELoc, ERange);\n    if (Res.second) {\n      // It will be analyzed later.\n      MVLI.ProcessedVarList.push_back(RefExpr);\n      PrivateCopies.push_back(nullptr);\n      Inits.push_back(nullptr);\n    }\n    ValueDecl *D = Res.first;\n    if (!D)\n      continue;\n\n    QualType Type = D->getType();\n    Type = Type.getNonReferenceType().getUnqualifiedType();\n\n    auto *VD = dyn_cast<VarDecl>(D);\n\n    // Item should be a pointer or reference to pointer.\n    if (!Type->isPointerType()) {\n      Diag(ELoc, diag::err_omp_usedeviceptr_not_a_pointer)\n          << 0 << RefExpr->getSourceRange();\n      continue;\n    }\n\n    // Build the private variable and the expression that refers to it.\n    auto VDPrivate =\n        buildVarDecl(*this, ELoc, Type, D->getName(),\n                     D->hasAttrs() ? &D->getAttrs() : nullptr,\n                     VD ? cast<DeclRefExpr>(SimpleRefExpr) : nullptr);\n    if (VDPrivate->isInvalidDecl())\n      continue;\n\n    CurContext->addDecl(VDPrivate);\n    DeclRefExpr *VDPrivateRefExpr = buildDeclRefExpr(\n        *this, VDPrivate, RefExpr->getType().getUnqualifiedType(), ELoc);\n\n    // Add temporary variable to initialize the private copy of the pointer.\n    VarDecl *VDInit =\n        buildVarDecl(*this, RefExpr->getExprLoc(), Type, \".devptr.temp\");\n    DeclRefExpr *VDInitRefExpr = buildDeclRefExpr(\n        *this, VDInit, RefExpr->getType(), RefExpr->getExprLoc());\n    AddInitializerToDecl(VDPrivate,\n                         DefaultLvalueConversion(VDInitRefExpr).get(),\n                         /*DirectInit=*/false);\n\n    // If required, build a capture to implement the privatization initialized\n    // with the current list item value.\n    DeclRefExpr *Ref = nullptr;\n    if (!VD)\n      Ref = buildCapture(*this, D, SimpleRefExpr, /*WithInit=*/true);\n    MVLI.ProcessedVarList.push_back(VD ? RefExpr->IgnoreParens() : Ref);\n    PrivateCopies.push_back(VDPrivateRefExpr);\n    Inits.push_back(VDInitRefExpr);\n\n    // We need to add a data sharing attribute for this variable to make sure it\n    // is correctly captured. A variable that shows up in a use_device_ptr has\n    // similar properties of a first private variable.\n    DSAStack->addDSA(D, RefExpr->IgnoreParens(), OMPC_firstprivate, Ref);\n\n    // Create a mappable component for the list item. List items in this clause\n    // only need a component.\n    MVLI.VarBaseDeclarations.push_back(D);\n    MVLI.VarComponents.resize(MVLI.VarComponents.size() + 1);\n    MVLI.VarComponents.back().emplace_back(SimpleRefExpr, D,\n                                           /*IsNonContiguous=*/false);\n  }\n\n  if (MVLI.ProcessedVarList.empty())\n    return nullptr;\n\n  return OMPUseDevicePtrClause::Create(\n      Context, Locs, MVLI.ProcessedVarList, PrivateCopies, Inits,\n      MVLI.VarBaseDeclarations, MVLI.VarComponents);\n}\n\nOMPClause *Sema::ActOnOpenMPUseDeviceAddrClause(ArrayRef<Expr *> VarList,\n                                                const OMPVarListLocTy &Locs) {\n  MappableVarListInfo MVLI(VarList);\n\n  for (Expr *RefExpr : VarList) {\n    assert(RefExpr && \"NULL expr in OpenMP use_device_addr clause.\");\n    SourceLocation ELoc;\n    SourceRange ERange;\n    Expr *SimpleRefExpr = RefExpr;\n    auto Res = getPrivateItem(*this, SimpleRefExpr, ELoc, ERange,\n                              /*AllowArraySection=*/true);\n    if (Res.second) {\n      // It will be analyzed later.\n      MVLI.ProcessedVarList.push_back(RefExpr);\n    }\n    ValueDecl *D = Res.first;\n    if (!D)\n      continue;\n    auto *VD = dyn_cast<VarDecl>(D);\n\n    // If required, build a capture to implement the privatization initialized\n    // with the current list item value.\n    DeclRefExpr *Ref = nullptr;\n    if (!VD)\n      Ref = buildCapture(*this, D, SimpleRefExpr, /*WithInit=*/true);\n    MVLI.ProcessedVarList.push_back(VD ? RefExpr->IgnoreParens() : Ref);\n\n    // We need to add a data sharing attribute for this variable to make sure it\n    // is correctly captured. A variable that shows up in a use_device_addr has\n    // similar properties of a first private variable.\n    DSAStack->addDSA(D, RefExpr->IgnoreParens(), OMPC_firstprivate, Ref);\n\n    // Create a mappable component for the list item. List items in this clause\n    // only need a component.\n    MVLI.VarBaseDeclarations.push_back(D);\n    MVLI.VarComponents.emplace_back();\n    Expr *Component = SimpleRefExpr;\n    if (VD && (isa<OMPArraySectionExpr>(RefExpr->IgnoreParenImpCasts()) ||\n               isa<ArraySubscriptExpr>(RefExpr->IgnoreParenImpCasts())))\n      Component = DefaultFunctionArrayLvalueConversion(SimpleRefExpr).get();\n    MVLI.VarComponents.back().emplace_back(Component, D,\n                                           /*IsNonContiguous=*/false);\n  }\n\n  if (MVLI.ProcessedVarList.empty())\n    return nullptr;\n\n  return OMPUseDeviceAddrClause::Create(Context, Locs, MVLI.ProcessedVarList,\n                                        MVLI.VarBaseDeclarations,\n                                        MVLI.VarComponents);\n}\n\nOMPClause *Sema::ActOnOpenMPIsDevicePtrClause(ArrayRef<Expr *> VarList,\n                                              const OMPVarListLocTy &Locs) {\n  MappableVarListInfo MVLI(VarList);\n  for (Expr *RefExpr : VarList) {\n    assert(RefExpr && \"NULL expr in OpenMP is_device_ptr clause.\");\n    SourceLocation ELoc;\n    SourceRange ERange;\n    Expr *SimpleRefExpr = RefExpr;\n    auto Res = getPrivateItem(*this, SimpleRefExpr, ELoc, ERange);\n    if (Res.second) {\n      // It will be analyzed later.\n      MVLI.ProcessedVarList.push_back(RefExpr);\n    }\n    ValueDecl *D = Res.first;\n    if (!D)\n      continue;\n\n    QualType Type = D->getType();\n    // item should be a pointer or array or reference to pointer or array\n    if (!Type.getNonReferenceType()->isPointerType() &&\n        !Type.getNonReferenceType()->isArrayType()) {\n      Diag(ELoc, diag::err_omp_argument_type_isdeviceptr)\n          << 0 << RefExpr->getSourceRange();\n      continue;\n    }\n\n    // Check if the declaration in the clause does not show up in any data\n    // sharing attribute.\n    DSAStackTy::DSAVarData DVar = DSAStack->getTopDSA(D, /*FromParent=*/false);\n    if (isOpenMPPrivate(DVar.CKind)) {\n      Diag(ELoc, diag::err_omp_variable_in_given_clause_and_dsa)\n          << getOpenMPClauseName(DVar.CKind)\n          << getOpenMPClauseName(OMPC_is_device_ptr)\n          << getOpenMPDirectiveName(DSAStack->getCurrentDirective());\n      reportOriginalDsa(*this, DSAStack, D, DVar);\n      continue;\n    }\n\n    const Expr *ConflictExpr;\n    if (DSAStack->checkMappableExprComponentListsForDecl(\n            D, /*CurrentRegionOnly=*/true,\n            [&ConflictExpr](\n                OMPClauseMappableExprCommon::MappableExprComponentListRef R,\n                OpenMPClauseKind) -> bool {\n              ConflictExpr = R.front().getAssociatedExpression();\n              return true;\n            })) {\n      Diag(ELoc, diag::err_omp_map_shared_storage) << RefExpr->getSourceRange();\n      Diag(ConflictExpr->getExprLoc(), diag::note_used_here)\n          << ConflictExpr->getSourceRange();\n      continue;\n    }\n\n    // Store the components in the stack so that they can be used to check\n    // against other clauses later on.\n    OMPClauseMappableExprCommon::MappableComponent MC(\n        SimpleRefExpr, D, /*IsNonContiguous=*/false);\n    DSAStack->addMappableExpressionComponents(\n        D, MC, /*WhereFoundClauseKind=*/OMPC_is_device_ptr);\n\n    // Record the expression we've just processed.\n    MVLI.ProcessedVarList.push_back(SimpleRefExpr);\n\n    // Create a mappable component for the list item. List items in this clause\n    // only need a component. We use a null declaration to signal fields in\n    // 'this'.\n    assert((isa<DeclRefExpr>(SimpleRefExpr) ||\n            isa<CXXThisExpr>(cast<MemberExpr>(SimpleRefExpr)->getBase())) &&\n           \"Unexpected device pointer expression!\");\n    MVLI.VarBaseDeclarations.push_back(\n        isa<DeclRefExpr>(SimpleRefExpr) ? D : nullptr);\n    MVLI.VarComponents.resize(MVLI.VarComponents.size() + 1);\n    MVLI.VarComponents.back().push_back(MC);\n  }\n\n  if (MVLI.ProcessedVarList.empty())\n    return nullptr;\n\n  return OMPIsDevicePtrClause::Create(Context, Locs, MVLI.ProcessedVarList,\n                                      MVLI.VarBaseDeclarations,\n                                      MVLI.VarComponents);\n}\n\nOMPClause *Sema::ActOnOpenMPAllocateClause(\n    Expr *Allocator, ArrayRef<Expr *> VarList, SourceLocation StartLoc,\n    SourceLocation ColonLoc, SourceLocation LParenLoc, SourceLocation EndLoc) {\n  if (Allocator) {\n    // OpenMP [2.11.4 allocate Clause, Description]\n    // allocator is an expression of omp_allocator_handle_t type.\n    if (!findOMPAllocatorHandleT(*this, Allocator->getExprLoc(), DSAStack))\n      return nullptr;\n\n    ExprResult AllocatorRes = DefaultLvalueConversion(Allocator);\n    if (AllocatorRes.isInvalid())\n      return nullptr;\n    AllocatorRes = PerformImplicitConversion(AllocatorRes.get(),\n                                             DSAStack->getOMPAllocatorHandleT(),\n                                             Sema::AA_Initializing,\n                                             /*AllowExplicit=*/true);\n    if (AllocatorRes.isInvalid())\n      return nullptr;\n    Allocator = AllocatorRes.get();\n  } else {\n    // OpenMP 5.0, 2.11.4 allocate Clause, Restrictions.\n    // allocate clauses that appear on a target construct or on constructs in a\n    // target region must specify an allocator expression unless a requires\n    // directive with the dynamic_allocators clause is present in the same\n    // compilation unit.\n    if (LangOpts.OpenMPIsDevice &&\n        !DSAStack->hasRequiresDeclWithClause<OMPDynamicAllocatorsClause>())\n      targetDiag(StartLoc, diag::err_expected_allocator_expression);\n  }\n  // Analyze and build list of variables.\n  SmallVector<Expr *, 8> Vars;\n  for (Expr *RefExpr : VarList) {\n    assert(RefExpr && \"NULL expr in OpenMP private clause.\");\n    SourceLocation ELoc;\n    SourceRange ERange;\n    Expr *SimpleRefExpr = RefExpr;\n    auto Res = getPrivateItem(*this, SimpleRefExpr, ELoc, ERange);\n    if (Res.second) {\n      // It will be analyzed later.\n      Vars.push_back(RefExpr);\n    }\n    ValueDecl *D = Res.first;\n    if (!D)\n      continue;\n\n    auto *VD = dyn_cast<VarDecl>(D);\n    DeclRefExpr *Ref = nullptr;\n    if (!VD && !CurContext->isDependentContext())\n      Ref = buildCapture(*this, D, SimpleRefExpr, /*WithInit=*/false);\n    Vars.push_back((VD || CurContext->isDependentContext())\n                       ? RefExpr->IgnoreParens()\n                       : Ref);\n  }\n\n  if (Vars.empty())\n    return nullptr;\n\n  if (Allocator)\n    DSAStack->addInnerAllocatorExpr(Allocator);\n  return OMPAllocateClause::Create(Context, StartLoc, LParenLoc, Allocator,\n                                   ColonLoc, EndLoc, Vars);\n}\n\nOMPClause *Sema::ActOnOpenMPNontemporalClause(ArrayRef<Expr *> VarList,\n                                              SourceLocation StartLoc,\n                                              SourceLocation LParenLoc,\n                                              SourceLocation EndLoc) {\n  SmallVector<Expr *, 8> Vars;\n  for (Expr *RefExpr : VarList) {\n    assert(RefExpr && \"NULL expr in OpenMP nontemporal clause.\");\n    SourceLocation ELoc;\n    SourceRange ERange;\n    Expr *SimpleRefExpr = RefExpr;\n    auto Res = getPrivateItem(*this, SimpleRefExpr, ELoc, ERange);\n    if (Res.second)\n      // It will be analyzed later.\n      Vars.push_back(RefExpr);\n    ValueDecl *D = Res.first;\n    if (!D)\n      continue;\n\n    // OpenMP 5.0, 2.9.3.1 simd Construct, Restrictions.\n    // A list-item cannot appear in more than one nontemporal clause.\n    if (const Expr *PrevRef =\n            DSAStack->addUniqueNontemporal(D, SimpleRefExpr)) {\n      Diag(ELoc, diag::err_omp_used_in_clause_twice)\n          << 0 << getOpenMPClauseName(OMPC_nontemporal) << ERange;\n      Diag(PrevRef->getExprLoc(), diag::note_omp_explicit_dsa)\n          << getOpenMPClauseName(OMPC_nontemporal);\n      continue;\n    }\n\n    Vars.push_back(RefExpr);\n  }\n\n  if (Vars.empty())\n    return nullptr;\n\n  return OMPNontemporalClause::Create(Context, StartLoc, LParenLoc, EndLoc,\n                                      Vars);\n}\n\nOMPClause *Sema::ActOnOpenMPInclusiveClause(ArrayRef<Expr *> VarList,\n                                            SourceLocation StartLoc,\n                                            SourceLocation LParenLoc,\n                                            SourceLocation EndLoc) {\n  SmallVector<Expr *, 8> Vars;\n  for (Expr *RefExpr : VarList) {\n    assert(RefExpr && \"NULL expr in OpenMP nontemporal clause.\");\n    SourceLocation ELoc;\n    SourceRange ERange;\n    Expr *SimpleRefExpr = RefExpr;\n    auto Res = getPrivateItem(*this, SimpleRefExpr, ELoc, ERange,\n                              /*AllowArraySection=*/true);\n    if (Res.second)\n      // It will be analyzed later.\n      Vars.push_back(RefExpr);\n    ValueDecl *D = Res.first;\n    if (!D)\n      continue;\n\n    const DSAStackTy::DSAVarData DVar =\n        DSAStack->getTopDSA(D, /*FromParent=*/true);\n    // OpenMP 5.0, 2.9.6, scan Directive, Restrictions.\n    // A list item that appears in the inclusive or exclusive clause must appear\n    // in a reduction clause with the inscan modifier on the enclosing\n    // worksharing-loop, worksharing-loop SIMD, or simd construct.\n    if (DVar.CKind != OMPC_reduction ||\n        DVar.Modifier != OMPC_REDUCTION_inscan)\n      Diag(ELoc, diag::err_omp_inclusive_exclusive_not_reduction)\n          << RefExpr->getSourceRange();\n\n    if (DSAStack->getParentDirective() != OMPD_unknown)\n      DSAStack->markDeclAsUsedInScanDirective(D);\n    Vars.push_back(RefExpr);\n  }\n\n  if (Vars.empty())\n    return nullptr;\n\n  return OMPInclusiveClause::Create(Context, StartLoc, LParenLoc, EndLoc, Vars);\n}\n\nOMPClause *Sema::ActOnOpenMPExclusiveClause(ArrayRef<Expr *> VarList,\n                                            SourceLocation StartLoc,\n                                            SourceLocation LParenLoc,\n                                            SourceLocation EndLoc) {\n  SmallVector<Expr *, 8> Vars;\n  for (Expr *RefExpr : VarList) {\n    assert(RefExpr && \"NULL expr in OpenMP nontemporal clause.\");\n    SourceLocation ELoc;\n    SourceRange ERange;\n    Expr *SimpleRefExpr = RefExpr;\n    auto Res = getPrivateItem(*this, SimpleRefExpr, ELoc, ERange,\n                              /*AllowArraySection=*/true);\n    if (Res.second)\n      // It will be analyzed later.\n      Vars.push_back(RefExpr);\n    ValueDecl *D = Res.first;\n    if (!D)\n      continue;\n\n    OpenMPDirectiveKind ParentDirective = DSAStack->getParentDirective();\n    DSAStackTy::DSAVarData DVar;\n    if (ParentDirective != OMPD_unknown)\n      DVar = DSAStack->getTopDSA(D, /*FromParent=*/true);\n    // OpenMP 5.0, 2.9.6, scan Directive, Restrictions.\n    // A list item that appears in the inclusive or exclusive clause must appear\n    // in a reduction clause with the inscan modifier on the enclosing\n    // worksharing-loop, worksharing-loop SIMD, or simd construct.\n    if (ParentDirective == OMPD_unknown || DVar.CKind != OMPC_reduction ||\n        DVar.Modifier != OMPC_REDUCTION_inscan) {\n      Diag(ELoc, diag::err_omp_inclusive_exclusive_not_reduction)\n          << RefExpr->getSourceRange();\n    } else {\n      DSAStack->markDeclAsUsedInScanDirective(D);\n    }\n    Vars.push_back(RefExpr);\n  }\n\n  if (Vars.empty())\n    return nullptr;\n\n  return OMPExclusiveClause::Create(Context, StartLoc, LParenLoc, EndLoc, Vars);\n}\n\n/// Tries to find omp_alloctrait_t type.\nstatic bool findOMPAlloctraitT(Sema &S, SourceLocation Loc, DSAStackTy *Stack) {\n  QualType OMPAlloctraitT = Stack->getOMPAlloctraitT();\n  if (!OMPAlloctraitT.isNull())\n    return true;\n  IdentifierInfo &II = S.PP.getIdentifierTable().get(\"omp_alloctrait_t\");\n  ParsedType PT = S.getTypeName(II, Loc, S.getCurScope());\n  if (!PT.getAsOpaquePtr() || PT.get().isNull()) {\n    S.Diag(Loc, diag::err_omp_implied_type_not_found) << \"omp_alloctrait_t\";\n    return false;\n  }\n  Stack->setOMPAlloctraitT(PT.get());\n  return true;\n}\n\nOMPClause *Sema::ActOnOpenMPUsesAllocatorClause(\n    SourceLocation StartLoc, SourceLocation LParenLoc, SourceLocation EndLoc,\n    ArrayRef<UsesAllocatorsData> Data) {\n  // OpenMP [2.12.5, target Construct]\n  // allocator is an identifier of omp_allocator_handle_t type.\n  if (!findOMPAllocatorHandleT(*this, StartLoc, DSAStack))\n    return nullptr;\n  // OpenMP [2.12.5, target Construct]\n  // allocator-traits-array is an identifier of const omp_alloctrait_t * type.\n  if (llvm::any_of(\n          Data,\n          [](const UsesAllocatorsData &D) { return D.AllocatorTraits; }) &&\n      !findOMPAlloctraitT(*this, StartLoc, DSAStack))\n    return nullptr;\n  llvm::SmallPtrSet<CanonicalDeclPtr<Decl>, 4> PredefinedAllocators;\n  for (int I = 0; I < OMPAllocateDeclAttr::OMPUserDefinedMemAlloc; ++I) {\n    auto AllocatorKind = static_cast<OMPAllocateDeclAttr::AllocatorTypeTy>(I);\n    StringRef Allocator =\n        OMPAllocateDeclAttr::ConvertAllocatorTypeTyToStr(AllocatorKind);\n    DeclarationName AllocatorName = &Context.Idents.get(Allocator);\n    PredefinedAllocators.insert(LookupSingleName(\n        TUScope, AllocatorName, StartLoc, Sema::LookupAnyName));\n  }\n\n  SmallVector<OMPUsesAllocatorsClause::Data, 4> NewData;\n  for (const UsesAllocatorsData &D : Data) {\n    Expr *AllocatorExpr = nullptr;\n    // Check allocator expression.\n    if (D.Allocator->isTypeDependent()) {\n      AllocatorExpr = D.Allocator;\n    } else {\n      // Traits were specified - need to assign new allocator to the specified\n      // allocator, so it must be an lvalue.\n      AllocatorExpr = D.Allocator->IgnoreParenImpCasts();\n      auto *DRE = dyn_cast<DeclRefExpr>(AllocatorExpr);\n      bool IsPredefinedAllocator = false;\n      if (DRE)\n        IsPredefinedAllocator = PredefinedAllocators.count(DRE->getDecl());\n      if (!DRE ||\n          !(Context.hasSameUnqualifiedType(\n                AllocatorExpr->getType(), DSAStack->getOMPAllocatorHandleT()) ||\n            Context.typesAreCompatible(AllocatorExpr->getType(),\n                                       DSAStack->getOMPAllocatorHandleT(),\n                                       /*CompareUnqualified=*/true)) ||\n          (!IsPredefinedAllocator &&\n           (AllocatorExpr->getType().isConstant(Context) ||\n            !AllocatorExpr->isLValue()))) {\n        Diag(D.Allocator->getExprLoc(), diag::err_omp_var_expected)\n            << \"omp_allocator_handle_t\" << (DRE ? 1 : 0)\n            << AllocatorExpr->getType() << D.Allocator->getSourceRange();\n        continue;\n      }\n      // OpenMP [2.12.5, target Construct]\n      // Predefined allocators appearing in a uses_allocators clause cannot have\n      // traits specified.\n      if (IsPredefinedAllocator && D.AllocatorTraits) {\n        Diag(D.AllocatorTraits->getExprLoc(),\n             diag::err_omp_predefined_allocator_with_traits)\n            << D.AllocatorTraits->getSourceRange();\n        Diag(D.Allocator->getExprLoc(), diag::note_omp_predefined_allocator)\n            << cast<NamedDecl>(DRE->getDecl())->getName()\n            << D.Allocator->getSourceRange();\n        continue;\n      }\n      // OpenMP [2.12.5, target Construct]\n      // Non-predefined allocators appearing in a uses_allocators clause must\n      // have traits specified.\n      if (!IsPredefinedAllocator && !D.AllocatorTraits) {\n        Diag(D.Allocator->getExprLoc(),\n             diag::err_omp_nonpredefined_allocator_without_traits);\n        continue;\n      }\n      // No allocator traits - just convert it to rvalue.\n      if (!D.AllocatorTraits)\n        AllocatorExpr = DefaultLvalueConversion(AllocatorExpr).get();\n      DSAStack->addUsesAllocatorsDecl(\n          DRE->getDecl(),\n          IsPredefinedAllocator\n              ? DSAStackTy::UsesAllocatorsDeclKind::PredefinedAllocator\n              : DSAStackTy::UsesAllocatorsDeclKind::UserDefinedAllocator);\n    }\n    Expr *AllocatorTraitsExpr = nullptr;\n    if (D.AllocatorTraits) {\n      if (D.AllocatorTraits->isTypeDependent()) {\n        AllocatorTraitsExpr = D.AllocatorTraits;\n      } else {\n        // OpenMP [2.12.5, target Construct]\n        // Arrays that contain allocator traits that appear in a uses_allocators\n        // clause must be constant arrays, have constant values and be defined\n        // in the same scope as the construct in which the clause appears.\n        AllocatorTraitsExpr = D.AllocatorTraits->IgnoreParenImpCasts();\n        // Check that traits expr is a constant array.\n        QualType TraitTy;\n        if (const ArrayType *Ty =\n                AllocatorTraitsExpr->getType()->getAsArrayTypeUnsafe())\n          if (const auto *ConstArrayTy = dyn_cast<ConstantArrayType>(Ty))\n            TraitTy = ConstArrayTy->getElementType();\n        if (TraitTy.isNull() ||\n            !(Context.hasSameUnqualifiedType(TraitTy,\n                                             DSAStack->getOMPAlloctraitT()) ||\n              Context.typesAreCompatible(TraitTy, DSAStack->getOMPAlloctraitT(),\n                                         /*CompareUnqualified=*/true))) {\n          Diag(D.AllocatorTraits->getExprLoc(),\n               diag::err_omp_expected_array_alloctraits)\n              << AllocatorTraitsExpr->getType();\n          continue;\n        }\n        // Do not map by default allocator traits if it is a standalone\n        // variable.\n        if (auto *DRE = dyn_cast<DeclRefExpr>(AllocatorTraitsExpr))\n          DSAStack->addUsesAllocatorsDecl(\n              DRE->getDecl(),\n              DSAStackTy::UsesAllocatorsDeclKind::AllocatorTrait);\n      }\n    }\n    OMPUsesAllocatorsClause::Data &NewD = NewData.emplace_back();\n    NewD.Allocator = AllocatorExpr;\n    NewD.AllocatorTraits = AllocatorTraitsExpr;\n    NewD.LParenLoc = D.LParenLoc;\n    NewD.RParenLoc = D.RParenLoc;\n  }\n  return OMPUsesAllocatorsClause::Create(Context, StartLoc, LParenLoc, EndLoc,\n                                         NewData);\n}\n\nOMPClause *Sema::ActOnOpenMPAffinityClause(\n    SourceLocation StartLoc, SourceLocation LParenLoc, SourceLocation ColonLoc,\n    SourceLocation EndLoc, Expr *Modifier, ArrayRef<Expr *> Locators) {\n  SmallVector<Expr *, 8> Vars;\n  for (Expr *RefExpr : Locators) {\n    assert(RefExpr && \"NULL expr in OpenMP shared clause.\");\n    if (isa<DependentScopeDeclRefExpr>(RefExpr) || RefExpr->isTypeDependent()) {\n      // It will be analyzed later.\n      Vars.push_back(RefExpr);\n      continue;\n    }\n\n    SourceLocation ELoc = RefExpr->getExprLoc();\n    Expr *SimpleExpr = RefExpr->IgnoreParenImpCasts();\n\n    if (!SimpleExpr->isLValue()) {\n      Diag(ELoc, diag::err_omp_expected_addressable_lvalue_or_array_item)\n          << 1 << 0 << RefExpr->getSourceRange();\n      continue;\n    }\n\n    ExprResult Res;\n    {\n      Sema::TentativeAnalysisScope Trap(*this);\n      Res = CreateBuiltinUnaryOp(ELoc, UO_AddrOf, SimpleExpr);\n    }\n    if (!Res.isUsable() && !isa<OMPArraySectionExpr>(SimpleExpr) &&\n        !isa<OMPArrayShapingExpr>(SimpleExpr)) {\n      Diag(ELoc, diag::err_omp_expected_addressable_lvalue_or_array_item)\n          << 1 << 0 << RefExpr->getSourceRange();\n      continue;\n    }\n    Vars.push_back(SimpleExpr);\n  }\n\n  return OMPAffinityClause::Create(Context, StartLoc, LParenLoc, ColonLoc,\n                                   EndLoc, Modifier, Vars);\n}\n"}}, "reports": [{"events": [{"location": {"col": 35, "file": 1, "line": 6751}, "message": "the definition seen here"}, {"location": {"col": 8, "file": 1, "line": 6732}, "message": "differing parameters are named here: ('NewDeclRefExpr'), in definition: ('NewLCRefExpr')"}, {"location": {"col": 8, "file": 1, "line": 6732}, "message": "function '(anonymous namespace)::OpenMPIterationSpaceChecker::setLCDeclAndLB' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaOpenMP.cpp", "reportHash": "ce5cf0e5357e210d0f15848a308d7203", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
