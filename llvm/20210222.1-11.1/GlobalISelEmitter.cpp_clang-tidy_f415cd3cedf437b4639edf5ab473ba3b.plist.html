<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"1": {"id": 1, "path": "/home/vsts/work/1/llvm-project/llvm/utils/TableGen/GlobalISelEmitter.cpp", "content": "//===- GlobalISelEmitter.cpp - Generate an instruction selector -----------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n/// This tablegen backend emits code for use by the GlobalISel instruction\n/// selector. See include/llvm/CodeGen/TargetGlobalISel.td.\n///\n/// This file analyzes the patterns recognized by the SelectionDAGISel tablegen\n/// backend, filters out the ones that are unsupported, maps\n/// SelectionDAG-specific constructs to their GlobalISel counterpart\n/// (when applicable: MVT to LLT;  SDNode to generic Instruction).\n///\n/// Not all patterns are supported: pass the tablegen invocation\n/// \"-warn-on-skipped-patterns\" to emit a warning when a pattern is skipped,\n/// as well as why.\n///\n/// The generated file defines a single method:\n///     bool <Target>InstructionSelector::selectImpl(MachineInstr &I) const;\n/// intended to be used in InstructionSelector::select as the first-step\n/// selector for the patterns that don't require complex C++.\n///\n/// FIXME: We'll probably want to eventually define a base\n/// \"TargetGenInstructionSelector\" class.\n///\n//===----------------------------------------------------------------------===//\n\n#include \"CodeGenDAGPatterns.h\"\n#include \"SubtargetFeatureInfo.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/SmallSet.h\"\n#include \"llvm/ADT/Statistic.h\"\n#include \"llvm/Support/CodeGenCoverage.h\"\n#include \"llvm/Support/CommandLine.h\"\n#include \"llvm/Support/Error.h\"\n#include \"llvm/Support/LowLevelTypeImpl.h\"\n#include \"llvm/Support/MachineValueType.h\"\n#include \"llvm/Support/ScopedPrinter.h\"\n#include \"llvm/TableGen/Error.h\"\n#include \"llvm/TableGen/Record.h\"\n#include \"llvm/TableGen/TableGenBackend.h\"\n#include <numeric>\n#include <string>\nusing namespace llvm;\n\n#define DEBUG_TYPE \"gisel-emitter\"\n\nSTATISTIC(NumPatternTotal, \"Total number of patterns\");\nSTATISTIC(NumPatternImported, \"Number of patterns imported from SelectionDAG\");\nSTATISTIC(NumPatternImportsSkipped, \"Number of SelectionDAG imports skipped\");\nSTATISTIC(NumPatternsTested, \"Number of patterns executed according to coverage information\");\nSTATISTIC(NumPatternEmitted, \"Number of patterns emitted\");\n\ncl::OptionCategory GlobalISelEmitterCat(\"Options for -gen-global-isel\");\n\nstatic cl::opt<bool> WarnOnSkippedPatterns(\n    \"warn-on-skipped-patterns\",\n    cl::desc(\"Explain why a pattern was skipped for inclusion \"\n             \"in the GlobalISel selector\"),\n    cl::init(false), cl::cat(GlobalISelEmitterCat));\n\nstatic cl::opt<bool> GenerateCoverage(\n    \"instrument-gisel-coverage\",\n    cl::desc(\"Generate coverage instrumentation for GlobalISel\"),\n    cl::init(false), cl::cat(GlobalISelEmitterCat));\n\nstatic cl::opt<std::string> UseCoverageFile(\n    \"gisel-coverage-file\", cl::init(\"\"),\n    cl::desc(\"Specify file to retrieve coverage information from\"),\n    cl::cat(GlobalISelEmitterCat));\n\nstatic cl::opt<bool> OptimizeMatchTable(\n    \"optimize-match-table\",\n    cl::desc(\"Generate an optimized version of the match table\"),\n    cl::init(true), cl::cat(GlobalISelEmitterCat));\n\nnamespace {\n//===- Helper functions ---------------------------------------------------===//\n\n/// Get the name of the enum value used to number the predicate function.\nstd::string getEnumNameForPredicate(const TreePredicateFn &Predicate) {\n  if (Predicate.hasGISelPredicateCode())\n    return \"GIPFP_MI_\" + Predicate.getFnName();\n  return \"GIPFP_\" + Predicate.getImmTypeIdentifier().str() + \"_\" +\n         Predicate.getFnName();\n}\n\n/// Get the opcode used to check this predicate.\nstd::string getMatchOpcodeForPredicate(const TreePredicateFn &Predicate) {\n  return \"GIM_Check\" + Predicate.getImmTypeIdentifier().str() + \"ImmPredicate\";\n}\n\n/// This class stands in for LLT wherever we want to tablegen-erate an\n/// equivalent at compiler run-time.\nclass LLTCodeGen {\nprivate:\n  LLT Ty;\n\npublic:\n  LLTCodeGen() = default;\n  LLTCodeGen(const LLT &Ty) : Ty(Ty) {}\n\n  std::string getCxxEnumValue() const {\n    std::string Str;\n    raw_string_ostream OS(Str);\n\n    emitCxxEnumValue(OS);\n    return OS.str();\n  }\n\n  void emitCxxEnumValue(raw_ostream &OS) const {\n    if (Ty.isScalar()) {\n      OS << \"GILLT_s\" << Ty.getSizeInBits();\n      return;\n    }\n    if (Ty.isVector()) {\n      OS << \"GILLT_v\" << Ty.getNumElements() << \"s\" << Ty.getScalarSizeInBits();\n      return;\n    }\n    if (Ty.isPointer()) {\n      OS << \"GILLT_p\" << Ty.getAddressSpace();\n      if (Ty.getSizeInBits() > 0)\n        OS << \"s\" << Ty.getSizeInBits();\n      return;\n    }\n    llvm_unreachable(\"Unhandled LLT\");\n  }\n\n  void emitCxxConstructorCall(raw_ostream &OS) const {\n    if (Ty.isScalar()) {\n      OS << \"LLT::scalar(\" << Ty.getSizeInBits() << \")\";\n      return;\n    }\n    if (Ty.isVector()) {\n      OS << \"LLT::vector(\" << Ty.getNumElements() << \", \"\n         << Ty.getScalarSizeInBits() << \")\";\n      return;\n    }\n    if (Ty.isPointer() && Ty.getSizeInBits() > 0) {\n      OS << \"LLT::pointer(\" << Ty.getAddressSpace() << \", \"\n         << Ty.getSizeInBits() << \")\";\n      return;\n    }\n    llvm_unreachable(\"Unhandled LLT\");\n  }\n\n  const LLT &get() const { return Ty; }\n\n  /// This ordering is used for std::unique() and llvm::sort(). There's no\n  /// particular logic behind the order but either A < B or B < A must be\n  /// true if A != B.\n  bool operator<(const LLTCodeGen &Other) const {\n    if (Ty.isValid() != Other.Ty.isValid())\n      return Ty.isValid() < Other.Ty.isValid();\n    if (!Ty.isValid())\n      return false;\n\n    if (Ty.isVector() != Other.Ty.isVector())\n      return Ty.isVector() < Other.Ty.isVector();\n    if (Ty.isScalar() != Other.Ty.isScalar())\n      return Ty.isScalar() < Other.Ty.isScalar();\n    if (Ty.isPointer() != Other.Ty.isPointer())\n      return Ty.isPointer() < Other.Ty.isPointer();\n\n    if (Ty.isPointer() && Ty.getAddressSpace() != Other.Ty.getAddressSpace())\n      return Ty.getAddressSpace() < Other.Ty.getAddressSpace();\n\n    if (Ty.isVector() && Ty.getNumElements() != Other.Ty.getNumElements())\n      return Ty.getNumElements() < Other.Ty.getNumElements();\n\n    return Ty.getSizeInBits() < Other.Ty.getSizeInBits();\n  }\n\n  bool operator==(const LLTCodeGen &B) const { return Ty == B.Ty; }\n};\n\n// Track all types that are used so we can emit the corresponding enum.\nstd::set<LLTCodeGen> KnownTypes;\n\nclass InstructionMatcher;\n/// Convert an MVT to an equivalent LLT if possible, or the invalid LLT() for\n/// MVTs that don't map cleanly to an LLT (e.g., iPTR, *any, ...).\nstatic Optional<LLTCodeGen> MVTToLLT(MVT::SimpleValueType SVT) {\n  MVT VT(SVT);\n\n  if (VT.isScalableVector())\n    return None;\n\n  if (VT.isFixedLengthVector() && VT.getVectorNumElements() != 1)\n    return LLTCodeGen(\n        LLT::vector(VT.getVectorNumElements(), VT.getScalarSizeInBits()));\n\n  if (VT.isInteger() || VT.isFloatingPoint())\n    return LLTCodeGen(LLT::scalar(VT.getSizeInBits()));\n\n  return None;\n}\n\nstatic std::string explainPredicates(const TreePatternNode *N) {\n  std::string Explanation;\n  StringRef Separator = \"\";\n  for (const TreePredicateCall &Call : N->getPredicateCalls()) {\n    const TreePredicateFn &P = Call.Fn;\n    Explanation +=\n        (Separator + P.getOrigPatFragRecord()->getRecord()->getName()).str();\n    Separator = \", \";\n\n    if (P.isAlwaysTrue())\n      Explanation += \" always-true\";\n    if (P.isImmediatePattern())\n      Explanation += \" immediate\";\n\n    if (P.isUnindexed())\n      Explanation += \" unindexed\";\n\n    if (P.isNonExtLoad())\n      Explanation += \" non-extload\";\n    if (P.isAnyExtLoad())\n      Explanation += \" extload\";\n    if (P.isSignExtLoad())\n      Explanation += \" sextload\";\n    if (P.isZeroExtLoad())\n      Explanation += \" zextload\";\n\n    if (P.isNonTruncStore())\n      Explanation += \" non-truncstore\";\n    if (P.isTruncStore())\n      Explanation += \" truncstore\";\n\n    if (Record *VT = P.getMemoryVT())\n      Explanation += (\" MemVT=\" + VT->getName()).str();\n    if (Record *VT = P.getScalarMemoryVT())\n      Explanation += (\" ScalarVT(MemVT)=\" + VT->getName()).str();\n\n    if (ListInit *AddrSpaces = P.getAddressSpaces()) {\n      raw_string_ostream OS(Explanation);\n      OS << \" AddressSpaces=[\";\n\n      StringRef AddrSpaceSeparator;\n      for (Init *Val : AddrSpaces->getValues()) {\n        IntInit *IntVal = dyn_cast<IntInit>(Val);\n        if (!IntVal)\n          continue;\n\n        OS << AddrSpaceSeparator << IntVal->getValue();\n        AddrSpaceSeparator = \", \";\n      }\n\n      OS << ']';\n    }\n\n    int64_t MinAlign = P.getMinAlignment();\n    if (MinAlign > 0)\n      Explanation += \" MinAlign=\" + utostr(MinAlign);\n\n    if (P.isAtomicOrderingMonotonic())\n      Explanation += \" monotonic\";\n    if (P.isAtomicOrderingAcquire())\n      Explanation += \" acquire\";\n    if (P.isAtomicOrderingRelease())\n      Explanation += \" release\";\n    if (P.isAtomicOrderingAcquireRelease())\n      Explanation += \" acq_rel\";\n    if (P.isAtomicOrderingSequentiallyConsistent())\n      Explanation += \" seq_cst\";\n    if (P.isAtomicOrderingAcquireOrStronger())\n      Explanation += \" >=acquire\";\n    if (P.isAtomicOrderingWeakerThanAcquire())\n      Explanation += \" <acquire\";\n    if (P.isAtomicOrderingReleaseOrStronger())\n      Explanation += \" >=release\";\n    if (P.isAtomicOrderingWeakerThanRelease())\n      Explanation += \" <release\";\n  }\n  return Explanation;\n}\n\nstd::string explainOperator(Record *Operator) {\n  if (Operator->isSubClassOf(\"SDNode\"))\n    return (\" (\" + Operator->getValueAsString(\"Opcode\") + \")\").str();\n\n  if (Operator->isSubClassOf(\"Intrinsic\"))\n    return (\" (Operator is an Intrinsic, \" + Operator->getName() + \")\").str();\n\n  if (Operator->isSubClassOf(\"ComplexPattern\"))\n    return (\" (Operator is an unmapped ComplexPattern, \" + Operator->getName() +\n            \")\")\n        .str();\n\n  if (Operator->isSubClassOf(\"SDNodeXForm\"))\n    return (\" (Operator is an unmapped SDNodeXForm, \" + Operator->getName() +\n            \")\")\n        .str();\n\n  return (\" (Operator \" + Operator->getName() + \" not understood)\").str();\n}\n\n/// Helper function to let the emitter report skip reason error messages.\nstatic Error failedImport(const Twine &Reason) {\n  return make_error<StringError>(Reason, inconvertibleErrorCode());\n}\n\nstatic Error isTrivialOperatorNode(const TreePatternNode *N) {\n  std::string Explanation;\n  std::string Separator;\n\n  bool HasUnsupportedPredicate = false;\n  for (const TreePredicateCall &Call : N->getPredicateCalls()) {\n    const TreePredicateFn &Predicate = Call.Fn;\n\n    if (Predicate.isAlwaysTrue())\n      continue;\n\n    if (Predicate.isImmediatePattern())\n      continue;\n\n    if (Predicate.isNonExtLoad() || Predicate.isAnyExtLoad() ||\n        Predicate.isSignExtLoad() || Predicate.isZeroExtLoad())\n      continue;\n\n    if (Predicate.isNonTruncStore() || Predicate.isTruncStore())\n      continue;\n\n    if (Predicate.isLoad() && Predicate.getMemoryVT())\n      continue;\n\n    if (Predicate.isLoad() || Predicate.isStore()) {\n      if (Predicate.isUnindexed())\n        continue;\n    }\n\n    if (Predicate.isLoad() || Predicate.isStore() || Predicate.isAtomic()) {\n      const ListInit *AddrSpaces = Predicate.getAddressSpaces();\n      if (AddrSpaces && !AddrSpaces->empty())\n        continue;\n\n      if (Predicate.getMinAlignment() > 0)\n        continue;\n    }\n\n    if (Predicate.isAtomic() && Predicate.getMemoryVT())\n      continue;\n\n    if (Predicate.isAtomic() &&\n        (Predicate.isAtomicOrderingMonotonic() ||\n         Predicate.isAtomicOrderingAcquire() ||\n         Predicate.isAtomicOrderingRelease() ||\n         Predicate.isAtomicOrderingAcquireRelease() ||\n         Predicate.isAtomicOrderingSequentiallyConsistent() ||\n         Predicate.isAtomicOrderingAcquireOrStronger() ||\n         Predicate.isAtomicOrderingWeakerThanAcquire() ||\n         Predicate.isAtomicOrderingReleaseOrStronger() ||\n         Predicate.isAtomicOrderingWeakerThanRelease()))\n      continue;\n\n    if (Predicate.hasGISelPredicateCode())\n      continue;\n\n    HasUnsupportedPredicate = true;\n    Explanation = Separator + \"Has a predicate (\" + explainPredicates(N) + \")\";\n    Separator = \", \";\n    Explanation += (Separator + \"first-failing:\" +\n                    Predicate.getOrigPatFragRecord()->getRecord()->getName())\n                       .str();\n    break;\n  }\n\n  if (!HasUnsupportedPredicate)\n    return Error::success();\n\n  return failedImport(Explanation);\n}\n\nstatic Record *getInitValueAsRegClass(Init *V) {\n  if (DefInit *VDefInit = dyn_cast<DefInit>(V)) {\n    if (VDefInit->getDef()->isSubClassOf(\"RegisterOperand\"))\n      return VDefInit->getDef()->getValueAsDef(\"RegClass\");\n    if (VDefInit->getDef()->isSubClassOf(\"RegisterClass\"))\n      return VDefInit->getDef();\n  }\n  return nullptr;\n}\n\nstd::string\ngetNameForFeatureBitset(const std::vector<Record *> &FeatureBitset) {\n  std::string Name = \"GIFBS\";\n  for (const auto &Feature : FeatureBitset)\n    Name += (\"_\" + Feature->getName()).str();\n  return Name;\n}\n\nstatic std::string getScopedName(unsigned Scope, const std::string &Name) {\n  return (\"pred:\" + Twine(Scope) + \":\" + Name).str();\n}\n\n//===- MatchTable Helpers -------------------------------------------------===//\n\nclass MatchTable;\n\n/// A record to be stored in a MatchTable.\n///\n/// This class represents any and all output that may be required to emit the\n/// MatchTable. Instances  are most often configured to represent an opcode or\n/// value that will be emitted to the table with some formatting but it can also\n/// represent commas, comments, and other formatting instructions.\nstruct MatchTableRecord {\n  enum RecordFlagsBits {\n    MTRF_None = 0x0,\n    /// Causes EmitStr to be formatted as comment when emitted.\n    MTRF_Comment = 0x1,\n    /// Causes the record value to be followed by a comma when emitted.\n    MTRF_CommaFollows = 0x2,\n    /// Causes the record value to be followed by a line break when emitted.\n    MTRF_LineBreakFollows = 0x4,\n    /// Indicates that the record defines a label and causes an additional\n    /// comment to be emitted containing the index of the label.\n    MTRF_Label = 0x8,\n    /// Causes the record to be emitted as the index of the label specified by\n    /// LabelID along with a comment indicating where that label is.\n    MTRF_JumpTarget = 0x10,\n    /// Causes the formatter to add a level of indentation before emitting the\n    /// record.\n    MTRF_Indent = 0x20,\n    /// Causes the formatter to remove a level of indentation after emitting the\n    /// record.\n    MTRF_Outdent = 0x40,\n  };\n\n  /// When MTRF_Label or MTRF_JumpTarget is used, indicates a label id to\n  /// reference or define.\n  unsigned LabelID;\n  /// The string to emit. Depending on the MTRF_* flags it may be a comment, a\n  /// value, a label name.\n  std::string EmitStr;\n\nprivate:\n  /// The number of MatchTable elements described by this record. Comments are 0\n  /// while values are typically 1. Values >1 may occur when we need to emit\n  /// values that exceed the size of a MatchTable element.\n  unsigned NumElements;\n\npublic:\n  /// A bitfield of RecordFlagsBits flags.\n  unsigned Flags;\n\n  /// The actual run-time value, if known\n  int64_t RawValue;\n\n  MatchTableRecord(Optional<unsigned> LabelID_, StringRef EmitStr,\n                   unsigned NumElements, unsigned Flags,\n                   int64_t RawValue = std::numeric_limits<int64_t>::min())\n      : LabelID(LabelID_.getValueOr(~0u)), EmitStr(EmitStr),\n        NumElements(NumElements), Flags(Flags), RawValue(RawValue) {\n    assert((!LabelID_.hasValue() || LabelID != ~0u) &&\n           \"This value is reserved for non-labels\");\n  }\n  MatchTableRecord(const MatchTableRecord &Other) = default;\n  MatchTableRecord(MatchTableRecord &&Other) = default;\n\n  /// Useful if a Match Table Record gets optimized out\n  void turnIntoComment() {\n    Flags |= MTRF_Comment;\n    Flags &= ~MTRF_CommaFollows;\n    NumElements = 0;\n  }\n\n  /// For Jump Table generation purposes\n  bool operator<(const MatchTableRecord &Other) const {\n    return RawValue < Other.RawValue;\n  }\n  int64_t getRawValue() const { return RawValue; }\n\n  void emit(raw_ostream &OS, bool LineBreakNextAfterThis,\n            const MatchTable &Table) const;\n  unsigned size() const { return NumElements; }\n};\n\nclass Matcher;\n\n/// Holds the contents of a generated MatchTable to enable formatting and the\n/// necessary index tracking needed to support GIM_Try.\nclass MatchTable {\n  /// An unique identifier for the table. The generated table will be named\n  /// MatchTable${ID}.\n  unsigned ID;\n  /// The records that make up the table. Also includes comments describing the\n  /// values being emitted and line breaks to format it.\n  std::vector<MatchTableRecord> Contents;\n  /// The currently defined labels.\n  DenseMap<unsigned, unsigned> LabelMap;\n  /// Tracks the sum of MatchTableRecord::NumElements as the table is built.\n  unsigned CurrentSize = 0;\n  /// A unique identifier for a MatchTable label.\n  unsigned CurrentLabelID = 0;\n  /// Determines if the table should be instrumented for rule coverage tracking.\n  bool IsWithCoverage;\n\npublic:\n  static MatchTableRecord LineBreak;\n  static MatchTableRecord Comment(StringRef Comment) {\n    return MatchTableRecord(None, Comment, 0, MatchTableRecord::MTRF_Comment);\n  }\n  static MatchTableRecord Opcode(StringRef Opcode, int IndentAdjust = 0) {\n    unsigned ExtraFlags = 0;\n    if (IndentAdjust > 0)\n      ExtraFlags |= MatchTableRecord::MTRF_Indent;\n    if (IndentAdjust < 0)\n      ExtraFlags |= MatchTableRecord::MTRF_Outdent;\n\n    return MatchTableRecord(None, Opcode, 1,\n                            MatchTableRecord::MTRF_CommaFollows | ExtraFlags);\n  }\n  static MatchTableRecord NamedValue(StringRef NamedValue) {\n    return MatchTableRecord(None, NamedValue, 1,\n                            MatchTableRecord::MTRF_CommaFollows);\n  }\n  static MatchTableRecord NamedValue(StringRef NamedValue, int64_t RawValue) {\n    return MatchTableRecord(None, NamedValue, 1,\n                            MatchTableRecord::MTRF_CommaFollows, RawValue);\n  }\n  static MatchTableRecord NamedValue(StringRef Namespace,\n                                     StringRef NamedValue) {\n    return MatchTableRecord(None, (Namespace + \"::\" + NamedValue).str(), 1,\n                            MatchTableRecord::MTRF_CommaFollows);\n  }\n  static MatchTableRecord NamedValue(StringRef Namespace, StringRef NamedValue,\n                                     int64_t RawValue) {\n    return MatchTableRecord(None, (Namespace + \"::\" + NamedValue).str(), 1,\n                            MatchTableRecord::MTRF_CommaFollows, RawValue);\n  }\n  static MatchTableRecord IntValue(int64_t IntValue) {\n    return MatchTableRecord(None, llvm::to_string(IntValue), 1,\n                            MatchTableRecord::MTRF_CommaFollows);\n  }\n  static MatchTableRecord Label(unsigned LabelID) {\n    return MatchTableRecord(LabelID, \"Label \" + llvm::to_string(LabelID), 0,\n                            MatchTableRecord::MTRF_Label |\n                                MatchTableRecord::MTRF_Comment |\n                                MatchTableRecord::MTRF_LineBreakFollows);\n  }\n  static MatchTableRecord JumpTarget(unsigned LabelID) {\n    return MatchTableRecord(LabelID, \"Label \" + llvm::to_string(LabelID), 1,\n                            MatchTableRecord::MTRF_JumpTarget |\n                                MatchTableRecord::MTRF_Comment |\n                                MatchTableRecord::MTRF_CommaFollows);\n  }\n\n  static MatchTable buildTable(ArrayRef<Matcher *> Rules, bool WithCoverage);\n\n  MatchTable(bool WithCoverage, unsigned ID = 0)\n      : ID(ID), IsWithCoverage(WithCoverage) {}\n\n  bool isWithCoverage() const { return IsWithCoverage; }\n\n  void push_back(const MatchTableRecord &Value) {\n    if (Value.Flags & MatchTableRecord::MTRF_Label)\n      defineLabel(Value.LabelID);\n    Contents.push_back(Value);\n    CurrentSize += Value.size();\n  }\n\n  unsigned allocateLabelID() { return CurrentLabelID++; }\n\n  void defineLabel(unsigned LabelID) {\n    LabelMap.insert(std::make_pair(LabelID, CurrentSize));\n  }\n\n  unsigned getLabelIndex(unsigned LabelID) const {\n    const auto I = LabelMap.find(LabelID);\n    assert(I != LabelMap.end() && \"Use of undeclared label\");\n    return I->second;\n  }\n\n  void emitUse(raw_ostream &OS) const { OS << \"MatchTable\" << ID; }\n\n  void emitDeclaration(raw_ostream &OS) const {\n    unsigned Indentation = 4;\n    OS << \"  constexpr static int64_t MatchTable\" << ID << \"[] = {\";\n    LineBreak.emit(OS, true, *this);\n    OS << std::string(Indentation, ' ');\n\n    for (auto I = Contents.begin(), E = Contents.end(); I != E;\n         ++I) {\n      bool LineBreakIsNext = false;\n      const auto &NextI = std::next(I);\n\n      if (NextI != E) {\n        if (NextI->EmitStr == \"\" &&\n            NextI->Flags == MatchTableRecord::MTRF_LineBreakFollows)\n          LineBreakIsNext = true;\n      }\n\n      if (I->Flags & MatchTableRecord::MTRF_Indent)\n        Indentation += 2;\n\n      I->emit(OS, LineBreakIsNext, *this);\n      if (I->Flags & MatchTableRecord::MTRF_LineBreakFollows)\n        OS << std::string(Indentation, ' ');\n\n      if (I->Flags & MatchTableRecord::MTRF_Outdent)\n        Indentation -= 2;\n    }\n    OS << \"};\\n\";\n  }\n};\n\nMatchTableRecord MatchTable::LineBreak = {\n    None, \"\" /* Emit String */, 0 /* Elements */,\n    MatchTableRecord::MTRF_LineBreakFollows};\n\nvoid MatchTableRecord::emit(raw_ostream &OS, bool LineBreakIsNextAfterThis,\n                            const MatchTable &Table) const {\n  bool UseLineComment =\n      LineBreakIsNextAfterThis || (Flags & MTRF_LineBreakFollows);\n  if (Flags & (MTRF_JumpTarget | MTRF_CommaFollows))\n    UseLineComment = false;\n\n  if (Flags & MTRF_Comment)\n    OS << (UseLineComment ? \"// \" : \"/*\");\n\n  OS << EmitStr;\n  if (Flags & MTRF_Label)\n    OS << \": @\" << Table.getLabelIndex(LabelID);\n\n  if ((Flags & MTRF_Comment) && !UseLineComment)\n    OS << \"*/\";\n\n  if (Flags & MTRF_JumpTarget) {\n    if (Flags & MTRF_Comment)\n      OS << \" \";\n    OS << Table.getLabelIndex(LabelID);\n  }\n\n  if (Flags & MTRF_CommaFollows) {\n    OS << \",\";\n    if (!LineBreakIsNextAfterThis && !(Flags & MTRF_LineBreakFollows))\n      OS << \" \";\n  }\n\n  if (Flags & MTRF_LineBreakFollows)\n    OS << \"\\n\";\n}\n\nMatchTable &operator<<(MatchTable &Table, const MatchTableRecord &Value) {\n  Table.push_back(Value);\n  return Table;\n}\n\n//===- Matchers -----------------------------------------------------------===//\n\nclass OperandMatcher;\nclass MatchAction;\nclass PredicateMatcher;\nclass RuleMatcher;\n\nclass Matcher {\npublic:\n  virtual ~Matcher() = default;\n  virtual void optimize() {}\n  virtual void emit(MatchTable &Table) = 0;\n\n  virtual bool hasFirstCondition() const = 0;\n  virtual const PredicateMatcher &getFirstCondition() const = 0;\n  virtual std::unique_ptr<PredicateMatcher> popFirstCondition() = 0;\n};\n\nMatchTable MatchTable::buildTable(ArrayRef<Matcher *> Rules,\n                                  bool WithCoverage) {\n  MatchTable Table(WithCoverage);\n  for (Matcher *Rule : Rules)\n    Rule->emit(Table);\n\n  return Table << MatchTable::Opcode(\"GIM_Reject\") << MatchTable::LineBreak;\n}\n\nclass GroupMatcher final : public Matcher {\n  /// Conditions that form a common prefix of all the matchers contained.\n  SmallVector<std::unique_ptr<PredicateMatcher>, 1> Conditions;\n\n  /// All the nested matchers, sharing a common prefix.\n  std::vector<Matcher *> Matchers;\n\n  /// An owning collection for any auxiliary matchers created while optimizing\n  /// nested matchers contained.\n  std::vector<std::unique_ptr<Matcher>> MatcherStorage;\n\npublic:\n  /// Add a matcher to the collection of nested matchers if it meets the\n  /// requirements, and return true. If it doesn't, do nothing and return false.\n  ///\n  /// Expected to preserve its argument, so it could be moved out later on.\n  bool addMatcher(Matcher &Candidate);\n\n  /// Mark the matcher as fully-built and ensure any invariants expected by both\n  /// optimize() and emit(...) methods. Generally, both sequences of calls\n  /// are expected to lead to a sensible result:\n  ///\n  /// addMatcher(...)*; finalize(); optimize(); emit(...); and\n  /// addMatcher(...)*; finalize(); emit(...);\n  ///\n  /// or generally\n  ///\n  /// addMatcher(...)*; finalize(); { optimize()*; emit(...); }*\n  ///\n  /// Multiple calls to optimize() are expected to be handled gracefully, though\n  /// optimize() is not expected to be idempotent. Multiple calls to finalize()\n  /// aren't generally supported. emit(...) is expected to be non-mutating and\n  /// producing the exact same results upon repeated calls.\n  ///\n  /// addMatcher() calls after the finalize() call are not supported.\n  ///\n  /// finalize() and optimize() are both allowed to mutate the contained\n  /// matchers, so moving them out after finalize() is not supported.\n  void finalize();\n  void optimize() override;\n  void emit(MatchTable &Table) override;\n\n  /// Could be used to move out the matchers added previously, unless finalize()\n  /// has been already called. If any of the matchers are moved out, the group\n  /// becomes safe to destroy, but not safe to re-use for anything else.\n  iterator_range<std::vector<Matcher *>::iterator> matchers() {\n    return make_range(Matchers.begin(), Matchers.end());\n  }\n  size_t size() const { return Matchers.size(); }\n  bool empty() const { return Matchers.empty(); }\n\n  std::unique_ptr<PredicateMatcher> popFirstCondition() override {\n    assert(!Conditions.empty() &&\n           \"Trying to pop a condition from a condition-less group\");\n    std::unique_ptr<PredicateMatcher> P = std::move(Conditions.front());\n    Conditions.erase(Conditions.begin());\n    return P;\n  }\n  const PredicateMatcher &getFirstCondition() const override {\n    assert(!Conditions.empty() &&\n           \"Trying to get a condition from a condition-less group\");\n    return *Conditions.front();\n  }\n  bool hasFirstCondition() const override { return !Conditions.empty(); }\n\nprivate:\n  /// See if a candidate matcher could be added to this group solely by\n  /// analyzing its first condition.\n  bool candidateConditionMatches(const PredicateMatcher &Predicate) const;\n};\n\nclass SwitchMatcher : public Matcher {\n  /// All the nested matchers, representing distinct switch-cases. The first\n  /// conditions (as Matcher::getFirstCondition() reports) of all the nested\n  /// matchers must share the same type and path to a value they check, in other\n  /// words, be isIdenticalDownToValue, but have different values they check\n  /// against.\n  std::vector<Matcher *> Matchers;\n\n  /// The representative condition, with a type and a path (InsnVarID and OpIdx\n  /// in most cases)  shared by all the matchers contained.\n  std::unique_ptr<PredicateMatcher> Condition = nullptr;\n\n  /// Temporary set used to check that the case values don't repeat within the\n  /// same switch.\n  std::set<MatchTableRecord> Values;\n\n  /// An owning collection for any auxiliary matchers created while optimizing\n  /// nested matchers contained.\n  std::vector<std::unique_ptr<Matcher>> MatcherStorage;\n\npublic:\n  bool addMatcher(Matcher &Candidate);\n\n  void finalize();\n  void emit(MatchTable &Table) override;\n\n  iterator_range<std::vector<Matcher *>::iterator> matchers() {\n    return make_range(Matchers.begin(), Matchers.end());\n  }\n  size_t size() const { return Matchers.size(); }\n  bool empty() const { return Matchers.empty(); }\n\n  std::unique_ptr<PredicateMatcher> popFirstCondition() override {\n    // SwitchMatcher doesn't have a common first condition for its cases, as all\n    // the cases only share a kind of a value (a type and a path to it) they\n    // match, but deliberately differ in the actual value they match.\n    llvm_unreachable(\"Trying to pop a condition from a condition-less group\");\n  }\n  const PredicateMatcher &getFirstCondition() const override {\n    llvm_unreachable(\"Trying to pop a condition from a condition-less group\");\n  }\n  bool hasFirstCondition() const override { return false; }\n\nprivate:\n  /// See if the predicate type has a Switch-implementation for it.\n  static bool isSupportedPredicateType(const PredicateMatcher &Predicate);\n\n  bool candidateConditionMatches(const PredicateMatcher &Predicate) const;\n\n  /// emit()-helper\n  static void emitPredicateSpecificOpcodes(const PredicateMatcher &P,\n                                           MatchTable &Table);\n};\n\n/// Generates code to check that a match rule matches.\nclass RuleMatcher : public Matcher {\npublic:\n  using ActionList = std::list<std::unique_ptr<MatchAction>>;\n  using action_iterator = ActionList::iterator;\n\nprotected:\n  /// A list of matchers that all need to succeed for the current rule to match.\n  /// FIXME: This currently supports a single match position but could be\n  /// extended to support multiple positions to support div/rem fusion or\n  /// load-multiple instructions.\n  using MatchersTy = std::vector<std::unique_ptr<InstructionMatcher>> ;\n  MatchersTy Matchers;\n\n  /// A list of actions that need to be taken when all predicates in this rule\n  /// have succeeded.\n  ActionList Actions;\n\n  using DefinedInsnVariablesMap = std::map<InstructionMatcher *, unsigned>;\n\n  /// A map of instruction matchers to the local variables\n  DefinedInsnVariablesMap InsnVariableIDs;\n\n  using MutatableInsnSet = SmallPtrSet<InstructionMatcher *, 4>;\n\n  // The set of instruction matchers that have not yet been claimed for mutation\n  // by a BuildMI.\n  MutatableInsnSet MutatableInsns;\n\n  /// A map of named operands defined by the matchers that may be referenced by\n  /// the renderers.\n  StringMap<OperandMatcher *> DefinedOperands;\n\n  /// A map of anonymous physical register operands defined by the matchers that\n  /// may be referenced by the renderers.\n  DenseMap<Record *, OperandMatcher *> PhysRegOperands;\n\n  /// ID for the next instruction variable defined with implicitlyDefineInsnVar()\n  unsigned NextInsnVarID;\n\n  /// ID for the next output instruction allocated with allocateOutputInsnID()\n  unsigned NextOutputInsnID;\n\n  /// ID for the next temporary register ID allocated with allocateTempRegID()\n  unsigned NextTempRegID;\n\n  std::vector<Record *> RequiredFeatures;\n  std::vector<std::unique_ptr<PredicateMatcher>> EpilogueMatchers;\n\n  ArrayRef<SMLoc> SrcLoc;\n\n  typedef std::tuple<Record *, unsigned, unsigned>\n      DefinedComplexPatternSubOperand;\n  typedef StringMap<DefinedComplexPatternSubOperand>\n      DefinedComplexPatternSubOperandMap;\n  /// A map of Symbolic Names to ComplexPattern sub-operands.\n  DefinedComplexPatternSubOperandMap ComplexSubOperands;\n  /// A map used to for multiple referenced error check of ComplexSubOperand.\n  /// ComplexSubOperand can't be referenced multiple from different operands,\n  /// however multiple references from same operand are allowed since that is\n  /// how 'same operand checks' are generated.\n  StringMap<std::string> ComplexSubOperandsParentName;\n\n  uint64_t RuleID;\n  static uint64_t NextRuleID;\n\npublic:\n  RuleMatcher(ArrayRef<SMLoc> SrcLoc)\n      : Matchers(), Actions(), InsnVariableIDs(), MutatableInsns(),\n        DefinedOperands(), NextInsnVarID(0), NextOutputInsnID(0),\n        NextTempRegID(0), SrcLoc(SrcLoc), ComplexSubOperands(),\n        RuleID(NextRuleID++) {}\n  RuleMatcher(RuleMatcher &&Other) = default;\n  RuleMatcher &operator=(RuleMatcher &&Other) = default;\n\n  uint64_t getRuleID() const { return RuleID; }\n\n  InstructionMatcher &addInstructionMatcher(StringRef SymbolicName);\n  void addRequiredFeature(Record *Feature);\n  const std::vector<Record *> &getRequiredFeatures() const;\n\n  template <class Kind, class... Args> Kind &addAction(Args &&... args);\n  template <class Kind, class... Args>\n  action_iterator insertAction(action_iterator InsertPt, Args &&... args);\n\n  /// Define an instruction without emitting any code to do so.\n  unsigned implicitlyDefineInsnVar(InstructionMatcher &Matcher);\n\n  unsigned getInsnVarID(InstructionMatcher &InsnMatcher) const;\n  DefinedInsnVariablesMap::const_iterator defined_insn_vars_begin() const {\n    return InsnVariableIDs.begin();\n  }\n  DefinedInsnVariablesMap::const_iterator defined_insn_vars_end() const {\n    return InsnVariableIDs.end();\n  }\n  iterator_range<typename DefinedInsnVariablesMap::const_iterator>\n  defined_insn_vars() const {\n    return make_range(defined_insn_vars_begin(), defined_insn_vars_end());\n  }\n\n  MutatableInsnSet::const_iterator mutatable_insns_begin() const {\n    return MutatableInsns.begin();\n  }\n  MutatableInsnSet::const_iterator mutatable_insns_end() const {\n    return MutatableInsns.end();\n  }\n  iterator_range<typename MutatableInsnSet::const_iterator>\n  mutatable_insns() const {\n    return make_range(mutatable_insns_begin(), mutatable_insns_end());\n  }\n  void reserveInsnMatcherForMutation(InstructionMatcher *InsnMatcher) {\n    bool R = MutatableInsns.erase(InsnMatcher);\n    assert(R && \"Reserving a mutatable insn that isn't available\");\n    (void)R;\n  }\n\n  action_iterator actions_begin() { return Actions.begin(); }\n  action_iterator actions_end() { return Actions.end(); }\n  iterator_range<action_iterator> actions() {\n    return make_range(actions_begin(), actions_end());\n  }\n\n  void defineOperand(StringRef SymbolicName, OperandMatcher &OM);\n\n  void definePhysRegOperand(Record *Reg, OperandMatcher &OM);\n\n  Error defineComplexSubOperand(StringRef SymbolicName, Record *ComplexPattern,\n                                unsigned RendererID, unsigned SubOperandID,\n                                StringRef ParentSymbolicName) {\n    std::string ParentName(ParentSymbolicName);\n    if (ComplexSubOperands.count(SymbolicName)) {\n      const std::string &RecordedParentName =\n          ComplexSubOperandsParentName[SymbolicName];\n      if (RecordedParentName != ParentName)\n        return failedImport(\"Error: Complex suboperand \" + SymbolicName +\n                            \" referenced by different operands: \" +\n                            RecordedParentName + \" and \" + ParentName + \".\");\n      // Complex suboperand referenced more than once from same the operand is\n      // used to generate 'same operand check'. Emitting of\n      // GIR_ComplexSubOperandRenderer for them is already handled.\n      return Error::success();\n    }\n\n    ComplexSubOperands[SymbolicName] =\n        std::make_tuple(ComplexPattern, RendererID, SubOperandID);\n    ComplexSubOperandsParentName[SymbolicName] = ParentName;\n\n    return Error::success();\n  }\n\n  Optional<DefinedComplexPatternSubOperand>\n  getComplexSubOperand(StringRef SymbolicName) const {\n    const auto &I = ComplexSubOperands.find(SymbolicName);\n    if (I == ComplexSubOperands.end())\n      return None;\n    return I->second;\n  }\n\n  InstructionMatcher &getInstructionMatcher(StringRef SymbolicName) const;\n  const OperandMatcher &getOperandMatcher(StringRef Name) const;\n  const OperandMatcher &getPhysRegOperandMatcher(Record *) const;\n\n  void optimize() override;\n  void emit(MatchTable &Table) override;\n\n  /// Compare the priority of this object and B.\n  ///\n  /// Returns true if this object is more important than B.\n  bool isHigherPriorityThan(const RuleMatcher &B) const;\n\n  /// Report the maximum number of temporary operands needed by the rule\n  /// matcher.\n  unsigned countRendererFns() const;\n\n  std::unique_ptr<PredicateMatcher> popFirstCondition() override;\n  const PredicateMatcher &getFirstCondition() const override;\n  LLTCodeGen getFirstConditionAsRootType();\n  bool hasFirstCondition() const override;\n  unsigned getNumOperands() const;\n  StringRef getOpcode() const;\n\n  // FIXME: Remove this as soon as possible\n  InstructionMatcher &insnmatchers_front() const { return *Matchers.front(); }\n\n  unsigned allocateOutputInsnID() { return NextOutputInsnID++; }\n  unsigned allocateTempRegID() { return NextTempRegID++; }\n\n  iterator_range<MatchersTy::iterator> insnmatchers() {\n    return make_range(Matchers.begin(), Matchers.end());\n  }\n  bool insnmatchers_empty() const { return Matchers.empty(); }\n  void insnmatchers_pop_front() { Matchers.erase(Matchers.begin()); }\n};\n\nuint64_t RuleMatcher::NextRuleID = 0;\n\nusing action_iterator = RuleMatcher::action_iterator;\n\ntemplate <class PredicateTy> class PredicateListMatcher {\nprivate:\n  /// Template instantiations should specialize this to return a string to use\n  /// for the comment emitted when there are no predicates.\n  std::string getNoPredicateComment() const;\n\nprotected:\n  using PredicatesTy = std::deque<std::unique_ptr<PredicateTy>>;\n  PredicatesTy Predicates;\n\n  /// Track if the list of predicates was manipulated by one of the optimization\n  /// methods.\n  bool Optimized = false;\n\npublic:\n  typename PredicatesTy::iterator predicates_begin() {\n    return Predicates.begin();\n  }\n  typename PredicatesTy::iterator predicates_end() {\n    return Predicates.end();\n  }\n  iterator_range<typename PredicatesTy::iterator> predicates() {\n    return make_range(predicates_begin(), predicates_end());\n  }\n  typename PredicatesTy::size_type predicates_size() const {\n    return Predicates.size();\n  }\n  bool predicates_empty() const { return Predicates.empty(); }\n\n  std::unique_ptr<PredicateTy> predicates_pop_front() {\n    std::unique_ptr<PredicateTy> Front = std::move(Predicates.front());\n    Predicates.pop_front();\n    Optimized = true;\n    return Front;\n  }\n\n  void prependPredicate(std::unique_ptr<PredicateTy> &&Predicate) {\n    Predicates.push_front(std::move(Predicate));\n  }\n\n  void eraseNullPredicates() {\n    const auto NewEnd =\n        std::stable_partition(Predicates.begin(), Predicates.end(),\n                              std::logical_not<std::unique_ptr<PredicateTy>>());\n    if (NewEnd != Predicates.begin()) {\n      Predicates.erase(Predicates.begin(), NewEnd);\n      Optimized = true;\n    }\n  }\n\n  /// Emit MatchTable opcodes that tests whether all the predicates are met.\n  template <class... Args>\n  void emitPredicateListOpcodes(MatchTable &Table, Args &&... args) {\n    if (Predicates.empty() && !Optimized) {\n      Table << MatchTable::Comment(getNoPredicateComment())\n            << MatchTable::LineBreak;\n      return;\n    }\n\n    for (const auto &Predicate : predicates())\n      Predicate->emitPredicateOpcodes(Table, std::forward<Args>(args)...);\n  }\n\n  /// Provide a function to avoid emitting certain predicates. This is used to\n  /// defer some predicate checks until after others\n  using PredicateFilterFunc = std::function<bool(const PredicateTy&)>;\n\n  /// Emit MatchTable opcodes for predicates which satisfy \\p\n  /// ShouldEmitPredicate. This should be called multiple times to ensure all\n  /// predicates are eventually added to the match table.\n  template <class... Args>\n  void emitFilteredPredicateListOpcodes(PredicateFilterFunc ShouldEmitPredicate,\n                                        MatchTable &Table, Args &&... args) {\n    if (Predicates.empty() && !Optimized) {\n      Table << MatchTable::Comment(getNoPredicateComment())\n            << MatchTable::LineBreak;\n      return;\n    }\n\n    for (const auto &Predicate : predicates()) {\n      if (ShouldEmitPredicate(*Predicate))\n        Predicate->emitPredicateOpcodes(Table, std::forward<Args>(args)...);\n    }\n  }\n};\n\nclass PredicateMatcher {\npublic:\n  /// This enum is used for RTTI and also defines the priority that is given to\n  /// the predicate when generating the matcher code. Kinds with higher priority\n  /// must be tested first.\n  ///\n  /// The relative priority of OPM_LLT, OPM_RegBank, and OPM_MBB do not matter\n  /// but OPM_Int must have priority over OPM_RegBank since constant integers\n  /// are represented by a virtual register defined by a G_CONSTANT instruction.\n  ///\n  /// Note: The relative priority between IPM_ and OPM_ does not matter, they\n  /// are currently not compared between each other.\n  enum PredicateKind {\n    IPM_Opcode,\n    IPM_NumOperands,\n    IPM_ImmPredicate,\n    IPM_Imm,\n    IPM_AtomicOrderingMMO,\n    IPM_MemoryLLTSize,\n    IPM_MemoryVsLLTSize,\n    IPM_MemoryAddressSpace,\n    IPM_MemoryAlignment,\n    IPM_VectorSplatImm,\n    IPM_GenericPredicate,\n    OPM_SameOperand,\n    OPM_ComplexPattern,\n    OPM_IntrinsicID,\n    OPM_CmpPredicate,\n    OPM_Instruction,\n    OPM_Int,\n    OPM_LiteralInt,\n    OPM_LLT,\n    OPM_PointerToAny,\n    OPM_RegBank,\n    OPM_MBB,\n    OPM_RecordNamedOperand,\n  };\n\nprotected:\n  PredicateKind Kind;\n  unsigned InsnVarID;\n  unsigned OpIdx;\n\npublic:\n  PredicateMatcher(PredicateKind Kind, unsigned InsnVarID, unsigned OpIdx = ~0)\n      : Kind(Kind), InsnVarID(InsnVarID), OpIdx(OpIdx) {}\n\n  unsigned getInsnVarID() const { return InsnVarID; }\n  unsigned getOpIdx() const { return OpIdx; }\n\n  virtual ~PredicateMatcher() = default;\n  /// Emit MatchTable opcodes that check the predicate for the given operand.\n  virtual void emitPredicateOpcodes(MatchTable &Table,\n                                    RuleMatcher &Rule) const = 0;\n\n  PredicateKind getKind() const { return Kind; }\n\n  bool dependsOnOperands() const {\n    // Custom predicates really depend on the context pattern of the\n    // instruction, not just the individual instruction. This therefore\n    // implicitly depends on all other pattern constraints.\n    return Kind == IPM_GenericPredicate;\n  }\n\n  virtual bool isIdentical(const PredicateMatcher &B) const {\n    return B.getKind() == getKind() && InsnVarID == B.InsnVarID &&\n           OpIdx == B.OpIdx;\n  }\n\n  virtual bool isIdenticalDownToValue(const PredicateMatcher &B) const {\n    return hasValue() && PredicateMatcher::isIdentical(B);\n  }\n\n  virtual MatchTableRecord getValue() const {\n    assert(hasValue() && \"Can not get a value of a value-less predicate!\");\n    llvm_unreachable(\"Not implemented yet\");\n  }\n  virtual bool hasValue() const { return false; }\n\n  /// Report the maximum number of temporary operands needed by the predicate\n  /// matcher.\n  virtual unsigned countRendererFns() const { return 0; }\n};\n\n/// Generates code to check a predicate of an operand.\n///\n/// Typical predicates include:\n/// * Operand is a particular register.\n/// * Operand is assigned a particular register bank.\n/// * Operand is an MBB.\nclass OperandPredicateMatcher : public PredicateMatcher {\npublic:\n  OperandPredicateMatcher(PredicateKind Kind, unsigned InsnVarID,\n                          unsigned OpIdx)\n      : PredicateMatcher(Kind, InsnVarID, OpIdx) {}\n  virtual ~OperandPredicateMatcher() {}\n\n  /// Compare the priority of this object and B.\n  ///\n  /// Returns true if this object is more important than B.\n  virtual bool isHigherPriorityThan(const OperandPredicateMatcher &B) const;\n};\n\ntemplate <>\nstd::string\nPredicateListMatcher<OperandPredicateMatcher>::getNoPredicateComment() const {\n  return \"No operand predicates\";\n}\n\n/// Generates code to check that a register operand is defined by the same exact\n/// one as another.\nclass SameOperandMatcher : public OperandPredicateMatcher {\n  std::string MatchingName;\n\npublic:\n  SameOperandMatcher(unsigned InsnVarID, unsigned OpIdx, StringRef MatchingName)\n      : OperandPredicateMatcher(OPM_SameOperand, InsnVarID, OpIdx),\n        MatchingName(MatchingName) {}\n\n  static bool classof(const PredicateMatcher *P) {\n    return P->getKind() == OPM_SameOperand;\n  }\n\n  void emitPredicateOpcodes(MatchTable &Table,\n                            RuleMatcher &Rule) const override;\n\n  bool isIdentical(const PredicateMatcher &B) const override {\n    return OperandPredicateMatcher::isIdentical(B) &&\n           MatchingName == cast<SameOperandMatcher>(&B)->MatchingName;\n  }\n};\n\n/// Generates code to check that an operand is a particular LLT.\nclass LLTOperandMatcher : public OperandPredicateMatcher {\nprotected:\n  LLTCodeGen Ty;\n\npublic:\n  static std::map<LLTCodeGen, unsigned> TypeIDValues;\n\n  static void initTypeIDValuesMap() {\n    TypeIDValues.clear();\n\n    unsigned ID = 0;\n    for (const LLTCodeGen &LLTy : KnownTypes)\n      TypeIDValues[LLTy] = ID++;\n  }\n\n  LLTOperandMatcher(unsigned InsnVarID, unsigned OpIdx, const LLTCodeGen &Ty)\n      : OperandPredicateMatcher(OPM_LLT, InsnVarID, OpIdx), Ty(Ty) {\n    KnownTypes.insert(Ty);\n  }\n\n  static bool classof(const PredicateMatcher *P) {\n    return P->getKind() == OPM_LLT;\n  }\n  bool isIdentical(const PredicateMatcher &B) const override {\n    return OperandPredicateMatcher::isIdentical(B) &&\n           Ty == cast<LLTOperandMatcher>(&B)->Ty;\n  }\n  MatchTableRecord getValue() const override {\n    const auto VI = TypeIDValues.find(Ty);\n    if (VI == TypeIDValues.end())\n      return MatchTable::NamedValue(getTy().getCxxEnumValue());\n    return MatchTable::NamedValue(getTy().getCxxEnumValue(), VI->second);\n  }\n  bool hasValue() const override {\n    if (TypeIDValues.size() != KnownTypes.size())\n      initTypeIDValuesMap();\n    return TypeIDValues.count(Ty);\n  }\n\n  LLTCodeGen getTy() const { return Ty; }\n\n  void emitPredicateOpcodes(MatchTable &Table,\n                            RuleMatcher &Rule) const override {\n    Table << MatchTable::Opcode(\"GIM_CheckType\") << MatchTable::Comment(\"MI\")\n          << MatchTable::IntValue(InsnVarID) << MatchTable::Comment(\"Op\")\n          << MatchTable::IntValue(OpIdx) << MatchTable::Comment(\"Type\")\n          << getValue() << MatchTable::LineBreak;\n  }\n};\n\nstd::map<LLTCodeGen, unsigned> LLTOperandMatcher::TypeIDValues;\n\n/// Generates code to check that an operand is a pointer to any address space.\n///\n/// In SelectionDAG, the types did not describe pointers or address spaces. As a\n/// result, iN is used to describe a pointer of N bits to any address space and\n/// PatFrag predicates are typically used to constrain the address space. There's\n/// no reliable means to derive the missing type information from the pattern so\n/// imported rules must test the components of a pointer separately.\n///\n/// If SizeInBits is zero, then the pointer size will be obtained from the\n/// subtarget.\nclass PointerToAnyOperandMatcher : public OperandPredicateMatcher {\nprotected:\n  unsigned SizeInBits;\n\npublic:\n  PointerToAnyOperandMatcher(unsigned InsnVarID, unsigned OpIdx,\n                             unsigned SizeInBits)\n      : OperandPredicateMatcher(OPM_PointerToAny, InsnVarID, OpIdx),\n        SizeInBits(SizeInBits) {}\n\n  static bool classof(const PredicateMatcher *P) {\n    return P->getKind() == OPM_PointerToAny;\n  }\n\n  bool isIdentical(const PredicateMatcher &B) const override {\n    return OperandPredicateMatcher::isIdentical(B) &&\n           SizeInBits == cast<PointerToAnyOperandMatcher>(&B)->SizeInBits;\n  }\n\n  void emitPredicateOpcodes(MatchTable &Table,\n                            RuleMatcher &Rule) const override {\n    Table << MatchTable::Opcode(\"GIM_CheckPointerToAny\")\n          << MatchTable::Comment(\"MI\") << MatchTable::IntValue(InsnVarID)\n          << MatchTable::Comment(\"Op\") << MatchTable::IntValue(OpIdx)\n          << MatchTable::Comment(\"SizeInBits\")\n          << MatchTable::IntValue(SizeInBits) << MatchTable::LineBreak;\n  }\n};\n\n/// Generates code to record named operand in RecordedOperands list at StoreIdx.\n/// Predicates with 'let PredicateCodeUsesOperands = 1' get RecordedOperands as\n/// an argument to predicate's c++ code once all operands have been matched.\nclass RecordNamedOperandMatcher : public OperandPredicateMatcher {\nprotected:\n  unsigned StoreIdx;\n  std::string Name;\n\npublic:\n  RecordNamedOperandMatcher(unsigned InsnVarID, unsigned OpIdx,\n                            unsigned StoreIdx, StringRef Name)\n      : OperandPredicateMatcher(OPM_RecordNamedOperand, InsnVarID, OpIdx),\n        StoreIdx(StoreIdx), Name(Name) {}\n\n  static bool classof(const PredicateMatcher *P) {\n    return P->getKind() == OPM_RecordNamedOperand;\n  }\n\n  bool isIdentical(const PredicateMatcher &B) const override {\n    return OperandPredicateMatcher::isIdentical(B) &&\n           StoreIdx == cast<RecordNamedOperandMatcher>(&B)->StoreIdx &&\n           Name == cast<RecordNamedOperandMatcher>(&B)->Name;\n  }\n\n  void emitPredicateOpcodes(MatchTable &Table,\n                            RuleMatcher &Rule) const override {\n    Table << MatchTable::Opcode(\"GIM_RecordNamedOperand\")\n          << MatchTable::Comment(\"MI\") << MatchTable::IntValue(InsnVarID)\n          << MatchTable::Comment(\"Op\") << MatchTable::IntValue(OpIdx)\n          << MatchTable::Comment(\"StoreIdx\") << MatchTable::IntValue(StoreIdx)\n          << MatchTable::Comment(\"Name : \" + Name) << MatchTable::LineBreak;\n  }\n};\n\n/// Generates code to check that an operand is a particular target constant.\nclass ComplexPatternOperandMatcher : public OperandPredicateMatcher {\nprotected:\n  const OperandMatcher &Operand;\n  const Record &TheDef;\n\n  unsigned getAllocatedTemporariesBaseID() const;\n\npublic:\n  bool isIdentical(const PredicateMatcher &B) const override { return false; }\n\n  ComplexPatternOperandMatcher(unsigned InsnVarID, unsigned OpIdx,\n                               const OperandMatcher &Operand,\n                               const Record &TheDef)\n      : OperandPredicateMatcher(OPM_ComplexPattern, InsnVarID, OpIdx),\n        Operand(Operand), TheDef(TheDef) {}\n\n  static bool classof(const PredicateMatcher *P) {\n    return P->getKind() == OPM_ComplexPattern;\n  }\n\n  void emitPredicateOpcodes(MatchTable &Table,\n                            RuleMatcher &Rule) const override {\n    unsigned ID = getAllocatedTemporariesBaseID();\n    Table << MatchTable::Opcode(\"GIM_CheckComplexPattern\")\n          << MatchTable::Comment(\"MI\") << MatchTable::IntValue(InsnVarID)\n          << MatchTable::Comment(\"Op\") << MatchTable::IntValue(OpIdx)\n          << MatchTable::Comment(\"Renderer\") << MatchTable::IntValue(ID)\n          << MatchTable::NamedValue((\"GICP_\" + TheDef.getName()).str())\n          << MatchTable::LineBreak;\n  }\n\n  unsigned countRendererFns() const override {\n    return 1;\n  }\n};\n\n/// Generates code to check that an operand is in a particular register bank.\nclass RegisterBankOperandMatcher : public OperandPredicateMatcher {\nprotected:\n  const CodeGenRegisterClass &RC;\n\npublic:\n  RegisterBankOperandMatcher(unsigned InsnVarID, unsigned OpIdx,\n                             const CodeGenRegisterClass &RC)\n      : OperandPredicateMatcher(OPM_RegBank, InsnVarID, OpIdx), RC(RC) {}\n\n  bool isIdentical(const PredicateMatcher &B) const override {\n    return OperandPredicateMatcher::isIdentical(B) &&\n           RC.getDef() == cast<RegisterBankOperandMatcher>(&B)->RC.getDef();\n  }\n\n  static bool classof(const PredicateMatcher *P) {\n    return P->getKind() == OPM_RegBank;\n  }\n\n  void emitPredicateOpcodes(MatchTable &Table,\n                            RuleMatcher &Rule) const override {\n    Table << MatchTable::Opcode(\"GIM_CheckRegBankForClass\")\n          << MatchTable::Comment(\"MI\") << MatchTable::IntValue(InsnVarID)\n          << MatchTable::Comment(\"Op\") << MatchTable::IntValue(OpIdx)\n          << MatchTable::Comment(\"RC\")\n          << MatchTable::NamedValue(RC.getQualifiedName() + \"RegClassID\")\n          << MatchTable::LineBreak;\n  }\n};\n\n/// Generates code to check that an operand is a basic block.\nclass MBBOperandMatcher : public OperandPredicateMatcher {\npublic:\n  MBBOperandMatcher(unsigned InsnVarID, unsigned OpIdx)\n      : OperandPredicateMatcher(OPM_MBB, InsnVarID, OpIdx) {}\n\n  static bool classof(const PredicateMatcher *P) {\n    return P->getKind() == OPM_MBB;\n  }\n\n  void emitPredicateOpcodes(MatchTable &Table,\n                            RuleMatcher &Rule) const override {\n    Table << MatchTable::Opcode(\"GIM_CheckIsMBB\") << MatchTable::Comment(\"MI\")\n          << MatchTable::IntValue(InsnVarID) << MatchTable::Comment(\"Op\")\n          << MatchTable::IntValue(OpIdx) << MatchTable::LineBreak;\n  }\n};\n\nclass ImmOperandMatcher : public OperandPredicateMatcher {\npublic:\n  ImmOperandMatcher(unsigned InsnVarID, unsigned OpIdx)\n      : OperandPredicateMatcher(IPM_Imm, InsnVarID, OpIdx) {}\n\n  static bool classof(const PredicateMatcher *P) {\n    return P->getKind() == IPM_Imm;\n  }\n\n  void emitPredicateOpcodes(MatchTable &Table,\n                            RuleMatcher &Rule) const override {\n    Table << MatchTable::Opcode(\"GIM_CheckIsImm\") << MatchTable::Comment(\"MI\")\n          << MatchTable::IntValue(InsnVarID) << MatchTable::Comment(\"Op\")\n          << MatchTable::IntValue(OpIdx) << MatchTable::LineBreak;\n  }\n};\n\n/// Generates code to check that an operand is a G_CONSTANT with a particular\n/// int.\nclass ConstantIntOperandMatcher : public OperandPredicateMatcher {\nprotected:\n  int64_t Value;\n\npublic:\n  ConstantIntOperandMatcher(unsigned InsnVarID, unsigned OpIdx, int64_t Value)\n      : OperandPredicateMatcher(OPM_Int, InsnVarID, OpIdx), Value(Value) {}\n\n  bool isIdentical(const PredicateMatcher &B) const override {\n    return OperandPredicateMatcher::isIdentical(B) &&\n           Value == cast<ConstantIntOperandMatcher>(&B)->Value;\n  }\n\n  static bool classof(const PredicateMatcher *P) {\n    return P->getKind() == OPM_Int;\n  }\n\n  void emitPredicateOpcodes(MatchTable &Table,\n                            RuleMatcher &Rule) const override {\n    Table << MatchTable::Opcode(\"GIM_CheckConstantInt\")\n          << MatchTable::Comment(\"MI\") << MatchTable::IntValue(InsnVarID)\n          << MatchTable::Comment(\"Op\") << MatchTable::IntValue(OpIdx)\n          << MatchTable::IntValue(Value) << MatchTable::LineBreak;\n  }\n};\n\n/// Generates code to check that an operand is a raw int (where MO.isImm() or\n/// MO.isCImm() is true).\nclass LiteralIntOperandMatcher : public OperandPredicateMatcher {\nprotected:\n  int64_t Value;\n\npublic:\n  LiteralIntOperandMatcher(unsigned InsnVarID, unsigned OpIdx, int64_t Value)\n      : OperandPredicateMatcher(OPM_LiteralInt, InsnVarID, OpIdx),\n        Value(Value) {}\n\n  bool isIdentical(const PredicateMatcher &B) const override {\n    return OperandPredicateMatcher::isIdentical(B) &&\n           Value == cast<LiteralIntOperandMatcher>(&B)->Value;\n  }\n\n  static bool classof(const PredicateMatcher *P) {\n    return P->getKind() == OPM_LiteralInt;\n  }\n\n  void emitPredicateOpcodes(MatchTable &Table,\n                            RuleMatcher &Rule) const override {\n    Table << MatchTable::Opcode(\"GIM_CheckLiteralInt\")\n          << MatchTable::Comment(\"MI\") << MatchTable::IntValue(InsnVarID)\n          << MatchTable::Comment(\"Op\") << MatchTable::IntValue(OpIdx)\n          << MatchTable::IntValue(Value) << MatchTable::LineBreak;\n  }\n};\n\n/// Generates code to check that an operand is an CmpInst predicate\nclass CmpPredicateOperandMatcher : public OperandPredicateMatcher {\nprotected:\n  std::string PredName;\n\npublic:\n  CmpPredicateOperandMatcher(unsigned InsnVarID, unsigned OpIdx,\n                             std::string P)\n    : OperandPredicateMatcher(OPM_CmpPredicate, InsnVarID, OpIdx), PredName(P) {}\n\n  bool isIdentical(const PredicateMatcher &B) const override {\n    return OperandPredicateMatcher::isIdentical(B) &&\n           PredName == cast<CmpPredicateOperandMatcher>(&B)->PredName;\n  }\n\n  static bool classof(const PredicateMatcher *P) {\n    return P->getKind() == OPM_CmpPredicate;\n  }\n\n  void emitPredicateOpcodes(MatchTable &Table,\n                            RuleMatcher &Rule) const override {\n    Table << MatchTable::Opcode(\"GIM_CheckCmpPredicate\")\n          << MatchTable::Comment(\"MI\") << MatchTable::IntValue(InsnVarID)\n          << MatchTable::Comment(\"Op\") << MatchTable::IntValue(OpIdx)\n          << MatchTable::Comment(\"Predicate\")\n          << MatchTable::NamedValue(\"CmpInst\", PredName)\n          << MatchTable::LineBreak;\n  }\n};\n\n/// Generates code to check that an operand is an intrinsic ID.\nclass IntrinsicIDOperandMatcher : public OperandPredicateMatcher {\nprotected:\n  const CodeGenIntrinsic *II;\n\npublic:\n  IntrinsicIDOperandMatcher(unsigned InsnVarID, unsigned OpIdx,\n                            const CodeGenIntrinsic *II)\n      : OperandPredicateMatcher(OPM_IntrinsicID, InsnVarID, OpIdx), II(II) {}\n\n  bool isIdentical(const PredicateMatcher &B) const override {\n    return OperandPredicateMatcher::isIdentical(B) &&\n           II == cast<IntrinsicIDOperandMatcher>(&B)->II;\n  }\n\n  static bool classof(const PredicateMatcher *P) {\n    return P->getKind() == OPM_IntrinsicID;\n  }\n\n  void emitPredicateOpcodes(MatchTable &Table,\n                            RuleMatcher &Rule) const override {\n    Table << MatchTable::Opcode(\"GIM_CheckIntrinsicID\")\n          << MatchTable::Comment(\"MI\") << MatchTable::IntValue(InsnVarID)\n          << MatchTable::Comment(\"Op\") << MatchTable::IntValue(OpIdx)\n          << MatchTable::NamedValue(\"Intrinsic::\" + II->EnumName)\n          << MatchTable::LineBreak;\n  }\n};\n\n/// Generates code to check that a set of predicates match for a particular\n/// operand.\nclass OperandMatcher : public PredicateListMatcher<OperandPredicateMatcher> {\nprotected:\n  InstructionMatcher &Insn;\n  unsigned OpIdx;\n  std::string SymbolicName;\n\n  /// The index of the first temporary variable allocated to this operand. The\n  /// number of allocated temporaries can be found with\n  /// countRendererFns().\n  unsigned AllocatedTemporariesBaseID;\n\npublic:\n  OperandMatcher(InstructionMatcher &Insn, unsigned OpIdx,\n                 const std::string &SymbolicName,\n                 unsigned AllocatedTemporariesBaseID)\n      : Insn(Insn), OpIdx(OpIdx), SymbolicName(SymbolicName),\n        AllocatedTemporariesBaseID(AllocatedTemporariesBaseID) {}\n\n  bool hasSymbolicName() const { return !SymbolicName.empty(); }\n  StringRef getSymbolicName() const { return SymbolicName; }\n  void setSymbolicName(StringRef Name) {\n    assert(SymbolicName.empty() && \"Operand already has a symbolic name\");\n    SymbolicName = std::string(Name);\n  }\n\n  /// Construct a new operand predicate and add it to the matcher.\n  template <class Kind, class... Args>\n  Optional<Kind *> addPredicate(Args &&... args) {\n    if (isSameAsAnotherOperand())\n      return None;\n    Predicates.emplace_back(std::make_unique<Kind>(\n        getInsnVarID(), getOpIdx(), std::forward<Args>(args)...));\n    return static_cast<Kind *>(Predicates.back().get());\n  }\n\n  unsigned getOpIdx() const { return OpIdx; }\n  unsigned getInsnVarID() const;\n\n  std::string getOperandExpr(unsigned InsnVarID) const {\n    return \"State.MIs[\" + llvm::to_string(InsnVarID) + \"]->getOperand(\" +\n           llvm::to_string(OpIdx) + \")\";\n  }\n\n  InstructionMatcher &getInstructionMatcher() const { return Insn; }\n\n  Error addTypeCheckPredicate(const TypeSetByHwMode &VTy,\n                              bool OperandIsAPointer);\n\n  /// Emit MatchTable opcodes that test whether the instruction named in\n  /// InsnVarID matches all the predicates and all the operands.\n  void emitPredicateOpcodes(MatchTable &Table, RuleMatcher &Rule) {\n    if (!Optimized) {\n      std::string Comment;\n      raw_string_ostream CommentOS(Comment);\n      CommentOS << \"MIs[\" << getInsnVarID() << \"] \";\n      if (SymbolicName.empty())\n        CommentOS << \"Operand \" << OpIdx;\n      else\n        CommentOS << SymbolicName;\n      Table << MatchTable::Comment(CommentOS.str()) << MatchTable::LineBreak;\n    }\n\n    emitPredicateListOpcodes(Table, Rule);\n  }\n\n  /// Compare the priority of this object and B.\n  ///\n  /// Returns true if this object is more important than B.\n  bool isHigherPriorityThan(OperandMatcher &B) {\n    // Operand matchers involving more predicates have higher priority.\n    if (predicates_size() > B.predicates_size())\n      return true;\n    if (predicates_size() < B.predicates_size())\n      return false;\n\n    // This assumes that predicates are added in a consistent order.\n    for (auto &&Predicate : zip(predicates(), B.predicates())) {\n      if (std::get<0>(Predicate)->isHigherPriorityThan(*std::get<1>(Predicate)))\n        return true;\n      if (std::get<1>(Predicate)->isHigherPriorityThan(*std::get<0>(Predicate)))\n        return false;\n    }\n\n    return false;\n  };\n\n  /// Report the maximum number of temporary operands needed by the operand\n  /// matcher.\n  unsigned countRendererFns() {\n    return std::accumulate(\n        predicates().begin(), predicates().end(), 0,\n        [](unsigned A,\n           const std::unique_ptr<OperandPredicateMatcher> &Predicate) {\n          return A + Predicate->countRendererFns();\n        });\n  }\n\n  unsigned getAllocatedTemporariesBaseID() const {\n    return AllocatedTemporariesBaseID;\n  }\n\n  bool isSameAsAnotherOperand() {\n    for (const auto &Predicate : predicates())\n      if (isa<SameOperandMatcher>(Predicate))\n        return true;\n    return false;\n  }\n};\n\nError OperandMatcher::addTypeCheckPredicate(const TypeSetByHwMode &VTy,\n                                            bool OperandIsAPointer) {\n  if (!VTy.isMachineValueType())\n    return failedImport(\"unsupported typeset\");\n\n  if (VTy.getMachineValueType() == MVT::iPTR && OperandIsAPointer) {\n    addPredicate<PointerToAnyOperandMatcher>(0);\n    return Error::success();\n  }\n\n  auto OpTyOrNone = MVTToLLT(VTy.getMachineValueType().SimpleTy);\n  if (!OpTyOrNone)\n    return failedImport(\"unsupported type\");\n\n  if (OperandIsAPointer)\n    addPredicate<PointerToAnyOperandMatcher>(OpTyOrNone->get().getSizeInBits());\n  else if (VTy.isPointer())\n    addPredicate<LLTOperandMatcher>(LLT::pointer(VTy.getPtrAddrSpace(),\n                                                 OpTyOrNone->get().getSizeInBits()));\n  else\n    addPredicate<LLTOperandMatcher>(*OpTyOrNone);\n  return Error::success();\n}\n\nunsigned ComplexPatternOperandMatcher::getAllocatedTemporariesBaseID() const {\n  return Operand.getAllocatedTemporariesBaseID();\n}\n\n/// Generates code to check a predicate on an instruction.\n///\n/// Typical predicates include:\n/// * The opcode of the instruction is a particular value.\n/// * The nsw/nuw flag is/isn't set.\nclass InstructionPredicateMatcher : public PredicateMatcher {\npublic:\n  InstructionPredicateMatcher(PredicateKind Kind, unsigned InsnVarID)\n      : PredicateMatcher(Kind, InsnVarID) {}\n  virtual ~InstructionPredicateMatcher() {}\n\n  /// Compare the priority of this object and B.\n  ///\n  /// Returns true if this object is more important than B.\n  virtual bool\n  isHigherPriorityThan(const InstructionPredicateMatcher &B) const {\n    return Kind < B.Kind;\n  };\n};\n\ntemplate <>\nstd::string\nPredicateListMatcher<PredicateMatcher>::getNoPredicateComment() const {\n  return \"No instruction predicates\";\n}\n\n/// Generates code to check the opcode of an instruction.\nclass InstructionOpcodeMatcher : public InstructionPredicateMatcher {\nprotected:\n  // Allow matching one to several, similar opcodes that share properties. This\n  // is to handle patterns where one SelectionDAG operation maps to multiple\n  // GlobalISel ones (e.g. G_BUILD_VECTOR and G_BUILD_VECTOR_TRUNC). The first\n  // is treated as the canonical opcode.\n  SmallVector<const CodeGenInstruction *, 2> Insts;\n\n  static DenseMap<const CodeGenInstruction *, unsigned> OpcodeValues;\n\n\n  MatchTableRecord getInstValue(const CodeGenInstruction *I) const {\n    const auto VI = OpcodeValues.find(I);\n    if (VI != OpcodeValues.end())\n      return MatchTable::NamedValue(I->Namespace, I->TheDef->getName(),\n                                    VI->second);\n    return MatchTable::NamedValue(I->Namespace, I->TheDef->getName());\n  }\n\npublic:\n  static void initOpcodeValuesMap(const CodeGenTarget &Target) {\n    OpcodeValues.clear();\n\n    unsigned OpcodeValue = 0;\n    for (const CodeGenInstruction *I : Target.getInstructionsByEnumValue())\n      OpcodeValues[I] = OpcodeValue++;\n  }\n\n  InstructionOpcodeMatcher(unsigned InsnVarID,\n                           ArrayRef<const CodeGenInstruction *> I)\n      : InstructionPredicateMatcher(IPM_Opcode, InsnVarID),\n        Insts(I.begin(), I.end()) {\n    assert((Insts.size() == 1 || Insts.size() == 2) &&\n           \"unexpected number of opcode alternatives\");\n  }\n\n  static bool classof(const PredicateMatcher *P) {\n    return P->getKind() == IPM_Opcode;\n  }\n\n  bool isIdentical(const PredicateMatcher &B) const override {\n    return InstructionPredicateMatcher::isIdentical(B) &&\n           Insts == cast<InstructionOpcodeMatcher>(&B)->Insts;\n  }\n\n  bool hasValue() const override {\n    return Insts.size() == 1 && OpcodeValues.count(Insts[0]);\n  }\n\n  // TODO: This is used for the SwitchMatcher optimization. We should be able to\n  // return a list of the opcodes to match.\n  MatchTableRecord getValue() const override {\n    assert(Insts.size() == 1);\n\n    const CodeGenInstruction *I = Insts[0];\n    const auto VI = OpcodeValues.find(I);\n    if (VI != OpcodeValues.end())\n      return MatchTable::NamedValue(I->Namespace, I->TheDef->getName(),\n                                    VI->second);\n    return MatchTable::NamedValue(I->Namespace, I->TheDef->getName());\n  }\n\n  void emitPredicateOpcodes(MatchTable &Table,\n                            RuleMatcher &Rule) const override {\n    StringRef CheckType = Insts.size() == 1 ?\n                          \"GIM_CheckOpcode\" : \"GIM_CheckOpcodeIsEither\";\n    Table << MatchTable::Opcode(CheckType) << MatchTable::Comment(\"MI\")\n          << MatchTable::IntValue(InsnVarID);\n\n    for (const CodeGenInstruction *I : Insts)\n      Table << getInstValue(I);\n    Table << MatchTable::LineBreak;\n  }\n\n  /// Compare the priority of this object and B.\n  ///\n  /// Returns true if this object is more important than B.\n  bool\n  isHigherPriorityThan(const InstructionPredicateMatcher &B) const override {\n    if (InstructionPredicateMatcher::isHigherPriorityThan(B))\n      return true;\n    if (B.InstructionPredicateMatcher::isHigherPriorityThan(*this))\n      return false;\n\n    // Prioritize opcodes for cosmetic reasons in the generated source. Although\n    // this is cosmetic at the moment, we may want to drive a similar ordering\n    // using instruction frequency information to improve compile time.\n    if (const InstructionOpcodeMatcher *BO =\n            dyn_cast<InstructionOpcodeMatcher>(&B))\n      return Insts[0]->TheDef->getName() < BO->Insts[0]->TheDef->getName();\n\n    return false;\n  };\n\n  bool isConstantInstruction() const {\n    return Insts.size() == 1 && Insts[0]->TheDef->getName() == \"G_CONSTANT\";\n  }\n\n  // The first opcode is the canonical opcode, and later are alternatives.\n  StringRef getOpcode() const {\n    return Insts[0]->TheDef->getName();\n  }\n\n  ArrayRef<const CodeGenInstruction *> getAlternativeOpcodes() {\n    return Insts;\n  }\n\n  bool isVariadicNumOperands() const {\n    // If one is variadic, they all should be.\n    return Insts[0]->Operands.isVariadic;\n  }\n\n  StringRef getOperandType(unsigned OpIdx) const {\n    // Types expected to be uniform for all alternatives.\n    return Insts[0]->Operands[OpIdx].OperandType;\n  }\n};\n\nDenseMap<const CodeGenInstruction *, unsigned>\n    InstructionOpcodeMatcher::OpcodeValues;\n\nclass InstructionNumOperandsMatcher final : public InstructionPredicateMatcher {\n  unsigned NumOperands = 0;\n\npublic:\n  InstructionNumOperandsMatcher(unsigned InsnVarID, unsigned NumOperands)\n      : InstructionPredicateMatcher(IPM_NumOperands, InsnVarID),\n        NumOperands(NumOperands) {}\n\n  static bool classof(const PredicateMatcher *P) {\n    return P->getKind() == IPM_NumOperands;\n  }\n\n  bool isIdentical(const PredicateMatcher &B) const override {\n    return InstructionPredicateMatcher::isIdentical(B) &&\n           NumOperands == cast<InstructionNumOperandsMatcher>(&B)->NumOperands;\n  }\n\n  void emitPredicateOpcodes(MatchTable &Table,\n                            RuleMatcher &Rule) const override {\n    Table << MatchTable::Opcode(\"GIM_CheckNumOperands\")\n          << MatchTable::Comment(\"MI\") << MatchTable::IntValue(InsnVarID)\n          << MatchTable::Comment(\"Expected\")\n          << MatchTable::IntValue(NumOperands) << MatchTable::LineBreak;\n  }\n};\n\n/// Generates code to check that this instruction is a constant whose value\n/// meets an immediate predicate.\n///\n/// Immediates are slightly odd since they are typically used like an operand\n/// but are represented as an operator internally. We typically write simm8:$src\n/// in a tablegen pattern, but this is just syntactic sugar for\n/// (imm:i32)<<P:Predicate_simm8>>:$imm which more directly describes the nodes\n/// that will be matched and the predicate (which is attached to the imm\n/// operator) that will be tested. In SelectionDAG this describes a\n/// ConstantSDNode whose internal value will be tested using the simm8 predicate.\n///\n/// The corresponding GlobalISel representation is %1 = G_CONSTANT iN Value. In\n/// this representation, the immediate could be tested with an\n/// InstructionMatcher, InstructionOpcodeMatcher, OperandMatcher, and a\n/// OperandPredicateMatcher-subclass to check the Value meets the predicate but\n/// there are two implementation issues with producing that matcher\n/// configuration from the SelectionDAG pattern:\n/// * ImmLeaf is a PatFrag whose root is an InstructionMatcher. This means that\n///   were we to sink the immediate predicate to the operand we would have to\n///   have two partial implementations of PatFrag support, one for immediates\n///   and one for non-immediates.\n/// * At the point we handle the predicate, the OperandMatcher hasn't been\n///   created yet. If we were to sink the predicate to the OperandMatcher we\n///   would also have to complicate (or duplicate) the code that descends and\n///   creates matchers for the subtree.\n/// Overall, it's simpler to handle it in the place it was found.\nclass InstructionImmPredicateMatcher : public InstructionPredicateMatcher {\nprotected:\n  TreePredicateFn Predicate;\n\npublic:\n  InstructionImmPredicateMatcher(unsigned InsnVarID,\n                                 const TreePredicateFn &Predicate)\n      : InstructionPredicateMatcher(IPM_ImmPredicate, InsnVarID),\n        Predicate(Predicate) {}\n\n  bool isIdentical(const PredicateMatcher &B) const override {\n    return InstructionPredicateMatcher::isIdentical(B) &&\n           Predicate.getOrigPatFragRecord() ==\n               cast<InstructionImmPredicateMatcher>(&B)\n                   ->Predicate.getOrigPatFragRecord();\n  }\n\n  static bool classof(const PredicateMatcher *P) {\n    return P->getKind() == IPM_ImmPredicate;\n  }\n\n  void emitPredicateOpcodes(MatchTable &Table,\n                            RuleMatcher &Rule) const override {\n    Table << MatchTable::Opcode(getMatchOpcodeForPredicate(Predicate))\n          << MatchTable::Comment(\"MI\") << MatchTable::IntValue(InsnVarID)\n          << MatchTable::Comment(\"Predicate\")\n          << MatchTable::NamedValue(getEnumNameForPredicate(Predicate))\n          << MatchTable::LineBreak;\n  }\n};\n\n/// Generates code to check that a memory instruction has a atomic ordering\n/// MachineMemoryOperand.\nclass AtomicOrderingMMOPredicateMatcher : public InstructionPredicateMatcher {\npublic:\n  enum AOComparator {\n    AO_Exactly,\n    AO_OrStronger,\n    AO_WeakerThan,\n  };\n\nprotected:\n  StringRef Order;\n  AOComparator Comparator;\n\npublic:\n  AtomicOrderingMMOPredicateMatcher(unsigned InsnVarID, StringRef Order,\n                                    AOComparator Comparator = AO_Exactly)\n      : InstructionPredicateMatcher(IPM_AtomicOrderingMMO, InsnVarID),\n        Order(Order), Comparator(Comparator) {}\n\n  static bool classof(const PredicateMatcher *P) {\n    return P->getKind() == IPM_AtomicOrderingMMO;\n  }\n\n  bool isIdentical(const PredicateMatcher &B) const override {\n    if (!InstructionPredicateMatcher::isIdentical(B))\n      return false;\n    const auto &R = *cast<AtomicOrderingMMOPredicateMatcher>(&B);\n    return Order == R.Order && Comparator == R.Comparator;\n  }\n\n  void emitPredicateOpcodes(MatchTable &Table,\n                            RuleMatcher &Rule) const override {\n    StringRef Opcode = \"GIM_CheckAtomicOrdering\";\n\n    if (Comparator == AO_OrStronger)\n      Opcode = \"GIM_CheckAtomicOrderingOrStrongerThan\";\n    if (Comparator == AO_WeakerThan)\n      Opcode = \"GIM_CheckAtomicOrderingWeakerThan\";\n\n    Table << MatchTable::Opcode(Opcode) << MatchTable::Comment(\"MI\")\n          << MatchTable::IntValue(InsnVarID) << MatchTable::Comment(\"Order\")\n          << MatchTable::NamedValue((\"(int64_t)AtomicOrdering::\" + Order).str())\n          << MatchTable::LineBreak;\n  }\n};\n\n/// Generates code to check that the size of an MMO is exactly N bytes.\nclass MemorySizePredicateMatcher : public InstructionPredicateMatcher {\nprotected:\n  unsigned MMOIdx;\n  uint64_t Size;\n\npublic:\n  MemorySizePredicateMatcher(unsigned InsnVarID, unsigned MMOIdx, unsigned Size)\n      : InstructionPredicateMatcher(IPM_MemoryLLTSize, InsnVarID),\n        MMOIdx(MMOIdx), Size(Size) {}\n\n  static bool classof(const PredicateMatcher *P) {\n    return P->getKind() == IPM_MemoryLLTSize;\n  }\n  bool isIdentical(const PredicateMatcher &B) const override {\n    return InstructionPredicateMatcher::isIdentical(B) &&\n           MMOIdx == cast<MemorySizePredicateMatcher>(&B)->MMOIdx &&\n           Size == cast<MemorySizePredicateMatcher>(&B)->Size;\n  }\n\n  void emitPredicateOpcodes(MatchTable &Table,\n                            RuleMatcher &Rule) const override {\n    Table << MatchTable::Opcode(\"GIM_CheckMemorySizeEqualTo\")\n          << MatchTable::Comment(\"MI\") << MatchTable::IntValue(InsnVarID)\n          << MatchTable::Comment(\"MMO\") << MatchTable::IntValue(MMOIdx)\n          << MatchTable::Comment(\"Size\") << MatchTable::IntValue(Size)\n          << MatchTable::LineBreak;\n  }\n};\n\nclass MemoryAddressSpacePredicateMatcher : public InstructionPredicateMatcher {\nprotected:\n  unsigned MMOIdx;\n  SmallVector<unsigned, 4> AddrSpaces;\n\npublic:\n  MemoryAddressSpacePredicateMatcher(unsigned InsnVarID, unsigned MMOIdx,\n                                     ArrayRef<unsigned> AddrSpaces)\n      : InstructionPredicateMatcher(IPM_MemoryAddressSpace, InsnVarID),\n        MMOIdx(MMOIdx), AddrSpaces(AddrSpaces.begin(), AddrSpaces.end()) {}\n\n  static bool classof(const PredicateMatcher *P) {\n    return P->getKind() == IPM_MemoryAddressSpace;\n  }\n  bool isIdentical(const PredicateMatcher &B) const override {\n    if (!InstructionPredicateMatcher::isIdentical(B))\n      return false;\n    auto *Other = cast<MemoryAddressSpacePredicateMatcher>(&B);\n    return MMOIdx == Other->MMOIdx && AddrSpaces == Other->AddrSpaces;\n  }\n\n  void emitPredicateOpcodes(MatchTable &Table,\n                            RuleMatcher &Rule) const override {\n    Table << MatchTable::Opcode(\"GIM_CheckMemoryAddressSpace\")\n          << MatchTable::Comment(\"MI\") << MatchTable::IntValue(InsnVarID)\n          << MatchTable::Comment(\"MMO\") << MatchTable::IntValue(MMOIdx)\n        // Encode number of address spaces to expect.\n          << MatchTable::Comment(\"NumAddrSpace\")\n          << MatchTable::IntValue(AddrSpaces.size());\n    for (unsigned AS : AddrSpaces)\n      Table << MatchTable::Comment(\"AddrSpace\") << MatchTable::IntValue(AS);\n\n    Table << MatchTable::LineBreak;\n  }\n};\n\nclass MemoryAlignmentPredicateMatcher : public InstructionPredicateMatcher {\nprotected:\n  unsigned MMOIdx;\n  int MinAlign;\n\npublic:\n  MemoryAlignmentPredicateMatcher(unsigned InsnVarID, unsigned MMOIdx,\n                                  int MinAlign)\n      : InstructionPredicateMatcher(IPM_MemoryAlignment, InsnVarID),\n        MMOIdx(MMOIdx), MinAlign(MinAlign) {\n    assert(MinAlign > 0);\n  }\n\n  static bool classof(const PredicateMatcher *P) {\n    return P->getKind() == IPM_MemoryAlignment;\n  }\n\n  bool isIdentical(const PredicateMatcher &B) const override {\n    if (!InstructionPredicateMatcher::isIdentical(B))\n      return false;\n    auto *Other = cast<MemoryAlignmentPredicateMatcher>(&B);\n    return MMOIdx == Other->MMOIdx && MinAlign == Other->MinAlign;\n  }\n\n  void emitPredicateOpcodes(MatchTable &Table,\n                            RuleMatcher &Rule) const override {\n    Table << MatchTable::Opcode(\"GIM_CheckMemoryAlignment\")\n          << MatchTable::Comment(\"MI\") << MatchTable::IntValue(InsnVarID)\n          << MatchTable::Comment(\"MMO\") << MatchTable::IntValue(MMOIdx)\n          << MatchTable::Comment(\"MinAlign\") << MatchTable::IntValue(MinAlign)\n          << MatchTable::LineBreak;\n  }\n};\n\n/// Generates code to check that the size of an MMO is less-than, equal-to, or\n/// greater than a given LLT.\nclass MemoryVsLLTSizePredicateMatcher : public InstructionPredicateMatcher {\npublic:\n  enum RelationKind {\n    GreaterThan,\n    EqualTo,\n    LessThan,\n  };\n\nprotected:\n  unsigned MMOIdx;\n  RelationKind Relation;\n  unsigned OpIdx;\n\npublic:\n  MemoryVsLLTSizePredicateMatcher(unsigned InsnVarID, unsigned MMOIdx,\n                                  enum RelationKind Relation,\n                                  unsigned OpIdx)\n      : InstructionPredicateMatcher(IPM_MemoryVsLLTSize, InsnVarID),\n        MMOIdx(MMOIdx), Relation(Relation), OpIdx(OpIdx) {}\n\n  static bool classof(const PredicateMatcher *P) {\n    return P->getKind() == IPM_MemoryVsLLTSize;\n  }\n  bool isIdentical(const PredicateMatcher &B) const override {\n    return InstructionPredicateMatcher::isIdentical(B) &&\n           MMOIdx == cast<MemoryVsLLTSizePredicateMatcher>(&B)->MMOIdx &&\n           Relation == cast<MemoryVsLLTSizePredicateMatcher>(&B)->Relation &&\n           OpIdx == cast<MemoryVsLLTSizePredicateMatcher>(&B)->OpIdx;\n  }\n\n  void emitPredicateOpcodes(MatchTable &Table,\n                            RuleMatcher &Rule) const override {\n    Table << MatchTable::Opcode(Relation == EqualTo\n                                    ? \"GIM_CheckMemorySizeEqualToLLT\"\n                                    : Relation == GreaterThan\n                                          ? \"GIM_CheckMemorySizeGreaterThanLLT\"\n                                          : \"GIM_CheckMemorySizeLessThanLLT\")\n          << MatchTable::Comment(\"MI\") << MatchTable::IntValue(InsnVarID)\n          << MatchTable::Comment(\"MMO\") << MatchTable::IntValue(MMOIdx)\n          << MatchTable::Comment(\"OpIdx\") << MatchTable::IntValue(OpIdx)\n          << MatchTable::LineBreak;\n  }\n};\n\n// Matcher for immAllOnesV/immAllZerosV\nclass VectorSplatImmPredicateMatcher : public InstructionPredicateMatcher {\npublic:\n  enum SplatKind {\n    AllZeros,\n    AllOnes\n  };\n\nprivate:\n  SplatKind Kind;\n\npublic:\n  VectorSplatImmPredicateMatcher(unsigned InsnVarID, SplatKind K)\n      : InstructionPredicateMatcher(IPM_VectorSplatImm, InsnVarID), Kind(K) {}\n\n  static bool classof(const PredicateMatcher *P) {\n    return P->getKind() == IPM_VectorSplatImm;\n  }\n\n  bool isIdentical(const PredicateMatcher &B) const override {\n    return InstructionPredicateMatcher::isIdentical(B) &&\n           Kind == static_cast<const VectorSplatImmPredicateMatcher &>(B).Kind;\n  }\n\n  void emitPredicateOpcodes(MatchTable &Table,\n                            RuleMatcher &Rule) const override {\n    if (Kind == AllOnes)\n      Table << MatchTable::Opcode(\"GIM_CheckIsBuildVectorAllOnes\");\n    else\n      Table << MatchTable::Opcode(\"GIM_CheckIsBuildVectorAllZeros\");\n\n    Table << MatchTable::Comment(\"MI\") << MatchTable::IntValue(InsnVarID);\n    Table << MatchTable::LineBreak;\n  }\n};\n\n/// Generates code to check an arbitrary C++ instruction predicate.\nclass GenericInstructionPredicateMatcher : public InstructionPredicateMatcher {\nprotected:\n  TreePredicateFn Predicate;\n\npublic:\n  GenericInstructionPredicateMatcher(unsigned InsnVarID,\n                                     TreePredicateFn Predicate)\n      : InstructionPredicateMatcher(IPM_GenericPredicate, InsnVarID),\n        Predicate(Predicate) {}\n\n  static bool classof(const InstructionPredicateMatcher *P) {\n    return P->getKind() == IPM_GenericPredicate;\n  }\n  bool isIdentical(const PredicateMatcher &B) const override {\n    return InstructionPredicateMatcher::isIdentical(B) &&\n           Predicate ==\n               static_cast<const GenericInstructionPredicateMatcher &>(B)\n                   .Predicate;\n  }\n  void emitPredicateOpcodes(MatchTable &Table,\n                            RuleMatcher &Rule) const override {\n    Table << MatchTable::Opcode(\"GIM_CheckCxxInsnPredicate\")\n          << MatchTable::Comment(\"MI\") << MatchTable::IntValue(InsnVarID)\n          << MatchTable::Comment(\"FnId\")\n          << MatchTable::NamedValue(getEnumNameForPredicate(Predicate))\n          << MatchTable::LineBreak;\n  }\n};\n\n/// Generates code to check that a set of predicates and operands match for a\n/// particular instruction.\n///\n/// Typical predicates include:\n/// * Has a specific opcode.\n/// * Has an nsw/nuw flag or doesn't.\nclass InstructionMatcher final : public PredicateListMatcher<PredicateMatcher> {\nprotected:\n  typedef std::vector<std::unique_ptr<OperandMatcher>> OperandVec;\n\n  RuleMatcher &Rule;\n\n  /// The operands to match. All rendered operands must be present even if the\n  /// condition is always true.\n  OperandVec Operands;\n  bool NumOperandsCheck = true;\n\n  std::string SymbolicName;\n  unsigned InsnVarID;\n\n  /// PhysRegInputs - List list has an entry for each explicitly specified\n  /// physreg input to the pattern.  The first elt is the Register node, the\n  /// second is the recorded slot number the input pattern match saved it in.\n  SmallVector<std::pair<Record *, unsigned>, 2> PhysRegInputs;\n\npublic:\n  InstructionMatcher(RuleMatcher &Rule, StringRef SymbolicName,\n                     bool NumOpsCheck = true)\n      : Rule(Rule), NumOperandsCheck(NumOpsCheck), SymbolicName(SymbolicName) {\n    // We create a new instruction matcher.\n    // Get a new ID for that instruction.\n    InsnVarID = Rule.implicitlyDefineInsnVar(*this);\n  }\n\n  /// Construct a new instruction predicate and add it to the matcher.\n  template <class Kind, class... Args>\n  Optional<Kind *> addPredicate(Args &&... args) {\n    Predicates.emplace_back(\n        std::make_unique<Kind>(getInsnVarID(), std::forward<Args>(args)...));\n    return static_cast<Kind *>(Predicates.back().get());\n  }\n\n  RuleMatcher &getRuleMatcher() const { return Rule; }\n\n  unsigned getInsnVarID() const { return InsnVarID; }\n\n  /// Add an operand to the matcher.\n  OperandMatcher &addOperand(unsigned OpIdx, const std::string &SymbolicName,\n                             unsigned AllocatedTemporariesBaseID) {\n    Operands.emplace_back(new OperandMatcher(*this, OpIdx, SymbolicName,\n                                             AllocatedTemporariesBaseID));\n    if (!SymbolicName.empty())\n      Rule.defineOperand(SymbolicName, *Operands.back());\n\n    return *Operands.back();\n  }\n\n  OperandMatcher &getOperand(unsigned OpIdx) {\n    auto I = llvm::find_if(Operands,\n                           [&OpIdx](const std::unique_ptr<OperandMatcher> &X) {\n                             return X->getOpIdx() == OpIdx;\n                           });\n    if (I != Operands.end())\n      return **I;\n    llvm_unreachable(\"Failed to lookup operand\");\n  }\n\n  OperandMatcher &addPhysRegInput(Record *Reg, unsigned OpIdx,\n                                  unsigned TempOpIdx) {\n    assert(SymbolicName.empty());\n    OperandMatcher *OM = new OperandMatcher(*this, OpIdx, \"\", TempOpIdx);\n    Operands.emplace_back(OM);\n    Rule.definePhysRegOperand(Reg, *OM);\n    PhysRegInputs.emplace_back(Reg, OpIdx);\n    return *OM;\n  }\n\n  ArrayRef<std::pair<Record *, unsigned>> getPhysRegInputs() const {\n    return PhysRegInputs;\n  }\n\n  StringRef getSymbolicName() const { return SymbolicName; }\n  unsigned getNumOperands() const { return Operands.size(); }\n  OperandVec::iterator operands_begin() { return Operands.begin(); }\n  OperandVec::iterator operands_end() { return Operands.end(); }\n  iterator_range<OperandVec::iterator> operands() {\n    return make_range(operands_begin(), operands_end());\n  }\n  OperandVec::const_iterator operands_begin() const { return Operands.begin(); }\n  OperandVec::const_iterator operands_end() const { return Operands.end(); }\n  iterator_range<OperandVec::const_iterator> operands() const {\n    return make_range(operands_begin(), operands_end());\n  }\n  bool operands_empty() const { return Operands.empty(); }\n\n  void pop_front() { Operands.erase(Operands.begin()); }\n\n  void optimize();\n\n  /// Emit MatchTable opcodes that test whether the instruction named in\n  /// InsnVarName matches all the predicates and all the operands.\n  void emitPredicateOpcodes(MatchTable &Table, RuleMatcher &Rule) {\n    if (NumOperandsCheck)\n      InstructionNumOperandsMatcher(InsnVarID, getNumOperands())\n          .emitPredicateOpcodes(Table, Rule);\n\n    // First emit all instruction level predicates need to be verified before we\n    // can verify operands.\n    emitFilteredPredicateListOpcodes(\n      [](const PredicateMatcher &P) {\n        return !P.dependsOnOperands();\n      }, Table, Rule);\n\n    // Emit all operand constraints.\n    for (const auto &Operand : Operands)\n      Operand->emitPredicateOpcodes(Table, Rule);\n\n    // All of the tablegen defined predicates should now be matched. Now emit\n    // any custom predicates that rely on all generated checks.\n    emitFilteredPredicateListOpcodes(\n      [](const PredicateMatcher &P) {\n        return P.dependsOnOperands();\n      }, Table, Rule);\n  }\n\n  /// Compare the priority of this object and B.\n  ///\n  /// Returns true if this object is more important than B.\n  bool isHigherPriorityThan(InstructionMatcher &B) {\n    // Instruction matchers involving more operands have higher priority.\n    if (Operands.size() > B.Operands.size())\n      return true;\n    if (Operands.size() < B.Operands.size())\n      return false;\n\n    for (auto &&P : zip(predicates(), B.predicates())) {\n      auto L = static_cast<InstructionPredicateMatcher *>(std::get<0>(P).get());\n      auto R = static_cast<InstructionPredicateMatcher *>(std::get<1>(P).get());\n      if (L->isHigherPriorityThan(*R))\n        return true;\n      if (R->isHigherPriorityThan(*L))\n        return false;\n    }\n\n    for (auto Operand : zip(Operands, B.Operands)) {\n      if (std::get<0>(Operand)->isHigherPriorityThan(*std::get<1>(Operand)))\n        return true;\n      if (std::get<1>(Operand)->isHigherPriorityThan(*std::get<0>(Operand)))\n        return false;\n    }\n\n    return false;\n  };\n\n  /// Report the maximum number of temporary operands needed by the instruction\n  /// matcher.\n  unsigned countRendererFns() {\n    return std::accumulate(\n               predicates().begin(), predicates().end(), 0,\n               [](unsigned A,\n                  const std::unique_ptr<PredicateMatcher> &Predicate) {\n                 return A + Predicate->countRendererFns();\n               }) +\n           std::accumulate(\n               Operands.begin(), Operands.end(), 0,\n               [](unsigned A, const std::unique_ptr<OperandMatcher> &Operand) {\n                 return A + Operand->countRendererFns();\n               });\n  }\n\n  InstructionOpcodeMatcher &getOpcodeMatcher() {\n    for (auto &P : predicates())\n      if (auto *OpMatcher = dyn_cast<InstructionOpcodeMatcher>(P.get()))\n        return *OpMatcher;\n    llvm_unreachable(\"Didn't find an opcode matcher\");\n  }\n\n  bool isConstantInstruction() {\n    return getOpcodeMatcher().isConstantInstruction();\n  }\n\n  StringRef getOpcode() { return getOpcodeMatcher().getOpcode(); }\n};\n\nStringRef RuleMatcher::getOpcode() const {\n  return Matchers.front()->getOpcode();\n}\n\nunsigned RuleMatcher::getNumOperands() const {\n  return Matchers.front()->getNumOperands();\n}\n\nLLTCodeGen RuleMatcher::getFirstConditionAsRootType() {\n  InstructionMatcher &InsnMatcher = *Matchers.front();\n  if (!InsnMatcher.predicates_empty())\n    if (const auto *TM =\n            dyn_cast<LLTOperandMatcher>(&**InsnMatcher.predicates_begin()))\n      if (TM->getInsnVarID() == 0 && TM->getOpIdx() == 0)\n        return TM->getTy();\n  return {};\n}\n\n/// Generates code to check that the operand is a register defined by an\n/// instruction that matches the given instruction matcher.\n///\n/// For example, the pattern:\n///   (set $dst, (G_MUL (G_ADD $src1, $src2), $src3))\n/// would use an InstructionOperandMatcher for operand 1 of the G_MUL to match\n/// the:\n///   (G_ADD $src1, $src2)\n/// subpattern.\nclass InstructionOperandMatcher : public OperandPredicateMatcher {\nprotected:\n  std::unique_ptr<InstructionMatcher> InsnMatcher;\n\npublic:\n  InstructionOperandMatcher(unsigned InsnVarID, unsigned OpIdx,\n                            RuleMatcher &Rule, StringRef SymbolicName,\n                            bool NumOpsCheck = true)\n      : OperandPredicateMatcher(OPM_Instruction, InsnVarID, OpIdx),\n        InsnMatcher(new InstructionMatcher(Rule, SymbolicName, NumOpsCheck)) {}\n\n  static bool classof(const PredicateMatcher *P) {\n    return P->getKind() == OPM_Instruction;\n  }\n\n  InstructionMatcher &getInsnMatcher() const { return *InsnMatcher; }\n\n  void emitCaptureOpcodes(MatchTable &Table, RuleMatcher &Rule) const {\n    const unsigned NewInsnVarID = InsnMatcher->getInsnVarID();\n    Table << MatchTable::Opcode(\"GIM_RecordInsn\")\n          << MatchTable::Comment(\"DefineMI\")\n          << MatchTable::IntValue(NewInsnVarID) << MatchTable::Comment(\"MI\")\n          << MatchTable::IntValue(getInsnVarID())\n          << MatchTable::Comment(\"OpIdx\") << MatchTable::IntValue(getOpIdx())\n          << MatchTable::Comment(\"MIs[\" + llvm::to_string(NewInsnVarID) + \"]\")\n          << MatchTable::LineBreak;\n  }\n\n  void emitPredicateOpcodes(MatchTable &Table,\n                            RuleMatcher &Rule) const override {\n    emitCaptureOpcodes(Table, Rule);\n    InsnMatcher->emitPredicateOpcodes(Table, Rule);\n  }\n\n  bool isHigherPriorityThan(const OperandPredicateMatcher &B) const override {\n    if (OperandPredicateMatcher::isHigherPriorityThan(B))\n      return true;\n    if (B.OperandPredicateMatcher::isHigherPriorityThan(*this))\n      return false;\n\n    if (const InstructionOperandMatcher *BP =\n            dyn_cast<InstructionOperandMatcher>(&B))\n      if (InsnMatcher->isHigherPriorityThan(*BP->InsnMatcher))\n        return true;\n    return false;\n  }\n};\n\nvoid InstructionMatcher::optimize() {\n  SmallVector<std::unique_ptr<PredicateMatcher>, 8> Stash;\n  const auto &OpcMatcher = getOpcodeMatcher();\n\n  Stash.push_back(predicates_pop_front());\n  if (Stash.back().get() == &OpcMatcher) {\n    if (NumOperandsCheck && OpcMatcher.isVariadicNumOperands())\n      Stash.emplace_back(\n          new InstructionNumOperandsMatcher(InsnVarID, getNumOperands()));\n    NumOperandsCheck = false;\n\n    for (auto &OM : Operands)\n      for (auto &OP : OM->predicates())\n        if (isa<IntrinsicIDOperandMatcher>(OP)) {\n          Stash.push_back(std::move(OP));\n          OM->eraseNullPredicates();\n          break;\n        }\n  }\n\n  if (InsnVarID > 0) {\n    assert(!Operands.empty() && \"Nested instruction is expected to def a vreg\");\n    for (auto &OP : Operands[0]->predicates())\n      OP.reset();\n    Operands[0]->eraseNullPredicates();\n  }\n  for (auto &OM : Operands) {\n    for (auto &OP : OM->predicates())\n      if (isa<LLTOperandMatcher>(OP))\n        Stash.push_back(std::move(OP));\n    OM->eraseNullPredicates();\n  }\n  while (!Stash.empty())\n    prependPredicate(Stash.pop_back_val());\n}\n\n//===- Actions ------------------------------------------------------------===//\nclass OperandRenderer {\npublic:\n  enum RendererKind {\n    OR_Copy,\n    OR_CopyOrAddZeroReg,\n    OR_CopySubReg,\n    OR_CopyPhysReg,\n    OR_CopyConstantAsImm,\n    OR_CopyFConstantAsFPImm,\n    OR_Imm,\n    OR_SubRegIndex,\n    OR_Register,\n    OR_TempRegister,\n    OR_ComplexPattern,\n    OR_Custom,\n    OR_CustomOperand\n  };\n\nprotected:\n  RendererKind Kind;\n\npublic:\n  OperandRenderer(RendererKind Kind) : Kind(Kind) {}\n  virtual ~OperandRenderer() {}\n\n  RendererKind getKind() const { return Kind; }\n\n  virtual void emitRenderOpcodes(MatchTable &Table,\n                                 RuleMatcher &Rule) const = 0;\n};\n\n/// A CopyRenderer emits code to copy a single operand from an existing\n/// instruction to the one being built.\nclass CopyRenderer : public OperandRenderer {\nprotected:\n  unsigned NewInsnID;\n  /// The name of the operand.\n  const StringRef SymbolicName;\n\npublic:\n  CopyRenderer(unsigned NewInsnID, StringRef SymbolicName)\n      : OperandRenderer(OR_Copy), NewInsnID(NewInsnID),\n        SymbolicName(SymbolicName) {\n    assert(!SymbolicName.empty() && \"Cannot copy from an unspecified source\");\n  }\n\n  static bool classof(const OperandRenderer *R) {\n    return R->getKind() == OR_Copy;\n  }\n\n  StringRef getSymbolicName() const { return SymbolicName; }\n\n  void emitRenderOpcodes(MatchTable &Table, RuleMatcher &Rule) const override {\n    const OperandMatcher &Operand = Rule.getOperandMatcher(SymbolicName);\n    unsigned OldInsnVarID = Rule.getInsnVarID(Operand.getInstructionMatcher());\n    Table << MatchTable::Opcode(\"GIR_Copy\") << MatchTable::Comment(\"NewInsnID\")\n          << MatchTable::IntValue(NewInsnID) << MatchTable::Comment(\"OldInsnID\")\n          << MatchTable::IntValue(OldInsnVarID) << MatchTable::Comment(\"OpIdx\")\n          << MatchTable::IntValue(Operand.getOpIdx())\n          << MatchTable::Comment(SymbolicName) << MatchTable::LineBreak;\n  }\n};\n\n/// A CopyRenderer emits code to copy a virtual register to a specific physical\n/// register.\nclass CopyPhysRegRenderer : public OperandRenderer {\nprotected:\n  unsigned NewInsnID;\n  Record *PhysReg;\n\npublic:\n  CopyPhysRegRenderer(unsigned NewInsnID, Record *Reg)\n      : OperandRenderer(OR_CopyPhysReg), NewInsnID(NewInsnID),\n        PhysReg(Reg) {\n    assert(PhysReg);\n  }\n\n  static bool classof(const OperandRenderer *R) {\n    return R->getKind() == OR_CopyPhysReg;\n  }\n\n  Record *getPhysReg() const { return PhysReg; }\n\n  void emitRenderOpcodes(MatchTable &Table, RuleMatcher &Rule) const override {\n    const OperandMatcher &Operand = Rule.getPhysRegOperandMatcher(PhysReg);\n    unsigned OldInsnVarID = Rule.getInsnVarID(Operand.getInstructionMatcher());\n    Table << MatchTable::Opcode(\"GIR_Copy\") << MatchTable::Comment(\"NewInsnID\")\n          << MatchTable::IntValue(NewInsnID) << MatchTable::Comment(\"OldInsnID\")\n          << MatchTable::IntValue(OldInsnVarID) << MatchTable::Comment(\"OpIdx\")\n          << MatchTable::IntValue(Operand.getOpIdx())\n          << MatchTable::Comment(PhysReg->getName())\n          << MatchTable::LineBreak;\n  }\n};\n\n/// A CopyOrAddZeroRegRenderer emits code to copy a single operand from an\n/// existing instruction to the one being built. If the operand turns out to be\n/// a 'G_CONSTANT 0' then it replaces the operand with a zero register.\nclass CopyOrAddZeroRegRenderer : public OperandRenderer {\nprotected:\n  unsigned NewInsnID;\n  /// The name of the operand.\n  const StringRef SymbolicName;\n  const Record *ZeroRegisterDef;\n\npublic:\n  CopyOrAddZeroRegRenderer(unsigned NewInsnID,\n                           StringRef SymbolicName, Record *ZeroRegisterDef)\n      : OperandRenderer(OR_CopyOrAddZeroReg), NewInsnID(NewInsnID),\n        SymbolicName(SymbolicName), ZeroRegisterDef(ZeroRegisterDef) {\n    assert(!SymbolicName.empty() && \"Cannot copy from an unspecified source\");\n  }\n\n  static bool classof(const OperandRenderer *R) {\n    return R->getKind() == OR_CopyOrAddZeroReg;\n  }\n\n  StringRef getSymbolicName() const { return SymbolicName; }\n\n  void emitRenderOpcodes(MatchTable &Table, RuleMatcher &Rule) const override {\n    const OperandMatcher &Operand = Rule.getOperandMatcher(SymbolicName);\n    unsigned OldInsnVarID = Rule.getInsnVarID(Operand.getInstructionMatcher());\n    Table << MatchTable::Opcode(\"GIR_CopyOrAddZeroReg\")\n          << MatchTable::Comment(\"NewInsnID\") << MatchTable::IntValue(NewInsnID)\n          << MatchTable::Comment(\"OldInsnID\")\n          << MatchTable::IntValue(OldInsnVarID) << MatchTable::Comment(\"OpIdx\")\n          << MatchTable::IntValue(Operand.getOpIdx())\n          << MatchTable::NamedValue(\n                 (ZeroRegisterDef->getValue(\"Namespace\")\n                      ? ZeroRegisterDef->getValueAsString(\"Namespace\")\n                      : \"\"),\n                 ZeroRegisterDef->getName())\n          << MatchTable::Comment(SymbolicName) << MatchTable::LineBreak;\n  }\n};\n\n/// A CopyConstantAsImmRenderer emits code to render a G_CONSTANT instruction to\n/// an extended immediate operand.\nclass CopyConstantAsImmRenderer : public OperandRenderer {\nprotected:\n  unsigned NewInsnID;\n  /// The name of the operand.\n  const std::string SymbolicName;\n  bool Signed;\n\npublic:\n  CopyConstantAsImmRenderer(unsigned NewInsnID, StringRef SymbolicName)\n      : OperandRenderer(OR_CopyConstantAsImm), NewInsnID(NewInsnID),\n        SymbolicName(SymbolicName), Signed(true) {}\n\n  static bool classof(const OperandRenderer *R) {\n    return R->getKind() == OR_CopyConstantAsImm;\n  }\n\n  StringRef getSymbolicName() const { return SymbolicName; }\n\n  void emitRenderOpcodes(MatchTable &Table, RuleMatcher &Rule) const override {\n    InstructionMatcher &InsnMatcher = Rule.getInstructionMatcher(SymbolicName);\n    unsigned OldInsnVarID = Rule.getInsnVarID(InsnMatcher);\n    Table << MatchTable::Opcode(Signed ? \"GIR_CopyConstantAsSImm\"\n                                       : \"GIR_CopyConstantAsUImm\")\n          << MatchTable::Comment(\"NewInsnID\") << MatchTable::IntValue(NewInsnID)\n          << MatchTable::Comment(\"OldInsnID\")\n          << MatchTable::IntValue(OldInsnVarID)\n          << MatchTable::Comment(SymbolicName) << MatchTable::LineBreak;\n  }\n};\n\n/// A CopyFConstantAsFPImmRenderer emits code to render a G_FCONSTANT\n/// instruction to an extended immediate operand.\nclass CopyFConstantAsFPImmRenderer : public OperandRenderer {\nprotected:\n  unsigned NewInsnID;\n  /// The name of the operand.\n  const std::string SymbolicName;\n\npublic:\n  CopyFConstantAsFPImmRenderer(unsigned NewInsnID, StringRef SymbolicName)\n      : OperandRenderer(OR_CopyFConstantAsFPImm), NewInsnID(NewInsnID),\n        SymbolicName(SymbolicName) {}\n\n  static bool classof(const OperandRenderer *R) {\n    return R->getKind() == OR_CopyFConstantAsFPImm;\n  }\n\n  StringRef getSymbolicName() const { return SymbolicName; }\n\n  void emitRenderOpcodes(MatchTable &Table, RuleMatcher &Rule) const override {\n    InstructionMatcher &InsnMatcher = Rule.getInstructionMatcher(SymbolicName);\n    unsigned OldInsnVarID = Rule.getInsnVarID(InsnMatcher);\n    Table << MatchTable::Opcode(\"GIR_CopyFConstantAsFPImm\")\n          << MatchTable::Comment(\"NewInsnID\") << MatchTable::IntValue(NewInsnID)\n          << MatchTable::Comment(\"OldInsnID\")\n          << MatchTable::IntValue(OldInsnVarID)\n          << MatchTable::Comment(SymbolicName) << MatchTable::LineBreak;\n  }\n};\n\n/// A CopySubRegRenderer emits code to copy a single register operand from an\n/// existing instruction to the one being built and indicate that only a\n/// subregister should be copied.\nclass CopySubRegRenderer : public OperandRenderer {\nprotected:\n  unsigned NewInsnID;\n  /// The name of the operand.\n  const StringRef SymbolicName;\n  /// The subregister to extract.\n  const CodeGenSubRegIndex *SubReg;\n\npublic:\n  CopySubRegRenderer(unsigned NewInsnID, StringRef SymbolicName,\n                     const CodeGenSubRegIndex *SubReg)\n      : OperandRenderer(OR_CopySubReg), NewInsnID(NewInsnID),\n        SymbolicName(SymbolicName), SubReg(SubReg) {}\n\n  static bool classof(const OperandRenderer *R) {\n    return R->getKind() == OR_CopySubReg;\n  }\n\n  StringRef getSymbolicName() const { return SymbolicName; }\n\n  void emitRenderOpcodes(MatchTable &Table, RuleMatcher &Rule) const override {\n    const OperandMatcher &Operand = Rule.getOperandMatcher(SymbolicName);\n    unsigned OldInsnVarID = Rule.getInsnVarID(Operand.getInstructionMatcher());\n    Table << MatchTable::Opcode(\"GIR_CopySubReg\")\n          << MatchTable::Comment(\"NewInsnID\") << MatchTable::IntValue(NewInsnID)\n          << MatchTable::Comment(\"OldInsnID\")\n          << MatchTable::IntValue(OldInsnVarID) << MatchTable::Comment(\"OpIdx\")\n          << MatchTable::IntValue(Operand.getOpIdx())\n          << MatchTable::Comment(\"SubRegIdx\")\n          << MatchTable::IntValue(SubReg->EnumValue)\n          << MatchTable::Comment(SymbolicName) << MatchTable::LineBreak;\n  }\n};\n\n/// Adds a specific physical register to the instruction being built.\n/// This is typically useful for WZR/XZR on AArch64.\nclass AddRegisterRenderer : public OperandRenderer {\nprotected:\n  unsigned InsnID;\n  const Record *RegisterDef;\n  bool IsDef;\n  const CodeGenTarget &Target;\n\npublic:\n  AddRegisterRenderer(unsigned InsnID, const CodeGenTarget &Target,\n                      const Record *RegisterDef, bool IsDef = false)\n      : OperandRenderer(OR_Register), InsnID(InsnID), RegisterDef(RegisterDef),\n        IsDef(IsDef), Target(Target) {}\n\n  static bool classof(const OperandRenderer *R) {\n    return R->getKind() == OR_Register;\n  }\n\n  void emitRenderOpcodes(MatchTable &Table, RuleMatcher &Rule) const override {\n    Table << MatchTable::Opcode(\"GIR_AddRegister\")\n          << MatchTable::Comment(\"InsnID\") << MatchTable::IntValue(InsnID);\n    if (RegisterDef->getName() != \"zero_reg\") {\n      Table << MatchTable::NamedValue(\n                   (RegisterDef->getValue(\"Namespace\")\n                        ? RegisterDef->getValueAsString(\"Namespace\")\n                        : \"\"),\n                   RegisterDef->getName());\n    } else {\n      Table << MatchTable::NamedValue(Target.getRegNamespace(), \"NoRegister\");\n    }\n    Table << MatchTable::Comment(\"AddRegisterRegFlags\");\n\n    // TODO: This is encoded as a 64-bit element, but only 16 or 32-bits are\n    // really needed for a physical register reference. We can pack the\n    // register and flags in a single field.\n    if (IsDef)\n      Table << MatchTable::NamedValue(\"RegState::Define\");\n    else\n      Table << MatchTable::IntValue(0);\n    Table << MatchTable::LineBreak;\n  }\n};\n\n/// Adds a specific temporary virtual register to the instruction being built.\n/// This is used to chain instructions together when emitting multiple\n/// instructions.\nclass TempRegRenderer : public OperandRenderer {\nprotected:\n  unsigned InsnID;\n  unsigned TempRegID;\n  const CodeGenSubRegIndex *SubRegIdx;\n  bool IsDef;\n  bool IsDead;\n\npublic:\n  TempRegRenderer(unsigned InsnID, unsigned TempRegID, bool IsDef = false,\n                  const CodeGenSubRegIndex *SubReg = nullptr,\n                  bool IsDead = false)\n      : OperandRenderer(OR_Register), InsnID(InsnID), TempRegID(TempRegID),\n        SubRegIdx(SubReg), IsDef(IsDef), IsDead(IsDead) {}\n\n  static bool classof(const OperandRenderer *R) {\n    return R->getKind() == OR_TempRegister;\n  }\n\n  void emitRenderOpcodes(MatchTable &Table, RuleMatcher &Rule) const override {\n    if (SubRegIdx) {\n      assert(!IsDef);\n      Table << MatchTable::Opcode(\"GIR_AddTempSubRegister\");\n    } else\n      Table << MatchTable::Opcode(\"GIR_AddTempRegister\");\n\n    Table << MatchTable::Comment(\"InsnID\") << MatchTable::IntValue(InsnID)\n          << MatchTable::Comment(\"TempRegID\") << MatchTable::IntValue(TempRegID)\n          << MatchTable::Comment(\"TempRegFlags\");\n\n    if (IsDef) {\n      SmallString<32> RegFlags;\n      RegFlags += \"RegState::Define\";\n      if (IsDead)\n        RegFlags += \"|RegState::Dead\";\n      Table << MatchTable::NamedValue(RegFlags);\n    } else\n      Table << MatchTable::IntValue(0);\n\n    if (SubRegIdx)\n      Table << MatchTable::NamedValue(SubRegIdx->getQualifiedName());\n    Table << MatchTable::LineBreak;\n  }\n};\n\n/// Adds a specific immediate to the instruction being built.\nclass ImmRenderer : public OperandRenderer {\nprotected:\n  unsigned InsnID;\n  int64_t Imm;\n\npublic:\n  ImmRenderer(unsigned InsnID, int64_t Imm)\n      : OperandRenderer(OR_Imm), InsnID(InsnID), Imm(Imm) {}\n\n  static bool classof(const OperandRenderer *R) {\n    return R->getKind() == OR_Imm;\n  }\n\n  void emitRenderOpcodes(MatchTable &Table, RuleMatcher &Rule) const override {\n    Table << MatchTable::Opcode(\"GIR_AddImm\") << MatchTable::Comment(\"InsnID\")\n          << MatchTable::IntValue(InsnID) << MatchTable::Comment(\"Imm\")\n          << MatchTable::IntValue(Imm) << MatchTable::LineBreak;\n  }\n};\n\n/// Adds an enum value for a subreg index to the instruction being built.\nclass SubRegIndexRenderer : public OperandRenderer {\nprotected:\n  unsigned InsnID;\n  const CodeGenSubRegIndex *SubRegIdx;\n\npublic:\n  SubRegIndexRenderer(unsigned InsnID, const CodeGenSubRegIndex *SRI)\n      : OperandRenderer(OR_SubRegIndex), InsnID(InsnID), SubRegIdx(SRI) {}\n\n  static bool classof(const OperandRenderer *R) {\n    return R->getKind() == OR_SubRegIndex;\n  }\n\n  void emitRenderOpcodes(MatchTable &Table, RuleMatcher &Rule) const override {\n    Table << MatchTable::Opcode(\"GIR_AddImm\") << MatchTable::Comment(\"InsnID\")\n          << MatchTable::IntValue(InsnID) << MatchTable::Comment(\"SubRegIndex\")\n          << MatchTable::IntValue(SubRegIdx->EnumValue)\n          << MatchTable::LineBreak;\n  }\n};\n\n/// Adds operands by calling a renderer function supplied by the ComplexPattern\n/// matcher function.\nclass RenderComplexPatternOperand : public OperandRenderer {\nprivate:\n  unsigned InsnID;\n  const Record &TheDef;\n  /// The name of the operand.\n  const StringRef SymbolicName;\n  /// The renderer number. This must be unique within a rule since it's used to\n  /// identify a temporary variable to hold the renderer function.\n  unsigned RendererID;\n  /// When provided, this is the suboperand of the ComplexPattern operand to\n  /// render. Otherwise all the suboperands will be rendered.\n  Optional<unsigned> SubOperand;\n\n  unsigned getNumOperands() const {\n    return TheDef.getValueAsDag(\"Operands\")->getNumArgs();\n  }\n\npublic:\n  RenderComplexPatternOperand(unsigned InsnID, const Record &TheDef,\n                              StringRef SymbolicName, unsigned RendererID,\n                              Optional<unsigned> SubOperand = None)\n      : OperandRenderer(OR_ComplexPattern), InsnID(InsnID), TheDef(TheDef),\n        SymbolicName(SymbolicName), RendererID(RendererID),\n        SubOperand(SubOperand) {}\n\n  static bool classof(const OperandRenderer *R) {\n    return R->getKind() == OR_ComplexPattern;\n  }\n\n  void emitRenderOpcodes(MatchTable &Table, RuleMatcher &Rule) const override {\n    Table << MatchTable::Opcode(SubOperand.hasValue() ? \"GIR_ComplexSubOperandRenderer\"\n                                                      : \"GIR_ComplexRenderer\")\n          << MatchTable::Comment(\"InsnID\") << MatchTable::IntValue(InsnID)\n          << MatchTable::Comment(\"RendererID\")\n          << MatchTable::IntValue(RendererID);\n    if (SubOperand.hasValue())\n      Table << MatchTable::Comment(\"SubOperand\")\n            << MatchTable::IntValue(SubOperand.getValue());\n    Table << MatchTable::Comment(SymbolicName) << MatchTable::LineBreak;\n  }\n};\n\nclass CustomRenderer : public OperandRenderer {\nprotected:\n  unsigned InsnID;\n  const Record &Renderer;\n  /// The name of the operand.\n  const std::string SymbolicName;\n\npublic:\n  CustomRenderer(unsigned InsnID, const Record &Renderer,\n                 StringRef SymbolicName)\n      : OperandRenderer(OR_Custom), InsnID(InsnID), Renderer(Renderer),\n        SymbolicName(SymbolicName) {}\n\n  static bool classof(const OperandRenderer *R) {\n    return R->getKind() == OR_Custom;\n  }\n\n  void emitRenderOpcodes(MatchTable &Table, RuleMatcher &Rule) const override {\n    InstructionMatcher &InsnMatcher = Rule.getInstructionMatcher(SymbolicName);\n    unsigned OldInsnVarID = Rule.getInsnVarID(InsnMatcher);\n    Table << MatchTable::Opcode(\"GIR_CustomRenderer\")\n          << MatchTable::Comment(\"InsnID\") << MatchTable::IntValue(InsnID)\n          << MatchTable::Comment(\"OldInsnID\")\n          << MatchTable::IntValue(OldInsnVarID)\n          << MatchTable::Comment(\"Renderer\")\n          << MatchTable::NamedValue(\n                 \"GICR_\" + Renderer.getValueAsString(\"RendererFn\").str())\n          << MatchTable::Comment(SymbolicName) << MatchTable::LineBreak;\n  }\n};\n\nclass CustomOperandRenderer : public OperandRenderer {\nprotected:\n  unsigned InsnID;\n  const Record &Renderer;\n  /// The name of the operand.\n  const std::string SymbolicName;\n\npublic:\n  CustomOperandRenderer(unsigned InsnID, const Record &Renderer,\n                        StringRef SymbolicName)\n      : OperandRenderer(OR_CustomOperand), InsnID(InsnID), Renderer(Renderer),\n        SymbolicName(SymbolicName) {}\n\n  static bool classof(const OperandRenderer *R) {\n    return R->getKind() == OR_CustomOperand;\n  }\n\n  void emitRenderOpcodes(MatchTable &Table, RuleMatcher &Rule) const override {\n    const OperandMatcher &OpdMatcher = Rule.getOperandMatcher(SymbolicName);\n    Table << MatchTable::Opcode(\"GIR_CustomOperandRenderer\")\n          << MatchTable::Comment(\"InsnID\") << MatchTable::IntValue(InsnID)\n          << MatchTable::Comment(\"OldInsnID\")\n          << MatchTable::IntValue(OpdMatcher.getInsnVarID())\n          << MatchTable::Comment(\"OpIdx\")\n          << MatchTable::IntValue(OpdMatcher.getOpIdx())\n          << MatchTable::Comment(\"OperandRenderer\")\n          << MatchTable::NamedValue(\n            \"GICR_\" + Renderer.getValueAsString(\"RendererFn\").str())\n          << MatchTable::Comment(SymbolicName) << MatchTable::LineBreak;\n  }\n};\n\n/// An action taken when all Matcher predicates succeeded for a parent rule.\n///\n/// Typical actions include:\n/// * Changing the opcode of an instruction.\n/// * Adding an operand to an instruction.\nclass MatchAction {\npublic:\n  virtual ~MatchAction() {}\n\n  /// Emit the MatchTable opcodes to implement the action.\n  virtual void emitActionOpcodes(MatchTable &Table,\n                                 RuleMatcher &Rule) const = 0;\n};\n\n/// Generates a comment describing the matched rule being acted upon.\nclass DebugCommentAction : public MatchAction {\nprivate:\n  std::string S;\n\npublic:\n  DebugCommentAction(StringRef S) : S(std::string(S)) {}\n\n  void emitActionOpcodes(MatchTable &Table, RuleMatcher &Rule) const override {\n    Table << MatchTable::Comment(S) << MatchTable::LineBreak;\n  }\n};\n\n/// Generates code to build an instruction or mutate an existing instruction\n/// into the desired instruction when this is possible.\nclass BuildMIAction : public MatchAction {\nprivate:\n  unsigned InsnID;\n  const CodeGenInstruction *I;\n  InstructionMatcher *Matched;\n  std::vector<std::unique_ptr<OperandRenderer>> OperandRenderers;\n\n  /// True if the instruction can be built solely by mutating the opcode.\n  bool canMutate(RuleMatcher &Rule, const InstructionMatcher *Insn) const {\n    if (!Insn)\n      return false;\n\n    if (OperandRenderers.size() != Insn->getNumOperands())\n      return false;\n\n    for (const auto &Renderer : enumerate(OperandRenderers)) {\n      if (const auto *Copy = dyn_cast<CopyRenderer>(&*Renderer.value())) {\n        const OperandMatcher &OM = Rule.getOperandMatcher(Copy->getSymbolicName());\n        if (Insn != &OM.getInstructionMatcher() ||\n            OM.getOpIdx() != Renderer.index())\n          return false;\n      } else\n        return false;\n    }\n\n    return true;\n  }\n\npublic:\n  BuildMIAction(unsigned InsnID, const CodeGenInstruction *I)\n      : InsnID(InsnID), I(I), Matched(nullptr) {}\n\n  unsigned getInsnID() const { return InsnID; }\n  const CodeGenInstruction *getCGI() const { return I; }\n\n  void chooseInsnToMutate(RuleMatcher &Rule) {\n    for (auto *MutateCandidate : Rule.mutatable_insns()) {\n      if (canMutate(Rule, MutateCandidate)) {\n        // Take the first one we're offered that we're able to mutate.\n        Rule.reserveInsnMatcherForMutation(MutateCandidate);\n        Matched = MutateCandidate;\n        return;\n      }\n    }\n  }\n\n  template <class Kind, class... Args>\n  Kind &addRenderer(Args&&... args) {\n    OperandRenderers.emplace_back(\n        std::make_unique<Kind>(InsnID, std::forward<Args>(args)...));\n    return *static_cast<Kind *>(OperandRenderers.back().get());\n  }\n\n  void emitActionOpcodes(MatchTable &Table, RuleMatcher &Rule) const override {\n    if (Matched) {\n      assert(canMutate(Rule, Matched) &&\n             \"Arranged to mutate an insn that isn't mutatable\");\n\n      unsigned RecycleInsnID = Rule.getInsnVarID(*Matched);\n      Table << MatchTable::Opcode(\"GIR_MutateOpcode\")\n            << MatchTable::Comment(\"InsnID\") << MatchTable::IntValue(InsnID)\n            << MatchTable::Comment(\"RecycleInsnID\")\n            << MatchTable::IntValue(RecycleInsnID)\n            << MatchTable::Comment(\"Opcode\")\n            << MatchTable::NamedValue(I->Namespace, I->TheDef->getName())\n            << MatchTable::LineBreak;\n\n      if (!I->ImplicitDefs.empty() || !I->ImplicitUses.empty()) {\n        for (auto Def : I->ImplicitDefs) {\n          auto Namespace = Def->getValue(\"Namespace\")\n                               ? Def->getValueAsString(\"Namespace\")\n                               : \"\";\n          Table << MatchTable::Opcode(\"GIR_AddImplicitDef\")\n                << MatchTable::Comment(\"InsnID\") << MatchTable::IntValue(InsnID)\n                << MatchTable::NamedValue(Namespace, Def->getName())\n                << MatchTable::LineBreak;\n        }\n        for (auto Use : I->ImplicitUses) {\n          auto Namespace = Use->getValue(\"Namespace\")\n                               ? Use->getValueAsString(\"Namespace\")\n                               : \"\";\n          Table << MatchTable::Opcode(\"GIR_AddImplicitUse\")\n                << MatchTable::Comment(\"InsnID\") << MatchTable::IntValue(InsnID)\n                << MatchTable::NamedValue(Namespace, Use->getName())\n                << MatchTable::LineBreak;\n        }\n      }\n      return;\n    }\n\n    // TODO: Simple permutation looks like it could be almost as common as\n    //       mutation due to commutative operations.\n\n    Table << MatchTable::Opcode(\"GIR_BuildMI\") << MatchTable::Comment(\"InsnID\")\n          << MatchTable::IntValue(InsnID) << MatchTable::Comment(\"Opcode\")\n          << MatchTable::NamedValue(I->Namespace, I->TheDef->getName())\n          << MatchTable::LineBreak;\n    for (const auto &Renderer : OperandRenderers)\n      Renderer->emitRenderOpcodes(Table, Rule);\n\n    if (I->mayLoad || I->mayStore) {\n      Table << MatchTable::Opcode(\"GIR_MergeMemOperands\")\n            << MatchTable::Comment(\"InsnID\") << MatchTable::IntValue(InsnID)\n            << MatchTable::Comment(\"MergeInsnID's\");\n      // Emit the ID's for all the instructions that are matched by this rule.\n      // TODO: Limit this to matched instructions that mayLoad/mayStore or have\n      //       some other means of having a memoperand. Also limit this to\n      //       emitted instructions that expect to have a memoperand too. For\n      //       example, (G_SEXT (G_LOAD x)) that results in separate load and\n      //       sign-extend instructions shouldn't put the memoperand on the\n      //       sign-extend since it has no effect there.\n      std::vector<unsigned> MergeInsnIDs;\n      for (const auto &IDMatcherPair : Rule.defined_insn_vars())\n        MergeInsnIDs.push_back(IDMatcherPair.second);\n      llvm::sort(MergeInsnIDs);\n      for (const auto &MergeInsnID : MergeInsnIDs)\n        Table << MatchTable::IntValue(MergeInsnID);\n      Table << MatchTable::NamedValue(\"GIU_MergeMemOperands_EndOfList\")\n            << MatchTable::LineBreak;\n    }\n\n    // FIXME: This is a hack but it's sufficient for ISel. We'll need to do\n    //        better for combines. Particularly when there are multiple match\n    //        roots.\n    if (InsnID == 0)\n      Table << MatchTable::Opcode(\"GIR_EraseFromParent\")\n            << MatchTable::Comment(\"InsnID\") << MatchTable::IntValue(InsnID)\n            << MatchTable::LineBreak;\n  }\n};\n\n/// Generates code to constrain the operands of an output instruction to the\n/// register classes specified by the definition of that instruction.\nclass ConstrainOperandsToDefinitionAction : public MatchAction {\n  unsigned InsnID;\n\npublic:\n  ConstrainOperandsToDefinitionAction(unsigned InsnID) : InsnID(InsnID) {}\n\n  void emitActionOpcodes(MatchTable &Table, RuleMatcher &Rule) const override {\n    Table << MatchTable::Opcode(\"GIR_ConstrainSelectedInstOperands\")\n          << MatchTable::Comment(\"InsnID\") << MatchTable::IntValue(InsnID)\n          << MatchTable::LineBreak;\n  }\n};\n\n/// Generates code to constrain the specified operand of an output instruction\n/// to the specified register class.\nclass ConstrainOperandToRegClassAction : public MatchAction {\n  unsigned InsnID;\n  unsigned OpIdx;\n  const CodeGenRegisterClass &RC;\n\npublic:\n  ConstrainOperandToRegClassAction(unsigned InsnID, unsigned OpIdx,\n                                   const CodeGenRegisterClass &RC)\n      : InsnID(InsnID), OpIdx(OpIdx), RC(RC) {}\n\n  void emitActionOpcodes(MatchTable &Table, RuleMatcher &Rule) const override {\n    Table << MatchTable::Opcode(\"GIR_ConstrainOperandRC\")\n          << MatchTable::Comment(\"InsnID\") << MatchTable::IntValue(InsnID)\n          << MatchTable::Comment(\"Op\") << MatchTable::IntValue(OpIdx)\n          << MatchTable::NamedValue(RC.getQualifiedName() + \"RegClassID\")\n          << MatchTable::LineBreak;\n  }\n};\n\n/// Generates code to create a temporary register which can be used to chain\n/// instructions together.\nclass MakeTempRegisterAction : public MatchAction {\nprivate:\n  LLTCodeGen Ty;\n  unsigned TempRegID;\n\npublic:\n  MakeTempRegisterAction(const LLTCodeGen &Ty, unsigned TempRegID)\n      : Ty(Ty), TempRegID(TempRegID) {\n    KnownTypes.insert(Ty);\n  }\n\n  void emitActionOpcodes(MatchTable &Table, RuleMatcher &Rule) const override {\n    Table << MatchTable::Opcode(\"GIR_MakeTempReg\")\n          << MatchTable::Comment(\"TempRegID\") << MatchTable::IntValue(TempRegID)\n          << MatchTable::Comment(\"TypeID\")\n          << MatchTable::NamedValue(Ty.getCxxEnumValue())\n          << MatchTable::LineBreak;\n  }\n};\n\nInstructionMatcher &RuleMatcher::addInstructionMatcher(StringRef SymbolicName) {\n  Matchers.emplace_back(new InstructionMatcher(*this, SymbolicName));\n  MutatableInsns.insert(Matchers.back().get());\n  return *Matchers.back();\n}\n\nvoid RuleMatcher::addRequiredFeature(Record *Feature) {\n  RequiredFeatures.push_back(Feature);\n}\n\nconst std::vector<Record *> &RuleMatcher::getRequiredFeatures() const {\n  return RequiredFeatures;\n}\n\n// Emplaces an action of the specified Kind at the end of the action list.\n//\n// Returns a reference to the newly created action.\n//\n// Like std::vector::emplace_back(), may invalidate all iterators if the new\n// size exceeds the capacity. Otherwise, only invalidates the past-the-end\n// iterator.\ntemplate <class Kind, class... Args>\nKind &RuleMatcher::addAction(Args &&... args) {\n  Actions.emplace_back(std::make_unique<Kind>(std::forward<Args>(args)...));\n  return *static_cast<Kind *>(Actions.back().get());\n}\n\n// Emplaces an action of the specified Kind before the given insertion point.\n//\n// Returns an iterator pointing at the newly created instruction.\n//\n// Like std::vector::insert(), may invalidate all iterators if the new size\n// exceeds the capacity. Otherwise, only invalidates the iterators from the\n// insertion point onwards.\ntemplate <class Kind, class... Args>\naction_iterator RuleMatcher::insertAction(action_iterator InsertPt,\n                                          Args &&... args) {\n  return Actions.emplace(InsertPt,\n                         std::make_unique<Kind>(std::forward<Args>(args)...));\n}\n\nunsigned RuleMatcher::implicitlyDefineInsnVar(InstructionMatcher &Matcher) {\n  unsigned NewInsnVarID = NextInsnVarID++;\n  InsnVariableIDs[&Matcher] = NewInsnVarID;\n  return NewInsnVarID;\n}\n\nunsigned RuleMatcher::getInsnVarID(InstructionMatcher &InsnMatcher) const {\n  const auto &I = InsnVariableIDs.find(&InsnMatcher);\n  if (I != InsnVariableIDs.end())\n    return I->second;\n  llvm_unreachable(\"Matched Insn was not captured in a local variable\");\n}\n\nvoid RuleMatcher::defineOperand(StringRef SymbolicName, OperandMatcher &OM) {\n  if (DefinedOperands.find(SymbolicName) == DefinedOperands.end()) {\n    DefinedOperands[SymbolicName] = &OM;\n    return;\n  }\n\n  // If the operand is already defined, then we must ensure both references in\n  // the matcher have the exact same node.\n  OM.addPredicate<SameOperandMatcher>(OM.getSymbolicName());\n}\n\nvoid RuleMatcher::definePhysRegOperand(Record *Reg, OperandMatcher &OM) {\n  if (PhysRegOperands.find(Reg) == PhysRegOperands.end()) {\n    PhysRegOperands[Reg] = &OM;\n    return;\n  }\n}\n\nInstructionMatcher &\nRuleMatcher::getInstructionMatcher(StringRef SymbolicName) const {\n  for (const auto &I : InsnVariableIDs)\n    if (I.first->getSymbolicName() == SymbolicName)\n      return *I.first;\n  llvm_unreachable(\n      (\"Failed to lookup instruction \" + SymbolicName).str().c_str());\n}\n\nconst OperandMatcher &\nRuleMatcher::getPhysRegOperandMatcher(Record *Reg) const {\n  const auto &I = PhysRegOperands.find(Reg);\n\n  if (I == PhysRegOperands.end()) {\n    PrintFatalError(SrcLoc, \"Register \" + Reg->getName() +\n                    \" was not declared in matcher\");\n  }\n\n  return *I->second;\n}\n\nconst OperandMatcher &\nRuleMatcher::getOperandMatcher(StringRef Name) const {\n  const auto &I = DefinedOperands.find(Name);\n\n  if (I == DefinedOperands.end())\n    PrintFatalError(SrcLoc, \"Operand \" + Name + \" was not declared in matcher\");\n\n  return *I->second;\n}\n\nvoid RuleMatcher::emit(MatchTable &Table) {\n  if (Matchers.empty())\n    llvm_unreachable(\"Unexpected empty matcher!\");\n\n  // The representation supports rules that require multiple roots such as:\n  //    %ptr(p0) = ...\n  //    %elt0(s32) = G_LOAD %ptr\n  //    %1(p0) = G_ADD %ptr, 4\n  //    %elt1(s32) = G_LOAD p0 %1\n  // which could be usefully folded into:\n  //    %ptr(p0) = ...\n  //    %elt0(s32), %elt1(s32) = TGT_LOAD_PAIR %ptr\n  // on some targets but we don't need to make use of that yet.\n  assert(Matchers.size() == 1 && \"Cannot handle multi-root matchers yet\");\n\n  unsigned LabelID = Table.allocateLabelID();\n  Table << MatchTable::Opcode(\"GIM_Try\", +1)\n        << MatchTable::Comment(\"On fail goto\")\n        << MatchTable::JumpTarget(LabelID)\n        << MatchTable::Comment((\"Rule ID \" + Twine(RuleID) + \" //\").str())\n        << MatchTable::LineBreak;\n\n  if (!RequiredFeatures.empty()) {\n    Table << MatchTable::Opcode(\"GIM_CheckFeatures\")\n          << MatchTable::NamedValue(getNameForFeatureBitset(RequiredFeatures))\n          << MatchTable::LineBreak;\n  }\n\n  Matchers.front()->emitPredicateOpcodes(Table, *this);\n\n  // We must also check if it's safe to fold the matched instructions.\n  if (InsnVariableIDs.size() >= 2) {\n    // Invert the map to create stable ordering (by var names)\n    SmallVector<unsigned, 2> InsnIDs;\n    for (const auto &Pair : InsnVariableIDs) {\n      // Skip the root node since it isn't moving anywhere. Everything else is\n      // sinking to meet it.\n      if (Pair.first == Matchers.front().get())\n        continue;\n\n      InsnIDs.push_back(Pair.second);\n    }\n    llvm::sort(InsnIDs);\n\n    for (const auto &InsnID : InsnIDs) {\n      // Reject the difficult cases until we have a more accurate check.\n      Table << MatchTable::Opcode(\"GIM_CheckIsSafeToFold\")\n            << MatchTable::Comment(\"InsnID\") << MatchTable::IntValue(InsnID)\n            << MatchTable::LineBreak;\n\n      // FIXME: Emit checks to determine it's _actually_ safe to fold and/or\n      //        account for unsafe cases.\n      //\n      //        Example:\n      //          MI1--> %0 = ...\n      //                 %1 = ... %0\n      //          MI0--> %2 = ... %0\n      //          It's not safe to erase MI1. We currently handle this by not\n      //          erasing %0 (even when it's dead).\n      //\n      //        Example:\n      //          MI1--> %0 = load volatile @a\n      //                 %1 = load volatile @a\n      //          MI0--> %2 = ... %0\n      //          It's not safe to sink %0's def past %1. We currently handle\n      //          this by rejecting all loads.\n      //\n      //        Example:\n      //          MI1--> %0 = load @a\n      //                 %1 = store @a\n      //          MI0--> %2 = ... %0\n      //          It's not safe to sink %0's def past %1. We currently handle\n      //          this by rejecting all loads.\n      //\n      //        Example:\n      //                   G_CONDBR %cond, @BB1\n      //                 BB0:\n      //          MI1-->   %0 = load @a\n      //                   G_BR @BB1\n      //                 BB1:\n      //          MI0-->   %2 = ... %0\n      //          It's not always safe to sink %0 across control flow. In this\n      //          case it may introduce a memory fault. We currentl handle this\n      //          by rejecting all loads.\n    }\n  }\n\n  for (const auto &PM : EpilogueMatchers)\n    PM->emitPredicateOpcodes(Table, *this);\n\n  for (const auto &MA : Actions)\n    MA->emitActionOpcodes(Table, *this);\n\n  if (Table.isWithCoverage())\n    Table << MatchTable::Opcode(\"GIR_Coverage\") << MatchTable::IntValue(RuleID)\n          << MatchTable::LineBreak;\n  else\n    Table << MatchTable::Comment((\"GIR_Coverage, \" + Twine(RuleID) + \",\").str())\n          << MatchTable::LineBreak;\n\n  Table << MatchTable::Opcode(\"GIR_Done\", -1) << MatchTable::LineBreak\n        << MatchTable::Label(LabelID);\n  ++NumPatternEmitted;\n}\n\nbool RuleMatcher::isHigherPriorityThan(const RuleMatcher &B) const {\n  // Rules involving more match roots have higher priority.\n  if (Matchers.size() > B.Matchers.size())\n    return true;\n  if (Matchers.size() < B.Matchers.size())\n    return false;\n\n  for (auto Matcher : zip(Matchers, B.Matchers)) {\n    if (std::get<0>(Matcher)->isHigherPriorityThan(*std::get<1>(Matcher)))\n      return true;\n    if (std::get<1>(Matcher)->isHigherPriorityThan(*std::get<0>(Matcher)))\n      return false;\n  }\n\n  return false;\n}\n\nunsigned RuleMatcher::countRendererFns() const {\n  return std::accumulate(\n      Matchers.begin(), Matchers.end(), 0,\n      [](unsigned A, const std::unique_ptr<InstructionMatcher> &Matcher) {\n        return A + Matcher->countRendererFns();\n      });\n}\n\nbool OperandPredicateMatcher::isHigherPriorityThan(\n    const OperandPredicateMatcher &B) const {\n  // Generally speaking, an instruction is more important than an Int or a\n  // LiteralInt because it can cover more nodes but theres an exception to\n  // this. G_CONSTANT's are less important than either of those two because they\n  // are more permissive.\n\n  const InstructionOperandMatcher *AOM =\n      dyn_cast<InstructionOperandMatcher>(this);\n  const InstructionOperandMatcher *BOM =\n      dyn_cast<InstructionOperandMatcher>(&B);\n  bool AIsConstantInsn = AOM && AOM->getInsnMatcher().isConstantInstruction();\n  bool BIsConstantInsn = BOM && BOM->getInsnMatcher().isConstantInstruction();\n\n  if (AOM && BOM) {\n    // The relative priorities between a G_CONSTANT and any other instruction\n    // don't actually matter but this code is needed to ensure a strict weak\n    // ordering. This is particularly important on Windows where the rules will\n    // be incorrectly sorted without it.\n    if (AIsConstantInsn != BIsConstantInsn)\n      return AIsConstantInsn < BIsConstantInsn;\n    return false;\n  }\n\n  if (AOM && AIsConstantInsn && (B.Kind == OPM_Int || B.Kind == OPM_LiteralInt))\n    return false;\n  if (BOM && BIsConstantInsn && (Kind == OPM_Int || Kind == OPM_LiteralInt))\n    return true;\n\n  return Kind < B.Kind;\n}\n\nvoid SameOperandMatcher::emitPredicateOpcodes(MatchTable &Table,\n                                              RuleMatcher &Rule) const {\n  const OperandMatcher &OtherOM = Rule.getOperandMatcher(MatchingName);\n  unsigned OtherInsnVarID = Rule.getInsnVarID(OtherOM.getInstructionMatcher());\n  assert(OtherInsnVarID == OtherOM.getInstructionMatcher().getInsnVarID());\n\n  Table << MatchTable::Opcode(\"GIM_CheckIsSameOperand\")\n        << MatchTable::Comment(\"MI\") << MatchTable::IntValue(InsnVarID)\n        << MatchTable::Comment(\"OpIdx\") << MatchTable::IntValue(OpIdx)\n        << MatchTable::Comment(\"OtherMI\")\n        << MatchTable::IntValue(OtherInsnVarID)\n        << MatchTable::Comment(\"OtherOpIdx\")\n        << MatchTable::IntValue(OtherOM.getOpIdx())\n        << MatchTable::LineBreak;\n}\n\n//===- GlobalISelEmitter class --------------------------------------------===//\n\nstatic Expected<LLTCodeGen> getInstResultType(const TreePatternNode *Dst) {\n  ArrayRef<TypeSetByHwMode> ChildTypes = Dst->getExtTypes();\n  if (ChildTypes.size() != 1)\n    return failedImport(\"Dst pattern child has multiple results\");\n\n  Optional<LLTCodeGen> MaybeOpTy;\n  if (ChildTypes.front().isMachineValueType()) {\n    MaybeOpTy =\n      MVTToLLT(ChildTypes.front().getMachineValueType().SimpleTy);\n  }\n\n  if (!MaybeOpTy)\n    return failedImport(\"Dst operand has an unsupported type\");\n  return *MaybeOpTy;\n}\n\nclass GlobalISelEmitter {\npublic:\n  explicit GlobalISelEmitter(RecordKeeper &RK);\n  void run(raw_ostream &OS);\n\nprivate:\n  const RecordKeeper &RK;\n  const CodeGenDAGPatterns CGP;\n  const CodeGenTarget &Target;\n  CodeGenRegBank &CGRegs;\n\n  /// Keep track of the equivalence between SDNodes and Instruction by mapping\n  /// SDNodes to the GINodeEquiv mapping. We need to map to the GINodeEquiv to\n  /// check for attributes on the relation such as CheckMMOIsNonAtomic.\n  /// This is defined using 'GINodeEquiv' in the target description.\n  DenseMap<Record *, Record *> NodeEquivs;\n\n  /// Keep track of the equivalence between ComplexPattern's and\n  /// GIComplexOperandMatcher. Map entries are specified by subclassing\n  /// GIComplexPatternEquiv.\n  DenseMap<const Record *, const Record *> ComplexPatternEquivs;\n\n  /// Keep track of the equivalence between SDNodeXForm's and\n  /// GICustomOperandRenderer. Map entries are specified by subclassing\n  /// GISDNodeXFormEquiv.\n  DenseMap<const Record *, const Record *> SDNodeXFormEquivs;\n\n  /// Keep track of Scores of PatternsToMatch similar to how the DAG does.\n  /// This adds compatibility for RuleMatchers to use this for ordering rules.\n  DenseMap<uint64_t, int> RuleMatcherScores;\n\n  // Map of predicates to their subtarget features.\n  SubtargetFeatureInfoMap SubtargetFeatures;\n\n  // Rule coverage information.\n  Optional<CodeGenCoverage> RuleCoverage;\n\n  /// Variables used to help with collecting of named operands for predicates\n  /// with 'let PredicateCodeUsesOperands = 1'. WaitingForNamedOperands is set\n  /// to the number of named operands that predicate expects. Store locations in\n  /// StoreIdxForName correspond to the order in which operand names appear in\n  /// predicate's argument list.\n  /// When we visit named leaf operand and WaitingForNamedOperands is not zero,\n  /// add matcher that will record operand and decrease counter.\n  unsigned WaitingForNamedOperands = 0;\n  StringMap<unsigned> StoreIdxForName;\n\n  void gatherOpcodeValues();\n  void gatherTypeIDValues();\n  void gatherNodeEquivs();\n\n  Record *findNodeEquiv(Record *N) const;\n  const CodeGenInstruction *getEquivNode(Record &Equiv,\n                                         const TreePatternNode *N) const;\n\n  Error importRulePredicates(RuleMatcher &M, ArrayRef<Predicate> Predicates);\n  Expected<InstructionMatcher &>\n  createAndImportSelDAGMatcher(RuleMatcher &Rule,\n                               InstructionMatcher &InsnMatcher,\n                               const TreePatternNode *Src, unsigned &TempOpIdx);\n  Error importComplexPatternOperandMatcher(OperandMatcher &OM, Record *R,\n                                           unsigned &TempOpIdx) const;\n  Error importChildMatcher(RuleMatcher &Rule, InstructionMatcher &InsnMatcher,\n                           const TreePatternNode *SrcChild,\n                           bool OperandIsAPointer, bool OperandIsImmArg,\n                           unsigned OpIdx, unsigned &TempOpIdx);\n\n  Expected<BuildMIAction &> createAndImportInstructionRenderer(\n      RuleMatcher &M, InstructionMatcher &InsnMatcher,\n      const TreePatternNode *Src, const TreePatternNode *Dst);\n  Expected<action_iterator> createAndImportSubInstructionRenderer(\n      action_iterator InsertPt, RuleMatcher &M, const TreePatternNode *Dst,\n      unsigned TempReg);\n  Expected<action_iterator>\n  createInstructionRenderer(action_iterator InsertPt, RuleMatcher &M,\n                            const TreePatternNode *Dst);\n\n  Expected<action_iterator>\n  importExplicitDefRenderers(action_iterator InsertPt, RuleMatcher &M,\n                             BuildMIAction &DstMIBuilder,\n                             const TreePatternNode *Dst);\n\n  Expected<action_iterator>\n  importExplicitUseRenderers(action_iterator InsertPt, RuleMatcher &M,\n                             BuildMIAction &DstMIBuilder,\n                             const llvm::TreePatternNode *Dst);\n  Expected<action_iterator>\n  importExplicitUseRenderer(action_iterator InsertPt, RuleMatcher &Rule,\n                            BuildMIAction &DstMIBuilder,\n                            TreePatternNode *DstChild);\n  Error importDefaultOperandRenderers(action_iterator InsertPt, RuleMatcher &M,\n                                      BuildMIAction &DstMIBuilder,\n                                      DagInit *DefaultOps) const;\n  Error\n  importImplicitDefRenderers(BuildMIAction &DstMIBuilder,\n                             const std::vector<Record *> &ImplicitDefs) const;\n\n  void emitCxxPredicateFns(raw_ostream &OS, StringRef CodeFieldName,\n                           StringRef TypeIdentifier, StringRef ArgType,\n                           StringRef ArgName, StringRef AdditionalArgs,\n                           StringRef AdditionalDeclarations,\n                           std::function<bool(const Record *R)> Filter);\n  void emitImmPredicateFns(raw_ostream &OS, StringRef TypeIdentifier,\n                           StringRef ArgType,\n                           std::function<bool(const Record *R)> Filter);\n  void emitMIPredicateFns(raw_ostream &OS);\n\n  /// Analyze pattern \\p P, returning a matcher for it if possible.\n  /// Otherwise, return an Error explaining why we don't support it.\n  Expected<RuleMatcher> runOnPattern(const PatternToMatch &P);\n\n  void declareSubtargetFeature(Record *Predicate);\n\n  MatchTable buildMatchTable(MutableArrayRef<RuleMatcher> Rules, bool Optimize,\n                             bool WithCoverage);\n\n  /// Infer a CodeGenRegisterClass for the type of \\p SuperRegNode. The returned\n  /// CodeGenRegisterClass will support the CodeGenRegisterClass of\n  /// \\p SubRegNode, and the subregister index defined by \\p SubRegIdxNode.\n  /// If no register class is found, return None.\n  Optional<const CodeGenRegisterClass *>\n  inferSuperRegisterClassForNode(const TypeSetByHwMode &Ty,\n                                 TreePatternNode *SuperRegNode,\n                                 TreePatternNode *SubRegIdxNode);\n  Optional<CodeGenSubRegIndex *>\n  inferSubRegIndexForNode(TreePatternNode *SubRegIdxNode);\n\n  /// Infer a CodeGenRegisterClass which suppoorts \\p Ty and \\p SubRegIdxNode.\n  /// Return None if no such class exists.\n  Optional<const CodeGenRegisterClass *>\n  inferSuperRegisterClass(const TypeSetByHwMode &Ty,\n                          TreePatternNode *SubRegIdxNode);\n\n  /// Return the CodeGenRegisterClass associated with \\p Leaf if it has one.\n  Optional<const CodeGenRegisterClass *>\n  getRegClassFromLeaf(TreePatternNode *Leaf);\n\n  /// Return a CodeGenRegisterClass for \\p N if one can be found. Return None\n  /// otherwise.\n  Optional<const CodeGenRegisterClass *>\n  inferRegClassFromPattern(TreePatternNode *N);\n\n  // Add builtin predicates.\n  Expected<InstructionMatcher &>\n  addBuiltinPredicates(const Record *SrcGIEquivOrNull,\n                       const TreePredicateFn &Predicate,\n                       InstructionMatcher &InsnMatcher, bool &HasAddedMatcher);\n\npublic:\n  /// Takes a sequence of \\p Rules and group them based on the predicates\n  /// they share. \\p MatcherStorage is used as a memory container\n  /// for the group that are created as part of this process.\n  ///\n  /// What this optimization does looks like if GroupT = GroupMatcher:\n  /// Output without optimization:\n  /// \\verbatim\n  /// # R1\n  ///  # predicate A\n  ///  # predicate B\n  ///  ...\n  /// # R2\n  ///  # predicate A // <-- effectively this is going to be checked twice.\n  ///                //     Once in R1 and once in R2.\n  ///  # predicate C\n  /// \\endverbatim\n  /// Output with optimization:\n  /// \\verbatim\n  /// # Group1_2\n  ///  # predicate A // <-- Check is now shared.\n  ///  # R1\n  ///   # predicate B\n  ///  # R2\n  ///   # predicate C\n  /// \\endverbatim\n  template <class GroupT>\n  static std::vector<Matcher *> optimizeRules(\n      ArrayRef<Matcher *> Rules,\n      std::vector<std::unique_ptr<Matcher>> &MatcherStorage);\n};\n\nvoid GlobalISelEmitter::gatherOpcodeValues() {\n  InstructionOpcodeMatcher::initOpcodeValuesMap(Target);\n}\n\nvoid GlobalISelEmitter::gatherTypeIDValues() {\n  LLTOperandMatcher::initTypeIDValuesMap();\n}\n\nvoid GlobalISelEmitter::gatherNodeEquivs() {\n  assert(NodeEquivs.empty());\n  for (Record *Equiv : RK.getAllDerivedDefinitions(\"GINodeEquiv\"))\n    NodeEquivs[Equiv->getValueAsDef(\"Node\")] = Equiv;\n\n  assert(ComplexPatternEquivs.empty());\n  for (Record *Equiv : RK.getAllDerivedDefinitions(\"GIComplexPatternEquiv\")) {\n    Record *SelDAGEquiv = Equiv->getValueAsDef(\"SelDAGEquivalent\");\n    if (!SelDAGEquiv)\n      continue;\n    ComplexPatternEquivs[SelDAGEquiv] = Equiv;\n }\n\n assert(SDNodeXFormEquivs.empty());\n for (Record *Equiv : RK.getAllDerivedDefinitions(\"GISDNodeXFormEquiv\")) {\n   Record *SelDAGEquiv = Equiv->getValueAsDef(\"SelDAGEquivalent\");\n   if (!SelDAGEquiv)\n     continue;\n   SDNodeXFormEquivs[SelDAGEquiv] = Equiv;\n }\n}\n\nRecord *GlobalISelEmitter::findNodeEquiv(Record *N) const {\n  return NodeEquivs.lookup(N);\n}\n\nconst CodeGenInstruction *\nGlobalISelEmitter::getEquivNode(Record &Equiv, const TreePatternNode *N) const {\n  if (N->getNumChildren() >= 1) {\n    // setcc operation maps to two different G_* instructions based on the type.\n    if (!Equiv.isValueUnset(\"IfFloatingPoint\") &&\n        MVT(N->getChild(0)->getSimpleType(0)).isFloatingPoint())\n      return &Target.getInstruction(Equiv.getValueAsDef(\"IfFloatingPoint\"));\n  }\n\n  for (const TreePredicateCall &Call : N->getPredicateCalls()) {\n    const TreePredicateFn &Predicate = Call.Fn;\n    if (!Equiv.isValueUnset(\"IfSignExtend\") && Predicate.isLoad() &&\n        Predicate.isSignExtLoad())\n      return &Target.getInstruction(Equiv.getValueAsDef(\"IfSignExtend\"));\n    if (!Equiv.isValueUnset(\"IfZeroExtend\") && Predicate.isLoad() &&\n        Predicate.isZeroExtLoad())\n      return &Target.getInstruction(Equiv.getValueAsDef(\"IfZeroExtend\"));\n  }\n\n  return &Target.getInstruction(Equiv.getValueAsDef(\"I\"));\n}\n\nGlobalISelEmitter::GlobalISelEmitter(RecordKeeper &RK)\n    : RK(RK), CGP(RK), Target(CGP.getTargetInfo()),\n      CGRegs(Target.getRegBank()) {}\n\n//===- Emitter ------------------------------------------------------------===//\n\nError\nGlobalISelEmitter::importRulePredicates(RuleMatcher &M,\n                                        ArrayRef<Predicate> Predicates) {\n  for (const Predicate &P : Predicates) {\n    if (!P.Def || P.getCondString().empty())\n      continue;\n    declareSubtargetFeature(P.Def);\n    M.addRequiredFeature(P.Def);\n  }\n\n  return Error::success();\n}\n\nExpected<InstructionMatcher &> GlobalISelEmitter::addBuiltinPredicates(\n    const Record *SrcGIEquivOrNull, const TreePredicateFn &Predicate,\n    InstructionMatcher &InsnMatcher, bool &HasAddedMatcher) {\n  if (Predicate.isLoad() || Predicate.isStore() || Predicate.isAtomic()) {\n    if (const ListInit *AddrSpaces = Predicate.getAddressSpaces()) {\n      SmallVector<unsigned, 4> ParsedAddrSpaces;\n\n      for (Init *Val : AddrSpaces->getValues()) {\n        IntInit *IntVal = dyn_cast<IntInit>(Val);\n        if (!IntVal)\n          return failedImport(\"Address space is not an integer\");\n        ParsedAddrSpaces.push_back(IntVal->getValue());\n      }\n\n      if (!ParsedAddrSpaces.empty()) {\n        InsnMatcher.addPredicate<MemoryAddressSpacePredicateMatcher>(\n            0, ParsedAddrSpaces);\n      }\n    }\n\n    int64_t MinAlign = Predicate.getMinAlignment();\n    if (MinAlign > 0)\n      InsnMatcher.addPredicate<MemoryAlignmentPredicateMatcher>(0, MinAlign);\n  }\n\n  // G_LOAD is used for both non-extending and any-extending loads.\n  if (Predicate.isLoad() && Predicate.isNonExtLoad()) {\n    InsnMatcher.addPredicate<MemoryVsLLTSizePredicateMatcher>(\n        0, MemoryVsLLTSizePredicateMatcher::EqualTo, 0);\n    return InsnMatcher;\n  }\n  if (Predicate.isLoad() && Predicate.isAnyExtLoad()) {\n    InsnMatcher.addPredicate<MemoryVsLLTSizePredicateMatcher>(\n        0, MemoryVsLLTSizePredicateMatcher::LessThan, 0);\n    return InsnMatcher;\n  }\n\n  if (Predicate.isStore()) {\n    if (Predicate.isTruncStore()) {\n      // FIXME: If MemoryVT is set, we end up with 2 checks for the MMO size.\n      InsnMatcher.addPredicate<MemoryVsLLTSizePredicateMatcher>(\n          0, MemoryVsLLTSizePredicateMatcher::LessThan, 0);\n      return InsnMatcher;\n    }\n    if (Predicate.isNonTruncStore()) {\n      // We need to check the sizes match here otherwise we could incorrectly\n      // match truncating stores with non-truncating ones.\n      InsnMatcher.addPredicate<MemoryVsLLTSizePredicateMatcher>(\n          0, MemoryVsLLTSizePredicateMatcher::EqualTo, 0);\n    }\n  }\n\n  // No check required. We already did it by swapping the opcode.\n  if (!SrcGIEquivOrNull->isValueUnset(\"IfSignExtend\") &&\n      Predicate.isSignExtLoad())\n    return InsnMatcher;\n\n  // No check required. We already did it by swapping the opcode.\n  if (!SrcGIEquivOrNull->isValueUnset(\"IfZeroExtend\") &&\n      Predicate.isZeroExtLoad())\n    return InsnMatcher;\n\n  // No check required. G_STORE by itself is a non-extending store.\n  if (Predicate.isNonTruncStore())\n    return InsnMatcher;\n\n  if (Predicate.isLoad() || Predicate.isStore() || Predicate.isAtomic()) {\n    if (Predicate.getMemoryVT() != nullptr) {\n      Optional<LLTCodeGen> MemTyOrNone =\n          MVTToLLT(getValueType(Predicate.getMemoryVT()));\n\n      if (!MemTyOrNone)\n        return failedImport(\"MemVT could not be converted to LLT\");\n\n      // MMO's work in bytes so we must take care of unusual types like i1\n      // don't round down.\n      unsigned MemSizeInBits =\n          llvm::alignTo(MemTyOrNone->get().getSizeInBits(), 8);\n\n      InsnMatcher.addPredicate<MemorySizePredicateMatcher>(0,\n                                                           MemSizeInBits / 8);\n      return InsnMatcher;\n    }\n  }\n\n  if (Predicate.isLoad() || Predicate.isStore()) {\n    // No check required. A G_LOAD/G_STORE is an unindexed load.\n    if (Predicate.isUnindexed())\n      return InsnMatcher;\n  }\n\n  if (Predicate.isAtomic()) {\n    if (Predicate.isAtomicOrderingMonotonic()) {\n      InsnMatcher.addPredicate<AtomicOrderingMMOPredicateMatcher>(\"Monotonic\");\n      return InsnMatcher;\n    }\n    if (Predicate.isAtomicOrderingAcquire()) {\n      InsnMatcher.addPredicate<AtomicOrderingMMOPredicateMatcher>(\"Acquire\");\n      return InsnMatcher;\n    }\n    if (Predicate.isAtomicOrderingRelease()) {\n      InsnMatcher.addPredicate<AtomicOrderingMMOPredicateMatcher>(\"Release\");\n      return InsnMatcher;\n    }\n    if (Predicate.isAtomicOrderingAcquireRelease()) {\n      InsnMatcher.addPredicate<AtomicOrderingMMOPredicateMatcher>(\n          \"AcquireRelease\");\n      return InsnMatcher;\n    }\n    if (Predicate.isAtomicOrderingSequentiallyConsistent()) {\n      InsnMatcher.addPredicate<AtomicOrderingMMOPredicateMatcher>(\n          \"SequentiallyConsistent\");\n      return InsnMatcher;\n    }\n  }\n\n  if (Predicate.isAtomicOrderingAcquireOrStronger()) {\n    InsnMatcher.addPredicate<AtomicOrderingMMOPredicateMatcher>(\n        \"Acquire\", AtomicOrderingMMOPredicateMatcher::AO_OrStronger);\n    return InsnMatcher;\n  }\n  if (Predicate.isAtomicOrderingWeakerThanAcquire()) {\n    InsnMatcher.addPredicate<AtomicOrderingMMOPredicateMatcher>(\n        \"Acquire\", AtomicOrderingMMOPredicateMatcher::AO_WeakerThan);\n    return InsnMatcher;\n  }\n\n  if (Predicate.isAtomicOrderingReleaseOrStronger()) {\n    InsnMatcher.addPredicate<AtomicOrderingMMOPredicateMatcher>(\n        \"Release\", AtomicOrderingMMOPredicateMatcher::AO_OrStronger);\n    return InsnMatcher;\n  }\n  if (Predicate.isAtomicOrderingWeakerThanRelease()) {\n    InsnMatcher.addPredicate<AtomicOrderingMMOPredicateMatcher>(\n        \"Release\", AtomicOrderingMMOPredicateMatcher::AO_WeakerThan);\n    return InsnMatcher;\n  }\n  HasAddedMatcher = false;\n  return InsnMatcher;\n}\n\nExpected<InstructionMatcher &> GlobalISelEmitter::createAndImportSelDAGMatcher(\n    RuleMatcher &Rule, InstructionMatcher &InsnMatcher,\n    const TreePatternNode *Src, unsigned &TempOpIdx) {\n  Record *SrcGIEquivOrNull = nullptr;\n  const CodeGenInstruction *SrcGIOrNull = nullptr;\n\n  // Start with the defined operands (i.e., the results of the root operator).\n  if (Src->getExtTypes().size() > 1)\n    return failedImport(\"Src pattern has multiple results\");\n\n  if (Src->isLeaf()) {\n    Init *SrcInit = Src->getLeafValue();\n    if (isa<IntInit>(SrcInit)) {\n      InsnMatcher.addPredicate<InstructionOpcodeMatcher>(\n          &Target.getInstruction(RK.getDef(\"G_CONSTANT\")));\n    } else\n      return failedImport(\n          \"Unable to deduce gMIR opcode to handle Src (which is a leaf)\");\n  } else {\n    SrcGIEquivOrNull = findNodeEquiv(Src->getOperator());\n    if (!SrcGIEquivOrNull)\n      return failedImport(\"Pattern operator lacks an equivalent Instruction\" +\n                          explainOperator(Src->getOperator()));\n    SrcGIOrNull = getEquivNode(*SrcGIEquivOrNull, Src);\n\n    // The operators look good: match the opcode\n    InsnMatcher.addPredicate<InstructionOpcodeMatcher>(SrcGIOrNull);\n  }\n\n  unsigned OpIdx = 0;\n  for (const TypeSetByHwMode &VTy : Src->getExtTypes()) {\n    // Results don't have a name unless they are the root node. The caller will\n    // set the name if appropriate.\n    OperandMatcher &OM = InsnMatcher.addOperand(OpIdx++, \"\", TempOpIdx);\n    if (auto Error = OM.addTypeCheckPredicate(VTy, false /* OperandIsAPointer */))\n      return failedImport(toString(std::move(Error)) +\n                          \" for result of Src pattern operator\");\n  }\n\n  for (const TreePredicateCall &Call : Src->getPredicateCalls()) {\n    const TreePredicateFn &Predicate = Call.Fn;\n    bool HasAddedBuiltinMatcher = true;\n    if (Predicate.isAlwaysTrue())\n      continue;\n\n    if (Predicate.isImmediatePattern()) {\n      InsnMatcher.addPredicate<InstructionImmPredicateMatcher>(Predicate);\n      continue;\n    }\n\n    auto InsnMatcherOrError = addBuiltinPredicates(\n        SrcGIEquivOrNull, Predicate, InsnMatcher, HasAddedBuiltinMatcher);\n    if (auto Error = InsnMatcherOrError.takeError())\n      return std::move(Error);\n\n    if (Predicate.hasGISelPredicateCode()) {\n      if (Predicate.usesOperands()) {\n        assert(WaitingForNamedOperands == 0 &&\n               \"previous predicate didn't find all operands or \"\n               \"nested predicate that uses operands\");\n        TreePattern *TP = Predicate.getOrigPatFragRecord();\n        WaitingForNamedOperands = TP->getNumArgs();\n        for (unsigned i = 0; i < WaitingForNamedOperands; ++i)\n          StoreIdxForName[getScopedName(Call.Scope, TP->getArgName(i))] = i;\n      }\n      InsnMatcher.addPredicate<GenericInstructionPredicateMatcher>(Predicate);\n      continue;\n    }\n    if (!HasAddedBuiltinMatcher) {\n      return failedImport(\"Src pattern child has predicate (\" +\n                          explainPredicates(Src) + \")\");\n    }\n  }\n\n  bool IsAtomic = false;\n  if (SrcGIEquivOrNull && SrcGIEquivOrNull->getValueAsBit(\"CheckMMOIsNonAtomic\"))\n    InsnMatcher.addPredicate<AtomicOrderingMMOPredicateMatcher>(\"NotAtomic\");\n  else if (SrcGIEquivOrNull && SrcGIEquivOrNull->getValueAsBit(\"CheckMMOIsAtomic\")) {\n    IsAtomic = true;\n    InsnMatcher.addPredicate<AtomicOrderingMMOPredicateMatcher>(\n      \"Unordered\", AtomicOrderingMMOPredicateMatcher::AO_OrStronger);\n  }\n\n  if (Src->isLeaf()) {\n    Init *SrcInit = Src->getLeafValue();\n    if (IntInit *SrcIntInit = dyn_cast<IntInit>(SrcInit)) {\n      OperandMatcher &OM =\n          InsnMatcher.addOperand(OpIdx++, Src->getName(), TempOpIdx);\n      OM.addPredicate<LiteralIntOperandMatcher>(SrcIntInit->getValue());\n    } else\n      return failedImport(\n          \"Unable to deduce gMIR opcode to handle Src (which is a leaf)\");\n  } else {\n    assert(SrcGIOrNull &&\n           \"Expected to have already found an equivalent Instruction\");\n    if (SrcGIOrNull->TheDef->getName() == \"G_CONSTANT\" ||\n        SrcGIOrNull->TheDef->getName() == \"G_FCONSTANT\") {\n      // imm/fpimm still have operands but we don't need to do anything with it\n      // here since we don't support ImmLeaf predicates yet. However, we still\n      // need to note the hidden operand to get GIM_CheckNumOperands correct.\n      InsnMatcher.addOperand(OpIdx++, \"\", TempOpIdx);\n      return InsnMatcher;\n    }\n\n    // Special case because the operand order is changed from setcc. The\n    // predicate operand needs to be swapped from the last operand to the first\n    // source.\n\n    unsigned NumChildren = Src->getNumChildren();\n    bool IsFCmp = SrcGIOrNull->TheDef->getName() == \"G_FCMP\";\n\n    if (IsFCmp || SrcGIOrNull->TheDef->getName() == \"G_ICMP\") {\n      TreePatternNode *SrcChild = Src->getChild(NumChildren - 1);\n      if (SrcChild->isLeaf()) {\n        DefInit *DI = dyn_cast<DefInit>(SrcChild->getLeafValue());\n        Record *CCDef = DI ? DI->getDef() : nullptr;\n        if (!CCDef || !CCDef->isSubClassOf(\"CondCode\"))\n          return failedImport(\"Unable to handle CondCode\");\n\n        OperandMatcher &OM =\n          InsnMatcher.addOperand(OpIdx++, SrcChild->getName(), TempOpIdx);\n        StringRef PredType = IsFCmp ? CCDef->getValueAsString(\"FCmpPredicate\") :\n                                      CCDef->getValueAsString(\"ICmpPredicate\");\n\n        if (!PredType.empty()) {\n          OM.addPredicate<CmpPredicateOperandMatcher>(std::string(PredType));\n          // Process the other 2 operands normally.\n          --NumChildren;\n        }\n      }\n    }\n\n    // Hack around an unfortunate mistake in how atomic store (and really\n    // atomicrmw in general) operands were ordered. A ISD::STORE used the order\n    // <stored value>, <pointer> order. ISD::ATOMIC_STORE used the opposite,\n    // <pointer>, <stored value>. In GlobalISel there's just the one store\n    // opcode, so we need to swap the operands here to get the right type check.\n    if (IsAtomic && SrcGIOrNull->TheDef->getName() == \"G_STORE\") {\n      assert(NumChildren == 2 && \"wrong operands for atomic store\");\n\n      TreePatternNode *PtrChild = Src->getChild(0);\n      TreePatternNode *ValueChild = Src->getChild(1);\n\n      if (auto Error = importChildMatcher(Rule, InsnMatcher, PtrChild, true,\n                                          false, 1, TempOpIdx))\n        return std::move(Error);\n\n      if (auto Error = importChildMatcher(Rule, InsnMatcher, ValueChild, false,\n                                          false, 0, TempOpIdx))\n        return std::move(Error);\n      return InsnMatcher;\n    }\n\n    // Match the used operands (i.e. the children of the operator).\n    bool IsIntrinsic =\n        SrcGIOrNull->TheDef->getName() == \"G_INTRINSIC\" ||\n        SrcGIOrNull->TheDef->getName() == \"G_INTRINSIC_W_SIDE_EFFECTS\";\n    const CodeGenIntrinsic *II = Src->getIntrinsicInfo(CGP);\n    if (IsIntrinsic && !II)\n      return failedImport(\"Expected IntInit containing intrinsic ID)\");\n\n    for (unsigned i = 0; i != NumChildren; ++i) {\n      TreePatternNode *SrcChild = Src->getChild(i);\n\n      // We need to determine the meaning of a literal integer based on the\n      // context. If this is a field required to be an immediate (such as an\n      // immarg intrinsic argument), the required predicates are different than\n      // a constant which may be materialized in a register. If we have an\n      // argument that is required to be an immediate, we should not emit an LLT\n      // type check, and should not be looking for a G_CONSTANT defined\n      // register.\n      bool OperandIsImmArg = SrcGIOrNull->isOperandImmArg(i);\n\n      // SelectionDAG allows pointers to be represented with iN since it doesn't\n      // distinguish between pointers and integers but they are different types in GlobalISel.\n      // Coerce integers to pointers to address space 0 if the context indicates a pointer.\n      //\n      bool OperandIsAPointer = SrcGIOrNull->isOperandAPointer(i);\n\n      if (IsIntrinsic) {\n        // For G_INTRINSIC/G_INTRINSIC_W_SIDE_EFFECTS, the operand immediately\n        // following the defs is an intrinsic ID.\n        if (i == 0) {\n          OperandMatcher &OM =\n              InsnMatcher.addOperand(OpIdx++, SrcChild->getName(), TempOpIdx);\n          OM.addPredicate<IntrinsicIDOperandMatcher>(II);\n          continue;\n        }\n\n        // We have to check intrinsics for llvm_anyptr_ty and immarg parameters.\n        //\n        // Note that we have to look at the i-1th parameter, because we don't\n        // have the intrinsic ID in the intrinsic's parameter list.\n        OperandIsAPointer |= II->isParamAPointer(i - 1);\n        OperandIsImmArg |= II->isParamImmArg(i - 1);\n      }\n\n      if (auto Error =\n              importChildMatcher(Rule, InsnMatcher, SrcChild, OperandIsAPointer,\n                                 OperandIsImmArg, OpIdx++, TempOpIdx))\n        return std::move(Error);\n    }\n  }\n\n  return InsnMatcher;\n}\n\nError GlobalISelEmitter::importComplexPatternOperandMatcher(\n    OperandMatcher &OM, Record *R, unsigned &TempOpIdx) const {\n  const auto &ComplexPattern = ComplexPatternEquivs.find(R);\n  if (ComplexPattern == ComplexPatternEquivs.end())\n    return failedImport(\"SelectionDAG ComplexPattern (\" + R->getName() +\n                        \") not mapped to GlobalISel\");\n\n  OM.addPredicate<ComplexPatternOperandMatcher>(OM, *ComplexPattern->second);\n  TempOpIdx++;\n  return Error::success();\n}\n\n// Get the name to use for a pattern operand. For an anonymous physical register\n// input, this should use the register name.\nstatic StringRef getSrcChildName(const TreePatternNode *SrcChild,\n                                 Record *&PhysReg) {\n  StringRef SrcChildName = SrcChild->getName();\n  if (SrcChildName.empty() && SrcChild->isLeaf()) {\n    if (auto *ChildDefInit = dyn_cast<DefInit>(SrcChild->getLeafValue())) {\n      auto *ChildRec = ChildDefInit->getDef();\n      if (ChildRec->isSubClassOf(\"Register\")) {\n        SrcChildName = ChildRec->getName();\n        PhysReg = ChildRec;\n      }\n    }\n  }\n\n  return SrcChildName;\n}\n\nError GlobalISelEmitter::importChildMatcher(\n    RuleMatcher &Rule, InstructionMatcher &InsnMatcher,\n    const TreePatternNode *SrcChild, bool OperandIsAPointer,\n    bool OperandIsImmArg, unsigned OpIdx, unsigned &TempOpIdx) {\n\n  Record *PhysReg = nullptr;\n  std::string SrcChildName = std::string(getSrcChildName(SrcChild, PhysReg));\n  if (!SrcChild->isLeaf() &&\n      SrcChild->getOperator()->isSubClassOf(\"ComplexPattern\")) {\n    // The \"name\" of a non-leaf complex pattern (MY_PAT $op1, $op2) is\n    // \"MY_PAT:op1:op2\" and the ones with same \"name\" represent same operand.\n    std::string PatternName = std::string(SrcChild->getOperator()->getName());\n    for (unsigned i = 0; i < SrcChild->getNumChildren(); ++i) {\n      PatternName += \":\";\n      PatternName += SrcChild->getChild(i)->getName();\n    }\n    SrcChildName = PatternName;\n  }\n\n  OperandMatcher &OM =\n      PhysReg ? InsnMatcher.addPhysRegInput(PhysReg, OpIdx, TempOpIdx)\n              : InsnMatcher.addOperand(OpIdx, SrcChildName, TempOpIdx);\n  if (OM.isSameAsAnotherOperand())\n    return Error::success();\n\n  ArrayRef<TypeSetByHwMode> ChildTypes = SrcChild->getExtTypes();\n  if (ChildTypes.size() != 1)\n    return failedImport(\"Src pattern child has multiple results\");\n\n  // Check MBB's before the type check since they are not a known type.\n  if (!SrcChild->isLeaf()) {\n    if (SrcChild->getOperator()->isSubClassOf(\"SDNode\")) {\n      auto &ChildSDNI = CGP.getSDNodeInfo(SrcChild->getOperator());\n      if (ChildSDNI.getSDClassName() == \"BasicBlockSDNode\") {\n        OM.addPredicate<MBBOperandMatcher>();\n        return Error::success();\n      }\n      if (SrcChild->getOperator()->getName() == \"timm\") {\n        OM.addPredicate<ImmOperandMatcher>();\n        return Error::success();\n      }\n    }\n  }\n\n  // Immediate arguments have no meaningful type to check as they don't have\n  // registers.\n  if (!OperandIsImmArg) {\n    if (auto Error =\n            OM.addTypeCheckPredicate(ChildTypes.front(), OperandIsAPointer))\n      return failedImport(toString(std::move(Error)) + \" for Src operand (\" +\n                          to_string(*SrcChild) + \")\");\n  }\n\n  // Check for nested instructions.\n  if (!SrcChild->isLeaf()) {\n    if (SrcChild->getOperator()->isSubClassOf(\"ComplexPattern\")) {\n      // When a ComplexPattern is used as an operator, it should do the same\n      // thing as when used as a leaf. However, the children of the operator\n      // name the sub-operands that make up the complex operand and we must\n      // prepare to reference them in the renderer too.\n      unsigned RendererID = TempOpIdx;\n      if (auto Error = importComplexPatternOperandMatcher(\n              OM, SrcChild->getOperator(), TempOpIdx))\n        return Error;\n\n      for (unsigned i = 0, e = SrcChild->getNumChildren(); i != e; ++i) {\n        auto *SubOperand = SrcChild->getChild(i);\n        if (!SubOperand->getName().empty()) {\n          if (auto Error = Rule.defineComplexSubOperand(\n                  SubOperand->getName(), SrcChild->getOperator(), RendererID, i,\n                  SrcChildName))\n            return Error;\n        }\n      }\n\n      return Error::success();\n    }\n\n    auto MaybeInsnOperand = OM.addPredicate<InstructionOperandMatcher>(\n        InsnMatcher.getRuleMatcher(), SrcChild->getName());\n    if (!MaybeInsnOperand.hasValue()) {\n      // This isn't strictly true. If the user were to provide exactly the same\n      // matchers as the original operand then we could allow it. However, it's\n      // simpler to not permit the redundant specification.\n      return failedImport(\"Nested instruction cannot be the same as another operand\");\n    }\n\n    // Map the node to a gMIR instruction.\n    InstructionOperandMatcher &InsnOperand = **MaybeInsnOperand;\n    auto InsnMatcherOrError = createAndImportSelDAGMatcher(\n        Rule, InsnOperand.getInsnMatcher(), SrcChild, TempOpIdx);\n    if (auto Error = InsnMatcherOrError.takeError())\n      return Error;\n\n    return Error::success();\n  }\n\n  if (SrcChild->hasAnyPredicate())\n    return failedImport(\"Src pattern child has unsupported predicate\");\n\n  // Check for constant immediates.\n  if (auto *ChildInt = dyn_cast<IntInit>(SrcChild->getLeafValue())) {\n    if (OperandIsImmArg) {\n      // Checks for argument directly in operand list\n      OM.addPredicate<LiteralIntOperandMatcher>(ChildInt->getValue());\n    } else {\n      // Checks for materialized constant\n      OM.addPredicate<ConstantIntOperandMatcher>(ChildInt->getValue());\n    }\n    return Error::success();\n  }\n\n  // Check for def's like register classes or ComplexPattern's.\n  if (auto *ChildDefInit = dyn_cast<DefInit>(SrcChild->getLeafValue())) {\n    auto *ChildRec = ChildDefInit->getDef();\n\n    if (WaitingForNamedOperands) {\n      auto PA = SrcChild->getNamesAsPredicateArg().begin();\n      std::string Name = getScopedName(PA->getScope(), PA->getIdentifier());\n      OM.addPredicate<RecordNamedOperandMatcher>(StoreIdxForName[Name], Name);\n      --WaitingForNamedOperands;\n    }\n\n    // Check for register classes.\n    if (ChildRec->isSubClassOf(\"RegisterClass\") ||\n        ChildRec->isSubClassOf(\"RegisterOperand\")) {\n      OM.addPredicate<RegisterBankOperandMatcher>(\n          Target.getRegisterClass(getInitValueAsRegClass(ChildDefInit)));\n      return Error::success();\n    }\n\n    if (ChildRec->isSubClassOf(\"Register\")) {\n      // This just be emitted as a copy to the specific register.\n      ValueTypeByHwMode VT = ChildTypes.front().getValueTypeByHwMode();\n      const CodeGenRegisterClass *RC\n        = CGRegs.getMinimalPhysRegClass(ChildRec, &VT);\n      if (!RC) {\n        return failedImport(\n          \"Could not determine physical register class of pattern source\");\n      }\n\n      OM.addPredicate<RegisterBankOperandMatcher>(*RC);\n      return Error::success();\n    }\n\n    // Check for ValueType.\n    if (ChildRec->isSubClassOf(\"ValueType\")) {\n      // We already added a type check as standard practice so this doesn't need\n      // to do anything.\n      return Error::success();\n    }\n\n    // Check for ComplexPattern's.\n    if (ChildRec->isSubClassOf(\"ComplexPattern\"))\n      return importComplexPatternOperandMatcher(OM, ChildRec, TempOpIdx);\n\n    if (ChildRec->isSubClassOf(\"ImmLeaf\")) {\n      return failedImport(\n          \"Src pattern child def is an unsupported tablegen class (ImmLeaf)\");\n    }\n\n    // Place holder for SRCVALUE nodes. Nothing to do here.\n    if (ChildRec->getName() == \"srcvalue\")\n      return Error::success();\n\n    const bool ImmAllOnesV = ChildRec->getName() == \"immAllOnesV\";\n    if (ImmAllOnesV || ChildRec->getName() == \"immAllZerosV\") {\n      auto MaybeInsnOperand = OM.addPredicate<InstructionOperandMatcher>(\n          InsnMatcher.getRuleMatcher(), SrcChild->getName(), false);\n      InstructionOperandMatcher &InsnOperand = **MaybeInsnOperand;\n\n      ValueTypeByHwMode VTy = ChildTypes.front().getValueTypeByHwMode();\n\n      const CodeGenInstruction &BuildVector\n        = Target.getInstruction(RK.getDef(\"G_BUILD_VECTOR\"));\n      const CodeGenInstruction &BuildVectorTrunc\n        = Target.getInstruction(RK.getDef(\"G_BUILD_VECTOR_TRUNC\"));\n\n      // Treat G_BUILD_VECTOR as the canonical opcode, and G_BUILD_VECTOR_TRUNC\n      // as an alternative.\n      InsnOperand.getInsnMatcher().addPredicate<InstructionOpcodeMatcher>(\n      makeArrayRef({&BuildVector, &BuildVectorTrunc}));\n\n      // TODO: Handle both G_BUILD_VECTOR and G_BUILD_VECTOR_TRUNC We could\n      // theoretically not emit any opcode check, but getOpcodeMatcher currently\n      // has to succeed.\n      OperandMatcher &OM =\n          InsnOperand.getInsnMatcher().addOperand(0, \"\", TempOpIdx);\n      if (auto Error =\n              OM.addTypeCheckPredicate(VTy, false /* OperandIsAPointer */))\n        return failedImport(toString(std::move(Error)) +\n                            \" for result of Src pattern operator\");\n\n      InsnOperand.getInsnMatcher().addPredicate<VectorSplatImmPredicateMatcher>(\n          ImmAllOnesV ? VectorSplatImmPredicateMatcher::AllOnes\n                      : VectorSplatImmPredicateMatcher::AllZeros);\n      return Error::success();\n    }\n\n    return failedImport(\n        \"Src pattern child def is an unsupported tablegen class\");\n  }\n\n  return failedImport(\"Src pattern child is an unsupported kind\");\n}\n\nExpected<action_iterator> GlobalISelEmitter::importExplicitUseRenderer(\n    action_iterator InsertPt, RuleMatcher &Rule, BuildMIAction &DstMIBuilder,\n    TreePatternNode *DstChild) {\n\n  const auto &SubOperand = Rule.getComplexSubOperand(DstChild->getName());\n  if (SubOperand.hasValue()) {\n    DstMIBuilder.addRenderer<RenderComplexPatternOperand>(\n        *std::get<0>(*SubOperand), DstChild->getName(),\n        std::get<1>(*SubOperand), std::get<2>(*SubOperand));\n    return InsertPt;\n  }\n\n  if (!DstChild->isLeaf()) {\n    if (DstChild->getOperator()->isSubClassOf(\"SDNodeXForm\")) {\n      auto Child = DstChild->getChild(0);\n      auto I = SDNodeXFormEquivs.find(DstChild->getOperator());\n      if (I != SDNodeXFormEquivs.end()) {\n        Record *XFormOpc = DstChild->getOperator()->getValueAsDef(\"Opcode\");\n        if (XFormOpc->getName() == \"timm\") {\n          // If this is a TargetConstant, there won't be a corresponding\n          // instruction to transform. Instead, this will refer directly to an\n          // operand in an instruction's operand list.\n          DstMIBuilder.addRenderer<CustomOperandRenderer>(*I->second,\n                                                          Child->getName());\n        } else {\n          DstMIBuilder.addRenderer<CustomRenderer>(*I->second,\n                                                   Child->getName());\n        }\n\n        return InsertPt;\n      }\n      return failedImport(\"SDNodeXForm \" + Child->getName() +\n                          \" has no custom renderer\");\n    }\n\n    // We accept 'bb' here. It's an operator because BasicBlockSDNode isn't\n    // inline, but in MI it's just another operand.\n    if (DstChild->getOperator()->isSubClassOf(\"SDNode\")) {\n      auto &ChildSDNI = CGP.getSDNodeInfo(DstChild->getOperator());\n      if (ChildSDNI.getSDClassName() == \"BasicBlockSDNode\") {\n        DstMIBuilder.addRenderer<CopyRenderer>(DstChild->getName());\n        return InsertPt;\n      }\n    }\n\n    // Similarly, imm is an operator in TreePatternNode's view but must be\n    // rendered as operands.\n    // FIXME: The target should be able to choose sign-extended when appropriate\n    //        (e.g. on Mips).\n    if (DstChild->getOperator()->getName() == \"timm\") {\n      DstMIBuilder.addRenderer<CopyRenderer>(DstChild->getName());\n      return InsertPt;\n    } else if (DstChild->getOperator()->getName() == \"imm\") {\n      DstMIBuilder.addRenderer<CopyConstantAsImmRenderer>(DstChild->getName());\n      return InsertPt;\n    } else if (DstChild->getOperator()->getName() == \"fpimm\") {\n      DstMIBuilder.addRenderer<CopyFConstantAsFPImmRenderer>(\n          DstChild->getName());\n      return InsertPt;\n    }\n\n    if (DstChild->getOperator()->isSubClassOf(\"Instruction\")) {\n      auto OpTy = getInstResultType(DstChild);\n      if (!OpTy)\n        return OpTy.takeError();\n\n      unsigned TempRegID = Rule.allocateTempRegID();\n      InsertPt = Rule.insertAction<MakeTempRegisterAction>(\n          InsertPt, *OpTy, TempRegID);\n      DstMIBuilder.addRenderer<TempRegRenderer>(TempRegID);\n\n      auto InsertPtOrError = createAndImportSubInstructionRenderer(\n          ++InsertPt, Rule, DstChild, TempRegID);\n      if (auto Error = InsertPtOrError.takeError())\n        return std::move(Error);\n      return InsertPtOrError.get();\n    }\n\n    return failedImport(\"Dst pattern child isn't a leaf node or an MBB\" + llvm::to_string(*DstChild));\n  }\n\n  // It could be a specific immediate in which case we should just check for\n  // that immediate.\n  if (const IntInit *ChildIntInit =\n          dyn_cast<IntInit>(DstChild->getLeafValue())) {\n    DstMIBuilder.addRenderer<ImmRenderer>(ChildIntInit->getValue());\n    return InsertPt;\n  }\n\n  // Otherwise, we're looking for a bog-standard RegisterClass operand.\n  if (auto *ChildDefInit = dyn_cast<DefInit>(DstChild->getLeafValue())) {\n    auto *ChildRec = ChildDefInit->getDef();\n\n    ArrayRef<TypeSetByHwMode> ChildTypes = DstChild->getExtTypes();\n    if (ChildTypes.size() != 1)\n      return failedImport(\"Dst pattern child has multiple results\");\n\n    Optional<LLTCodeGen> OpTyOrNone = None;\n    if (ChildTypes.front().isMachineValueType())\n      OpTyOrNone = MVTToLLT(ChildTypes.front().getMachineValueType().SimpleTy);\n    if (!OpTyOrNone)\n      return failedImport(\"Dst operand has an unsupported type\");\n\n    if (ChildRec->isSubClassOf(\"Register\")) {\n      DstMIBuilder.addRenderer<AddRegisterRenderer>(Target, ChildRec);\n      return InsertPt;\n    }\n\n    if (ChildRec->isSubClassOf(\"RegisterClass\") ||\n        ChildRec->isSubClassOf(\"RegisterOperand\") ||\n        ChildRec->isSubClassOf(\"ValueType\")) {\n      if (ChildRec->isSubClassOf(\"RegisterOperand\") &&\n          !ChildRec->isValueUnset(\"GIZeroRegister\")) {\n        DstMIBuilder.addRenderer<CopyOrAddZeroRegRenderer>(\n            DstChild->getName(), ChildRec->getValueAsDef(\"GIZeroRegister\"));\n        return InsertPt;\n      }\n\n      DstMIBuilder.addRenderer<CopyRenderer>(DstChild->getName());\n      return InsertPt;\n    }\n\n    if (ChildRec->isSubClassOf(\"SubRegIndex\")) {\n      CodeGenSubRegIndex *SubIdx = CGRegs.getSubRegIdx(ChildRec);\n      DstMIBuilder.addRenderer<ImmRenderer>(SubIdx->EnumValue);\n      return InsertPt;\n    }\n\n    if (ChildRec->isSubClassOf(\"ComplexPattern\")) {\n      const auto &ComplexPattern = ComplexPatternEquivs.find(ChildRec);\n      if (ComplexPattern == ComplexPatternEquivs.end())\n        return failedImport(\n            \"SelectionDAG ComplexPattern not mapped to GlobalISel\");\n\n      const OperandMatcher &OM = Rule.getOperandMatcher(DstChild->getName());\n      DstMIBuilder.addRenderer<RenderComplexPatternOperand>(\n          *ComplexPattern->second, DstChild->getName(),\n          OM.getAllocatedTemporariesBaseID());\n      return InsertPt;\n    }\n\n    return failedImport(\n        \"Dst pattern child def is an unsupported tablegen class\");\n  }\n\n  return failedImport(\"Dst pattern child is an unsupported kind\");\n}\n\nExpected<BuildMIAction &> GlobalISelEmitter::createAndImportInstructionRenderer(\n    RuleMatcher &M, InstructionMatcher &InsnMatcher, const TreePatternNode *Src,\n    const TreePatternNode *Dst) {\n  auto InsertPtOrError = createInstructionRenderer(M.actions_end(), M, Dst);\n  if (auto Error = InsertPtOrError.takeError())\n    return std::move(Error);\n\n  action_iterator InsertPt = InsertPtOrError.get();\n  BuildMIAction &DstMIBuilder = *static_cast<BuildMIAction *>(InsertPt->get());\n\n  for (auto PhysInput : InsnMatcher.getPhysRegInputs()) {\n    InsertPt = M.insertAction<BuildMIAction>(\n        InsertPt, M.allocateOutputInsnID(),\n        &Target.getInstruction(RK.getDef(\"COPY\")));\n    BuildMIAction &CopyToPhysRegMIBuilder =\n        *static_cast<BuildMIAction *>(InsertPt->get());\n    CopyToPhysRegMIBuilder.addRenderer<AddRegisterRenderer>(Target,\n                                                            PhysInput.first,\n                                                            true);\n    CopyToPhysRegMIBuilder.addRenderer<CopyPhysRegRenderer>(PhysInput.first);\n  }\n\n  if (auto Error = importExplicitDefRenderers(InsertPt, M, DstMIBuilder, Dst)\n                       .takeError())\n    return std::move(Error);\n\n  if (auto Error = importExplicitUseRenderers(InsertPt, M, DstMIBuilder, Dst)\n                       .takeError())\n    return std::move(Error);\n\n  return DstMIBuilder;\n}\n\nExpected<action_iterator>\nGlobalISelEmitter::createAndImportSubInstructionRenderer(\n    const action_iterator InsertPt, RuleMatcher &M, const TreePatternNode *Dst,\n    unsigned TempRegID) {\n  auto InsertPtOrError = createInstructionRenderer(InsertPt, M, Dst);\n\n  // TODO: Assert there's exactly one result.\n\n  if (auto Error = InsertPtOrError.takeError())\n    return std::move(Error);\n\n  BuildMIAction &DstMIBuilder =\n      *static_cast<BuildMIAction *>(InsertPtOrError.get()->get());\n\n  // Assign the result to TempReg.\n  DstMIBuilder.addRenderer<TempRegRenderer>(TempRegID, true);\n\n  InsertPtOrError =\n      importExplicitUseRenderers(InsertPtOrError.get(), M, DstMIBuilder, Dst);\n  if (auto Error = InsertPtOrError.takeError())\n    return std::move(Error);\n\n  // We need to make sure that when we import an INSERT_SUBREG as a\n  // subinstruction that it ends up being constrained to the correct super\n  // register and subregister classes.\n  auto OpName = Target.getInstruction(Dst->getOperator()).TheDef->getName();\n  if (OpName == \"INSERT_SUBREG\") {\n    auto SubClass = inferRegClassFromPattern(Dst->getChild(1));\n    if (!SubClass)\n      return failedImport(\n          \"Cannot infer register class from INSERT_SUBREG operand #1\");\n    Optional<const CodeGenRegisterClass *> SuperClass =\n        inferSuperRegisterClassForNode(Dst->getExtType(0), Dst->getChild(0),\n                                       Dst->getChild(2));\n    if (!SuperClass)\n      return failedImport(\n          \"Cannot infer register class for INSERT_SUBREG operand #0\");\n    // The destination and the super register source of an INSERT_SUBREG must\n    // be the same register class.\n    M.insertAction<ConstrainOperandToRegClassAction>(\n        InsertPt, DstMIBuilder.getInsnID(), 0, **SuperClass);\n    M.insertAction<ConstrainOperandToRegClassAction>(\n        InsertPt, DstMIBuilder.getInsnID(), 1, **SuperClass);\n    M.insertAction<ConstrainOperandToRegClassAction>(\n        InsertPt, DstMIBuilder.getInsnID(), 2, **SubClass);\n    return InsertPtOrError.get();\n  }\n\n  if (OpName == \"EXTRACT_SUBREG\") {\n    // EXTRACT_SUBREG selects into a subregister COPY but unlike most\n    // instructions, the result register class is controlled by the\n    // subregisters of the operand. As a result, we must constrain the result\n    // class rather than check that it's already the right one.\n    auto SuperClass = inferRegClassFromPattern(Dst->getChild(0));\n    if (!SuperClass)\n      return failedImport(\n        \"Cannot infer register class from EXTRACT_SUBREG operand #0\");\n\n    auto SubIdx = inferSubRegIndexForNode(Dst->getChild(1));\n    if (!SubIdx)\n      return failedImport(\"EXTRACT_SUBREG child #1 is not a subreg index\");\n\n    const auto SrcRCDstRCPair =\n      (*SuperClass)->getMatchingSubClassWithSubRegs(CGRegs, *SubIdx);\n    assert(SrcRCDstRCPair->second && \"Couldn't find a matching subclass\");\n    M.insertAction<ConstrainOperandToRegClassAction>(\n      InsertPt, DstMIBuilder.getInsnID(), 0, *SrcRCDstRCPair->second);\n    M.insertAction<ConstrainOperandToRegClassAction>(\n      InsertPt, DstMIBuilder.getInsnID(), 1, *SrcRCDstRCPair->first);\n\n    // We're done with this pattern!  It's eligible for GISel emission; return\n    // it.\n    return InsertPtOrError.get();\n  }\n\n  // Similar to INSERT_SUBREG, we also have to handle SUBREG_TO_REG as a\n  // subinstruction.\n  if (OpName == \"SUBREG_TO_REG\") {\n    auto SubClass = inferRegClassFromPattern(Dst->getChild(1));\n    if (!SubClass)\n      return failedImport(\n        \"Cannot infer register class from SUBREG_TO_REG child #1\");\n    auto SuperClass = inferSuperRegisterClass(Dst->getExtType(0),\n                                              Dst->getChild(2));\n    if (!SuperClass)\n      return failedImport(\n        \"Cannot infer register class for SUBREG_TO_REG operand #0\");\n    M.insertAction<ConstrainOperandToRegClassAction>(\n      InsertPt, DstMIBuilder.getInsnID(), 0, **SuperClass);\n    M.insertAction<ConstrainOperandToRegClassAction>(\n      InsertPt, DstMIBuilder.getInsnID(), 2, **SubClass);\n    return InsertPtOrError.get();\n  }\n\n  if (OpName == \"REG_SEQUENCE\") {\n    auto SuperClass = inferRegClassFromPattern(Dst->getChild(0));\n    M.insertAction<ConstrainOperandToRegClassAction>(\n      InsertPt, DstMIBuilder.getInsnID(), 0, **SuperClass);\n\n    unsigned Num = Dst->getNumChildren();\n    for (unsigned I = 1; I != Num; I += 2) {\n      TreePatternNode *SubRegChild = Dst->getChild(I + 1);\n\n      auto SubIdx = inferSubRegIndexForNode(SubRegChild);\n      if (!SubIdx)\n        return failedImport(\"REG_SEQUENCE child is not a subreg index\");\n\n      const auto SrcRCDstRCPair =\n        (*SuperClass)->getMatchingSubClassWithSubRegs(CGRegs, *SubIdx);\n      assert(SrcRCDstRCPair->second && \"Couldn't find a matching subclass\");\n      M.insertAction<ConstrainOperandToRegClassAction>(\n        InsertPt, DstMIBuilder.getInsnID(), I, *SrcRCDstRCPair->second);\n    }\n\n    return InsertPtOrError.get();\n  }\n\n  M.insertAction<ConstrainOperandsToDefinitionAction>(InsertPt,\n                                                      DstMIBuilder.getInsnID());\n  return InsertPtOrError.get();\n}\n\nExpected<action_iterator> GlobalISelEmitter::createInstructionRenderer(\n    action_iterator InsertPt, RuleMatcher &M, const TreePatternNode *Dst) {\n  Record *DstOp = Dst->getOperator();\n  if (!DstOp->isSubClassOf(\"Instruction\")) {\n    if (DstOp->isSubClassOf(\"ValueType\"))\n      return failedImport(\n          \"Pattern operator isn't an instruction (it's a ValueType)\");\n    return failedImport(\"Pattern operator isn't an instruction\");\n  }\n  CodeGenInstruction *DstI = &Target.getInstruction(DstOp);\n\n  // COPY_TO_REGCLASS is just a copy with a ConstrainOperandToRegClassAction\n  // attached. Similarly for EXTRACT_SUBREG except that's a subregister copy.\n  StringRef Name = DstI->TheDef->getName();\n  if (Name == \"COPY_TO_REGCLASS\" || Name == \"EXTRACT_SUBREG\")\n    DstI = &Target.getInstruction(RK.getDef(\"COPY\"));\n\n  return M.insertAction<BuildMIAction>(InsertPt, M.allocateOutputInsnID(),\n                                       DstI);\n}\n\nExpected<action_iterator> GlobalISelEmitter::importExplicitDefRenderers(\n    action_iterator InsertPt, RuleMatcher &M, BuildMIAction &DstMIBuilder,\n    const TreePatternNode *Dst) {\n  const CodeGenInstruction *DstI = DstMIBuilder.getCGI();\n  const unsigned NumDefs = DstI->Operands.NumDefs;\n  if (NumDefs == 0)\n    return InsertPt;\n\n  DstMIBuilder.addRenderer<CopyRenderer>(DstI->Operands[0].Name);\n\n  // Some instructions have multiple defs, but are missing a type entry\n  // (e.g. s_cc_out operands).\n  if (Dst->getExtTypes().size() < NumDefs)\n    return failedImport(\"unhandled discarded def\");\n\n  // Patterns only handle a single result, so any result after the first is an\n  // implicitly dead def.\n  for (unsigned I = 1; I < NumDefs; ++I) {\n    const TypeSetByHwMode &ExtTy = Dst->getExtType(I);\n    if (!ExtTy.isMachineValueType())\n      return failedImport(\"unsupported typeset\");\n\n    auto OpTy = MVTToLLT(ExtTy.getMachineValueType().SimpleTy);\n    if (!OpTy)\n      return failedImport(\"unsupported type\");\n\n    unsigned TempRegID = M.allocateTempRegID();\n    InsertPt =\n      M.insertAction<MakeTempRegisterAction>(InsertPt, *OpTy, TempRegID);\n    DstMIBuilder.addRenderer<TempRegRenderer>(TempRegID, true, nullptr, true);\n  }\n\n  return InsertPt;\n}\n\nExpected<action_iterator> GlobalISelEmitter::importExplicitUseRenderers(\n    action_iterator InsertPt, RuleMatcher &M, BuildMIAction &DstMIBuilder,\n    const llvm::TreePatternNode *Dst) {\n  const CodeGenInstruction *DstI = DstMIBuilder.getCGI();\n  CodeGenInstruction *OrigDstI = &Target.getInstruction(Dst->getOperator());\n\n  StringRef Name = OrigDstI->TheDef->getName();\n  unsigned ExpectedDstINumUses = Dst->getNumChildren();\n\n  // EXTRACT_SUBREG needs to use a subregister COPY.\n  if (Name == \"EXTRACT_SUBREG\") {\n    if (!Dst->getChild(1)->isLeaf())\n      return failedImport(\"EXTRACT_SUBREG child #1 is not a leaf\");\n    DefInit *SubRegInit = dyn_cast<DefInit>(Dst->getChild(1)->getLeafValue());\n    if (!SubRegInit)\n      return failedImport(\"EXTRACT_SUBREG child #1 is not a subreg index\");\n\n    CodeGenSubRegIndex *SubIdx = CGRegs.getSubRegIdx(SubRegInit->getDef());\n    TreePatternNode *ValChild = Dst->getChild(0);\n    if (!ValChild->isLeaf()) {\n      // We really have to handle the source instruction, and then insert a\n      // copy from the subregister.\n      auto ExtractSrcTy = getInstResultType(ValChild);\n      if (!ExtractSrcTy)\n        return ExtractSrcTy.takeError();\n\n      unsigned TempRegID = M.allocateTempRegID();\n      InsertPt = M.insertAction<MakeTempRegisterAction>(\n        InsertPt, *ExtractSrcTy, TempRegID);\n\n      auto InsertPtOrError = createAndImportSubInstructionRenderer(\n        ++InsertPt, M, ValChild, TempRegID);\n      if (auto Error = InsertPtOrError.takeError())\n        return std::move(Error);\n\n      DstMIBuilder.addRenderer<TempRegRenderer>(TempRegID, false, SubIdx);\n      return InsertPt;\n    }\n\n    // If this is a source operand, this is just a subregister copy.\n    Record *RCDef = getInitValueAsRegClass(ValChild->getLeafValue());\n    if (!RCDef)\n      return failedImport(\"EXTRACT_SUBREG child #0 could not \"\n                          \"be coerced to a register class\");\n\n    CodeGenRegisterClass *RC = CGRegs.getRegClass(RCDef);\n\n    const auto SrcRCDstRCPair =\n      RC->getMatchingSubClassWithSubRegs(CGRegs, SubIdx);\n    if (SrcRCDstRCPair.hasValue()) {\n      assert(SrcRCDstRCPair->second && \"Couldn't find a matching subclass\");\n      if (SrcRCDstRCPair->first != RC)\n        return failedImport(\"EXTRACT_SUBREG requires an additional COPY\");\n    }\n\n    DstMIBuilder.addRenderer<CopySubRegRenderer>(Dst->getChild(0)->getName(),\n                                                 SubIdx);\n    return InsertPt;\n  }\n\n  if (Name == \"REG_SEQUENCE\") {\n    if (!Dst->getChild(0)->isLeaf())\n      return failedImport(\"REG_SEQUENCE child #0 is not a leaf\");\n\n    Record *RCDef = getInitValueAsRegClass(Dst->getChild(0)->getLeafValue());\n    if (!RCDef)\n      return failedImport(\"REG_SEQUENCE child #0 could not \"\n                          \"be coerced to a register class\");\n\n    if ((ExpectedDstINumUses - 1) % 2 != 0)\n      return failedImport(\"Malformed REG_SEQUENCE\");\n\n    for (unsigned I = 1; I != ExpectedDstINumUses; I += 2) {\n      TreePatternNode *ValChild = Dst->getChild(I);\n      TreePatternNode *SubRegChild = Dst->getChild(I + 1);\n\n      if (DefInit *SubRegInit =\n              dyn_cast<DefInit>(SubRegChild->getLeafValue())) {\n        CodeGenSubRegIndex *SubIdx = CGRegs.getSubRegIdx(SubRegInit->getDef());\n\n        auto InsertPtOrError =\n            importExplicitUseRenderer(InsertPt, M, DstMIBuilder, ValChild);\n        if (auto Error = InsertPtOrError.takeError())\n          return std::move(Error);\n        InsertPt = InsertPtOrError.get();\n        DstMIBuilder.addRenderer<SubRegIndexRenderer>(SubIdx);\n      }\n    }\n\n    return InsertPt;\n  }\n\n  // Render the explicit uses.\n  unsigned DstINumUses = OrigDstI->Operands.size() - OrigDstI->Operands.NumDefs;\n  if (Name == \"COPY_TO_REGCLASS\") {\n    DstINumUses--; // Ignore the class constraint.\n    ExpectedDstINumUses--;\n  }\n\n  // NumResults - This is the number of results produced by the instruction in\n  // the \"outs\" list.\n  unsigned NumResults = OrigDstI->Operands.NumDefs;\n\n  // Number of operands we know the output instruction must have. If it is\n  // variadic, we could have more operands.\n  unsigned NumFixedOperands = DstI->Operands.size();\n\n  // Loop over all of the fixed operands of the instruction pattern, emitting\n  // code to fill them all in. The node 'N' usually has number children equal to\n  // the number of input operands of the instruction.  However, in cases where\n  // there are predicate operands for an instruction, we need to fill in the\n  // 'execute always' values. Match up the node operands to the instruction\n  // operands to do this.\n  unsigned Child = 0;\n\n  // Similarly to the code in TreePatternNode::ApplyTypeConstraints, count the\n  // number of operands at the end of the list which have default values.\n  // Those can come from the pattern if it provides enough arguments, or be\n  // filled in with the default if the pattern hasn't provided them. But any\n  // operand with a default value _before_ the last mandatory one will be\n  // filled in with their defaults unconditionally.\n  unsigned NonOverridableOperands = NumFixedOperands;\n  while (NonOverridableOperands > NumResults &&\n         CGP.operandHasDefault(DstI->Operands[NonOverridableOperands - 1].Rec))\n    --NonOverridableOperands;\n\n  unsigned NumDefaultOps = 0;\n  for (unsigned I = 0; I != DstINumUses; ++I) {\n    unsigned InstOpNo = DstI->Operands.NumDefs + I;\n\n    // Determine what to emit for this operand.\n    Record *OperandNode = DstI->Operands[InstOpNo].Rec;\n\n    // If the operand has default values, introduce them now.\n    if (CGP.operandHasDefault(OperandNode) &&\n        (InstOpNo < NonOverridableOperands || Child >= Dst->getNumChildren())) {\n      // This is a predicate or optional def operand which the pattern has not\n      // overridden, or which we aren't letting it override; emit the 'default\n      // ops' operands.\n\n      const CGIOperandList::OperandInfo &DstIOperand = DstI->Operands[InstOpNo];\n      DagInit *DefaultOps = DstIOperand.Rec->getValueAsDag(\"DefaultOps\");\n      if (auto Error = importDefaultOperandRenderers(\n            InsertPt, M, DstMIBuilder, DefaultOps))\n        return std::move(Error);\n      ++NumDefaultOps;\n      continue;\n    }\n\n    auto InsertPtOrError = importExplicitUseRenderer(InsertPt, M, DstMIBuilder,\n                                                     Dst->getChild(Child));\n    if (auto Error = InsertPtOrError.takeError())\n      return std::move(Error);\n    InsertPt = InsertPtOrError.get();\n    ++Child;\n  }\n\n  if (NumDefaultOps + ExpectedDstINumUses != DstINumUses)\n    return failedImport(\"Expected \" + llvm::to_string(DstINumUses) +\n                        \" used operands but found \" +\n                        llvm::to_string(ExpectedDstINumUses) +\n                        \" explicit ones and \" + llvm::to_string(NumDefaultOps) +\n                        \" default ones\");\n\n  return InsertPt;\n}\n\nError GlobalISelEmitter::importDefaultOperandRenderers(\n    action_iterator InsertPt, RuleMatcher &M, BuildMIAction &DstMIBuilder,\n    DagInit *DefaultOps) const {\n  for (const auto *DefaultOp : DefaultOps->getArgs()) {\n    Optional<LLTCodeGen> OpTyOrNone = None;\n\n    // Look through ValueType operators.\n    if (const DagInit *DefaultDagOp = dyn_cast<DagInit>(DefaultOp)) {\n      if (const DefInit *DefaultDagOperator =\n              dyn_cast<DefInit>(DefaultDagOp->getOperator())) {\n        if (DefaultDagOperator->getDef()->isSubClassOf(\"ValueType\")) {\n          OpTyOrNone = MVTToLLT(getValueType(\n                                  DefaultDagOperator->getDef()));\n          DefaultOp = DefaultDagOp->getArg(0);\n        }\n      }\n    }\n\n    if (const DefInit *DefaultDefOp = dyn_cast<DefInit>(DefaultOp)) {\n      auto Def = DefaultDefOp->getDef();\n      if (Def->getName() == \"undef_tied_input\") {\n        unsigned TempRegID = M.allocateTempRegID();\n        M.insertAction<MakeTempRegisterAction>(\n          InsertPt, OpTyOrNone.getValue(), TempRegID);\n        InsertPt = M.insertAction<BuildMIAction>(\n          InsertPt, M.allocateOutputInsnID(),\n          &Target.getInstruction(RK.getDef(\"IMPLICIT_DEF\")));\n        BuildMIAction &IDMIBuilder = *static_cast<BuildMIAction *>(\n          InsertPt->get());\n        IDMIBuilder.addRenderer<TempRegRenderer>(TempRegID);\n        DstMIBuilder.addRenderer<TempRegRenderer>(TempRegID);\n      } else {\n        DstMIBuilder.addRenderer<AddRegisterRenderer>(Target, Def);\n      }\n      continue;\n    }\n\n    if (const IntInit *DefaultIntOp = dyn_cast<IntInit>(DefaultOp)) {\n      DstMIBuilder.addRenderer<ImmRenderer>(DefaultIntOp->getValue());\n      continue;\n    }\n\n    return failedImport(\"Could not add default op\");\n  }\n\n  return Error::success();\n}\n\nError GlobalISelEmitter::importImplicitDefRenderers(\n    BuildMIAction &DstMIBuilder,\n    const std::vector<Record *> &ImplicitDefs) const {\n  if (!ImplicitDefs.empty())\n    return failedImport(\"Pattern defines a physical register\");\n  return Error::success();\n}\n\nOptional<const CodeGenRegisterClass *>\nGlobalISelEmitter::getRegClassFromLeaf(TreePatternNode *Leaf) {\n  assert(Leaf && \"Expected node?\");\n  assert(Leaf->isLeaf() && \"Expected leaf?\");\n  Record *RCRec = getInitValueAsRegClass(Leaf->getLeafValue());\n  if (!RCRec)\n    return None;\n  CodeGenRegisterClass *RC = CGRegs.getRegClass(RCRec);\n  if (!RC)\n    return None;\n  return RC;\n}\n\nOptional<const CodeGenRegisterClass *>\nGlobalISelEmitter::inferRegClassFromPattern(TreePatternNode *N) {\n  if (!N)\n    return None;\n\n  if (N->isLeaf())\n    return getRegClassFromLeaf(N);\n\n  // We don't have a leaf node, so we have to try and infer something. Check\n  // that we have an instruction that we an infer something from.\n\n  // Only handle things that produce a single type.\n  if (N->getNumTypes() != 1)\n    return None;\n  Record *OpRec = N->getOperator();\n\n  // We only want instructions.\n  if (!OpRec->isSubClassOf(\"Instruction\"))\n    return None;\n\n  // Don't want to try and infer things when there could potentially be more\n  // than one candidate register class.\n  auto &Inst = Target.getInstruction(OpRec);\n  if (Inst.Operands.NumDefs > 1)\n    return None;\n\n  // Handle any special-case instructions which we can safely infer register\n  // classes from.\n  StringRef InstName = Inst.TheDef->getName();\n  bool IsRegSequence = InstName == \"REG_SEQUENCE\";\n  if (IsRegSequence || InstName == \"COPY_TO_REGCLASS\") {\n    // If we have a COPY_TO_REGCLASS, then we need to handle it specially. It\n    // has the desired register class as the first child.\n    TreePatternNode *RCChild = N->getChild(IsRegSequence ? 0 : 1);\n    if (!RCChild->isLeaf())\n      return None;\n    return getRegClassFromLeaf(RCChild);\n  }\n  if (InstName == \"INSERT_SUBREG\") {\n    TreePatternNode *Child0 = N->getChild(0);\n    assert(Child0->getNumTypes() == 1 && \"Unexpected number of types!\");\n    const TypeSetByHwMode &VTy = Child0->getExtType(0);\n    return inferSuperRegisterClassForNode(VTy, Child0, N->getChild(2));\n  }\n  if (InstName == \"EXTRACT_SUBREG\") {\n    assert(N->getNumTypes() == 1 && \"Unexpected number of types!\");\n    const TypeSetByHwMode &VTy = N->getExtType(0);\n    return inferSuperRegisterClass(VTy, N->getChild(1));\n  }\n\n  // Handle destination record types that we can safely infer a register class\n  // from.\n  const auto &DstIOperand = Inst.Operands[0];\n  Record *DstIOpRec = DstIOperand.Rec;\n  if (DstIOpRec->isSubClassOf(\"RegisterOperand\")) {\n    DstIOpRec = DstIOpRec->getValueAsDef(\"RegClass\");\n    const CodeGenRegisterClass &RC = Target.getRegisterClass(DstIOpRec);\n    return &RC;\n  }\n\n  if (DstIOpRec->isSubClassOf(\"RegisterClass\")) {\n    const CodeGenRegisterClass &RC = Target.getRegisterClass(DstIOpRec);\n    return &RC;\n  }\n\n  return None;\n}\n\nOptional<const CodeGenRegisterClass *>\nGlobalISelEmitter::inferSuperRegisterClass(const TypeSetByHwMode &Ty,\n                                           TreePatternNode *SubRegIdxNode) {\n  assert(SubRegIdxNode && \"Expected subregister index node!\");\n  // We need a ValueTypeByHwMode for getSuperRegForSubReg.\n  if (!Ty.isValueTypeByHwMode(false))\n    return None;\n  if (!SubRegIdxNode->isLeaf())\n    return None;\n  DefInit *SubRegInit = dyn_cast<DefInit>(SubRegIdxNode->getLeafValue());\n  if (!SubRegInit)\n    return None;\n  CodeGenSubRegIndex *SubIdx = CGRegs.getSubRegIdx(SubRegInit->getDef());\n\n  // Use the information we found above to find a minimal register class which\n  // supports the subregister and type we want.\n  auto RC =\n      Target.getSuperRegForSubReg(Ty.getValueTypeByHwMode(), CGRegs, SubIdx,\n                                  /* MustBeAllocatable */ true);\n  if (!RC)\n    return None;\n  return *RC;\n}\n\nOptional<const CodeGenRegisterClass *>\nGlobalISelEmitter::inferSuperRegisterClassForNode(\n    const TypeSetByHwMode &Ty, TreePatternNode *SuperRegNode,\n    TreePatternNode *SubRegIdxNode) {\n  assert(SuperRegNode && \"Expected super register node!\");\n  // Check if we already have a defined register class for the super register\n  // node. If we do, then we should preserve that rather than inferring anything\n  // from the subregister index node. We can assume that whoever wrote the\n  // pattern in the first place made sure that the super register and\n  // subregister are compatible.\n  if (Optional<const CodeGenRegisterClass *> SuperRegisterClass =\n          inferRegClassFromPattern(SuperRegNode))\n    return *SuperRegisterClass;\n  return inferSuperRegisterClass(Ty, SubRegIdxNode);\n}\n\nOptional<CodeGenSubRegIndex *>\nGlobalISelEmitter::inferSubRegIndexForNode(TreePatternNode *SubRegIdxNode) {\n  if (!SubRegIdxNode->isLeaf())\n    return None;\n\n  DefInit *SubRegInit = dyn_cast<DefInit>(SubRegIdxNode->getLeafValue());\n  if (!SubRegInit)\n    return None;\n  return CGRegs.getSubRegIdx(SubRegInit->getDef());\n}\n\nExpected<RuleMatcher> GlobalISelEmitter::runOnPattern(const PatternToMatch &P) {\n  // Keep track of the matchers and actions to emit.\n  int Score = P.getPatternComplexity(CGP);\n  RuleMatcher M(P.getSrcRecord()->getLoc());\n  RuleMatcherScores[M.getRuleID()] = Score;\n  M.addAction<DebugCommentAction>(llvm::to_string(*P.getSrcPattern()) +\n                                  \"  =>  \" +\n                                  llvm::to_string(*P.getDstPattern()));\n\n  if (auto Error = importRulePredicates(M, P.getPredicates()))\n    return std::move(Error);\n\n  // Next, analyze the pattern operators.\n  TreePatternNode *Src = P.getSrcPattern();\n  TreePatternNode *Dst = P.getDstPattern();\n\n  // If the root of either pattern isn't a simple operator, ignore it.\n  if (auto Err = isTrivialOperatorNode(Dst))\n    return failedImport(\"Dst pattern root isn't a trivial operator (\" +\n                        toString(std::move(Err)) + \")\");\n  if (auto Err = isTrivialOperatorNode(Src))\n    return failedImport(\"Src pattern root isn't a trivial operator (\" +\n                        toString(std::move(Err)) + \")\");\n\n  // The different predicates and matchers created during\n  // addInstructionMatcher use the RuleMatcher M to set up their\n  // instruction ID (InsnVarID) that are going to be used when\n  // M is going to be emitted.\n  // However, the code doing the emission still relies on the IDs\n  // returned during that process by the RuleMatcher when issuing\n  // the recordInsn opcodes.\n  // Because of that:\n  // 1. The order in which we created the predicates\n  //    and such must be the same as the order in which we emit them,\n  //    and\n  // 2. We need to reset the generation of the IDs in M somewhere between\n  //    addInstructionMatcher and emit\n  //\n  // FIXME: Long term, we don't want to have to rely on this implicit\n  // naming being the same. One possible solution would be to have\n  // explicit operator for operation capture and reference those.\n  // The plus side is that it would expose opportunities to share\n  // the capture accross rules. The downside is that it would\n  // introduce a dependency between predicates (captures must happen\n  // before their first use.)\n  InstructionMatcher &InsnMatcherTemp = M.addInstructionMatcher(Src->getName());\n  unsigned TempOpIdx = 0;\n  auto InsnMatcherOrError =\n      createAndImportSelDAGMatcher(M, InsnMatcherTemp, Src, TempOpIdx);\n  if (auto Error = InsnMatcherOrError.takeError())\n    return std::move(Error);\n  InstructionMatcher &InsnMatcher = InsnMatcherOrError.get();\n\n  if (Dst->isLeaf()) {\n    Record *RCDef = getInitValueAsRegClass(Dst->getLeafValue());\n    if (RCDef) {\n      const CodeGenRegisterClass &RC = Target.getRegisterClass(RCDef);\n\n      // We need to replace the def and all its uses with the specified\n      // operand. However, we must also insert COPY's wherever needed.\n      // For now, emit a copy and let the register allocator clean up.\n      auto &DstI = Target.getInstruction(RK.getDef(\"COPY\"));\n      const auto &DstIOperand = DstI.Operands[0];\n\n      OperandMatcher &OM0 = InsnMatcher.getOperand(0);\n      OM0.setSymbolicName(DstIOperand.Name);\n      M.defineOperand(OM0.getSymbolicName(), OM0);\n      OM0.addPredicate<RegisterBankOperandMatcher>(RC);\n\n      auto &DstMIBuilder =\n          M.addAction<BuildMIAction>(M.allocateOutputInsnID(), &DstI);\n      DstMIBuilder.addRenderer<CopyRenderer>(DstIOperand.Name);\n      DstMIBuilder.addRenderer<CopyRenderer>(Dst->getName());\n      M.addAction<ConstrainOperandToRegClassAction>(0, 0, RC);\n\n      // We're done with this pattern!  It's eligible for GISel emission; return\n      // it.\n      ++NumPatternImported;\n      return std::move(M);\n    }\n\n    return failedImport(\"Dst pattern root isn't a known leaf\");\n  }\n\n  // Start with the defined operands (i.e., the results of the root operator).\n  Record *DstOp = Dst->getOperator();\n  if (!DstOp->isSubClassOf(\"Instruction\"))\n    return failedImport(\"Pattern operator isn't an instruction\");\n\n  auto &DstI = Target.getInstruction(DstOp);\n  StringRef DstIName = DstI.TheDef->getName();\n\n  if (DstI.Operands.NumDefs < Src->getExtTypes().size())\n    return failedImport(\"Src pattern result has more defs than dst MI (\" +\n                        to_string(Src->getExtTypes().size()) + \" def(s) vs \" +\n                        to_string(DstI.Operands.NumDefs) + \" def(s))\");\n\n  // The root of the match also has constraints on the register bank so that it\n  // matches the result instruction.\n  unsigned OpIdx = 0;\n  for (const TypeSetByHwMode &VTy : Src->getExtTypes()) {\n    (void)VTy;\n\n    const auto &DstIOperand = DstI.Operands[OpIdx];\n    Record *DstIOpRec = DstIOperand.Rec;\n    if (DstIName == \"COPY_TO_REGCLASS\") {\n      DstIOpRec = getInitValueAsRegClass(Dst->getChild(1)->getLeafValue());\n\n      if (DstIOpRec == nullptr)\n        return failedImport(\n            \"COPY_TO_REGCLASS operand #1 isn't a register class\");\n    } else if (DstIName == \"REG_SEQUENCE\") {\n      DstIOpRec = getInitValueAsRegClass(Dst->getChild(0)->getLeafValue());\n      if (DstIOpRec == nullptr)\n        return failedImport(\"REG_SEQUENCE operand #0 isn't a register class\");\n    } else if (DstIName == \"EXTRACT_SUBREG\") {\n      auto InferredClass = inferRegClassFromPattern(Dst->getChild(0));\n      if (!InferredClass)\n        return failedImport(\"Could not infer class for EXTRACT_SUBREG operand #0\");\n\n      // We can assume that a subregister is in the same bank as it's super\n      // register.\n      DstIOpRec = (*InferredClass)->getDef();\n    } else if (DstIName == \"INSERT_SUBREG\") {\n      auto MaybeSuperClass = inferSuperRegisterClassForNode(\n          VTy, Dst->getChild(0), Dst->getChild(2));\n      if (!MaybeSuperClass)\n        return failedImport(\n            \"Cannot infer register class for INSERT_SUBREG operand #0\");\n      // Move to the next pattern here, because the register class we found\n      // doesn't necessarily have a record associated with it. So, we can't\n      // set DstIOpRec using this.\n      OperandMatcher &OM = InsnMatcher.getOperand(OpIdx);\n      OM.setSymbolicName(DstIOperand.Name);\n      M.defineOperand(OM.getSymbolicName(), OM);\n      OM.addPredicate<RegisterBankOperandMatcher>(**MaybeSuperClass);\n      ++OpIdx;\n      continue;\n    } else if (DstIName == \"SUBREG_TO_REG\") {\n      auto MaybeRegClass = inferSuperRegisterClass(VTy, Dst->getChild(2));\n      if (!MaybeRegClass)\n        return failedImport(\n            \"Cannot infer register class for SUBREG_TO_REG operand #0\");\n      OperandMatcher &OM = InsnMatcher.getOperand(OpIdx);\n      OM.setSymbolicName(DstIOperand.Name);\n      M.defineOperand(OM.getSymbolicName(), OM);\n      OM.addPredicate<RegisterBankOperandMatcher>(**MaybeRegClass);\n      ++OpIdx;\n      continue;\n    } else if (DstIOpRec->isSubClassOf(\"RegisterOperand\"))\n      DstIOpRec = DstIOpRec->getValueAsDef(\"RegClass\");\n    else if (!DstIOpRec->isSubClassOf(\"RegisterClass\"))\n      return failedImport(\"Dst MI def isn't a register class\" +\n                          to_string(*Dst));\n\n    OperandMatcher &OM = InsnMatcher.getOperand(OpIdx);\n    OM.setSymbolicName(DstIOperand.Name);\n    M.defineOperand(OM.getSymbolicName(), OM);\n    OM.addPredicate<RegisterBankOperandMatcher>(\n        Target.getRegisterClass(DstIOpRec));\n    ++OpIdx;\n  }\n\n  auto DstMIBuilderOrError =\n      createAndImportInstructionRenderer(M, InsnMatcher, Src, Dst);\n  if (auto Error = DstMIBuilderOrError.takeError())\n    return std::move(Error);\n  BuildMIAction &DstMIBuilder = DstMIBuilderOrError.get();\n\n  // Render the implicit defs.\n  // These are only added to the root of the result.\n  if (auto Error = importImplicitDefRenderers(DstMIBuilder, P.getDstRegs()))\n    return std::move(Error);\n\n  DstMIBuilder.chooseInsnToMutate(M);\n\n  // Constrain the registers to classes. This is normally derived from the\n  // emitted instruction but a few instructions require special handling.\n  if (DstIName == \"COPY_TO_REGCLASS\") {\n    // COPY_TO_REGCLASS does not provide operand constraints itself but the\n    // result is constrained to the class given by the second child.\n    Record *DstIOpRec =\n        getInitValueAsRegClass(Dst->getChild(1)->getLeafValue());\n\n    if (DstIOpRec == nullptr)\n      return failedImport(\"COPY_TO_REGCLASS operand #1 isn't a register class\");\n\n    M.addAction<ConstrainOperandToRegClassAction>(\n        0, 0, Target.getRegisterClass(DstIOpRec));\n\n    // We're done with this pattern!  It's eligible for GISel emission; return\n    // it.\n    ++NumPatternImported;\n    return std::move(M);\n  }\n\n  if (DstIName == \"EXTRACT_SUBREG\") {\n    auto SuperClass = inferRegClassFromPattern(Dst->getChild(0));\n    if (!SuperClass)\n      return failedImport(\n        \"Cannot infer register class from EXTRACT_SUBREG operand #0\");\n\n    auto SubIdx = inferSubRegIndexForNode(Dst->getChild(1));\n    if (!SubIdx)\n      return failedImport(\"EXTRACT_SUBREG child #1 is not a subreg index\");\n\n    // It would be nice to leave this constraint implicit but we're required\n    // to pick a register class so constrain the result to a register class\n    // that can hold the correct MVT.\n    //\n    // FIXME: This may introduce an extra copy if the chosen class doesn't\n    //        actually contain the subregisters.\n    assert(Src->getExtTypes().size() == 1 &&\n             \"Expected Src of EXTRACT_SUBREG to have one result type\");\n\n    const auto SrcRCDstRCPair =\n      (*SuperClass)->getMatchingSubClassWithSubRegs(CGRegs, *SubIdx);\n    if (!SrcRCDstRCPair) {\n      return failedImport(\"subreg index is incompatible \"\n                          \"with inferred reg class\");\n    }\n\n    assert(SrcRCDstRCPair->second && \"Couldn't find a matching subclass\");\n    M.addAction<ConstrainOperandToRegClassAction>(0, 0, *SrcRCDstRCPair->second);\n    M.addAction<ConstrainOperandToRegClassAction>(0, 1, *SrcRCDstRCPair->first);\n\n    // We're done with this pattern!  It's eligible for GISel emission; return\n    // it.\n    ++NumPatternImported;\n    return std::move(M);\n  }\n\n  if (DstIName == \"INSERT_SUBREG\") {\n    assert(Src->getExtTypes().size() == 1 &&\n           \"Expected Src of INSERT_SUBREG to have one result type\");\n    // We need to constrain the destination, a super regsister source, and a\n    // subregister source.\n    auto SubClass = inferRegClassFromPattern(Dst->getChild(1));\n    if (!SubClass)\n      return failedImport(\n          \"Cannot infer register class from INSERT_SUBREG operand #1\");\n    auto SuperClass = inferSuperRegisterClassForNode(\n        Src->getExtType(0), Dst->getChild(0), Dst->getChild(2));\n    if (!SuperClass)\n      return failedImport(\n          \"Cannot infer register class for INSERT_SUBREG operand #0\");\n    M.addAction<ConstrainOperandToRegClassAction>(0, 0, **SuperClass);\n    M.addAction<ConstrainOperandToRegClassAction>(0, 1, **SuperClass);\n    M.addAction<ConstrainOperandToRegClassAction>(0, 2, **SubClass);\n    ++NumPatternImported;\n    return std::move(M);\n  }\n\n  if (DstIName == \"SUBREG_TO_REG\") {\n    // We need to constrain the destination and subregister source.\n    assert(Src->getExtTypes().size() == 1 &&\n           \"Expected Src of SUBREG_TO_REG to have one result type\");\n\n    // Attempt to infer the subregister source from the first child. If it has\n    // an explicitly given register class, we'll use that. Otherwise, we will\n    // fail.\n    auto SubClass = inferRegClassFromPattern(Dst->getChild(1));\n    if (!SubClass)\n      return failedImport(\n          \"Cannot infer register class from SUBREG_TO_REG child #1\");\n    // We don't have a child to look at that might have a super register node.\n    auto SuperClass =\n        inferSuperRegisterClass(Src->getExtType(0), Dst->getChild(2));\n    if (!SuperClass)\n      return failedImport(\n          \"Cannot infer register class for SUBREG_TO_REG operand #0\");\n    M.addAction<ConstrainOperandToRegClassAction>(0, 0, **SuperClass);\n    M.addAction<ConstrainOperandToRegClassAction>(0, 2, **SubClass);\n    ++NumPatternImported;\n    return std::move(M);\n  }\n\n  if (DstIName == \"REG_SEQUENCE\") {\n    auto SuperClass = inferRegClassFromPattern(Dst->getChild(0));\n\n    M.addAction<ConstrainOperandToRegClassAction>(0, 0, **SuperClass);\n\n    unsigned Num = Dst->getNumChildren();\n    for (unsigned I = 1; I != Num; I += 2) {\n      TreePatternNode *SubRegChild = Dst->getChild(I + 1);\n\n      auto SubIdx = inferSubRegIndexForNode(SubRegChild);\n      if (!SubIdx)\n        return failedImport(\"REG_SEQUENCE child is not a subreg index\");\n\n      const auto SrcRCDstRCPair =\n        (*SuperClass)->getMatchingSubClassWithSubRegs(CGRegs, *SubIdx);\n\n      M.addAction<ConstrainOperandToRegClassAction>(0, I,\n                                                    *SrcRCDstRCPair->second);\n    }\n\n    ++NumPatternImported;\n    return std::move(M);\n  }\n\n  M.addAction<ConstrainOperandsToDefinitionAction>(0);\n\n  // We're done with this pattern!  It's eligible for GISel emission; return it.\n  ++NumPatternImported;\n  return std::move(M);\n}\n\n// Emit imm predicate table and an enum to reference them with.\n// The 'Predicate_' part of the name is redundant but eliminating it is more\n// trouble than it's worth.\nvoid GlobalISelEmitter::emitCxxPredicateFns(\n    raw_ostream &OS, StringRef CodeFieldName, StringRef TypeIdentifier,\n    StringRef ArgType, StringRef ArgName, StringRef AdditionalArgs,\n    StringRef AdditionalDeclarations,\n    std::function<bool(const Record *R)> Filter) {\n  std::vector<const Record *> MatchedRecords;\n  const auto &Defs = RK.getAllDerivedDefinitions(\"PatFrag\");\n  std::copy_if(Defs.begin(), Defs.end(), std::back_inserter(MatchedRecords),\n               [&](Record *Record) {\n                 return !Record->getValueAsString(CodeFieldName).empty() &&\n                        Filter(Record);\n               });\n\n  if (!MatchedRecords.empty()) {\n    OS << \"// PatFrag predicates.\\n\"\n       << \"enum {\\n\";\n    std::string EnumeratorSeparator =\n        (\" = GIPFP_\" + TypeIdentifier + \"_Invalid + 1,\\n\").str();\n    for (const auto *Record : MatchedRecords) {\n      OS << \"  GIPFP_\" << TypeIdentifier << \"_Predicate_\" << Record->getName()\n         << EnumeratorSeparator;\n      EnumeratorSeparator = \",\\n\";\n    }\n    OS << \"};\\n\";\n  }\n\n  OS << \"bool \" << Target.getName() << \"InstructionSelector::test\" << ArgName\n     << \"Predicate_\" << TypeIdentifier << \"(unsigned PredicateID, \" << ArgType << \" \"\n     << ArgName << AdditionalArgs <<\") const {\\n\"\n     << AdditionalDeclarations;\n  if (!AdditionalDeclarations.empty())\n    OS << \"\\n\";\n  if (!MatchedRecords.empty())\n    OS << \"  switch (PredicateID) {\\n\";\n  for (const auto *Record : MatchedRecords) {\n    OS << \"  case GIPFP_\" << TypeIdentifier << \"_Predicate_\"\n       << Record->getName() << \": {\\n\"\n       << \"    \" << Record->getValueAsString(CodeFieldName) << \"\\n\"\n       << \"    llvm_unreachable(\\\"\" << CodeFieldName\n       << \" should have returned\\\");\\n\"\n       << \"    return false;\\n\"\n       << \"  }\\n\";\n  }\n  if (!MatchedRecords.empty())\n    OS << \"  }\\n\";\n  OS << \"  llvm_unreachable(\\\"Unknown predicate\\\");\\n\"\n     << \"  return false;\\n\"\n     << \"}\\n\";\n}\n\nvoid GlobalISelEmitter::emitImmPredicateFns(\n    raw_ostream &OS, StringRef TypeIdentifier, StringRef ArgType,\n    std::function<bool(const Record *R)> Filter) {\n  return emitCxxPredicateFns(OS, \"ImmediateCode\", TypeIdentifier, ArgType,\n                             \"Imm\", \"\", \"\", Filter);\n}\n\nvoid GlobalISelEmitter::emitMIPredicateFns(raw_ostream &OS) {\n  return emitCxxPredicateFns(\n      OS, \"GISelPredicateCode\", \"MI\", \"const MachineInstr &\", \"MI\",\n      \", const std::array<const MachineOperand *, 3> &Operands\",\n      \"  const MachineFunction &MF = *MI.getParent()->getParent();\\n\"\n      \"  const MachineRegisterInfo &MRI = MF.getRegInfo();\\n\"\n      \"  (void)MRI;\",\n      [](const Record *R) { return true; });\n}\n\ntemplate <class GroupT>\nstd::vector<Matcher *> GlobalISelEmitter::optimizeRules(\n    ArrayRef<Matcher *> Rules,\n    std::vector<std::unique_ptr<Matcher>> &MatcherStorage) {\n\n  std::vector<Matcher *> OptRules;\n  std::unique_ptr<GroupT> CurrentGroup = std::make_unique<GroupT>();\n  assert(CurrentGroup->empty() && \"Newly created group isn't empty!\");\n  unsigned NumGroups = 0;\n\n  auto ProcessCurrentGroup = [&]() {\n    if (CurrentGroup->empty())\n      // An empty group is good to be reused:\n      return;\n\n    // If the group isn't large enough to provide any benefit, move all the\n    // added rules out of it and make sure to re-create the group to properly\n    // re-initialize it:\n    if (CurrentGroup->size() < 2)\n      append_range(OptRules, CurrentGroup->matchers());\n    else {\n      CurrentGroup->finalize();\n      OptRules.push_back(CurrentGroup.get());\n      MatcherStorage.emplace_back(std::move(CurrentGroup));\n      ++NumGroups;\n    }\n    CurrentGroup = std::make_unique<GroupT>();\n  };\n  for (Matcher *Rule : Rules) {\n    // Greedily add as many matchers as possible to the current group:\n    if (CurrentGroup->addMatcher(*Rule))\n      continue;\n\n    ProcessCurrentGroup();\n    assert(CurrentGroup->empty() && \"A group wasn't properly re-initialized\");\n\n    // Try to add the pending matcher to a newly created empty group:\n    if (!CurrentGroup->addMatcher(*Rule))\n      // If we couldn't add the matcher to an empty group, that group type\n      // doesn't support that kind of matchers at all, so just skip it:\n      OptRules.push_back(Rule);\n  }\n  ProcessCurrentGroup();\n\n  LLVM_DEBUG(dbgs() << \"NumGroups: \" << NumGroups << \"\\n\");\n  assert(CurrentGroup->empty() && \"The last group wasn't properly processed\");\n  return OptRules;\n}\n\nMatchTable\nGlobalISelEmitter::buildMatchTable(MutableArrayRef<RuleMatcher> Rules,\n                                   bool Optimize, bool WithCoverage) {\n  std::vector<Matcher *> InputRules;\n  for (Matcher &Rule : Rules)\n    InputRules.push_back(&Rule);\n\n  if (!Optimize)\n    return MatchTable::buildTable(InputRules, WithCoverage);\n\n  unsigned CurrentOrdering = 0;\n  StringMap<unsigned> OpcodeOrder;\n  for (RuleMatcher &Rule : Rules) {\n    const StringRef Opcode = Rule.getOpcode();\n    assert(!Opcode.empty() && \"Didn't expect an undefined opcode\");\n    if (OpcodeOrder.count(Opcode) == 0)\n      OpcodeOrder[Opcode] = CurrentOrdering++;\n  }\n\n  llvm::stable_sort(InputRules, [&OpcodeOrder](const Matcher *A,\n                                               const Matcher *B) {\n    auto *L = static_cast<const RuleMatcher *>(A);\n    auto *R = static_cast<const RuleMatcher *>(B);\n    return std::make_tuple(OpcodeOrder[L->getOpcode()], L->getNumOperands()) <\n           std::make_tuple(OpcodeOrder[R->getOpcode()], R->getNumOperands());\n  });\n\n  for (Matcher *Rule : InputRules)\n    Rule->optimize();\n\n  std::vector<std::unique_ptr<Matcher>> MatcherStorage;\n  std::vector<Matcher *> OptRules =\n      optimizeRules<GroupMatcher>(InputRules, MatcherStorage);\n\n  for (Matcher *Rule : OptRules)\n    Rule->optimize();\n\n  OptRules = optimizeRules<SwitchMatcher>(OptRules, MatcherStorage);\n\n  return MatchTable::buildTable(OptRules, WithCoverage);\n}\n\nvoid GroupMatcher::optimize() {\n  // Make sure we only sort by a specific predicate within a range of rules that\n  // all have that predicate checked against a specific value (not a wildcard):\n  auto F = Matchers.begin();\n  auto T = F;\n  auto E = Matchers.end();\n  while (T != E) {\n    while (T != E) {\n      auto *R = static_cast<RuleMatcher *>(*T);\n      if (!R->getFirstConditionAsRootType().get().isValid())\n        break;\n      ++T;\n    }\n    std::stable_sort(F, T, [](Matcher *A, Matcher *B) {\n      auto *L = static_cast<RuleMatcher *>(A);\n      auto *R = static_cast<RuleMatcher *>(B);\n      return L->getFirstConditionAsRootType() <\n             R->getFirstConditionAsRootType();\n    });\n    if (T != E)\n      F = ++T;\n  }\n  GlobalISelEmitter::optimizeRules<GroupMatcher>(Matchers, MatcherStorage)\n      .swap(Matchers);\n  GlobalISelEmitter::optimizeRules<SwitchMatcher>(Matchers, MatcherStorage)\n      .swap(Matchers);\n}\n\nvoid GlobalISelEmitter::run(raw_ostream &OS) {\n  if (!UseCoverageFile.empty()) {\n    RuleCoverage = CodeGenCoverage();\n    auto RuleCoverageBufOrErr = MemoryBuffer::getFile(UseCoverageFile);\n    if (!RuleCoverageBufOrErr) {\n      PrintWarning(SMLoc(), \"Missing rule coverage data\");\n      RuleCoverage = None;\n    } else {\n      if (!RuleCoverage->parse(*RuleCoverageBufOrErr.get(), Target.getName())) {\n        PrintWarning(SMLoc(), \"Ignoring invalid or missing rule coverage data\");\n        RuleCoverage = None;\n      }\n    }\n  }\n\n  // Track the run-time opcode values\n  gatherOpcodeValues();\n  // Track the run-time LLT ID values\n  gatherTypeIDValues();\n\n  // Track the GINodeEquiv definitions.\n  gatherNodeEquivs();\n\n  emitSourceFileHeader((\"Global Instruction Selector for the \" +\n                       Target.getName() + \" target\").str(), OS);\n  std::vector<RuleMatcher> Rules;\n  // Look through the SelectionDAG patterns we found, possibly emitting some.\n  for (const PatternToMatch &Pat : CGP.ptms()) {\n    ++NumPatternTotal;\n\n    auto MatcherOrErr = runOnPattern(Pat);\n\n    // The pattern analysis can fail, indicating an unsupported pattern.\n    // Report that if we've been asked to do so.\n    if (auto Err = MatcherOrErr.takeError()) {\n      if (WarnOnSkippedPatterns) {\n        PrintWarning(Pat.getSrcRecord()->getLoc(),\n                     \"Skipped pattern: \" + toString(std::move(Err)));\n      } else {\n        consumeError(std::move(Err));\n      }\n      ++NumPatternImportsSkipped;\n      continue;\n    }\n\n    if (RuleCoverage) {\n      if (RuleCoverage->isCovered(MatcherOrErr->getRuleID()))\n        ++NumPatternsTested;\n      else\n        PrintWarning(Pat.getSrcRecord()->getLoc(),\n                     \"Pattern is not covered by a test\");\n    }\n    Rules.push_back(std::move(MatcherOrErr.get()));\n  }\n\n  // Comparison function to order records by name.\n  auto orderByName = [](const Record *A, const Record *B) {\n    return A->getName() < B->getName();\n  };\n\n  std::vector<Record *> ComplexPredicates =\n      RK.getAllDerivedDefinitions(\"GIComplexOperandMatcher\");\n  llvm::sort(ComplexPredicates, orderByName);\n\n  std::vector<StringRef> CustomRendererFns;\n  transform(RK.getAllDerivedDefinitions(\"GICustomOperandRenderer\"),\n            std::back_inserter(CustomRendererFns), [](const auto &Record) {\n              return Record->getValueAsString(\"RendererFn\");\n            });\n  // Sort and remove duplicates to get a list of unique renderer functions, in\n  // case some were mentioned more than once.\n  llvm::sort(CustomRendererFns);\n  CustomRendererFns.erase(\n      std::unique(CustomRendererFns.begin(), CustomRendererFns.end()),\n      CustomRendererFns.end());\n\n  unsigned MaxTemporaries = 0;\n  for (const auto &Rule : Rules)\n    MaxTemporaries = std::max(MaxTemporaries, Rule.countRendererFns());\n\n  OS << \"#ifdef GET_GLOBALISEL_PREDICATE_BITSET\\n\"\n     << \"const unsigned MAX_SUBTARGET_PREDICATES = \" << SubtargetFeatures.size()\n     << \";\\n\"\n     << \"using PredicateBitset = \"\n        \"llvm::PredicateBitsetImpl<MAX_SUBTARGET_PREDICATES>;\\n\"\n     << \"#endif // ifdef GET_GLOBALISEL_PREDICATE_BITSET\\n\\n\";\n\n  OS << \"#ifdef GET_GLOBALISEL_TEMPORARIES_DECL\\n\"\n     << \"  mutable MatcherState State;\\n\"\n     << \"  typedef \"\n        \"ComplexRendererFns(\"\n     << Target.getName()\n     << \"InstructionSelector::*ComplexMatcherMemFn)(MachineOperand &) const;\\n\"\n\n     << \"  typedef void(\" << Target.getName()\n     << \"InstructionSelector::*CustomRendererFn)(MachineInstrBuilder &, const \"\n        \"MachineInstr &, int) \"\n        \"const;\\n\"\n     << \"  const ISelInfoTy<PredicateBitset, ComplexMatcherMemFn, \"\n        \"CustomRendererFn> \"\n        \"ISelInfo;\\n\";\n  OS << \"  static \" << Target.getName()\n     << \"InstructionSelector::ComplexMatcherMemFn ComplexPredicateFns[];\\n\"\n     << \"  static \" << Target.getName()\n     << \"InstructionSelector::CustomRendererFn CustomRenderers[];\\n\"\n     << \"  bool testImmPredicate_I64(unsigned PredicateID, int64_t Imm) const \"\n        \"override;\\n\"\n     << \"  bool testImmPredicate_APInt(unsigned PredicateID, const APInt &Imm) \"\n        \"const override;\\n\"\n     << \"  bool testImmPredicate_APFloat(unsigned PredicateID, const APFloat \"\n        \"&Imm) const override;\\n\"\n     << \"  const int64_t *getMatchTable() const override;\\n\"\n     << \"  bool testMIPredicate_MI(unsigned PredicateID, const MachineInstr &MI\"\n        \", const std::array<const MachineOperand *, 3> &Operands) \"\n        \"const override;\\n\"\n     << \"#endif // ifdef GET_GLOBALISEL_TEMPORARIES_DECL\\n\\n\";\n\n  OS << \"#ifdef GET_GLOBALISEL_TEMPORARIES_INIT\\n\"\n     << \", State(\" << MaxTemporaries << \"),\\n\"\n     << \"ISelInfo(TypeObjects, NumTypeObjects, FeatureBitsets\"\n     << \", ComplexPredicateFns, CustomRenderers)\\n\"\n     << \"#endif // ifdef GET_GLOBALISEL_TEMPORARIES_INIT\\n\\n\";\n\n  OS << \"#ifdef GET_GLOBALISEL_IMPL\\n\";\n  SubtargetFeatureInfo::emitSubtargetFeatureBitEnumeration(SubtargetFeatures,\n                                                           OS);\n\n  // Separate subtarget features by how often they must be recomputed.\n  SubtargetFeatureInfoMap ModuleFeatures;\n  std::copy_if(SubtargetFeatures.begin(), SubtargetFeatures.end(),\n               std::inserter(ModuleFeatures, ModuleFeatures.end()),\n               [](const SubtargetFeatureInfoMap::value_type &X) {\n                 return !X.second.mustRecomputePerFunction();\n               });\n  SubtargetFeatureInfoMap FunctionFeatures;\n  std::copy_if(SubtargetFeatures.begin(), SubtargetFeatures.end(),\n               std::inserter(FunctionFeatures, FunctionFeatures.end()),\n               [](const SubtargetFeatureInfoMap::value_type &X) {\n                 return X.second.mustRecomputePerFunction();\n               });\n\n  SubtargetFeatureInfo::emitComputeAvailableFeatures(\n    Target.getName(), \"InstructionSelector\", \"computeAvailableModuleFeatures\",\n      ModuleFeatures, OS);\n\n\n  OS << \"void \" << Target.getName() << \"InstructionSelector\"\n    \"::setupGeneratedPerFunctionState(MachineFunction &MF) {\\n\"\n    \"  AvailableFunctionFeatures = computeAvailableFunctionFeatures(\"\n    \"(const \" << Target.getName() << \"Subtarget *)&MF.getSubtarget(), &MF);\\n\"\n    \"}\\n\";\n\n  if (Target.getName() == \"X86\" || Target.getName() == \"AArch64\") {\n    // TODO: Implement PGSO.\n    OS << \"static bool shouldOptForSize(const MachineFunction *MF) {\\n\";\n    OS << \"    return MF->getFunction().hasOptSize();\\n\";\n    OS << \"}\\n\\n\";\n  }\n\n  SubtargetFeatureInfo::emitComputeAvailableFeatures(\n      Target.getName(), \"InstructionSelector\",\n      \"computeAvailableFunctionFeatures\", FunctionFeatures, OS,\n      \"const MachineFunction *MF\");\n\n  // Emit a table containing the LLT objects needed by the matcher and an enum\n  // for the matcher to reference them with.\n  std::vector<LLTCodeGen> TypeObjects;\n  append_range(TypeObjects, KnownTypes);\n  llvm::sort(TypeObjects);\n  OS << \"// LLT Objects.\\n\"\n     << \"enum {\\n\";\n  for (const auto &TypeObject : TypeObjects) {\n    OS << \"  \";\n    TypeObject.emitCxxEnumValue(OS);\n    OS << \",\\n\";\n  }\n  OS << \"};\\n\";\n  OS << \"const static size_t NumTypeObjects = \" << TypeObjects.size() << \";\\n\"\n     << \"const static LLT TypeObjects[] = {\\n\";\n  for (const auto &TypeObject : TypeObjects) {\n    OS << \"  \";\n    TypeObject.emitCxxConstructorCall(OS);\n    OS << \",\\n\";\n  }\n  OS << \"};\\n\\n\";\n\n  // Emit a table containing the PredicateBitsets objects needed by the matcher\n  // and an enum for the matcher to reference them with.\n  std::vector<std::vector<Record *>> FeatureBitsets;\n  for (auto &Rule : Rules)\n    FeatureBitsets.push_back(Rule.getRequiredFeatures());\n  llvm::sort(FeatureBitsets, [&](const std::vector<Record *> &A,\n                                 const std::vector<Record *> &B) {\n    if (A.size() < B.size())\n      return true;\n    if (A.size() > B.size())\n      return false;\n    for (auto Pair : zip(A, B)) {\n      if (std::get<0>(Pair)->getName() < std::get<1>(Pair)->getName())\n        return true;\n      if (std::get<0>(Pair)->getName() > std::get<1>(Pair)->getName())\n        return false;\n    }\n    return false;\n  });\n  FeatureBitsets.erase(\n      std::unique(FeatureBitsets.begin(), FeatureBitsets.end()),\n      FeatureBitsets.end());\n  OS << \"// Feature bitsets.\\n\"\n     << \"enum {\\n\"\n     << \"  GIFBS_Invalid,\\n\";\n  for (const auto &FeatureBitset : FeatureBitsets) {\n    if (FeatureBitset.empty())\n      continue;\n    OS << \"  \" << getNameForFeatureBitset(FeatureBitset) << \",\\n\";\n  }\n  OS << \"};\\n\"\n     << \"const static PredicateBitset FeatureBitsets[] {\\n\"\n     << \"  {}, // GIFBS_Invalid\\n\";\n  for (const auto &FeatureBitset : FeatureBitsets) {\n    if (FeatureBitset.empty())\n      continue;\n    OS << \"  {\";\n    for (const auto &Feature : FeatureBitset) {\n      const auto &I = SubtargetFeatures.find(Feature);\n      assert(I != SubtargetFeatures.end() && \"Didn't import predicate?\");\n      OS << I->second.getEnumBitName() << \", \";\n    }\n    OS << \"},\\n\";\n  }\n  OS << \"};\\n\\n\";\n\n  // Emit complex predicate table and an enum to reference them with.\n  OS << \"// ComplexPattern predicates.\\n\"\n     << \"enum {\\n\"\n     << \"  GICP_Invalid,\\n\";\n  for (const auto &Record : ComplexPredicates)\n    OS << \"  GICP_\" << Record->getName() << \",\\n\";\n  OS << \"};\\n\"\n     << \"// See constructor for table contents\\n\\n\";\n\n  emitImmPredicateFns(OS, \"I64\", \"int64_t\", [](const Record *R) {\n    bool Unset;\n    return !R->getValueAsBitOrUnset(\"IsAPFloat\", Unset) &&\n           !R->getValueAsBit(\"IsAPInt\");\n  });\n  emitImmPredicateFns(OS, \"APFloat\", \"const APFloat &\", [](const Record *R) {\n    bool Unset;\n    return R->getValueAsBitOrUnset(\"IsAPFloat\", Unset);\n  });\n  emitImmPredicateFns(OS, \"APInt\", \"const APInt &\", [](const Record *R) {\n    return R->getValueAsBit(\"IsAPInt\");\n  });\n  emitMIPredicateFns(OS);\n  OS << \"\\n\";\n\n  OS << Target.getName() << \"InstructionSelector::ComplexMatcherMemFn\\n\"\n     << Target.getName() << \"InstructionSelector::ComplexPredicateFns[] = {\\n\"\n     << \"  nullptr, // GICP_Invalid\\n\";\n  for (const auto &Record : ComplexPredicates)\n    OS << \"  &\" << Target.getName()\n       << \"InstructionSelector::\" << Record->getValueAsString(\"MatcherFn\")\n       << \", // \" << Record->getName() << \"\\n\";\n  OS << \"};\\n\\n\";\n\n  OS << \"// Custom renderers.\\n\"\n     << \"enum {\\n\"\n     << \"  GICR_Invalid,\\n\";\n  for (const auto &Fn : CustomRendererFns)\n    OS << \"  GICR_\" << Fn << \",\\n\";\n  OS << \"};\\n\";\n\n  OS << Target.getName() << \"InstructionSelector::CustomRendererFn\\n\"\n     << Target.getName() << \"InstructionSelector::CustomRenderers[] = {\\n\"\n     << \"  nullptr, // GICR_Invalid\\n\";\n  for (const auto &Fn : CustomRendererFns)\n    OS << \"  &\" << Target.getName() << \"InstructionSelector::\" << Fn << \",\\n\";\n  OS << \"};\\n\\n\";\n\n  llvm::stable_sort(Rules, [&](const RuleMatcher &A, const RuleMatcher &B) {\n    int ScoreA = RuleMatcherScores[A.getRuleID()];\n    int ScoreB = RuleMatcherScores[B.getRuleID()];\n    if (ScoreA > ScoreB)\n      return true;\n    if (ScoreB > ScoreA)\n      return false;\n    if (A.isHigherPriorityThan(B)) {\n      assert(!B.isHigherPriorityThan(A) && \"Cannot be more important \"\n                                           \"and less important at \"\n                                           \"the same time\");\n      return true;\n    }\n    return false;\n  });\n\n  OS << \"bool \" << Target.getName()\n     << \"InstructionSelector::selectImpl(MachineInstr &I, CodeGenCoverage \"\n        \"&CoverageInfo) const {\\n\"\n     << \"  MachineFunction &MF = *I.getParent()->getParent();\\n\"\n     << \"  MachineRegisterInfo &MRI = MF.getRegInfo();\\n\"\n     << \"  const PredicateBitset AvailableFeatures = getAvailableFeatures();\\n\"\n     << \"  NewMIVector OutMIs;\\n\"\n     << \"  State.MIs.clear();\\n\"\n     << \"  State.MIs.push_back(&I);\\n\\n\"\n     << \"  if (executeMatchTable(*this, OutMIs, State, ISelInfo\"\n     << \", getMatchTable(), TII, MRI, TRI, RBI, AvailableFeatures\"\n     << \", CoverageInfo)) {\\n\"\n     << \"    return true;\\n\"\n     << \"  }\\n\\n\"\n     << \"  return false;\\n\"\n     << \"}\\n\\n\";\n\n  const MatchTable Table =\n      buildMatchTable(Rules, OptimizeMatchTable, GenerateCoverage);\n  OS << \"const int64_t *\" << Target.getName()\n     << \"InstructionSelector::getMatchTable() const {\\n\";\n  Table.emitDeclaration(OS);\n  OS << \"  return \";\n  Table.emitUse(OS);\n  OS << \";\\n}\\n\";\n  OS << \"#endif // ifdef GET_GLOBALISEL_IMPL\\n\";\n\n  OS << \"#ifdef GET_GLOBALISEL_PREDICATES_DECL\\n\"\n     << \"PredicateBitset AvailableModuleFeatures;\\n\"\n     << \"mutable PredicateBitset AvailableFunctionFeatures;\\n\"\n     << \"PredicateBitset getAvailableFeatures() const {\\n\"\n     << \"  return AvailableModuleFeatures | AvailableFunctionFeatures;\\n\"\n     << \"}\\n\"\n     << \"PredicateBitset\\n\"\n     << \"computeAvailableModuleFeatures(const \" << Target.getName()\n     << \"Subtarget *Subtarget) const;\\n\"\n     << \"PredicateBitset\\n\"\n     << \"computeAvailableFunctionFeatures(const \" << Target.getName()\n     << \"Subtarget *Subtarget,\\n\"\n     << \"                                 const MachineFunction *MF) const;\\n\"\n     << \"void setupGeneratedPerFunctionState(MachineFunction &MF) override;\\n\"\n     << \"#endif // ifdef GET_GLOBALISEL_PREDICATES_DECL\\n\";\n\n  OS << \"#ifdef GET_GLOBALISEL_PREDICATES_INIT\\n\"\n     << \"AvailableModuleFeatures(computeAvailableModuleFeatures(&STI)),\\n\"\n     << \"AvailableFunctionFeatures()\\n\"\n     << \"#endif // ifdef GET_GLOBALISEL_PREDICATES_INIT\\n\";\n}\n\nvoid GlobalISelEmitter::declareSubtargetFeature(Record *Predicate) {\n  if (SubtargetFeatures.count(Predicate) == 0)\n    SubtargetFeatures.emplace(\n        Predicate, SubtargetFeatureInfo(Predicate, SubtargetFeatures.size()));\n}\n\nvoid RuleMatcher::optimize() {\n  for (auto &Item : InsnVariableIDs) {\n    InstructionMatcher &InsnMatcher = *Item.first;\n    for (auto &OM : InsnMatcher.operands()) {\n      // Complex Patterns are usually expensive and they relatively rarely fail\n      // on their own: more often we end up throwing away all the work done by a\n      // matching part of a complex pattern because some other part of the\n      // enclosing pattern didn't match. All of this makes it beneficial to\n      // delay complex patterns until the very end of the rule matching,\n      // especially for targets having lots of complex patterns.\n      for (auto &OP : OM->predicates())\n        if (isa<ComplexPatternOperandMatcher>(OP))\n          EpilogueMatchers.emplace_back(std::move(OP));\n      OM->eraseNullPredicates();\n    }\n    InsnMatcher.optimize();\n  }\n  llvm::sort(EpilogueMatchers, [](const std::unique_ptr<PredicateMatcher> &L,\n                                  const std::unique_ptr<PredicateMatcher> &R) {\n    return std::make_tuple(L->getKind(), L->getInsnVarID(), L->getOpIdx()) <\n           std::make_tuple(R->getKind(), R->getInsnVarID(), R->getOpIdx());\n  });\n}\n\nbool RuleMatcher::hasFirstCondition() const {\n  if (insnmatchers_empty())\n    return false;\n  InstructionMatcher &Matcher = insnmatchers_front();\n  if (!Matcher.predicates_empty())\n    return true;\n  for (auto &OM : Matcher.operands())\n    for (auto &OP : OM->predicates())\n      if (!isa<InstructionOperandMatcher>(OP))\n        return true;\n  return false;\n}\n\nconst PredicateMatcher &RuleMatcher::getFirstCondition() const {\n  assert(!insnmatchers_empty() &&\n         \"Trying to get a condition from an empty RuleMatcher\");\n\n  InstructionMatcher &Matcher = insnmatchers_front();\n  if (!Matcher.predicates_empty())\n    return **Matcher.predicates_begin();\n  // If there is no more predicate on the instruction itself, look at its\n  // operands.\n  for (auto &OM : Matcher.operands())\n    for (auto &OP : OM->predicates())\n      if (!isa<InstructionOperandMatcher>(OP))\n        return *OP;\n\n  llvm_unreachable(\"Trying to get a condition from an InstructionMatcher with \"\n                   \"no conditions\");\n}\n\nstd::unique_ptr<PredicateMatcher> RuleMatcher::popFirstCondition() {\n  assert(!insnmatchers_empty() &&\n         \"Trying to pop a condition from an empty RuleMatcher\");\n\n  InstructionMatcher &Matcher = insnmatchers_front();\n  if (!Matcher.predicates_empty())\n    return Matcher.predicates_pop_front();\n  // If there is no more predicate on the instruction itself, look at its\n  // operands.\n  for (auto &OM : Matcher.operands())\n    for (auto &OP : OM->predicates())\n      if (!isa<InstructionOperandMatcher>(OP)) {\n        std::unique_ptr<PredicateMatcher> Result = std::move(OP);\n        OM->eraseNullPredicates();\n        return Result;\n      }\n\n  llvm_unreachable(\"Trying to pop a condition from an InstructionMatcher with \"\n                   \"no conditions\");\n}\n\nbool GroupMatcher::candidateConditionMatches(\n    const PredicateMatcher &Predicate) const {\n\n  if (empty()) {\n    // Sharing predicates for nested instructions is not supported yet as we\n    // currently don't hoist the GIM_RecordInsn's properly, therefore we can\n    // only work on the original root instruction (InsnVarID == 0):\n    if (Predicate.getInsnVarID() != 0)\n      return false;\n    // ... otherwise an empty group can handle any predicate with no specific\n    // requirements:\n    return true;\n  }\n\n  const Matcher &Representative = **Matchers.begin();\n  const auto &RepresentativeCondition = Representative.getFirstCondition();\n  // ... if not empty, the group can only accomodate matchers with the exact\n  // same first condition:\n  return Predicate.isIdentical(RepresentativeCondition);\n}\n\nbool GroupMatcher::addMatcher(Matcher &Candidate) {\n  if (!Candidate.hasFirstCondition())\n    return false;\n\n  const PredicateMatcher &Predicate = Candidate.getFirstCondition();\n  if (!candidateConditionMatches(Predicate))\n    return false;\n\n  Matchers.push_back(&Candidate);\n  return true;\n}\n\nvoid GroupMatcher::finalize() {\n  assert(Conditions.empty() && \"Already finalized?\");\n  if (empty())\n    return;\n\n  Matcher &FirstRule = **Matchers.begin();\n  for (;;) {\n    // All the checks are expected to succeed during the first iteration:\n    for (const auto &Rule : Matchers)\n      if (!Rule->hasFirstCondition())\n        return;\n    const auto &FirstCondition = FirstRule.getFirstCondition();\n    for (unsigned I = 1, E = Matchers.size(); I < E; ++I)\n      if (!Matchers[I]->getFirstCondition().isIdentical(FirstCondition))\n        return;\n\n    Conditions.push_back(FirstRule.popFirstCondition());\n    for (unsigned I = 1, E = Matchers.size(); I < E; ++I)\n      Matchers[I]->popFirstCondition();\n  }\n}\n\nvoid GroupMatcher::emit(MatchTable &Table) {\n  unsigned LabelID = ~0U;\n  if (!Conditions.empty()) {\n    LabelID = Table.allocateLabelID();\n    Table << MatchTable::Opcode(\"GIM_Try\", +1)\n          << MatchTable::Comment(\"On fail goto\")\n          << MatchTable::JumpTarget(LabelID) << MatchTable::LineBreak;\n  }\n  for (auto &Condition : Conditions)\n    Condition->emitPredicateOpcodes(\n        Table, *static_cast<RuleMatcher *>(*Matchers.begin()));\n\n  for (const auto &M : Matchers)\n    M->emit(Table);\n\n  // Exit the group\n  if (!Conditions.empty())\n    Table << MatchTable::Opcode(\"GIM_Reject\", -1) << MatchTable::LineBreak\n          << MatchTable::Label(LabelID);\n}\n\nbool SwitchMatcher::isSupportedPredicateType(const PredicateMatcher &P) {\n  return isa<InstructionOpcodeMatcher>(P) || isa<LLTOperandMatcher>(P);\n}\n\nbool SwitchMatcher::candidateConditionMatches(\n    const PredicateMatcher &Predicate) const {\n\n  if (empty()) {\n    // Sharing predicates for nested instructions is not supported yet as we\n    // currently don't hoist the GIM_RecordInsn's properly, therefore we can\n    // only work on the original root instruction (InsnVarID == 0):\n    if (Predicate.getInsnVarID() != 0)\n      return false;\n    // ... while an attempt to add even a root matcher to an empty SwitchMatcher\n    // could fail as not all the types of conditions are supported:\n    if (!isSupportedPredicateType(Predicate))\n      return false;\n    // ... or the condition might not have a proper implementation of\n    // getValue() / isIdenticalDownToValue() yet:\n    if (!Predicate.hasValue())\n      return false;\n    // ... otherwise an empty Switch can accomodate the condition with no\n    // further requirements:\n    return true;\n  }\n\n  const Matcher &CaseRepresentative = **Matchers.begin();\n  const auto &RepresentativeCondition = CaseRepresentative.getFirstCondition();\n  // Switch-cases must share the same kind of condition and path to the value it\n  // checks:\n  if (!Predicate.isIdenticalDownToValue(RepresentativeCondition))\n    return false;\n\n  const auto Value = Predicate.getValue();\n  // ... but be unique with respect to the actual value they check:\n  return Values.count(Value) == 0;\n}\n\nbool SwitchMatcher::addMatcher(Matcher &Candidate) {\n  if (!Candidate.hasFirstCondition())\n    return false;\n\n  const PredicateMatcher &Predicate = Candidate.getFirstCondition();\n  if (!candidateConditionMatches(Predicate))\n    return false;\n  const auto Value = Predicate.getValue();\n  Values.insert(Value);\n\n  Matchers.push_back(&Candidate);\n  return true;\n}\n\nvoid SwitchMatcher::finalize() {\n  assert(Condition == nullptr && \"Already finalized\");\n  assert(Values.size() == Matchers.size() && \"Broken SwitchMatcher\");\n  if (empty())\n    return;\n\n  llvm::stable_sort(Matchers, [](const Matcher *L, const Matcher *R) {\n    return L->getFirstCondition().getValue() <\n           R->getFirstCondition().getValue();\n  });\n  Condition = Matchers[0]->popFirstCondition();\n  for (unsigned I = 1, E = Values.size(); I < E; ++I)\n    Matchers[I]->popFirstCondition();\n}\n\nvoid SwitchMatcher::emitPredicateSpecificOpcodes(const PredicateMatcher &P,\n                                                 MatchTable &Table) {\n  assert(isSupportedPredicateType(P) && \"Predicate type is not supported\");\n\n  if (const auto *Condition = dyn_cast<InstructionOpcodeMatcher>(&P)) {\n    Table << MatchTable::Opcode(\"GIM_SwitchOpcode\") << MatchTable::Comment(\"MI\")\n          << MatchTable::IntValue(Condition->getInsnVarID());\n    return;\n  }\n  if (const auto *Condition = dyn_cast<LLTOperandMatcher>(&P)) {\n    Table << MatchTable::Opcode(\"GIM_SwitchType\") << MatchTable::Comment(\"MI\")\n          << MatchTable::IntValue(Condition->getInsnVarID())\n          << MatchTable::Comment(\"Op\")\n          << MatchTable::IntValue(Condition->getOpIdx());\n    return;\n  }\n\n  llvm_unreachable(\"emitPredicateSpecificOpcodes is broken: can not handle a \"\n                   \"predicate type that is claimed to be supported\");\n}\n\nvoid SwitchMatcher::emit(MatchTable &Table) {\n  assert(Values.size() == Matchers.size() && \"Broken SwitchMatcher\");\n  if (empty())\n    return;\n  assert(Condition != nullptr &&\n         \"Broken SwitchMatcher, hasn't been finalized?\");\n\n  std::vector<unsigned> LabelIDs(Values.size());\n  std::generate(LabelIDs.begin(), LabelIDs.end(),\n                [&Table]() { return Table.allocateLabelID(); });\n  const unsigned Default = Table.allocateLabelID();\n\n  const int64_t LowerBound = Values.begin()->getRawValue();\n  const int64_t UpperBound = Values.rbegin()->getRawValue() + 1;\n\n  emitPredicateSpecificOpcodes(*Condition, Table);\n\n  Table << MatchTable::Comment(\"[\") << MatchTable::IntValue(LowerBound)\n        << MatchTable::IntValue(UpperBound) << MatchTable::Comment(\")\")\n        << MatchTable::Comment(\"default:\") << MatchTable::JumpTarget(Default);\n\n  int64_t J = LowerBound;\n  auto VI = Values.begin();\n  for (unsigned I = 0, E = Values.size(); I < E; ++I) {\n    auto V = *VI++;\n    while (J++ < V.getRawValue())\n      Table << MatchTable::IntValue(0);\n    V.turnIntoComment();\n    Table << MatchTable::LineBreak << V << MatchTable::JumpTarget(LabelIDs[I]);\n  }\n  Table << MatchTable::LineBreak;\n\n  for (unsigned I = 0, E = Values.size(); I < E; ++I) {\n    Table << MatchTable::Label(LabelIDs[I]);\n    Matchers[I]->emit(Table);\n    Table << MatchTable::Opcode(\"GIM_Reject\") << MatchTable::LineBreak;\n  }\n  Table << MatchTable::Label(Default);\n}\n\nunsigned OperandMatcher::getInsnVarID() const { return Insn.getInsnVarID(); }\n\n} // end anonymous namespace\n\n//===----------------------------------------------------------------------===//\n\nnamespace llvm {\nvoid EmitGlobalISel(RecordKeeper &RK, raw_ostream &OS) {\n  GlobalISelEmitter(RK).run(OS);\n}\n} // End llvm namespace\n"}}, "reports": [{"events": [{"location": {"col": 24, "file": 1, "line": 615}, "message": "the definition seen here"}, {"location": {"col": 8, "file": 1, "line": 477}, "message": "differing parameters are named here: ('LineBreakNextAfterThis'), in definition: ('LineBreakIsNextAfterThis')"}, {"location": {"col": 8, "file": 1, "line": 477}, "message": "function '(anonymous namespace)::MatchTableRecord::emit' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/TableGen/GlobalISelEmitter.cpp", "reportHash": "085167167ceb31b2575e826a36044d8f", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
