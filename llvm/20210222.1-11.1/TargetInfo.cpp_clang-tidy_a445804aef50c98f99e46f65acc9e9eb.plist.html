<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/TargetInfo.cpp", "content": "//===---- TargetInfo.cpp - Encapsulate target details -----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// These classes wrap the information about a call or function\n// definition used to handle ABI compliancy.\n//\n//===----------------------------------------------------------------------===//\n\n#include \"TargetInfo.h\"\n#include \"ABIInfo.h\"\n#include \"CGBlocks.h\"\n#include \"CGCXXABI.h\"\n#include \"CGValue.h\"\n#include \"CodeGenFunction.h\"\n#include \"clang/AST/Attr.h\"\n#include \"clang/AST/RecordLayout.h\"\n#include \"clang/Basic/CodeGenOptions.h\"\n#include \"clang/Basic/DiagnosticFrontend.h\"\n#include \"clang/Basic/Builtins.h\"\n#include \"clang/CodeGen/CGFunctionInfo.h\"\n#include \"clang/CodeGen/SwiftCallingConv.h\"\n#include \"llvm/ADT/SmallBitVector.h\"\n#include \"llvm/ADT/StringExtras.h\"\n#include \"llvm/ADT/StringSwitch.h\"\n#include \"llvm/ADT/Triple.h\"\n#include \"llvm/ADT/Twine.h\"\n#include \"llvm/IR/DataLayout.h\"\n#include \"llvm/IR/IntrinsicsNVPTX.h\"\n#include \"llvm/IR/IntrinsicsS390.h\"\n#include \"llvm/IR/Type.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <algorithm> // std::sort\n\nusing namespace clang;\nusing namespace CodeGen;\n\n// Helper for coercing an aggregate argument or return value into an integer\n// array of the same size (including padding) and alignment.  This alternate\n// coercion happens only for the RenderScript ABI and can be removed after\n// runtimes that rely on it are no longer supported.\n//\n// RenderScript assumes that the size of the argument / return value in the IR\n// is the same as the size of the corresponding qualified type. This helper\n// coerces the aggregate type into an array of the same size (including\n// padding).  This coercion is used in lieu of expansion of struct members or\n// other canonical coercions that return a coerced-type of larger size.\n//\n// Ty          - The argument / return value type\n// Context     - The associated ASTContext\n// LLVMContext - The associated LLVMContext\nstatic ABIArgInfo coerceToIntArray(QualType Ty,\n                                   ASTContext &Context,\n                                   llvm::LLVMContext &LLVMContext) {\n  // Alignment and Size are measured in bits.\n  const uint64_t Size = Context.getTypeSize(Ty);\n  const uint64_t Alignment = Context.getTypeAlign(Ty);\n  llvm::Type *IntType = llvm::Type::getIntNTy(LLVMContext, Alignment);\n  const uint64_t NumElements = (Size + Alignment - 1) / Alignment;\n  return ABIArgInfo::getDirect(llvm::ArrayType::get(IntType, NumElements));\n}\n\nstatic void AssignToArrayRange(CodeGen::CGBuilderTy &Builder,\n                               llvm::Value *Array,\n                               llvm::Value *Value,\n                               unsigned FirstIndex,\n                               unsigned LastIndex) {\n  // Alternatively, we could emit this as a loop in the source.\n  for (unsigned I = FirstIndex; I <= LastIndex; ++I) {\n    llvm::Value *Cell =\n        Builder.CreateConstInBoundsGEP1_32(Builder.getInt8Ty(), Array, I);\n    Builder.CreateAlignedStore(Value, Cell, CharUnits::One());\n  }\n}\n\nstatic bool isAggregateTypeForABI(QualType T) {\n  return !CodeGenFunction::hasScalarEvaluationKind(T) ||\n         T->isMemberFunctionPointerType();\n}\n\nABIArgInfo ABIInfo::getNaturalAlignIndirect(QualType Ty, bool ByVal,\n                                            bool Realign,\n                                            llvm::Type *Padding) const {\n  return ABIArgInfo::getIndirect(getContext().getTypeAlignInChars(Ty), ByVal,\n                                 Realign, Padding);\n}\n\nABIArgInfo\nABIInfo::getNaturalAlignIndirectInReg(QualType Ty, bool Realign) const {\n  return ABIArgInfo::getIndirectInReg(getContext().getTypeAlignInChars(Ty),\n                                      /*ByVal*/ false, Realign);\n}\n\nAddress ABIInfo::EmitMSVAArg(CodeGenFunction &CGF, Address VAListAddr,\n                             QualType Ty) const {\n  return Address::invalid();\n}\n\nbool ABIInfo::isPromotableIntegerTypeForABI(QualType Ty) const {\n  if (Ty->isPromotableIntegerType())\n    return true;\n\n  if (const auto *EIT = Ty->getAs<ExtIntType>())\n    if (EIT->getNumBits() < getContext().getTypeSize(getContext().IntTy))\n      return true;\n\n  return false;\n}\n\nABIInfo::~ABIInfo() {}\n\n/// Does the given lowering require more than the given number of\n/// registers when expanded?\n///\n/// This is intended to be the basis of a reasonable basic implementation\n/// of should{Pass,Return}IndirectlyForSwift.\n///\n/// For most targets, a limit of four total registers is reasonable; this\n/// limits the amount of code required in order to move around the value\n/// in case it wasn't produced immediately prior to the call by the caller\n/// (or wasn't produced in exactly the right registers) or isn't used\n/// immediately within the callee.  But some targets may need to further\n/// limit the register count due to an inability to support that many\n/// return registers.\nstatic bool occupiesMoreThan(CodeGenTypes &cgt,\n                             ArrayRef<llvm::Type*> scalarTypes,\n                             unsigned maxAllRegisters) {\n  unsigned intCount = 0, fpCount = 0;\n  for (llvm::Type *type : scalarTypes) {\n    if (type->isPointerTy()) {\n      intCount++;\n    } else if (auto intTy = dyn_cast<llvm::IntegerType>(type)) {\n      auto ptrWidth = cgt.getTarget().getPointerWidth(0);\n      intCount += (intTy->getBitWidth() + ptrWidth - 1) / ptrWidth;\n    } else {\n      assert(type->isVectorTy() || type->isFloatingPointTy());\n      fpCount++;\n    }\n  }\n\n  return (intCount + fpCount > maxAllRegisters);\n}\n\nbool SwiftABIInfo::isLegalVectorTypeForSwift(CharUnits vectorSize,\n                                             llvm::Type *eltTy,\n                                             unsigned numElts) const {\n  // The default implementation of this assumes that the target guarantees\n  // 128-bit SIMD support but nothing more.\n  return (vectorSize.getQuantity() > 8 && vectorSize.getQuantity() <= 16);\n}\n\nstatic CGCXXABI::RecordArgABI getRecordArgABI(const RecordType *RT,\n                                              CGCXXABI &CXXABI) {\n  const CXXRecordDecl *RD = dyn_cast<CXXRecordDecl>(RT->getDecl());\n  if (!RD) {\n    if (!RT->getDecl()->canPassInRegisters())\n      return CGCXXABI::RAA_Indirect;\n    return CGCXXABI::RAA_Default;\n  }\n  return CXXABI.getRecordArgABI(RD);\n}\n\nstatic CGCXXABI::RecordArgABI getRecordArgABI(QualType T,\n                                              CGCXXABI &CXXABI) {\n  const RecordType *RT = T->getAs<RecordType>();\n  if (!RT)\n    return CGCXXABI::RAA_Default;\n  return getRecordArgABI(RT, CXXABI);\n}\n\nstatic bool classifyReturnType(const CGCXXABI &CXXABI, CGFunctionInfo &FI,\n                               const ABIInfo &Info) {\n  QualType Ty = FI.getReturnType();\n\n  if (const auto *RT = Ty->getAs<RecordType>())\n    if (!isa<CXXRecordDecl>(RT->getDecl()) &&\n        !RT->getDecl()->canPassInRegisters()) {\n      FI.getReturnInfo() = Info.getNaturalAlignIndirect(Ty);\n      return true;\n    }\n\n  return CXXABI.classifyReturnType(FI);\n}\n\n/// Pass transparent unions as if they were the type of the first element. Sema\n/// should ensure that all elements of the union have the same \"machine type\".\nstatic QualType useFirstFieldIfTransparentUnion(QualType Ty) {\n  if (const RecordType *UT = Ty->getAsUnionType()) {\n    const RecordDecl *UD = UT->getDecl();\n    if (UD->hasAttr<TransparentUnionAttr>()) {\n      assert(!UD->field_empty() && \"sema created an empty transparent union\");\n      return UD->field_begin()->getType();\n    }\n  }\n  return Ty;\n}\n\nCGCXXABI &ABIInfo::getCXXABI() const {\n  return CGT.getCXXABI();\n}\n\nASTContext &ABIInfo::getContext() const {\n  return CGT.getContext();\n}\n\nllvm::LLVMContext &ABIInfo::getVMContext() const {\n  return CGT.getLLVMContext();\n}\n\nconst llvm::DataLayout &ABIInfo::getDataLayout() const {\n  return CGT.getDataLayout();\n}\n\nconst TargetInfo &ABIInfo::getTarget() const {\n  return CGT.getTarget();\n}\n\nconst CodeGenOptions &ABIInfo::getCodeGenOpts() const {\n  return CGT.getCodeGenOpts();\n}\n\nbool ABIInfo::isAndroid() const { return getTarget().getTriple().isAndroid(); }\n\nbool ABIInfo::isHomogeneousAggregateBaseType(QualType Ty) const {\n  return false;\n}\n\nbool ABIInfo::isHomogeneousAggregateSmallEnough(const Type *Base,\n                                                uint64_t Members) const {\n  return false;\n}\n\nLLVM_DUMP_METHOD void ABIArgInfo::dump() const {\n  raw_ostream &OS = llvm::errs();\n  OS << \"(ABIArgInfo Kind=\";\n  switch (TheKind) {\n  case Direct:\n    OS << \"Direct Type=\";\n    if (llvm::Type *Ty = getCoerceToType())\n      Ty->print(OS);\n    else\n      OS << \"null\";\n    break;\n  case Extend:\n    OS << \"Extend\";\n    break;\n  case Ignore:\n    OS << \"Ignore\";\n    break;\n  case InAlloca:\n    OS << \"InAlloca Offset=\" << getInAllocaFieldIndex();\n    break;\n  case Indirect:\n    OS << \"Indirect Align=\" << getIndirectAlign().getQuantity()\n       << \" ByVal=\" << getIndirectByVal()\n       << \" Realign=\" << getIndirectRealign();\n    break;\n  case IndirectAliased:\n    OS << \"Indirect Align=\" << getIndirectAlign().getQuantity()\n       << \" AadrSpace=\" << getIndirectAddrSpace()\n       << \" Realign=\" << getIndirectRealign();\n    break;\n  case Expand:\n    OS << \"Expand\";\n    break;\n  case CoerceAndExpand:\n    OS << \"CoerceAndExpand Type=\";\n    getCoerceAndExpandType()->print(OS);\n    break;\n  }\n  OS << \")\\n\";\n}\n\n// Dynamically round a pointer up to a multiple of the given alignment.\nstatic llvm::Value *emitRoundPointerUpToAlignment(CodeGenFunction &CGF,\n                                                  llvm::Value *Ptr,\n                                                  CharUnits Align) {\n  llvm::Value *PtrAsInt = Ptr;\n  // OverflowArgArea = (OverflowArgArea + Align - 1) & -Align;\n  PtrAsInt = CGF.Builder.CreatePtrToInt(PtrAsInt, CGF.IntPtrTy);\n  PtrAsInt = CGF.Builder.CreateAdd(PtrAsInt,\n        llvm::ConstantInt::get(CGF.IntPtrTy, Align.getQuantity() - 1));\n  PtrAsInt = CGF.Builder.CreateAnd(PtrAsInt,\n           llvm::ConstantInt::get(CGF.IntPtrTy, -Align.getQuantity()));\n  PtrAsInt = CGF.Builder.CreateIntToPtr(PtrAsInt,\n                                        Ptr->getType(),\n                                        Ptr->getName() + \".aligned\");\n  return PtrAsInt;\n}\n\n/// Emit va_arg for a platform using the common void* representation,\n/// where arguments are simply emitted in an array of slots on the stack.\n///\n/// This version implements the core direct-value passing rules.\n///\n/// \\param SlotSize - The size and alignment of a stack slot.\n///   Each argument will be allocated to a multiple of this number of\n///   slots, and all the slots will be aligned to this value.\n/// \\param AllowHigherAlign - The slot alignment is not a cap;\n///   an argument type with an alignment greater than the slot size\n///   will be emitted on a higher-alignment address, potentially\n///   leaving one or more empty slots behind as padding.  If this\n///   is false, the returned address might be less-aligned than\n///   DirectAlign.\nstatic Address emitVoidPtrDirectVAArg(CodeGenFunction &CGF,\n                                      Address VAListAddr,\n                                      llvm::Type *DirectTy,\n                                      CharUnits DirectSize,\n                                      CharUnits DirectAlign,\n                                      CharUnits SlotSize,\n                                      bool AllowHigherAlign) {\n  // Cast the element type to i8* if necessary.  Some platforms define\n  // va_list as a struct containing an i8* instead of just an i8*.\n  if (VAListAddr.getElementType() != CGF.Int8PtrTy)\n    VAListAddr = CGF.Builder.CreateElementBitCast(VAListAddr, CGF.Int8PtrTy);\n\n  llvm::Value *Ptr = CGF.Builder.CreateLoad(VAListAddr, \"argp.cur\");\n\n  // If the CC aligns values higher than the slot size, do so if needed.\n  Address Addr = Address::invalid();\n  if (AllowHigherAlign && DirectAlign > SlotSize) {\n    Addr = Address(emitRoundPointerUpToAlignment(CGF, Ptr, DirectAlign),\n                                                 DirectAlign);\n  } else {\n    Addr = Address(Ptr, SlotSize);\n  }\n\n  // Advance the pointer past the argument, then store that back.\n  CharUnits FullDirectSize = DirectSize.alignTo(SlotSize);\n  Address NextPtr =\n      CGF.Builder.CreateConstInBoundsByteGEP(Addr, FullDirectSize, \"argp.next\");\n  CGF.Builder.CreateStore(NextPtr.getPointer(), VAListAddr);\n\n  // If the argument is smaller than a slot, and this is a big-endian\n  // target, the argument will be right-adjusted in its slot.\n  if (DirectSize < SlotSize && CGF.CGM.getDataLayout().isBigEndian() &&\n      !DirectTy->isStructTy()) {\n    Addr = CGF.Builder.CreateConstInBoundsByteGEP(Addr, SlotSize - DirectSize);\n  }\n\n  Addr = CGF.Builder.CreateElementBitCast(Addr, DirectTy);\n  return Addr;\n}\n\n/// Emit va_arg for a platform using the common void* representation,\n/// where arguments are simply emitted in an array of slots on the stack.\n///\n/// \\param IsIndirect - Values of this type are passed indirectly.\n/// \\param ValueInfo - The size and alignment of this type, generally\n///   computed with getContext().getTypeInfoInChars(ValueTy).\n/// \\param SlotSizeAndAlign - The size and alignment of a stack slot.\n///   Each argument will be allocated to a multiple of this number of\n///   slots, and all the slots will be aligned to this value.\n/// \\param AllowHigherAlign - The slot alignment is not a cap;\n///   an argument type with an alignment greater than the slot size\n///   will be emitted on a higher-alignment address, potentially\n///   leaving one or more empty slots behind as padding.\nstatic Address emitVoidPtrVAArg(CodeGenFunction &CGF, Address VAListAddr,\n                                QualType ValueTy, bool IsIndirect,\n                                TypeInfoChars ValueInfo,\n                                CharUnits SlotSizeAndAlign,\n                                bool AllowHigherAlign) {\n  // The size and alignment of the value that was passed directly.\n  CharUnits DirectSize, DirectAlign;\n  if (IsIndirect) {\n    DirectSize = CGF.getPointerSize();\n    DirectAlign = CGF.getPointerAlign();\n  } else {\n    DirectSize = ValueInfo.Width;\n    DirectAlign = ValueInfo.Align;\n  }\n\n  // Cast the address we've calculated to the right type.\n  llvm::Type *DirectTy = CGF.ConvertTypeForMem(ValueTy);\n  if (IsIndirect)\n    DirectTy = DirectTy->getPointerTo(0);\n\n  Address Addr = emitVoidPtrDirectVAArg(CGF, VAListAddr, DirectTy,\n                                        DirectSize, DirectAlign,\n                                        SlotSizeAndAlign,\n                                        AllowHigherAlign);\n\n  if (IsIndirect) {\n    Addr = Address(CGF.Builder.CreateLoad(Addr), ValueInfo.Align);\n  }\n\n  return Addr;\n\n}\n\nstatic Address emitMergePHI(CodeGenFunction &CGF,\n                            Address Addr1, llvm::BasicBlock *Block1,\n                            Address Addr2, llvm::BasicBlock *Block2,\n                            const llvm::Twine &Name = \"\") {\n  assert(Addr1.getType() == Addr2.getType());\n  llvm::PHINode *PHI = CGF.Builder.CreatePHI(Addr1.getType(), 2, Name);\n  PHI->addIncoming(Addr1.getPointer(), Block1);\n  PHI->addIncoming(Addr2.getPointer(), Block2);\n  CharUnits Align = std::min(Addr1.getAlignment(), Addr2.getAlignment());\n  return Address(PHI, Align);\n}\n\nTargetCodeGenInfo::~TargetCodeGenInfo() = default;\n\n// If someone can figure out a general rule for this, that would be great.\n// It's probably just doomed to be platform-dependent, though.\nunsigned TargetCodeGenInfo::getSizeOfUnwindException() const {\n  // Verified for:\n  //   x86-64     FreeBSD, Linux, Darwin\n  //   x86-32     FreeBSD, Linux, Darwin\n  //   PowerPC    Linux, Darwin\n  //   ARM        Darwin (*not* EABI)\n  //   AArch64    Linux\n  return 32;\n}\n\nbool TargetCodeGenInfo::isNoProtoCallVariadic(const CallArgList &args,\n                                     const FunctionNoProtoType *fnType) const {\n  // The following conventions are known to require this to be false:\n  //   x86_stdcall\n  //   MIPS\n  // For everything else, we just prefer false unless we opt out.\n  return false;\n}\n\nvoid\nTargetCodeGenInfo::getDependentLibraryOption(llvm::StringRef Lib,\n                                             llvm::SmallString<24> &Opt) const {\n  // This assumes the user is passing a library name like \"rt\" instead of a\n  // filename like \"librt.a/so\", and that they don't care whether it's static or\n  // dynamic.\n  Opt = \"-l\";\n  Opt += Lib;\n}\n\nunsigned TargetCodeGenInfo::getOpenCLKernelCallingConv() const {\n  // OpenCL kernels are called via an explicit runtime API with arguments\n  // set with clSetKernelArg(), not as normal sub-functions.\n  // Return SPIR_KERNEL by default as the kernel calling convention to\n  // ensure the fingerprint is fixed such way that each OpenCL argument\n  // gets one matching argument in the produced kernel function argument\n  // list to enable feasible implementation of clSetKernelArg() with\n  // aggregates etc. In case we would use the default C calling conv here,\n  // clSetKernelArg() might break depending on the target-specific\n  // conventions; different targets might split structs passed as values\n  // to multiple function arguments etc.\n  return llvm::CallingConv::SPIR_KERNEL;\n}\n\nllvm::Constant *TargetCodeGenInfo::getNullPointer(const CodeGen::CodeGenModule &CGM,\n    llvm::PointerType *T, QualType QT) const {\n  return llvm::ConstantPointerNull::get(T);\n}\n\nLangAS TargetCodeGenInfo::getGlobalVarAddressSpace(CodeGenModule &CGM,\n                                                   const VarDecl *D) const {\n  assert(!CGM.getLangOpts().OpenCL &&\n         !(CGM.getLangOpts().CUDA && CGM.getLangOpts().CUDAIsDevice) &&\n         \"Address space agnostic languages only\");\n  return D ? D->getType().getAddressSpace() : LangAS::Default;\n}\n\nllvm::Value *TargetCodeGenInfo::performAddrSpaceCast(\n    CodeGen::CodeGenFunction &CGF, llvm::Value *Src, LangAS SrcAddr,\n    LangAS DestAddr, llvm::Type *DestTy, bool isNonNull) const {\n  // Since target may map different address spaces in AST to the same address\n  // space, an address space conversion may end up as a bitcast.\n  if (auto *C = dyn_cast<llvm::Constant>(Src))\n    return performAddrSpaceCast(CGF.CGM, C, SrcAddr, DestAddr, DestTy);\n  // Try to preserve the source's name to make IR more readable.\n  return CGF.Builder.CreatePointerBitCastOrAddrSpaceCast(\n      Src, DestTy, Src->hasName() ? Src->getName() + \".ascast\" : \"\");\n}\n\nllvm::Constant *\nTargetCodeGenInfo::performAddrSpaceCast(CodeGenModule &CGM, llvm::Constant *Src,\n                                        LangAS SrcAddr, LangAS DestAddr,\n                                        llvm::Type *DestTy) const {\n  // Since target may map different address spaces in AST to the same address\n  // space, an address space conversion may end up as a bitcast.\n  return llvm::ConstantExpr::getPointerCast(Src, DestTy);\n}\n\nllvm::SyncScope::ID\nTargetCodeGenInfo::getLLVMSyncScopeID(const LangOptions &LangOpts,\n                                      SyncScope Scope,\n                                      llvm::AtomicOrdering Ordering,\n                                      llvm::LLVMContext &Ctx) const {\n  return Ctx.getOrInsertSyncScopeID(\"\"); /* default sync scope */\n}\n\nstatic bool isEmptyRecord(ASTContext &Context, QualType T, bool AllowArrays);\n\n/// isEmptyField - Return true iff a the field is \"empty\", that is it\n/// is an unnamed bit-field or an (array of) empty record(s).\nstatic bool isEmptyField(ASTContext &Context, const FieldDecl *FD,\n                         bool AllowArrays) {\n  if (FD->isUnnamedBitfield())\n    return true;\n\n  QualType FT = FD->getType();\n\n  // Constant arrays of empty records count as empty, strip them off.\n  // Constant arrays of zero length always count as empty.\n  bool WasArray = false;\n  if (AllowArrays)\n    while (const ConstantArrayType *AT = Context.getAsConstantArrayType(FT)) {\n      if (AT->getSize() == 0)\n        return true;\n      FT = AT->getElementType();\n      // The [[no_unique_address]] special case below does not apply to\n      // arrays of C++ empty records, so we need to remember this fact.\n      WasArray = true;\n    }\n\n  const RecordType *RT = FT->getAs<RecordType>();\n  if (!RT)\n    return false;\n\n  // C++ record fields are never empty, at least in the Itanium ABI.\n  //\n  // FIXME: We should use a predicate for whether this behavior is true in the\n  // current ABI.\n  //\n  // The exception to the above rule are fields marked with the\n  // [[no_unique_address]] attribute (since C++20).  Those do count as empty\n  // according to the Itanium ABI.  The exception applies only to records,\n  // not arrays of records, so we must also check whether we stripped off an\n  // array type above.\n  if (isa<CXXRecordDecl>(RT->getDecl()) &&\n      (WasArray || !FD->hasAttr<NoUniqueAddressAttr>()))\n    return false;\n\n  return isEmptyRecord(Context, FT, AllowArrays);\n}\n\n/// isEmptyRecord - Return true iff a structure contains only empty\n/// fields. Note that a structure with a flexible array member is not\n/// considered empty.\nstatic bool isEmptyRecord(ASTContext &Context, QualType T, bool AllowArrays) {\n  const RecordType *RT = T->getAs<RecordType>();\n  if (!RT)\n    return false;\n  const RecordDecl *RD = RT->getDecl();\n  if (RD->hasFlexibleArrayMember())\n    return false;\n\n  // If this is a C++ record, check the bases first.\n  if (const CXXRecordDecl *CXXRD = dyn_cast<CXXRecordDecl>(RD))\n    for (const auto &I : CXXRD->bases())\n      if (!isEmptyRecord(Context, I.getType(), true))\n        return false;\n\n  for (const auto *I : RD->fields())\n    if (!isEmptyField(Context, I, AllowArrays))\n      return false;\n  return true;\n}\n\n/// isSingleElementStruct - Determine if a structure is a \"single\n/// element struct\", i.e. it has exactly one non-empty field or\n/// exactly one field which is itself a single element\n/// struct. Structures with flexible array members are never\n/// considered single element structs.\n///\n/// \\return The field declaration for the single non-empty field, if\n/// it exists.\nstatic const Type *isSingleElementStruct(QualType T, ASTContext &Context) {\n  const RecordType *RT = T->getAs<RecordType>();\n  if (!RT)\n    return nullptr;\n\n  const RecordDecl *RD = RT->getDecl();\n  if (RD->hasFlexibleArrayMember())\n    return nullptr;\n\n  const Type *Found = nullptr;\n\n  // If this is a C++ record, check the bases first.\n  if (const CXXRecordDecl *CXXRD = dyn_cast<CXXRecordDecl>(RD)) {\n    for (const auto &I : CXXRD->bases()) {\n      // Ignore empty records.\n      if (isEmptyRecord(Context, I.getType(), true))\n        continue;\n\n      // If we already found an element then this isn't a single-element struct.\n      if (Found)\n        return nullptr;\n\n      // If this is non-empty and not a single element struct, the composite\n      // cannot be a single element struct.\n      Found = isSingleElementStruct(I.getType(), Context);\n      if (!Found)\n        return nullptr;\n    }\n  }\n\n  // Check for single element.\n  for (const auto *FD : RD->fields()) {\n    QualType FT = FD->getType();\n\n    // Ignore empty fields.\n    if (isEmptyField(Context, FD, true))\n      continue;\n\n    // If we already found an element then this isn't a single-element\n    // struct.\n    if (Found)\n      return nullptr;\n\n    // Treat single element arrays as the element.\n    while (const ConstantArrayType *AT = Context.getAsConstantArrayType(FT)) {\n      if (AT->getSize().getZExtValue() != 1)\n        break;\n      FT = AT->getElementType();\n    }\n\n    if (!isAggregateTypeForABI(FT)) {\n      Found = FT.getTypePtr();\n    } else {\n      Found = isSingleElementStruct(FT, Context);\n      if (!Found)\n        return nullptr;\n    }\n  }\n\n  // We don't consider a struct a single-element struct if it has\n  // padding beyond the element type.\n  if (Found && Context.getTypeSize(Found) != Context.getTypeSize(T))\n    return nullptr;\n\n  return Found;\n}\n\nnamespace {\nAddress EmitVAArgInstr(CodeGenFunction &CGF, Address VAListAddr, QualType Ty,\n                       const ABIArgInfo &AI) {\n  // This default implementation defers to the llvm backend's va_arg\n  // instruction. It can handle only passing arguments directly\n  // (typically only handled in the backend for primitive types), or\n  // aggregates passed indirectly by pointer (NOTE: if the \"byval\"\n  // flag has ABI impact in the callee, this implementation cannot\n  // work.)\n\n  // Only a few cases are covered here at the moment -- those needed\n  // by the default abi.\n  llvm::Value *Val;\n\n  if (AI.isIndirect()) {\n    assert(!AI.getPaddingType() &&\n           \"Unexpected PaddingType seen in arginfo in generic VAArg emitter!\");\n    assert(\n        !AI.getIndirectRealign() &&\n        \"Unexpected IndirectRealign seen in arginfo in generic VAArg emitter!\");\n\n    auto TyInfo = CGF.getContext().getTypeInfoInChars(Ty);\n    CharUnits TyAlignForABI = TyInfo.Align;\n\n    llvm::Type *BaseTy =\n        llvm::PointerType::getUnqual(CGF.ConvertTypeForMem(Ty));\n    llvm::Value *Addr =\n        CGF.Builder.CreateVAArg(VAListAddr.getPointer(), BaseTy);\n    return Address(Addr, TyAlignForABI);\n  } else {\n    assert((AI.isDirect() || AI.isExtend()) &&\n           \"Unexpected ArgInfo Kind in generic VAArg emitter!\");\n\n    assert(!AI.getInReg() &&\n           \"Unexpected InReg seen in arginfo in generic VAArg emitter!\");\n    assert(!AI.getPaddingType() &&\n           \"Unexpected PaddingType seen in arginfo in generic VAArg emitter!\");\n    assert(!AI.getDirectOffset() &&\n           \"Unexpected DirectOffset seen in arginfo in generic VAArg emitter!\");\n    assert(!AI.getCoerceToType() &&\n           \"Unexpected CoerceToType seen in arginfo in generic VAArg emitter!\");\n\n    Address Temp = CGF.CreateMemTemp(Ty, \"varet\");\n    Val = CGF.Builder.CreateVAArg(VAListAddr.getPointer(), CGF.ConvertType(Ty));\n    CGF.Builder.CreateStore(Val, Temp);\n    return Temp;\n  }\n}\n\n/// DefaultABIInfo - The default implementation for ABI specific\n/// details. This implementation provides information which results in\n/// self-consistent and sensible LLVM IR generation, but does not\n/// conform to any particular ABI.\nclass DefaultABIInfo : public ABIInfo {\npublic:\n  DefaultABIInfo(CodeGen::CodeGenTypes &CGT) : ABIInfo(CGT) {}\n\n  ABIArgInfo classifyReturnType(QualType RetTy) const;\n  ABIArgInfo classifyArgumentType(QualType RetTy) const;\n\n  void computeInfo(CGFunctionInfo &FI) const override {\n    if (!getCXXABI().classifyReturnType(FI))\n      FI.getReturnInfo() = classifyReturnType(FI.getReturnType());\n    for (auto &I : FI.arguments())\n      I.info = classifyArgumentType(I.type);\n  }\n\n  Address EmitVAArg(CodeGenFunction &CGF, Address VAListAddr,\n                    QualType Ty) const override {\n    return EmitVAArgInstr(CGF, VAListAddr, Ty, classifyArgumentType(Ty));\n  }\n};\n\nclass DefaultTargetCodeGenInfo : public TargetCodeGenInfo {\npublic:\n  DefaultTargetCodeGenInfo(CodeGen::CodeGenTypes &CGT)\n      : TargetCodeGenInfo(std::make_unique<DefaultABIInfo>(CGT)) {}\n};\n\nABIArgInfo DefaultABIInfo::classifyArgumentType(QualType Ty) const {\n  Ty = useFirstFieldIfTransparentUnion(Ty);\n\n  if (isAggregateTypeForABI(Ty)) {\n    // Records with non-trivial destructors/copy-constructors should not be\n    // passed by value.\n    if (CGCXXABI::RecordArgABI RAA = getRecordArgABI(Ty, getCXXABI()))\n      return getNaturalAlignIndirect(Ty, RAA == CGCXXABI::RAA_DirectInMemory);\n\n    return getNaturalAlignIndirect(Ty);\n  }\n\n  // Treat an enum type as its underlying type.\n  if (const EnumType *EnumTy = Ty->getAs<EnumType>())\n    Ty = EnumTy->getDecl()->getIntegerType();\n\n  ASTContext &Context = getContext();\n  if (const auto *EIT = Ty->getAs<ExtIntType>())\n    if (EIT->getNumBits() >\n        Context.getTypeSize(Context.getTargetInfo().hasInt128Type()\n                                ? Context.Int128Ty\n                                : Context.LongLongTy))\n      return getNaturalAlignIndirect(Ty);\n\n  return (isPromotableIntegerTypeForABI(Ty) ? ABIArgInfo::getExtend(Ty)\n                                            : ABIArgInfo::getDirect());\n}\n\nABIArgInfo DefaultABIInfo::classifyReturnType(QualType RetTy) const {\n  if (RetTy->isVoidType())\n    return ABIArgInfo::getIgnore();\n\n  if (isAggregateTypeForABI(RetTy))\n    return getNaturalAlignIndirect(RetTy);\n\n  // Treat an enum type as its underlying type.\n  if (const EnumType *EnumTy = RetTy->getAs<EnumType>())\n    RetTy = EnumTy->getDecl()->getIntegerType();\n\n  if (const auto *EIT = RetTy->getAs<ExtIntType>())\n    if (EIT->getNumBits() >\n        getContext().getTypeSize(getContext().getTargetInfo().hasInt128Type()\n                                     ? getContext().Int128Ty\n                                     : getContext().LongLongTy))\n      return getNaturalAlignIndirect(RetTy);\n\n  return (isPromotableIntegerTypeForABI(RetTy) ? ABIArgInfo::getExtend(RetTy)\n                                               : ABIArgInfo::getDirect());\n}\n\n//===----------------------------------------------------------------------===//\n// WebAssembly ABI Implementation\n//\n// This is a very simple ABI that relies a lot on DefaultABIInfo.\n//===----------------------------------------------------------------------===//\n\nclass WebAssemblyABIInfo final : public SwiftABIInfo {\npublic:\n  enum ABIKind {\n    MVP = 0,\n    ExperimentalMV = 1,\n  };\n\nprivate:\n  DefaultABIInfo defaultInfo;\n  ABIKind Kind;\n\npublic:\n  explicit WebAssemblyABIInfo(CodeGen::CodeGenTypes &CGT, ABIKind Kind)\n      : SwiftABIInfo(CGT), defaultInfo(CGT), Kind(Kind) {}\n\nprivate:\n  ABIArgInfo classifyReturnType(QualType RetTy) const;\n  ABIArgInfo classifyArgumentType(QualType Ty) const;\n\n  // DefaultABIInfo's classifyReturnType and classifyArgumentType are\n  // non-virtual, but computeInfo and EmitVAArg are virtual, so we\n  // overload them.\n  void computeInfo(CGFunctionInfo &FI) const override {\n    if (!getCXXABI().classifyReturnType(FI))\n      FI.getReturnInfo() = classifyReturnType(FI.getReturnType());\n    for (auto &Arg : FI.arguments())\n      Arg.info = classifyArgumentType(Arg.type);\n  }\n\n  Address EmitVAArg(CodeGenFunction &CGF, Address VAListAddr,\n                    QualType Ty) const override;\n\n  bool shouldPassIndirectlyForSwift(ArrayRef<llvm::Type*> scalars,\n                                    bool asReturnValue) const override {\n    return occupiesMoreThan(CGT, scalars, /*total*/ 4);\n  }\n\n  bool isSwiftErrorInRegister() const override {\n    return false;\n  }\n};\n\nclass WebAssemblyTargetCodeGenInfo final : public TargetCodeGenInfo {\npublic:\n  explicit WebAssemblyTargetCodeGenInfo(CodeGen::CodeGenTypes &CGT,\n                                        WebAssemblyABIInfo::ABIKind K)\n      : TargetCodeGenInfo(std::make_unique<WebAssemblyABIInfo>(CGT, K)) {}\n\n  void setTargetAttributes(const Decl *D, llvm::GlobalValue *GV,\n                           CodeGen::CodeGenModule &CGM) const override {\n    TargetCodeGenInfo::setTargetAttributes(D, GV, CGM);\n    if (const auto *FD = dyn_cast_or_null<FunctionDecl>(D)) {\n      if (const auto *Attr = FD->getAttr<WebAssemblyImportModuleAttr>()) {\n        llvm::Function *Fn = cast<llvm::Function>(GV);\n        llvm::AttrBuilder B;\n        B.addAttribute(\"wasm-import-module\", Attr->getImportModule());\n        Fn->addAttributes(llvm::AttributeList::FunctionIndex, B);\n      }\n      if (const auto *Attr = FD->getAttr<WebAssemblyImportNameAttr>()) {\n        llvm::Function *Fn = cast<llvm::Function>(GV);\n        llvm::AttrBuilder B;\n        B.addAttribute(\"wasm-import-name\", Attr->getImportName());\n        Fn->addAttributes(llvm::AttributeList::FunctionIndex, B);\n      }\n      if (const auto *Attr = FD->getAttr<WebAssemblyExportNameAttr>()) {\n        llvm::Function *Fn = cast<llvm::Function>(GV);\n        llvm::AttrBuilder B;\n        B.addAttribute(\"wasm-export-name\", Attr->getExportName());\n        Fn->addAttributes(llvm::AttributeList::FunctionIndex, B);\n      }\n    }\n\n    if (auto *FD = dyn_cast_or_null<FunctionDecl>(D)) {\n      llvm::Function *Fn = cast<llvm::Function>(GV);\n      if (!FD->doesThisDeclarationHaveABody() && !FD->hasPrototype())\n        Fn->addFnAttr(\"no-prototype\");\n    }\n  }\n};\n\n/// Classify argument of given type \\p Ty.\nABIArgInfo WebAssemblyABIInfo::classifyArgumentType(QualType Ty) const {\n  Ty = useFirstFieldIfTransparentUnion(Ty);\n\n  if (isAggregateTypeForABI(Ty)) {\n    // Records with non-trivial destructors/copy-constructors should not be\n    // passed by value.\n    if (auto RAA = getRecordArgABI(Ty, getCXXABI()))\n      return getNaturalAlignIndirect(Ty, RAA == CGCXXABI::RAA_DirectInMemory);\n    // Ignore empty structs/unions.\n    if (isEmptyRecord(getContext(), Ty, true))\n      return ABIArgInfo::getIgnore();\n    // Lower single-element structs to just pass a regular value. TODO: We\n    // could do reasonable-size multiple-element structs too, using getExpand(),\n    // though watch out for things like bitfields.\n    if (const Type *SeltTy = isSingleElementStruct(Ty, getContext()))\n      return ABIArgInfo::getDirect(CGT.ConvertType(QualType(SeltTy, 0)));\n    // For the experimental multivalue ABI, fully expand all other aggregates\n    if (Kind == ABIKind::ExperimentalMV) {\n      const RecordType *RT = Ty->getAs<RecordType>();\n      assert(RT);\n      bool HasBitField = false;\n      for (auto *Field : RT->getDecl()->fields()) {\n        if (Field->isBitField()) {\n          HasBitField = true;\n          break;\n        }\n      }\n      if (!HasBitField)\n        return ABIArgInfo::getExpand();\n    }\n  }\n\n  // Otherwise just do the default thing.\n  return defaultInfo.classifyArgumentType(Ty);\n}\n\nABIArgInfo WebAssemblyABIInfo::classifyReturnType(QualType RetTy) const {\n  if (isAggregateTypeForABI(RetTy)) {\n    // Records with non-trivial destructors/copy-constructors should not be\n    // returned by value.\n    if (!getRecordArgABI(RetTy, getCXXABI())) {\n      // Ignore empty structs/unions.\n      if (isEmptyRecord(getContext(), RetTy, true))\n        return ABIArgInfo::getIgnore();\n      // Lower single-element structs to just return a regular value. TODO: We\n      // could do reasonable-size multiple-element structs too, using\n      // ABIArgInfo::getDirect().\n      if (const Type *SeltTy = isSingleElementStruct(RetTy, getContext()))\n        return ABIArgInfo::getDirect(CGT.ConvertType(QualType(SeltTy, 0)));\n      // For the experimental multivalue ABI, return all other aggregates\n      if (Kind == ABIKind::ExperimentalMV)\n        return ABIArgInfo::getDirect();\n    }\n  }\n\n  // Otherwise just do the default thing.\n  return defaultInfo.classifyReturnType(RetTy);\n}\n\nAddress WebAssemblyABIInfo::EmitVAArg(CodeGenFunction &CGF, Address VAListAddr,\n                                      QualType Ty) const {\n  bool IsIndirect = isAggregateTypeForABI(Ty) &&\n                    !isEmptyRecord(getContext(), Ty, true) &&\n                    !isSingleElementStruct(Ty, getContext());\n  return emitVoidPtrVAArg(CGF, VAListAddr, Ty, IsIndirect,\n                          getContext().getTypeInfoInChars(Ty),\n                          CharUnits::fromQuantity(4),\n                          /*AllowHigherAlign=*/true);\n}\n\n//===----------------------------------------------------------------------===//\n// le32/PNaCl bitcode ABI Implementation\n//\n// This is a simplified version of the x86_32 ABI.  Arguments and return values\n// are always passed on the stack.\n//===----------------------------------------------------------------------===//\n\nclass PNaClABIInfo : public ABIInfo {\n public:\n  PNaClABIInfo(CodeGen::CodeGenTypes &CGT) : ABIInfo(CGT) {}\n\n  ABIArgInfo classifyReturnType(QualType RetTy) const;\n  ABIArgInfo classifyArgumentType(QualType RetTy) const;\n\n  void computeInfo(CGFunctionInfo &FI) const override;\n  Address EmitVAArg(CodeGenFunction &CGF,\n                    Address VAListAddr, QualType Ty) const override;\n};\n\nclass PNaClTargetCodeGenInfo : public TargetCodeGenInfo {\n public:\n   PNaClTargetCodeGenInfo(CodeGen::CodeGenTypes &CGT)\n       : TargetCodeGenInfo(std::make_unique<PNaClABIInfo>(CGT)) {}\n};\n\nvoid PNaClABIInfo::computeInfo(CGFunctionInfo &FI) const {\n  if (!getCXXABI().classifyReturnType(FI))\n    FI.getReturnInfo() = classifyReturnType(FI.getReturnType());\n\n  for (auto &I : FI.arguments())\n    I.info = classifyArgumentType(I.type);\n}\n\nAddress PNaClABIInfo::EmitVAArg(CodeGenFunction &CGF, Address VAListAddr,\n                                QualType Ty) const {\n  // The PNaCL ABI is a bit odd, in that varargs don't use normal\n  // function classification. Structs get passed directly for varargs\n  // functions, through a rewriting transform in\n  // pnacl-llvm/lib/Transforms/NaCl/ExpandVarArgs.cpp, which allows\n  // this target to actually support a va_arg instructions with an\n  // aggregate type, unlike other targets.\n  return EmitVAArgInstr(CGF, VAListAddr, Ty, ABIArgInfo::getDirect());\n}\n\n/// Classify argument of given type \\p Ty.\nABIArgInfo PNaClABIInfo::classifyArgumentType(QualType Ty) const {\n  if (isAggregateTypeForABI(Ty)) {\n    if (CGCXXABI::RecordArgABI RAA = getRecordArgABI(Ty, getCXXABI()))\n      return getNaturalAlignIndirect(Ty, RAA == CGCXXABI::RAA_DirectInMemory);\n    return getNaturalAlignIndirect(Ty);\n  } else if (const EnumType *EnumTy = Ty->getAs<EnumType>()) {\n    // Treat an enum type as its underlying type.\n    Ty = EnumTy->getDecl()->getIntegerType();\n  } else if (Ty->isFloatingType()) {\n    // Floating-point types don't go inreg.\n    return ABIArgInfo::getDirect();\n  } else if (const auto *EIT = Ty->getAs<ExtIntType>()) {\n    // Treat extended integers as integers if <=64, otherwise pass indirectly.\n    if (EIT->getNumBits() > 64)\n      return getNaturalAlignIndirect(Ty);\n    return ABIArgInfo::getDirect();\n  }\n\n  return (isPromotableIntegerTypeForABI(Ty) ? ABIArgInfo::getExtend(Ty)\n                                            : ABIArgInfo::getDirect());\n}\n\nABIArgInfo PNaClABIInfo::classifyReturnType(QualType RetTy) const {\n  if (RetTy->isVoidType())\n    return ABIArgInfo::getIgnore();\n\n  // In the PNaCl ABI we always return records/structures on the stack.\n  if (isAggregateTypeForABI(RetTy))\n    return getNaturalAlignIndirect(RetTy);\n\n  // Treat extended integers as integers if <=64, otherwise pass indirectly.\n  if (const auto *EIT = RetTy->getAs<ExtIntType>()) {\n    if (EIT->getNumBits() > 64)\n      return getNaturalAlignIndirect(RetTy);\n    return ABIArgInfo::getDirect();\n  }\n\n  // Treat an enum type as its underlying type.\n  if (const EnumType *EnumTy = RetTy->getAs<EnumType>())\n    RetTy = EnumTy->getDecl()->getIntegerType();\n\n  return (isPromotableIntegerTypeForABI(RetTy) ? ABIArgInfo::getExtend(RetTy)\n                                               : ABIArgInfo::getDirect());\n}\n\n/// IsX86_MMXType - Return true if this is an MMX type.\nbool IsX86_MMXType(llvm::Type *IRType) {\n  // Return true if the type is an MMX type <2 x i32>, <4 x i16>, or <8 x i8>.\n  return IRType->isVectorTy() && IRType->getPrimitiveSizeInBits() == 64 &&\n    cast<llvm::VectorType>(IRType)->getElementType()->isIntegerTy() &&\n    IRType->getScalarSizeInBits() != 64;\n}\n\nstatic llvm::Type* X86AdjustInlineAsmType(CodeGen::CodeGenFunction &CGF,\n                                          StringRef Constraint,\n                                          llvm::Type* Ty) {\n  bool IsMMXCons = llvm::StringSwitch<bool>(Constraint)\n                     .Cases(\"y\", \"&y\", \"^Ym\", true)\n                     .Default(false);\n  if (IsMMXCons && Ty->isVectorTy()) {\n    if (cast<llvm::VectorType>(Ty)->getPrimitiveSizeInBits().getFixedSize() !=\n        64) {\n      // Invalid MMX constraint\n      return nullptr;\n    }\n\n    return llvm::Type::getX86_MMXTy(CGF.getLLVMContext());\n  }\n\n  // No operation needed\n  return Ty;\n}\n\n/// Returns true if this type can be passed in SSE registers with the\n/// X86_VectorCall calling convention. Shared between x86_32 and x86_64.\nstatic bool isX86VectorTypeForVectorCall(ASTContext &Context, QualType Ty) {\n  if (const BuiltinType *BT = Ty->getAs<BuiltinType>()) {\n    if (BT->isFloatingPoint() && BT->getKind() != BuiltinType::Half) {\n      if (BT->getKind() == BuiltinType::LongDouble) {\n        if (&Context.getTargetInfo().getLongDoubleFormat() ==\n            &llvm::APFloat::x87DoubleExtended())\n          return false;\n      }\n      return true;\n    }\n  } else if (const VectorType *VT = Ty->getAs<VectorType>()) {\n    // vectorcall can pass XMM, YMM, and ZMM vectors. We don't pass SSE1 MMX\n    // registers specially.\n    unsigned VecSize = Context.getTypeSize(VT);\n    if (VecSize == 128 || VecSize == 256 || VecSize == 512)\n      return true;\n  }\n  return false;\n}\n\n/// Returns true if this aggregate is small enough to be passed in SSE registers\n/// in the X86_VectorCall calling convention. Shared between x86_32 and x86_64.\nstatic bool isX86VectorCallAggregateSmallEnough(uint64_t NumMembers) {\n  return NumMembers <= 4;\n}\n\n/// Returns a Homogeneous Vector Aggregate ABIArgInfo, used in X86.\nstatic ABIArgInfo getDirectX86Hva(llvm::Type* T = nullptr) {\n  auto AI = ABIArgInfo::getDirect(T);\n  AI.setInReg(true);\n  AI.setCanBeFlattened(false);\n  return AI;\n}\n\n//===----------------------------------------------------------------------===//\n// X86-32 ABI Implementation\n//===----------------------------------------------------------------------===//\n\n/// Similar to llvm::CCState, but for Clang.\nstruct CCState {\n  CCState(CGFunctionInfo &FI)\n      : IsPreassigned(FI.arg_size()), CC(FI.getCallingConvention()) {}\n\n  llvm::SmallBitVector IsPreassigned;\n  unsigned CC = CallingConv::CC_C;\n  unsigned FreeRegs = 0;\n  unsigned FreeSSERegs = 0;\n};\n\n/// X86_32ABIInfo - The X86-32 ABI information.\nclass X86_32ABIInfo : public SwiftABIInfo {\n  enum Class {\n    Integer,\n    Float\n  };\n\n  static const unsigned MinABIStackAlignInBytes = 4;\n\n  bool IsDarwinVectorABI;\n  bool IsRetSmallStructInRegABI;\n  bool IsWin32StructABI;\n  bool IsSoftFloatABI;\n  bool IsMCUABI;\n  unsigned DefaultNumRegisterParameters;\n\n  static bool isRegisterSize(unsigned Size) {\n    return (Size == 8 || Size == 16 || Size == 32 || Size == 64);\n  }\n\n  bool isHomogeneousAggregateBaseType(QualType Ty) const override {\n    // FIXME: Assumes vectorcall is in use.\n    return isX86VectorTypeForVectorCall(getContext(), Ty);\n  }\n\n  bool isHomogeneousAggregateSmallEnough(const Type *Ty,\n                                         uint64_t NumMembers) const override {\n    // FIXME: Assumes vectorcall is in use.\n    return isX86VectorCallAggregateSmallEnough(NumMembers);\n  }\n\n  bool shouldReturnTypeInRegister(QualType Ty, ASTContext &Context) const;\n\n  /// getIndirectResult - Give a source type \\arg Ty, return a suitable result\n  /// such that the argument will be passed in memory.\n  ABIArgInfo getIndirectResult(QualType Ty, bool ByVal, CCState &State) const;\n\n  ABIArgInfo getIndirectReturnResult(QualType Ty, CCState &State) const;\n\n  /// Return the alignment to use for the given type on the stack.\n  unsigned getTypeStackAlignInBytes(QualType Ty, unsigned Align) const;\n\n  Class classify(QualType Ty) const;\n  ABIArgInfo classifyReturnType(QualType RetTy, CCState &State) const;\n  ABIArgInfo classifyArgumentType(QualType RetTy, CCState &State) const;\n\n  /// Updates the number of available free registers, returns\n  /// true if any registers were allocated.\n  bool updateFreeRegs(QualType Ty, CCState &State) const;\n\n  bool shouldAggregateUseDirect(QualType Ty, CCState &State, bool &InReg,\n                                bool &NeedsPadding) const;\n  bool shouldPrimitiveUseInReg(QualType Ty, CCState &State) const;\n\n  bool canExpandIndirectArgument(QualType Ty) const;\n\n  /// Rewrite the function info so that all memory arguments use\n  /// inalloca.\n  void rewriteWithInAlloca(CGFunctionInfo &FI) const;\n\n  void addFieldToArgStruct(SmallVector<llvm::Type *, 6> &FrameFields,\n                           CharUnits &StackOffset, ABIArgInfo &Info,\n                           QualType Type) const;\n  void runVectorCallFirstPass(CGFunctionInfo &FI, CCState &State) const;\n\npublic:\n\n  void computeInfo(CGFunctionInfo &FI) const override;\n  Address EmitVAArg(CodeGenFunction &CGF, Address VAListAddr,\n                    QualType Ty) const override;\n\n  X86_32ABIInfo(CodeGen::CodeGenTypes &CGT, bool DarwinVectorABI,\n                bool RetSmallStructInRegABI, bool Win32StructABI,\n                unsigned NumRegisterParameters, bool SoftFloatABI)\n    : SwiftABIInfo(CGT), IsDarwinVectorABI(DarwinVectorABI),\n      IsRetSmallStructInRegABI(RetSmallStructInRegABI),\n      IsWin32StructABI(Win32StructABI),\n      IsSoftFloatABI(SoftFloatABI),\n      IsMCUABI(CGT.getTarget().getTriple().isOSIAMCU()),\n      DefaultNumRegisterParameters(NumRegisterParameters) {}\n\n  bool shouldPassIndirectlyForSwift(ArrayRef<llvm::Type*> scalars,\n                                    bool asReturnValue) const override {\n    // LLVM's x86-32 lowering currently only assigns up to three\n    // integer registers and three fp registers.  Oddly, it'll use up to\n    // four vector registers for vectors, but those can overlap with the\n    // scalar registers.\n    return occupiesMoreThan(CGT, scalars, /*total*/ 3);\n  }\n\n  bool isSwiftErrorInRegister() const override {\n    // x86-32 lowering does not support passing swifterror in a register.\n    return false;\n  }\n};\n\nclass X86_32TargetCodeGenInfo : public TargetCodeGenInfo {\npublic:\n  X86_32TargetCodeGenInfo(CodeGen::CodeGenTypes &CGT, bool DarwinVectorABI,\n                          bool RetSmallStructInRegABI, bool Win32StructABI,\n                          unsigned NumRegisterParameters, bool SoftFloatABI)\n      : TargetCodeGenInfo(std::make_unique<X86_32ABIInfo>(\n            CGT, DarwinVectorABI, RetSmallStructInRegABI, Win32StructABI,\n            NumRegisterParameters, SoftFloatABI)) {}\n\n  static bool isStructReturnInRegABI(\n      const llvm::Triple &Triple, const CodeGenOptions &Opts);\n\n  void setTargetAttributes(const Decl *D, llvm::GlobalValue *GV,\n                           CodeGen::CodeGenModule &CGM) const override;\n\n  int getDwarfEHStackPointer(CodeGen::CodeGenModule &CGM) const override {\n    // Darwin uses different dwarf register numbers for EH.\n    if (CGM.getTarget().getTriple().isOSDarwin()) return 5;\n    return 4;\n  }\n\n  bool initDwarfEHRegSizeTable(CodeGen::CodeGenFunction &CGF,\n                               llvm::Value *Address) const override;\n\n  llvm::Type* adjustInlineAsmType(CodeGen::CodeGenFunction &CGF,\n                                  StringRef Constraint,\n                                  llvm::Type* Ty) const override {\n    return X86AdjustInlineAsmType(CGF, Constraint, Ty);\n  }\n\n  void addReturnRegisterOutputs(CodeGenFunction &CGF, LValue ReturnValue,\n                                std::string &Constraints,\n                                std::vector<llvm::Type *> &ResultRegTypes,\n                                std::vector<llvm::Type *> &ResultTruncRegTypes,\n                                std::vector<LValue> &ResultRegDests,\n                                std::string &AsmString,\n                                unsigned NumOutputs) const override;\n\n  llvm::Constant *\n  getUBSanFunctionSignature(CodeGen::CodeGenModule &CGM) const override {\n    unsigned Sig = (0xeb << 0) |  // jmp rel8\n                   (0x06 << 8) |  //           .+0x08\n                   ('v' << 16) |\n                   ('2' << 24);\n    return llvm::ConstantInt::get(CGM.Int32Ty, Sig);\n  }\n\n  StringRef getARCRetainAutoreleasedReturnValueMarker() const override {\n    return \"movl\\t%ebp, %ebp\"\n           \"\\t\\t// marker for objc_retainAutoreleaseReturnValue\";\n  }\n};\n\n}\n\n/// Rewrite input constraint references after adding some output constraints.\n/// In the case where there is one output and one input and we add one output,\n/// we need to replace all operand references greater than or equal to 1:\n///     mov $0, $1\n///     mov eax, $1\n/// The result will be:\n///     mov $0, $2\n///     mov eax, $2\nstatic void rewriteInputConstraintReferences(unsigned FirstIn,\n                                             unsigned NumNewOuts,\n                                             std::string &AsmString) {\n  std::string Buf;\n  llvm::raw_string_ostream OS(Buf);\n  size_t Pos = 0;\n  while (Pos < AsmString.size()) {\n    size_t DollarStart = AsmString.find('$', Pos);\n    if (DollarStart == std::string::npos)\n      DollarStart = AsmString.size();\n    size_t DollarEnd = AsmString.find_first_not_of('$', DollarStart);\n    if (DollarEnd == std::string::npos)\n      DollarEnd = AsmString.size();\n    OS << StringRef(&AsmString[Pos], DollarEnd - Pos);\n    Pos = DollarEnd;\n    size_t NumDollars = DollarEnd - DollarStart;\n    if (NumDollars % 2 != 0 && Pos < AsmString.size()) {\n      // We have an operand reference.\n      size_t DigitStart = Pos;\n      if (AsmString[DigitStart] == '{') {\n        OS << '{';\n        ++DigitStart;\n      }\n      size_t DigitEnd = AsmString.find_first_not_of(\"0123456789\", DigitStart);\n      if (DigitEnd == std::string::npos)\n        DigitEnd = AsmString.size();\n      StringRef OperandStr(&AsmString[DigitStart], DigitEnd - DigitStart);\n      unsigned OperandIndex;\n      if (!OperandStr.getAsInteger(10, OperandIndex)) {\n        if (OperandIndex >= FirstIn)\n          OperandIndex += NumNewOuts;\n        OS << OperandIndex;\n      } else {\n        OS << OperandStr;\n      }\n      Pos = DigitEnd;\n    }\n  }\n  AsmString = std::move(OS.str());\n}\n\n/// Add output constraints for EAX:EDX because they are return registers.\nvoid X86_32TargetCodeGenInfo::addReturnRegisterOutputs(\n    CodeGenFunction &CGF, LValue ReturnSlot, std::string &Constraints,\n    std::vector<llvm::Type *> &ResultRegTypes,\n    std::vector<llvm::Type *> &ResultTruncRegTypes,\n    std::vector<LValue> &ResultRegDests, std::string &AsmString,\n    unsigned NumOutputs) const {\n  uint64_t RetWidth = CGF.getContext().getTypeSize(ReturnSlot.getType());\n\n  // Use the EAX constraint if the width is 32 or smaller and EAX:EDX if it is\n  // larger.\n  if (!Constraints.empty())\n    Constraints += ',';\n  if (RetWidth <= 32) {\n    Constraints += \"={eax}\";\n    ResultRegTypes.push_back(CGF.Int32Ty);\n  } else {\n    // Use the 'A' constraint for EAX:EDX.\n    Constraints += \"=A\";\n    ResultRegTypes.push_back(CGF.Int64Ty);\n  }\n\n  // Truncate EAX or EAX:EDX to an integer of the appropriate size.\n  llvm::Type *CoerceTy = llvm::IntegerType::get(CGF.getLLVMContext(), RetWidth);\n  ResultTruncRegTypes.push_back(CoerceTy);\n\n  // Coerce the integer by bitcasting the return slot pointer.\n  ReturnSlot.setAddress(CGF.Builder.CreateBitCast(ReturnSlot.getAddress(CGF),\n                                                  CoerceTy->getPointerTo()));\n  ResultRegDests.push_back(ReturnSlot);\n\n  rewriteInputConstraintReferences(NumOutputs, 1, AsmString);\n}\n\n/// shouldReturnTypeInRegister - Determine if the given type should be\n/// returned in a register (for the Darwin and MCU ABI).\nbool X86_32ABIInfo::shouldReturnTypeInRegister(QualType Ty,\n                                               ASTContext &Context) const {\n  uint64_t Size = Context.getTypeSize(Ty);\n\n  // For i386, type must be register sized.\n  // For the MCU ABI, it only needs to be <= 8-byte\n  if ((IsMCUABI && Size > 64) || (!IsMCUABI && !isRegisterSize(Size)))\n   return false;\n\n  if (Ty->isVectorType()) {\n    // 64- and 128- bit vectors inside structures are not returned in\n    // registers.\n    if (Size == 64 || Size == 128)\n      return false;\n\n    return true;\n  }\n\n  // If this is a builtin, pointer, enum, complex type, member pointer, or\n  // member function pointer it is ok.\n  if (Ty->getAs<BuiltinType>() || Ty->hasPointerRepresentation() ||\n      Ty->isAnyComplexType() || Ty->isEnumeralType() ||\n      Ty->isBlockPointerType() || Ty->isMemberPointerType())\n    return true;\n\n  // Arrays are treated like records.\n  if (const ConstantArrayType *AT = Context.getAsConstantArrayType(Ty))\n    return shouldReturnTypeInRegister(AT->getElementType(), Context);\n\n  // Otherwise, it must be a record type.\n  const RecordType *RT = Ty->getAs<RecordType>();\n  if (!RT) return false;\n\n  // FIXME: Traverse bases here too.\n\n  // Structure types are passed in register if all fields would be\n  // passed in a register.\n  for (const auto *FD : RT->getDecl()->fields()) {\n    // Empty fields are ignored.\n    if (isEmptyField(Context, FD, true))\n      continue;\n\n    // Check fields recursively.\n    if (!shouldReturnTypeInRegister(FD->getType(), Context))\n      return false;\n  }\n  return true;\n}\n\nstatic bool is32Or64BitBasicType(QualType Ty, ASTContext &Context) {\n  // Treat complex types as the element type.\n  if (const ComplexType *CTy = Ty->getAs<ComplexType>())\n    Ty = CTy->getElementType();\n\n  // Check for a type which we know has a simple scalar argument-passing\n  // convention without any padding.  (We're specifically looking for 32\n  // and 64-bit integer and integer-equivalents, float, and double.)\n  if (!Ty->getAs<BuiltinType>() && !Ty->hasPointerRepresentation() &&\n      !Ty->isEnumeralType() && !Ty->isBlockPointerType())\n    return false;\n\n  uint64_t Size = Context.getTypeSize(Ty);\n  return Size == 32 || Size == 64;\n}\n\nstatic bool addFieldSizes(ASTContext &Context, const RecordDecl *RD,\n                          uint64_t &Size) {\n  for (const auto *FD : RD->fields()) {\n    // Scalar arguments on the stack get 4 byte alignment on x86. If the\n    // argument is smaller than 32-bits, expanding the struct will create\n    // alignment padding.\n    if (!is32Or64BitBasicType(FD->getType(), Context))\n      return false;\n\n    // FIXME: Reject bit-fields wholesale; there are two problems, we don't know\n    // how to expand them yet, and the predicate for telling if a bitfield still\n    // counts as \"basic\" is more complicated than what we were doing previously.\n    if (FD->isBitField())\n      return false;\n\n    Size += Context.getTypeSize(FD->getType());\n  }\n  return true;\n}\n\nstatic bool addBaseAndFieldSizes(ASTContext &Context, const CXXRecordDecl *RD,\n                                 uint64_t &Size) {\n  // Don't do this if there are any non-empty bases.\n  for (const CXXBaseSpecifier &Base : RD->bases()) {\n    if (!addBaseAndFieldSizes(Context, Base.getType()->getAsCXXRecordDecl(),\n                              Size))\n      return false;\n  }\n  if (!addFieldSizes(Context, RD, Size))\n    return false;\n  return true;\n}\n\n/// Test whether an argument type which is to be passed indirectly (on the\n/// stack) would have the equivalent layout if it was expanded into separate\n/// arguments. If so, we prefer to do the latter to avoid inhibiting\n/// optimizations.\nbool X86_32ABIInfo::canExpandIndirectArgument(QualType Ty) const {\n  // We can only expand structure types.\n  const RecordType *RT = Ty->getAs<RecordType>();\n  if (!RT)\n    return false;\n  const RecordDecl *RD = RT->getDecl();\n  uint64_t Size = 0;\n  if (const CXXRecordDecl *CXXRD = dyn_cast<CXXRecordDecl>(RD)) {\n    if (!IsWin32StructABI) {\n      // On non-Windows, we have to conservatively match our old bitcode\n      // prototypes in order to be ABI-compatible at the bitcode level.\n      if (!CXXRD->isCLike())\n        return false;\n    } else {\n      // Don't do this for dynamic classes.\n      if (CXXRD->isDynamicClass())\n        return false;\n    }\n    if (!addBaseAndFieldSizes(getContext(), CXXRD, Size))\n      return false;\n  } else {\n    if (!addFieldSizes(getContext(), RD, Size))\n      return false;\n  }\n\n  // We can do this if there was no alignment padding.\n  return Size == getContext().getTypeSize(Ty);\n}\n\nABIArgInfo X86_32ABIInfo::getIndirectReturnResult(QualType RetTy, CCState &State) const {\n  // If the return value is indirect, then the hidden argument is consuming one\n  // integer register.\n  if (State.FreeRegs) {\n    --State.FreeRegs;\n    if (!IsMCUABI)\n      return getNaturalAlignIndirectInReg(RetTy);\n  }\n  return getNaturalAlignIndirect(RetTy, /*ByVal=*/false);\n}\n\nABIArgInfo X86_32ABIInfo::classifyReturnType(QualType RetTy,\n                                             CCState &State) const {\n  if (RetTy->isVoidType())\n    return ABIArgInfo::getIgnore();\n\n  const Type *Base = nullptr;\n  uint64_t NumElts = 0;\n  if ((State.CC == llvm::CallingConv::X86_VectorCall ||\n       State.CC == llvm::CallingConv::X86_RegCall) &&\n      isHomogeneousAggregate(RetTy, Base, NumElts)) {\n    // The LLVM struct type for such an aggregate should lower properly.\n    return ABIArgInfo::getDirect();\n  }\n\n  if (const VectorType *VT = RetTy->getAs<VectorType>()) {\n    // On Darwin, some vectors are returned in registers.\n    if (IsDarwinVectorABI) {\n      uint64_t Size = getContext().getTypeSize(RetTy);\n\n      // 128-bit vectors are a special case; they are returned in\n      // registers and we need to make sure to pick a type the LLVM\n      // backend will like.\n      if (Size == 128)\n        return ABIArgInfo::getDirect(llvm::FixedVectorType::get(\n            llvm::Type::getInt64Ty(getVMContext()), 2));\n\n      // Always return in register if it fits in a general purpose\n      // register, or if it is 64 bits and has a single element.\n      if ((Size == 8 || Size == 16 || Size == 32) ||\n          (Size == 64 && VT->getNumElements() == 1))\n        return ABIArgInfo::getDirect(llvm::IntegerType::get(getVMContext(),\n                                                            Size));\n\n      return getIndirectReturnResult(RetTy, State);\n    }\n\n    return ABIArgInfo::getDirect();\n  }\n\n  if (isAggregateTypeForABI(RetTy)) {\n    if (const RecordType *RT = RetTy->getAs<RecordType>()) {\n      // Structures with flexible arrays are always indirect.\n      if (RT->getDecl()->hasFlexibleArrayMember())\n        return getIndirectReturnResult(RetTy, State);\n    }\n\n    // If specified, structs and unions are always indirect.\n    if (!IsRetSmallStructInRegABI && !RetTy->isAnyComplexType())\n      return getIndirectReturnResult(RetTy, State);\n\n    // Ignore empty structs/unions.\n    if (isEmptyRecord(getContext(), RetTy, true))\n      return ABIArgInfo::getIgnore();\n\n    // Small structures which are register sized are generally returned\n    // in a register.\n    if (shouldReturnTypeInRegister(RetTy, getContext())) {\n      uint64_t Size = getContext().getTypeSize(RetTy);\n\n      // As a special-case, if the struct is a \"single-element\" struct, and\n      // the field is of type \"float\" or \"double\", return it in a\n      // floating-point register. (MSVC does not apply this special case.)\n      // We apply a similar transformation for pointer types to improve the\n      // quality of the generated IR.\n      if (const Type *SeltTy = isSingleElementStruct(RetTy, getContext()))\n        if ((!IsWin32StructABI && SeltTy->isRealFloatingType())\n            || SeltTy->hasPointerRepresentation())\n          return ABIArgInfo::getDirect(CGT.ConvertType(QualType(SeltTy, 0)));\n\n      // FIXME: We should be able to narrow this integer in cases with dead\n      // padding.\n      return ABIArgInfo::getDirect(llvm::IntegerType::get(getVMContext(),Size));\n    }\n\n    return getIndirectReturnResult(RetTy, State);\n  }\n\n  // Treat an enum type as its underlying type.\n  if (const EnumType *EnumTy = RetTy->getAs<EnumType>())\n    RetTy = EnumTy->getDecl()->getIntegerType();\n\n  if (const auto *EIT = RetTy->getAs<ExtIntType>())\n    if (EIT->getNumBits() > 64)\n      return getIndirectReturnResult(RetTy, State);\n\n  return (isPromotableIntegerTypeForABI(RetTy) ? ABIArgInfo::getExtend(RetTy)\n                                               : ABIArgInfo::getDirect());\n}\n\nstatic bool isSIMDVectorType(ASTContext &Context, QualType Ty) {\n  return Ty->getAs<VectorType>() && Context.getTypeSize(Ty) == 128;\n}\n\nstatic bool isRecordWithSIMDVectorType(ASTContext &Context, QualType Ty) {\n  const RecordType *RT = Ty->getAs<RecordType>();\n  if (!RT)\n    return 0;\n  const RecordDecl *RD = RT->getDecl();\n\n  // If this is a C++ record, check the bases first.\n  if (const CXXRecordDecl *CXXRD = dyn_cast<CXXRecordDecl>(RD))\n    for (const auto &I : CXXRD->bases())\n      if (!isRecordWithSIMDVectorType(Context, I.getType()))\n        return false;\n\n  for (const auto *i : RD->fields()) {\n    QualType FT = i->getType();\n\n    if (isSIMDVectorType(Context, FT))\n      return true;\n\n    if (isRecordWithSIMDVectorType(Context, FT))\n      return true;\n  }\n\n  return false;\n}\n\nunsigned X86_32ABIInfo::getTypeStackAlignInBytes(QualType Ty,\n                                                 unsigned Align) const {\n  // Otherwise, if the alignment is less than or equal to the minimum ABI\n  // alignment, just use the default; the backend will handle this.\n  if (Align <= MinABIStackAlignInBytes)\n    return 0; // Use default alignment.\n\n  // On non-Darwin, the stack type alignment is always 4.\n  if (!IsDarwinVectorABI) {\n    // Set explicit alignment, since we may need to realign the top.\n    return MinABIStackAlignInBytes;\n  }\n\n  // Otherwise, if the type contains an SSE vector type, the alignment is 16.\n  if (Align >= 16 && (isSIMDVectorType(getContext(), Ty) ||\n                      isRecordWithSIMDVectorType(getContext(), Ty)))\n    return 16;\n\n  return MinABIStackAlignInBytes;\n}\n\nABIArgInfo X86_32ABIInfo::getIndirectResult(QualType Ty, bool ByVal,\n                                            CCState &State) const {\n  if (!ByVal) {\n    if (State.FreeRegs) {\n      --State.FreeRegs; // Non-byval indirects just use one pointer.\n      if (!IsMCUABI)\n        return getNaturalAlignIndirectInReg(Ty);\n    }\n    return getNaturalAlignIndirect(Ty, false);\n  }\n\n  // Compute the byval alignment.\n  unsigned TypeAlign = getContext().getTypeAlign(Ty) / 8;\n  unsigned StackAlign = getTypeStackAlignInBytes(Ty, TypeAlign);\n  if (StackAlign == 0)\n    return ABIArgInfo::getIndirect(CharUnits::fromQuantity(4), /*ByVal=*/true);\n\n  // If the stack alignment is less than the type alignment, realign the\n  // argument.\n  bool Realign = TypeAlign > StackAlign;\n  return ABIArgInfo::getIndirect(CharUnits::fromQuantity(StackAlign),\n                                 /*ByVal=*/true, Realign);\n}\n\nX86_32ABIInfo::Class X86_32ABIInfo::classify(QualType Ty) const {\n  const Type *T = isSingleElementStruct(Ty, getContext());\n  if (!T)\n    T = Ty.getTypePtr();\n\n  if (const BuiltinType *BT = T->getAs<BuiltinType>()) {\n    BuiltinType::Kind K = BT->getKind();\n    if (K == BuiltinType::Float || K == BuiltinType::Double)\n      return Float;\n  }\n  return Integer;\n}\n\nbool X86_32ABIInfo::updateFreeRegs(QualType Ty, CCState &State) const {\n  if (!IsSoftFloatABI) {\n    Class C = classify(Ty);\n    if (C == Float)\n      return false;\n  }\n\n  unsigned Size = getContext().getTypeSize(Ty);\n  unsigned SizeInRegs = (Size + 31) / 32;\n\n  if (SizeInRegs == 0)\n    return false;\n\n  if (!IsMCUABI) {\n    if (SizeInRegs > State.FreeRegs) {\n      State.FreeRegs = 0;\n      return false;\n    }\n  } else {\n    // The MCU psABI allows passing parameters in-reg even if there are\n    // earlier parameters that are passed on the stack. Also,\n    // it does not allow passing >8-byte structs in-register,\n    // even if there are 3 free registers available.\n    if (SizeInRegs > State.FreeRegs || SizeInRegs > 2)\n      return false;\n  }\n\n  State.FreeRegs -= SizeInRegs;\n  return true;\n}\n\nbool X86_32ABIInfo::shouldAggregateUseDirect(QualType Ty, CCState &State,\n                                             bool &InReg,\n                                             bool &NeedsPadding) const {\n  // On Windows, aggregates other than HFAs are never passed in registers, and\n  // they do not consume register slots. Homogenous floating-point aggregates\n  // (HFAs) have already been dealt with at this point.\n  if (IsWin32StructABI && isAggregateTypeForABI(Ty))\n    return false;\n\n  NeedsPadding = false;\n  InReg = !IsMCUABI;\n\n  if (!updateFreeRegs(Ty, State))\n    return false;\n\n  if (IsMCUABI)\n    return true;\n\n  if (State.CC == llvm::CallingConv::X86_FastCall ||\n      State.CC == llvm::CallingConv::X86_VectorCall ||\n      State.CC == llvm::CallingConv::X86_RegCall) {\n    if (getContext().getTypeSize(Ty) <= 32 && State.FreeRegs)\n      NeedsPadding = true;\n\n    return false;\n  }\n\n  return true;\n}\n\nbool X86_32ABIInfo::shouldPrimitiveUseInReg(QualType Ty, CCState &State) const {\n  if (!updateFreeRegs(Ty, State))\n    return false;\n\n  if (IsMCUABI)\n    return false;\n\n  if (State.CC == llvm::CallingConv::X86_FastCall ||\n      State.CC == llvm::CallingConv::X86_VectorCall ||\n      State.CC == llvm::CallingConv::X86_RegCall) {\n    if (getContext().getTypeSize(Ty) > 32)\n      return false;\n\n    return (Ty->isIntegralOrEnumerationType() || Ty->isPointerType() ||\n        Ty->isReferenceType());\n  }\n\n  return true;\n}\n\nvoid X86_32ABIInfo::runVectorCallFirstPass(CGFunctionInfo &FI, CCState &State) const {\n  // Vectorcall x86 works subtly different than in x64, so the format is\n  // a bit different than the x64 version.  First, all vector types (not HVAs)\n  // are assigned, with the first 6 ending up in the [XYZ]MM0-5 registers.\n  // This differs from the x64 implementation, where the first 6 by INDEX get\n  // registers.\n  // In the second pass over the arguments, HVAs are passed in the remaining\n  // vector registers if possible, or indirectly by address. The address will be\n  // passed in ECX/EDX if available. Any other arguments are passed according to\n  // the usual fastcall rules.\n  MutableArrayRef<CGFunctionInfoArgInfo> Args = FI.arguments();\n  for (int I = 0, E = Args.size(); I < E; ++I) {\n    const Type *Base = nullptr;\n    uint64_t NumElts = 0;\n    const QualType &Ty = Args[I].type;\n    if ((Ty->isVectorType() || Ty->isBuiltinType()) &&\n        isHomogeneousAggregate(Ty, Base, NumElts)) {\n      if (State.FreeSSERegs >= NumElts) {\n        State.FreeSSERegs -= NumElts;\n        Args[I].info = ABIArgInfo::getDirectInReg();\n        State.IsPreassigned.set(I);\n      }\n    }\n  }\n}\n\nABIArgInfo X86_32ABIInfo::classifyArgumentType(QualType Ty,\n                                               CCState &State) const {\n  // FIXME: Set alignment on indirect arguments.\n  bool IsFastCall = State.CC == llvm::CallingConv::X86_FastCall;\n  bool IsRegCall = State.CC == llvm::CallingConv::X86_RegCall;\n  bool IsVectorCall = State.CC == llvm::CallingConv::X86_VectorCall;\n\n  Ty = useFirstFieldIfTransparentUnion(Ty);\n  TypeInfo TI = getContext().getTypeInfo(Ty);\n\n  // Check with the C++ ABI first.\n  const RecordType *RT = Ty->getAs<RecordType>();\n  if (RT) {\n    CGCXXABI::RecordArgABI RAA = getRecordArgABI(RT, getCXXABI());\n    if (RAA == CGCXXABI::RAA_Indirect) {\n      return getIndirectResult(Ty, false, State);\n    } else if (RAA == CGCXXABI::RAA_DirectInMemory) {\n      // The field index doesn't matter, we'll fix it up later.\n      return ABIArgInfo::getInAlloca(/*FieldIndex=*/0);\n    }\n  }\n\n  // Regcall uses the concept of a homogenous vector aggregate, similar\n  // to other targets.\n  const Type *Base = nullptr;\n  uint64_t NumElts = 0;\n  if ((IsRegCall || IsVectorCall) &&\n      isHomogeneousAggregate(Ty, Base, NumElts)) {\n    if (State.FreeSSERegs >= NumElts) {\n      State.FreeSSERegs -= NumElts;\n\n      // Vectorcall passes HVAs directly and does not flatten them, but regcall\n      // does.\n      if (IsVectorCall)\n        return getDirectX86Hva();\n\n      if (Ty->isBuiltinType() || Ty->isVectorType())\n        return ABIArgInfo::getDirect();\n      return ABIArgInfo::getExpand();\n    }\n    return getIndirectResult(Ty, /*ByVal=*/false, State);\n  }\n\n  if (isAggregateTypeForABI(Ty)) {\n    // Structures with flexible arrays are always indirect.\n    // FIXME: This should not be byval!\n    if (RT && RT->getDecl()->hasFlexibleArrayMember())\n      return getIndirectResult(Ty, true, State);\n\n    // Ignore empty structs/unions on non-Windows.\n    if (!IsWin32StructABI && isEmptyRecord(getContext(), Ty, true))\n      return ABIArgInfo::getIgnore();\n\n    llvm::LLVMContext &LLVMContext = getVMContext();\n    llvm::IntegerType *Int32 = llvm::Type::getInt32Ty(LLVMContext);\n    bool NeedsPadding = false;\n    bool InReg;\n    if (shouldAggregateUseDirect(Ty, State, InReg, NeedsPadding)) {\n      unsigned SizeInRegs = (TI.Width + 31) / 32;\n      SmallVector<llvm::Type*, 3> Elements(SizeInRegs, Int32);\n      llvm::Type *Result = llvm::StructType::get(LLVMContext, Elements);\n      if (InReg)\n        return ABIArgInfo::getDirectInReg(Result);\n      else\n        return ABIArgInfo::getDirect(Result);\n    }\n    llvm::IntegerType *PaddingType = NeedsPadding ? Int32 : nullptr;\n\n    // Pass over-aligned aggregates on Windows indirectly. This behavior was\n    // added in MSVC 2015.\n    if (IsWin32StructABI && TI.AlignIsRequired && TI.Align > 32)\n      return getIndirectResult(Ty, /*ByVal=*/false, State);\n\n    // Expand small (<= 128-bit) record types when we know that the stack layout\n    // of those arguments will match the struct. This is important because the\n    // LLVM backend isn't smart enough to remove byval, which inhibits many\n    // optimizations.\n    // Don't do this for the MCU if there are still free integer registers\n    // (see X86_64 ABI for full explanation).\n    if (TI.Width <= 4 * 32 && (!IsMCUABI || State.FreeRegs == 0) &&\n        canExpandIndirectArgument(Ty))\n      return ABIArgInfo::getExpandWithPadding(\n          IsFastCall || IsVectorCall || IsRegCall, PaddingType);\n\n    return getIndirectResult(Ty, true, State);\n  }\n\n  if (const VectorType *VT = Ty->getAs<VectorType>()) {\n    // On Windows, vectors are passed directly if registers are available, or\n    // indirectly if not. This avoids the need to align argument memory. Pass\n    // user-defined vector types larger than 512 bits indirectly for simplicity.\n    if (IsWin32StructABI) {\n      if (TI.Width <= 512 && State.FreeSSERegs > 0) {\n        --State.FreeSSERegs;\n        return ABIArgInfo::getDirectInReg();\n      }\n      return getIndirectResult(Ty, /*ByVal=*/false, State);\n    }\n\n    // On Darwin, some vectors are passed in memory, we handle this by passing\n    // it as an i8/i16/i32/i64.\n    if (IsDarwinVectorABI) {\n      if ((TI.Width == 8 || TI.Width == 16 || TI.Width == 32) ||\n          (TI.Width == 64 && VT->getNumElements() == 1))\n        return ABIArgInfo::getDirect(\n            llvm::IntegerType::get(getVMContext(), TI.Width));\n    }\n\n    if (IsX86_MMXType(CGT.ConvertType(Ty)))\n      return ABIArgInfo::getDirect(llvm::IntegerType::get(getVMContext(), 64));\n\n    return ABIArgInfo::getDirect();\n  }\n\n\n  if (const EnumType *EnumTy = Ty->getAs<EnumType>())\n    Ty = EnumTy->getDecl()->getIntegerType();\n\n  bool InReg = shouldPrimitiveUseInReg(Ty, State);\n\n  if (isPromotableIntegerTypeForABI(Ty)) {\n    if (InReg)\n      return ABIArgInfo::getExtendInReg(Ty);\n    return ABIArgInfo::getExtend(Ty);\n  }\n\n  if (const auto * EIT = Ty->getAs<ExtIntType>()) {\n    if (EIT->getNumBits() <= 64) {\n      if (InReg)\n        return ABIArgInfo::getDirectInReg();\n      return ABIArgInfo::getDirect();\n    }\n    return getIndirectResult(Ty, /*ByVal=*/false, State);\n  }\n\n  if (InReg)\n    return ABIArgInfo::getDirectInReg();\n  return ABIArgInfo::getDirect();\n}\n\nvoid X86_32ABIInfo::computeInfo(CGFunctionInfo &FI) const {\n  CCState State(FI);\n  if (IsMCUABI)\n    State.FreeRegs = 3;\n  else if (State.CC == llvm::CallingConv::X86_FastCall) {\n    State.FreeRegs = 2;\n    State.FreeSSERegs = 3;\n  } else if (State.CC == llvm::CallingConv::X86_VectorCall) {\n    State.FreeRegs = 2;\n    State.FreeSSERegs = 6;\n  } else if (FI.getHasRegParm())\n    State.FreeRegs = FI.getRegParm();\n  else if (State.CC == llvm::CallingConv::X86_RegCall) {\n    State.FreeRegs = 5;\n    State.FreeSSERegs = 8;\n  } else if (IsWin32StructABI) {\n    // Since MSVC 2015, the first three SSE vectors have been passed in\n    // registers. The rest are passed indirectly.\n    State.FreeRegs = DefaultNumRegisterParameters;\n    State.FreeSSERegs = 3;\n  } else\n    State.FreeRegs = DefaultNumRegisterParameters;\n\n  if (!::classifyReturnType(getCXXABI(), FI, *this)) {\n    FI.getReturnInfo() = classifyReturnType(FI.getReturnType(), State);\n  } else if (FI.getReturnInfo().isIndirect()) {\n    // The C++ ABI is not aware of register usage, so we have to check if the\n    // return value was sret and put it in a register ourselves if appropriate.\n    if (State.FreeRegs) {\n      --State.FreeRegs;  // The sret parameter consumes a register.\n      if (!IsMCUABI)\n        FI.getReturnInfo().setInReg(true);\n    }\n  }\n\n  // The chain argument effectively gives us another free register.\n  if (FI.isChainCall())\n    ++State.FreeRegs;\n\n  // For vectorcall, do a first pass over the arguments, assigning FP and vector\n  // arguments to XMM registers as available.\n  if (State.CC == llvm::CallingConv::X86_VectorCall)\n    runVectorCallFirstPass(FI, State);\n\n  bool UsedInAlloca = false;\n  MutableArrayRef<CGFunctionInfoArgInfo> Args = FI.arguments();\n  for (int I = 0, E = Args.size(); I < E; ++I) {\n    // Skip arguments that have already been assigned.\n    if (State.IsPreassigned.test(I))\n      continue;\n\n    Args[I].info = classifyArgumentType(Args[I].type, State);\n    UsedInAlloca |= (Args[I].info.getKind() == ABIArgInfo::InAlloca);\n  }\n\n  // If we needed to use inalloca for any argument, do a second pass and rewrite\n  // all the memory arguments to use inalloca.\n  if (UsedInAlloca)\n    rewriteWithInAlloca(FI);\n}\n\nvoid\nX86_32ABIInfo::addFieldToArgStruct(SmallVector<llvm::Type *, 6> &FrameFields,\n                                   CharUnits &StackOffset, ABIArgInfo &Info,\n                                   QualType Type) const {\n  // Arguments are always 4-byte-aligned.\n  CharUnits WordSize = CharUnits::fromQuantity(4);\n  assert(StackOffset.isMultipleOf(WordSize) && \"unaligned inalloca struct\");\n\n  // sret pointers and indirect things will require an extra pointer\n  // indirection, unless they are byval. Most things are byval, and will not\n  // require this indirection.\n  bool IsIndirect = false;\n  if (Info.isIndirect() && !Info.getIndirectByVal())\n    IsIndirect = true;\n  Info = ABIArgInfo::getInAlloca(FrameFields.size(), IsIndirect);\n  llvm::Type *LLTy = CGT.ConvertTypeForMem(Type);\n  if (IsIndirect)\n    LLTy = LLTy->getPointerTo(0);\n  FrameFields.push_back(LLTy);\n  StackOffset += IsIndirect ? WordSize : getContext().getTypeSizeInChars(Type);\n\n  // Insert padding bytes to respect alignment.\n  CharUnits FieldEnd = StackOffset;\n  StackOffset = FieldEnd.alignTo(WordSize);\n  if (StackOffset != FieldEnd) {\n    CharUnits NumBytes = StackOffset - FieldEnd;\n    llvm::Type *Ty = llvm::Type::getInt8Ty(getVMContext());\n    Ty = llvm::ArrayType::get(Ty, NumBytes.getQuantity());\n    FrameFields.push_back(Ty);\n  }\n}\n\nstatic bool isArgInAlloca(const ABIArgInfo &Info) {\n  // Leave ignored and inreg arguments alone.\n  switch (Info.getKind()) {\n  case ABIArgInfo::InAlloca:\n    return true;\n  case ABIArgInfo::Ignore:\n  case ABIArgInfo::IndirectAliased:\n    return false;\n  case ABIArgInfo::Indirect:\n  case ABIArgInfo::Direct:\n  case ABIArgInfo::Extend:\n    return !Info.getInReg();\n  case ABIArgInfo::Expand:\n  case ABIArgInfo::CoerceAndExpand:\n    // These are aggregate types which are never passed in registers when\n    // inalloca is involved.\n    return true;\n  }\n  llvm_unreachable(\"invalid enum\");\n}\n\nvoid X86_32ABIInfo::rewriteWithInAlloca(CGFunctionInfo &FI) const {\n  assert(IsWin32StructABI && \"inalloca only supported on win32\");\n\n  // Build a packed struct type for all of the arguments in memory.\n  SmallVector<llvm::Type *, 6> FrameFields;\n\n  // The stack alignment is always 4.\n  CharUnits StackAlign = CharUnits::fromQuantity(4);\n\n  CharUnits StackOffset;\n  CGFunctionInfo::arg_iterator I = FI.arg_begin(), E = FI.arg_end();\n\n  // Put 'this' into the struct before 'sret', if necessary.\n  bool IsThisCall =\n      FI.getCallingConvention() == llvm::CallingConv::X86_ThisCall;\n  ABIArgInfo &Ret = FI.getReturnInfo();\n  if (Ret.isIndirect() && Ret.isSRetAfterThis() && !IsThisCall &&\n      isArgInAlloca(I->info)) {\n    addFieldToArgStruct(FrameFields, StackOffset, I->info, I->type);\n    ++I;\n  }\n\n  // Put the sret parameter into the inalloca struct if it's in memory.\n  if (Ret.isIndirect() && !Ret.getInReg()) {\n    addFieldToArgStruct(FrameFields, StackOffset, Ret, FI.getReturnType());\n    // On Windows, the hidden sret parameter is always returned in eax.\n    Ret.setInAllocaSRet(IsWin32StructABI);\n  }\n\n  // Skip the 'this' parameter in ecx.\n  if (IsThisCall)\n    ++I;\n\n  // Put arguments passed in memory into the struct.\n  for (; I != E; ++I) {\n    if (isArgInAlloca(I->info))\n      addFieldToArgStruct(FrameFields, StackOffset, I->info, I->type);\n  }\n\n  FI.setArgStruct(llvm::StructType::get(getVMContext(), FrameFields,\n                                        /*isPacked=*/true),\n                  StackAlign);\n}\n\nAddress X86_32ABIInfo::EmitVAArg(CodeGenFunction &CGF,\n                                 Address VAListAddr, QualType Ty) const {\n\n  auto TypeInfo = getContext().getTypeInfoInChars(Ty);\n\n  // x86-32 changes the alignment of certain arguments on the stack.\n  //\n  // Just messing with TypeInfo like this works because we never pass\n  // anything indirectly.\n  TypeInfo.Align = CharUnits::fromQuantity(\n                getTypeStackAlignInBytes(Ty, TypeInfo.Align.getQuantity()));\n\n  return emitVoidPtrVAArg(CGF, VAListAddr, Ty, /*Indirect*/ false,\n                          TypeInfo, CharUnits::fromQuantity(4),\n                          /*AllowHigherAlign*/ true);\n}\n\nbool X86_32TargetCodeGenInfo::isStructReturnInRegABI(\n    const llvm::Triple &Triple, const CodeGenOptions &Opts) {\n  assert(Triple.getArch() == llvm::Triple::x86);\n\n  switch (Opts.getStructReturnConvention()) {\n  case CodeGenOptions::SRCK_Default:\n    break;\n  case CodeGenOptions::SRCK_OnStack:  // -fpcc-struct-return\n    return false;\n  case CodeGenOptions::SRCK_InRegs:  // -freg-struct-return\n    return true;\n  }\n\n  if (Triple.isOSDarwin() || Triple.isOSIAMCU())\n    return true;\n\n  switch (Triple.getOS()) {\n  case llvm::Triple::DragonFly:\n  case llvm::Triple::FreeBSD:\n  case llvm::Triple::OpenBSD:\n  case llvm::Triple::Win32:\n    return true;\n  default:\n    return false;\n  }\n}\n\nstatic void addX86InterruptAttrs(const FunctionDecl *FD, llvm::GlobalValue *GV,\n                                 CodeGen::CodeGenModule &CGM) {\n  if (!FD->hasAttr<AnyX86InterruptAttr>())\n    return;\n\n  llvm::Function *Fn = cast<llvm::Function>(GV);\n  Fn->setCallingConv(llvm::CallingConv::X86_INTR);\n  if (FD->getNumParams() == 0)\n    return;\n\n  auto PtrTy = cast<PointerType>(FD->getParamDecl(0)->getType());\n  llvm::Type *ByValTy = CGM.getTypes().ConvertType(PtrTy->getPointeeType());\n  llvm::Attribute NewAttr = llvm::Attribute::getWithByValType(\n    Fn->getContext(), ByValTy);\n  Fn->addParamAttr(0, NewAttr);\n}\n\nvoid X86_32TargetCodeGenInfo::setTargetAttributes(\n    const Decl *D, llvm::GlobalValue *GV, CodeGen::CodeGenModule &CGM) const {\n  if (GV->isDeclaration())\n    return;\n  if (const FunctionDecl *FD = dyn_cast_or_null<FunctionDecl>(D)) {\n    if (FD->hasAttr<X86ForceAlignArgPointerAttr>()) {\n      llvm::Function *Fn = cast<llvm::Function>(GV);\n      Fn->addFnAttr(\"stackrealign\");\n    }\n\n    addX86InterruptAttrs(FD, GV, CGM);\n  }\n}\n\nbool X86_32TargetCodeGenInfo::initDwarfEHRegSizeTable(\n                                               CodeGen::CodeGenFunction &CGF,\n                                               llvm::Value *Address) const {\n  CodeGen::CGBuilderTy &Builder = CGF.Builder;\n\n  llvm::Value *Four8 = llvm::ConstantInt::get(CGF.Int8Ty, 4);\n\n  // 0-7 are the eight integer registers;  the order is different\n  //   on Darwin (for EH), but the range is the same.\n  // 8 is %eip.\n  AssignToArrayRange(Builder, Address, Four8, 0, 8);\n\n  if (CGF.CGM.getTarget().getTriple().isOSDarwin()) {\n    // 12-16 are st(0..4).  Not sure why we stop at 4.\n    // These have size 16, which is sizeof(long double) on\n    // platforms with 8-byte alignment for that type.\n    llvm::Value *Sixteen8 = llvm::ConstantInt::get(CGF.Int8Ty, 16);\n    AssignToArrayRange(Builder, Address, Sixteen8, 12, 16);\n\n  } else {\n    // 9 is %eflags, which doesn't get a size on Darwin for some\n    // reason.\n    Builder.CreateAlignedStore(\n        Four8, Builder.CreateConstInBoundsGEP1_32(CGF.Int8Ty, Address, 9),\n                               CharUnits::One());\n\n    // 11-16 are st(0..5).  Not sure why we stop at 5.\n    // These have size 12, which is sizeof(long double) on\n    // platforms with 4-byte alignment for that type.\n    llvm::Value *Twelve8 = llvm::ConstantInt::get(CGF.Int8Ty, 12);\n    AssignToArrayRange(Builder, Address, Twelve8, 11, 16);\n  }\n\n  return false;\n}\n\n//===----------------------------------------------------------------------===//\n// X86-64 ABI Implementation\n//===----------------------------------------------------------------------===//\n\n\nnamespace {\n/// The AVX ABI level for X86 targets.\nenum class X86AVXABILevel {\n  None,\n  AVX,\n  AVX512\n};\n\n/// \\p returns the size in bits of the largest (native) vector for \\p AVXLevel.\nstatic unsigned getNativeVectorSizeForAVXABI(X86AVXABILevel AVXLevel) {\n  switch (AVXLevel) {\n  case X86AVXABILevel::AVX512:\n    return 512;\n  case X86AVXABILevel::AVX:\n    return 256;\n  case X86AVXABILevel::None:\n    return 128;\n  }\n  llvm_unreachable(\"Unknown AVXLevel\");\n}\n\n/// X86_64ABIInfo - The X86_64 ABI information.\nclass X86_64ABIInfo : public SwiftABIInfo {\n  enum Class {\n    Integer = 0,\n    SSE,\n    SSEUp,\n    X87,\n    X87Up,\n    ComplexX87,\n    NoClass,\n    Memory\n  };\n\n  /// merge - Implement the X86_64 ABI merging algorithm.\n  ///\n  /// Merge an accumulating classification \\arg Accum with a field\n  /// classification \\arg Field.\n  ///\n  /// \\param Accum - The accumulating classification. This should\n  /// always be either NoClass or the result of a previous merge\n  /// call. In addition, this should never be Memory (the caller\n  /// should just return Memory for the aggregate).\n  static Class merge(Class Accum, Class Field);\n\n  /// postMerge - Implement the X86_64 ABI post merging algorithm.\n  ///\n  /// Post merger cleanup, reduces a malformed Hi and Lo pair to\n  /// final MEMORY or SSE classes when necessary.\n  ///\n  /// \\param AggregateSize - The size of the current aggregate in\n  /// the classification process.\n  ///\n  /// \\param Lo - The classification for the parts of the type\n  /// residing in the low word of the containing object.\n  ///\n  /// \\param Hi - The classification for the parts of the type\n  /// residing in the higher words of the containing object.\n  ///\n  void postMerge(unsigned AggregateSize, Class &Lo, Class &Hi) const;\n\n  /// classify - Determine the x86_64 register classes in which the\n  /// given type T should be passed.\n  ///\n  /// \\param Lo - The classification for the parts of the type\n  /// residing in the low word of the containing object.\n  ///\n  /// \\param Hi - The classification for the parts of the type\n  /// residing in the high word of the containing object.\n  ///\n  /// \\param OffsetBase - The bit offset of this type in the\n  /// containing object.  Some parameters are classified different\n  /// depending on whether they straddle an eightbyte boundary.\n  ///\n  /// \\param isNamedArg - Whether the argument in question is a \"named\"\n  /// argument, as used in AMD64-ABI 3.5.7.\n  ///\n  /// If a word is unused its result will be NoClass; if a type should\n  /// be passed in Memory then at least the classification of \\arg Lo\n  /// will be Memory.\n  ///\n  /// The \\arg Lo class will be NoClass iff the argument is ignored.\n  ///\n  /// If the \\arg Lo class is ComplexX87, then the \\arg Hi class will\n  /// also be ComplexX87.\n  void classify(QualType T, uint64_t OffsetBase, Class &Lo, Class &Hi,\n                bool isNamedArg) const;\n\n  llvm::Type *GetByteVectorType(QualType Ty) const;\n  llvm::Type *GetSSETypeAtOffset(llvm::Type *IRType,\n                                 unsigned IROffset, QualType SourceTy,\n                                 unsigned SourceOffset) const;\n  llvm::Type *GetINTEGERTypeAtOffset(llvm::Type *IRType,\n                                     unsigned IROffset, QualType SourceTy,\n                                     unsigned SourceOffset) const;\n\n  /// getIndirectResult - Give a source type \\arg Ty, return a suitable result\n  /// such that the argument will be returned in memory.\n  ABIArgInfo getIndirectReturnResult(QualType Ty) const;\n\n  /// getIndirectResult - Give a source type \\arg Ty, return a suitable result\n  /// such that the argument will be passed in memory.\n  ///\n  /// \\param freeIntRegs - The number of free integer registers remaining\n  /// available.\n  ABIArgInfo getIndirectResult(QualType Ty, unsigned freeIntRegs) const;\n\n  ABIArgInfo classifyReturnType(QualType RetTy) const;\n\n  ABIArgInfo classifyArgumentType(QualType Ty, unsigned freeIntRegs,\n                                  unsigned &neededInt, unsigned &neededSSE,\n                                  bool isNamedArg) const;\n\n  ABIArgInfo classifyRegCallStructType(QualType Ty, unsigned &NeededInt,\n                                       unsigned &NeededSSE) const;\n\n  ABIArgInfo classifyRegCallStructTypeImpl(QualType Ty, unsigned &NeededInt,\n                                           unsigned &NeededSSE) const;\n\n  bool IsIllegalVectorType(QualType Ty) const;\n\n  /// The 0.98 ABI revision clarified a lot of ambiguities,\n  /// unfortunately in ways that were not always consistent with\n  /// certain previous compilers.  In particular, platforms which\n  /// required strict binary compatibility with older versions of GCC\n  /// may need to exempt themselves.\n  bool honorsRevision0_98() const {\n    return !getTarget().getTriple().isOSDarwin();\n  }\n\n  /// GCC classifies <1 x long long> as SSE but some platform ABIs choose to\n  /// classify it as INTEGER (for compatibility with older clang compilers).\n  bool classifyIntegerMMXAsSSE() const {\n    // Clang <= 3.8 did not do this.\n    if (getContext().getLangOpts().getClangABICompat() <=\n        LangOptions::ClangABI::Ver3_8)\n      return false;\n\n    const llvm::Triple &Triple = getTarget().getTriple();\n    if (Triple.isOSDarwin() || Triple.getOS() == llvm::Triple::PS4)\n      return false;\n    if (Triple.isOSFreeBSD() && Triple.getOSMajorVersion() >= 10)\n      return false;\n    return true;\n  }\n\n  // GCC classifies vectors of __int128 as memory.\n  bool passInt128VectorsInMem() const {\n    // Clang <= 9.0 did not do this.\n    if (getContext().getLangOpts().getClangABICompat() <=\n        LangOptions::ClangABI::Ver9)\n      return false;\n\n    const llvm::Triple &T = getTarget().getTriple();\n    return T.isOSLinux() || T.isOSNetBSD();\n  }\n\n  X86AVXABILevel AVXLevel;\n  // Some ABIs (e.g. X32 ABI and Native Client OS) use 32 bit pointers on\n  // 64-bit hardware.\n  bool Has64BitPointers;\n\npublic:\n  X86_64ABIInfo(CodeGen::CodeGenTypes &CGT, X86AVXABILevel AVXLevel) :\n      SwiftABIInfo(CGT), AVXLevel(AVXLevel),\n      Has64BitPointers(CGT.getDataLayout().getPointerSize(0) == 8) {\n  }\n\n  bool isPassedUsingAVXType(QualType type) const {\n    unsigned neededInt, neededSSE;\n    // The freeIntRegs argument doesn't matter here.\n    ABIArgInfo info = classifyArgumentType(type, 0, neededInt, neededSSE,\n                                           /*isNamedArg*/true);\n    if (info.isDirect()) {\n      llvm::Type *ty = info.getCoerceToType();\n      if (llvm::VectorType *vectorTy = dyn_cast_or_null<llvm::VectorType>(ty))\n        return vectorTy->getPrimitiveSizeInBits().getFixedSize() > 128;\n    }\n    return false;\n  }\n\n  void computeInfo(CGFunctionInfo &FI) const override;\n\n  Address EmitVAArg(CodeGenFunction &CGF, Address VAListAddr,\n                    QualType Ty) const override;\n  Address EmitMSVAArg(CodeGenFunction &CGF, Address VAListAddr,\n                      QualType Ty) const override;\n\n  bool has64BitPointers() const {\n    return Has64BitPointers;\n  }\n\n  bool shouldPassIndirectlyForSwift(ArrayRef<llvm::Type*> scalars,\n                                    bool asReturnValue) const override {\n    return occupiesMoreThan(CGT, scalars, /*total*/ 4);\n  }\n  bool isSwiftErrorInRegister() const override {\n    return true;\n  }\n};\n\n/// WinX86_64ABIInfo - The Windows X86_64 ABI information.\nclass WinX86_64ABIInfo : public SwiftABIInfo {\npublic:\n  WinX86_64ABIInfo(CodeGen::CodeGenTypes &CGT, X86AVXABILevel AVXLevel)\n      : SwiftABIInfo(CGT), AVXLevel(AVXLevel),\n        IsMingw64(getTarget().getTriple().isWindowsGNUEnvironment()) {}\n\n  void computeInfo(CGFunctionInfo &FI) const override;\n\n  Address EmitVAArg(CodeGenFunction &CGF, Address VAListAddr,\n                    QualType Ty) const override;\n\n  bool isHomogeneousAggregateBaseType(QualType Ty) const override {\n    // FIXME: Assumes vectorcall is in use.\n    return isX86VectorTypeForVectorCall(getContext(), Ty);\n  }\n\n  bool isHomogeneousAggregateSmallEnough(const Type *Ty,\n                                         uint64_t NumMembers) const override {\n    // FIXME: Assumes vectorcall is in use.\n    return isX86VectorCallAggregateSmallEnough(NumMembers);\n  }\n\n  bool shouldPassIndirectlyForSwift(ArrayRef<llvm::Type *> scalars,\n                                    bool asReturnValue) const override {\n    return occupiesMoreThan(CGT, scalars, /*total*/ 4);\n  }\n\n  bool isSwiftErrorInRegister() const override {\n    return true;\n  }\n\nprivate:\n  ABIArgInfo classify(QualType Ty, unsigned &FreeSSERegs, bool IsReturnType,\n                      bool IsVectorCall, bool IsRegCall) const;\n  ABIArgInfo reclassifyHvaArgForVectorCall(QualType Ty, unsigned &FreeSSERegs,\n                                           const ABIArgInfo &current) const;\n\n  X86AVXABILevel AVXLevel;\n\n  bool IsMingw64;\n};\n\nclass X86_64TargetCodeGenInfo : public TargetCodeGenInfo {\npublic:\n  X86_64TargetCodeGenInfo(CodeGen::CodeGenTypes &CGT, X86AVXABILevel AVXLevel)\n      : TargetCodeGenInfo(std::make_unique<X86_64ABIInfo>(CGT, AVXLevel)) {}\n\n  const X86_64ABIInfo &getABIInfo() const {\n    return static_cast<const X86_64ABIInfo&>(TargetCodeGenInfo::getABIInfo());\n  }\n\n  /// Disable tail call on x86-64. The epilogue code before the tail jump blocks\n  /// autoreleaseRV/retainRV and autoreleaseRV/unsafeClaimRV optimizations.\n  bool markARCOptimizedReturnCallsAsNoTail() const override { return true; }\n\n  int getDwarfEHStackPointer(CodeGen::CodeGenModule &CGM) const override {\n    return 7;\n  }\n\n  bool initDwarfEHRegSizeTable(CodeGen::CodeGenFunction &CGF,\n                               llvm::Value *Address) const override {\n    llvm::Value *Eight8 = llvm::ConstantInt::get(CGF.Int8Ty, 8);\n\n    // 0-15 are the 16 integer registers.\n    // 16 is %rip.\n    AssignToArrayRange(CGF.Builder, Address, Eight8, 0, 16);\n    return false;\n  }\n\n  llvm::Type* adjustInlineAsmType(CodeGen::CodeGenFunction &CGF,\n                                  StringRef Constraint,\n                                  llvm::Type* Ty) const override {\n    return X86AdjustInlineAsmType(CGF, Constraint, Ty);\n  }\n\n  bool isNoProtoCallVariadic(const CallArgList &args,\n                             const FunctionNoProtoType *fnType) const override {\n    // The default CC on x86-64 sets %al to the number of SSA\n    // registers used, and GCC sets this when calling an unprototyped\n    // function, so we override the default behavior.  However, don't do\n    // that when AVX types are involved: the ABI explicitly states it is\n    // undefined, and it doesn't work in practice because of how the ABI\n    // defines varargs anyway.\n    if (fnType->getCallConv() == CC_C) {\n      bool HasAVXType = false;\n      for (CallArgList::const_iterator\n             it = args.begin(), ie = args.end(); it != ie; ++it) {\n        if (getABIInfo().isPassedUsingAVXType(it->Ty)) {\n          HasAVXType = true;\n          break;\n        }\n      }\n\n      if (!HasAVXType)\n        return true;\n    }\n\n    return TargetCodeGenInfo::isNoProtoCallVariadic(args, fnType);\n  }\n\n  llvm::Constant *\n  getUBSanFunctionSignature(CodeGen::CodeGenModule &CGM) const override {\n    unsigned Sig = (0xeb << 0) | // jmp rel8\n                   (0x06 << 8) | //           .+0x08\n                   ('v' << 16) |\n                   ('2' << 24);\n    return llvm::ConstantInt::get(CGM.Int32Ty, Sig);\n  }\n\n  void setTargetAttributes(const Decl *D, llvm::GlobalValue *GV,\n                           CodeGen::CodeGenModule &CGM) const override {\n    if (GV->isDeclaration())\n      return;\n    if (const FunctionDecl *FD = dyn_cast_or_null<FunctionDecl>(D)) {\n      if (FD->hasAttr<X86ForceAlignArgPointerAttr>()) {\n        llvm::Function *Fn = cast<llvm::Function>(GV);\n        Fn->addFnAttr(\"stackrealign\");\n      }\n\n      addX86InterruptAttrs(FD, GV, CGM);\n    }\n  }\n\n  void checkFunctionCallABI(CodeGenModule &CGM, SourceLocation CallLoc,\n                            const FunctionDecl *Caller,\n                            const FunctionDecl *Callee,\n                            const CallArgList &Args) const override;\n};\n\nstatic void initFeatureMaps(const ASTContext &Ctx,\n                            llvm::StringMap<bool> &CallerMap,\n                            const FunctionDecl *Caller,\n                            llvm::StringMap<bool> &CalleeMap,\n                            const FunctionDecl *Callee) {\n  if (CalleeMap.empty() && CallerMap.empty()) {\n    // The caller is potentially nullptr in the case where the call isn't in a\n    // function.  In this case, the getFunctionFeatureMap ensures we just get\n    // the TU level setting (since it cannot be modified by 'target'..\n    Ctx.getFunctionFeatureMap(CallerMap, Caller);\n    Ctx.getFunctionFeatureMap(CalleeMap, Callee);\n  }\n}\n\nstatic bool checkAVXParamFeature(DiagnosticsEngine &Diag,\n                                 SourceLocation CallLoc,\n                                 const llvm::StringMap<bool> &CallerMap,\n                                 const llvm::StringMap<bool> &CalleeMap,\n                                 QualType Ty, StringRef Feature,\n                                 bool IsArgument) {\n  bool CallerHasFeat = CallerMap.lookup(Feature);\n  bool CalleeHasFeat = CalleeMap.lookup(Feature);\n  if (!CallerHasFeat && !CalleeHasFeat)\n    return Diag.Report(CallLoc, diag::warn_avx_calling_convention)\n           << IsArgument << Ty << Feature;\n\n  // Mixing calling conventions here is very clearly an error.\n  if (!CallerHasFeat || !CalleeHasFeat)\n    return Diag.Report(CallLoc, diag::err_avx_calling_convention)\n           << IsArgument << Ty << Feature;\n\n  // Else, both caller and callee have the required feature, so there is no need\n  // to diagnose.\n  return false;\n}\n\nstatic bool checkAVXParam(DiagnosticsEngine &Diag, ASTContext &Ctx,\n                          SourceLocation CallLoc,\n                          const llvm::StringMap<bool> &CallerMap,\n                          const llvm::StringMap<bool> &CalleeMap, QualType Ty,\n                          bool IsArgument) {\n  uint64_t Size = Ctx.getTypeSize(Ty);\n  if (Size > 256)\n    return checkAVXParamFeature(Diag, CallLoc, CallerMap, CalleeMap, Ty,\n                                \"avx512f\", IsArgument);\n\n  if (Size > 128)\n    return checkAVXParamFeature(Diag, CallLoc, CallerMap, CalleeMap, Ty, \"avx\",\n                                IsArgument);\n\n  return false;\n}\n\nvoid X86_64TargetCodeGenInfo::checkFunctionCallABI(\n    CodeGenModule &CGM, SourceLocation CallLoc, const FunctionDecl *Caller,\n    const FunctionDecl *Callee, const CallArgList &Args) const {\n  llvm::StringMap<bool> CallerMap;\n  llvm::StringMap<bool> CalleeMap;\n  unsigned ArgIndex = 0;\n\n  // We need to loop through the actual call arguments rather than the the\n  // function's parameters, in case this variadic.\n  for (const CallArg &Arg : Args) {\n    // The \"avx\" feature changes how vectors >128 in size are passed. \"avx512f\"\n    // additionally changes how vectors >256 in size are passed. Like GCC, we\n    // warn when a function is called with an argument where this will change.\n    // Unlike GCC, we also error when it is an obvious ABI mismatch, that is,\n    // the caller and callee features are mismatched.\n    // Unfortunately, we cannot do this diagnostic in SEMA, since the callee can\n    // change its ABI with attribute-target after this call.\n    if (Arg.getType()->isVectorType() &&\n        CGM.getContext().getTypeSize(Arg.getType()) > 128) {\n      initFeatureMaps(CGM.getContext(), CallerMap, Caller, CalleeMap, Callee);\n      QualType Ty = Arg.getType();\n      // The CallArg seems to have desugared the type already, so for clearer\n      // diagnostics, replace it with the type in the FunctionDecl if possible.\n      if (ArgIndex < Callee->getNumParams())\n        Ty = Callee->getParamDecl(ArgIndex)->getType();\n\n      if (checkAVXParam(CGM.getDiags(), CGM.getContext(), CallLoc, CallerMap,\n                        CalleeMap, Ty, /*IsArgument*/ true))\n        return;\n    }\n    ++ArgIndex;\n  }\n\n  // Check return always, as we don't have a good way of knowing in codegen\n  // whether this value is used, tail-called, etc.\n  if (Callee->getReturnType()->isVectorType() &&\n      CGM.getContext().getTypeSize(Callee->getReturnType()) > 128) {\n    initFeatureMaps(CGM.getContext(), CallerMap, Caller, CalleeMap, Callee);\n    checkAVXParam(CGM.getDiags(), CGM.getContext(), CallLoc, CallerMap,\n                  CalleeMap, Callee->getReturnType(),\n                  /*IsArgument*/ false);\n  }\n}\n\nstatic std::string qualifyWindowsLibrary(llvm::StringRef Lib) {\n  // If the argument does not end in .lib, automatically add the suffix.\n  // If the argument contains a space, enclose it in quotes.\n  // This matches the behavior of MSVC.\n  bool Quote = (Lib.find(' ') != StringRef::npos);\n  std::string ArgStr = Quote ? \"\\\"\" : \"\";\n  ArgStr += Lib;\n  if (!Lib.endswith_lower(\".lib\") && !Lib.endswith_lower(\".a\"))\n    ArgStr += \".lib\";\n  ArgStr += Quote ? \"\\\"\" : \"\";\n  return ArgStr;\n}\n\nclass WinX86_32TargetCodeGenInfo : public X86_32TargetCodeGenInfo {\npublic:\n  WinX86_32TargetCodeGenInfo(CodeGen::CodeGenTypes &CGT,\n        bool DarwinVectorABI, bool RetSmallStructInRegABI, bool Win32StructABI,\n        unsigned NumRegisterParameters)\n    : X86_32TargetCodeGenInfo(CGT, DarwinVectorABI, RetSmallStructInRegABI,\n        Win32StructABI, NumRegisterParameters, false) {}\n\n  void setTargetAttributes(const Decl *D, llvm::GlobalValue *GV,\n                           CodeGen::CodeGenModule &CGM) const override;\n\n  void getDependentLibraryOption(llvm::StringRef Lib,\n                                 llvm::SmallString<24> &Opt) const override {\n    Opt = \"/DEFAULTLIB:\";\n    Opt += qualifyWindowsLibrary(Lib);\n  }\n\n  void getDetectMismatchOption(llvm::StringRef Name,\n                               llvm::StringRef Value,\n                               llvm::SmallString<32> &Opt) const override {\n    Opt = \"/FAILIFMISMATCH:\\\"\" + Name.str() + \"=\" + Value.str() + \"\\\"\";\n  }\n};\n\nstatic void addStackProbeTargetAttributes(const Decl *D, llvm::GlobalValue *GV,\n                                          CodeGen::CodeGenModule &CGM) {\n  if (llvm::Function *Fn = dyn_cast_or_null<llvm::Function>(GV)) {\n\n    if (CGM.getCodeGenOpts().StackProbeSize != 4096)\n      Fn->addFnAttr(\"stack-probe-size\",\n                    llvm::utostr(CGM.getCodeGenOpts().StackProbeSize));\n    if (CGM.getCodeGenOpts().NoStackArgProbe)\n      Fn->addFnAttr(\"no-stack-arg-probe\");\n  }\n}\n\nvoid WinX86_32TargetCodeGenInfo::setTargetAttributes(\n    const Decl *D, llvm::GlobalValue *GV, CodeGen::CodeGenModule &CGM) const {\n  X86_32TargetCodeGenInfo::setTargetAttributes(D, GV, CGM);\n  if (GV->isDeclaration())\n    return;\n  addStackProbeTargetAttributes(D, GV, CGM);\n}\n\nclass WinX86_64TargetCodeGenInfo : public TargetCodeGenInfo {\npublic:\n  WinX86_64TargetCodeGenInfo(CodeGen::CodeGenTypes &CGT,\n                             X86AVXABILevel AVXLevel)\n      : TargetCodeGenInfo(std::make_unique<WinX86_64ABIInfo>(CGT, AVXLevel)) {}\n\n  void setTargetAttributes(const Decl *D, llvm::GlobalValue *GV,\n                           CodeGen::CodeGenModule &CGM) const override;\n\n  int getDwarfEHStackPointer(CodeGen::CodeGenModule &CGM) const override {\n    return 7;\n  }\n\n  bool initDwarfEHRegSizeTable(CodeGen::CodeGenFunction &CGF,\n                               llvm::Value *Address) const override {\n    llvm::Value *Eight8 = llvm::ConstantInt::get(CGF.Int8Ty, 8);\n\n    // 0-15 are the 16 integer registers.\n    // 16 is %rip.\n    AssignToArrayRange(CGF.Builder, Address, Eight8, 0, 16);\n    return false;\n  }\n\n  void getDependentLibraryOption(llvm::StringRef Lib,\n                                 llvm::SmallString<24> &Opt) const override {\n    Opt = \"/DEFAULTLIB:\";\n    Opt += qualifyWindowsLibrary(Lib);\n  }\n\n  void getDetectMismatchOption(llvm::StringRef Name,\n                               llvm::StringRef Value,\n                               llvm::SmallString<32> &Opt) const override {\n    Opt = \"/FAILIFMISMATCH:\\\"\" + Name.str() + \"=\" + Value.str() + \"\\\"\";\n  }\n};\n\nvoid WinX86_64TargetCodeGenInfo::setTargetAttributes(\n    const Decl *D, llvm::GlobalValue *GV, CodeGen::CodeGenModule &CGM) const {\n  TargetCodeGenInfo::setTargetAttributes(D, GV, CGM);\n  if (GV->isDeclaration())\n    return;\n  if (const FunctionDecl *FD = dyn_cast_or_null<FunctionDecl>(D)) {\n    if (FD->hasAttr<X86ForceAlignArgPointerAttr>()) {\n      llvm::Function *Fn = cast<llvm::Function>(GV);\n      Fn->addFnAttr(\"stackrealign\");\n    }\n\n    addX86InterruptAttrs(FD, GV, CGM);\n  }\n\n  addStackProbeTargetAttributes(D, GV, CGM);\n}\n}\n\nvoid X86_64ABIInfo::postMerge(unsigned AggregateSize, Class &Lo,\n                              Class &Hi) const {\n  // AMD64-ABI 3.2.3p2: Rule 5. Then a post merger cleanup is done:\n  //\n  // (a) If one of the classes is Memory, the whole argument is passed in\n  //     memory.\n  //\n  // (b) If X87UP is not preceded by X87, the whole argument is passed in\n  //     memory.\n  //\n  // (c) If the size of the aggregate exceeds two eightbytes and the first\n  //     eightbyte isn't SSE or any other eightbyte isn't SSEUP, the whole\n  //     argument is passed in memory. NOTE: This is necessary to keep the\n  //     ABI working for processors that don't support the __m256 type.\n  //\n  // (d) If SSEUP is not preceded by SSE or SSEUP, it is converted to SSE.\n  //\n  // Some of these are enforced by the merging logic.  Others can arise\n  // only with unions; for example:\n  //   union { _Complex double; unsigned; }\n  //\n  // Note that clauses (b) and (c) were added in 0.98.\n  //\n  if (Hi == Memory)\n    Lo = Memory;\n  if (Hi == X87Up && Lo != X87 && honorsRevision0_98())\n    Lo = Memory;\n  if (AggregateSize > 128 && (Lo != SSE || Hi != SSEUp))\n    Lo = Memory;\n  if (Hi == SSEUp && Lo != SSE)\n    Hi = SSE;\n}\n\nX86_64ABIInfo::Class X86_64ABIInfo::merge(Class Accum, Class Field) {\n  // AMD64-ABI 3.2.3p2: Rule 4. Each field of an object is\n  // classified recursively so that always two fields are\n  // considered. The resulting class is calculated according to\n  // the classes of the fields in the eightbyte:\n  //\n  // (a) If both classes are equal, this is the resulting class.\n  //\n  // (b) If one of the classes is NO_CLASS, the resulting class is\n  // the other class.\n  //\n  // (c) If one of the classes is MEMORY, the result is the MEMORY\n  // class.\n  //\n  // (d) If one of the classes is INTEGER, the result is the\n  // INTEGER.\n  //\n  // (e) If one of the classes is X87, X87UP, COMPLEX_X87 class,\n  // MEMORY is used as class.\n  //\n  // (f) Otherwise class SSE is used.\n\n  // Accum should never be memory (we should have returned) or\n  // ComplexX87 (because this cannot be passed in a structure).\n  assert((Accum != Memory && Accum != ComplexX87) &&\n         \"Invalid accumulated classification during merge.\");\n  if (Accum == Field || Field == NoClass)\n    return Accum;\n  if (Field == Memory)\n    return Memory;\n  if (Accum == NoClass)\n    return Field;\n  if (Accum == Integer || Field == Integer)\n    return Integer;\n  if (Field == X87 || Field == X87Up || Field == ComplexX87 ||\n      Accum == X87 || Accum == X87Up)\n    return Memory;\n  return SSE;\n}\n\nvoid X86_64ABIInfo::classify(QualType Ty, uint64_t OffsetBase,\n                             Class &Lo, Class &Hi, bool isNamedArg) const {\n  // FIXME: This code can be simplified by introducing a simple value class for\n  // Class pairs with appropriate constructor methods for the various\n  // situations.\n\n  // FIXME: Some of the split computations are wrong; unaligned vectors\n  // shouldn't be passed in registers for example, so there is no chance they\n  // can straddle an eightbyte. Verify & simplify.\n\n  Lo = Hi = NoClass;\n\n  Class &Current = OffsetBase < 64 ? Lo : Hi;\n  Current = Memory;\n\n  if (const BuiltinType *BT = Ty->getAs<BuiltinType>()) {\n    BuiltinType::Kind k = BT->getKind();\n\n    if (k == BuiltinType::Void) {\n      Current = NoClass;\n    } else if (k == BuiltinType::Int128 || k == BuiltinType::UInt128) {\n      Lo = Integer;\n      Hi = Integer;\n    } else if (k >= BuiltinType::Bool && k <= BuiltinType::LongLong) {\n      Current = Integer;\n    } else if (k == BuiltinType::Float || k == BuiltinType::Double) {\n      Current = SSE;\n    } else if (k == BuiltinType::LongDouble) {\n      const llvm::fltSemantics *LDF = &getTarget().getLongDoubleFormat();\n      if (LDF == &llvm::APFloat::IEEEquad()) {\n        Lo = SSE;\n        Hi = SSEUp;\n      } else if (LDF == &llvm::APFloat::x87DoubleExtended()) {\n        Lo = X87;\n        Hi = X87Up;\n      } else if (LDF == &llvm::APFloat::IEEEdouble()) {\n        Current = SSE;\n      } else\n        llvm_unreachable(\"unexpected long double representation!\");\n    }\n    // FIXME: _Decimal32 and _Decimal64 are SSE.\n    // FIXME: _float128 and _Decimal128 are (SSE, SSEUp).\n    return;\n  }\n\n  if (const EnumType *ET = Ty->getAs<EnumType>()) {\n    // Classify the underlying integer type.\n    classify(ET->getDecl()->getIntegerType(), OffsetBase, Lo, Hi, isNamedArg);\n    return;\n  }\n\n  if (Ty->hasPointerRepresentation()) {\n    Current = Integer;\n    return;\n  }\n\n  if (Ty->isMemberPointerType()) {\n    if (Ty->isMemberFunctionPointerType()) {\n      if (Has64BitPointers) {\n        // If Has64BitPointers, this is an {i64, i64}, so classify both\n        // Lo and Hi now.\n        Lo = Hi = Integer;\n      } else {\n        // Otherwise, with 32-bit pointers, this is an {i32, i32}. If that\n        // straddles an eightbyte boundary, Hi should be classified as well.\n        uint64_t EB_FuncPtr = (OffsetBase) / 64;\n        uint64_t EB_ThisAdj = (OffsetBase + 64 - 1) / 64;\n        if (EB_FuncPtr != EB_ThisAdj) {\n          Lo = Hi = Integer;\n        } else {\n          Current = Integer;\n        }\n      }\n    } else {\n      Current = Integer;\n    }\n    return;\n  }\n\n  if (const VectorType *VT = Ty->getAs<VectorType>()) {\n    uint64_t Size = getContext().getTypeSize(VT);\n    if (Size == 1 || Size == 8 || Size == 16 || Size == 32) {\n      // gcc passes the following as integer:\n      // 4 bytes - <4 x char>, <2 x short>, <1 x int>, <1 x float>\n      // 2 bytes - <2 x char>, <1 x short>\n      // 1 byte  - <1 x char>\n      Current = Integer;\n\n      // If this type crosses an eightbyte boundary, it should be\n      // split.\n      uint64_t EB_Lo = (OffsetBase) / 64;\n      uint64_t EB_Hi = (OffsetBase + Size - 1) / 64;\n      if (EB_Lo != EB_Hi)\n        Hi = Lo;\n    } else if (Size == 64) {\n      QualType ElementType = VT->getElementType();\n\n      // gcc passes <1 x double> in memory. :(\n      if (ElementType->isSpecificBuiltinType(BuiltinType::Double))\n        return;\n\n      // gcc passes <1 x long long> as SSE but clang used to unconditionally\n      // pass them as integer.  For platforms where clang is the de facto\n      // platform compiler, we must continue to use integer.\n      if (!classifyIntegerMMXAsSSE() &&\n          (ElementType->isSpecificBuiltinType(BuiltinType::LongLong) ||\n           ElementType->isSpecificBuiltinType(BuiltinType::ULongLong) ||\n           ElementType->isSpecificBuiltinType(BuiltinType::Long) ||\n           ElementType->isSpecificBuiltinType(BuiltinType::ULong)))\n        Current = Integer;\n      else\n        Current = SSE;\n\n      // If this type crosses an eightbyte boundary, it should be\n      // split.\n      if (OffsetBase && OffsetBase != 64)\n        Hi = Lo;\n    } else if (Size == 128 ||\n               (isNamedArg && Size <= getNativeVectorSizeForAVXABI(AVXLevel))) {\n      QualType ElementType = VT->getElementType();\n\n      // gcc passes 256 and 512 bit <X x __int128> vectors in memory. :(\n      if (passInt128VectorsInMem() && Size != 128 &&\n          (ElementType->isSpecificBuiltinType(BuiltinType::Int128) ||\n           ElementType->isSpecificBuiltinType(BuiltinType::UInt128)))\n        return;\n\n      // Arguments of 256-bits are split into four eightbyte chunks. The\n      // least significant one belongs to class SSE and all the others to class\n      // SSEUP. The original Lo and Hi design considers that types can't be\n      // greater than 128-bits, so a 64-bit split in Hi and Lo makes sense.\n      // This design isn't correct for 256-bits, but since there're no cases\n      // where the upper parts would need to be inspected, avoid adding\n      // complexity and just consider Hi to match the 64-256 part.\n      //\n      // Note that per 3.5.7 of AMD64-ABI, 256-bit args are only passed in\n      // registers if they are \"named\", i.e. not part of the \"...\" of a\n      // variadic function.\n      //\n      // Similarly, per 3.2.3. of the AVX512 draft, 512-bits (\"named\") args are\n      // split into eight eightbyte chunks, one SSE and seven SSEUP.\n      Lo = SSE;\n      Hi = SSEUp;\n    }\n    return;\n  }\n\n  if (const ComplexType *CT = Ty->getAs<ComplexType>()) {\n    QualType ET = getContext().getCanonicalType(CT->getElementType());\n\n    uint64_t Size = getContext().getTypeSize(Ty);\n    if (ET->isIntegralOrEnumerationType()) {\n      if (Size <= 64)\n        Current = Integer;\n      else if (Size <= 128)\n        Lo = Hi = Integer;\n    } else if (ET == getContext().FloatTy) {\n      Current = SSE;\n    } else if (ET == getContext().DoubleTy) {\n      Lo = Hi = SSE;\n    } else if (ET == getContext().LongDoubleTy) {\n      const llvm::fltSemantics *LDF = &getTarget().getLongDoubleFormat();\n      if (LDF == &llvm::APFloat::IEEEquad())\n        Current = Memory;\n      else if (LDF == &llvm::APFloat::x87DoubleExtended())\n        Current = ComplexX87;\n      else if (LDF == &llvm::APFloat::IEEEdouble())\n        Lo = Hi = SSE;\n      else\n        llvm_unreachable(\"unexpected long double representation!\");\n    }\n\n    // If this complex type crosses an eightbyte boundary then it\n    // should be split.\n    uint64_t EB_Real = (OffsetBase) / 64;\n    uint64_t EB_Imag = (OffsetBase + getContext().getTypeSize(ET)) / 64;\n    if (Hi == NoClass && EB_Real != EB_Imag)\n      Hi = Lo;\n\n    return;\n  }\n\n  if (const auto *EITy = Ty->getAs<ExtIntType>()) {\n    if (EITy->getNumBits() <= 64)\n      Current = Integer;\n    else if (EITy->getNumBits() <= 128)\n      Lo = Hi = Integer;\n    // Larger values need to get passed in memory.\n    return;\n  }\n\n  if (const ConstantArrayType *AT = getContext().getAsConstantArrayType(Ty)) {\n    // Arrays are treated like structures.\n\n    uint64_t Size = getContext().getTypeSize(Ty);\n\n    // AMD64-ABI 3.2.3p2: Rule 1. If the size of an object is larger\n    // than eight eightbytes, ..., it has class MEMORY.\n    if (Size > 512)\n      return;\n\n    // AMD64-ABI 3.2.3p2: Rule 1. If ..., or it contains unaligned\n    // fields, it has class MEMORY.\n    //\n    // Only need to check alignment of array base.\n    if (OffsetBase % getContext().getTypeAlign(AT->getElementType()))\n      return;\n\n    // Otherwise implement simplified merge. We could be smarter about\n    // this, but it isn't worth it and would be harder to verify.\n    Current = NoClass;\n    uint64_t EltSize = getContext().getTypeSize(AT->getElementType());\n    uint64_t ArraySize = AT->getSize().getZExtValue();\n\n    // The only case a 256-bit wide vector could be used is when the array\n    // contains a single 256-bit element. Since Lo and Hi logic isn't extended\n    // to work for sizes wider than 128, early check and fallback to memory.\n    //\n    if (Size > 128 &&\n        (Size != EltSize || Size > getNativeVectorSizeForAVXABI(AVXLevel)))\n      return;\n\n    for (uint64_t i=0, Offset=OffsetBase; i<ArraySize; ++i, Offset += EltSize) {\n      Class FieldLo, FieldHi;\n      classify(AT->getElementType(), Offset, FieldLo, FieldHi, isNamedArg);\n      Lo = merge(Lo, FieldLo);\n      Hi = merge(Hi, FieldHi);\n      if (Lo == Memory || Hi == Memory)\n        break;\n    }\n\n    postMerge(Size, Lo, Hi);\n    assert((Hi != SSEUp || Lo == SSE) && \"Invalid SSEUp array classification.\");\n    return;\n  }\n\n  if (const RecordType *RT = Ty->getAs<RecordType>()) {\n    uint64_t Size = getContext().getTypeSize(Ty);\n\n    // AMD64-ABI 3.2.3p2: Rule 1. If the size of an object is larger\n    // than eight eightbytes, ..., it has class MEMORY.\n    if (Size > 512)\n      return;\n\n    // AMD64-ABI 3.2.3p2: Rule 2. If a C++ object has either a non-trivial\n    // copy constructor or a non-trivial destructor, it is passed by invisible\n    // reference.\n    if (getRecordArgABI(RT, getCXXABI()))\n      return;\n\n    const RecordDecl *RD = RT->getDecl();\n\n    // Assume variable sized types are passed in memory.\n    if (RD->hasFlexibleArrayMember())\n      return;\n\n    const ASTRecordLayout &Layout = getContext().getASTRecordLayout(RD);\n\n    // Reset Lo class, this will be recomputed.\n    Current = NoClass;\n\n    // If this is a C++ record, classify the bases first.\n    if (const CXXRecordDecl *CXXRD = dyn_cast<CXXRecordDecl>(RD)) {\n      for (const auto &I : CXXRD->bases()) {\n        assert(!I.isVirtual() && !I.getType()->isDependentType() &&\n               \"Unexpected base class!\");\n        const auto *Base =\n            cast<CXXRecordDecl>(I.getType()->castAs<RecordType>()->getDecl());\n\n        // Classify this field.\n        //\n        // AMD64-ABI 3.2.3p2: Rule 3. If the size of the aggregate exceeds a\n        // single eightbyte, each is classified separately. Each eightbyte gets\n        // initialized to class NO_CLASS.\n        Class FieldLo, FieldHi;\n        uint64_t Offset =\n          OffsetBase + getContext().toBits(Layout.getBaseClassOffset(Base));\n        classify(I.getType(), Offset, FieldLo, FieldHi, isNamedArg);\n        Lo = merge(Lo, FieldLo);\n        Hi = merge(Hi, FieldHi);\n        if (Lo == Memory || Hi == Memory) {\n          postMerge(Size, Lo, Hi);\n          return;\n        }\n      }\n    }\n\n    // Classify the fields one at a time, merging the results.\n    unsigned idx = 0;\n    bool UseClang11Compat = getContext().getLangOpts().getClangABICompat() <=\n                                LangOptions::ClangABI::Ver11 ||\n                            getContext().getTargetInfo().getTriple().isPS4();\n    bool IsUnion = RT->isUnionType() && !UseClang11Compat;\n\n    for (RecordDecl::field_iterator i = RD->field_begin(), e = RD->field_end();\n           i != e; ++i, ++idx) {\n      uint64_t Offset = OffsetBase + Layout.getFieldOffset(idx);\n      bool BitField = i->isBitField();\n\n      // Ignore padding bit-fields.\n      if (BitField && i->isUnnamedBitfield())\n        continue;\n\n      // AMD64-ABI 3.2.3p2: Rule 1. If the size of an object is larger than\n      // eight eightbytes, or it contains unaligned fields, it has class MEMORY.\n      //\n      // The only case a 256-bit or a 512-bit wide vector could be used is when\n      // the struct contains a single 256-bit or 512-bit element. Early check\n      // and fallback to memory.\n      //\n      // FIXME: Extended the Lo and Hi logic properly to work for size wider\n      // than 128.\n      if (Size > 128 &&\n          ((!IsUnion && Size != getContext().getTypeSize(i->getType())) ||\n           Size > getNativeVectorSizeForAVXABI(AVXLevel))) {\n        Lo = Memory;\n        postMerge(Size, Lo, Hi);\n        return;\n      }\n      // Note, skip this test for bit-fields, see below.\n      if (!BitField && Offset % getContext().getTypeAlign(i->getType())) {\n        Lo = Memory;\n        postMerge(Size, Lo, Hi);\n        return;\n      }\n\n      // Classify this field.\n      //\n      // AMD64-ABI 3.2.3p2: Rule 3. If the size of the aggregate\n      // exceeds a single eightbyte, each is classified\n      // separately. Each eightbyte gets initialized to class\n      // NO_CLASS.\n      Class FieldLo, FieldHi;\n\n      // Bit-fields require special handling, they do not force the\n      // structure to be passed in memory even if unaligned, and\n      // therefore they can straddle an eightbyte.\n      if (BitField) {\n        assert(!i->isUnnamedBitfield());\n        uint64_t Offset = OffsetBase + Layout.getFieldOffset(idx);\n        uint64_t Size = i->getBitWidthValue(getContext());\n\n        uint64_t EB_Lo = Offset / 64;\n        uint64_t EB_Hi = (Offset + Size - 1) / 64;\n\n        if (EB_Lo) {\n          assert(EB_Hi == EB_Lo && \"Invalid classification, type > 16 bytes.\");\n          FieldLo = NoClass;\n          FieldHi = Integer;\n        } else {\n          FieldLo = Integer;\n          FieldHi = EB_Hi ? Integer : NoClass;\n        }\n      } else\n        classify(i->getType(), Offset, FieldLo, FieldHi, isNamedArg);\n      Lo = merge(Lo, FieldLo);\n      Hi = merge(Hi, FieldHi);\n      if (Lo == Memory || Hi == Memory)\n        break;\n    }\n\n    postMerge(Size, Lo, Hi);\n  }\n}\n\nABIArgInfo X86_64ABIInfo::getIndirectReturnResult(QualType Ty) const {\n  // If this is a scalar LLVM value then assume LLVM will pass it in the right\n  // place naturally.\n  if (!isAggregateTypeForABI(Ty)) {\n    // Treat an enum type as its underlying type.\n    if (const EnumType *EnumTy = Ty->getAs<EnumType>())\n      Ty = EnumTy->getDecl()->getIntegerType();\n\n    if (Ty->isExtIntType())\n      return getNaturalAlignIndirect(Ty);\n\n    return (isPromotableIntegerTypeForABI(Ty) ? ABIArgInfo::getExtend(Ty)\n                                              : ABIArgInfo::getDirect());\n  }\n\n  return getNaturalAlignIndirect(Ty);\n}\n\nbool X86_64ABIInfo::IsIllegalVectorType(QualType Ty) const {\n  if (const VectorType *VecTy = Ty->getAs<VectorType>()) {\n    uint64_t Size = getContext().getTypeSize(VecTy);\n    unsigned LargestVector = getNativeVectorSizeForAVXABI(AVXLevel);\n    if (Size <= 64 || Size > LargestVector)\n      return true;\n    QualType EltTy = VecTy->getElementType();\n    if (passInt128VectorsInMem() &&\n        (EltTy->isSpecificBuiltinType(BuiltinType::Int128) ||\n         EltTy->isSpecificBuiltinType(BuiltinType::UInt128)))\n      return true;\n  }\n\n  return false;\n}\n\nABIArgInfo X86_64ABIInfo::getIndirectResult(QualType Ty,\n                                            unsigned freeIntRegs) const {\n  // If this is a scalar LLVM value then assume LLVM will pass it in the right\n  // place naturally.\n  //\n  // This assumption is optimistic, as there could be free registers available\n  // when we need to pass this argument in memory, and LLVM could try to pass\n  // the argument in the free register. This does not seem to happen currently,\n  // but this code would be much safer if we could mark the argument with\n  // 'onstack'. See PR12193.\n  if (!isAggregateTypeForABI(Ty) && !IsIllegalVectorType(Ty) &&\n      !Ty->isExtIntType()) {\n    // Treat an enum type as its underlying type.\n    if (const EnumType *EnumTy = Ty->getAs<EnumType>())\n      Ty = EnumTy->getDecl()->getIntegerType();\n\n    return (isPromotableIntegerTypeForABI(Ty) ? ABIArgInfo::getExtend(Ty)\n                                              : ABIArgInfo::getDirect());\n  }\n\n  if (CGCXXABI::RecordArgABI RAA = getRecordArgABI(Ty, getCXXABI()))\n    return getNaturalAlignIndirect(Ty, RAA == CGCXXABI::RAA_DirectInMemory);\n\n  // Compute the byval alignment. We specify the alignment of the byval in all\n  // cases so that the mid-level optimizer knows the alignment of the byval.\n  unsigned Align = std::max(getContext().getTypeAlign(Ty) / 8, 8U);\n\n  // Attempt to avoid passing indirect results using byval when possible. This\n  // is important for good codegen.\n  //\n  // We do this by coercing the value into a scalar type which the backend can\n  // handle naturally (i.e., without using byval).\n  //\n  // For simplicity, we currently only do this when we have exhausted all of the\n  // free integer registers. Doing this when there are free integer registers\n  // would require more care, as we would have to ensure that the coerced value\n  // did not claim the unused register. That would require either reording the\n  // arguments to the function (so that any subsequent inreg values came first),\n  // or only doing this optimization when there were no following arguments that\n  // might be inreg.\n  //\n  // We currently expect it to be rare (particularly in well written code) for\n  // arguments to be passed on the stack when there are still free integer\n  // registers available (this would typically imply large structs being passed\n  // by value), so this seems like a fair tradeoff for now.\n  //\n  // We can revisit this if the backend grows support for 'onstack' parameter\n  // attributes. See PR12193.\n  if (freeIntRegs == 0) {\n    uint64_t Size = getContext().getTypeSize(Ty);\n\n    // If this type fits in an eightbyte, coerce it into the matching integral\n    // type, which will end up on the stack (with alignment 8).\n    if (Align == 8 && Size <= 64)\n      return ABIArgInfo::getDirect(llvm::IntegerType::get(getVMContext(),\n                                                          Size));\n  }\n\n  return ABIArgInfo::getIndirect(CharUnits::fromQuantity(Align));\n}\n\n/// The ABI specifies that a value should be passed in a full vector XMM/YMM\n/// register. Pick an LLVM IR type that will be passed as a vector register.\nllvm::Type *X86_64ABIInfo::GetByteVectorType(QualType Ty) const {\n  // Wrapper structs/arrays that only contain vectors are passed just like\n  // vectors; strip them off if present.\n  if (const Type *InnerTy = isSingleElementStruct(Ty, getContext()))\n    Ty = QualType(InnerTy, 0);\n\n  llvm::Type *IRType = CGT.ConvertType(Ty);\n  if (isa<llvm::VectorType>(IRType)) {\n    // Don't pass vXi128 vectors in their native type, the backend can't\n    // legalize them.\n    if (passInt128VectorsInMem() &&\n        cast<llvm::VectorType>(IRType)->getElementType()->isIntegerTy(128)) {\n      // Use a vXi64 vector.\n      uint64_t Size = getContext().getTypeSize(Ty);\n      return llvm::FixedVectorType::get(llvm::Type::getInt64Ty(getVMContext()),\n                                        Size / 64);\n    }\n\n    return IRType;\n  }\n\n  if (IRType->getTypeID() == llvm::Type::FP128TyID)\n    return IRType;\n\n  // We couldn't find the preferred IR vector type for 'Ty'.\n  uint64_t Size = getContext().getTypeSize(Ty);\n  assert((Size == 128 || Size == 256 || Size == 512) && \"Invalid type found!\");\n\n\n  // Return a LLVM IR vector type based on the size of 'Ty'.\n  return llvm::FixedVectorType::get(llvm::Type::getDoubleTy(getVMContext()),\n                                    Size / 64);\n}\n\n/// BitsContainNoUserData - Return true if the specified [start,end) bit range\n/// is known to either be off the end of the specified type or being in\n/// alignment padding.  The user type specified is known to be at most 128 bits\n/// in size, and have passed through X86_64ABIInfo::classify with a successful\n/// classification that put one of the two halves in the INTEGER class.\n///\n/// It is conservatively correct to return false.\nstatic bool BitsContainNoUserData(QualType Ty, unsigned StartBit,\n                                  unsigned EndBit, ASTContext &Context) {\n  // If the bytes being queried are off the end of the type, there is no user\n  // data hiding here.  This handles analysis of builtins, vectors and other\n  // types that don't contain interesting padding.\n  unsigned TySize = (unsigned)Context.getTypeSize(Ty);\n  if (TySize <= StartBit)\n    return true;\n\n  if (const ConstantArrayType *AT = Context.getAsConstantArrayType(Ty)) {\n    unsigned EltSize = (unsigned)Context.getTypeSize(AT->getElementType());\n    unsigned NumElts = (unsigned)AT->getSize().getZExtValue();\n\n    // Check each element to see if the element overlaps with the queried range.\n    for (unsigned i = 0; i != NumElts; ++i) {\n      // If the element is after the span we care about, then we're done..\n      unsigned EltOffset = i*EltSize;\n      if (EltOffset >= EndBit) break;\n\n      unsigned EltStart = EltOffset < StartBit ? StartBit-EltOffset :0;\n      if (!BitsContainNoUserData(AT->getElementType(), EltStart,\n                                 EndBit-EltOffset, Context))\n        return false;\n    }\n    // If it overlaps no elements, then it is safe to process as padding.\n    return true;\n  }\n\n  if (const RecordType *RT = Ty->getAs<RecordType>()) {\n    const RecordDecl *RD = RT->getDecl();\n    const ASTRecordLayout &Layout = Context.getASTRecordLayout(RD);\n\n    // If this is a C++ record, check the bases first.\n    if (const CXXRecordDecl *CXXRD = dyn_cast<CXXRecordDecl>(RD)) {\n      for (const auto &I : CXXRD->bases()) {\n        assert(!I.isVirtual() && !I.getType()->isDependentType() &&\n               \"Unexpected base class!\");\n        const auto *Base =\n            cast<CXXRecordDecl>(I.getType()->castAs<RecordType>()->getDecl());\n\n        // If the base is after the span we care about, ignore it.\n        unsigned BaseOffset = Context.toBits(Layout.getBaseClassOffset(Base));\n        if (BaseOffset >= EndBit) continue;\n\n        unsigned BaseStart = BaseOffset < StartBit ? StartBit-BaseOffset :0;\n        if (!BitsContainNoUserData(I.getType(), BaseStart,\n                                   EndBit-BaseOffset, Context))\n          return false;\n      }\n    }\n\n    // Verify that no field has data that overlaps the region of interest.  Yes\n    // this could be sped up a lot by being smarter about queried fields,\n    // however we're only looking at structs up to 16 bytes, so we don't care\n    // much.\n    unsigned idx = 0;\n    for (RecordDecl::field_iterator i = RD->field_begin(), e = RD->field_end();\n         i != e; ++i, ++idx) {\n      unsigned FieldOffset = (unsigned)Layout.getFieldOffset(idx);\n\n      // If we found a field after the region we care about, then we're done.\n      if (FieldOffset >= EndBit) break;\n\n      unsigned FieldStart = FieldOffset < StartBit ? StartBit-FieldOffset :0;\n      if (!BitsContainNoUserData(i->getType(), FieldStart, EndBit-FieldOffset,\n                                 Context))\n        return false;\n    }\n\n    // If nothing in this record overlapped the area of interest, then we're\n    // clean.\n    return true;\n  }\n\n  return false;\n}\n\n/// ContainsFloatAtOffset - Return true if the specified LLVM IR type has a\n/// float member at the specified offset.  For example, {int,{float}} has a\n/// float at offset 4.  It is conservatively correct for this routine to return\n/// false.\nstatic bool ContainsFloatAtOffset(llvm::Type *IRType, unsigned IROffset,\n                                  const llvm::DataLayout &TD) {\n  // Base case if we find a float.\n  if (IROffset == 0 && IRType->isFloatTy())\n    return true;\n\n  // If this is a struct, recurse into the field at the specified offset.\n  if (llvm::StructType *STy = dyn_cast<llvm::StructType>(IRType)) {\n    const llvm::StructLayout *SL = TD.getStructLayout(STy);\n    unsigned Elt = SL->getElementContainingOffset(IROffset);\n    IROffset -= SL->getElementOffset(Elt);\n    return ContainsFloatAtOffset(STy->getElementType(Elt), IROffset, TD);\n  }\n\n  // If this is an array, recurse into the field at the specified offset.\n  if (llvm::ArrayType *ATy = dyn_cast<llvm::ArrayType>(IRType)) {\n    llvm::Type *EltTy = ATy->getElementType();\n    unsigned EltSize = TD.getTypeAllocSize(EltTy);\n    IROffset -= IROffset/EltSize*EltSize;\n    return ContainsFloatAtOffset(EltTy, IROffset, TD);\n  }\n\n  return false;\n}\n\n\n/// GetSSETypeAtOffset - Return a type that will be passed by the backend in the\n/// low 8 bytes of an XMM register, corresponding to the SSE class.\nllvm::Type *X86_64ABIInfo::\nGetSSETypeAtOffset(llvm::Type *IRType, unsigned IROffset,\n                   QualType SourceTy, unsigned SourceOffset) const {\n  // The only three choices we have are either double, <2 x float>, or float. We\n  // pass as float if the last 4 bytes is just padding.  This happens for\n  // structs that contain 3 floats.\n  if (BitsContainNoUserData(SourceTy, SourceOffset*8+32,\n                            SourceOffset*8+64, getContext()))\n    return llvm::Type::getFloatTy(getVMContext());\n\n  // We want to pass as <2 x float> if the LLVM IR type contains a float at\n  // offset+0 and offset+4.  Walk the LLVM IR type to find out if this is the\n  // case.\n  if (ContainsFloatAtOffset(IRType, IROffset, getDataLayout()) &&\n      ContainsFloatAtOffset(IRType, IROffset+4, getDataLayout()))\n    return llvm::FixedVectorType::get(llvm::Type::getFloatTy(getVMContext()),\n                                      2);\n\n  return llvm::Type::getDoubleTy(getVMContext());\n}\n\n\n/// GetINTEGERTypeAtOffset - The ABI specifies that a value should be passed in\n/// an 8-byte GPR.  This means that we either have a scalar or we are talking\n/// about the high or low part of an up-to-16-byte struct.  This routine picks\n/// the best LLVM IR type to represent this, which may be i64 or may be anything\n/// else that the backend will pass in a GPR that works better (e.g. i8, %foo*,\n/// etc).\n///\n/// PrefType is an LLVM IR type that corresponds to (part of) the IR type for\n/// the source type.  IROffset is an offset in bytes into the LLVM IR type that\n/// the 8-byte value references.  PrefType may be null.\n///\n/// SourceTy is the source-level type for the entire argument.  SourceOffset is\n/// an offset into this that we're processing (which is always either 0 or 8).\n///\nllvm::Type *X86_64ABIInfo::\nGetINTEGERTypeAtOffset(llvm::Type *IRType, unsigned IROffset,\n                       QualType SourceTy, unsigned SourceOffset) const {\n  // If we're dealing with an un-offset LLVM IR type, then it means that we're\n  // returning an 8-byte unit starting with it.  See if we can safely use it.\n  if (IROffset == 0) {\n    // Pointers and int64's always fill the 8-byte unit.\n    if ((isa<llvm::PointerType>(IRType) && Has64BitPointers) ||\n        IRType->isIntegerTy(64))\n      return IRType;\n\n    // If we have a 1/2/4-byte integer, we can use it only if the rest of the\n    // goodness in the source type is just tail padding.  This is allowed to\n    // kick in for struct {double,int} on the int, but not on\n    // struct{double,int,int} because we wouldn't return the second int.  We\n    // have to do this analysis on the source type because we can't depend on\n    // unions being lowered a specific way etc.\n    if (IRType->isIntegerTy(8) || IRType->isIntegerTy(16) ||\n        IRType->isIntegerTy(32) ||\n        (isa<llvm::PointerType>(IRType) && !Has64BitPointers)) {\n      unsigned BitWidth = isa<llvm::PointerType>(IRType) ? 32 :\n          cast<llvm::IntegerType>(IRType)->getBitWidth();\n\n      if (BitsContainNoUserData(SourceTy, SourceOffset*8+BitWidth,\n                                SourceOffset*8+64, getContext()))\n        return IRType;\n    }\n  }\n\n  if (llvm::StructType *STy = dyn_cast<llvm::StructType>(IRType)) {\n    // If this is a struct, recurse into the field at the specified offset.\n    const llvm::StructLayout *SL = getDataLayout().getStructLayout(STy);\n    if (IROffset < SL->getSizeInBytes()) {\n      unsigned FieldIdx = SL->getElementContainingOffset(IROffset);\n      IROffset -= SL->getElementOffset(FieldIdx);\n\n      return GetINTEGERTypeAtOffset(STy->getElementType(FieldIdx), IROffset,\n                                    SourceTy, SourceOffset);\n    }\n  }\n\n  if (llvm::ArrayType *ATy = dyn_cast<llvm::ArrayType>(IRType)) {\n    llvm::Type *EltTy = ATy->getElementType();\n    unsigned EltSize = getDataLayout().getTypeAllocSize(EltTy);\n    unsigned EltOffset = IROffset/EltSize*EltSize;\n    return GetINTEGERTypeAtOffset(EltTy, IROffset-EltOffset, SourceTy,\n                                  SourceOffset);\n  }\n\n  // Okay, we don't have any better idea of what to pass, so we pass this in an\n  // integer register that isn't too big to fit the rest of the struct.\n  unsigned TySizeInBytes =\n    (unsigned)getContext().getTypeSizeInChars(SourceTy).getQuantity();\n\n  assert(TySizeInBytes != SourceOffset && \"Empty field?\");\n\n  // It is always safe to classify this as an integer type up to i64 that\n  // isn't larger than the structure.\n  return llvm::IntegerType::get(getVMContext(),\n                                std::min(TySizeInBytes-SourceOffset, 8U)*8);\n}\n\n\n/// GetX86_64ByValArgumentPair - Given a high and low type that can ideally\n/// be used as elements of a two register pair to pass or return, return a\n/// first class aggregate to represent them.  For example, if the low part of\n/// a by-value argument should be passed as i32* and the high part as float,\n/// return {i32*, float}.\nstatic llvm::Type *\nGetX86_64ByValArgumentPair(llvm::Type *Lo, llvm::Type *Hi,\n                           const llvm::DataLayout &TD) {\n  // In order to correctly satisfy the ABI, we need to the high part to start\n  // at offset 8.  If the high and low parts we inferred are both 4-byte types\n  // (e.g. i32 and i32) then the resultant struct type ({i32,i32}) won't have\n  // the second element at offset 8.  Check for this:\n  unsigned LoSize = (unsigned)TD.getTypeAllocSize(Lo);\n  unsigned HiAlign = TD.getABITypeAlignment(Hi);\n  unsigned HiStart = llvm::alignTo(LoSize, HiAlign);\n  assert(HiStart != 0 && HiStart <= 8 && \"Invalid x86-64 argument pair!\");\n\n  // To handle this, we have to increase the size of the low part so that the\n  // second element will start at an 8 byte offset.  We can't increase the size\n  // of the second element because it might make us access off the end of the\n  // struct.\n  if (HiStart != 8) {\n    // There are usually two sorts of types the ABI generation code can produce\n    // for the low part of a pair that aren't 8 bytes in size: float or\n    // i8/i16/i32.  This can also include pointers when they are 32-bit (X32 and\n    // NaCl).\n    // Promote these to a larger type.\n    if (Lo->isFloatTy())\n      Lo = llvm::Type::getDoubleTy(Lo->getContext());\n    else {\n      assert((Lo->isIntegerTy() || Lo->isPointerTy())\n             && \"Invalid/unknown lo type\");\n      Lo = llvm::Type::getInt64Ty(Lo->getContext());\n    }\n  }\n\n  llvm::StructType *Result = llvm::StructType::get(Lo, Hi);\n\n  // Verify that the second element is at an 8-byte offset.\n  assert(TD.getStructLayout(Result)->getElementOffset(1) == 8 &&\n         \"Invalid x86-64 argument pair!\");\n  return Result;\n}\n\nABIArgInfo X86_64ABIInfo::\nclassifyReturnType(QualType RetTy) const {\n  // AMD64-ABI 3.2.3p4: Rule 1. Classify the return type with the\n  // classification algorithm.\n  X86_64ABIInfo::Class Lo, Hi;\n  classify(RetTy, 0, Lo, Hi, /*isNamedArg*/ true);\n\n  // Check some invariants.\n  assert((Hi != Memory || Lo == Memory) && \"Invalid memory classification.\");\n  assert((Hi != SSEUp || Lo == SSE) && \"Invalid SSEUp classification.\");\n\n  llvm::Type *ResType = nullptr;\n  switch (Lo) {\n  case NoClass:\n    if (Hi == NoClass)\n      return ABIArgInfo::getIgnore();\n    // If the low part is just padding, it takes no register, leave ResType\n    // null.\n    assert((Hi == SSE || Hi == Integer || Hi == X87Up) &&\n           \"Unknown missing lo part\");\n    break;\n\n  case SSEUp:\n  case X87Up:\n    llvm_unreachable(\"Invalid classification for lo word.\");\n\n    // AMD64-ABI 3.2.3p4: Rule 2. Types of class memory are returned via\n    // hidden argument.\n  case Memory:\n    return getIndirectReturnResult(RetTy);\n\n    // AMD64-ABI 3.2.3p4: Rule 3. If the class is INTEGER, the next\n    // available register of the sequence %rax, %rdx is used.\n  case Integer:\n    ResType = GetINTEGERTypeAtOffset(CGT.ConvertType(RetTy), 0, RetTy, 0);\n\n    // If we have a sign or zero extended integer, make sure to return Extend\n    // so that the parameter gets the right LLVM IR attributes.\n    if (Hi == NoClass && isa<llvm::IntegerType>(ResType)) {\n      // Treat an enum type as its underlying type.\n      if (const EnumType *EnumTy = RetTy->getAs<EnumType>())\n        RetTy = EnumTy->getDecl()->getIntegerType();\n\n      if (RetTy->isIntegralOrEnumerationType() &&\n          isPromotableIntegerTypeForABI(RetTy))\n        return ABIArgInfo::getExtend(RetTy);\n    }\n    break;\n\n    // AMD64-ABI 3.2.3p4: Rule 4. If the class is SSE, the next\n    // available SSE register of the sequence %xmm0, %xmm1 is used.\n  case SSE:\n    ResType = GetSSETypeAtOffset(CGT.ConvertType(RetTy), 0, RetTy, 0);\n    break;\n\n    // AMD64-ABI 3.2.3p4: Rule 6. If the class is X87, the value is\n    // returned on the X87 stack in %st0 as 80-bit x87 number.\n  case X87:\n    ResType = llvm::Type::getX86_FP80Ty(getVMContext());\n    break;\n\n    // AMD64-ABI 3.2.3p4: Rule 8. If the class is COMPLEX_X87, the real\n    // part of the value is returned in %st0 and the imaginary part in\n    // %st1.\n  case ComplexX87:\n    assert(Hi == ComplexX87 && \"Unexpected ComplexX87 classification.\");\n    ResType = llvm::StructType::get(llvm::Type::getX86_FP80Ty(getVMContext()),\n                                    llvm::Type::getX86_FP80Ty(getVMContext()));\n    break;\n  }\n\n  llvm::Type *HighPart = nullptr;\n  switch (Hi) {\n    // Memory was handled previously and X87 should\n    // never occur as a hi class.\n  case Memory:\n  case X87:\n    llvm_unreachable(\"Invalid classification for hi word.\");\n\n  case ComplexX87: // Previously handled.\n  case NoClass:\n    break;\n\n  case Integer:\n    HighPart = GetINTEGERTypeAtOffset(CGT.ConvertType(RetTy), 8, RetTy, 8);\n    if (Lo == NoClass)  // Return HighPart at offset 8 in memory.\n      return ABIArgInfo::getDirect(HighPart, 8);\n    break;\n  case SSE:\n    HighPart = GetSSETypeAtOffset(CGT.ConvertType(RetTy), 8, RetTy, 8);\n    if (Lo == NoClass)  // Return HighPart at offset 8 in memory.\n      return ABIArgInfo::getDirect(HighPart, 8);\n    break;\n\n    // AMD64-ABI 3.2.3p4: Rule 5. If the class is SSEUP, the eightbyte\n    // is passed in the next available eightbyte chunk if the last used\n    // vector register.\n    //\n    // SSEUP should always be preceded by SSE, just widen.\n  case SSEUp:\n    assert(Lo == SSE && \"Unexpected SSEUp classification.\");\n    ResType = GetByteVectorType(RetTy);\n    break;\n\n    // AMD64-ABI 3.2.3p4: Rule 7. If the class is X87UP, the value is\n    // returned together with the previous X87 value in %st0.\n  case X87Up:\n    // If X87Up is preceded by X87, we don't need to do\n    // anything. However, in some cases with unions it may not be\n    // preceded by X87. In such situations we follow gcc and pass the\n    // extra bits in an SSE reg.\n    if (Lo != X87) {\n      HighPart = GetSSETypeAtOffset(CGT.ConvertType(RetTy), 8, RetTy, 8);\n      if (Lo == NoClass)  // Return HighPart at offset 8 in memory.\n        return ABIArgInfo::getDirect(HighPart, 8);\n    }\n    break;\n  }\n\n  // If a high part was specified, merge it together with the low part.  It is\n  // known to pass in the high eightbyte of the result.  We do this by forming a\n  // first class struct aggregate with the high and low part: {low, high}\n  if (HighPart)\n    ResType = GetX86_64ByValArgumentPair(ResType, HighPart, getDataLayout());\n\n  return ABIArgInfo::getDirect(ResType);\n}\n\nABIArgInfo X86_64ABIInfo::classifyArgumentType(\n  QualType Ty, unsigned freeIntRegs, unsigned &neededInt, unsigned &neededSSE,\n  bool isNamedArg)\n  const\n{\n  Ty = useFirstFieldIfTransparentUnion(Ty);\n\n  X86_64ABIInfo::Class Lo, Hi;\n  classify(Ty, 0, Lo, Hi, isNamedArg);\n\n  // Check some invariants.\n  // FIXME: Enforce these by construction.\n  assert((Hi != Memory || Lo == Memory) && \"Invalid memory classification.\");\n  assert((Hi != SSEUp || Lo == SSE) && \"Invalid SSEUp classification.\");\n\n  neededInt = 0;\n  neededSSE = 0;\n  llvm::Type *ResType = nullptr;\n  switch (Lo) {\n  case NoClass:\n    if (Hi == NoClass)\n      return ABIArgInfo::getIgnore();\n    // If the low part is just padding, it takes no register, leave ResType\n    // null.\n    assert((Hi == SSE || Hi == Integer || Hi == X87Up) &&\n           \"Unknown missing lo part\");\n    break;\n\n    // AMD64-ABI 3.2.3p3: Rule 1. If the class is MEMORY, pass the argument\n    // on the stack.\n  case Memory:\n\n    // AMD64-ABI 3.2.3p3: Rule 5. If the class is X87, X87UP or\n    // COMPLEX_X87, it is passed in memory.\n  case X87:\n  case ComplexX87:\n    if (getRecordArgABI(Ty, getCXXABI()) == CGCXXABI::RAA_Indirect)\n      ++neededInt;\n    return getIndirectResult(Ty, freeIntRegs);\n\n  case SSEUp:\n  case X87Up:\n    llvm_unreachable(\"Invalid classification for lo word.\");\n\n    // AMD64-ABI 3.2.3p3: Rule 2. If the class is INTEGER, the next\n    // available register of the sequence %rdi, %rsi, %rdx, %rcx, %r8\n    // and %r9 is used.\n  case Integer:\n    ++neededInt;\n\n    // Pick an 8-byte type based on the preferred type.\n    ResType = GetINTEGERTypeAtOffset(CGT.ConvertType(Ty), 0, Ty, 0);\n\n    // If we have a sign or zero extended integer, make sure to return Extend\n    // so that the parameter gets the right LLVM IR attributes.\n    if (Hi == NoClass && isa<llvm::IntegerType>(ResType)) {\n      // Treat an enum type as its underlying type.\n      if (const EnumType *EnumTy = Ty->getAs<EnumType>())\n        Ty = EnumTy->getDecl()->getIntegerType();\n\n      if (Ty->isIntegralOrEnumerationType() &&\n          isPromotableIntegerTypeForABI(Ty))\n        return ABIArgInfo::getExtend(Ty);\n    }\n\n    break;\n\n    // AMD64-ABI 3.2.3p3: Rule 3. If the class is SSE, the next\n    // available SSE register is used, the registers are taken in the\n    // order from %xmm0 to %xmm7.\n  case SSE: {\n    llvm::Type *IRType = CGT.ConvertType(Ty);\n    ResType = GetSSETypeAtOffset(IRType, 0, Ty, 0);\n    ++neededSSE;\n    break;\n  }\n  }\n\n  llvm::Type *HighPart = nullptr;\n  switch (Hi) {\n    // Memory was handled previously, ComplexX87 and X87 should\n    // never occur as hi classes, and X87Up must be preceded by X87,\n    // which is passed in memory.\n  case Memory:\n  case X87:\n  case ComplexX87:\n    llvm_unreachable(\"Invalid classification for hi word.\");\n\n  case NoClass: break;\n\n  case Integer:\n    ++neededInt;\n    // Pick an 8-byte type based on the preferred type.\n    HighPart = GetINTEGERTypeAtOffset(CGT.ConvertType(Ty), 8, Ty, 8);\n\n    if (Lo == NoClass)  // Pass HighPart at offset 8 in memory.\n      return ABIArgInfo::getDirect(HighPart, 8);\n    break;\n\n    // X87Up generally doesn't occur here (long double is passed in\n    // memory), except in situations involving unions.\n  case X87Up:\n  case SSE:\n    HighPart = GetSSETypeAtOffset(CGT.ConvertType(Ty), 8, Ty, 8);\n\n    if (Lo == NoClass)  // Pass HighPart at offset 8 in memory.\n      return ABIArgInfo::getDirect(HighPart, 8);\n\n    ++neededSSE;\n    break;\n\n    // AMD64-ABI 3.2.3p3: Rule 4. If the class is SSEUP, the\n    // eightbyte is passed in the upper half of the last used SSE\n    // register.  This only happens when 128-bit vectors are passed.\n  case SSEUp:\n    assert(Lo == SSE && \"Unexpected SSEUp classification\");\n    ResType = GetByteVectorType(Ty);\n    break;\n  }\n\n  // If a high part was specified, merge it together with the low part.  It is\n  // known to pass in the high eightbyte of the result.  We do this by forming a\n  // first class struct aggregate with the high and low part: {low, high}\n  if (HighPart)\n    ResType = GetX86_64ByValArgumentPair(ResType, HighPart, getDataLayout());\n\n  return ABIArgInfo::getDirect(ResType);\n}\n\nABIArgInfo\nX86_64ABIInfo::classifyRegCallStructTypeImpl(QualType Ty, unsigned &NeededInt,\n                                             unsigned &NeededSSE) const {\n  auto RT = Ty->getAs<RecordType>();\n  assert(RT && \"classifyRegCallStructType only valid with struct types\");\n\n  if (RT->getDecl()->hasFlexibleArrayMember())\n    return getIndirectReturnResult(Ty);\n\n  // Sum up bases\n  if (auto CXXRD = dyn_cast<CXXRecordDecl>(RT->getDecl())) {\n    if (CXXRD->isDynamicClass()) {\n      NeededInt = NeededSSE = 0;\n      return getIndirectReturnResult(Ty);\n    }\n\n    for (const auto &I : CXXRD->bases())\n      if (classifyRegCallStructTypeImpl(I.getType(), NeededInt, NeededSSE)\n              .isIndirect()) {\n        NeededInt = NeededSSE = 0;\n        return getIndirectReturnResult(Ty);\n      }\n  }\n\n  // Sum up members\n  for (const auto *FD : RT->getDecl()->fields()) {\n    if (FD->getType()->isRecordType() && !FD->getType()->isUnionType()) {\n      if (classifyRegCallStructTypeImpl(FD->getType(), NeededInt, NeededSSE)\n              .isIndirect()) {\n        NeededInt = NeededSSE = 0;\n        return getIndirectReturnResult(Ty);\n      }\n    } else {\n      unsigned LocalNeededInt, LocalNeededSSE;\n      if (classifyArgumentType(FD->getType(), UINT_MAX, LocalNeededInt,\n                               LocalNeededSSE, true)\n              .isIndirect()) {\n        NeededInt = NeededSSE = 0;\n        return getIndirectReturnResult(Ty);\n      }\n      NeededInt += LocalNeededInt;\n      NeededSSE += LocalNeededSSE;\n    }\n  }\n\n  return ABIArgInfo::getDirect();\n}\n\nABIArgInfo X86_64ABIInfo::classifyRegCallStructType(QualType Ty,\n                                                    unsigned &NeededInt,\n                                                    unsigned &NeededSSE) const {\n\n  NeededInt = 0;\n  NeededSSE = 0;\n\n  return classifyRegCallStructTypeImpl(Ty, NeededInt, NeededSSE);\n}\n\nvoid X86_64ABIInfo::computeInfo(CGFunctionInfo &FI) const {\n\n  const unsigned CallingConv = FI.getCallingConvention();\n  // It is possible to force Win64 calling convention on any x86_64 target by\n  // using __attribute__((ms_abi)). In such case to correctly emit Win64\n  // compatible code delegate this call to WinX86_64ABIInfo::computeInfo.\n  if (CallingConv == llvm::CallingConv::Win64) {\n    WinX86_64ABIInfo Win64ABIInfo(CGT, AVXLevel);\n    Win64ABIInfo.computeInfo(FI);\n    return;\n  }\n\n  bool IsRegCall = CallingConv == llvm::CallingConv::X86_RegCall;\n\n  // Keep track of the number of assigned registers.\n  unsigned FreeIntRegs = IsRegCall ? 11 : 6;\n  unsigned FreeSSERegs = IsRegCall ? 16 : 8;\n  unsigned NeededInt, NeededSSE;\n\n  if (!::classifyReturnType(getCXXABI(), FI, *this)) {\n    if (IsRegCall && FI.getReturnType()->getTypePtr()->isRecordType() &&\n        !FI.getReturnType()->getTypePtr()->isUnionType()) {\n      FI.getReturnInfo() =\n          classifyRegCallStructType(FI.getReturnType(), NeededInt, NeededSSE);\n      if (FreeIntRegs >= NeededInt && FreeSSERegs >= NeededSSE) {\n        FreeIntRegs -= NeededInt;\n        FreeSSERegs -= NeededSSE;\n      } else {\n        FI.getReturnInfo() = getIndirectReturnResult(FI.getReturnType());\n      }\n    } else if (IsRegCall && FI.getReturnType()->getAs<ComplexType>() &&\n               getContext().getCanonicalType(FI.getReturnType()\n                                                 ->getAs<ComplexType>()\n                                                 ->getElementType()) ==\n                   getContext().LongDoubleTy)\n      // Complex Long Double Type is passed in Memory when Regcall\n      // calling convention is used.\n      FI.getReturnInfo() = getIndirectReturnResult(FI.getReturnType());\n    else\n      FI.getReturnInfo() = classifyReturnType(FI.getReturnType());\n  }\n\n  // If the return value is indirect, then the hidden argument is consuming one\n  // integer register.\n  if (FI.getReturnInfo().isIndirect())\n    --FreeIntRegs;\n\n  // The chain argument effectively gives us another free register.\n  if (FI.isChainCall())\n    ++FreeIntRegs;\n\n  unsigned NumRequiredArgs = FI.getNumRequiredArgs();\n  // AMD64-ABI 3.2.3p3: Once arguments are classified, the registers\n  // get assigned (in left-to-right order) for passing as follows...\n  unsigned ArgNo = 0;\n  for (CGFunctionInfo::arg_iterator it = FI.arg_begin(), ie = FI.arg_end();\n       it != ie; ++it, ++ArgNo) {\n    bool IsNamedArg = ArgNo < NumRequiredArgs;\n\n    if (IsRegCall && it->type->isStructureOrClassType())\n      it->info = classifyRegCallStructType(it->type, NeededInt, NeededSSE);\n    else\n      it->info = classifyArgumentType(it->type, FreeIntRegs, NeededInt,\n                                      NeededSSE, IsNamedArg);\n\n    // AMD64-ABI 3.2.3p3: If there are no registers available for any\n    // eightbyte of an argument, the whole argument is passed on the\n    // stack. If registers have already been assigned for some\n    // eightbytes of such an argument, the assignments get reverted.\n    if (FreeIntRegs >= NeededInt && FreeSSERegs >= NeededSSE) {\n      FreeIntRegs -= NeededInt;\n      FreeSSERegs -= NeededSSE;\n    } else {\n      it->info = getIndirectResult(it->type, FreeIntRegs);\n    }\n  }\n}\n\nstatic Address EmitX86_64VAArgFromMemory(CodeGenFunction &CGF,\n                                         Address VAListAddr, QualType Ty) {\n  Address overflow_arg_area_p =\n      CGF.Builder.CreateStructGEP(VAListAddr, 2, \"overflow_arg_area_p\");\n  llvm::Value *overflow_arg_area =\n    CGF.Builder.CreateLoad(overflow_arg_area_p, \"overflow_arg_area\");\n\n  // AMD64-ABI 3.5.7p5: Step 7. Align l->overflow_arg_area upwards to a 16\n  // byte boundary if alignment needed by type exceeds 8 byte boundary.\n  // It isn't stated explicitly in the standard, but in practice we use\n  // alignment greater than 16 where necessary.\n  CharUnits Align = CGF.getContext().getTypeAlignInChars(Ty);\n  if (Align > CharUnits::fromQuantity(8)) {\n    overflow_arg_area = emitRoundPointerUpToAlignment(CGF, overflow_arg_area,\n                                                      Align);\n  }\n\n  // AMD64-ABI 3.5.7p5: Step 8. Fetch type from l->overflow_arg_area.\n  llvm::Type *LTy = CGF.ConvertTypeForMem(Ty);\n  llvm::Value *Res =\n    CGF.Builder.CreateBitCast(overflow_arg_area,\n                              llvm::PointerType::getUnqual(LTy));\n\n  // AMD64-ABI 3.5.7p5: Step 9. Set l->overflow_arg_area to:\n  // l->overflow_arg_area + sizeof(type).\n  // AMD64-ABI 3.5.7p5: Step 10. Align l->overflow_arg_area upwards to\n  // an 8 byte boundary.\n\n  uint64_t SizeInBytes = (CGF.getContext().getTypeSize(Ty) + 7) / 8;\n  llvm::Value *Offset =\n      llvm::ConstantInt::get(CGF.Int32Ty, (SizeInBytes + 7)  & ~7);\n  overflow_arg_area = CGF.Builder.CreateGEP(overflow_arg_area, Offset,\n                                            \"overflow_arg_area.next\");\n  CGF.Builder.CreateStore(overflow_arg_area, overflow_arg_area_p);\n\n  // AMD64-ABI 3.5.7p5: Step 11. Return the fetched type.\n  return Address(Res, Align);\n}\n\nAddress X86_64ABIInfo::EmitVAArg(CodeGenFunction &CGF, Address VAListAddr,\n                                 QualType Ty) const {\n  // Assume that va_list type is correct; should be pointer to LLVM type:\n  // struct {\n  //   i32 gp_offset;\n  //   i32 fp_offset;\n  //   i8* overflow_arg_area;\n  //   i8* reg_save_area;\n  // };\n  unsigned neededInt, neededSSE;\n\n  Ty = getContext().getCanonicalType(Ty);\n  ABIArgInfo AI = classifyArgumentType(Ty, 0, neededInt, neededSSE,\n                                       /*isNamedArg*/false);\n\n  // AMD64-ABI 3.5.7p5: Step 1. Determine whether type may be passed\n  // in the registers. If not go to step 7.\n  if (!neededInt && !neededSSE)\n    return EmitX86_64VAArgFromMemory(CGF, VAListAddr, Ty);\n\n  // AMD64-ABI 3.5.7p5: Step 2. Compute num_gp to hold the number of\n  // general purpose registers needed to pass type and num_fp to hold\n  // the number of floating point registers needed.\n\n  // AMD64-ABI 3.5.7p5: Step 3. Verify whether arguments fit into\n  // registers. In the case: l->gp_offset > 48 - num_gp * 8 or\n  // l->fp_offset > 304 - num_fp * 16 go to step 7.\n  //\n  // NOTE: 304 is a typo, there are (6 * 8 + 8 * 16) = 176 bytes of\n  // register save space).\n\n  llvm::Value *InRegs = nullptr;\n  Address gp_offset_p = Address::invalid(), fp_offset_p = Address::invalid();\n  llvm::Value *gp_offset = nullptr, *fp_offset = nullptr;\n  if (neededInt) {\n    gp_offset_p = CGF.Builder.CreateStructGEP(VAListAddr, 0, \"gp_offset_p\");\n    gp_offset = CGF.Builder.CreateLoad(gp_offset_p, \"gp_offset\");\n    InRegs = llvm::ConstantInt::get(CGF.Int32Ty, 48 - neededInt * 8);\n    InRegs = CGF.Builder.CreateICmpULE(gp_offset, InRegs, \"fits_in_gp\");\n  }\n\n  if (neededSSE) {\n    fp_offset_p = CGF.Builder.CreateStructGEP(VAListAddr, 1, \"fp_offset_p\");\n    fp_offset = CGF.Builder.CreateLoad(fp_offset_p, \"fp_offset\");\n    llvm::Value *FitsInFP =\n      llvm::ConstantInt::get(CGF.Int32Ty, 176 - neededSSE * 16);\n    FitsInFP = CGF.Builder.CreateICmpULE(fp_offset, FitsInFP, \"fits_in_fp\");\n    InRegs = InRegs ? CGF.Builder.CreateAnd(InRegs, FitsInFP) : FitsInFP;\n  }\n\n  llvm::BasicBlock *InRegBlock = CGF.createBasicBlock(\"vaarg.in_reg\");\n  llvm::BasicBlock *InMemBlock = CGF.createBasicBlock(\"vaarg.in_mem\");\n  llvm::BasicBlock *ContBlock = CGF.createBasicBlock(\"vaarg.end\");\n  CGF.Builder.CreateCondBr(InRegs, InRegBlock, InMemBlock);\n\n  // Emit code to load the value if it was passed in registers.\n\n  CGF.EmitBlock(InRegBlock);\n\n  // AMD64-ABI 3.5.7p5: Step 4. Fetch type from l->reg_save_area with\n  // an offset of l->gp_offset and/or l->fp_offset. This may require\n  // copying to a temporary location in case the parameter is passed\n  // in different register classes or requires an alignment greater\n  // than 8 for general purpose registers and 16 for XMM registers.\n  //\n  // FIXME: This really results in shameful code when we end up needing to\n  // collect arguments from different places; often what should result in a\n  // simple assembling of a structure from scattered addresses has many more\n  // loads than necessary. Can we clean this up?\n  llvm::Type *LTy = CGF.ConvertTypeForMem(Ty);\n  llvm::Value *RegSaveArea = CGF.Builder.CreateLoad(\n      CGF.Builder.CreateStructGEP(VAListAddr, 3), \"reg_save_area\");\n\n  Address RegAddr = Address::invalid();\n  if (neededInt && neededSSE) {\n    // FIXME: Cleanup.\n    assert(AI.isDirect() && \"Unexpected ABI info for mixed regs\");\n    llvm::StructType *ST = cast<llvm::StructType>(AI.getCoerceToType());\n    Address Tmp = CGF.CreateMemTemp(Ty);\n    Tmp = CGF.Builder.CreateElementBitCast(Tmp, ST);\n    assert(ST->getNumElements() == 2 && \"Unexpected ABI info for mixed regs\");\n    llvm::Type *TyLo = ST->getElementType(0);\n    llvm::Type *TyHi = ST->getElementType(1);\n    assert((TyLo->isFPOrFPVectorTy() ^ TyHi->isFPOrFPVectorTy()) &&\n           \"Unexpected ABI info for mixed regs\");\n    llvm::Type *PTyLo = llvm::PointerType::getUnqual(TyLo);\n    llvm::Type *PTyHi = llvm::PointerType::getUnqual(TyHi);\n    llvm::Value *GPAddr = CGF.Builder.CreateGEP(RegSaveArea, gp_offset);\n    llvm::Value *FPAddr = CGF.Builder.CreateGEP(RegSaveArea, fp_offset);\n    llvm::Value *RegLoAddr = TyLo->isFPOrFPVectorTy() ? FPAddr : GPAddr;\n    llvm::Value *RegHiAddr = TyLo->isFPOrFPVectorTy() ? GPAddr : FPAddr;\n\n    // Copy the first element.\n    // FIXME: Our choice of alignment here and below is probably pessimistic.\n    llvm::Value *V = CGF.Builder.CreateAlignedLoad(\n        TyLo, CGF.Builder.CreateBitCast(RegLoAddr, PTyLo),\n        CharUnits::fromQuantity(getDataLayout().getABITypeAlignment(TyLo)));\n    CGF.Builder.CreateStore(V, CGF.Builder.CreateStructGEP(Tmp, 0));\n\n    // Copy the second element.\n    V = CGF.Builder.CreateAlignedLoad(\n        TyHi, CGF.Builder.CreateBitCast(RegHiAddr, PTyHi),\n        CharUnits::fromQuantity(getDataLayout().getABITypeAlignment(TyHi)));\n    CGF.Builder.CreateStore(V, CGF.Builder.CreateStructGEP(Tmp, 1));\n\n    RegAddr = CGF.Builder.CreateElementBitCast(Tmp, LTy);\n  } else if (neededInt) {\n    RegAddr = Address(CGF.Builder.CreateGEP(RegSaveArea, gp_offset),\n                      CharUnits::fromQuantity(8));\n    RegAddr = CGF.Builder.CreateElementBitCast(RegAddr, LTy);\n\n    // Copy to a temporary if necessary to ensure the appropriate alignment.\n    auto TInfo = getContext().getTypeInfoInChars(Ty);\n    uint64_t TySize = TInfo.Width.getQuantity();\n    CharUnits TyAlign = TInfo.Align;\n\n    // Copy into a temporary if the type is more aligned than the\n    // register save area.\n    if (TyAlign.getQuantity() > 8) {\n      Address Tmp = CGF.CreateMemTemp(Ty);\n      CGF.Builder.CreateMemCpy(Tmp, RegAddr, TySize, false);\n      RegAddr = Tmp;\n    }\n\n  } else if (neededSSE == 1) {\n    RegAddr = Address(CGF.Builder.CreateGEP(RegSaveArea, fp_offset),\n                      CharUnits::fromQuantity(16));\n    RegAddr = CGF.Builder.CreateElementBitCast(RegAddr, LTy);\n  } else {\n    assert(neededSSE == 2 && \"Invalid number of needed registers!\");\n    // SSE registers are spaced 16 bytes apart in the register save\n    // area, we need to collect the two eightbytes together.\n    // The ABI isn't explicit about this, but it seems reasonable\n    // to assume that the slots are 16-byte aligned, since the stack is\n    // naturally 16-byte aligned and the prologue is expected to store\n    // all the SSE registers to the RSA.\n    Address RegAddrLo = Address(CGF.Builder.CreateGEP(RegSaveArea, fp_offset),\n                                CharUnits::fromQuantity(16));\n    Address RegAddrHi =\n      CGF.Builder.CreateConstInBoundsByteGEP(RegAddrLo,\n                                             CharUnits::fromQuantity(16));\n    llvm::Type *ST = AI.canHaveCoerceToType()\n                         ? AI.getCoerceToType()\n                         : llvm::StructType::get(CGF.DoubleTy, CGF.DoubleTy);\n    llvm::Value *V;\n    Address Tmp = CGF.CreateMemTemp(Ty);\n    Tmp = CGF.Builder.CreateElementBitCast(Tmp, ST);\n    V = CGF.Builder.CreateLoad(CGF.Builder.CreateElementBitCast(\n        RegAddrLo, ST->getStructElementType(0)));\n    CGF.Builder.CreateStore(V, CGF.Builder.CreateStructGEP(Tmp, 0));\n    V = CGF.Builder.CreateLoad(CGF.Builder.CreateElementBitCast(\n        RegAddrHi, ST->getStructElementType(1)));\n    CGF.Builder.CreateStore(V, CGF.Builder.CreateStructGEP(Tmp, 1));\n\n    RegAddr = CGF.Builder.CreateElementBitCast(Tmp, LTy);\n  }\n\n  // AMD64-ABI 3.5.7p5: Step 5. Set:\n  // l->gp_offset = l->gp_offset + num_gp * 8\n  // l->fp_offset = l->fp_offset + num_fp * 16.\n  if (neededInt) {\n    llvm::Value *Offset = llvm::ConstantInt::get(CGF.Int32Ty, neededInt * 8);\n    CGF.Builder.CreateStore(CGF.Builder.CreateAdd(gp_offset, Offset),\n                            gp_offset_p);\n  }\n  if (neededSSE) {\n    llvm::Value *Offset = llvm::ConstantInt::get(CGF.Int32Ty, neededSSE * 16);\n    CGF.Builder.CreateStore(CGF.Builder.CreateAdd(fp_offset, Offset),\n                            fp_offset_p);\n  }\n  CGF.EmitBranch(ContBlock);\n\n  // Emit code to load the value if it was passed in memory.\n\n  CGF.EmitBlock(InMemBlock);\n  Address MemAddr = EmitX86_64VAArgFromMemory(CGF, VAListAddr, Ty);\n\n  // Return the appropriate result.\n\n  CGF.EmitBlock(ContBlock);\n  Address ResAddr = emitMergePHI(CGF, RegAddr, InRegBlock, MemAddr, InMemBlock,\n                                 \"vaarg.addr\");\n  return ResAddr;\n}\n\nAddress X86_64ABIInfo::EmitMSVAArg(CodeGenFunction &CGF, Address VAListAddr,\n                                   QualType Ty) const {\n  return emitVoidPtrVAArg(CGF, VAListAddr, Ty, /*indirect*/ false,\n                          CGF.getContext().getTypeInfoInChars(Ty),\n                          CharUnits::fromQuantity(8),\n                          /*allowHigherAlign*/ false);\n}\n\nABIArgInfo WinX86_64ABIInfo::reclassifyHvaArgForVectorCall(\n    QualType Ty, unsigned &FreeSSERegs, const ABIArgInfo &current) const {\n  const Type *Base = nullptr;\n  uint64_t NumElts = 0;\n\n  if (!Ty->isBuiltinType() && !Ty->isVectorType() &&\n      isHomogeneousAggregate(Ty, Base, NumElts) && FreeSSERegs >= NumElts) {\n    FreeSSERegs -= NumElts;\n    return getDirectX86Hva();\n  }\n  return current;\n}\n\nABIArgInfo WinX86_64ABIInfo::classify(QualType Ty, unsigned &FreeSSERegs,\n                                      bool IsReturnType, bool IsVectorCall,\n                                      bool IsRegCall) const {\n\n  if (Ty->isVoidType())\n    return ABIArgInfo::getIgnore();\n\n  if (const EnumType *EnumTy = Ty->getAs<EnumType>())\n    Ty = EnumTy->getDecl()->getIntegerType();\n\n  TypeInfo Info = getContext().getTypeInfo(Ty);\n  uint64_t Width = Info.Width;\n  CharUnits Align = getContext().toCharUnitsFromBits(Info.Align);\n\n  const RecordType *RT = Ty->getAs<RecordType>();\n  if (RT) {\n    if (!IsReturnType) {\n      if (CGCXXABI::RecordArgABI RAA = getRecordArgABI(RT, getCXXABI()))\n        return getNaturalAlignIndirect(Ty, RAA == CGCXXABI::RAA_DirectInMemory);\n    }\n\n    if (RT->getDecl()->hasFlexibleArrayMember())\n      return getNaturalAlignIndirect(Ty, /*ByVal=*/false);\n\n  }\n\n  const Type *Base = nullptr;\n  uint64_t NumElts = 0;\n  // vectorcall adds the concept of a homogenous vector aggregate, similar to\n  // other targets.\n  if ((IsVectorCall || IsRegCall) &&\n      isHomogeneousAggregate(Ty, Base, NumElts)) {\n    if (IsRegCall) {\n      if (FreeSSERegs >= NumElts) {\n        FreeSSERegs -= NumElts;\n        if (IsReturnType || Ty->isBuiltinType() || Ty->isVectorType())\n          return ABIArgInfo::getDirect();\n        return ABIArgInfo::getExpand();\n      }\n      return ABIArgInfo::getIndirect(Align, /*ByVal=*/false);\n    } else if (IsVectorCall) {\n      if (FreeSSERegs >= NumElts &&\n          (IsReturnType || Ty->isBuiltinType() || Ty->isVectorType())) {\n        FreeSSERegs -= NumElts;\n        return ABIArgInfo::getDirect();\n      } else if (IsReturnType) {\n        return ABIArgInfo::getExpand();\n      } else if (!Ty->isBuiltinType() && !Ty->isVectorType()) {\n        // HVAs are delayed and reclassified in the 2nd step.\n        return ABIArgInfo::getIndirect(Align, /*ByVal=*/false);\n      }\n    }\n  }\n\n  if (Ty->isMemberPointerType()) {\n    // If the member pointer is represented by an LLVM int or ptr, pass it\n    // directly.\n    llvm::Type *LLTy = CGT.ConvertType(Ty);\n    if (LLTy->isPointerTy() || LLTy->isIntegerTy())\n      return ABIArgInfo::getDirect();\n  }\n\n  if (RT || Ty->isAnyComplexType() || Ty->isMemberPointerType()) {\n    // MS x64 ABI requirement: \"Any argument that doesn't fit in 8 bytes, or is\n    // not 1, 2, 4, or 8 bytes, must be passed by reference.\"\n    if (Width > 64 || !llvm::isPowerOf2_64(Width))\n      return getNaturalAlignIndirect(Ty, /*ByVal=*/false);\n\n    // Otherwise, coerce it to a small integer.\n    return ABIArgInfo::getDirect(llvm::IntegerType::get(getVMContext(), Width));\n  }\n\n  if (const BuiltinType *BT = Ty->getAs<BuiltinType>()) {\n    switch (BT->getKind()) {\n    case BuiltinType::Bool:\n      // Bool type is always extended to the ABI, other builtin types are not\n      // extended.\n      return ABIArgInfo::getExtend(Ty);\n\n    case BuiltinType::LongDouble:\n      // Mingw64 GCC uses the old 80 bit extended precision floating point\n      // unit. It passes them indirectly through memory.\n      if (IsMingw64) {\n        const llvm::fltSemantics *LDF = &getTarget().getLongDoubleFormat();\n        if (LDF == &llvm::APFloat::x87DoubleExtended())\n          return ABIArgInfo::getIndirect(Align, /*ByVal=*/false);\n      }\n      break;\n\n    case BuiltinType::Int128:\n    case BuiltinType::UInt128:\n      // If it's a parameter type, the normal ABI rule is that arguments larger\n      // than 8 bytes are passed indirectly. GCC follows it. We follow it too,\n      // even though it isn't particularly efficient.\n      if (!IsReturnType)\n        return ABIArgInfo::getIndirect(Align, /*ByVal=*/false);\n\n      // Mingw64 GCC returns i128 in XMM0. Coerce to v2i64 to handle that.\n      // Clang matches them for compatibility.\n      return ABIArgInfo::getDirect(llvm::FixedVectorType::get(\n          llvm::Type::getInt64Ty(getVMContext()), 2));\n\n    default:\n      break;\n    }\n  }\n\n  if (Ty->isExtIntType()) {\n    // MS x64 ABI requirement: \"Any argument that doesn't fit in 8 bytes, or is\n    // not 1, 2, 4, or 8 bytes, must be passed by reference.\"\n    // However, non-power-of-two _ExtInts will be passed as 1,2,4 or 8 bytes\n    // anyway as long is it fits in them, so we don't have to check the power of\n    // 2.\n    if (Width <= 64)\n      return ABIArgInfo::getDirect();\n    return ABIArgInfo::getIndirect(Align, /*ByVal=*/false);\n  }\n\n  return ABIArgInfo::getDirect();\n}\n\nvoid WinX86_64ABIInfo::computeInfo(CGFunctionInfo &FI) const {\n  const unsigned CC = FI.getCallingConvention();\n  bool IsVectorCall = CC == llvm::CallingConv::X86_VectorCall;\n  bool IsRegCall = CC == llvm::CallingConv::X86_RegCall;\n\n  // If __attribute__((sysv_abi)) is in use, use the SysV argument\n  // classification rules.\n  if (CC == llvm::CallingConv::X86_64_SysV) {\n    X86_64ABIInfo SysVABIInfo(CGT, AVXLevel);\n    SysVABIInfo.computeInfo(FI);\n    return;\n  }\n\n  unsigned FreeSSERegs = 0;\n  if (IsVectorCall) {\n    // We can use up to 4 SSE return registers with vectorcall.\n    FreeSSERegs = 4;\n  } else if (IsRegCall) {\n    // RegCall gives us 16 SSE registers.\n    FreeSSERegs = 16;\n  }\n\n  if (!getCXXABI().classifyReturnType(FI))\n    FI.getReturnInfo() = classify(FI.getReturnType(), FreeSSERegs, true,\n                                  IsVectorCall, IsRegCall);\n\n  if (IsVectorCall) {\n    // We can use up to 6 SSE register parameters with vectorcall.\n    FreeSSERegs = 6;\n  } else if (IsRegCall) {\n    // RegCall gives us 16 SSE registers, we can reuse the return registers.\n    FreeSSERegs = 16;\n  }\n\n  unsigned ArgNum = 0;\n  unsigned ZeroSSERegs = 0;\n  for (auto &I : FI.arguments()) {\n    // Vectorcall in x64 only permits the first 6 arguments to be passed as\n    // XMM/YMM registers. After the sixth argument, pretend no vector\n    // registers are left.\n    unsigned *MaybeFreeSSERegs =\n        (IsVectorCall && ArgNum >= 6) ? &ZeroSSERegs : &FreeSSERegs;\n    I.info =\n        classify(I.type, *MaybeFreeSSERegs, false, IsVectorCall, IsRegCall);\n    ++ArgNum;\n  }\n\n  if (IsVectorCall) {\n    // For vectorcall, assign aggregate HVAs to any free vector registers in a\n    // second pass.\n    for (auto &I : FI.arguments())\n      I.info = reclassifyHvaArgForVectorCall(I.type, FreeSSERegs, I.info);\n  }\n}\n\nAddress WinX86_64ABIInfo::EmitVAArg(CodeGenFunction &CGF, Address VAListAddr,\n                                    QualType Ty) const {\n\n  bool IsIndirect = false;\n\n  // MS x64 ABI requirement: \"Any argument that doesn't fit in 8 bytes, or is\n  // not 1, 2, 4, or 8 bytes, must be passed by reference.\"\n  if (isAggregateTypeForABI(Ty) || Ty->isMemberPointerType()) {\n    uint64_t Width = getContext().getTypeSize(Ty);\n    IsIndirect = Width > 64 || !llvm::isPowerOf2_64(Width);\n  }\n\n  return emitVoidPtrVAArg(CGF, VAListAddr, Ty, IsIndirect,\n                          CGF.getContext().getTypeInfoInChars(Ty),\n                          CharUnits::fromQuantity(8),\n                          /*allowHigherAlign*/ false);\n}\n\nstatic bool PPC_initDwarfEHRegSizeTable(CodeGen::CodeGenFunction &CGF,\n                                        llvm::Value *Address, bool Is64Bit,\n                                        bool IsAIX) {\n  // This is calculated from the LLVM and GCC tables and verified\n  // against gcc output.  AFAIK all PPC ABIs use the same encoding.\n\n  CodeGen::CGBuilderTy &Builder = CGF.Builder;\n\n  llvm::IntegerType *i8 = CGF.Int8Ty;\n  llvm::Value *Four8 = llvm::ConstantInt::get(i8, 4);\n  llvm::Value *Eight8 = llvm::ConstantInt::get(i8, 8);\n  llvm::Value *Sixteen8 = llvm::ConstantInt::get(i8, 16);\n\n  // 0-31: r0-31, the 4-byte or 8-byte general-purpose registers\n  AssignToArrayRange(Builder, Address, Is64Bit ? Eight8 : Four8, 0, 31);\n\n  // 32-63: fp0-31, the 8-byte floating-point registers\n  AssignToArrayRange(Builder, Address, Eight8, 32, 63);\n\n  // 64-67 are various 4-byte or 8-byte special-purpose registers:\n  // 64: mq\n  // 65: lr\n  // 66: ctr\n  // 67: ap\n  AssignToArrayRange(Builder, Address, Is64Bit ? Eight8 : Four8, 64, 67);\n\n  // 68-76 are various 4-byte special-purpose registers:\n  // 68-75 cr0-7\n  // 76: xer\n  AssignToArrayRange(Builder, Address, Four8, 68, 76);\n\n  // 77-108: v0-31, the 16-byte vector registers\n  AssignToArrayRange(Builder, Address, Sixteen8, 77, 108);\n\n  // 109: vrsave\n  // 110: vscr\n  AssignToArrayRange(Builder, Address, Is64Bit ? Eight8 : Four8, 109, 110);\n\n  // AIX does not utilize the rest of the registers.\n  if (IsAIX)\n    return false;\n\n  // 111: spe_acc\n  // 112: spefscr\n  // 113: sfp\n  AssignToArrayRange(Builder, Address, Is64Bit ? Eight8 : Four8, 111, 113);\n\n  if (!Is64Bit)\n    return false;\n\n  // TODO: Need to verify if these registers are used on 64 bit AIX with Power8\n  // or above CPU.\n  // 64-bit only registers:\n  // 114: tfhar\n  // 115: tfiar\n  // 116: texasr\n  AssignToArrayRange(Builder, Address, Eight8, 114, 116);\n\n  return false;\n}\n\n// AIX\nnamespace {\n/// AIXABIInfo - The AIX XCOFF ABI information.\nclass AIXABIInfo : public ABIInfo {\n  const bool Is64Bit;\n  const unsigned PtrByteSize;\n  CharUnits getParamTypeAlignment(QualType Ty) const;\n\npublic:\n  AIXABIInfo(CodeGen::CodeGenTypes &CGT, bool Is64Bit)\n      : ABIInfo(CGT), Is64Bit(Is64Bit), PtrByteSize(Is64Bit ? 8 : 4) {}\n\n  bool isPromotableTypeForABI(QualType Ty) const;\n\n  ABIArgInfo classifyReturnType(QualType RetTy) const;\n  ABIArgInfo classifyArgumentType(QualType Ty) const;\n\n  void computeInfo(CGFunctionInfo &FI) const override {\n    if (!getCXXABI().classifyReturnType(FI))\n      FI.getReturnInfo() = classifyReturnType(FI.getReturnType());\n\n    for (auto &I : FI.arguments())\n      I.info = classifyArgumentType(I.type);\n  }\n\n  Address EmitVAArg(CodeGenFunction &CGF, Address VAListAddr,\n                    QualType Ty) const override;\n};\n\nclass AIXTargetCodeGenInfo : public TargetCodeGenInfo {\n  const bool Is64Bit;\n\npublic:\n  AIXTargetCodeGenInfo(CodeGen::CodeGenTypes &CGT, bool Is64Bit)\n      : TargetCodeGenInfo(std::make_unique<AIXABIInfo>(CGT, Is64Bit)),\n        Is64Bit(Is64Bit) {}\n  int getDwarfEHStackPointer(CodeGen::CodeGenModule &M) const override {\n    return 1; // r1 is the dedicated stack pointer\n  }\n\n  bool initDwarfEHRegSizeTable(CodeGen::CodeGenFunction &CGF,\n                               llvm::Value *Address) const override;\n};\n} // namespace\n\n// Return true if the ABI requires Ty to be passed sign- or zero-\n// extended to 32/64 bits.\nbool AIXABIInfo::isPromotableTypeForABI(QualType Ty) const {\n  // Treat an enum type as its underlying type.\n  if (const EnumType *EnumTy = Ty->getAs<EnumType>())\n    Ty = EnumTy->getDecl()->getIntegerType();\n\n  // Promotable integer types are required to be promoted by the ABI.\n  if (Ty->isPromotableIntegerType())\n    return true;\n\n  if (!Is64Bit)\n    return false;\n\n  // For 64 bit mode, in addition to the usual promotable integer types, we also\n  // need to extend all 32-bit types, since the ABI requires promotion to 64\n  // bits.\n  if (const BuiltinType *BT = Ty->getAs<BuiltinType>())\n    switch (BT->getKind()) {\n    case BuiltinType::Int:\n    case BuiltinType::UInt:\n      return true;\n    default:\n      break;\n    }\n\n  return false;\n}\n\nABIArgInfo AIXABIInfo::classifyReturnType(QualType RetTy) const {\n  if (RetTy->isAnyComplexType())\n    return ABIArgInfo::getDirect();\n\n  if (RetTy->isVectorType())\n    return ABIArgInfo::getDirect();\n\n  if (RetTy->isVoidType())\n    return ABIArgInfo::getIgnore();\n\n  if (isAggregateTypeForABI(RetTy))\n    return getNaturalAlignIndirect(RetTy);\n\n  return (isPromotableTypeForABI(RetTy) ? ABIArgInfo::getExtend(RetTy)\n                                        : ABIArgInfo::getDirect());\n}\n\nABIArgInfo AIXABIInfo::classifyArgumentType(QualType Ty) const {\n  Ty = useFirstFieldIfTransparentUnion(Ty);\n\n  if (Ty->isAnyComplexType())\n    return ABIArgInfo::getDirect();\n\n  if (Ty->isVectorType())\n    return ABIArgInfo::getDirect();\n\n  if (isAggregateTypeForABI(Ty)) {\n    // Records with non-trivial destructors/copy-constructors should not be\n    // passed by value.\n    if (CGCXXABI::RecordArgABI RAA = getRecordArgABI(Ty, getCXXABI()))\n      return getNaturalAlignIndirect(Ty, RAA == CGCXXABI::RAA_DirectInMemory);\n\n    CharUnits CCAlign = getParamTypeAlignment(Ty);\n    CharUnits TyAlign = getContext().getTypeAlignInChars(Ty);\n\n    return ABIArgInfo::getIndirect(CCAlign, /*ByVal*/ true,\n                                   /*Realign*/ TyAlign > CCAlign);\n  }\n\n  return (isPromotableTypeForABI(Ty) ? ABIArgInfo::getExtend(Ty)\n                                     : ABIArgInfo::getDirect());\n}\n\nCharUnits AIXABIInfo::getParamTypeAlignment(QualType Ty) const {\n  // Complex types are passed just like their elements.\n  if (const ComplexType *CTy = Ty->getAs<ComplexType>())\n    Ty = CTy->getElementType();\n\n  if (Ty->isVectorType())\n    return CharUnits::fromQuantity(16);\n\n  // If the structure contains a vector type, the alignment is 16.\n  if (isRecordWithSIMDVectorType(getContext(), Ty))\n    return CharUnits::fromQuantity(16);\n\n  return CharUnits::fromQuantity(PtrByteSize);\n}\n\nAddress AIXABIInfo::EmitVAArg(CodeGenFunction &CGF, Address VAListAddr,\n                              QualType Ty) const {\n  if (Ty->isAnyComplexType())\n    llvm::report_fatal_error(\"complex type is not supported on AIX yet\");\n\n  if (Ty->isVectorType())\n    llvm::report_fatal_error(\n        \"vector types are not yet supported for variadic functions on AIX\");\n\n  auto TypeInfo = getContext().getTypeInfoInChars(Ty);\n  TypeInfo.Align = getParamTypeAlignment(Ty);\n\n  CharUnits SlotSize = CharUnits::fromQuantity(PtrByteSize);\n\n  return emitVoidPtrVAArg(CGF, VAListAddr, Ty, /*Indirect*/ false, TypeInfo,\n                          SlotSize, /*AllowHigher*/ true);\n}\n\nbool AIXTargetCodeGenInfo::initDwarfEHRegSizeTable(\n    CodeGen::CodeGenFunction &CGF, llvm::Value *Address) const {\n  return PPC_initDwarfEHRegSizeTable(CGF, Address, Is64Bit, /*IsAIX*/ true);\n}\n\n// PowerPC-32\nnamespace {\n/// PPC32_SVR4_ABIInfo - The 32-bit PowerPC ELF (SVR4) ABI information.\nclass PPC32_SVR4_ABIInfo : public DefaultABIInfo {\n  bool IsSoftFloatABI;\n  bool IsRetSmallStructInRegABI;\n\n  CharUnits getParamTypeAlignment(QualType Ty) const;\n\npublic:\n  PPC32_SVR4_ABIInfo(CodeGen::CodeGenTypes &CGT, bool SoftFloatABI,\n                     bool RetSmallStructInRegABI)\n      : DefaultABIInfo(CGT), IsSoftFloatABI(SoftFloatABI),\n        IsRetSmallStructInRegABI(RetSmallStructInRegABI) {}\n\n  ABIArgInfo classifyReturnType(QualType RetTy) const;\n\n  void computeInfo(CGFunctionInfo &FI) const override {\n    if (!getCXXABI().classifyReturnType(FI))\n      FI.getReturnInfo() = classifyReturnType(FI.getReturnType());\n    for (auto &I : FI.arguments())\n      I.info = classifyArgumentType(I.type);\n  }\n\n  Address EmitVAArg(CodeGenFunction &CGF, Address VAListAddr,\n                    QualType Ty) const override;\n};\n\nclass PPC32TargetCodeGenInfo : public TargetCodeGenInfo {\npublic:\n  PPC32TargetCodeGenInfo(CodeGenTypes &CGT, bool SoftFloatABI,\n                         bool RetSmallStructInRegABI)\n      : TargetCodeGenInfo(std::make_unique<PPC32_SVR4_ABIInfo>(\n            CGT, SoftFloatABI, RetSmallStructInRegABI)) {}\n\n  static bool isStructReturnInRegABI(const llvm::Triple &Triple,\n                                     const CodeGenOptions &Opts);\n\n  int getDwarfEHStackPointer(CodeGen::CodeGenModule &M) const override {\n    // This is recovered from gcc output.\n    return 1; // r1 is the dedicated stack pointer\n  }\n\n  bool initDwarfEHRegSizeTable(CodeGen::CodeGenFunction &CGF,\n                               llvm::Value *Address) const override;\n};\n}\n\nCharUnits PPC32_SVR4_ABIInfo::getParamTypeAlignment(QualType Ty) const {\n  // Complex types are passed just like their elements.\n  if (const ComplexType *CTy = Ty->getAs<ComplexType>())\n    Ty = CTy->getElementType();\n\n  if (Ty->isVectorType())\n    return CharUnits::fromQuantity(getContext().getTypeSize(Ty) == 128 ? 16\n                                                                       : 4);\n\n  // For single-element float/vector structs, we consider the whole type\n  // to have the same alignment requirements as its single element.\n  const Type *AlignTy = nullptr;\n  if (const Type *EltType = isSingleElementStruct(Ty, getContext())) {\n    const BuiltinType *BT = EltType->getAs<BuiltinType>();\n    if ((EltType->isVectorType() && getContext().getTypeSize(EltType) == 128) ||\n        (BT && BT->isFloatingPoint()))\n      AlignTy = EltType;\n  }\n\n  if (AlignTy)\n    return CharUnits::fromQuantity(AlignTy->isVectorType() ? 16 : 4);\n  return CharUnits::fromQuantity(4);\n}\n\nABIArgInfo PPC32_SVR4_ABIInfo::classifyReturnType(QualType RetTy) const {\n  uint64_t Size;\n\n  // -msvr4-struct-return puts small aggregates in GPR3 and GPR4.\n  if (isAggregateTypeForABI(RetTy) && IsRetSmallStructInRegABI &&\n      (Size = getContext().getTypeSize(RetTy)) <= 64) {\n    // System V ABI (1995), page 3-22, specified:\n    // > A structure or union whose size is less than or equal to 8 bytes\n    // > shall be returned in r3 and r4, as if it were first stored in the\n    // > 8-byte aligned memory area and then the low addressed word were\n    // > loaded into r3 and the high-addressed word into r4.  Bits beyond\n    // > the last member of the structure or union are not defined.\n    //\n    // GCC for big-endian PPC32 inserts the pad before the first member,\n    // not \"beyond the last member\" of the struct.  To stay compatible\n    // with GCC, we coerce the struct to an integer of the same size.\n    // LLVM will extend it and return i32 in r3, or i64 in r3:r4.\n    if (Size == 0)\n      return ABIArgInfo::getIgnore();\n    else {\n      llvm::Type *CoerceTy = llvm::Type::getIntNTy(getVMContext(), Size);\n      return ABIArgInfo::getDirect(CoerceTy);\n    }\n  }\n\n  return DefaultABIInfo::classifyReturnType(RetTy);\n}\n\n// TODO: this implementation is now likely redundant with\n// DefaultABIInfo::EmitVAArg.\nAddress PPC32_SVR4_ABIInfo::EmitVAArg(CodeGenFunction &CGF, Address VAList,\n                                      QualType Ty) const {\n  if (getTarget().getTriple().isOSDarwin()) {\n    auto TI = getContext().getTypeInfoInChars(Ty);\n    TI.Align = getParamTypeAlignment(Ty);\n\n    CharUnits SlotSize = CharUnits::fromQuantity(4);\n    return emitVoidPtrVAArg(CGF, VAList, Ty,\n                            classifyArgumentType(Ty).isIndirect(), TI, SlotSize,\n                            /*AllowHigherAlign=*/true);\n  }\n\n  const unsigned OverflowLimit = 8;\n  if (const ComplexType *CTy = Ty->getAs<ComplexType>()) {\n    // TODO: Implement this. For now ignore.\n    (void)CTy;\n    return Address::invalid(); // FIXME?\n  }\n\n  // struct __va_list_tag {\n  //   unsigned char gpr;\n  //   unsigned char fpr;\n  //   unsigned short reserved;\n  //   void *overflow_arg_area;\n  //   void *reg_save_area;\n  // };\n\n  bool isI64 = Ty->isIntegerType() && getContext().getTypeSize(Ty) == 64;\n  bool isInt = !Ty->isFloatingType();\n  bool isF64 = Ty->isFloatingType() && getContext().getTypeSize(Ty) == 64;\n\n  // All aggregates are passed indirectly?  That doesn't seem consistent\n  // with the argument-lowering code.\n  bool isIndirect = isAggregateTypeForABI(Ty);\n\n  CGBuilderTy &Builder = CGF.Builder;\n\n  // The calling convention either uses 1-2 GPRs or 1 FPR.\n  Address NumRegsAddr = Address::invalid();\n  if (isInt || IsSoftFloatABI) {\n    NumRegsAddr = Builder.CreateStructGEP(VAList, 0, \"gpr\");\n  } else {\n    NumRegsAddr = Builder.CreateStructGEP(VAList, 1, \"fpr\");\n  }\n\n  llvm::Value *NumRegs = Builder.CreateLoad(NumRegsAddr, \"numUsedRegs\");\n\n  // \"Align\" the register count when TY is i64.\n  if (isI64 || (isF64 && IsSoftFloatABI)) {\n    NumRegs = Builder.CreateAdd(NumRegs, Builder.getInt8(1));\n    NumRegs = Builder.CreateAnd(NumRegs, Builder.getInt8((uint8_t) ~1U));\n  }\n\n  llvm::Value *CC =\n      Builder.CreateICmpULT(NumRegs, Builder.getInt8(OverflowLimit), \"cond\");\n\n  llvm::BasicBlock *UsingRegs = CGF.createBasicBlock(\"using_regs\");\n  llvm::BasicBlock *UsingOverflow = CGF.createBasicBlock(\"using_overflow\");\n  llvm::BasicBlock *Cont = CGF.createBasicBlock(\"cont\");\n\n  Builder.CreateCondBr(CC, UsingRegs, UsingOverflow);\n\n  llvm::Type *DirectTy = CGF.ConvertType(Ty);\n  if (isIndirect) DirectTy = DirectTy->getPointerTo(0);\n\n  // Case 1: consume registers.\n  Address RegAddr = Address::invalid();\n  {\n    CGF.EmitBlock(UsingRegs);\n\n    Address RegSaveAreaPtr = Builder.CreateStructGEP(VAList, 4);\n    RegAddr = Address(Builder.CreateLoad(RegSaveAreaPtr),\n                      CharUnits::fromQuantity(8));\n    assert(RegAddr.getElementType() == CGF.Int8Ty);\n\n    // Floating-point registers start after the general-purpose registers.\n    if (!(isInt || IsSoftFloatABI)) {\n      RegAddr = Builder.CreateConstInBoundsByteGEP(RegAddr,\n                                                   CharUnits::fromQuantity(32));\n    }\n\n    // Get the address of the saved value by scaling the number of\n    // registers we've used by the number of\n    CharUnits RegSize = CharUnits::fromQuantity((isInt || IsSoftFloatABI) ? 4 : 8);\n    llvm::Value *RegOffset =\n      Builder.CreateMul(NumRegs, Builder.getInt8(RegSize.getQuantity()));\n    RegAddr = Address(Builder.CreateInBoundsGEP(CGF.Int8Ty,\n                                            RegAddr.getPointer(), RegOffset),\n                      RegAddr.getAlignment().alignmentOfArrayElement(RegSize));\n    RegAddr = Builder.CreateElementBitCast(RegAddr, DirectTy);\n\n    // Increase the used-register count.\n    NumRegs =\n      Builder.CreateAdd(NumRegs,\n                        Builder.getInt8((isI64 || (isF64 && IsSoftFloatABI)) ? 2 : 1));\n    Builder.CreateStore(NumRegs, NumRegsAddr);\n\n    CGF.EmitBranch(Cont);\n  }\n\n  // Case 2: consume space in the overflow area.\n  Address MemAddr = Address::invalid();\n  {\n    CGF.EmitBlock(UsingOverflow);\n\n    Builder.CreateStore(Builder.getInt8(OverflowLimit), NumRegsAddr);\n\n    // Everything in the overflow area is rounded up to a size of at least 4.\n    CharUnits OverflowAreaAlign = CharUnits::fromQuantity(4);\n\n    CharUnits Size;\n    if (!isIndirect) {\n      auto TypeInfo = CGF.getContext().getTypeInfoInChars(Ty);\n      Size = TypeInfo.Width.alignTo(OverflowAreaAlign);\n    } else {\n      Size = CGF.getPointerSize();\n    }\n\n    Address OverflowAreaAddr = Builder.CreateStructGEP(VAList, 3);\n    Address OverflowArea(Builder.CreateLoad(OverflowAreaAddr, \"argp.cur\"),\n                         OverflowAreaAlign);\n    // Round up address of argument to alignment\n    CharUnits Align = CGF.getContext().getTypeAlignInChars(Ty);\n    if (Align > OverflowAreaAlign) {\n      llvm::Value *Ptr = OverflowArea.getPointer();\n      OverflowArea = Address(emitRoundPointerUpToAlignment(CGF, Ptr, Align),\n                                                           Align);\n    }\n\n    MemAddr = Builder.CreateElementBitCast(OverflowArea, DirectTy);\n\n    // Increase the overflow area.\n    OverflowArea = Builder.CreateConstInBoundsByteGEP(OverflowArea, Size);\n    Builder.CreateStore(OverflowArea.getPointer(), OverflowAreaAddr);\n    CGF.EmitBranch(Cont);\n  }\n\n  CGF.EmitBlock(Cont);\n\n  // Merge the cases with a phi.\n  Address Result = emitMergePHI(CGF, RegAddr, UsingRegs, MemAddr, UsingOverflow,\n                                \"vaarg.addr\");\n\n  // Load the pointer if the argument was passed indirectly.\n  if (isIndirect) {\n    Result = Address(Builder.CreateLoad(Result, \"aggr\"),\n                     getContext().getTypeAlignInChars(Ty));\n  }\n\n  return Result;\n}\n\nbool PPC32TargetCodeGenInfo::isStructReturnInRegABI(\n    const llvm::Triple &Triple, const CodeGenOptions &Opts) {\n  assert(Triple.isPPC32());\n\n  switch (Opts.getStructReturnConvention()) {\n  case CodeGenOptions::SRCK_Default:\n    break;\n  case CodeGenOptions::SRCK_OnStack: // -maix-struct-return\n    return false;\n  case CodeGenOptions::SRCK_InRegs: // -msvr4-struct-return\n    return true;\n  }\n\n  if (Triple.isOSBinFormatELF() && !Triple.isOSLinux())\n    return true;\n\n  return false;\n}\n\nbool\nPPC32TargetCodeGenInfo::initDwarfEHRegSizeTable(CodeGen::CodeGenFunction &CGF,\n                                                llvm::Value *Address) const {\n  return PPC_initDwarfEHRegSizeTable(CGF, Address, /*Is64Bit*/ false,\n                                     /*IsAIX*/ false);\n}\n\n// PowerPC-64\n\nnamespace {\n/// PPC64_SVR4_ABIInfo - The 64-bit PowerPC ELF (SVR4) ABI information.\nclass PPC64_SVR4_ABIInfo : public SwiftABIInfo {\npublic:\n  enum ABIKind {\n    ELFv1 = 0,\n    ELFv2\n  };\n\nprivate:\n  static const unsigned GPRBits = 64;\n  ABIKind Kind;\n  bool IsSoftFloatABI;\n\npublic:\n  PPC64_SVR4_ABIInfo(CodeGen::CodeGenTypes &CGT, ABIKind Kind,\n                     bool SoftFloatABI)\n      : SwiftABIInfo(CGT), Kind(Kind), IsSoftFloatABI(SoftFloatABI) {}\n\n  bool isPromotableTypeForABI(QualType Ty) const;\n  CharUnits getParamTypeAlignment(QualType Ty) const;\n\n  ABIArgInfo classifyReturnType(QualType RetTy) const;\n  ABIArgInfo classifyArgumentType(QualType Ty) const;\n\n  bool isHomogeneousAggregateBaseType(QualType Ty) const override;\n  bool isHomogeneousAggregateSmallEnough(const Type *Ty,\n                                         uint64_t Members) const override;\n\n  // TODO: We can add more logic to computeInfo to improve performance.\n  // Example: For aggregate arguments that fit in a register, we could\n  // use getDirectInReg (as is done below for structs containing a single\n  // floating-point value) to avoid pushing them to memory on function\n  // entry.  This would require changing the logic in PPCISelLowering\n  // when lowering the parameters in the caller and args in the callee.\n  void computeInfo(CGFunctionInfo &FI) const override {\n    if (!getCXXABI().classifyReturnType(FI))\n      FI.getReturnInfo() = classifyReturnType(FI.getReturnType());\n    for (auto &I : FI.arguments()) {\n      // We rely on the default argument classification for the most part.\n      // One exception:  An aggregate containing a single floating-point\n      // or vector item must be passed in a register if one is available.\n      const Type *T = isSingleElementStruct(I.type, getContext());\n      if (T) {\n        const BuiltinType *BT = T->getAs<BuiltinType>();\n        if ((T->isVectorType() && getContext().getTypeSize(T) == 128) ||\n            (BT && BT->isFloatingPoint())) {\n          QualType QT(T, 0);\n          I.info = ABIArgInfo::getDirectInReg(CGT.ConvertType(QT));\n          continue;\n        }\n      }\n      I.info = classifyArgumentType(I.type);\n    }\n  }\n\n  Address EmitVAArg(CodeGenFunction &CGF, Address VAListAddr,\n                    QualType Ty) const override;\n\n  bool shouldPassIndirectlyForSwift(ArrayRef<llvm::Type*> scalars,\n                                    bool asReturnValue) const override {\n    return occupiesMoreThan(CGT, scalars, /*total*/ 4);\n  }\n\n  bool isSwiftErrorInRegister() const override {\n    return false;\n  }\n};\n\nclass PPC64_SVR4_TargetCodeGenInfo : public TargetCodeGenInfo {\n\npublic:\n  PPC64_SVR4_TargetCodeGenInfo(CodeGenTypes &CGT,\n                               PPC64_SVR4_ABIInfo::ABIKind Kind,\n                               bool SoftFloatABI)\n      : TargetCodeGenInfo(\n            std::make_unique<PPC64_SVR4_ABIInfo>(CGT, Kind, SoftFloatABI)) {}\n\n  int getDwarfEHStackPointer(CodeGen::CodeGenModule &M) const override {\n    // This is recovered from gcc output.\n    return 1; // r1 is the dedicated stack pointer\n  }\n\n  bool initDwarfEHRegSizeTable(CodeGen::CodeGenFunction &CGF,\n                               llvm::Value *Address) const override;\n};\n\nclass PPC64TargetCodeGenInfo : public DefaultTargetCodeGenInfo {\npublic:\n  PPC64TargetCodeGenInfo(CodeGenTypes &CGT) : DefaultTargetCodeGenInfo(CGT) {}\n\n  int getDwarfEHStackPointer(CodeGen::CodeGenModule &M) const override {\n    // This is recovered from gcc output.\n    return 1; // r1 is the dedicated stack pointer\n  }\n\n  bool initDwarfEHRegSizeTable(CodeGen::CodeGenFunction &CGF,\n                               llvm::Value *Address) const override;\n};\n\n}\n\n// Return true if the ABI requires Ty to be passed sign- or zero-\n// extended to 64 bits.\nbool\nPPC64_SVR4_ABIInfo::isPromotableTypeForABI(QualType Ty) const {\n  // Treat an enum type as its underlying type.\n  if (const EnumType *EnumTy = Ty->getAs<EnumType>())\n    Ty = EnumTy->getDecl()->getIntegerType();\n\n  // Promotable integer types are required to be promoted by the ABI.\n  if (isPromotableIntegerTypeForABI(Ty))\n    return true;\n\n  // In addition to the usual promotable integer types, we also need to\n  // extend all 32-bit types, since the ABI requires promotion to 64 bits.\n  if (const BuiltinType *BT = Ty->getAs<BuiltinType>())\n    switch (BT->getKind()) {\n    case BuiltinType::Int:\n    case BuiltinType::UInt:\n      return true;\n    default:\n      break;\n    }\n\n  if (const auto *EIT = Ty->getAs<ExtIntType>())\n    if (EIT->getNumBits() < 64)\n      return true;\n\n  return false;\n}\n\n/// isAlignedParamType - Determine whether a type requires 16-byte or\n/// higher alignment in the parameter area.  Always returns at least 8.\nCharUnits PPC64_SVR4_ABIInfo::getParamTypeAlignment(QualType Ty) const {\n  // Complex types are passed just like their elements.\n  if (const ComplexType *CTy = Ty->getAs<ComplexType>())\n    Ty = CTy->getElementType();\n\n  // Only vector types of size 16 bytes need alignment (larger types are\n  // passed via reference, smaller types are not aligned).\n  if (Ty->isVectorType()) {\n    return CharUnits::fromQuantity(getContext().getTypeSize(Ty) == 128 ? 16 : 8);\n  } else if (Ty->isRealFloatingType() &&\n             &getContext().getFloatTypeSemantics(Ty) ==\n                 &llvm::APFloat::IEEEquad()) {\n    // According to ABI document section 'Optional Save Areas': If extended\n    // precision floating-point values in IEEE BINARY 128 QUADRUPLE PRECISION\n    // format are supported, map them to a single quadword, quadword aligned.\n    return CharUnits::fromQuantity(16);\n  }\n\n  // For single-element float/vector structs, we consider the whole type\n  // to have the same alignment requirements as its single element.\n  const Type *AlignAsType = nullptr;\n  const Type *EltType = isSingleElementStruct(Ty, getContext());\n  if (EltType) {\n    const BuiltinType *BT = EltType->getAs<BuiltinType>();\n    if ((EltType->isVectorType() && getContext().getTypeSize(EltType) == 128) ||\n        (BT && BT->isFloatingPoint()))\n      AlignAsType = EltType;\n  }\n\n  // Likewise for ELFv2 homogeneous aggregates.\n  const Type *Base = nullptr;\n  uint64_t Members = 0;\n  if (!AlignAsType && Kind == ELFv2 &&\n      isAggregateTypeForABI(Ty) && isHomogeneousAggregate(Ty, Base, Members))\n    AlignAsType = Base;\n\n  // With special case aggregates, only vector base types need alignment.\n  if (AlignAsType) {\n    return CharUnits::fromQuantity(AlignAsType->isVectorType() ? 16 : 8);\n  }\n\n  // Otherwise, we only need alignment for any aggregate type that\n  // has an alignment requirement of >= 16 bytes.\n  if (isAggregateTypeForABI(Ty) && getContext().getTypeAlign(Ty) >= 128) {\n    return CharUnits::fromQuantity(16);\n  }\n\n  return CharUnits::fromQuantity(8);\n}\n\n/// isHomogeneousAggregate - Return true if a type is an ELFv2 homogeneous\n/// aggregate.  Base is set to the base element type, and Members is set\n/// to the number of base elements.\nbool ABIInfo::isHomogeneousAggregate(QualType Ty, const Type *&Base,\n                                     uint64_t &Members) const {\n  if (const ConstantArrayType *AT = getContext().getAsConstantArrayType(Ty)) {\n    uint64_t NElements = AT->getSize().getZExtValue();\n    if (NElements == 0)\n      return false;\n    if (!isHomogeneousAggregate(AT->getElementType(), Base, Members))\n      return false;\n    Members *= NElements;\n  } else if (const RecordType *RT = Ty->getAs<RecordType>()) {\n    const RecordDecl *RD = RT->getDecl();\n    if (RD->hasFlexibleArrayMember())\n      return false;\n\n    Members = 0;\n\n    // If this is a C++ record, check the properties of the record such as\n    // bases and ABI specific restrictions\n    if (const CXXRecordDecl *CXXRD = dyn_cast<CXXRecordDecl>(RD)) {\n      if (!getCXXABI().isPermittedToBeHomogeneousAggregate(CXXRD))\n        return false;\n\n      for (const auto &I : CXXRD->bases()) {\n        // Ignore empty records.\n        if (isEmptyRecord(getContext(), I.getType(), true))\n          continue;\n\n        uint64_t FldMembers;\n        if (!isHomogeneousAggregate(I.getType(), Base, FldMembers))\n          return false;\n\n        Members += FldMembers;\n      }\n    }\n\n    for (const auto *FD : RD->fields()) {\n      // Ignore (non-zero arrays of) empty records.\n      QualType FT = FD->getType();\n      while (const ConstantArrayType *AT =\n             getContext().getAsConstantArrayType(FT)) {\n        if (AT->getSize().getZExtValue() == 0)\n          return false;\n        FT = AT->getElementType();\n      }\n      if (isEmptyRecord(getContext(), FT, true))\n        continue;\n\n      // For compatibility with GCC, ignore empty bitfields in C++ mode.\n      if (getContext().getLangOpts().CPlusPlus &&\n          FD->isZeroLengthBitField(getContext()))\n        continue;\n\n      uint64_t FldMembers;\n      if (!isHomogeneousAggregate(FD->getType(), Base, FldMembers))\n        return false;\n\n      Members = (RD->isUnion() ?\n                 std::max(Members, FldMembers) : Members + FldMembers);\n    }\n\n    if (!Base)\n      return false;\n\n    // Ensure there is no padding.\n    if (getContext().getTypeSize(Base) * Members !=\n        getContext().getTypeSize(Ty))\n      return false;\n  } else {\n    Members = 1;\n    if (const ComplexType *CT = Ty->getAs<ComplexType>()) {\n      Members = 2;\n      Ty = CT->getElementType();\n    }\n\n    // Most ABIs only support float, double, and some vector type widths.\n    if (!isHomogeneousAggregateBaseType(Ty))\n      return false;\n\n    // The base type must be the same for all members.  Types that\n    // agree in both total size and mode (float vs. vector) are\n    // treated as being equivalent here.\n    const Type *TyPtr = Ty.getTypePtr();\n    if (!Base) {\n      Base = TyPtr;\n      // If it's a non-power-of-2 vector, its size is already a power-of-2,\n      // so make sure to widen it explicitly.\n      if (const VectorType *VT = Base->getAs<VectorType>()) {\n        QualType EltTy = VT->getElementType();\n        unsigned NumElements =\n            getContext().getTypeSize(VT) / getContext().getTypeSize(EltTy);\n        Base = getContext()\n                   .getVectorType(EltTy, NumElements, VT->getVectorKind())\n                   .getTypePtr();\n      }\n    }\n\n    if (Base->isVectorType() != TyPtr->isVectorType() ||\n        getContext().getTypeSize(Base) != getContext().getTypeSize(TyPtr))\n      return false;\n  }\n  return Members > 0 && isHomogeneousAggregateSmallEnough(Base, Members);\n}\n\nbool PPC64_SVR4_ABIInfo::isHomogeneousAggregateBaseType(QualType Ty) const {\n  // Homogeneous aggregates for ELFv2 must have base types of float,\n  // double, long double, or 128-bit vectors.\n  if (const BuiltinType *BT = Ty->getAs<BuiltinType>()) {\n    if (BT->getKind() == BuiltinType::Float ||\n        BT->getKind() == BuiltinType::Double ||\n        BT->getKind() == BuiltinType::LongDouble ||\n        (getContext().getTargetInfo().hasFloat128Type() &&\n          (BT->getKind() == BuiltinType::Float128))) {\n      if (IsSoftFloatABI)\n        return false;\n      return true;\n    }\n  }\n  if (const VectorType *VT = Ty->getAs<VectorType>()) {\n    if (getContext().getTypeSize(VT) == 128)\n      return true;\n  }\n  return false;\n}\n\nbool PPC64_SVR4_ABIInfo::isHomogeneousAggregateSmallEnough(\n    const Type *Base, uint64_t Members) const {\n  // Vector and fp128 types require one register, other floating point types\n  // require one or two registers depending on their size.\n  uint32_t NumRegs =\n      ((getContext().getTargetInfo().hasFloat128Type() &&\n          Base->isFloat128Type()) ||\n        Base->isVectorType()) ? 1\n                              : (getContext().getTypeSize(Base) + 63) / 64;\n\n  // Homogeneous Aggregates may occupy at most 8 registers.\n  return Members * NumRegs <= 8;\n}\n\nABIArgInfo\nPPC64_SVR4_ABIInfo::classifyArgumentType(QualType Ty) const {\n  Ty = useFirstFieldIfTransparentUnion(Ty);\n\n  if (Ty->isAnyComplexType())\n    return ABIArgInfo::getDirect();\n\n  // Non-Altivec vector types are passed in GPRs (smaller than 16 bytes)\n  // or via reference (larger than 16 bytes).\n  if (Ty->isVectorType()) {\n    uint64_t Size = getContext().getTypeSize(Ty);\n    if (Size > 128)\n      return getNaturalAlignIndirect(Ty, /*ByVal=*/false);\n    else if (Size < 128) {\n      llvm::Type *CoerceTy = llvm::IntegerType::get(getVMContext(), Size);\n      return ABIArgInfo::getDirect(CoerceTy);\n    }\n  }\n\n  if (const auto *EIT = Ty->getAs<ExtIntType>())\n    if (EIT->getNumBits() > 128)\n      return getNaturalAlignIndirect(Ty, /*ByVal=*/true);\n\n  if (isAggregateTypeForABI(Ty)) {\n    if (CGCXXABI::RecordArgABI RAA = getRecordArgABI(Ty, getCXXABI()))\n      return getNaturalAlignIndirect(Ty, RAA == CGCXXABI::RAA_DirectInMemory);\n\n    uint64_t ABIAlign = getParamTypeAlignment(Ty).getQuantity();\n    uint64_t TyAlign = getContext().getTypeAlignInChars(Ty).getQuantity();\n\n    // ELFv2 homogeneous aggregates are passed as array types.\n    const Type *Base = nullptr;\n    uint64_t Members = 0;\n    if (Kind == ELFv2 &&\n        isHomogeneousAggregate(Ty, Base, Members)) {\n      llvm::Type *BaseTy = CGT.ConvertType(QualType(Base, 0));\n      llvm::Type *CoerceTy = llvm::ArrayType::get(BaseTy, Members);\n      return ABIArgInfo::getDirect(CoerceTy);\n    }\n\n    // If an aggregate may end up fully in registers, we do not\n    // use the ByVal method, but pass the aggregate as array.\n    // This is usually beneficial since we avoid forcing the\n    // back-end to store the argument to memory.\n    uint64_t Bits = getContext().getTypeSize(Ty);\n    if (Bits > 0 && Bits <= 8 * GPRBits) {\n      llvm::Type *CoerceTy;\n\n      // Types up to 8 bytes are passed as integer type (which will be\n      // properly aligned in the argument save area doubleword).\n      if (Bits <= GPRBits)\n        CoerceTy =\n            llvm::IntegerType::get(getVMContext(), llvm::alignTo(Bits, 8));\n      // Larger types are passed as arrays, with the base type selected\n      // according to the required alignment in the save area.\n      else {\n        uint64_t RegBits = ABIAlign * 8;\n        uint64_t NumRegs = llvm::alignTo(Bits, RegBits) / RegBits;\n        llvm::Type *RegTy = llvm::IntegerType::get(getVMContext(), RegBits);\n        CoerceTy = llvm::ArrayType::get(RegTy, NumRegs);\n      }\n\n      return ABIArgInfo::getDirect(CoerceTy);\n    }\n\n    // All other aggregates are passed ByVal.\n    return ABIArgInfo::getIndirect(CharUnits::fromQuantity(ABIAlign),\n                                   /*ByVal=*/true,\n                                   /*Realign=*/TyAlign > ABIAlign);\n  }\n\n  return (isPromotableTypeForABI(Ty) ? ABIArgInfo::getExtend(Ty)\n                                     : ABIArgInfo::getDirect());\n}\n\nABIArgInfo\nPPC64_SVR4_ABIInfo::classifyReturnType(QualType RetTy) const {\n  if (RetTy->isVoidType())\n    return ABIArgInfo::getIgnore();\n\n  if (RetTy->isAnyComplexType())\n    return ABIArgInfo::getDirect();\n\n  // Non-Altivec vector types are returned in GPRs (smaller than 16 bytes)\n  // or via reference (larger than 16 bytes).\n  if (RetTy->isVectorType()) {\n    uint64_t Size = getContext().getTypeSize(RetTy);\n    if (Size > 128)\n      return getNaturalAlignIndirect(RetTy);\n    else if (Size < 128) {\n      llvm::Type *CoerceTy = llvm::IntegerType::get(getVMContext(), Size);\n      return ABIArgInfo::getDirect(CoerceTy);\n    }\n  }\n\n  if (const auto *EIT = RetTy->getAs<ExtIntType>())\n    if (EIT->getNumBits() > 128)\n      return getNaturalAlignIndirect(RetTy, /*ByVal=*/false);\n\n  if (isAggregateTypeForABI(RetTy)) {\n    // ELFv2 homogeneous aggregates are returned as array types.\n    const Type *Base = nullptr;\n    uint64_t Members = 0;\n    if (Kind == ELFv2 &&\n        isHomogeneousAggregate(RetTy, Base, Members)) {\n      llvm::Type *BaseTy = CGT.ConvertType(QualType(Base, 0));\n      llvm::Type *CoerceTy = llvm::ArrayType::get(BaseTy, Members);\n      return ABIArgInfo::getDirect(CoerceTy);\n    }\n\n    // ELFv2 small aggregates are returned in up to two registers.\n    uint64_t Bits = getContext().getTypeSize(RetTy);\n    if (Kind == ELFv2 && Bits <= 2 * GPRBits) {\n      if (Bits == 0)\n        return ABIArgInfo::getIgnore();\n\n      llvm::Type *CoerceTy;\n      if (Bits > GPRBits) {\n        CoerceTy = llvm::IntegerType::get(getVMContext(), GPRBits);\n        CoerceTy = llvm::StructType::get(CoerceTy, CoerceTy);\n      } else\n        CoerceTy =\n            llvm::IntegerType::get(getVMContext(), llvm::alignTo(Bits, 8));\n      return ABIArgInfo::getDirect(CoerceTy);\n    }\n\n    // All other aggregates are returned indirectly.\n    return getNaturalAlignIndirect(RetTy);\n  }\n\n  return (isPromotableTypeForABI(RetTy) ? ABIArgInfo::getExtend(RetTy)\n                                        : ABIArgInfo::getDirect());\n}\n\n// Based on ARMABIInfo::EmitVAArg, adjusted for 64-bit machine.\nAddress PPC64_SVR4_ABIInfo::EmitVAArg(CodeGenFunction &CGF, Address VAListAddr,\n                                      QualType Ty) const {\n  auto TypeInfo = getContext().getTypeInfoInChars(Ty);\n  TypeInfo.Align = getParamTypeAlignment(Ty);\n\n  CharUnits SlotSize = CharUnits::fromQuantity(8);\n\n  // If we have a complex type and the base type is smaller than 8 bytes,\n  // the ABI calls for the real and imaginary parts to be right-adjusted\n  // in separate doublewords.  However, Clang expects us to produce a\n  // pointer to a structure with the two parts packed tightly.  So generate\n  // loads of the real and imaginary parts relative to the va_list pointer,\n  // and store them to a temporary structure.\n  if (const ComplexType *CTy = Ty->getAs<ComplexType>()) {\n    CharUnits EltSize = TypeInfo.Width / 2;\n    if (EltSize < SlotSize) {\n      Address Addr = emitVoidPtrDirectVAArg(CGF, VAListAddr, CGF.Int8Ty,\n                                            SlotSize * 2, SlotSize,\n                                            SlotSize, /*AllowHigher*/ true);\n\n      Address RealAddr = Addr;\n      Address ImagAddr = RealAddr;\n      if (CGF.CGM.getDataLayout().isBigEndian()) {\n        RealAddr = CGF.Builder.CreateConstInBoundsByteGEP(RealAddr,\n                                                          SlotSize - EltSize);\n        ImagAddr = CGF.Builder.CreateConstInBoundsByteGEP(ImagAddr,\n                                                      2 * SlotSize - EltSize);\n      } else {\n        ImagAddr = CGF.Builder.CreateConstInBoundsByteGEP(RealAddr, SlotSize);\n      }\n\n      llvm::Type *EltTy = CGF.ConvertTypeForMem(CTy->getElementType());\n      RealAddr = CGF.Builder.CreateElementBitCast(RealAddr, EltTy);\n      ImagAddr = CGF.Builder.CreateElementBitCast(ImagAddr, EltTy);\n      llvm::Value *Real = CGF.Builder.CreateLoad(RealAddr, \".vareal\");\n      llvm::Value *Imag = CGF.Builder.CreateLoad(ImagAddr, \".vaimag\");\n\n      Address Temp = CGF.CreateMemTemp(Ty, \"vacplx\");\n      CGF.EmitStoreOfComplex({Real, Imag}, CGF.MakeAddrLValue(Temp, Ty),\n                             /*init*/ true);\n      return Temp;\n    }\n  }\n\n  // Otherwise, just use the general rule.\n  return emitVoidPtrVAArg(CGF, VAListAddr, Ty, /*Indirect*/ false,\n                          TypeInfo, SlotSize, /*AllowHigher*/ true);\n}\n\nbool\nPPC64_SVR4_TargetCodeGenInfo::initDwarfEHRegSizeTable(\n  CodeGen::CodeGenFunction &CGF,\n  llvm::Value *Address) const {\n  return PPC_initDwarfEHRegSizeTable(CGF, Address, /*Is64Bit*/ true,\n                                     /*IsAIX*/ false);\n}\n\nbool\nPPC64TargetCodeGenInfo::initDwarfEHRegSizeTable(CodeGen::CodeGenFunction &CGF,\n                                                llvm::Value *Address) const {\n  return PPC_initDwarfEHRegSizeTable(CGF, Address, /*Is64Bit*/ true,\n                                     /*IsAIX*/ false);\n}\n\n//===----------------------------------------------------------------------===//\n// AArch64 ABI Implementation\n//===----------------------------------------------------------------------===//\n\nnamespace {\n\nclass AArch64ABIInfo : public SwiftABIInfo {\npublic:\n  enum ABIKind {\n    AAPCS = 0,\n    DarwinPCS,\n    Win64\n  };\n\nprivate:\n  ABIKind Kind;\n\npublic:\n  AArch64ABIInfo(CodeGenTypes &CGT, ABIKind Kind)\n    : SwiftABIInfo(CGT), Kind(Kind) {}\n\nprivate:\n  ABIKind getABIKind() const { return Kind; }\n  bool isDarwinPCS() const { return Kind == DarwinPCS; }\n\n  ABIArgInfo classifyReturnType(QualType RetTy, bool IsVariadic) const;\n  ABIArgInfo classifyArgumentType(QualType RetTy) const;\n  ABIArgInfo coerceIllegalVector(QualType Ty) const;\n  bool isHomogeneousAggregateBaseType(QualType Ty) const override;\n  bool isHomogeneousAggregateSmallEnough(const Type *Ty,\n                                         uint64_t Members) const override;\n\n  bool isIllegalVectorType(QualType Ty) const;\n\n  void computeInfo(CGFunctionInfo &FI) const override {\n    if (!::classifyReturnType(getCXXABI(), FI, *this))\n      FI.getReturnInfo() =\n          classifyReturnType(FI.getReturnType(), FI.isVariadic());\n\n    for (auto &it : FI.arguments())\n      it.info = classifyArgumentType(it.type);\n  }\n\n  Address EmitDarwinVAArg(Address VAListAddr, QualType Ty,\n                          CodeGenFunction &CGF) const;\n\n  Address EmitAAPCSVAArg(Address VAListAddr, QualType Ty,\n                         CodeGenFunction &CGF) const;\n\n  Address EmitVAArg(CodeGenFunction &CGF, Address VAListAddr,\n                    QualType Ty) const override {\n    llvm::Type *BaseTy = CGF.ConvertType(Ty);\n    if (isa<llvm::ScalableVectorType>(BaseTy))\n      llvm::report_fatal_error(\"Passing SVE types to variadic functions is \"\n                               \"currently not supported\");\n\n    return Kind == Win64 ? EmitMSVAArg(CGF, VAListAddr, Ty)\n                         : isDarwinPCS() ? EmitDarwinVAArg(VAListAddr, Ty, CGF)\n                                         : EmitAAPCSVAArg(VAListAddr, Ty, CGF);\n  }\n\n  Address EmitMSVAArg(CodeGenFunction &CGF, Address VAListAddr,\n                      QualType Ty) const override;\n\n  bool shouldPassIndirectlyForSwift(ArrayRef<llvm::Type*> scalars,\n                                    bool asReturnValue) const override {\n    return occupiesMoreThan(CGT, scalars, /*total*/ 4);\n  }\n  bool isSwiftErrorInRegister() const override {\n    return true;\n  }\n\n  bool isLegalVectorTypeForSwift(CharUnits totalSize, llvm::Type *eltTy,\n                                 unsigned elts) const override;\n\n  bool allowBFloatArgsAndRet() const override {\n    return getTarget().hasBFloat16Type();\n  }\n};\n\nclass AArch64TargetCodeGenInfo : public TargetCodeGenInfo {\npublic:\n  AArch64TargetCodeGenInfo(CodeGenTypes &CGT, AArch64ABIInfo::ABIKind Kind)\n      : TargetCodeGenInfo(std::make_unique<AArch64ABIInfo>(CGT, Kind)) {}\n\n  StringRef getARCRetainAutoreleasedReturnValueMarker() const override {\n    return \"mov\\tfp, fp\\t\\t// marker for objc_retainAutoreleaseReturnValue\";\n  }\n\n  int getDwarfEHStackPointer(CodeGen::CodeGenModule &M) const override {\n    return 31;\n  }\n\n  bool doesReturnSlotInterfereWithArgs() const override { return false; }\n\n  void setTargetAttributes(const Decl *D, llvm::GlobalValue *GV,\n                           CodeGen::CodeGenModule &CGM) const override {\n    const FunctionDecl *FD = dyn_cast_or_null<FunctionDecl>(D);\n    if (!FD)\n      return;\n\n    const auto *TA = FD->getAttr<TargetAttr>();\n    if (TA == nullptr)\n      return;\n\n    ParsedTargetAttr Attr = TA->parse();\n    if (Attr.BranchProtection.empty())\n      return;\n\n    TargetInfo::BranchProtectionInfo BPI;\n    StringRef Error;\n    (void)CGM.getTarget().validateBranchProtection(Attr.BranchProtection,\n                                                   BPI, Error);\n    assert(Error.empty());\n\n    auto *Fn = cast<llvm::Function>(GV);\n    static const char *SignReturnAddrStr[] = {\"none\", \"non-leaf\", \"all\"};\n    Fn->addFnAttr(\"sign-return-address\", SignReturnAddrStr[static_cast<int>(BPI.SignReturnAddr)]);\n\n    if (BPI.SignReturnAddr != LangOptions::SignReturnAddressScopeKind::None) {\n      Fn->addFnAttr(\"sign-return-address-key\",\n                    BPI.SignKey == LangOptions::SignReturnAddressKeyKind::AKey\n                        ? \"a_key\"\n                        : \"b_key\");\n    }\n\n    Fn->addFnAttr(\"branch-target-enforcement\",\n                  BPI.BranchTargetEnforcement ? \"true\" : \"false\");\n  }\n};\n\nclass WindowsAArch64TargetCodeGenInfo : public AArch64TargetCodeGenInfo {\npublic:\n  WindowsAArch64TargetCodeGenInfo(CodeGenTypes &CGT, AArch64ABIInfo::ABIKind K)\n      : AArch64TargetCodeGenInfo(CGT, K) {}\n\n  void setTargetAttributes(const Decl *D, llvm::GlobalValue *GV,\n                           CodeGen::CodeGenModule &CGM) const override;\n\n  void getDependentLibraryOption(llvm::StringRef Lib,\n                                 llvm::SmallString<24> &Opt) const override {\n    Opt = \"/DEFAULTLIB:\" + qualifyWindowsLibrary(Lib);\n  }\n\n  void getDetectMismatchOption(llvm::StringRef Name, llvm::StringRef Value,\n                               llvm::SmallString<32> &Opt) const override {\n    Opt = \"/FAILIFMISMATCH:\\\"\" + Name.str() + \"=\" + Value.str() + \"\\\"\";\n  }\n};\n\nvoid WindowsAArch64TargetCodeGenInfo::setTargetAttributes(\n    const Decl *D, llvm::GlobalValue *GV, CodeGen::CodeGenModule &CGM) const {\n  AArch64TargetCodeGenInfo::setTargetAttributes(D, GV, CGM);\n  if (GV->isDeclaration())\n    return;\n  addStackProbeTargetAttributes(D, GV, CGM);\n}\n}\n\nABIArgInfo AArch64ABIInfo::coerceIllegalVector(QualType Ty) const {\n  assert(Ty->isVectorType() && \"expected vector type!\");\n\n  const auto *VT = Ty->castAs<VectorType>();\n  if (VT->getVectorKind() == VectorType::SveFixedLengthPredicateVector) {\n    assert(VT->getElementType()->isBuiltinType() && \"expected builtin type!\");\n    assert(VT->getElementType()->castAs<BuiltinType>()->getKind() ==\n               BuiltinType::UChar &&\n           \"unexpected builtin type for SVE predicate!\");\n    return ABIArgInfo::getDirect(llvm::ScalableVectorType::get(\n        llvm::Type::getInt1Ty(getVMContext()), 16));\n  }\n\n  if (VT->getVectorKind() == VectorType::SveFixedLengthDataVector) {\n    assert(VT->getElementType()->isBuiltinType() && \"expected builtin type!\");\n\n    const auto *BT = VT->getElementType()->castAs<BuiltinType>();\n    llvm::ScalableVectorType *ResType = nullptr;\n    switch (BT->getKind()) {\n    default:\n      llvm_unreachable(\"unexpected builtin type for SVE vector!\");\n    case BuiltinType::SChar:\n    case BuiltinType::UChar:\n      ResType = llvm::ScalableVectorType::get(\n          llvm::Type::getInt8Ty(getVMContext()), 16);\n      break;\n    case BuiltinType::Short:\n    case BuiltinType::UShort:\n      ResType = llvm::ScalableVectorType::get(\n          llvm::Type::getInt16Ty(getVMContext()), 8);\n      break;\n    case BuiltinType::Int:\n    case BuiltinType::UInt:\n      ResType = llvm::ScalableVectorType::get(\n          llvm::Type::getInt32Ty(getVMContext()), 4);\n      break;\n    case BuiltinType::Long:\n    case BuiltinType::ULong:\n      ResType = llvm::ScalableVectorType::get(\n          llvm::Type::getInt64Ty(getVMContext()), 2);\n      break;\n    case BuiltinType::Half:\n      ResType = llvm::ScalableVectorType::get(\n          llvm::Type::getHalfTy(getVMContext()), 8);\n      break;\n    case BuiltinType::Float:\n      ResType = llvm::ScalableVectorType::get(\n          llvm::Type::getFloatTy(getVMContext()), 4);\n      break;\n    case BuiltinType::Double:\n      ResType = llvm::ScalableVectorType::get(\n          llvm::Type::getDoubleTy(getVMContext()), 2);\n      break;\n    case BuiltinType::BFloat16:\n      ResType = llvm::ScalableVectorType::get(\n          llvm::Type::getBFloatTy(getVMContext()), 8);\n      break;\n    }\n    return ABIArgInfo::getDirect(ResType);\n  }\n\n  uint64_t Size = getContext().getTypeSize(Ty);\n  // Android promotes <2 x i8> to i16, not i32\n  if (isAndroid() && (Size <= 16)) {\n    llvm::Type *ResType = llvm::Type::getInt16Ty(getVMContext());\n    return ABIArgInfo::getDirect(ResType);\n  }\n  if (Size <= 32) {\n    llvm::Type *ResType = llvm::Type::getInt32Ty(getVMContext());\n    return ABIArgInfo::getDirect(ResType);\n  }\n  if (Size == 64) {\n    auto *ResType =\n        llvm::FixedVectorType::get(llvm::Type::getInt32Ty(getVMContext()), 2);\n    return ABIArgInfo::getDirect(ResType);\n  }\n  if (Size == 128) {\n    auto *ResType =\n        llvm::FixedVectorType::get(llvm::Type::getInt32Ty(getVMContext()), 4);\n    return ABIArgInfo::getDirect(ResType);\n  }\n  return getNaturalAlignIndirect(Ty, /*ByVal=*/false);\n}\n\nABIArgInfo AArch64ABIInfo::classifyArgumentType(QualType Ty) const {\n  Ty = useFirstFieldIfTransparentUnion(Ty);\n\n  // Handle illegal vector types here.\n  if (isIllegalVectorType(Ty))\n    return coerceIllegalVector(Ty);\n\n  if (!isAggregateTypeForABI(Ty)) {\n    // Treat an enum type as its underlying type.\n    if (const EnumType *EnumTy = Ty->getAs<EnumType>())\n      Ty = EnumTy->getDecl()->getIntegerType();\n\n    if (const auto *EIT = Ty->getAs<ExtIntType>())\n      if (EIT->getNumBits() > 128)\n        return getNaturalAlignIndirect(Ty);\n\n    return (isPromotableIntegerTypeForABI(Ty) && isDarwinPCS()\n                ? ABIArgInfo::getExtend(Ty)\n                : ABIArgInfo::getDirect());\n  }\n\n  // Structures with either a non-trivial destructor or a non-trivial\n  // copy constructor are always indirect.\n  if (CGCXXABI::RecordArgABI RAA = getRecordArgABI(Ty, getCXXABI())) {\n    return getNaturalAlignIndirect(Ty, /*ByVal=*/RAA ==\n                                     CGCXXABI::RAA_DirectInMemory);\n  }\n\n  // Empty records are always ignored on Darwin, but actually passed in C++ mode\n  // elsewhere for GNU compatibility.\n  uint64_t Size = getContext().getTypeSize(Ty);\n  bool IsEmpty = isEmptyRecord(getContext(), Ty, true);\n  if (IsEmpty || Size == 0) {\n    if (!getContext().getLangOpts().CPlusPlus || isDarwinPCS())\n      return ABIArgInfo::getIgnore();\n\n    // GNU C mode. The only argument that gets ignored is an empty one with size\n    // 0.\n    if (IsEmpty && Size == 0)\n      return ABIArgInfo::getIgnore();\n    return ABIArgInfo::getDirect(llvm::Type::getInt8Ty(getVMContext()));\n  }\n\n  // Homogeneous Floating-point Aggregates (HFAs) need to be expanded.\n  const Type *Base = nullptr;\n  uint64_t Members = 0;\n  if (isHomogeneousAggregate(Ty, Base, Members)) {\n    return ABIArgInfo::getDirect(\n        llvm::ArrayType::get(CGT.ConvertType(QualType(Base, 0)), Members));\n  }\n\n  // Aggregates <= 16 bytes are passed directly in registers or on the stack.\n  if (Size <= 128) {\n    // On RenderScript, coerce Aggregates <= 16 bytes to an integer array of\n    // same size and alignment.\n    if (getTarget().isRenderScriptTarget()) {\n      return coerceToIntArray(Ty, getContext(), getVMContext());\n    }\n    unsigned Alignment;\n    if (Kind == AArch64ABIInfo::AAPCS) {\n      Alignment = getContext().getTypeUnadjustedAlign(Ty);\n      Alignment = Alignment < 128 ? 64 : 128;\n    } else {\n      Alignment = std::max(getContext().getTypeAlign(Ty),\n                           (unsigned)getTarget().getPointerWidth(0));\n    }\n    Size = llvm::alignTo(Size, Alignment);\n\n    // We use a pair of i64 for 16-byte aggregate with 8-byte alignment.\n    // For aggregates with 16-byte alignment, we use i128.\n    llvm::Type *BaseTy = llvm::Type::getIntNTy(getVMContext(), Alignment);\n    return ABIArgInfo::getDirect(\n        Size == Alignment ? BaseTy\n                          : llvm::ArrayType::get(BaseTy, Size / Alignment));\n  }\n\n  return getNaturalAlignIndirect(Ty, /*ByVal=*/false);\n}\n\nABIArgInfo AArch64ABIInfo::classifyReturnType(QualType RetTy,\n                                              bool IsVariadic) const {\n  if (RetTy->isVoidType())\n    return ABIArgInfo::getIgnore();\n\n  if (const auto *VT = RetTy->getAs<VectorType>()) {\n    if (VT->getVectorKind() == VectorType::SveFixedLengthDataVector ||\n        VT->getVectorKind() == VectorType::SveFixedLengthPredicateVector)\n      return coerceIllegalVector(RetTy);\n  }\n\n  // Large vector types should be returned via memory.\n  if (RetTy->isVectorType() && getContext().getTypeSize(RetTy) > 128)\n    return getNaturalAlignIndirect(RetTy);\n\n  if (!isAggregateTypeForABI(RetTy)) {\n    // Treat an enum type as its underlying type.\n    if (const EnumType *EnumTy = RetTy->getAs<EnumType>())\n      RetTy = EnumTy->getDecl()->getIntegerType();\n\n    if (const auto *EIT = RetTy->getAs<ExtIntType>())\n      if (EIT->getNumBits() > 128)\n        return getNaturalAlignIndirect(RetTy);\n\n    return (isPromotableIntegerTypeForABI(RetTy) && isDarwinPCS()\n                ? ABIArgInfo::getExtend(RetTy)\n                : ABIArgInfo::getDirect());\n  }\n\n  uint64_t Size = getContext().getTypeSize(RetTy);\n  if (isEmptyRecord(getContext(), RetTy, true) || Size == 0)\n    return ABIArgInfo::getIgnore();\n\n  const Type *Base = nullptr;\n  uint64_t Members = 0;\n  if (isHomogeneousAggregate(RetTy, Base, Members) &&\n      !(getTarget().getTriple().getArch() == llvm::Triple::aarch64_32 &&\n        IsVariadic))\n    // Homogeneous Floating-point Aggregates (HFAs) are returned directly.\n    return ABIArgInfo::getDirect();\n\n  // Aggregates <= 16 bytes are returned directly in registers or on the stack.\n  if (Size <= 128) {\n    // On RenderScript, coerce Aggregates <= 16 bytes to an integer array of\n    // same size and alignment.\n    if (getTarget().isRenderScriptTarget()) {\n      return coerceToIntArray(RetTy, getContext(), getVMContext());\n    }\n    unsigned Alignment = getContext().getTypeAlign(RetTy);\n    Size = llvm::alignTo(Size, 64); // round up to multiple of 8 bytes\n\n    // We use a pair of i64 for 16-byte aggregate with 8-byte alignment.\n    // For aggregates with 16-byte alignment, we use i128.\n    if (Alignment < 128 && Size == 128) {\n      llvm::Type *BaseTy = llvm::Type::getInt64Ty(getVMContext());\n      return ABIArgInfo::getDirect(llvm::ArrayType::get(BaseTy, Size / 64));\n    }\n    return ABIArgInfo::getDirect(llvm::IntegerType::get(getVMContext(), Size));\n  }\n\n  return getNaturalAlignIndirect(RetTy);\n}\n\n/// isIllegalVectorType - check whether the vector type is legal for AArch64.\nbool AArch64ABIInfo::isIllegalVectorType(QualType Ty) const {\n  if (const VectorType *VT = Ty->getAs<VectorType>()) {\n    // Check whether VT is a fixed-length SVE vector. These types are\n    // represented as scalable vectors in function args/return and must be\n    // coerced from fixed vectors.\n    if (VT->getVectorKind() == VectorType::SveFixedLengthDataVector ||\n        VT->getVectorKind() == VectorType::SveFixedLengthPredicateVector)\n      return true;\n\n    // Check whether VT is legal.\n    unsigned NumElements = VT->getNumElements();\n    uint64_t Size = getContext().getTypeSize(VT);\n    // NumElements should be power of 2.\n    if (!llvm::isPowerOf2_32(NumElements))\n      return true;\n\n    // arm64_32 has to be compatible with the ARM logic here, which allows huge\n    // vectors for some reason.\n    llvm::Triple Triple = getTarget().getTriple();\n    if (Triple.getArch() == llvm::Triple::aarch64_32 &&\n        Triple.isOSBinFormatMachO())\n      return Size <= 32;\n\n    return Size != 64 && (Size != 128 || NumElements == 1);\n  }\n  return false;\n}\n\nbool AArch64ABIInfo::isLegalVectorTypeForSwift(CharUnits totalSize,\n                                               llvm::Type *eltTy,\n                                               unsigned elts) const {\n  if (!llvm::isPowerOf2_32(elts))\n    return false;\n  if (totalSize.getQuantity() != 8 &&\n      (totalSize.getQuantity() != 16 || elts == 1))\n    return false;\n  return true;\n}\n\nbool AArch64ABIInfo::isHomogeneousAggregateBaseType(QualType Ty) const {\n  // Homogeneous aggregates for AAPCS64 must have base types of a floating\n  // point type or a short-vector type. This is the same as the 32-bit ABI,\n  // but with the difference that any floating-point type is allowed,\n  // including __fp16.\n  if (const BuiltinType *BT = Ty->getAs<BuiltinType>()) {\n    if (BT->isFloatingPoint())\n      return true;\n  } else if (const VectorType *VT = Ty->getAs<VectorType>()) {\n    unsigned VecSize = getContext().getTypeSize(VT);\n    if (VecSize == 64 || VecSize == 128)\n      return true;\n  }\n  return false;\n}\n\nbool AArch64ABIInfo::isHomogeneousAggregateSmallEnough(const Type *Base,\n                                                       uint64_t Members) const {\n  return Members <= 4;\n}\n\nAddress AArch64ABIInfo::EmitAAPCSVAArg(Address VAListAddr,\n                                            QualType Ty,\n                                            CodeGenFunction &CGF) const {\n  ABIArgInfo AI = classifyArgumentType(Ty);\n  bool IsIndirect = AI.isIndirect();\n\n  llvm::Type *BaseTy = CGF.ConvertType(Ty);\n  if (IsIndirect)\n    BaseTy = llvm::PointerType::getUnqual(BaseTy);\n  else if (AI.getCoerceToType())\n    BaseTy = AI.getCoerceToType();\n\n  unsigned NumRegs = 1;\n  if (llvm::ArrayType *ArrTy = dyn_cast<llvm::ArrayType>(BaseTy)) {\n    BaseTy = ArrTy->getElementType();\n    NumRegs = ArrTy->getNumElements();\n  }\n  bool IsFPR = BaseTy->isFloatingPointTy() || BaseTy->isVectorTy();\n\n  // The AArch64 va_list type and handling is specified in the Procedure Call\n  // Standard, section B.4:\n  //\n  // struct {\n  //   void *__stack;\n  //   void *__gr_top;\n  //   void *__vr_top;\n  //   int __gr_offs;\n  //   int __vr_offs;\n  // };\n\n  llvm::BasicBlock *MaybeRegBlock = CGF.createBasicBlock(\"vaarg.maybe_reg\");\n  llvm::BasicBlock *InRegBlock = CGF.createBasicBlock(\"vaarg.in_reg\");\n  llvm::BasicBlock *OnStackBlock = CGF.createBasicBlock(\"vaarg.on_stack\");\n  llvm::BasicBlock *ContBlock = CGF.createBasicBlock(\"vaarg.end\");\n\n  CharUnits TySize = getContext().getTypeSizeInChars(Ty);\n  CharUnits TyAlign = getContext().getTypeUnadjustedAlignInChars(Ty);\n\n  Address reg_offs_p = Address::invalid();\n  llvm::Value *reg_offs = nullptr;\n  int reg_top_index;\n  int RegSize = IsIndirect ? 8 : TySize.getQuantity();\n  if (!IsFPR) {\n    // 3 is the field number of __gr_offs\n    reg_offs_p = CGF.Builder.CreateStructGEP(VAListAddr, 3, \"gr_offs_p\");\n    reg_offs = CGF.Builder.CreateLoad(reg_offs_p, \"gr_offs\");\n    reg_top_index = 1; // field number for __gr_top\n    RegSize = llvm::alignTo(RegSize, 8);\n  } else {\n    // 4 is the field number of __vr_offs.\n    reg_offs_p = CGF.Builder.CreateStructGEP(VAListAddr, 4, \"vr_offs_p\");\n    reg_offs = CGF.Builder.CreateLoad(reg_offs_p, \"vr_offs\");\n    reg_top_index = 2; // field number for __vr_top\n    RegSize = 16 * NumRegs;\n  }\n\n  //=======================================\n  // Find out where argument was passed\n  //=======================================\n\n  // If reg_offs >= 0 we're already using the stack for this type of\n  // argument. We don't want to keep updating reg_offs (in case it overflows,\n  // though anyone passing 2GB of arguments, each at most 16 bytes, deserves\n  // whatever they get).\n  llvm::Value *UsingStack = nullptr;\n  UsingStack = CGF.Builder.CreateICmpSGE(\n      reg_offs, llvm::ConstantInt::get(CGF.Int32Ty, 0));\n\n  CGF.Builder.CreateCondBr(UsingStack, OnStackBlock, MaybeRegBlock);\n\n  // Otherwise, at least some kind of argument could go in these registers, the\n  // question is whether this particular type is too big.\n  CGF.EmitBlock(MaybeRegBlock);\n\n  // Integer arguments may need to correct register alignment (for example a\n  // \"struct { __int128 a; };\" gets passed in x_2N, x_{2N+1}). In this case we\n  // align __gr_offs to calculate the potential address.\n  if (!IsFPR && !IsIndirect && TyAlign.getQuantity() > 8) {\n    int Align = TyAlign.getQuantity();\n\n    reg_offs = CGF.Builder.CreateAdd(\n        reg_offs, llvm::ConstantInt::get(CGF.Int32Ty, Align - 1),\n        \"align_regoffs\");\n    reg_offs = CGF.Builder.CreateAnd(\n        reg_offs, llvm::ConstantInt::get(CGF.Int32Ty, -Align),\n        \"aligned_regoffs\");\n  }\n\n  // Update the gr_offs/vr_offs pointer for next call to va_arg on this va_list.\n  // The fact that this is done unconditionally reflects the fact that\n  // allocating an argument to the stack also uses up all the remaining\n  // registers of the appropriate kind.\n  llvm::Value *NewOffset = nullptr;\n  NewOffset = CGF.Builder.CreateAdd(\n      reg_offs, llvm::ConstantInt::get(CGF.Int32Ty, RegSize), \"new_reg_offs\");\n  CGF.Builder.CreateStore(NewOffset, reg_offs_p);\n\n  // Now we're in a position to decide whether this argument really was in\n  // registers or not.\n  llvm::Value *InRegs = nullptr;\n  InRegs = CGF.Builder.CreateICmpSLE(\n      NewOffset, llvm::ConstantInt::get(CGF.Int32Ty, 0), \"inreg\");\n\n  CGF.Builder.CreateCondBr(InRegs, InRegBlock, OnStackBlock);\n\n  //=======================================\n  // Argument was in registers\n  //=======================================\n\n  // Now we emit the code for if the argument was originally passed in\n  // registers. First start the appropriate block:\n  CGF.EmitBlock(InRegBlock);\n\n  llvm::Value *reg_top = nullptr;\n  Address reg_top_p =\n      CGF.Builder.CreateStructGEP(VAListAddr, reg_top_index, \"reg_top_p\");\n  reg_top = CGF.Builder.CreateLoad(reg_top_p, \"reg_top\");\n  Address BaseAddr(CGF.Builder.CreateInBoundsGEP(reg_top, reg_offs),\n                   CharUnits::fromQuantity(IsFPR ? 16 : 8));\n  Address RegAddr = Address::invalid();\n  llvm::Type *MemTy = CGF.ConvertTypeForMem(Ty);\n\n  if (IsIndirect) {\n    // If it's been passed indirectly (actually a struct), whatever we find from\n    // stored registers or on the stack will actually be a struct **.\n    MemTy = llvm::PointerType::getUnqual(MemTy);\n  }\n\n  const Type *Base = nullptr;\n  uint64_t NumMembers = 0;\n  bool IsHFA = isHomogeneousAggregate(Ty, Base, NumMembers);\n  if (IsHFA && NumMembers > 1) {\n    // Homogeneous aggregates passed in registers will have their elements split\n    // and stored 16-bytes apart regardless of size (they're notionally in qN,\n    // qN+1, ...). We reload and store into a temporary local variable\n    // contiguously.\n    assert(!IsIndirect && \"Homogeneous aggregates should be passed directly\");\n    auto BaseTyInfo = getContext().getTypeInfoInChars(QualType(Base, 0));\n    llvm::Type *BaseTy = CGF.ConvertType(QualType(Base, 0));\n    llvm::Type *HFATy = llvm::ArrayType::get(BaseTy, NumMembers);\n    Address Tmp = CGF.CreateTempAlloca(HFATy,\n                                       std::max(TyAlign, BaseTyInfo.Align));\n\n    // On big-endian platforms, the value will be right-aligned in its slot.\n    int Offset = 0;\n    if (CGF.CGM.getDataLayout().isBigEndian() &&\n        BaseTyInfo.Width.getQuantity() < 16)\n      Offset = 16 - BaseTyInfo.Width.getQuantity();\n\n    for (unsigned i = 0; i < NumMembers; ++i) {\n      CharUnits BaseOffset = CharUnits::fromQuantity(16 * i + Offset);\n      Address LoadAddr =\n        CGF.Builder.CreateConstInBoundsByteGEP(BaseAddr, BaseOffset);\n      LoadAddr = CGF.Builder.CreateElementBitCast(LoadAddr, BaseTy);\n\n      Address StoreAddr = CGF.Builder.CreateConstArrayGEP(Tmp, i);\n\n      llvm::Value *Elem = CGF.Builder.CreateLoad(LoadAddr);\n      CGF.Builder.CreateStore(Elem, StoreAddr);\n    }\n\n    RegAddr = CGF.Builder.CreateElementBitCast(Tmp, MemTy);\n  } else {\n    // Otherwise the object is contiguous in memory.\n\n    // It might be right-aligned in its slot.\n    CharUnits SlotSize = BaseAddr.getAlignment();\n    if (CGF.CGM.getDataLayout().isBigEndian() && !IsIndirect &&\n        (IsHFA || !isAggregateTypeForABI(Ty)) &&\n        TySize < SlotSize) {\n      CharUnits Offset = SlotSize - TySize;\n      BaseAddr = CGF.Builder.CreateConstInBoundsByteGEP(BaseAddr, Offset);\n    }\n\n    RegAddr = CGF.Builder.CreateElementBitCast(BaseAddr, MemTy);\n  }\n\n  CGF.EmitBranch(ContBlock);\n\n  //=======================================\n  // Argument was on the stack\n  //=======================================\n  CGF.EmitBlock(OnStackBlock);\n\n  Address stack_p = CGF.Builder.CreateStructGEP(VAListAddr, 0, \"stack_p\");\n  llvm::Value *OnStackPtr = CGF.Builder.CreateLoad(stack_p, \"stack\");\n\n  // Again, stack arguments may need realignment. In this case both integer and\n  // floating-point ones might be affected.\n  if (!IsIndirect && TyAlign.getQuantity() > 8) {\n    int Align = TyAlign.getQuantity();\n\n    OnStackPtr = CGF.Builder.CreatePtrToInt(OnStackPtr, CGF.Int64Ty);\n\n    OnStackPtr = CGF.Builder.CreateAdd(\n        OnStackPtr, llvm::ConstantInt::get(CGF.Int64Ty, Align - 1),\n        \"align_stack\");\n    OnStackPtr = CGF.Builder.CreateAnd(\n        OnStackPtr, llvm::ConstantInt::get(CGF.Int64Ty, -Align),\n        \"align_stack\");\n\n    OnStackPtr = CGF.Builder.CreateIntToPtr(OnStackPtr, CGF.Int8PtrTy);\n  }\n  Address OnStackAddr(OnStackPtr,\n                      std::max(CharUnits::fromQuantity(8), TyAlign));\n\n  // All stack slots are multiples of 8 bytes.\n  CharUnits StackSlotSize = CharUnits::fromQuantity(8);\n  CharUnits StackSize;\n  if (IsIndirect)\n    StackSize = StackSlotSize;\n  else\n    StackSize = TySize.alignTo(StackSlotSize);\n\n  llvm::Value *StackSizeC = CGF.Builder.getSize(StackSize);\n  llvm::Value *NewStack =\n      CGF.Builder.CreateInBoundsGEP(OnStackPtr, StackSizeC, \"new_stack\");\n\n  // Write the new value of __stack for the next call to va_arg\n  CGF.Builder.CreateStore(NewStack, stack_p);\n\n  if (CGF.CGM.getDataLayout().isBigEndian() && !isAggregateTypeForABI(Ty) &&\n      TySize < StackSlotSize) {\n    CharUnits Offset = StackSlotSize - TySize;\n    OnStackAddr = CGF.Builder.CreateConstInBoundsByteGEP(OnStackAddr, Offset);\n  }\n\n  OnStackAddr = CGF.Builder.CreateElementBitCast(OnStackAddr, MemTy);\n\n  CGF.EmitBranch(ContBlock);\n\n  //=======================================\n  // Tidy up\n  //=======================================\n  CGF.EmitBlock(ContBlock);\n\n  Address ResAddr = emitMergePHI(CGF, RegAddr, InRegBlock,\n                                 OnStackAddr, OnStackBlock, \"vaargs.addr\");\n\n  if (IsIndirect)\n    return Address(CGF.Builder.CreateLoad(ResAddr, \"vaarg.addr\"),\n                   TyAlign);\n\n  return ResAddr;\n}\n\nAddress AArch64ABIInfo::EmitDarwinVAArg(Address VAListAddr, QualType Ty,\n                                        CodeGenFunction &CGF) const {\n  // The backend's lowering doesn't support va_arg for aggregates or\n  // illegal vector types.  Lower VAArg here for these cases and use\n  // the LLVM va_arg instruction for everything else.\n  if (!isAggregateTypeForABI(Ty) && !isIllegalVectorType(Ty))\n    return EmitVAArgInstr(CGF, VAListAddr, Ty, ABIArgInfo::getDirect());\n\n  uint64_t PointerSize = getTarget().getPointerWidth(0) / 8;\n  CharUnits SlotSize = CharUnits::fromQuantity(PointerSize);\n\n  // Empty records are ignored for parameter passing purposes.\n  if (isEmptyRecord(getContext(), Ty, true)) {\n    Address Addr(CGF.Builder.CreateLoad(VAListAddr, \"ap.cur\"), SlotSize);\n    Addr = CGF.Builder.CreateElementBitCast(Addr, CGF.ConvertTypeForMem(Ty));\n    return Addr;\n  }\n\n  // The size of the actual thing passed, which might end up just\n  // being a pointer for indirect types.\n  auto TyInfo = getContext().getTypeInfoInChars(Ty);\n\n  // Arguments bigger than 16 bytes which aren't homogeneous\n  // aggregates should be passed indirectly.\n  bool IsIndirect = false;\n  if (TyInfo.Width.getQuantity() > 16) {\n    const Type *Base = nullptr;\n    uint64_t Members = 0;\n    IsIndirect = !isHomogeneousAggregate(Ty, Base, Members);\n  }\n\n  return emitVoidPtrVAArg(CGF, VAListAddr, Ty, IsIndirect,\n                          TyInfo, SlotSize, /*AllowHigherAlign*/ true);\n}\n\nAddress AArch64ABIInfo::EmitMSVAArg(CodeGenFunction &CGF, Address VAListAddr,\n                                    QualType Ty) const {\n  return emitVoidPtrVAArg(CGF, VAListAddr, Ty, /*indirect*/ false,\n                          CGF.getContext().getTypeInfoInChars(Ty),\n                          CharUnits::fromQuantity(8),\n                          /*allowHigherAlign*/ false);\n}\n\n//===----------------------------------------------------------------------===//\n// ARM ABI Implementation\n//===----------------------------------------------------------------------===//\n\nnamespace {\n\nclass ARMABIInfo : public SwiftABIInfo {\npublic:\n  enum ABIKind {\n    APCS = 0,\n    AAPCS = 1,\n    AAPCS_VFP = 2,\n    AAPCS16_VFP = 3,\n  };\n\nprivate:\n  ABIKind Kind;\n  bool IsFloatABISoftFP;\n\npublic:\n  ARMABIInfo(CodeGenTypes &CGT, ABIKind _Kind)\n      : SwiftABIInfo(CGT), Kind(_Kind) {\n    setCCs();\n    IsFloatABISoftFP = CGT.getCodeGenOpts().FloatABI == \"softfp\" ||\n        CGT.getCodeGenOpts().FloatABI == \"\"; // default\n  }\n\n  bool isEABI() const {\n    switch (getTarget().getTriple().getEnvironment()) {\n    case llvm::Triple::Android:\n    case llvm::Triple::EABI:\n    case llvm::Triple::EABIHF:\n    case llvm::Triple::GNUEABI:\n    case llvm::Triple::GNUEABIHF:\n    case llvm::Triple::MuslEABI:\n    case llvm::Triple::MuslEABIHF:\n      return true;\n    default:\n      return false;\n    }\n  }\n\n  bool isEABIHF() const {\n    switch (getTarget().getTriple().getEnvironment()) {\n    case llvm::Triple::EABIHF:\n    case llvm::Triple::GNUEABIHF:\n    case llvm::Triple::MuslEABIHF:\n      return true;\n    default:\n      return false;\n    }\n  }\n\n  ABIKind getABIKind() const { return Kind; }\n\n  bool allowBFloatArgsAndRet() const override {\n    return !IsFloatABISoftFP && getTarget().hasBFloat16Type();\n  }\n\nprivate:\n  ABIArgInfo classifyReturnType(QualType RetTy, bool isVariadic,\n                                unsigned functionCallConv) const;\n  ABIArgInfo classifyArgumentType(QualType RetTy, bool isVariadic,\n                                  unsigned functionCallConv) const;\n  ABIArgInfo classifyHomogeneousAggregate(QualType Ty, const Type *Base,\n                                          uint64_t Members) const;\n  ABIArgInfo coerceIllegalVector(QualType Ty) const;\n  bool isIllegalVectorType(QualType Ty) const;\n  bool containsAnyFP16Vectors(QualType Ty) const;\n\n  bool isHomogeneousAggregateBaseType(QualType Ty) const override;\n  bool isHomogeneousAggregateSmallEnough(const Type *Ty,\n                                         uint64_t Members) const override;\n\n  bool isEffectivelyAAPCS_VFP(unsigned callConvention, bool acceptHalf) const;\n\n  void computeInfo(CGFunctionInfo &FI) const override;\n\n  Address EmitVAArg(CodeGenFunction &CGF, Address VAListAddr,\n                    QualType Ty) const override;\n\n  llvm::CallingConv::ID getLLVMDefaultCC() const;\n  llvm::CallingConv::ID getABIDefaultCC() const;\n  void setCCs();\n\n  bool shouldPassIndirectlyForSwift(ArrayRef<llvm::Type*> scalars,\n                                    bool asReturnValue) const override {\n    return occupiesMoreThan(CGT, scalars, /*total*/ 4);\n  }\n  bool isSwiftErrorInRegister() const override {\n    return true;\n  }\n  bool isLegalVectorTypeForSwift(CharUnits totalSize, llvm::Type *eltTy,\n                                 unsigned elts) const override;\n};\n\nclass ARMTargetCodeGenInfo : public TargetCodeGenInfo {\npublic:\n  ARMTargetCodeGenInfo(CodeGenTypes &CGT, ARMABIInfo::ABIKind K)\n      : TargetCodeGenInfo(std::make_unique<ARMABIInfo>(CGT, K)) {}\n\n  const ARMABIInfo &getABIInfo() const {\n    return static_cast<const ARMABIInfo&>(TargetCodeGenInfo::getABIInfo());\n  }\n\n  int getDwarfEHStackPointer(CodeGen::CodeGenModule &M) const override {\n    return 13;\n  }\n\n  StringRef getARCRetainAutoreleasedReturnValueMarker() const override {\n    return \"mov\\tr7, r7\\t\\t// marker for objc_retainAutoreleaseReturnValue\";\n  }\n\n  bool initDwarfEHRegSizeTable(CodeGen::CodeGenFunction &CGF,\n                               llvm::Value *Address) const override {\n    llvm::Value *Four8 = llvm::ConstantInt::get(CGF.Int8Ty, 4);\n\n    // 0-15 are the 16 integer registers.\n    AssignToArrayRange(CGF.Builder, Address, Four8, 0, 15);\n    return false;\n  }\n\n  unsigned getSizeOfUnwindException() const override {\n    if (getABIInfo().isEABI()) return 88;\n    return TargetCodeGenInfo::getSizeOfUnwindException();\n  }\n\n  void setTargetAttributes(const Decl *D, llvm::GlobalValue *GV,\n                           CodeGen::CodeGenModule &CGM) const override {\n    if (GV->isDeclaration())\n      return;\n    const FunctionDecl *FD = dyn_cast_or_null<FunctionDecl>(D);\n    if (!FD)\n      return;\n\n    const ARMInterruptAttr *Attr = FD->getAttr<ARMInterruptAttr>();\n    if (!Attr)\n      return;\n\n    const char *Kind;\n    switch (Attr->getInterrupt()) {\n    case ARMInterruptAttr::Generic: Kind = \"\"; break;\n    case ARMInterruptAttr::IRQ:     Kind = \"IRQ\"; break;\n    case ARMInterruptAttr::FIQ:     Kind = \"FIQ\"; break;\n    case ARMInterruptAttr::SWI:     Kind = \"SWI\"; break;\n    case ARMInterruptAttr::ABORT:   Kind = \"ABORT\"; break;\n    case ARMInterruptAttr::UNDEF:   Kind = \"UNDEF\"; break;\n    }\n\n    llvm::Function *Fn = cast<llvm::Function>(GV);\n\n    Fn->addFnAttr(\"interrupt\", Kind);\n\n    ARMABIInfo::ABIKind ABI = cast<ARMABIInfo>(getABIInfo()).getABIKind();\n    if (ABI == ARMABIInfo::APCS)\n      return;\n\n    // AAPCS guarantees that sp will be 8-byte aligned on any public interface,\n    // however this is not necessarily true on taking any interrupt. Instruct\n    // the backend to perform a realignment as part of the function prologue.\n    llvm::AttrBuilder B;\n    B.addStackAlignmentAttr(8);\n    Fn->addAttributes(llvm::AttributeList::FunctionIndex, B);\n  }\n};\n\nclass WindowsARMTargetCodeGenInfo : public ARMTargetCodeGenInfo {\npublic:\n  WindowsARMTargetCodeGenInfo(CodeGenTypes &CGT, ARMABIInfo::ABIKind K)\n      : ARMTargetCodeGenInfo(CGT, K) {}\n\n  void setTargetAttributes(const Decl *D, llvm::GlobalValue *GV,\n                           CodeGen::CodeGenModule &CGM) const override;\n\n  void getDependentLibraryOption(llvm::StringRef Lib,\n                                 llvm::SmallString<24> &Opt) const override {\n    Opt = \"/DEFAULTLIB:\" + qualifyWindowsLibrary(Lib);\n  }\n\n  void getDetectMismatchOption(llvm::StringRef Name, llvm::StringRef Value,\n                               llvm::SmallString<32> &Opt) const override {\n    Opt = \"/FAILIFMISMATCH:\\\"\" + Name.str() + \"=\" + Value.str() + \"\\\"\";\n  }\n};\n\nvoid WindowsARMTargetCodeGenInfo::setTargetAttributes(\n    const Decl *D, llvm::GlobalValue *GV, CodeGen::CodeGenModule &CGM) const {\n  ARMTargetCodeGenInfo::setTargetAttributes(D, GV, CGM);\n  if (GV->isDeclaration())\n    return;\n  addStackProbeTargetAttributes(D, GV, CGM);\n}\n}\n\nvoid ARMABIInfo::computeInfo(CGFunctionInfo &FI) const {\n  if (!::classifyReturnType(getCXXABI(), FI, *this))\n    FI.getReturnInfo() = classifyReturnType(FI.getReturnType(), FI.isVariadic(),\n                                            FI.getCallingConvention());\n\n  for (auto &I : FI.arguments())\n    I.info = classifyArgumentType(I.type, FI.isVariadic(),\n                                  FI.getCallingConvention());\n\n\n  // Always honor user-specified calling convention.\n  if (FI.getCallingConvention() != llvm::CallingConv::C)\n    return;\n\n  llvm::CallingConv::ID cc = getRuntimeCC();\n  if (cc != llvm::CallingConv::C)\n    FI.setEffectiveCallingConvention(cc);\n}\n\n/// Return the default calling convention that LLVM will use.\nllvm::CallingConv::ID ARMABIInfo::getLLVMDefaultCC() const {\n  // The default calling convention that LLVM will infer.\n  if (isEABIHF() || getTarget().getTriple().isWatchABI())\n    return llvm::CallingConv::ARM_AAPCS_VFP;\n  else if (isEABI())\n    return llvm::CallingConv::ARM_AAPCS;\n  else\n    return llvm::CallingConv::ARM_APCS;\n}\n\n/// Return the calling convention that our ABI would like us to use\n/// as the C calling convention.\nllvm::CallingConv::ID ARMABIInfo::getABIDefaultCC() const {\n  switch (getABIKind()) {\n  case APCS: return llvm::CallingConv::ARM_APCS;\n  case AAPCS: return llvm::CallingConv::ARM_AAPCS;\n  case AAPCS_VFP: return llvm::CallingConv::ARM_AAPCS_VFP;\n  case AAPCS16_VFP: return llvm::CallingConv::ARM_AAPCS_VFP;\n  }\n  llvm_unreachable(\"bad ABI kind\");\n}\n\nvoid ARMABIInfo::setCCs() {\n  assert(getRuntimeCC() == llvm::CallingConv::C);\n\n  // Don't muddy up the IR with a ton of explicit annotations if\n  // they'd just match what LLVM will infer from the triple.\n  llvm::CallingConv::ID abiCC = getABIDefaultCC();\n  if (abiCC != getLLVMDefaultCC())\n    RuntimeCC = abiCC;\n}\n\nABIArgInfo ARMABIInfo::coerceIllegalVector(QualType Ty) const {\n  uint64_t Size = getContext().getTypeSize(Ty);\n  if (Size <= 32) {\n    llvm::Type *ResType =\n        llvm::Type::getInt32Ty(getVMContext());\n    return ABIArgInfo::getDirect(ResType);\n  }\n  if (Size == 64 || Size == 128) {\n    auto *ResType = llvm::FixedVectorType::get(\n        llvm::Type::getInt32Ty(getVMContext()), Size / 32);\n    return ABIArgInfo::getDirect(ResType);\n  }\n  return getNaturalAlignIndirect(Ty, /*ByVal=*/false);\n}\n\nABIArgInfo ARMABIInfo::classifyHomogeneousAggregate(QualType Ty,\n                                                    const Type *Base,\n                                                    uint64_t Members) const {\n  assert(Base && \"Base class should be set for homogeneous aggregate\");\n  // Base can be a floating-point or a vector.\n  if (const VectorType *VT = Base->getAs<VectorType>()) {\n    // FP16 vectors should be converted to integer vectors\n    if (!getTarget().hasLegalHalfType() && containsAnyFP16Vectors(Ty)) {\n      uint64_t Size = getContext().getTypeSize(VT);\n      auto *NewVecTy = llvm::FixedVectorType::get(\n          llvm::Type::getInt32Ty(getVMContext()), Size / 32);\n      llvm::Type *Ty = llvm::ArrayType::get(NewVecTy, Members);\n      return ABIArgInfo::getDirect(Ty, 0, nullptr, false);\n    }\n  }\n  return ABIArgInfo::getDirect(nullptr, 0, nullptr, false);\n}\n\nABIArgInfo ARMABIInfo::classifyArgumentType(QualType Ty, bool isVariadic,\n                                            unsigned functionCallConv) const {\n  // 6.1.2.1 The following argument types are VFP CPRCs:\n  //   A single-precision floating-point type (including promoted\n  //   half-precision types); A double-precision floating-point type;\n  //   A 64-bit or 128-bit containerized vector type; Homogeneous Aggregate\n  //   with a Base Type of a single- or double-precision floating-point type,\n  //   64-bit containerized vectors or 128-bit containerized vectors with one\n  //   to four Elements.\n  // Variadic functions should always marshal to the base standard.\n  bool IsAAPCS_VFP =\n      !isVariadic && isEffectivelyAAPCS_VFP(functionCallConv, /* AAPCS16 */ false);\n\n  Ty = useFirstFieldIfTransparentUnion(Ty);\n\n  // Handle illegal vector types here.\n  if (isIllegalVectorType(Ty))\n    return coerceIllegalVector(Ty);\n\n  if (!isAggregateTypeForABI(Ty)) {\n    // Treat an enum type as its underlying type.\n    if (const EnumType *EnumTy = Ty->getAs<EnumType>()) {\n      Ty = EnumTy->getDecl()->getIntegerType();\n    }\n\n    if (const auto *EIT = Ty->getAs<ExtIntType>())\n      if (EIT->getNumBits() > 64)\n        return getNaturalAlignIndirect(Ty, /*ByVal=*/true);\n\n    return (isPromotableIntegerTypeForABI(Ty) ? ABIArgInfo::getExtend(Ty)\n                                              : ABIArgInfo::getDirect());\n  }\n\n  if (CGCXXABI::RecordArgABI RAA = getRecordArgABI(Ty, getCXXABI())) {\n    return getNaturalAlignIndirect(Ty, RAA == CGCXXABI::RAA_DirectInMemory);\n  }\n\n  // Ignore empty records.\n  if (isEmptyRecord(getContext(), Ty, true))\n    return ABIArgInfo::getIgnore();\n\n  if (IsAAPCS_VFP) {\n    // Homogeneous Aggregates need to be expanded when we can fit the aggregate\n    // into VFP registers.\n    const Type *Base = nullptr;\n    uint64_t Members = 0;\n    if (isHomogeneousAggregate(Ty, Base, Members))\n      return classifyHomogeneousAggregate(Ty, Base, Members);\n  } else if (getABIKind() == ARMABIInfo::AAPCS16_VFP) {\n    // WatchOS does have homogeneous aggregates. Note that we intentionally use\n    // this convention even for a variadic function: the backend will use GPRs\n    // if needed.\n    const Type *Base = nullptr;\n    uint64_t Members = 0;\n    if (isHomogeneousAggregate(Ty, Base, Members)) {\n      assert(Base && Members <= 4 && \"unexpected homogeneous aggregate\");\n      llvm::Type *Ty =\n        llvm::ArrayType::get(CGT.ConvertType(QualType(Base, 0)), Members);\n      return ABIArgInfo::getDirect(Ty, 0, nullptr, false);\n    }\n  }\n\n  if (getABIKind() == ARMABIInfo::AAPCS16_VFP &&\n      getContext().getTypeSizeInChars(Ty) > CharUnits::fromQuantity(16)) {\n    // WatchOS is adopting the 64-bit AAPCS rule on composite types: if they're\n    // bigger than 128-bits, they get placed in space allocated by the caller,\n    // and a pointer is passed.\n    return ABIArgInfo::getIndirect(\n        CharUnits::fromQuantity(getContext().getTypeAlign(Ty) / 8), false);\n  }\n\n  // Support byval for ARM.\n  // The ABI alignment for APCS is 4-byte and for AAPCS at least 4-byte and at\n  // most 8-byte. We realign the indirect argument if type alignment is bigger\n  // than ABI alignment.\n  uint64_t ABIAlign = 4;\n  uint64_t TyAlign;\n  if (getABIKind() == ARMABIInfo::AAPCS_VFP ||\n      getABIKind() == ARMABIInfo::AAPCS) {\n    TyAlign = getContext().getTypeUnadjustedAlignInChars(Ty).getQuantity();\n    ABIAlign = std::min(std::max(TyAlign, (uint64_t)4), (uint64_t)8);\n  } else {\n    TyAlign = getContext().getTypeAlignInChars(Ty).getQuantity();\n  }\n  if (getContext().getTypeSizeInChars(Ty) > CharUnits::fromQuantity(64)) {\n    assert(getABIKind() != ARMABIInfo::AAPCS16_VFP && \"unexpected byval\");\n    return ABIArgInfo::getIndirect(CharUnits::fromQuantity(ABIAlign),\n                                   /*ByVal=*/true,\n                                   /*Realign=*/TyAlign > ABIAlign);\n  }\n\n  // On RenderScript, coerce Aggregates <= 64 bytes to an integer array of\n  // same size and alignment.\n  if (getTarget().isRenderScriptTarget()) {\n    return coerceToIntArray(Ty, getContext(), getVMContext());\n  }\n\n  // Otherwise, pass by coercing to a structure of the appropriate size.\n  llvm::Type* ElemTy;\n  unsigned SizeRegs;\n  // FIXME: Try to match the types of the arguments more accurately where\n  // we can.\n  if (TyAlign <= 4) {\n    ElemTy = llvm::Type::getInt32Ty(getVMContext());\n    SizeRegs = (getContext().getTypeSize(Ty) + 31) / 32;\n  } else {\n    ElemTy = llvm::Type::getInt64Ty(getVMContext());\n    SizeRegs = (getContext().getTypeSize(Ty) + 63) / 64;\n  }\n\n  return ABIArgInfo::getDirect(llvm::ArrayType::get(ElemTy, SizeRegs));\n}\n\nstatic bool isIntegerLikeType(QualType Ty, ASTContext &Context,\n                              llvm::LLVMContext &VMContext) {\n  // APCS, C Language Calling Conventions, Non-Simple Return Values: A structure\n  // is called integer-like if its size is less than or equal to one word, and\n  // the offset of each of its addressable sub-fields is zero.\n\n  uint64_t Size = Context.getTypeSize(Ty);\n\n  // Check that the type fits in a word.\n  if (Size > 32)\n    return false;\n\n  // FIXME: Handle vector types!\n  if (Ty->isVectorType())\n    return false;\n\n  // Float types are never treated as \"integer like\".\n  if (Ty->isRealFloatingType())\n    return false;\n\n  // If this is a builtin or pointer type then it is ok.\n  if (Ty->getAs<BuiltinType>() || Ty->isPointerType())\n    return true;\n\n  // Small complex integer types are \"integer like\".\n  if (const ComplexType *CT = Ty->getAs<ComplexType>())\n    return isIntegerLikeType(CT->getElementType(), Context, VMContext);\n\n  // Single element and zero sized arrays should be allowed, by the definition\n  // above, but they are not.\n\n  // Otherwise, it must be a record type.\n  const RecordType *RT = Ty->getAs<RecordType>();\n  if (!RT) return false;\n\n  // Ignore records with flexible arrays.\n  const RecordDecl *RD = RT->getDecl();\n  if (RD->hasFlexibleArrayMember())\n    return false;\n\n  // Check that all sub-fields are at offset 0, and are themselves \"integer\n  // like\".\n  const ASTRecordLayout &Layout = Context.getASTRecordLayout(RD);\n\n  bool HadField = false;\n  unsigned idx = 0;\n  for (RecordDecl::field_iterator i = RD->field_begin(), e = RD->field_end();\n       i != e; ++i, ++idx) {\n    const FieldDecl *FD = *i;\n\n    // Bit-fields are not addressable, we only need to verify they are \"integer\n    // like\". We still have to disallow a subsequent non-bitfield, for example:\n    //   struct { int : 0; int x }\n    // is non-integer like according to gcc.\n    if (FD->isBitField()) {\n      if (!RD->isUnion())\n        HadField = true;\n\n      if (!isIntegerLikeType(FD->getType(), Context, VMContext))\n        return false;\n\n      continue;\n    }\n\n    // Check if this field is at offset 0.\n    if (Layout.getFieldOffset(idx) != 0)\n      return false;\n\n    if (!isIntegerLikeType(FD->getType(), Context, VMContext))\n      return false;\n\n    // Only allow at most one field in a structure. This doesn't match the\n    // wording above, but follows gcc in situations with a field following an\n    // empty structure.\n    if (!RD->isUnion()) {\n      if (HadField)\n        return false;\n\n      HadField = true;\n    }\n  }\n\n  return true;\n}\n\nABIArgInfo ARMABIInfo::classifyReturnType(QualType RetTy, bool isVariadic,\n                                          unsigned functionCallConv) const {\n\n  // Variadic functions should always marshal to the base standard.\n  bool IsAAPCS_VFP =\n      !isVariadic && isEffectivelyAAPCS_VFP(functionCallConv, /* AAPCS16 */ true);\n\n  if (RetTy->isVoidType())\n    return ABIArgInfo::getIgnore();\n\n  if (const VectorType *VT = RetTy->getAs<VectorType>()) {\n    // Large vector types should be returned via memory.\n    if (getContext().getTypeSize(RetTy) > 128)\n      return getNaturalAlignIndirect(RetTy);\n    // TODO: FP16/BF16 vectors should be converted to integer vectors\n    // This check is similar  to isIllegalVectorType - refactor?\n    if ((!getTarget().hasLegalHalfType() &&\n        (VT->getElementType()->isFloat16Type() ||\n         VT->getElementType()->isHalfType())) ||\n        (IsFloatABISoftFP &&\n         VT->getElementType()->isBFloat16Type()))\n      return coerceIllegalVector(RetTy);\n  }\n\n  if (!isAggregateTypeForABI(RetTy)) {\n    // Treat an enum type as its underlying type.\n    if (const EnumType *EnumTy = RetTy->getAs<EnumType>())\n      RetTy = EnumTy->getDecl()->getIntegerType();\n\n    if (const auto *EIT = RetTy->getAs<ExtIntType>())\n      if (EIT->getNumBits() > 64)\n        return getNaturalAlignIndirect(RetTy, /*ByVal=*/false);\n\n    return isPromotableIntegerTypeForABI(RetTy) ? ABIArgInfo::getExtend(RetTy)\n                                                : ABIArgInfo::getDirect();\n  }\n\n  // Are we following APCS?\n  if (getABIKind() == APCS) {\n    if (isEmptyRecord(getContext(), RetTy, false))\n      return ABIArgInfo::getIgnore();\n\n    // Complex types are all returned as packed integers.\n    //\n    // FIXME: Consider using 2 x vector types if the back end handles them\n    // correctly.\n    if (RetTy->isAnyComplexType())\n      return ABIArgInfo::getDirect(llvm::IntegerType::get(\n          getVMContext(), getContext().getTypeSize(RetTy)));\n\n    // Integer like structures are returned in r0.\n    if (isIntegerLikeType(RetTy, getContext(), getVMContext())) {\n      // Return in the smallest viable integer type.\n      uint64_t Size = getContext().getTypeSize(RetTy);\n      if (Size <= 8)\n        return ABIArgInfo::getDirect(llvm::Type::getInt8Ty(getVMContext()));\n      if (Size <= 16)\n        return ABIArgInfo::getDirect(llvm::Type::getInt16Ty(getVMContext()));\n      return ABIArgInfo::getDirect(llvm::Type::getInt32Ty(getVMContext()));\n    }\n\n    // Otherwise return in memory.\n    return getNaturalAlignIndirect(RetTy);\n  }\n\n  // Otherwise this is an AAPCS variant.\n\n  if (isEmptyRecord(getContext(), RetTy, true))\n    return ABIArgInfo::getIgnore();\n\n  // Check for homogeneous aggregates with AAPCS-VFP.\n  if (IsAAPCS_VFP) {\n    const Type *Base = nullptr;\n    uint64_t Members = 0;\n    if (isHomogeneousAggregate(RetTy, Base, Members))\n      return classifyHomogeneousAggregate(RetTy, Base, Members);\n  }\n\n  // Aggregates <= 4 bytes are returned in r0; other aggregates\n  // are returned indirectly.\n  uint64_t Size = getContext().getTypeSize(RetTy);\n  if (Size <= 32) {\n    // On RenderScript, coerce Aggregates <= 4 bytes to an integer array of\n    // same size and alignment.\n    if (getTarget().isRenderScriptTarget()) {\n      return coerceToIntArray(RetTy, getContext(), getVMContext());\n    }\n    if (getDataLayout().isBigEndian())\n      // Return in 32 bit integer integer type (as if loaded by LDR, AAPCS 5.4)\n      return ABIArgInfo::getDirect(llvm::Type::getInt32Ty(getVMContext()));\n\n    // Return in the smallest viable integer type.\n    if (Size <= 8)\n      return ABIArgInfo::getDirect(llvm::Type::getInt8Ty(getVMContext()));\n    if (Size <= 16)\n      return ABIArgInfo::getDirect(llvm::Type::getInt16Ty(getVMContext()));\n    return ABIArgInfo::getDirect(llvm::Type::getInt32Ty(getVMContext()));\n  } else if (Size <= 128 && getABIKind() == AAPCS16_VFP) {\n    llvm::Type *Int32Ty = llvm::Type::getInt32Ty(getVMContext());\n    llvm::Type *CoerceTy =\n        llvm::ArrayType::get(Int32Ty, llvm::alignTo(Size, 32) / 32);\n    return ABIArgInfo::getDirect(CoerceTy);\n  }\n\n  return getNaturalAlignIndirect(RetTy);\n}\n\n/// isIllegalVector - check whether Ty is an illegal vector type.\nbool ARMABIInfo::isIllegalVectorType(QualType Ty) const {\n  if (const VectorType *VT = Ty->getAs<VectorType> ()) {\n    // On targets that don't support half, fp16 or bfloat, they are expanded\n    // into float, and we don't want the ABI to depend on whether or not they\n    // are supported in hardware. Thus return false to coerce vectors of these\n    // types into integer vectors.\n    // We do not depend on hasLegalHalfType for bfloat as it is a\n    // separate IR type.\n    if ((!getTarget().hasLegalHalfType() &&\n        (VT->getElementType()->isFloat16Type() ||\n         VT->getElementType()->isHalfType())) ||\n        (IsFloatABISoftFP &&\n         VT->getElementType()->isBFloat16Type()))\n      return true;\n    if (isAndroid()) {\n      // Android shipped using Clang 3.1, which supported a slightly different\n      // vector ABI. The primary differences were that 3-element vector types\n      // were legal, and so were sub 32-bit vectors (i.e. <2 x i8>). This path\n      // accepts that legacy behavior for Android only.\n      // Check whether VT is legal.\n      unsigned NumElements = VT->getNumElements();\n      // NumElements should be power of 2 or equal to 3.\n      if (!llvm::isPowerOf2_32(NumElements) && NumElements != 3)\n        return true;\n    } else {\n      // Check whether VT is legal.\n      unsigned NumElements = VT->getNumElements();\n      uint64_t Size = getContext().getTypeSize(VT);\n      // NumElements should be power of 2.\n      if (!llvm::isPowerOf2_32(NumElements))\n        return true;\n      // Size should be greater than 32 bits.\n      return Size <= 32;\n    }\n  }\n  return false;\n}\n\n/// Return true if a type contains any 16-bit floating point vectors\nbool ARMABIInfo::containsAnyFP16Vectors(QualType Ty) const {\n  if (const ConstantArrayType *AT = getContext().getAsConstantArrayType(Ty)) {\n    uint64_t NElements = AT->getSize().getZExtValue();\n    if (NElements == 0)\n      return false;\n    return containsAnyFP16Vectors(AT->getElementType());\n  } else if (const RecordType *RT = Ty->getAs<RecordType>()) {\n    const RecordDecl *RD = RT->getDecl();\n\n    // If this is a C++ record, check the bases first.\n    if (const CXXRecordDecl *CXXRD = dyn_cast<CXXRecordDecl>(RD))\n      if (llvm::any_of(CXXRD->bases(), [this](const CXXBaseSpecifier &B) {\n            return containsAnyFP16Vectors(B.getType());\n          }))\n        return true;\n\n    if (llvm::any_of(RD->fields(), [this](FieldDecl *FD) {\n          return FD && containsAnyFP16Vectors(FD->getType());\n        }))\n      return true;\n\n    return false;\n  } else {\n    if (const VectorType *VT = Ty->getAs<VectorType>())\n      return (VT->getElementType()->isFloat16Type() ||\n              VT->getElementType()->isBFloat16Type() ||\n              VT->getElementType()->isHalfType());\n    return false;\n  }\n}\n\nbool ARMABIInfo::isLegalVectorTypeForSwift(CharUnits vectorSize,\n                                           llvm::Type *eltTy,\n                                           unsigned numElts) const {\n  if (!llvm::isPowerOf2_32(numElts))\n    return false;\n  unsigned size = getDataLayout().getTypeStoreSizeInBits(eltTy);\n  if (size > 64)\n    return false;\n  if (vectorSize.getQuantity() != 8 &&\n      (vectorSize.getQuantity() != 16 || numElts == 1))\n    return false;\n  return true;\n}\n\nbool ARMABIInfo::isHomogeneousAggregateBaseType(QualType Ty) const {\n  // Homogeneous aggregates for AAPCS-VFP must have base types of float,\n  // double, or 64-bit or 128-bit vectors.\n  if (const BuiltinType *BT = Ty->getAs<BuiltinType>()) {\n    if (BT->getKind() == BuiltinType::Float ||\n        BT->getKind() == BuiltinType::Double ||\n        BT->getKind() == BuiltinType::LongDouble)\n      return true;\n  } else if (const VectorType *VT = Ty->getAs<VectorType>()) {\n    unsigned VecSize = getContext().getTypeSize(VT);\n    if (VecSize == 64 || VecSize == 128)\n      return true;\n  }\n  return false;\n}\n\nbool ARMABIInfo::isHomogeneousAggregateSmallEnough(const Type *Base,\n                                                   uint64_t Members) const {\n  return Members <= 4;\n}\n\nbool ARMABIInfo::isEffectivelyAAPCS_VFP(unsigned callConvention,\n                                        bool acceptHalf) const {\n  // Give precedence to user-specified calling conventions.\n  if (callConvention != llvm::CallingConv::C)\n    return (callConvention == llvm::CallingConv::ARM_AAPCS_VFP);\n  else\n    return (getABIKind() == AAPCS_VFP) ||\n           (acceptHalf && (getABIKind() == AAPCS16_VFP));\n}\n\nAddress ARMABIInfo::EmitVAArg(CodeGenFunction &CGF, Address VAListAddr,\n                              QualType Ty) const {\n  CharUnits SlotSize = CharUnits::fromQuantity(4);\n\n  // Empty records are ignored for parameter passing purposes.\n  if (isEmptyRecord(getContext(), Ty, true)) {\n    Address Addr(CGF.Builder.CreateLoad(VAListAddr), SlotSize);\n    Addr = CGF.Builder.CreateElementBitCast(Addr, CGF.ConvertTypeForMem(Ty));\n    return Addr;\n  }\n\n  CharUnits TySize = getContext().getTypeSizeInChars(Ty);\n  CharUnits TyAlignForABI = getContext().getTypeUnadjustedAlignInChars(Ty);\n\n  // Use indirect if size of the illegal vector is bigger than 16 bytes.\n  bool IsIndirect = false;\n  const Type *Base = nullptr;\n  uint64_t Members = 0;\n  if (TySize > CharUnits::fromQuantity(16) && isIllegalVectorType(Ty)) {\n    IsIndirect = true;\n\n  // ARMv7k passes structs bigger than 16 bytes indirectly, in space\n  // allocated by the caller.\n  } else if (TySize > CharUnits::fromQuantity(16) &&\n             getABIKind() == ARMABIInfo::AAPCS16_VFP &&\n             !isHomogeneousAggregate(Ty, Base, Members)) {\n    IsIndirect = true;\n\n  // Otherwise, bound the type's ABI alignment.\n  // The ABI alignment for 64-bit or 128-bit vectors is 8 for AAPCS and 4 for\n  // APCS. For AAPCS, the ABI alignment is at least 4-byte and at most 8-byte.\n  // Our callers should be prepared to handle an under-aligned address.\n  } else if (getABIKind() == ARMABIInfo::AAPCS_VFP ||\n             getABIKind() == ARMABIInfo::AAPCS) {\n    TyAlignForABI = std::max(TyAlignForABI, CharUnits::fromQuantity(4));\n    TyAlignForABI = std::min(TyAlignForABI, CharUnits::fromQuantity(8));\n  } else if (getABIKind() == ARMABIInfo::AAPCS16_VFP) {\n    // ARMv7k allows type alignment up to 16 bytes.\n    TyAlignForABI = std::max(TyAlignForABI, CharUnits::fromQuantity(4));\n    TyAlignForABI = std::min(TyAlignForABI, CharUnits::fromQuantity(16));\n  } else {\n    TyAlignForABI = CharUnits::fromQuantity(4);\n  }\n\n  TypeInfoChars TyInfo(TySize, TyAlignForABI, false);\n  return emitVoidPtrVAArg(CGF, VAListAddr, Ty, IsIndirect, TyInfo,\n                          SlotSize, /*AllowHigherAlign*/ true);\n}\n\n//===----------------------------------------------------------------------===//\n// NVPTX ABI Implementation\n//===----------------------------------------------------------------------===//\n\nnamespace {\n\nclass NVPTXTargetCodeGenInfo;\n\nclass NVPTXABIInfo : public ABIInfo {\n  NVPTXTargetCodeGenInfo &CGInfo;\n\npublic:\n  NVPTXABIInfo(CodeGenTypes &CGT, NVPTXTargetCodeGenInfo &Info)\n      : ABIInfo(CGT), CGInfo(Info) {}\n\n  ABIArgInfo classifyReturnType(QualType RetTy) const;\n  ABIArgInfo classifyArgumentType(QualType Ty) const;\n\n  void computeInfo(CGFunctionInfo &FI) const override;\n  Address EmitVAArg(CodeGenFunction &CGF, Address VAListAddr,\n                    QualType Ty) const override;\n  bool isUnsupportedType(QualType T) const;\n  ABIArgInfo coerceToIntArrayWithLimit(QualType Ty, unsigned MaxSize) const;\n};\n\nclass NVPTXTargetCodeGenInfo : public TargetCodeGenInfo {\npublic:\n  NVPTXTargetCodeGenInfo(CodeGenTypes &CGT)\n      : TargetCodeGenInfo(std::make_unique<NVPTXABIInfo>(CGT, *this)) {}\n\n  void setTargetAttributes(const Decl *D, llvm::GlobalValue *GV,\n                           CodeGen::CodeGenModule &M) const override;\n  bool shouldEmitStaticExternCAliases() const override;\n\n  llvm::Type *getCUDADeviceBuiltinSurfaceDeviceType() const override {\n    // On the device side, surface reference is represented as an object handle\n    // in 64-bit integer.\n    return llvm::Type::getInt64Ty(getABIInfo().getVMContext());\n  }\n\n  llvm::Type *getCUDADeviceBuiltinTextureDeviceType() const override {\n    // On the device side, texture reference is represented as an object handle\n    // in 64-bit integer.\n    return llvm::Type::getInt64Ty(getABIInfo().getVMContext());\n  }\n\n  bool emitCUDADeviceBuiltinSurfaceDeviceCopy(CodeGenFunction &CGF, LValue Dst,\n                                              LValue Src) const override {\n    emitBuiltinSurfTexDeviceCopy(CGF, Dst, Src);\n    return true;\n  }\n\n  bool emitCUDADeviceBuiltinTextureDeviceCopy(CodeGenFunction &CGF, LValue Dst,\n                                              LValue Src) const override {\n    emitBuiltinSurfTexDeviceCopy(CGF, Dst, Src);\n    return true;\n  }\n\nprivate:\n  // Adds a NamedMDNode with GV, Name, and Operand as operands, and adds the\n  // resulting MDNode to the nvvm.annotations MDNode.\n  static void addNVVMMetadata(llvm::GlobalValue *GV, StringRef Name,\n                              int Operand);\n\n  static void emitBuiltinSurfTexDeviceCopy(CodeGenFunction &CGF, LValue Dst,\n                                           LValue Src) {\n    llvm::Value *Handle = nullptr;\n    llvm::Constant *C =\n        llvm::dyn_cast<llvm::Constant>(Src.getAddress(CGF).getPointer());\n    // Lookup `addrspacecast` through the constant pointer if any.\n    if (auto *ASC = llvm::dyn_cast_or_null<llvm::AddrSpaceCastOperator>(C))\n      C = llvm::cast<llvm::Constant>(ASC->getPointerOperand());\n    if (auto *GV = llvm::dyn_cast_or_null<llvm::GlobalVariable>(C)) {\n      // Load the handle from the specific global variable using\n      // `nvvm.texsurf.handle.internal` intrinsic.\n      Handle = CGF.EmitRuntimeCall(\n          CGF.CGM.getIntrinsic(llvm::Intrinsic::nvvm_texsurf_handle_internal,\n                               {GV->getType()}),\n          {GV}, \"texsurf_handle\");\n    } else\n      Handle = CGF.EmitLoadOfScalar(Src, SourceLocation());\n    CGF.EmitStoreOfScalar(Handle, Dst);\n  }\n};\n\n/// Checks if the type is unsupported directly by the current target.\nbool NVPTXABIInfo::isUnsupportedType(QualType T) const {\n  ASTContext &Context = getContext();\n  if (!Context.getTargetInfo().hasFloat16Type() && T->isFloat16Type())\n    return true;\n  if (!Context.getTargetInfo().hasFloat128Type() &&\n      (T->isFloat128Type() ||\n       (T->isRealFloatingType() && Context.getTypeSize(T) == 128)))\n    return true;\n  if (const auto *EIT = T->getAs<ExtIntType>())\n    return EIT->getNumBits() >\n           (Context.getTargetInfo().hasInt128Type() ? 128U : 64U);\n  if (!Context.getTargetInfo().hasInt128Type() && T->isIntegerType() &&\n      Context.getTypeSize(T) > 64U)\n    return true;\n  if (const auto *AT = T->getAsArrayTypeUnsafe())\n    return isUnsupportedType(AT->getElementType());\n  const auto *RT = T->getAs<RecordType>();\n  if (!RT)\n    return false;\n  const RecordDecl *RD = RT->getDecl();\n\n  // If this is a C++ record, check the bases first.\n  if (const CXXRecordDecl *CXXRD = dyn_cast<CXXRecordDecl>(RD))\n    for (const CXXBaseSpecifier &I : CXXRD->bases())\n      if (isUnsupportedType(I.getType()))\n        return true;\n\n  for (const FieldDecl *I : RD->fields())\n    if (isUnsupportedType(I->getType()))\n      return true;\n  return false;\n}\n\n/// Coerce the given type into an array with maximum allowed size of elements.\nABIArgInfo NVPTXABIInfo::coerceToIntArrayWithLimit(QualType Ty,\n                                                   unsigned MaxSize) const {\n  // Alignment and Size are measured in bits.\n  const uint64_t Size = getContext().getTypeSize(Ty);\n  const uint64_t Alignment = getContext().getTypeAlign(Ty);\n  const unsigned Div = std::min<unsigned>(MaxSize, Alignment);\n  llvm::Type *IntType = llvm::Type::getIntNTy(getVMContext(), Div);\n  const uint64_t NumElements = (Size + Div - 1) / Div;\n  return ABIArgInfo::getDirect(llvm::ArrayType::get(IntType, NumElements));\n}\n\nABIArgInfo NVPTXABIInfo::classifyReturnType(QualType RetTy) const {\n  if (RetTy->isVoidType())\n    return ABIArgInfo::getIgnore();\n\n  if (getContext().getLangOpts().OpenMP &&\n      getContext().getLangOpts().OpenMPIsDevice && isUnsupportedType(RetTy))\n    return coerceToIntArrayWithLimit(RetTy, 64);\n\n  // note: this is different from default ABI\n  if (!RetTy->isScalarType())\n    return ABIArgInfo::getDirect();\n\n  // Treat an enum type as its underlying type.\n  if (const EnumType *EnumTy = RetTy->getAs<EnumType>())\n    RetTy = EnumTy->getDecl()->getIntegerType();\n\n  return (isPromotableIntegerTypeForABI(RetTy) ? ABIArgInfo::getExtend(RetTy)\n                                               : ABIArgInfo::getDirect());\n}\n\nABIArgInfo NVPTXABIInfo::classifyArgumentType(QualType Ty) const {\n  // Treat an enum type as its underlying type.\n  if (const EnumType *EnumTy = Ty->getAs<EnumType>())\n    Ty = EnumTy->getDecl()->getIntegerType();\n\n  // Return aggregates type as indirect by value\n  if (isAggregateTypeForABI(Ty)) {\n    // Under CUDA device compilation, tex/surf builtin types are replaced with\n    // object types and passed directly.\n    if (getContext().getLangOpts().CUDAIsDevice) {\n      if (Ty->isCUDADeviceBuiltinSurfaceType())\n        return ABIArgInfo::getDirect(\n            CGInfo.getCUDADeviceBuiltinSurfaceDeviceType());\n      if (Ty->isCUDADeviceBuiltinTextureType())\n        return ABIArgInfo::getDirect(\n            CGInfo.getCUDADeviceBuiltinTextureDeviceType());\n    }\n    return getNaturalAlignIndirect(Ty, /* byval */ true);\n  }\n\n  if (const auto *EIT = Ty->getAs<ExtIntType>()) {\n    if ((EIT->getNumBits() > 128) ||\n        (!getContext().getTargetInfo().hasInt128Type() &&\n         EIT->getNumBits() > 64))\n      return getNaturalAlignIndirect(Ty, /* byval */ true);\n  }\n\n  return (isPromotableIntegerTypeForABI(Ty) ? ABIArgInfo::getExtend(Ty)\n                                            : ABIArgInfo::getDirect());\n}\n\nvoid NVPTXABIInfo::computeInfo(CGFunctionInfo &FI) const {\n  if (!getCXXABI().classifyReturnType(FI))\n    FI.getReturnInfo() = classifyReturnType(FI.getReturnType());\n  for (auto &I : FI.arguments())\n    I.info = classifyArgumentType(I.type);\n\n  // Always honor user-specified calling convention.\n  if (FI.getCallingConvention() != llvm::CallingConv::C)\n    return;\n\n  FI.setEffectiveCallingConvention(getRuntimeCC());\n}\n\nAddress NVPTXABIInfo::EmitVAArg(CodeGenFunction &CGF, Address VAListAddr,\n                                QualType Ty) const {\n  llvm_unreachable(\"NVPTX does not support varargs\");\n}\n\nvoid NVPTXTargetCodeGenInfo::setTargetAttributes(\n    const Decl *D, llvm::GlobalValue *GV, CodeGen::CodeGenModule &M) const {\n  if (GV->isDeclaration())\n    return;\n  const VarDecl *VD = dyn_cast_or_null<VarDecl>(D);\n  if (VD) {\n    if (M.getLangOpts().CUDA) {\n      if (VD->getType()->isCUDADeviceBuiltinSurfaceType())\n        addNVVMMetadata(GV, \"surface\", 1);\n      else if (VD->getType()->isCUDADeviceBuiltinTextureType())\n        addNVVMMetadata(GV, \"texture\", 1);\n      return;\n    }\n  }\n\n  const FunctionDecl *FD = dyn_cast_or_null<FunctionDecl>(D);\n  if (!FD) return;\n\n  llvm::Function *F = cast<llvm::Function>(GV);\n\n  // Perform special handling in OpenCL mode\n  if (M.getLangOpts().OpenCL) {\n    // Use OpenCL function attributes to check for kernel functions\n    // By default, all functions are device functions\n    if (FD->hasAttr<OpenCLKernelAttr>()) {\n      // OpenCL __kernel functions get kernel metadata\n      // Create !{<func-ref>, metadata !\"kernel\", i32 1} node\n      addNVVMMetadata(F, \"kernel\", 1);\n      // And kernel functions are not subject to inlining\n      F->addFnAttr(llvm::Attribute::NoInline);\n    }\n  }\n\n  // Perform special handling in CUDA mode.\n  if (M.getLangOpts().CUDA) {\n    // CUDA __global__ functions get a kernel metadata entry.  Since\n    // __global__ functions cannot be called from the device, we do not\n    // need to set the noinline attribute.\n    if (FD->hasAttr<CUDAGlobalAttr>()) {\n      // Create !{<func-ref>, metadata !\"kernel\", i32 1} node\n      addNVVMMetadata(F, \"kernel\", 1);\n    }\n    if (CUDALaunchBoundsAttr *Attr = FD->getAttr<CUDALaunchBoundsAttr>()) {\n      // Create !{<func-ref>, metadata !\"maxntidx\", i32 <val>} node\n      llvm::APSInt MaxThreads(32);\n      MaxThreads = Attr->getMaxThreads()->EvaluateKnownConstInt(M.getContext());\n      if (MaxThreads > 0)\n        addNVVMMetadata(F, \"maxntidx\", MaxThreads.getExtValue());\n\n      // min blocks is an optional argument for CUDALaunchBoundsAttr. If it was\n      // not specified in __launch_bounds__ or if the user specified a 0 value,\n      // we don't have to add a PTX directive.\n      if (Attr->getMinBlocks()) {\n        llvm::APSInt MinBlocks(32);\n        MinBlocks = Attr->getMinBlocks()->EvaluateKnownConstInt(M.getContext());\n        if (MinBlocks > 0)\n          // Create !{<func-ref>, metadata !\"minctasm\", i32 <val>} node\n          addNVVMMetadata(F, \"minctasm\", MinBlocks.getExtValue());\n      }\n    }\n  }\n}\n\nvoid NVPTXTargetCodeGenInfo::addNVVMMetadata(llvm::GlobalValue *GV,\n                                             StringRef Name, int Operand) {\n  llvm::Module *M = GV->getParent();\n  llvm::LLVMContext &Ctx = M->getContext();\n\n  // Get \"nvvm.annotations\" metadata node\n  llvm::NamedMDNode *MD = M->getOrInsertNamedMetadata(\"nvvm.annotations\");\n\n  llvm::Metadata *MDVals[] = {\n      llvm::ConstantAsMetadata::get(GV), llvm::MDString::get(Ctx, Name),\n      llvm::ConstantAsMetadata::get(\n          llvm::ConstantInt::get(llvm::Type::getInt32Ty(Ctx), Operand))};\n  // Append metadata to nvvm.annotations\n  MD->addOperand(llvm::MDNode::get(Ctx, MDVals));\n}\n\nbool NVPTXTargetCodeGenInfo::shouldEmitStaticExternCAliases() const {\n  return false;\n}\n}\n\n//===----------------------------------------------------------------------===//\n// SystemZ ABI Implementation\n//===----------------------------------------------------------------------===//\n\nnamespace {\n\nclass SystemZABIInfo : public SwiftABIInfo {\n  bool HasVector;\n  bool IsSoftFloatABI;\n\npublic:\n  SystemZABIInfo(CodeGenTypes &CGT, bool HV, bool SF)\n    : SwiftABIInfo(CGT), HasVector(HV), IsSoftFloatABI(SF) {}\n\n  bool isPromotableIntegerTypeForABI(QualType Ty) const;\n  bool isCompoundType(QualType Ty) const;\n  bool isVectorArgumentType(QualType Ty) const;\n  bool isFPArgumentType(QualType Ty) const;\n  QualType GetSingleElementType(QualType Ty) const;\n\n  ABIArgInfo classifyReturnType(QualType RetTy) const;\n  ABIArgInfo classifyArgumentType(QualType ArgTy) const;\n\n  void computeInfo(CGFunctionInfo &FI) const override {\n    if (!getCXXABI().classifyReturnType(FI))\n      FI.getReturnInfo() = classifyReturnType(FI.getReturnType());\n    for (auto &I : FI.arguments())\n      I.info = classifyArgumentType(I.type);\n  }\n\n  Address EmitVAArg(CodeGenFunction &CGF, Address VAListAddr,\n                    QualType Ty) const override;\n\n  bool shouldPassIndirectlyForSwift(ArrayRef<llvm::Type*> scalars,\n                                    bool asReturnValue) const override {\n    return occupiesMoreThan(CGT, scalars, /*total*/ 4);\n  }\n  bool isSwiftErrorInRegister() const override {\n    return false;\n  }\n};\n\nclass SystemZTargetCodeGenInfo : public TargetCodeGenInfo {\npublic:\n  SystemZTargetCodeGenInfo(CodeGenTypes &CGT, bool HasVector, bool SoftFloatABI)\n      : TargetCodeGenInfo(\n            std::make_unique<SystemZABIInfo>(CGT, HasVector, SoftFloatABI)) {}\n\n  llvm::Value *testFPKind(llvm::Value *V, unsigned BuiltinID,\n                          CGBuilderTy &Builder,\n                          CodeGenModule &CGM) const override {\n    assert(V->getType()->isFloatingPointTy() && \"V should have an FP type.\");\n    // Only use TDC in constrained FP mode.\n    if (!Builder.getIsFPConstrained())\n      return nullptr;\n\n    llvm::Type *Ty = V->getType();\n    if (Ty->isFloatTy() || Ty->isDoubleTy() || Ty->isFP128Ty()) {\n      llvm::Module &M = CGM.getModule();\n      auto &Ctx = M.getContext();\n      llvm::Function *TDCFunc =\n          llvm::Intrinsic::getDeclaration(&M, llvm::Intrinsic::s390_tdc, Ty);\n      unsigned TDCBits = 0;\n      switch (BuiltinID) {\n      case Builtin::BI__builtin_isnan:\n        TDCBits = 0xf;\n        break;\n      default:\n        break;\n      }\n      if (TDCBits)\n        return Builder.CreateCall(\n            TDCFunc,\n            {V, llvm::ConstantInt::get(llvm::Type::getInt64Ty(Ctx), TDCBits)});\n    }\n    return nullptr;\n  }\n};\n}\n\nbool SystemZABIInfo::isPromotableIntegerTypeForABI(QualType Ty) const {\n  // Treat an enum type as its underlying type.\n  if (const EnumType *EnumTy = Ty->getAs<EnumType>())\n    Ty = EnumTy->getDecl()->getIntegerType();\n\n  // Promotable integer types are required to be promoted by the ABI.\n  if (ABIInfo::isPromotableIntegerTypeForABI(Ty))\n    return true;\n\n  if (const auto *EIT = Ty->getAs<ExtIntType>())\n    if (EIT->getNumBits() < 64)\n      return true;\n\n  // 32-bit values must also be promoted.\n  if (const BuiltinType *BT = Ty->getAs<BuiltinType>())\n    switch (BT->getKind()) {\n    case BuiltinType::Int:\n    case BuiltinType::UInt:\n      return true;\n    default:\n      return false;\n    }\n  return false;\n}\n\nbool SystemZABIInfo::isCompoundType(QualType Ty) const {\n  return (Ty->isAnyComplexType() ||\n          Ty->isVectorType() ||\n          isAggregateTypeForABI(Ty));\n}\n\nbool SystemZABIInfo::isVectorArgumentType(QualType Ty) const {\n  return (HasVector &&\n          Ty->isVectorType() &&\n          getContext().getTypeSize(Ty) <= 128);\n}\n\nbool SystemZABIInfo::isFPArgumentType(QualType Ty) const {\n  if (IsSoftFloatABI)\n    return false;\n\n  if (const BuiltinType *BT = Ty->getAs<BuiltinType>())\n    switch (BT->getKind()) {\n    case BuiltinType::Float:\n    case BuiltinType::Double:\n      return true;\n    default:\n      return false;\n    }\n\n  return false;\n}\n\nQualType SystemZABIInfo::GetSingleElementType(QualType Ty) const {\n  const RecordType *RT = Ty->getAs<RecordType>();\n\n  if (RT && RT->isStructureOrClassType()) {\n    const RecordDecl *RD = RT->getDecl();\n    QualType Found;\n\n    // If this is a C++ record, check the bases first.\n    if (const CXXRecordDecl *CXXRD = dyn_cast<CXXRecordDecl>(RD))\n      for (const auto &I : CXXRD->bases()) {\n        QualType Base = I.getType();\n\n        // Empty bases don't affect things either way.\n        if (isEmptyRecord(getContext(), Base, true))\n          continue;\n\n        if (!Found.isNull())\n          return Ty;\n        Found = GetSingleElementType(Base);\n      }\n\n    // Check the fields.\n    for (const auto *FD : RD->fields()) {\n      // For compatibility with GCC, ignore empty bitfields in C++ mode.\n      // Unlike isSingleElementStruct(), empty structure and array fields\n      // do count.  So do anonymous bitfields that aren't zero-sized.\n      if (getContext().getLangOpts().CPlusPlus &&\n          FD->isZeroLengthBitField(getContext()))\n        continue;\n      // Like isSingleElementStruct(), ignore C++20 empty data members.\n      if (FD->hasAttr<NoUniqueAddressAttr>() &&\n          isEmptyRecord(getContext(), FD->getType(), true))\n        continue;\n\n      // Unlike isSingleElementStruct(), arrays do not count.\n      // Nested structures still do though.\n      if (!Found.isNull())\n        return Ty;\n      Found = GetSingleElementType(FD->getType());\n    }\n\n    // Unlike isSingleElementStruct(), trailing padding is allowed.\n    // An 8-byte aligned struct s { float f; } is passed as a double.\n    if (!Found.isNull())\n      return Found;\n  }\n\n  return Ty;\n}\n\nAddress SystemZABIInfo::EmitVAArg(CodeGenFunction &CGF, Address VAListAddr,\n                                  QualType Ty) const {\n  // Assume that va_list type is correct; should be pointer to LLVM type:\n  // struct {\n  //   i64 __gpr;\n  //   i64 __fpr;\n  //   i8 *__overflow_arg_area;\n  //   i8 *__reg_save_area;\n  // };\n\n  // Every non-vector argument occupies 8 bytes and is passed by preference\n  // in either GPRs or FPRs.  Vector arguments occupy 8 or 16 bytes and are\n  // always passed on the stack.\n  Ty = getContext().getCanonicalType(Ty);\n  auto TyInfo = getContext().getTypeInfoInChars(Ty);\n  llvm::Type *ArgTy = CGF.ConvertTypeForMem(Ty);\n  llvm::Type *DirectTy = ArgTy;\n  ABIArgInfo AI = classifyArgumentType(Ty);\n  bool IsIndirect = AI.isIndirect();\n  bool InFPRs = false;\n  bool IsVector = false;\n  CharUnits UnpaddedSize;\n  CharUnits DirectAlign;\n  if (IsIndirect) {\n    DirectTy = llvm::PointerType::getUnqual(DirectTy);\n    UnpaddedSize = DirectAlign = CharUnits::fromQuantity(8);\n  } else {\n    if (AI.getCoerceToType())\n      ArgTy = AI.getCoerceToType();\n    InFPRs = (!IsSoftFloatABI && (ArgTy->isFloatTy() || ArgTy->isDoubleTy()));\n    IsVector = ArgTy->isVectorTy();\n    UnpaddedSize = TyInfo.Width;\n    DirectAlign = TyInfo.Align;\n  }\n  CharUnits PaddedSize = CharUnits::fromQuantity(8);\n  if (IsVector && UnpaddedSize > PaddedSize)\n    PaddedSize = CharUnits::fromQuantity(16);\n  assert((UnpaddedSize <= PaddedSize) && \"Invalid argument size.\");\n\n  CharUnits Padding = (PaddedSize - UnpaddedSize);\n\n  llvm::Type *IndexTy = CGF.Int64Ty;\n  llvm::Value *PaddedSizeV =\n    llvm::ConstantInt::get(IndexTy, PaddedSize.getQuantity());\n\n  if (IsVector) {\n    // Work out the address of a vector argument on the stack.\n    // Vector arguments are always passed in the high bits of a\n    // single (8 byte) or double (16 byte) stack slot.\n    Address OverflowArgAreaPtr =\n        CGF.Builder.CreateStructGEP(VAListAddr, 2, \"overflow_arg_area_ptr\");\n    Address OverflowArgArea =\n      Address(CGF.Builder.CreateLoad(OverflowArgAreaPtr, \"overflow_arg_area\"),\n              TyInfo.Align);\n    Address MemAddr =\n      CGF.Builder.CreateElementBitCast(OverflowArgArea, DirectTy, \"mem_addr\");\n\n    // Update overflow_arg_area_ptr pointer\n    llvm::Value *NewOverflowArgArea =\n      CGF.Builder.CreateGEP(OverflowArgArea.getPointer(), PaddedSizeV,\n                            \"overflow_arg_area\");\n    CGF.Builder.CreateStore(NewOverflowArgArea, OverflowArgAreaPtr);\n\n    return MemAddr;\n  }\n\n  assert(PaddedSize.getQuantity() == 8);\n\n  unsigned MaxRegs, RegCountField, RegSaveIndex;\n  CharUnits RegPadding;\n  if (InFPRs) {\n    MaxRegs = 4; // Maximum of 4 FPR arguments\n    RegCountField = 1; // __fpr\n    RegSaveIndex = 16; // save offset for f0\n    RegPadding = CharUnits(); // floats are passed in the high bits of an FPR\n  } else {\n    MaxRegs = 5; // Maximum of 5 GPR arguments\n    RegCountField = 0; // __gpr\n    RegSaveIndex = 2; // save offset for r2\n    RegPadding = Padding; // values are passed in the low bits of a GPR\n  }\n\n  Address RegCountPtr =\n      CGF.Builder.CreateStructGEP(VAListAddr, RegCountField, \"reg_count_ptr\");\n  llvm::Value *RegCount = CGF.Builder.CreateLoad(RegCountPtr, \"reg_count\");\n  llvm::Value *MaxRegsV = llvm::ConstantInt::get(IndexTy, MaxRegs);\n  llvm::Value *InRegs = CGF.Builder.CreateICmpULT(RegCount, MaxRegsV,\n                                                 \"fits_in_regs\");\n\n  llvm::BasicBlock *InRegBlock = CGF.createBasicBlock(\"vaarg.in_reg\");\n  llvm::BasicBlock *InMemBlock = CGF.createBasicBlock(\"vaarg.in_mem\");\n  llvm::BasicBlock *ContBlock = CGF.createBasicBlock(\"vaarg.end\");\n  CGF.Builder.CreateCondBr(InRegs, InRegBlock, InMemBlock);\n\n  // Emit code to load the value if it was passed in registers.\n  CGF.EmitBlock(InRegBlock);\n\n  // Work out the address of an argument register.\n  llvm::Value *ScaledRegCount =\n    CGF.Builder.CreateMul(RegCount, PaddedSizeV, \"scaled_reg_count\");\n  llvm::Value *RegBase =\n    llvm::ConstantInt::get(IndexTy, RegSaveIndex * PaddedSize.getQuantity()\n                                      + RegPadding.getQuantity());\n  llvm::Value *RegOffset =\n    CGF.Builder.CreateAdd(ScaledRegCount, RegBase, \"reg_offset\");\n  Address RegSaveAreaPtr =\n      CGF.Builder.CreateStructGEP(VAListAddr, 3, \"reg_save_area_ptr\");\n  llvm::Value *RegSaveArea =\n    CGF.Builder.CreateLoad(RegSaveAreaPtr, \"reg_save_area\");\n  Address RawRegAddr(CGF.Builder.CreateGEP(RegSaveArea, RegOffset,\n                                           \"raw_reg_addr\"),\n                     PaddedSize);\n  Address RegAddr =\n    CGF.Builder.CreateElementBitCast(RawRegAddr, DirectTy, \"reg_addr\");\n\n  // Update the register count\n  llvm::Value *One = llvm::ConstantInt::get(IndexTy, 1);\n  llvm::Value *NewRegCount =\n    CGF.Builder.CreateAdd(RegCount, One, \"reg_count\");\n  CGF.Builder.CreateStore(NewRegCount, RegCountPtr);\n  CGF.EmitBranch(ContBlock);\n\n  // Emit code to load the value if it was passed in memory.\n  CGF.EmitBlock(InMemBlock);\n\n  // Work out the address of a stack argument.\n  Address OverflowArgAreaPtr =\n      CGF.Builder.CreateStructGEP(VAListAddr, 2, \"overflow_arg_area_ptr\");\n  Address OverflowArgArea =\n    Address(CGF.Builder.CreateLoad(OverflowArgAreaPtr, \"overflow_arg_area\"),\n            PaddedSize);\n  Address RawMemAddr =\n    CGF.Builder.CreateConstByteGEP(OverflowArgArea, Padding, \"raw_mem_addr\");\n  Address MemAddr =\n    CGF.Builder.CreateElementBitCast(RawMemAddr, DirectTy, \"mem_addr\");\n\n  // Update overflow_arg_area_ptr pointer\n  llvm::Value *NewOverflowArgArea =\n    CGF.Builder.CreateGEP(OverflowArgArea.getPointer(), PaddedSizeV,\n                          \"overflow_arg_area\");\n  CGF.Builder.CreateStore(NewOverflowArgArea, OverflowArgAreaPtr);\n  CGF.EmitBranch(ContBlock);\n\n  // Return the appropriate result.\n  CGF.EmitBlock(ContBlock);\n  Address ResAddr = emitMergePHI(CGF, RegAddr, InRegBlock,\n                                 MemAddr, InMemBlock, \"va_arg.addr\");\n\n  if (IsIndirect)\n    ResAddr = Address(CGF.Builder.CreateLoad(ResAddr, \"indirect_arg\"),\n                      TyInfo.Align);\n\n  return ResAddr;\n}\n\nABIArgInfo SystemZABIInfo::classifyReturnType(QualType RetTy) const {\n  if (RetTy->isVoidType())\n    return ABIArgInfo::getIgnore();\n  if (isVectorArgumentType(RetTy))\n    return ABIArgInfo::getDirect();\n  if (isCompoundType(RetTy) || getContext().getTypeSize(RetTy) > 64)\n    return getNaturalAlignIndirect(RetTy);\n  return (isPromotableIntegerTypeForABI(RetTy) ? ABIArgInfo::getExtend(RetTy)\n                                               : ABIArgInfo::getDirect());\n}\n\nABIArgInfo SystemZABIInfo::classifyArgumentType(QualType Ty) const {\n  // Handle the generic C++ ABI.\n  if (CGCXXABI::RecordArgABI RAA = getRecordArgABI(Ty, getCXXABI()))\n    return getNaturalAlignIndirect(Ty, RAA == CGCXXABI::RAA_DirectInMemory);\n\n  // Integers and enums are extended to full register width.\n  if (isPromotableIntegerTypeForABI(Ty))\n    return ABIArgInfo::getExtend(Ty);\n\n  // Handle vector types and vector-like structure types.  Note that\n  // as opposed to float-like structure types, we do not allow any\n  // padding for vector-like structures, so verify the sizes match.\n  uint64_t Size = getContext().getTypeSize(Ty);\n  QualType SingleElementTy = GetSingleElementType(Ty);\n  if (isVectorArgumentType(SingleElementTy) &&\n      getContext().getTypeSize(SingleElementTy) == Size)\n    return ABIArgInfo::getDirect(CGT.ConvertType(SingleElementTy));\n\n  // Values that are not 1, 2, 4 or 8 bytes in size are passed indirectly.\n  if (Size != 8 && Size != 16 && Size != 32 && Size != 64)\n    return getNaturalAlignIndirect(Ty, /*ByVal=*/false);\n\n  // Handle small structures.\n  if (const RecordType *RT = Ty->getAs<RecordType>()) {\n    // Structures with flexible arrays have variable length, so really\n    // fail the size test above.\n    const RecordDecl *RD = RT->getDecl();\n    if (RD->hasFlexibleArrayMember())\n      return getNaturalAlignIndirect(Ty, /*ByVal=*/false);\n\n    // The structure is passed as an unextended integer, a float, or a double.\n    llvm::Type *PassTy;\n    if (isFPArgumentType(SingleElementTy)) {\n      assert(Size == 32 || Size == 64);\n      if (Size == 32)\n        PassTy = llvm::Type::getFloatTy(getVMContext());\n      else\n        PassTy = llvm::Type::getDoubleTy(getVMContext());\n    } else\n      PassTy = llvm::IntegerType::get(getVMContext(), Size);\n    return ABIArgInfo::getDirect(PassTy);\n  }\n\n  // Non-structure compounds are passed indirectly.\n  if (isCompoundType(Ty))\n    return getNaturalAlignIndirect(Ty, /*ByVal=*/false);\n\n  return ABIArgInfo::getDirect(nullptr);\n}\n\n//===----------------------------------------------------------------------===//\n// MSP430 ABI Implementation\n//===----------------------------------------------------------------------===//\n\nnamespace {\n\nclass MSP430ABIInfo : public DefaultABIInfo {\n  static ABIArgInfo complexArgInfo() {\n    ABIArgInfo Info = ABIArgInfo::getDirect();\n    Info.setCanBeFlattened(false);\n    return Info;\n  }\n\npublic:\n  MSP430ABIInfo(CodeGenTypes &CGT) : DefaultABIInfo(CGT) {}\n\n  ABIArgInfo classifyReturnType(QualType RetTy) const {\n    if (RetTy->isAnyComplexType())\n      return complexArgInfo();\n\n    return DefaultABIInfo::classifyReturnType(RetTy);\n  }\n\n  ABIArgInfo classifyArgumentType(QualType RetTy) const {\n    if (RetTy->isAnyComplexType())\n      return complexArgInfo();\n\n    return DefaultABIInfo::classifyArgumentType(RetTy);\n  }\n\n  // Just copy the original implementations because\n  // DefaultABIInfo::classify{Return,Argument}Type() are not virtual\n  void computeInfo(CGFunctionInfo &FI) const override {\n    if (!getCXXABI().classifyReturnType(FI))\n      FI.getReturnInfo() = classifyReturnType(FI.getReturnType());\n    for (auto &I : FI.arguments())\n      I.info = classifyArgumentType(I.type);\n  }\n\n  Address EmitVAArg(CodeGenFunction &CGF, Address VAListAddr,\n                    QualType Ty) const override {\n    return EmitVAArgInstr(CGF, VAListAddr, Ty, classifyArgumentType(Ty));\n  }\n};\n\nclass MSP430TargetCodeGenInfo : public TargetCodeGenInfo {\npublic:\n  MSP430TargetCodeGenInfo(CodeGenTypes &CGT)\n      : TargetCodeGenInfo(std::make_unique<MSP430ABIInfo>(CGT)) {}\n  void setTargetAttributes(const Decl *D, llvm::GlobalValue *GV,\n                           CodeGen::CodeGenModule &M) const override;\n};\n\n}\n\nvoid MSP430TargetCodeGenInfo::setTargetAttributes(\n    const Decl *D, llvm::GlobalValue *GV, CodeGen::CodeGenModule &M) const {\n  if (GV->isDeclaration())\n    return;\n  if (const FunctionDecl *FD = dyn_cast_or_null<FunctionDecl>(D)) {\n    const auto *InterruptAttr = FD->getAttr<MSP430InterruptAttr>();\n    if (!InterruptAttr)\n      return;\n\n    // Handle 'interrupt' attribute:\n    llvm::Function *F = cast<llvm::Function>(GV);\n\n    // Step 1: Set ISR calling convention.\n    F->setCallingConv(llvm::CallingConv::MSP430_INTR);\n\n    // Step 2: Add attributes goodness.\n    F->addFnAttr(llvm::Attribute::NoInline);\n    F->addFnAttr(\"interrupt\", llvm::utostr(InterruptAttr->getNumber()));\n  }\n}\n\n//===----------------------------------------------------------------------===//\n// MIPS ABI Implementation.  This works for both little-endian and\n// big-endian variants.\n//===----------------------------------------------------------------------===//\n\nnamespace {\nclass MipsABIInfo : public ABIInfo {\n  bool IsO32;\n  unsigned MinABIStackAlignInBytes, StackAlignInBytes;\n  void CoerceToIntArgs(uint64_t TySize,\n                       SmallVectorImpl<llvm::Type *> &ArgList) const;\n  llvm::Type* HandleAggregates(QualType Ty, uint64_t TySize) const;\n  llvm::Type* returnAggregateInRegs(QualType RetTy, uint64_t Size) const;\n  llvm::Type* getPaddingType(uint64_t Align, uint64_t Offset) const;\npublic:\n  MipsABIInfo(CodeGenTypes &CGT, bool _IsO32) :\n    ABIInfo(CGT), IsO32(_IsO32), MinABIStackAlignInBytes(IsO32 ? 4 : 8),\n    StackAlignInBytes(IsO32 ? 8 : 16) {}\n\n  ABIArgInfo classifyReturnType(QualType RetTy) const;\n  ABIArgInfo classifyArgumentType(QualType RetTy, uint64_t &Offset) const;\n  void computeInfo(CGFunctionInfo &FI) const override;\n  Address EmitVAArg(CodeGenFunction &CGF, Address VAListAddr,\n                    QualType Ty) const override;\n  ABIArgInfo extendType(QualType Ty) const;\n};\n\nclass MIPSTargetCodeGenInfo : public TargetCodeGenInfo {\n  unsigned SizeOfUnwindException;\npublic:\n  MIPSTargetCodeGenInfo(CodeGenTypes &CGT, bool IsO32)\n      : TargetCodeGenInfo(std::make_unique<MipsABIInfo>(CGT, IsO32)),\n        SizeOfUnwindException(IsO32 ? 24 : 32) {}\n\n  int getDwarfEHStackPointer(CodeGen::CodeGenModule &CGM) const override {\n    return 29;\n  }\n\n  void setTargetAttributes(const Decl *D, llvm::GlobalValue *GV,\n                           CodeGen::CodeGenModule &CGM) const override {\n    const FunctionDecl *FD = dyn_cast_or_null<FunctionDecl>(D);\n    if (!FD) return;\n    llvm::Function *Fn = cast<llvm::Function>(GV);\n\n    if (FD->hasAttr<MipsLongCallAttr>())\n      Fn->addFnAttr(\"long-call\");\n    else if (FD->hasAttr<MipsShortCallAttr>())\n      Fn->addFnAttr(\"short-call\");\n\n    // Other attributes do not have a meaning for declarations.\n    if (GV->isDeclaration())\n      return;\n\n    if (FD->hasAttr<Mips16Attr>()) {\n      Fn->addFnAttr(\"mips16\");\n    }\n    else if (FD->hasAttr<NoMips16Attr>()) {\n      Fn->addFnAttr(\"nomips16\");\n    }\n\n    if (FD->hasAttr<MicroMipsAttr>())\n      Fn->addFnAttr(\"micromips\");\n    else if (FD->hasAttr<NoMicroMipsAttr>())\n      Fn->addFnAttr(\"nomicromips\");\n\n    const MipsInterruptAttr *Attr = FD->getAttr<MipsInterruptAttr>();\n    if (!Attr)\n      return;\n\n    const char *Kind;\n    switch (Attr->getInterrupt()) {\n    case MipsInterruptAttr::eic:     Kind = \"eic\"; break;\n    case MipsInterruptAttr::sw0:     Kind = \"sw0\"; break;\n    case MipsInterruptAttr::sw1:     Kind = \"sw1\"; break;\n    case MipsInterruptAttr::hw0:     Kind = \"hw0\"; break;\n    case MipsInterruptAttr::hw1:     Kind = \"hw1\"; break;\n    case MipsInterruptAttr::hw2:     Kind = \"hw2\"; break;\n    case MipsInterruptAttr::hw3:     Kind = \"hw3\"; break;\n    case MipsInterruptAttr::hw4:     Kind = \"hw4\"; break;\n    case MipsInterruptAttr::hw5:     Kind = \"hw5\"; break;\n    }\n\n    Fn->addFnAttr(\"interrupt\", Kind);\n\n  }\n\n  bool initDwarfEHRegSizeTable(CodeGen::CodeGenFunction &CGF,\n                               llvm::Value *Address) const override;\n\n  unsigned getSizeOfUnwindException() const override {\n    return SizeOfUnwindException;\n  }\n};\n}\n\nvoid MipsABIInfo::CoerceToIntArgs(\n    uint64_t TySize, SmallVectorImpl<llvm::Type *> &ArgList) const {\n  llvm::IntegerType *IntTy =\n    llvm::IntegerType::get(getVMContext(), MinABIStackAlignInBytes * 8);\n\n  // Add (TySize / MinABIStackAlignInBytes) args of IntTy.\n  for (unsigned N = TySize / (MinABIStackAlignInBytes * 8); N; --N)\n    ArgList.push_back(IntTy);\n\n  // If necessary, add one more integer type to ArgList.\n  unsigned R = TySize % (MinABIStackAlignInBytes * 8);\n\n  if (R)\n    ArgList.push_back(llvm::IntegerType::get(getVMContext(), R));\n}\n\n// In N32/64, an aligned double precision floating point field is passed in\n// a register.\nllvm::Type* MipsABIInfo::HandleAggregates(QualType Ty, uint64_t TySize) const {\n  SmallVector<llvm::Type*, 8> ArgList, IntArgList;\n\n  if (IsO32) {\n    CoerceToIntArgs(TySize, ArgList);\n    return llvm::StructType::get(getVMContext(), ArgList);\n  }\n\n  if (Ty->isComplexType())\n    return CGT.ConvertType(Ty);\n\n  const RecordType *RT = Ty->getAs<RecordType>();\n\n  // Unions/vectors are passed in integer registers.\n  if (!RT || !RT->isStructureOrClassType()) {\n    CoerceToIntArgs(TySize, ArgList);\n    return llvm::StructType::get(getVMContext(), ArgList);\n  }\n\n  const RecordDecl *RD = RT->getDecl();\n  const ASTRecordLayout &Layout = getContext().getASTRecordLayout(RD);\n  assert(!(TySize % 8) && \"Size of structure must be multiple of 8.\");\n\n  uint64_t LastOffset = 0;\n  unsigned idx = 0;\n  llvm::IntegerType *I64 = llvm::IntegerType::get(getVMContext(), 64);\n\n  // Iterate over fields in the struct/class and check if there are any aligned\n  // double fields.\n  for (RecordDecl::field_iterator i = RD->field_begin(), e = RD->field_end();\n       i != e; ++i, ++idx) {\n    const QualType Ty = i->getType();\n    const BuiltinType *BT = Ty->getAs<BuiltinType>();\n\n    if (!BT || BT->getKind() != BuiltinType::Double)\n      continue;\n\n    uint64_t Offset = Layout.getFieldOffset(idx);\n    if (Offset % 64) // Ignore doubles that are not aligned.\n      continue;\n\n    // Add ((Offset - LastOffset) / 64) args of type i64.\n    for (unsigned j = (Offset - LastOffset) / 64; j > 0; --j)\n      ArgList.push_back(I64);\n\n    // Add double type.\n    ArgList.push_back(llvm::Type::getDoubleTy(getVMContext()));\n    LastOffset = Offset + 64;\n  }\n\n  CoerceToIntArgs(TySize - LastOffset, IntArgList);\n  ArgList.append(IntArgList.begin(), IntArgList.end());\n\n  return llvm::StructType::get(getVMContext(), ArgList);\n}\n\nllvm::Type *MipsABIInfo::getPaddingType(uint64_t OrigOffset,\n                                        uint64_t Offset) const {\n  if (OrigOffset + MinABIStackAlignInBytes > Offset)\n    return nullptr;\n\n  return llvm::IntegerType::get(getVMContext(), (Offset - OrigOffset) * 8);\n}\n\nABIArgInfo\nMipsABIInfo::classifyArgumentType(QualType Ty, uint64_t &Offset) const {\n  Ty = useFirstFieldIfTransparentUnion(Ty);\n\n  uint64_t OrigOffset = Offset;\n  uint64_t TySize = getContext().getTypeSize(Ty);\n  uint64_t Align = getContext().getTypeAlign(Ty) / 8;\n\n  Align = std::min(std::max(Align, (uint64_t)MinABIStackAlignInBytes),\n                   (uint64_t)StackAlignInBytes);\n  unsigned CurrOffset = llvm::alignTo(Offset, Align);\n  Offset = CurrOffset + llvm::alignTo(TySize, Align * 8) / 8;\n\n  if (isAggregateTypeForABI(Ty) || Ty->isVectorType()) {\n    // Ignore empty aggregates.\n    if (TySize == 0)\n      return ABIArgInfo::getIgnore();\n\n    if (CGCXXABI::RecordArgABI RAA = getRecordArgABI(Ty, getCXXABI())) {\n      Offset = OrigOffset + MinABIStackAlignInBytes;\n      return getNaturalAlignIndirect(Ty, RAA == CGCXXABI::RAA_DirectInMemory);\n    }\n\n    // If we have reached here, aggregates are passed directly by coercing to\n    // another structure type. Padding is inserted if the offset of the\n    // aggregate is unaligned.\n    ABIArgInfo ArgInfo =\n        ABIArgInfo::getDirect(HandleAggregates(Ty, TySize), 0,\n                              getPaddingType(OrigOffset, CurrOffset));\n    ArgInfo.setInReg(true);\n    return ArgInfo;\n  }\n\n  // Treat an enum type as its underlying type.\n  if (const EnumType *EnumTy = Ty->getAs<EnumType>())\n    Ty = EnumTy->getDecl()->getIntegerType();\n\n  // Make sure we pass indirectly things that are too large.\n  if (const auto *EIT = Ty->getAs<ExtIntType>())\n    if (EIT->getNumBits() > 128 ||\n        (EIT->getNumBits() > 64 &&\n         !getContext().getTargetInfo().hasInt128Type()))\n      return getNaturalAlignIndirect(Ty);\n\n  // All integral types are promoted to the GPR width.\n  if (Ty->isIntegralOrEnumerationType())\n    return extendType(Ty);\n\n  return ABIArgInfo::getDirect(\n      nullptr, 0, IsO32 ? nullptr : getPaddingType(OrigOffset, CurrOffset));\n}\n\nllvm::Type*\nMipsABIInfo::returnAggregateInRegs(QualType RetTy, uint64_t Size) const {\n  const RecordType *RT = RetTy->getAs<RecordType>();\n  SmallVector<llvm::Type*, 8> RTList;\n\n  if (RT && RT->isStructureOrClassType()) {\n    const RecordDecl *RD = RT->getDecl();\n    const ASTRecordLayout &Layout = getContext().getASTRecordLayout(RD);\n    unsigned FieldCnt = Layout.getFieldCount();\n\n    // N32/64 returns struct/classes in floating point registers if the\n    // following conditions are met:\n    // 1. The size of the struct/class is no larger than 128-bit.\n    // 2. The struct/class has one or two fields all of which are floating\n    //    point types.\n    // 3. The offset of the first field is zero (this follows what gcc does).\n    //\n    // Any other composite results are returned in integer registers.\n    //\n    if (FieldCnt && (FieldCnt <= 2) && !Layout.getFieldOffset(0)) {\n      RecordDecl::field_iterator b = RD->field_begin(), e = RD->field_end();\n      for (; b != e; ++b) {\n        const BuiltinType *BT = b->getType()->getAs<BuiltinType>();\n\n        if (!BT || !BT->isFloatingPoint())\n          break;\n\n        RTList.push_back(CGT.ConvertType(b->getType()));\n      }\n\n      if (b == e)\n        return llvm::StructType::get(getVMContext(), RTList,\n                                     RD->hasAttr<PackedAttr>());\n\n      RTList.clear();\n    }\n  }\n\n  CoerceToIntArgs(Size, RTList);\n  return llvm::StructType::get(getVMContext(), RTList);\n}\n\nABIArgInfo MipsABIInfo::classifyReturnType(QualType RetTy) const {\n  uint64_t Size = getContext().getTypeSize(RetTy);\n\n  if (RetTy->isVoidType())\n    return ABIArgInfo::getIgnore();\n\n  // O32 doesn't treat zero-sized structs differently from other structs.\n  // However, N32/N64 ignores zero sized return values.\n  if (!IsO32 && Size == 0)\n    return ABIArgInfo::getIgnore();\n\n  if (isAggregateTypeForABI(RetTy) || RetTy->isVectorType()) {\n    if (Size <= 128) {\n      if (RetTy->isAnyComplexType())\n        return ABIArgInfo::getDirect();\n\n      // O32 returns integer vectors in registers and N32/N64 returns all small\n      // aggregates in registers.\n      if (!IsO32 ||\n          (RetTy->isVectorType() && !RetTy->hasFloatingRepresentation())) {\n        ABIArgInfo ArgInfo =\n            ABIArgInfo::getDirect(returnAggregateInRegs(RetTy, Size));\n        ArgInfo.setInReg(true);\n        return ArgInfo;\n      }\n    }\n\n    return getNaturalAlignIndirect(RetTy);\n  }\n\n  // Treat an enum type as its underlying type.\n  if (const EnumType *EnumTy = RetTy->getAs<EnumType>())\n    RetTy = EnumTy->getDecl()->getIntegerType();\n\n  // Make sure we pass indirectly things that are too large.\n  if (const auto *EIT = RetTy->getAs<ExtIntType>())\n    if (EIT->getNumBits() > 128 ||\n        (EIT->getNumBits() > 64 &&\n         !getContext().getTargetInfo().hasInt128Type()))\n      return getNaturalAlignIndirect(RetTy);\n\n  if (isPromotableIntegerTypeForABI(RetTy))\n    return ABIArgInfo::getExtend(RetTy);\n\n  if ((RetTy->isUnsignedIntegerOrEnumerationType() ||\n      RetTy->isSignedIntegerOrEnumerationType()) && Size == 32 && !IsO32)\n    return ABIArgInfo::getSignExtend(RetTy);\n\n  return ABIArgInfo::getDirect();\n}\n\nvoid MipsABIInfo::computeInfo(CGFunctionInfo &FI) const {\n  ABIArgInfo &RetInfo = FI.getReturnInfo();\n  if (!getCXXABI().classifyReturnType(FI))\n    RetInfo = classifyReturnType(FI.getReturnType());\n\n  // Check if a pointer to an aggregate is passed as a hidden argument.\n  uint64_t Offset = RetInfo.isIndirect() ? MinABIStackAlignInBytes : 0;\n\n  for (auto &I : FI.arguments())\n    I.info = classifyArgumentType(I.type, Offset);\n}\n\nAddress MipsABIInfo::EmitVAArg(CodeGenFunction &CGF, Address VAListAddr,\n                               QualType OrigTy) const {\n  QualType Ty = OrigTy;\n\n  // Integer arguments are promoted to 32-bit on O32 and 64-bit on N32/N64.\n  // Pointers are also promoted in the same way but this only matters for N32.\n  unsigned SlotSizeInBits = IsO32 ? 32 : 64;\n  unsigned PtrWidth = getTarget().getPointerWidth(0);\n  bool DidPromote = false;\n  if ((Ty->isIntegerType() &&\n          getContext().getIntWidth(Ty) < SlotSizeInBits) ||\n      (Ty->isPointerType() && PtrWidth < SlotSizeInBits)) {\n    DidPromote = true;\n    Ty = getContext().getIntTypeForBitwidth(SlotSizeInBits,\n                                            Ty->isSignedIntegerType());\n  }\n\n  auto TyInfo = getContext().getTypeInfoInChars(Ty);\n\n  // The alignment of things in the argument area is never larger than\n  // StackAlignInBytes.\n  TyInfo.Align =\n    std::min(TyInfo.Align, CharUnits::fromQuantity(StackAlignInBytes));\n\n  // MinABIStackAlignInBytes is the size of argument slots on the stack.\n  CharUnits ArgSlotSize = CharUnits::fromQuantity(MinABIStackAlignInBytes);\n\n  Address Addr = emitVoidPtrVAArg(CGF, VAListAddr, Ty, /*indirect*/ false,\n                          TyInfo, ArgSlotSize, /*AllowHigherAlign*/ true);\n\n\n  // If there was a promotion, \"unpromote\" into a temporary.\n  // TODO: can we just use a pointer into a subset of the original slot?\n  if (DidPromote) {\n    Address Temp = CGF.CreateMemTemp(OrigTy, \"vaarg.promotion-temp\");\n    llvm::Value *Promoted = CGF.Builder.CreateLoad(Addr);\n\n    // Truncate down to the right width.\n    llvm::Type *IntTy = (OrigTy->isIntegerType() ? Temp.getElementType()\n                                                 : CGF.IntPtrTy);\n    llvm::Value *V = CGF.Builder.CreateTrunc(Promoted, IntTy);\n    if (OrigTy->isPointerType())\n      V = CGF.Builder.CreateIntToPtr(V, Temp.getElementType());\n\n    CGF.Builder.CreateStore(V, Temp);\n    Addr = Temp;\n  }\n\n  return Addr;\n}\n\nABIArgInfo MipsABIInfo::extendType(QualType Ty) const {\n  int TySize = getContext().getTypeSize(Ty);\n\n  // MIPS64 ABI requires unsigned 32 bit integers to be sign extended.\n  if (Ty->isUnsignedIntegerOrEnumerationType() && TySize == 32)\n    return ABIArgInfo::getSignExtend(Ty);\n\n  return ABIArgInfo::getExtend(Ty);\n}\n\nbool\nMIPSTargetCodeGenInfo::initDwarfEHRegSizeTable(CodeGen::CodeGenFunction &CGF,\n                                               llvm::Value *Address) const {\n  // This information comes from gcc's implementation, which seems to\n  // as canonical as it gets.\n\n  // Everything on MIPS is 4 bytes.  Double-precision FP registers\n  // are aliased to pairs of single-precision FP registers.\n  llvm::Value *Four8 = llvm::ConstantInt::get(CGF.Int8Ty, 4);\n\n  // 0-31 are the general purpose registers, $0 - $31.\n  // 32-63 are the floating-point registers, $f0 - $f31.\n  // 64 and 65 are the multiply/divide registers, $hi and $lo.\n  // 66 is the (notional, I think) register for signal-handler return.\n  AssignToArrayRange(CGF.Builder, Address, Four8, 0, 65);\n\n  // 67-74 are the floating-point status registers, $fcc0 - $fcc7.\n  // They are one bit wide and ignored here.\n\n  // 80-111 are the coprocessor 0 registers, $c0r0 - $c0r31.\n  // (coprocessor 1 is the FP unit)\n  // 112-143 are the coprocessor 2 registers, $c2r0 - $c2r31.\n  // 144-175 are the coprocessor 3 registers, $c3r0 - $c3r31.\n  // 176-181 are the DSP accumulator registers.\n  AssignToArrayRange(CGF.Builder, Address, Four8, 80, 181);\n  return false;\n}\n\n//===----------------------------------------------------------------------===//\n// AVR ABI Implementation.\n//===----------------------------------------------------------------------===//\n\nnamespace {\nclass AVRTargetCodeGenInfo : public TargetCodeGenInfo {\npublic:\n  AVRTargetCodeGenInfo(CodeGenTypes &CGT)\n      : TargetCodeGenInfo(std::make_unique<DefaultABIInfo>(CGT)) {}\n\n  void setTargetAttributes(const Decl *D, llvm::GlobalValue *GV,\n                           CodeGen::CodeGenModule &CGM) const override {\n    if (GV->isDeclaration())\n      return;\n    const auto *FD = dyn_cast_or_null<FunctionDecl>(D);\n    if (!FD) return;\n    auto *Fn = cast<llvm::Function>(GV);\n\n    if (FD->getAttr<AVRInterruptAttr>())\n      Fn->addFnAttr(\"interrupt\");\n\n    if (FD->getAttr<AVRSignalAttr>())\n      Fn->addFnAttr(\"signal\");\n  }\n};\n}\n\n//===----------------------------------------------------------------------===//\n// TCE ABI Implementation (see http://tce.cs.tut.fi). Uses mostly the defaults.\n// Currently subclassed only to implement custom OpenCL C function attribute\n// handling.\n//===----------------------------------------------------------------------===//\n\nnamespace {\n\nclass TCETargetCodeGenInfo : public DefaultTargetCodeGenInfo {\npublic:\n  TCETargetCodeGenInfo(CodeGenTypes &CGT)\n    : DefaultTargetCodeGenInfo(CGT) {}\n\n  void setTargetAttributes(const Decl *D, llvm::GlobalValue *GV,\n                           CodeGen::CodeGenModule &M) const override;\n};\n\nvoid TCETargetCodeGenInfo::setTargetAttributes(\n    const Decl *D, llvm::GlobalValue *GV, CodeGen::CodeGenModule &M) const {\n  if (GV->isDeclaration())\n    return;\n  const FunctionDecl *FD = dyn_cast_or_null<FunctionDecl>(D);\n  if (!FD) return;\n\n  llvm::Function *F = cast<llvm::Function>(GV);\n\n  if (M.getLangOpts().OpenCL) {\n    if (FD->hasAttr<OpenCLKernelAttr>()) {\n      // OpenCL C Kernel functions are not subject to inlining\n      F->addFnAttr(llvm::Attribute::NoInline);\n      const ReqdWorkGroupSizeAttr *Attr = FD->getAttr<ReqdWorkGroupSizeAttr>();\n      if (Attr) {\n        // Convert the reqd_work_group_size() attributes to metadata.\n        llvm::LLVMContext &Context = F->getContext();\n        llvm::NamedMDNode *OpenCLMetadata =\n            M.getModule().getOrInsertNamedMetadata(\n                \"opencl.kernel_wg_size_info\");\n\n        SmallVector<llvm::Metadata *, 5> Operands;\n        Operands.push_back(llvm::ConstantAsMetadata::get(F));\n\n        Operands.push_back(\n            llvm::ConstantAsMetadata::get(llvm::Constant::getIntegerValue(\n                M.Int32Ty, llvm::APInt(32, Attr->getXDim()))));\n        Operands.push_back(\n            llvm::ConstantAsMetadata::get(llvm::Constant::getIntegerValue(\n                M.Int32Ty, llvm::APInt(32, Attr->getYDim()))));\n        Operands.push_back(\n            llvm::ConstantAsMetadata::get(llvm::Constant::getIntegerValue(\n                M.Int32Ty, llvm::APInt(32, Attr->getZDim()))));\n\n        // Add a boolean constant operand for \"required\" (true) or \"hint\"\n        // (false) for implementing the work_group_size_hint attr later.\n        // Currently always true as the hint is not yet implemented.\n        Operands.push_back(\n            llvm::ConstantAsMetadata::get(llvm::ConstantInt::getTrue(Context)));\n        OpenCLMetadata->addOperand(llvm::MDNode::get(Context, Operands));\n      }\n    }\n  }\n}\n\n}\n\n//===----------------------------------------------------------------------===//\n// Hexagon ABI Implementation\n//===----------------------------------------------------------------------===//\n\nnamespace {\n\nclass HexagonABIInfo : public DefaultABIInfo {\npublic:\n  HexagonABIInfo(CodeGenTypes &CGT) : DefaultABIInfo(CGT) {}\n\nprivate:\n  ABIArgInfo classifyReturnType(QualType RetTy) const;\n  ABIArgInfo classifyArgumentType(QualType RetTy) const;\n  ABIArgInfo classifyArgumentType(QualType RetTy, unsigned *RegsLeft) const;\n\n  void computeInfo(CGFunctionInfo &FI) const override;\n\n  Address EmitVAArg(CodeGenFunction &CGF, Address VAListAddr,\n                    QualType Ty) const override;\n  Address EmitVAArgFromMemory(CodeGenFunction &CFG, Address VAListAddr,\n                              QualType Ty) const;\n  Address EmitVAArgForHexagon(CodeGenFunction &CFG, Address VAListAddr,\n                              QualType Ty) const;\n  Address EmitVAArgForHexagonLinux(CodeGenFunction &CFG, Address VAListAddr,\n                                   QualType Ty) const;\n};\n\nclass HexagonTargetCodeGenInfo : public TargetCodeGenInfo {\npublic:\n  HexagonTargetCodeGenInfo(CodeGenTypes &CGT)\n      : TargetCodeGenInfo(std::make_unique<HexagonABIInfo>(CGT)) {}\n\n  int getDwarfEHStackPointer(CodeGen::CodeGenModule &M) const override {\n    return 29;\n  }\n\n  void setTargetAttributes(const Decl *D, llvm::GlobalValue *GV,\n                           CodeGen::CodeGenModule &GCM) const override {\n    if (GV->isDeclaration())\n      return;\n    const FunctionDecl *FD = dyn_cast_or_null<FunctionDecl>(D);\n    if (!FD)\n      return;\n  }\n};\n\n} // namespace\n\nvoid HexagonABIInfo::computeInfo(CGFunctionInfo &FI) const {\n  unsigned RegsLeft = 6;\n  if (!getCXXABI().classifyReturnType(FI))\n    FI.getReturnInfo() = classifyReturnType(FI.getReturnType());\n  for (auto &I : FI.arguments())\n    I.info = classifyArgumentType(I.type, &RegsLeft);\n}\n\nstatic bool HexagonAdjustRegsLeft(uint64_t Size, unsigned *RegsLeft) {\n  assert(Size <= 64 && \"Not expecting to pass arguments larger than 64 bits\"\n                       \" through registers\");\n\n  if (*RegsLeft == 0)\n    return false;\n\n  if (Size <= 32) {\n    (*RegsLeft)--;\n    return true;\n  }\n\n  if (2 <= (*RegsLeft & (~1U))) {\n    *RegsLeft = (*RegsLeft & (~1U)) - 2;\n    return true;\n  }\n\n  // Next available register was r5 but candidate was greater than 32-bits so it\n  // has to go on the stack. However we still consume r5\n  if (*RegsLeft == 1)\n    *RegsLeft = 0;\n\n  return false;\n}\n\nABIArgInfo HexagonABIInfo::classifyArgumentType(QualType Ty,\n                                                unsigned *RegsLeft) const {\n  if (!isAggregateTypeForABI(Ty)) {\n    // Treat an enum type as its underlying type.\n    if (const EnumType *EnumTy = Ty->getAs<EnumType>())\n      Ty = EnumTy->getDecl()->getIntegerType();\n\n    uint64_t Size = getContext().getTypeSize(Ty);\n    if (Size <= 64)\n      HexagonAdjustRegsLeft(Size, RegsLeft);\n\n    if (Size > 64 && Ty->isExtIntType())\n      return getNaturalAlignIndirect(Ty, /*ByVal=*/true);\n\n    return isPromotableIntegerTypeForABI(Ty) ? ABIArgInfo::getExtend(Ty)\n                                             : ABIArgInfo::getDirect();\n  }\n\n  if (CGCXXABI::RecordArgABI RAA = getRecordArgABI(Ty, getCXXABI()))\n    return getNaturalAlignIndirect(Ty, RAA == CGCXXABI::RAA_DirectInMemory);\n\n  // Ignore empty records.\n  if (isEmptyRecord(getContext(), Ty, true))\n    return ABIArgInfo::getIgnore();\n\n  uint64_t Size = getContext().getTypeSize(Ty);\n  unsigned Align = getContext().getTypeAlign(Ty);\n\n  if (Size > 64)\n    return getNaturalAlignIndirect(Ty, /*ByVal=*/true);\n\n  if (HexagonAdjustRegsLeft(Size, RegsLeft))\n    Align = Size <= 32 ? 32 : 64;\n  if (Size <= Align) {\n    // Pass in the smallest viable integer type.\n    if (!llvm::isPowerOf2_64(Size))\n      Size = llvm::NextPowerOf2(Size);\n    return ABIArgInfo::getDirect(llvm::Type::getIntNTy(getVMContext(), Size));\n  }\n  return DefaultABIInfo::classifyArgumentType(Ty);\n}\n\nABIArgInfo HexagonABIInfo::classifyReturnType(QualType RetTy) const {\n  if (RetTy->isVoidType())\n    return ABIArgInfo::getIgnore();\n\n  const TargetInfo &T = CGT.getTarget();\n  uint64_t Size = getContext().getTypeSize(RetTy);\n\n  if (RetTy->getAs<VectorType>()) {\n    // HVX vectors are returned in vector registers or register pairs.\n    if (T.hasFeature(\"hvx\")) {\n      assert(T.hasFeature(\"hvx-length64b\") || T.hasFeature(\"hvx-length128b\"));\n      uint64_t VecSize = T.hasFeature(\"hvx-length64b\") ? 64*8 : 128*8;\n      if (Size == VecSize || Size == 2*VecSize)\n        return ABIArgInfo::getDirectInReg();\n    }\n    // Large vector types should be returned via memory.\n    if (Size > 64)\n      return getNaturalAlignIndirect(RetTy);\n  }\n\n  if (!isAggregateTypeForABI(RetTy)) {\n    // Treat an enum type as its underlying type.\n    if (const EnumType *EnumTy = RetTy->getAs<EnumType>())\n      RetTy = EnumTy->getDecl()->getIntegerType();\n\n    if (Size > 64 && RetTy->isExtIntType())\n      return getNaturalAlignIndirect(RetTy, /*ByVal=*/false);\n\n    return isPromotableIntegerTypeForABI(RetTy) ? ABIArgInfo::getExtend(RetTy)\n                                                : ABIArgInfo::getDirect();\n  }\n\n  if (isEmptyRecord(getContext(), RetTy, true))\n    return ABIArgInfo::getIgnore();\n\n  // Aggregates <= 8 bytes are returned in registers, other aggregates\n  // are returned indirectly.\n  if (Size <= 64) {\n    // Return in the smallest viable integer type.\n    if (!llvm::isPowerOf2_64(Size))\n      Size = llvm::NextPowerOf2(Size);\n    return ABIArgInfo::getDirect(llvm::Type::getIntNTy(getVMContext(), Size));\n  }\n  return getNaturalAlignIndirect(RetTy, /*ByVal=*/true);\n}\n\nAddress HexagonABIInfo::EmitVAArgFromMemory(CodeGenFunction &CGF,\n                                            Address VAListAddr,\n                                            QualType Ty) const {\n  // Load the overflow area pointer.\n  Address __overflow_area_pointer_p =\n      CGF.Builder.CreateStructGEP(VAListAddr, 2, \"__overflow_area_pointer_p\");\n  llvm::Value *__overflow_area_pointer = CGF.Builder.CreateLoad(\n      __overflow_area_pointer_p, \"__overflow_area_pointer\");\n\n  uint64_t Align = CGF.getContext().getTypeAlign(Ty) / 8;\n  if (Align > 4) {\n    // Alignment should be a power of 2.\n    assert((Align & (Align - 1)) == 0 && \"Alignment is not power of 2!\");\n\n    // overflow_arg_area = (overflow_arg_area + align - 1) & -align;\n    llvm::Value *Offset = llvm::ConstantInt::get(CGF.Int64Ty, Align - 1);\n\n    // Add offset to the current pointer to access the argument.\n    __overflow_area_pointer =\n        CGF.Builder.CreateGEP(__overflow_area_pointer, Offset);\n    llvm::Value *AsInt =\n        CGF.Builder.CreatePtrToInt(__overflow_area_pointer, CGF.Int32Ty);\n\n    // Create a mask which should be \"AND\"ed\n    // with (overflow_arg_area + align - 1)\n    llvm::Value *Mask = llvm::ConstantInt::get(CGF.Int32Ty, -(int)Align);\n    __overflow_area_pointer = CGF.Builder.CreateIntToPtr(\n        CGF.Builder.CreateAnd(AsInt, Mask), __overflow_area_pointer->getType(),\n        \"__overflow_area_pointer.align\");\n  }\n\n  // Get the type of the argument from memory and bitcast\n  // overflow area pointer to the argument type.\n  llvm::Type *PTy = CGF.ConvertTypeForMem(Ty);\n  Address AddrTyped = CGF.Builder.CreateBitCast(\n      Address(__overflow_area_pointer, CharUnits::fromQuantity(Align)),\n      llvm::PointerType::getUnqual(PTy));\n\n  // Round up to the minimum stack alignment for varargs which is 4 bytes.\n  uint64_t Offset = llvm::alignTo(CGF.getContext().getTypeSize(Ty) / 8, 4);\n\n  __overflow_area_pointer = CGF.Builder.CreateGEP(\n      __overflow_area_pointer, llvm::ConstantInt::get(CGF.Int32Ty, Offset),\n      \"__overflow_area_pointer.next\");\n  CGF.Builder.CreateStore(__overflow_area_pointer, __overflow_area_pointer_p);\n\n  return AddrTyped;\n}\n\nAddress HexagonABIInfo::EmitVAArgForHexagon(CodeGenFunction &CGF,\n                                            Address VAListAddr,\n                                            QualType Ty) const {\n  // FIXME: Need to handle alignment\n  llvm::Type *BP = CGF.Int8PtrTy;\n  llvm::Type *BPP = CGF.Int8PtrPtrTy;\n  CGBuilderTy &Builder = CGF.Builder;\n  Address VAListAddrAsBPP = Builder.CreateBitCast(VAListAddr, BPP, \"ap\");\n  llvm::Value *Addr = Builder.CreateLoad(VAListAddrAsBPP, \"ap.cur\");\n  // Handle address alignment for type alignment > 32 bits\n  uint64_t TyAlign = CGF.getContext().getTypeAlign(Ty) / 8;\n  if (TyAlign > 4) {\n    assert((TyAlign & (TyAlign - 1)) == 0 && \"Alignment is not power of 2!\");\n    llvm::Value *AddrAsInt = Builder.CreatePtrToInt(Addr, CGF.Int32Ty);\n    AddrAsInt = Builder.CreateAdd(AddrAsInt, Builder.getInt32(TyAlign - 1));\n    AddrAsInt = Builder.CreateAnd(AddrAsInt, Builder.getInt32(~(TyAlign - 1)));\n    Addr = Builder.CreateIntToPtr(AddrAsInt, BP);\n  }\n  llvm::Type *PTy = llvm::PointerType::getUnqual(CGF.ConvertType(Ty));\n  Address AddrTyped = Builder.CreateBitCast(\n      Address(Addr, CharUnits::fromQuantity(TyAlign)), PTy);\n\n  uint64_t Offset = llvm::alignTo(CGF.getContext().getTypeSize(Ty) / 8, 4);\n  llvm::Value *NextAddr = Builder.CreateGEP(\n      Addr, llvm::ConstantInt::get(CGF.Int32Ty, Offset), \"ap.next\");\n  Builder.CreateStore(NextAddr, VAListAddrAsBPP);\n\n  return AddrTyped;\n}\n\nAddress HexagonABIInfo::EmitVAArgForHexagonLinux(CodeGenFunction &CGF,\n                                                 Address VAListAddr,\n                                                 QualType Ty) const {\n  int ArgSize = CGF.getContext().getTypeSize(Ty) / 8;\n\n  if (ArgSize > 8)\n    return EmitVAArgFromMemory(CGF, VAListAddr, Ty);\n\n  // Here we have check if the argument is in register area or\n  // in overflow area.\n  // If the saved register area pointer + argsize rounded up to alignment >\n  // saved register area end pointer, argument is in overflow area.\n  unsigned RegsLeft = 6;\n  Ty = CGF.getContext().getCanonicalType(Ty);\n  (void)classifyArgumentType(Ty, &RegsLeft);\n\n  llvm::BasicBlock *MaybeRegBlock = CGF.createBasicBlock(\"vaarg.maybe_reg\");\n  llvm::BasicBlock *InRegBlock = CGF.createBasicBlock(\"vaarg.in_reg\");\n  llvm::BasicBlock *OnStackBlock = CGF.createBasicBlock(\"vaarg.on_stack\");\n  llvm::BasicBlock *ContBlock = CGF.createBasicBlock(\"vaarg.end\");\n\n  // Get rounded size of the argument.GCC does not allow vararg of\n  // size < 4 bytes. We follow the same logic here.\n  ArgSize = (CGF.getContext().getTypeSize(Ty) <= 32) ? 4 : 8;\n  int ArgAlign = (CGF.getContext().getTypeSize(Ty) <= 32) ? 4 : 8;\n\n  // Argument may be in saved register area\n  CGF.EmitBlock(MaybeRegBlock);\n\n  // Load the current saved register area pointer.\n  Address __current_saved_reg_area_pointer_p = CGF.Builder.CreateStructGEP(\n      VAListAddr, 0, \"__current_saved_reg_area_pointer_p\");\n  llvm::Value *__current_saved_reg_area_pointer = CGF.Builder.CreateLoad(\n      __current_saved_reg_area_pointer_p, \"__current_saved_reg_area_pointer\");\n\n  // Load the saved register area end pointer.\n  Address __saved_reg_area_end_pointer_p = CGF.Builder.CreateStructGEP(\n      VAListAddr, 1, \"__saved_reg_area_end_pointer_p\");\n  llvm::Value *__saved_reg_area_end_pointer = CGF.Builder.CreateLoad(\n      __saved_reg_area_end_pointer_p, \"__saved_reg_area_end_pointer\");\n\n  // If the size of argument is > 4 bytes, check if the stack\n  // location is aligned to 8 bytes\n  if (ArgAlign > 4) {\n\n    llvm::Value *__current_saved_reg_area_pointer_int =\n        CGF.Builder.CreatePtrToInt(__current_saved_reg_area_pointer,\n                                   CGF.Int32Ty);\n\n    __current_saved_reg_area_pointer_int = CGF.Builder.CreateAdd(\n        __current_saved_reg_area_pointer_int,\n        llvm::ConstantInt::get(CGF.Int32Ty, (ArgAlign - 1)),\n        \"align_current_saved_reg_area_pointer\");\n\n    __current_saved_reg_area_pointer_int =\n        CGF.Builder.CreateAnd(__current_saved_reg_area_pointer_int,\n                              llvm::ConstantInt::get(CGF.Int32Ty, -ArgAlign),\n                              \"align_current_saved_reg_area_pointer\");\n\n    __current_saved_reg_area_pointer =\n        CGF.Builder.CreateIntToPtr(__current_saved_reg_area_pointer_int,\n                                   __current_saved_reg_area_pointer->getType(),\n                                   \"align_current_saved_reg_area_pointer\");\n  }\n\n  llvm::Value *__new_saved_reg_area_pointer =\n      CGF.Builder.CreateGEP(__current_saved_reg_area_pointer,\n                            llvm::ConstantInt::get(CGF.Int32Ty, ArgSize),\n                            \"__new_saved_reg_area_pointer\");\n\n  llvm::Value *UsingStack = 0;\n  UsingStack = CGF.Builder.CreateICmpSGT(__new_saved_reg_area_pointer,\n                                         __saved_reg_area_end_pointer);\n\n  CGF.Builder.CreateCondBr(UsingStack, OnStackBlock, InRegBlock);\n\n  // Argument in saved register area\n  // Implement the block where argument is in register saved area\n  CGF.EmitBlock(InRegBlock);\n\n  llvm::Type *PTy = CGF.ConvertType(Ty);\n  llvm::Value *__saved_reg_area_p = CGF.Builder.CreateBitCast(\n      __current_saved_reg_area_pointer, llvm::PointerType::getUnqual(PTy));\n\n  CGF.Builder.CreateStore(__new_saved_reg_area_pointer,\n                          __current_saved_reg_area_pointer_p);\n\n  CGF.EmitBranch(ContBlock);\n\n  // Argument in overflow area\n  // Implement the block where the argument is in overflow area.\n  CGF.EmitBlock(OnStackBlock);\n\n  // Load the overflow area pointer\n  Address __overflow_area_pointer_p =\n      CGF.Builder.CreateStructGEP(VAListAddr, 2, \"__overflow_area_pointer_p\");\n  llvm::Value *__overflow_area_pointer = CGF.Builder.CreateLoad(\n      __overflow_area_pointer_p, \"__overflow_area_pointer\");\n\n  // Align the overflow area pointer according to the alignment of the argument\n  if (ArgAlign > 4) {\n    llvm::Value *__overflow_area_pointer_int =\n        CGF.Builder.CreatePtrToInt(__overflow_area_pointer, CGF.Int32Ty);\n\n    __overflow_area_pointer_int =\n        CGF.Builder.CreateAdd(__overflow_area_pointer_int,\n                              llvm::ConstantInt::get(CGF.Int32Ty, ArgAlign - 1),\n                              \"align_overflow_area_pointer\");\n\n    __overflow_area_pointer_int =\n        CGF.Builder.CreateAnd(__overflow_area_pointer_int,\n                              llvm::ConstantInt::get(CGF.Int32Ty, -ArgAlign),\n                              \"align_overflow_area_pointer\");\n\n    __overflow_area_pointer = CGF.Builder.CreateIntToPtr(\n        __overflow_area_pointer_int, __overflow_area_pointer->getType(),\n        \"align_overflow_area_pointer\");\n  }\n\n  // Get the pointer for next argument in overflow area and store it\n  // to overflow area pointer.\n  llvm::Value *__new_overflow_area_pointer = CGF.Builder.CreateGEP(\n      __overflow_area_pointer, llvm::ConstantInt::get(CGF.Int32Ty, ArgSize),\n      \"__overflow_area_pointer.next\");\n\n  CGF.Builder.CreateStore(__new_overflow_area_pointer,\n                          __overflow_area_pointer_p);\n\n  CGF.Builder.CreateStore(__new_overflow_area_pointer,\n                          __current_saved_reg_area_pointer_p);\n\n  // Bitcast the overflow area pointer to the type of argument.\n  llvm::Type *OverflowPTy = CGF.ConvertTypeForMem(Ty);\n  llvm::Value *__overflow_area_p = CGF.Builder.CreateBitCast(\n      __overflow_area_pointer, llvm::PointerType::getUnqual(OverflowPTy));\n\n  CGF.EmitBranch(ContBlock);\n\n  // Get the correct pointer to load the variable argument\n  // Implement the ContBlock\n  CGF.EmitBlock(ContBlock);\n\n  llvm::Type *MemPTy = llvm::PointerType::getUnqual(CGF.ConvertTypeForMem(Ty));\n  llvm::PHINode *ArgAddr = CGF.Builder.CreatePHI(MemPTy, 2, \"vaarg.addr\");\n  ArgAddr->addIncoming(__saved_reg_area_p, InRegBlock);\n  ArgAddr->addIncoming(__overflow_area_p, OnStackBlock);\n\n  return Address(ArgAddr, CharUnits::fromQuantity(ArgAlign));\n}\n\nAddress HexagonABIInfo::EmitVAArg(CodeGenFunction &CGF, Address VAListAddr,\n                                  QualType Ty) const {\n\n  if (getTarget().getTriple().isMusl())\n    return EmitVAArgForHexagonLinux(CGF, VAListAddr, Ty);\n\n  return EmitVAArgForHexagon(CGF, VAListAddr, Ty);\n}\n\n//===----------------------------------------------------------------------===//\n// Lanai ABI Implementation\n//===----------------------------------------------------------------------===//\n\nnamespace {\nclass LanaiABIInfo : public DefaultABIInfo {\npublic:\n  LanaiABIInfo(CodeGen::CodeGenTypes &CGT) : DefaultABIInfo(CGT) {}\n\n  bool shouldUseInReg(QualType Ty, CCState &State) const;\n\n  void computeInfo(CGFunctionInfo &FI) const override {\n    CCState State(FI);\n    // Lanai uses 4 registers to pass arguments unless the function has the\n    // regparm attribute set.\n    if (FI.getHasRegParm()) {\n      State.FreeRegs = FI.getRegParm();\n    } else {\n      State.FreeRegs = 4;\n    }\n\n    if (!getCXXABI().classifyReturnType(FI))\n      FI.getReturnInfo() = classifyReturnType(FI.getReturnType());\n    for (auto &I : FI.arguments())\n      I.info = classifyArgumentType(I.type, State);\n  }\n\n  ABIArgInfo getIndirectResult(QualType Ty, bool ByVal, CCState &State) const;\n  ABIArgInfo classifyArgumentType(QualType RetTy, CCState &State) const;\n};\n} // end anonymous namespace\n\nbool LanaiABIInfo::shouldUseInReg(QualType Ty, CCState &State) const {\n  unsigned Size = getContext().getTypeSize(Ty);\n  unsigned SizeInRegs = llvm::alignTo(Size, 32U) / 32U;\n\n  if (SizeInRegs == 0)\n    return false;\n\n  if (SizeInRegs > State.FreeRegs) {\n    State.FreeRegs = 0;\n    return false;\n  }\n\n  State.FreeRegs -= SizeInRegs;\n\n  return true;\n}\n\nABIArgInfo LanaiABIInfo::getIndirectResult(QualType Ty, bool ByVal,\n                                           CCState &State) const {\n  if (!ByVal) {\n    if (State.FreeRegs) {\n      --State.FreeRegs; // Non-byval indirects just use one pointer.\n      return getNaturalAlignIndirectInReg(Ty);\n    }\n    return getNaturalAlignIndirect(Ty, false);\n  }\n\n  // Compute the byval alignment.\n  const unsigned MinABIStackAlignInBytes = 4;\n  unsigned TypeAlign = getContext().getTypeAlign(Ty) / 8;\n  return ABIArgInfo::getIndirect(CharUnits::fromQuantity(4), /*ByVal=*/true,\n                                 /*Realign=*/TypeAlign >\n                                     MinABIStackAlignInBytes);\n}\n\nABIArgInfo LanaiABIInfo::classifyArgumentType(QualType Ty,\n                                              CCState &State) const {\n  // Check with the C++ ABI first.\n  const RecordType *RT = Ty->getAs<RecordType>();\n  if (RT) {\n    CGCXXABI::RecordArgABI RAA = getRecordArgABI(RT, getCXXABI());\n    if (RAA == CGCXXABI::RAA_Indirect) {\n      return getIndirectResult(Ty, /*ByVal=*/false, State);\n    } else if (RAA == CGCXXABI::RAA_DirectInMemory) {\n      return getNaturalAlignIndirect(Ty, /*ByVal=*/true);\n    }\n  }\n\n  if (isAggregateTypeForABI(Ty)) {\n    // Structures with flexible arrays are always indirect.\n    if (RT && RT->getDecl()->hasFlexibleArrayMember())\n      return getIndirectResult(Ty, /*ByVal=*/true, State);\n\n    // Ignore empty structs/unions.\n    if (isEmptyRecord(getContext(), Ty, true))\n      return ABIArgInfo::getIgnore();\n\n    llvm::LLVMContext &LLVMContext = getVMContext();\n    unsigned SizeInRegs = (getContext().getTypeSize(Ty) + 31) / 32;\n    if (SizeInRegs <= State.FreeRegs) {\n      llvm::IntegerType *Int32 = llvm::Type::getInt32Ty(LLVMContext);\n      SmallVector<llvm::Type *, 3> Elements(SizeInRegs, Int32);\n      llvm::Type *Result = llvm::StructType::get(LLVMContext, Elements);\n      State.FreeRegs -= SizeInRegs;\n      return ABIArgInfo::getDirectInReg(Result);\n    } else {\n      State.FreeRegs = 0;\n    }\n    return getIndirectResult(Ty, true, State);\n  }\n\n  // Treat an enum type as its underlying type.\n  if (const auto *EnumTy = Ty->getAs<EnumType>())\n    Ty = EnumTy->getDecl()->getIntegerType();\n\n  bool InReg = shouldUseInReg(Ty, State);\n\n  // Don't pass >64 bit integers in registers.\n  if (const auto *EIT = Ty->getAs<ExtIntType>())\n    if (EIT->getNumBits() > 64)\n      return getIndirectResult(Ty, /*ByVal=*/true, State);\n\n  if (isPromotableIntegerTypeForABI(Ty)) {\n    if (InReg)\n      return ABIArgInfo::getDirectInReg();\n    return ABIArgInfo::getExtend(Ty);\n  }\n  if (InReg)\n    return ABIArgInfo::getDirectInReg();\n  return ABIArgInfo::getDirect();\n}\n\nnamespace {\nclass LanaiTargetCodeGenInfo : public TargetCodeGenInfo {\npublic:\n  LanaiTargetCodeGenInfo(CodeGen::CodeGenTypes &CGT)\n      : TargetCodeGenInfo(std::make_unique<LanaiABIInfo>(CGT)) {}\n};\n}\n\n//===----------------------------------------------------------------------===//\n// AMDGPU ABI Implementation\n//===----------------------------------------------------------------------===//\n\nnamespace {\n\nclass AMDGPUABIInfo final : public DefaultABIInfo {\nprivate:\n  static const unsigned MaxNumRegsForArgsRet = 16;\n\n  unsigned numRegsForType(QualType Ty) const;\n\n  bool isHomogeneousAggregateBaseType(QualType Ty) const override;\n  bool isHomogeneousAggregateSmallEnough(const Type *Base,\n                                         uint64_t Members) const override;\n\n  // Coerce HIP scalar pointer arguments from generic pointers to global ones.\n  llvm::Type *coerceKernelArgumentType(llvm::Type *Ty, unsigned FromAS,\n                                       unsigned ToAS) const {\n    // Single value types.\n    if (Ty->isPointerTy() && Ty->getPointerAddressSpace() == FromAS)\n      return llvm::PointerType::get(\n          cast<llvm::PointerType>(Ty)->getElementType(), ToAS);\n    return Ty;\n  }\n\npublic:\n  explicit AMDGPUABIInfo(CodeGen::CodeGenTypes &CGT) :\n    DefaultABIInfo(CGT) {}\n\n  ABIArgInfo classifyReturnType(QualType RetTy) const;\n  ABIArgInfo classifyKernelArgumentType(QualType Ty) const;\n  ABIArgInfo classifyArgumentType(QualType Ty, unsigned &NumRegsLeft) const;\n\n  void computeInfo(CGFunctionInfo &FI) const override;\n  Address EmitVAArg(CodeGenFunction &CGF, Address VAListAddr,\n                    QualType Ty) const override;\n};\n\nbool AMDGPUABIInfo::isHomogeneousAggregateBaseType(QualType Ty) const {\n  return true;\n}\n\nbool AMDGPUABIInfo::isHomogeneousAggregateSmallEnough(\n  const Type *Base, uint64_t Members) const {\n  uint32_t NumRegs = (getContext().getTypeSize(Base) + 31) / 32;\n\n  // Homogeneous Aggregates may occupy at most 16 registers.\n  return Members * NumRegs <= MaxNumRegsForArgsRet;\n}\n\n/// Estimate number of registers the type will use when passed in registers.\nunsigned AMDGPUABIInfo::numRegsForType(QualType Ty) const {\n  unsigned NumRegs = 0;\n\n  if (const VectorType *VT = Ty->getAs<VectorType>()) {\n    // Compute from the number of elements. The reported size is based on the\n    // in-memory size, which includes the padding 4th element for 3-vectors.\n    QualType EltTy = VT->getElementType();\n    unsigned EltSize = getContext().getTypeSize(EltTy);\n\n    // 16-bit element vectors should be passed as packed.\n    if (EltSize == 16)\n      return (VT->getNumElements() + 1) / 2;\n\n    unsigned EltNumRegs = (EltSize + 31) / 32;\n    return EltNumRegs * VT->getNumElements();\n  }\n\n  if (const RecordType *RT = Ty->getAs<RecordType>()) {\n    const RecordDecl *RD = RT->getDecl();\n    assert(!RD->hasFlexibleArrayMember());\n\n    for (const FieldDecl *Field : RD->fields()) {\n      QualType FieldTy = Field->getType();\n      NumRegs += numRegsForType(FieldTy);\n    }\n\n    return NumRegs;\n  }\n\n  return (getContext().getTypeSize(Ty) + 31) / 32;\n}\n\nvoid AMDGPUABIInfo::computeInfo(CGFunctionInfo &FI) const {\n  llvm::CallingConv::ID CC = FI.getCallingConvention();\n\n  if (!getCXXABI().classifyReturnType(FI))\n    FI.getReturnInfo() = classifyReturnType(FI.getReturnType());\n\n  unsigned NumRegsLeft = MaxNumRegsForArgsRet;\n  for (auto &Arg : FI.arguments()) {\n    if (CC == llvm::CallingConv::AMDGPU_KERNEL) {\n      Arg.info = classifyKernelArgumentType(Arg.type);\n    } else {\n      Arg.info = classifyArgumentType(Arg.type, NumRegsLeft);\n    }\n  }\n}\n\nAddress AMDGPUABIInfo::EmitVAArg(CodeGenFunction &CGF, Address VAListAddr,\n                                 QualType Ty) const {\n  llvm_unreachable(\"AMDGPU does not support varargs\");\n}\n\nABIArgInfo AMDGPUABIInfo::classifyReturnType(QualType RetTy) const {\n  if (isAggregateTypeForABI(RetTy)) {\n    // Records with non-trivial destructors/copy-constructors should not be\n    // returned by value.\n    if (!getRecordArgABI(RetTy, getCXXABI())) {\n      // Ignore empty structs/unions.\n      if (isEmptyRecord(getContext(), RetTy, true))\n        return ABIArgInfo::getIgnore();\n\n      // Lower single-element structs to just return a regular value.\n      if (const Type *SeltTy = isSingleElementStruct(RetTy, getContext()))\n        return ABIArgInfo::getDirect(CGT.ConvertType(QualType(SeltTy, 0)));\n\n      if (const RecordType *RT = RetTy->getAs<RecordType>()) {\n        const RecordDecl *RD = RT->getDecl();\n        if (RD->hasFlexibleArrayMember())\n          return DefaultABIInfo::classifyReturnType(RetTy);\n      }\n\n      // Pack aggregates <= 4 bytes into single VGPR or pair.\n      uint64_t Size = getContext().getTypeSize(RetTy);\n      if (Size <= 16)\n        return ABIArgInfo::getDirect(llvm::Type::getInt16Ty(getVMContext()));\n\n      if (Size <= 32)\n        return ABIArgInfo::getDirect(llvm::Type::getInt32Ty(getVMContext()));\n\n      if (Size <= 64) {\n        llvm::Type *I32Ty = llvm::Type::getInt32Ty(getVMContext());\n        return ABIArgInfo::getDirect(llvm::ArrayType::get(I32Ty, 2));\n      }\n\n      if (numRegsForType(RetTy) <= MaxNumRegsForArgsRet)\n        return ABIArgInfo::getDirect();\n    }\n  }\n\n  // Otherwise just do the default thing.\n  return DefaultABIInfo::classifyReturnType(RetTy);\n}\n\n/// For kernels all parameters are really passed in a special buffer. It doesn't\n/// make sense to pass anything byval, so everything must be direct.\nABIArgInfo AMDGPUABIInfo::classifyKernelArgumentType(QualType Ty) const {\n  Ty = useFirstFieldIfTransparentUnion(Ty);\n\n  // TODO: Can we omit empty structs?\n\n  if (const Type *SeltTy = isSingleElementStruct(Ty, getContext()))\n    Ty = QualType(SeltTy, 0);\n\n  llvm::Type *OrigLTy = CGT.ConvertType(Ty);\n  llvm::Type *LTy = OrigLTy;\n  if (getContext().getLangOpts().HIP) {\n    LTy = coerceKernelArgumentType(\n        OrigLTy, /*FromAS=*/getContext().getTargetAddressSpace(LangAS::Default),\n        /*ToAS=*/getContext().getTargetAddressSpace(LangAS::cuda_device));\n  }\n\n  // FIXME: Should also use this for OpenCL, but it requires addressing the\n  // problem of kernels being called.\n  //\n  // FIXME: This doesn't apply the optimization of coercing pointers in structs\n  // to global address space when using byref. This would require implementing a\n  // new kind of coercion of the in-memory type when for indirect arguments.\n  if (!getContext().getLangOpts().OpenCL && LTy == OrigLTy &&\n      isAggregateTypeForABI(Ty)) {\n    return ABIArgInfo::getIndirectAliased(\n        getContext().getTypeAlignInChars(Ty),\n        getContext().getTargetAddressSpace(LangAS::opencl_constant),\n        false /*Realign*/, nullptr /*Padding*/);\n  }\n\n  // If we set CanBeFlattened to true, CodeGen will expand the struct to its\n  // individual elements, which confuses the Clover OpenCL backend; therefore we\n  // have to set it to false here. Other args of getDirect() are just defaults.\n  return ABIArgInfo::getDirect(LTy, 0, nullptr, false);\n}\n\nABIArgInfo AMDGPUABIInfo::classifyArgumentType(QualType Ty,\n                                               unsigned &NumRegsLeft) const {\n  assert(NumRegsLeft <= MaxNumRegsForArgsRet && \"register estimate underflow\");\n\n  Ty = useFirstFieldIfTransparentUnion(Ty);\n\n  if (isAggregateTypeForABI(Ty)) {\n    // Records with non-trivial destructors/copy-constructors should not be\n    // passed by value.\n    if (auto RAA = getRecordArgABI(Ty, getCXXABI()))\n      return getNaturalAlignIndirect(Ty, RAA == CGCXXABI::RAA_DirectInMemory);\n\n    // Ignore empty structs/unions.\n    if (isEmptyRecord(getContext(), Ty, true))\n      return ABIArgInfo::getIgnore();\n\n    // Lower single-element structs to just pass a regular value. TODO: We\n    // could do reasonable-size multiple-element structs too, using getExpand(),\n    // though watch out for things like bitfields.\n    if (const Type *SeltTy = isSingleElementStruct(Ty, getContext()))\n      return ABIArgInfo::getDirect(CGT.ConvertType(QualType(SeltTy, 0)));\n\n    if (const RecordType *RT = Ty->getAs<RecordType>()) {\n      const RecordDecl *RD = RT->getDecl();\n      if (RD->hasFlexibleArrayMember())\n        return DefaultABIInfo::classifyArgumentType(Ty);\n    }\n\n    // Pack aggregates <= 8 bytes into single VGPR or pair.\n    uint64_t Size = getContext().getTypeSize(Ty);\n    if (Size <= 64) {\n      unsigned NumRegs = (Size + 31) / 32;\n      NumRegsLeft -= std::min(NumRegsLeft, NumRegs);\n\n      if (Size <= 16)\n        return ABIArgInfo::getDirect(llvm::Type::getInt16Ty(getVMContext()));\n\n      if (Size <= 32)\n        return ABIArgInfo::getDirect(llvm::Type::getInt32Ty(getVMContext()));\n\n      // XXX: Should this be i64 instead, and should the limit increase?\n      llvm::Type *I32Ty = llvm::Type::getInt32Ty(getVMContext());\n      return ABIArgInfo::getDirect(llvm::ArrayType::get(I32Ty, 2));\n    }\n\n    if (NumRegsLeft > 0) {\n      unsigned NumRegs = numRegsForType(Ty);\n      if (NumRegsLeft >= NumRegs) {\n        NumRegsLeft -= NumRegs;\n        return ABIArgInfo::getDirect();\n      }\n    }\n  }\n\n  // Otherwise just do the default thing.\n  ABIArgInfo ArgInfo = DefaultABIInfo::classifyArgumentType(Ty);\n  if (!ArgInfo.isIndirect()) {\n    unsigned NumRegs = numRegsForType(Ty);\n    NumRegsLeft -= std::min(NumRegs, NumRegsLeft);\n  }\n\n  return ArgInfo;\n}\n\nclass AMDGPUTargetCodeGenInfo : public TargetCodeGenInfo {\npublic:\n  AMDGPUTargetCodeGenInfo(CodeGenTypes &CGT)\n      : TargetCodeGenInfo(std::make_unique<AMDGPUABIInfo>(CGT)) {}\n  void setTargetAttributes(const Decl *D, llvm::GlobalValue *GV,\n                           CodeGen::CodeGenModule &M) const override;\n  unsigned getOpenCLKernelCallingConv() const override;\n\n  llvm::Constant *getNullPointer(const CodeGen::CodeGenModule &CGM,\n      llvm::PointerType *T, QualType QT) const override;\n\n  LangAS getASTAllocaAddressSpace() const override {\n    return getLangASFromTargetAS(\n        getABIInfo().getDataLayout().getAllocaAddrSpace());\n  }\n  LangAS getGlobalVarAddressSpace(CodeGenModule &CGM,\n                                  const VarDecl *D) const override;\n  llvm::SyncScope::ID getLLVMSyncScopeID(const LangOptions &LangOpts,\n                                         SyncScope Scope,\n                                         llvm::AtomicOrdering Ordering,\n                                         llvm::LLVMContext &Ctx) const override;\n  llvm::Function *\n  createEnqueuedBlockKernel(CodeGenFunction &CGF,\n                            llvm::Function *BlockInvokeFunc,\n                            llvm::Value *BlockLiteral) const override;\n  bool shouldEmitStaticExternCAliases() const override;\n  void setCUDAKernelCallingConvention(const FunctionType *&FT) const override;\n};\n}\n\nstatic bool requiresAMDGPUProtectedVisibility(const Decl *D,\n                                              llvm::GlobalValue *GV) {\n  if (GV->getVisibility() != llvm::GlobalValue::HiddenVisibility)\n    return false;\n\n  return D->hasAttr<OpenCLKernelAttr>() ||\n         (isa<FunctionDecl>(D) && D->hasAttr<CUDAGlobalAttr>()) ||\n         (isa<VarDecl>(D) &&\n          (D->hasAttr<CUDADeviceAttr>() || D->hasAttr<CUDAConstantAttr>() ||\n           cast<VarDecl>(D)->getType()->isCUDADeviceBuiltinSurfaceType() ||\n           cast<VarDecl>(D)->getType()->isCUDADeviceBuiltinTextureType()));\n}\n\nvoid AMDGPUTargetCodeGenInfo::setTargetAttributes(\n    const Decl *D, llvm::GlobalValue *GV, CodeGen::CodeGenModule &M) const {\n  if (requiresAMDGPUProtectedVisibility(D, GV)) {\n    GV->setVisibility(llvm::GlobalValue::ProtectedVisibility);\n    GV->setDSOLocal(true);\n  }\n\n  if (GV->isDeclaration())\n    return;\n  const FunctionDecl *FD = dyn_cast_or_null<FunctionDecl>(D);\n  if (!FD)\n    return;\n\n  llvm::Function *F = cast<llvm::Function>(GV);\n\n  const auto *ReqdWGS = M.getLangOpts().OpenCL ?\n    FD->getAttr<ReqdWorkGroupSizeAttr>() : nullptr;\n\n\n  const bool IsOpenCLKernel = M.getLangOpts().OpenCL &&\n                              FD->hasAttr<OpenCLKernelAttr>();\n  const bool IsHIPKernel = M.getLangOpts().HIP &&\n                           FD->hasAttr<CUDAGlobalAttr>();\n  if ((IsOpenCLKernel || IsHIPKernel) &&\n      (M.getTriple().getOS() == llvm::Triple::AMDHSA))\n    F->addFnAttr(\"amdgpu-implicitarg-num-bytes\", \"56\");\n\n  if (IsHIPKernel)\n    F->addFnAttr(\"uniform-work-group-size\", \"true\");\n\n\n  const auto *FlatWGS = FD->getAttr<AMDGPUFlatWorkGroupSizeAttr>();\n  if (ReqdWGS || FlatWGS) {\n    unsigned Min = 0;\n    unsigned Max = 0;\n    if (FlatWGS) {\n      Min = FlatWGS->getMin()\n                ->EvaluateKnownConstInt(M.getContext())\n                .getExtValue();\n      Max = FlatWGS->getMax()\n                ->EvaluateKnownConstInt(M.getContext())\n                .getExtValue();\n    }\n    if (ReqdWGS && Min == 0 && Max == 0)\n      Min = Max = ReqdWGS->getXDim() * ReqdWGS->getYDim() * ReqdWGS->getZDim();\n\n    if (Min != 0) {\n      assert(Min <= Max && \"Min must be less than or equal Max\");\n\n      std::string AttrVal = llvm::utostr(Min) + \",\" + llvm::utostr(Max);\n      F->addFnAttr(\"amdgpu-flat-work-group-size\", AttrVal);\n    } else\n      assert(Max == 0 && \"Max must be zero\");\n  } else if (IsOpenCLKernel || IsHIPKernel) {\n    // By default, restrict the maximum size to a value specified by\n    // --gpu-max-threads-per-block=n or its default value for HIP.\n    const unsigned OpenCLDefaultMaxWorkGroupSize = 256;\n    const unsigned DefaultMaxWorkGroupSize =\n        IsOpenCLKernel ? OpenCLDefaultMaxWorkGroupSize\n                       : M.getLangOpts().GPUMaxThreadsPerBlock;\n    std::string AttrVal =\n        std::string(\"1,\") + llvm::utostr(DefaultMaxWorkGroupSize);\n    F->addFnAttr(\"amdgpu-flat-work-group-size\", AttrVal);\n  }\n\n  if (const auto *Attr = FD->getAttr<AMDGPUWavesPerEUAttr>()) {\n    unsigned Min =\n        Attr->getMin()->EvaluateKnownConstInt(M.getContext()).getExtValue();\n    unsigned Max = Attr->getMax() ? Attr->getMax()\n                                        ->EvaluateKnownConstInt(M.getContext())\n                                        .getExtValue()\n                                  : 0;\n\n    if (Min != 0) {\n      assert((Max == 0 || Min <= Max) && \"Min must be less than or equal Max\");\n\n      std::string AttrVal = llvm::utostr(Min);\n      if (Max != 0)\n        AttrVal = AttrVal + \",\" + llvm::utostr(Max);\n      F->addFnAttr(\"amdgpu-waves-per-eu\", AttrVal);\n    } else\n      assert(Max == 0 && \"Max must be zero\");\n  }\n\n  if (const auto *Attr = FD->getAttr<AMDGPUNumSGPRAttr>()) {\n    unsigned NumSGPR = Attr->getNumSGPR();\n\n    if (NumSGPR != 0)\n      F->addFnAttr(\"amdgpu-num-sgpr\", llvm::utostr(NumSGPR));\n  }\n\n  if (const auto *Attr = FD->getAttr<AMDGPUNumVGPRAttr>()) {\n    uint32_t NumVGPR = Attr->getNumVGPR();\n\n    if (NumVGPR != 0)\n      F->addFnAttr(\"amdgpu-num-vgpr\", llvm::utostr(NumVGPR));\n  }\n\n  if (M.getContext().getTargetInfo().allowAMDGPUUnsafeFPAtomics())\n    F->addFnAttr(\"amdgpu-unsafe-fp-atomics\", \"true\");\n}\n\nunsigned AMDGPUTargetCodeGenInfo::getOpenCLKernelCallingConv() const {\n  return llvm::CallingConv::AMDGPU_KERNEL;\n}\n\n// Currently LLVM assumes null pointers always have value 0,\n// which results in incorrectly transformed IR. Therefore, instead of\n// emitting null pointers in private and local address spaces, a null\n// pointer in generic address space is emitted which is casted to a\n// pointer in local or private address space.\nllvm::Constant *AMDGPUTargetCodeGenInfo::getNullPointer(\n    const CodeGen::CodeGenModule &CGM, llvm::PointerType *PT,\n    QualType QT) const {\n  if (CGM.getContext().getTargetNullPointerValue(QT) == 0)\n    return llvm::ConstantPointerNull::get(PT);\n\n  auto &Ctx = CGM.getContext();\n  auto NPT = llvm::PointerType::get(PT->getElementType(),\n      Ctx.getTargetAddressSpace(LangAS::opencl_generic));\n  return llvm::ConstantExpr::getAddrSpaceCast(\n      llvm::ConstantPointerNull::get(NPT), PT);\n}\n\nLangAS\nAMDGPUTargetCodeGenInfo::getGlobalVarAddressSpace(CodeGenModule &CGM,\n                                                  const VarDecl *D) const {\n  assert(!CGM.getLangOpts().OpenCL &&\n         !(CGM.getLangOpts().CUDA && CGM.getLangOpts().CUDAIsDevice) &&\n         \"Address space agnostic languages only\");\n  LangAS DefaultGlobalAS = getLangASFromTargetAS(\n      CGM.getContext().getTargetAddressSpace(LangAS::opencl_global));\n  if (!D)\n    return DefaultGlobalAS;\n\n  LangAS AddrSpace = D->getType().getAddressSpace();\n  assert(AddrSpace == LangAS::Default || isTargetAddressSpace(AddrSpace));\n  if (AddrSpace != LangAS::Default)\n    return AddrSpace;\n\n  if (CGM.isTypeConstant(D->getType(), false)) {\n    if (auto ConstAS = CGM.getTarget().getConstantAddressSpace())\n      return ConstAS.getValue();\n  }\n  return DefaultGlobalAS;\n}\n\nllvm::SyncScope::ID\nAMDGPUTargetCodeGenInfo::getLLVMSyncScopeID(const LangOptions &LangOpts,\n                                            SyncScope Scope,\n                                            llvm::AtomicOrdering Ordering,\n                                            llvm::LLVMContext &Ctx) const {\n  std::string Name;\n  switch (Scope) {\n  case SyncScope::OpenCLWorkGroup:\n    Name = \"workgroup\";\n    break;\n  case SyncScope::OpenCLDevice:\n    Name = \"agent\";\n    break;\n  case SyncScope::OpenCLAllSVMDevices:\n    Name = \"\";\n    break;\n  case SyncScope::OpenCLSubGroup:\n    Name = \"wavefront\";\n  }\n\n  if (Ordering != llvm::AtomicOrdering::SequentiallyConsistent) {\n    if (!Name.empty())\n      Name = Twine(Twine(Name) + Twine(\"-\")).str();\n\n    Name = Twine(Twine(Name) + Twine(\"one-as\")).str();\n  }\n\n  return Ctx.getOrInsertSyncScopeID(Name);\n}\n\nbool AMDGPUTargetCodeGenInfo::shouldEmitStaticExternCAliases() const {\n  return false;\n}\n\nvoid AMDGPUTargetCodeGenInfo::setCUDAKernelCallingConvention(\n    const FunctionType *&FT) const {\n  FT = getABIInfo().getContext().adjustFunctionType(\n      FT, FT->getExtInfo().withCallingConv(CC_OpenCLKernel));\n}\n\n//===----------------------------------------------------------------------===//\n// SPARC v8 ABI Implementation.\n// Based on the SPARC Compliance Definition version 2.4.1.\n//\n// Ensures that complex values are passed in registers.\n//\nnamespace {\nclass SparcV8ABIInfo : public DefaultABIInfo {\npublic:\n  SparcV8ABIInfo(CodeGenTypes &CGT) : DefaultABIInfo(CGT) {}\n\nprivate:\n  ABIArgInfo classifyReturnType(QualType RetTy) const;\n  void computeInfo(CGFunctionInfo &FI) const override;\n};\n} // end anonymous namespace\n\n\nABIArgInfo\nSparcV8ABIInfo::classifyReturnType(QualType Ty) const {\n  if (Ty->isAnyComplexType()) {\n    return ABIArgInfo::getDirect();\n  }\n  else {\n    return DefaultABIInfo::classifyReturnType(Ty);\n  }\n}\n\nvoid SparcV8ABIInfo::computeInfo(CGFunctionInfo &FI) const {\n\n  FI.getReturnInfo() = classifyReturnType(FI.getReturnType());\n  for (auto &Arg : FI.arguments())\n    Arg.info = classifyArgumentType(Arg.type);\n}\n\nnamespace {\nclass SparcV8TargetCodeGenInfo : public TargetCodeGenInfo {\npublic:\n  SparcV8TargetCodeGenInfo(CodeGenTypes &CGT)\n      : TargetCodeGenInfo(std::make_unique<SparcV8ABIInfo>(CGT)) {}\n};\n} // end anonymous namespace\n\n//===----------------------------------------------------------------------===//\n// SPARC v9 ABI Implementation.\n// Based on the SPARC Compliance Definition version 2.4.1.\n//\n// Function arguments a mapped to a nominal \"parameter array\" and promoted to\n// registers depending on their type. Each argument occupies 8 or 16 bytes in\n// the array, structs larger than 16 bytes are passed indirectly.\n//\n// One case requires special care:\n//\n//   struct mixed {\n//     int i;\n//     float f;\n//   };\n//\n// When a struct mixed is passed by value, it only occupies 8 bytes in the\n// parameter array, but the int is passed in an integer register, and the float\n// is passed in a floating point register. This is represented as two arguments\n// with the LLVM IR inreg attribute:\n//\n//   declare void f(i32 inreg %i, float inreg %f)\n//\n// The code generator will only allocate 4 bytes from the parameter array for\n// the inreg arguments. All other arguments are allocated a multiple of 8\n// bytes.\n//\nnamespace {\nclass SparcV9ABIInfo : public ABIInfo {\npublic:\n  SparcV9ABIInfo(CodeGenTypes &CGT) : ABIInfo(CGT) {}\n\nprivate:\n  ABIArgInfo classifyType(QualType RetTy, unsigned SizeLimit) const;\n  void computeInfo(CGFunctionInfo &FI) const override;\n  Address EmitVAArg(CodeGenFunction &CGF, Address VAListAddr,\n                    QualType Ty) const override;\n\n  // Coercion type builder for structs passed in registers. The coercion type\n  // serves two purposes:\n  //\n  // 1. Pad structs to a multiple of 64 bits, so they are passed 'left-aligned'\n  //    in registers.\n  // 2. Expose aligned floating point elements as first-level elements, so the\n  //    code generator knows to pass them in floating point registers.\n  //\n  // We also compute the InReg flag which indicates that the struct contains\n  // aligned 32-bit floats.\n  //\n  struct CoerceBuilder {\n    llvm::LLVMContext &Context;\n    const llvm::DataLayout &DL;\n    SmallVector<llvm::Type*, 8> Elems;\n    uint64_t Size;\n    bool InReg;\n\n    CoerceBuilder(llvm::LLVMContext &c, const llvm::DataLayout &dl)\n      : Context(c), DL(dl), Size(0), InReg(false) {}\n\n    // Pad Elems with integers until Size is ToSize.\n    void pad(uint64_t ToSize) {\n      assert(ToSize >= Size && \"Cannot remove elements\");\n      if (ToSize == Size)\n        return;\n\n      // Finish the current 64-bit word.\n      uint64_t Aligned = llvm::alignTo(Size, 64);\n      if (Aligned > Size && Aligned <= ToSize) {\n        Elems.push_back(llvm::IntegerType::get(Context, Aligned - Size));\n        Size = Aligned;\n      }\n\n      // Add whole 64-bit words.\n      while (Size + 64 <= ToSize) {\n        Elems.push_back(llvm::Type::getInt64Ty(Context));\n        Size += 64;\n      }\n\n      // Final in-word padding.\n      if (Size < ToSize) {\n        Elems.push_back(llvm::IntegerType::get(Context, ToSize - Size));\n        Size = ToSize;\n      }\n    }\n\n    // Add a floating point element at Offset.\n    void addFloat(uint64_t Offset, llvm::Type *Ty, unsigned Bits) {\n      // Unaligned floats are treated as integers.\n      if (Offset % Bits)\n        return;\n      // The InReg flag is only required if there are any floats < 64 bits.\n      if (Bits < 64)\n        InReg = true;\n      pad(Offset);\n      Elems.push_back(Ty);\n      Size = Offset + Bits;\n    }\n\n    // Add a struct type to the coercion type, starting at Offset (in bits).\n    void addStruct(uint64_t Offset, llvm::StructType *StrTy) {\n      const llvm::StructLayout *Layout = DL.getStructLayout(StrTy);\n      for (unsigned i = 0, e = StrTy->getNumElements(); i != e; ++i) {\n        llvm::Type *ElemTy = StrTy->getElementType(i);\n        uint64_t ElemOffset = Offset + Layout->getElementOffsetInBits(i);\n        switch (ElemTy->getTypeID()) {\n        case llvm::Type::StructTyID:\n          addStruct(ElemOffset, cast<llvm::StructType>(ElemTy));\n          break;\n        case llvm::Type::FloatTyID:\n          addFloat(ElemOffset, ElemTy, 32);\n          break;\n        case llvm::Type::DoubleTyID:\n          addFloat(ElemOffset, ElemTy, 64);\n          break;\n        case llvm::Type::FP128TyID:\n          addFloat(ElemOffset, ElemTy, 128);\n          break;\n        case llvm::Type::PointerTyID:\n          if (ElemOffset % 64 == 0) {\n            pad(ElemOffset);\n            Elems.push_back(ElemTy);\n            Size += 64;\n          }\n          break;\n        default:\n          break;\n        }\n      }\n    }\n\n    // Check if Ty is a usable substitute for the coercion type.\n    bool isUsableType(llvm::StructType *Ty) const {\n      return llvm::makeArrayRef(Elems) == Ty->elements();\n    }\n\n    // Get the coercion type as a literal struct type.\n    llvm::Type *getType() const {\n      if (Elems.size() == 1)\n        return Elems.front();\n      else\n        return llvm::StructType::get(Context, Elems);\n    }\n  };\n};\n} // end anonymous namespace\n\nABIArgInfo\nSparcV9ABIInfo::classifyType(QualType Ty, unsigned SizeLimit) const {\n  if (Ty->isVoidType())\n    return ABIArgInfo::getIgnore();\n\n  uint64_t Size = getContext().getTypeSize(Ty);\n\n  // Anything too big to fit in registers is passed with an explicit indirect\n  // pointer / sret pointer.\n  if (Size > SizeLimit)\n    return getNaturalAlignIndirect(Ty, /*ByVal=*/false);\n\n  // Treat an enum type as its underlying type.\n  if (const EnumType *EnumTy = Ty->getAs<EnumType>())\n    Ty = EnumTy->getDecl()->getIntegerType();\n\n  // Integer types smaller than a register are extended.\n  if (Size < 64 && Ty->isIntegerType())\n    return ABIArgInfo::getExtend(Ty);\n\n  if (const auto *EIT = Ty->getAs<ExtIntType>())\n    if (EIT->getNumBits() < 64)\n      return ABIArgInfo::getExtend(Ty);\n\n  // Other non-aggregates go in registers.\n  if (!isAggregateTypeForABI(Ty))\n    return ABIArgInfo::getDirect();\n\n  // If a C++ object has either a non-trivial copy constructor or a non-trivial\n  // destructor, it is passed with an explicit indirect pointer / sret pointer.\n  if (CGCXXABI::RecordArgABI RAA = getRecordArgABI(Ty, getCXXABI()))\n    return getNaturalAlignIndirect(Ty, RAA == CGCXXABI::RAA_DirectInMemory);\n\n  // This is a small aggregate type that should be passed in registers.\n  // Build a coercion type from the LLVM struct type.\n  llvm::StructType *StrTy = dyn_cast<llvm::StructType>(CGT.ConvertType(Ty));\n  if (!StrTy)\n    return ABIArgInfo::getDirect();\n\n  CoerceBuilder CB(getVMContext(), getDataLayout());\n  CB.addStruct(0, StrTy);\n  CB.pad(llvm::alignTo(CB.DL.getTypeSizeInBits(StrTy), 64));\n\n  // Try to use the original type for coercion.\n  llvm::Type *CoerceTy = CB.isUsableType(StrTy) ? StrTy : CB.getType();\n\n  if (CB.InReg)\n    return ABIArgInfo::getDirectInReg(CoerceTy);\n  else\n    return ABIArgInfo::getDirect(CoerceTy);\n}\n\nAddress SparcV9ABIInfo::EmitVAArg(CodeGenFunction &CGF, Address VAListAddr,\n                                  QualType Ty) const {\n  ABIArgInfo AI = classifyType(Ty, 16 * 8);\n  llvm::Type *ArgTy = CGT.ConvertType(Ty);\n  if (AI.canHaveCoerceToType() && !AI.getCoerceToType())\n    AI.setCoerceToType(ArgTy);\n\n  CharUnits SlotSize = CharUnits::fromQuantity(8);\n\n  CGBuilderTy &Builder = CGF.Builder;\n  Address Addr(Builder.CreateLoad(VAListAddr, \"ap.cur\"), SlotSize);\n  llvm::Type *ArgPtrTy = llvm::PointerType::getUnqual(ArgTy);\n\n  auto TypeInfo = getContext().getTypeInfoInChars(Ty);\n\n  Address ArgAddr = Address::invalid();\n  CharUnits Stride;\n  switch (AI.getKind()) {\n  case ABIArgInfo::Expand:\n  case ABIArgInfo::CoerceAndExpand:\n  case ABIArgInfo::InAlloca:\n    llvm_unreachable(\"Unsupported ABI kind for va_arg\");\n\n  case ABIArgInfo::Extend: {\n    Stride = SlotSize;\n    CharUnits Offset = SlotSize - TypeInfo.Width;\n    ArgAddr = Builder.CreateConstInBoundsByteGEP(Addr, Offset, \"extend\");\n    break;\n  }\n\n  case ABIArgInfo::Direct: {\n    auto AllocSize = getDataLayout().getTypeAllocSize(AI.getCoerceToType());\n    Stride = CharUnits::fromQuantity(AllocSize).alignTo(SlotSize);\n    ArgAddr = Addr;\n    break;\n  }\n\n  case ABIArgInfo::Indirect:\n  case ABIArgInfo::IndirectAliased:\n    Stride = SlotSize;\n    ArgAddr = Builder.CreateElementBitCast(Addr, ArgPtrTy, \"indirect\");\n    ArgAddr = Address(Builder.CreateLoad(ArgAddr, \"indirect.arg\"),\n                      TypeInfo.Align);\n    break;\n\n  case ABIArgInfo::Ignore:\n    return Address(llvm::UndefValue::get(ArgPtrTy), TypeInfo.Align);\n  }\n\n  // Update VAList.\n  Address NextPtr = Builder.CreateConstInBoundsByteGEP(Addr, Stride, \"ap.next\");\n  Builder.CreateStore(NextPtr.getPointer(), VAListAddr);\n\n  return Builder.CreateBitCast(ArgAddr, ArgPtrTy, \"arg.addr\");\n}\n\nvoid SparcV9ABIInfo::computeInfo(CGFunctionInfo &FI) const {\n  FI.getReturnInfo() = classifyType(FI.getReturnType(), 32 * 8);\n  for (auto &I : FI.arguments())\n    I.info = classifyType(I.type, 16 * 8);\n}\n\nnamespace {\nclass SparcV9TargetCodeGenInfo : public TargetCodeGenInfo {\npublic:\n  SparcV9TargetCodeGenInfo(CodeGenTypes &CGT)\n      : TargetCodeGenInfo(std::make_unique<SparcV9ABIInfo>(CGT)) {}\n\n  int getDwarfEHStackPointer(CodeGen::CodeGenModule &M) const override {\n    return 14;\n  }\n\n  bool initDwarfEHRegSizeTable(CodeGen::CodeGenFunction &CGF,\n                               llvm::Value *Address) const override;\n};\n} // end anonymous namespace\n\nbool\nSparcV9TargetCodeGenInfo::initDwarfEHRegSizeTable(CodeGen::CodeGenFunction &CGF,\n                                                llvm::Value *Address) const {\n  // This is calculated from the LLVM and GCC tables and verified\n  // against gcc output.  AFAIK all ABIs use the same encoding.\n\n  CodeGen::CGBuilderTy &Builder = CGF.Builder;\n\n  llvm::IntegerType *i8 = CGF.Int8Ty;\n  llvm::Value *Four8 = llvm::ConstantInt::get(i8, 4);\n  llvm::Value *Eight8 = llvm::ConstantInt::get(i8, 8);\n\n  // 0-31: the 8-byte general-purpose registers\n  AssignToArrayRange(Builder, Address, Eight8, 0, 31);\n\n  // 32-63: f0-31, the 4-byte floating-point registers\n  AssignToArrayRange(Builder, Address, Four8, 32, 63);\n\n  //   Y   = 64\n  //   PSR = 65\n  //   WIM = 66\n  //   TBR = 67\n  //   PC  = 68\n  //   NPC = 69\n  //   FSR = 70\n  //   CSR = 71\n  AssignToArrayRange(Builder, Address, Eight8, 64, 71);\n\n  // 72-87: d0-15, the 8-byte floating-point registers\n  AssignToArrayRange(Builder, Address, Eight8, 72, 87);\n\n  return false;\n}\n\n// ARC ABI implementation.\nnamespace {\n\nclass ARCABIInfo : public DefaultABIInfo {\npublic:\n  using DefaultABIInfo::DefaultABIInfo;\n\nprivate:\n  Address EmitVAArg(CodeGenFunction &CGF, Address VAListAddr,\n                    QualType Ty) const override;\n\n  void updateState(const ABIArgInfo &Info, QualType Ty, CCState &State) const {\n    if (!State.FreeRegs)\n      return;\n    if (Info.isIndirect() && Info.getInReg())\n      State.FreeRegs--;\n    else if (Info.isDirect() && Info.getInReg()) {\n      unsigned sz = (getContext().getTypeSize(Ty) + 31) / 32;\n      if (sz < State.FreeRegs)\n        State.FreeRegs -= sz;\n      else\n        State.FreeRegs = 0;\n    }\n  }\n\n  void computeInfo(CGFunctionInfo &FI) const override {\n    CCState State(FI);\n    // ARC uses 8 registers to pass arguments.\n    State.FreeRegs = 8;\n\n    if (!getCXXABI().classifyReturnType(FI))\n      FI.getReturnInfo() = classifyReturnType(FI.getReturnType());\n    updateState(FI.getReturnInfo(), FI.getReturnType(), State);\n    for (auto &I : FI.arguments()) {\n      I.info = classifyArgumentType(I.type, State.FreeRegs);\n      updateState(I.info, I.type, State);\n    }\n  }\n\n  ABIArgInfo getIndirectByRef(QualType Ty, bool HasFreeRegs) const;\n  ABIArgInfo getIndirectByValue(QualType Ty) const;\n  ABIArgInfo classifyArgumentType(QualType Ty, uint8_t FreeRegs) const;\n  ABIArgInfo classifyReturnType(QualType RetTy) const;\n};\n\nclass ARCTargetCodeGenInfo : public TargetCodeGenInfo {\npublic:\n  ARCTargetCodeGenInfo(CodeGenTypes &CGT)\n      : TargetCodeGenInfo(std::make_unique<ARCABIInfo>(CGT)) {}\n};\n\n\nABIArgInfo ARCABIInfo::getIndirectByRef(QualType Ty, bool HasFreeRegs) const {\n  return HasFreeRegs ? getNaturalAlignIndirectInReg(Ty) :\n                       getNaturalAlignIndirect(Ty, false);\n}\n\nABIArgInfo ARCABIInfo::getIndirectByValue(QualType Ty) const {\n  // Compute the byval alignment.\n  const unsigned MinABIStackAlignInBytes = 4;\n  unsigned TypeAlign = getContext().getTypeAlign(Ty) / 8;\n  return ABIArgInfo::getIndirect(CharUnits::fromQuantity(4), /*ByVal=*/true,\n                                 TypeAlign > MinABIStackAlignInBytes);\n}\n\nAddress ARCABIInfo::EmitVAArg(CodeGenFunction &CGF, Address VAListAddr,\n                              QualType Ty) const {\n  return emitVoidPtrVAArg(CGF, VAListAddr, Ty, /*indirect*/ false,\n                          getContext().getTypeInfoInChars(Ty),\n                          CharUnits::fromQuantity(4), true);\n}\n\nABIArgInfo ARCABIInfo::classifyArgumentType(QualType Ty,\n                                            uint8_t FreeRegs) const {\n  // Handle the generic C++ ABI.\n  const RecordType *RT = Ty->getAs<RecordType>();\n  if (RT) {\n    CGCXXABI::RecordArgABI RAA = getRecordArgABI(RT, getCXXABI());\n    if (RAA == CGCXXABI::RAA_Indirect)\n      return getIndirectByRef(Ty, FreeRegs > 0);\n\n    if (RAA == CGCXXABI::RAA_DirectInMemory)\n      return getIndirectByValue(Ty);\n  }\n\n  // Treat an enum type as its underlying type.\n  if (const EnumType *EnumTy = Ty->getAs<EnumType>())\n    Ty = EnumTy->getDecl()->getIntegerType();\n\n  auto SizeInRegs = llvm::alignTo(getContext().getTypeSize(Ty), 32) / 32;\n\n  if (isAggregateTypeForABI(Ty)) {\n    // Structures with flexible arrays are always indirect.\n    if (RT && RT->getDecl()->hasFlexibleArrayMember())\n      return getIndirectByValue(Ty);\n\n    // Ignore empty structs/unions.\n    if (isEmptyRecord(getContext(), Ty, true))\n      return ABIArgInfo::getIgnore();\n\n    llvm::LLVMContext &LLVMContext = getVMContext();\n\n    llvm::IntegerType *Int32 = llvm::Type::getInt32Ty(LLVMContext);\n    SmallVector<llvm::Type *, 3> Elements(SizeInRegs, Int32);\n    llvm::Type *Result = llvm::StructType::get(LLVMContext, Elements);\n\n    return FreeRegs >= SizeInRegs ?\n        ABIArgInfo::getDirectInReg(Result) :\n        ABIArgInfo::getDirect(Result, 0, nullptr, false);\n  }\n\n  if (const auto *EIT = Ty->getAs<ExtIntType>())\n    if (EIT->getNumBits() > 64)\n      return getIndirectByValue(Ty);\n\n  return isPromotableIntegerTypeForABI(Ty)\n             ? (FreeRegs >= SizeInRegs ? ABIArgInfo::getExtendInReg(Ty)\n                                       : ABIArgInfo::getExtend(Ty))\n             : (FreeRegs >= SizeInRegs ? ABIArgInfo::getDirectInReg()\n                                       : ABIArgInfo::getDirect());\n}\n\nABIArgInfo ARCABIInfo::classifyReturnType(QualType RetTy) const {\n  if (RetTy->isAnyComplexType())\n    return ABIArgInfo::getDirectInReg();\n\n  // Arguments of size > 4 registers are indirect.\n  auto RetSize = llvm::alignTo(getContext().getTypeSize(RetTy), 32) / 32;\n  if (RetSize > 4)\n    return getIndirectByRef(RetTy, /*HasFreeRegs*/ true);\n\n  return DefaultABIInfo::classifyReturnType(RetTy);\n}\n\n} // End anonymous namespace.\n\n//===----------------------------------------------------------------------===//\n// XCore ABI Implementation\n//===----------------------------------------------------------------------===//\n\nnamespace {\n\n/// A SmallStringEnc instance is used to build up the TypeString by passing\n/// it by reference between functions that append to it.\ntypedef llvm::SmallString<128> SmallStringEnc;\n\n/// TypeStringCache caches the meta encodings of Types.\n///\n/// The reason for caching TypeStrings is two fold:\n///   1. To cache a type's encoding for later uses;\n///   2. As a means to break recursive member type inclusion.\n///\n/// A cache Entry can have a Status of:\n///   NonRecursive:   The type encoding is not recursive;\n///   Recursive:      The type encoding is recursive;\n///   Incomplete:     An incomplete TypeString;\n///   IncompleteUsed: An incomplete TypeString that has been used in a\n///                   Recursive type encoding.\n///\n/// A NonRecursive entry will have all of its sub-members expanded as fully\n/// as possible. Whilst it may contain types which are recursive, the type\n/// itself is not recursive and thus its encoding may be safely used whenever\n/// the type is encountered.\n///\n/// A Recursive entry will have all of its sub-members expanded as fully as\n/// possible. The type itself is recursive and it may contain other types which\n/// are recursive. The Recursive encoding must not be used during the expansion\n/// of a recursive type's recursive branch. For simplicity the code uses\n/// IncompleteCount to reject all usage of Recursive encodings for member types.\n///\n/// An Incomplete entry is always a RecordType and only encodes its\n/// identifier e.g. \"s(S){}\". Incomplete 'StubEnc' entries are ephemeral and\n/// are placed into the cache during type expansion as a means to identify and\n/// handle recursive inclusion of types as sub-members. If there is recursion\n/// the entry becomes IncompleteUsed.\n///\n/// During the expansion of a RecordType's members:\n///\n///   If the cache contains a NonRecursive encoding for the member type, the\n///   cached encoding is used;\n///\n///   If the cache contains a Recursive encoding for the member type, the\n///   cached encoding is 'Swapped' out, as it may be incorrect, and...\n///\n///   If the member is a RecordType, an Incomplete encoding is placed into the\n///   cache to break potential recursive inclusion of itself as a sub-member;\n///\n///   Once a member RecordType has been expanded, its temporary incomplete\n///   entry is removed from the cache. If a Recursive encoding was swapped out\n///   it is swapped back in;\n///\n///   If an incomplete entry is used to expand a sub-member, the incomplete\n///   entry is marked as IncompleteUsed. The cache keeps count of how many\n///   IncompleteUsed entries it currently contains in IncompleteUsedCount;\n///\n///   If a member's encoding is found to be a NonRecursive or Recursive viz:\n///   IncompleteUsedCount==0, the member's encoding is added to the cache.\n///   Else the member is part of a recursive type and thus the recursion has\n///   been exited too soon for the encoding to be correct for the member.\n///\nclass TypeStringCache {\n  enum Status {NonRecursive, Recursive, Incomplete, IncompleteUsed};\n  struct Entry {\n    std::string Str;     // The encoded TypeString for the type.\n    enum Status State;   // Information about the encoding in 'Str'.\n    std::string Swapped; // A temporary place holder for a Recursive encoding\n                         // during the expansion of RecordType's members.\n  };\n  std::map<const IdentifierInfo *, struct Entry> Map;\n  unsigned IncompleteCount;     // Number of Incomplete entries in the Map.\n  unsigned IncompleteUsedCount; // Number of IncompleteUsed entries in the Map.\npublic:\n  TypeStringCache() : IncompleteCount(0), IncompleteUsedCount(0) {}\n  void addIncomplete(const IdentifierInfo *ID, std::string StubEnc);\n  bool removeIncomplete(const IdentifierInfo *ID);\n  void addIfComplete(const IdentifierInfo *ID, StringRef Str,\n                     bool IsRecursive);\n  StringRef lookupStr(const IdentifierInfo *ID);\n};\n\n/// TypeString encodings for enum & union fields must be order.\n/// FieldEncoding is a helper for this ordering process.\nclass FieldEncoding {\n  bool HasName;\n  std::string Enc;\npublic:\n  FieldEncoding(bool b, SmallStringEnc &e) : HasName(b), Enc(e.c_str()) {}\n  StringRef str() { return Enc; }\n  bool operator<(const FieldEncoding &rhs) const {\n    if (HasName != rhs.HasName) return HasName;\n    return Enc < rhs.Enc;\n  }\n};\n\nclass XCoreABIInfo : public DefaultABIInfo {\npublic:\n  XCoreABIInfo(CodeGen::CodeGenTypes &CGT) : DefaultABIInfo(CGT) {}\n  Address EmitVAArg(CodeGenFunction &CGF, Address VAListAddr,\n                    QualType Ty) const override;\n};\n\nclass XCoreTargetCodeGenInfo : public TargetCodeGenInfo {\n  mutable TypeStringCache TSC;\n  void emitTargetMD(const Decl *D, llvm::GlobalValue *GV,\n                    const CodeGen::CodeGenModule &M) const;\n\npublic:\n  XCoreTargetCodeGenInfo(CodeGenTypes &CGT)\n      : TargetCodeGenInfo(std::make_unique<XCoreABIInfo>(CGT)) {}\n  void emitTargetMetadata(CodeGen::CodeGenModule &CGM,\n                          const llvm::MapVector<GlobalDecl, StringRef>\n                              &MangledDeclNames) const override;\n};\n\n} // End anonymous namespace.\n\n// TODO: this implementation is likely now redundant with the default\n// EmitVAArg.\nAddress XCoreABIInfo::EmitVAArg(CodeGenFunction &CGF, Address VAListAddr,\n                                QualType Ty) const {\n  CGBuilderTy &Builder = CGF.Builder;\n\n  // Get the VAList.\n  CharUnits SlotSize = CharUnits::fromQuantity(4);\n  Address AP(Builder.CreateLoad(VAListAddr), SlotSize);\n\n  // Handle the argument.\n  ABIArgInfo AI = classifyArgumentType(Ty);\n  CharUnits TypeAlign = getContext().getTypeAlignInChars(Ty);\n  llvm::Type *ArgTy = CGT.ConvertType(Ty);\n  if (AI.canHaveCoerceToType() && !AI.getCoerceToType())\n    AI.setCoerceToType(ArgTy);\n  llvm::Type *ArgPtrTy = llvm::PointerType::getUnqual(ArgTy);\n\n  Address Val = Address::invalid();\n  CharUnits ArgSize = CharUnits::Zero();\n  switch (AI.getKind()) {\n  case ABIArgInfo::Expand:\n  case ABIArgInfo::CoerceAndExpand:\n  case ABIArgInfo::InAlloca:\n    llvm_unreachable(\"Unsupported ABI kind for va_arg\");\n  case ABIArgInfo::Ignore:\n    Val = Address(llvm::UndefValue::get(ArgPtrTy), TypeAlign);\n    ArgSize = CharUnits::Zero();\n    break;\n  case ABIArgInfo::Extend:\n  case ABIArgInfo::Direct:\n    Val = Builder.CreateBitCast(AP, ArgPtrTy);\n    ArgSize = CharUnits::fromQuantity(\n                       getDataLayout().getTypeAllocSize(AI.getCoerceToType()));\n    ArgSize = ArgSize.alignTo(SlotSize);\n    break;\n  case ABIArgInfo::Indirect:\n  case ABIArgInfo::IndirectAliased:\n    Val = Builder.CreateElementBitCast(AP, ArgPtrTy);\n    Val = Address(Builder.CreateLoad(Val), TypeAlign);\n    ArgSize = SlotSize;\n    break;\n  }\n\n  // Increment the VAList.\n  if (!ArgSize.isZero()) {\n    Address APN = Builder.CreateConstInBoundsByteGEP(AP, ArgSize);\n    Builder.CreateStore(APN.getPointer(), VAListAddr);\n  }\n\n  return Val;\n}\n\n/// During the expansion of a RecordType, an incomplete TypeString is placed\n/// into the cache as a means to identify and break recursion.\n/// If there is a Recursive encoding in the cache, it is swapped out and will\n/// be reinserted by removeIncomplete().\n/// All other types of encoding should have been used rather than arriving here.\nvoid TypeStringCache::addIncomplete(const IdentifierInfo *ID,\n                                    std::string StubEnc) {\n  if (!ID)\n    return;\n  Entry &E = Map[ID];\n  assert( (E.Str.empty() || E.State == Recursive) &&\n         \"Incorrectly use of addIncomplete\");\n  assert(!StubEnc.empty() && \"Passing an empty string to addIncomplete()\");\n  E.Swapped.swap(E.Str); // swap out the Recursive\n  E.Str.swap(StubEnc);\n  E.State = Incomplete;\n  ++IncompleteCount;\n}\n\n/// Once the RecordType has been expanded, the temporary incomplete TypeString\n/// must be removed from the cache.\n/// If a Recursive was swapped out by addIncomplete(), it will be replaced.\n/// Returns true if the RecordType was defined recursively.\nbool TypeStringCache::removeIncomplete(const IdentifierInfo *ID) {\n  if (!ID)\n    return false;\n  auto I = Map.find(ID);\n  assert(I != Map.end() && \"Entry not present\");\n  Entry &E = I->second;\n  assert( (E.State == Incomplete ||\n           E.State == IncompleteUsed) &&\n         \"Entry must be an incomplete type\");\n  bool IsRecursive = false;\n  if (E.State == IncompleteUsed) {\n    // We made use of our Incomplete encoding, thus we are recursive.\n    IsRecursive = true;\n    --IncompleteUsedCount;\n  }\n  if (E.Swapped.empty())\n    Map.erase(I);\n  else {\n    // Swap the Recursive back.\n    E.Swapped.swap(E.Str);\n    E.Swapped.clear();\n    E.State = Recursive;\n  }\n  --IncompleteCount;\n  return IsRecursive;\n}\n\n/// Add the encoded TypeString to the cache only if it is NonRecursive or\n/// Recursive (viz: all sub-members were expanded as fully as possible).\nvoid TypeStringCache::addIfComplete(const IdentifierInfo *ID, StringRef Str,\n                                    bool IsRecursive) {\n  if (!ID || IncompleteUsedCount)\n    return; // No key or it is is an incomplete sub-type so don't add.\n  Entry &E = Map[ID];\n  if (IsRecursive && !E.Str.empty()) {\n    assert(E.State==Recursive && E.Str.size() == Str.size() &&\n           \"This is not the same Recursive entry\");\n    // The parent container was not recursive after all, so we could have used\n    // this Recursive sub-member entry after all, but we assumed the worse when\n    // we started viz: IncompleteCount!=0.\n    return;\n  }\n  assert(E.Str.empty() && \"Entry already present\");\n  E.Str = Str.str();\n  E.State = IsRecursive? Recursive : NonRecursive;\n}\n\n/// Return a cached TypeString encoding for the ID. If there isn't one, or we\n/// are recursively expanding a type (IncompleteCount != 0) and the cached\n/// encoding is Recursive, return an empty StringRef.\nStringRef TypeStringCache::lookupStr(const IdentifierInfo *ID) {\n  if (!ID)\n    return StringRef();   // We have no key.\n  auto I = Map.find(ID);\n  if (I == Map.end())\n    return StringRef();   // We have no encoding.\n  Entry &E = I->second;\n  if (E.State == Recursive && IncompleteCount)\n    return StringRef();   // We don't use Recursive encodings for member types.\n\n  if (E.State == Incomplete) {\n    // The incomplete type is being used to break out of recursion.\n    E.State = IncompleteUsed;\n    ++IncompleteUsedCount;\n  }\n  return E.Str;\n}\n\n/// The XCore ABI includes a type information section that communicates symbol\n/// type information to the linker. The linker uses this information to verify\n/// safety/correctness of things such as array bound and pointers et al.\n/// The ABI only requires C (and XC) language modules to emit TypeStrings.\n/// This type information (TypeString) is emitted into meta data for all global\n/// symbols: definitions, declarations, functions & variables.\n///\n/// The TypeString carries type, qualifier, name, size & value details.\n/// Please see 'Tools Development Guide' section 2.16.2 for format details:\n/// https://www.xmos.com/download/public/Tools-Development-Guide%28X9114A%29.pdf\n/// The output is tested by test/CodeGen/xcore-stringtype.c.\n///\nstatic bool getTypeString(SmallStringEnc &Enc, const Decl *D,\n                          const CodeGen::CodeGenModule &CGM,\n                          TypeStringCache &TSC);\n\n/// XCore uses emitTargetMD to emit TypeString metadata for global symbols.\nvoid XCoreTargetCodeGenInfo::emitTargetMD(\n    const Decl *D, llvm::GlobalValue *GV,\n    const CodeGen::CodeGenModule &CGM) const {\n  SmallStringEnc Enc;\n  if (getTypeString(Enc, D, CGM, TSC)) {\n    llvm::LLVMContext &Ctx = CGM.getModule().getContext();\n    llvm::Metadata *MDVals[] = {llvm::ConstantAsMetadata::get(GV),\n                                llvm::MDString::get(Ctx, Enc.str())};\n    llvm::NamedMDNode *MD =\n      CGM.getModule().getOrInsertNamedMetadata(\"xcore.typestrings\");\n    MD->addOperand(llvm::MDNode::get(Ctx, MDVals));\n  }\n}\n\nvoid XCoreTargetCodeGenInfo::emitTargetMetadata(\n    CodeGen::CodeGenModule &CGM,\n    const llvm::MapVector<GlobalDecl, StringRef> &MangledDeclNames) const {\n  // Warning, new MangledDeclNames may be appended within this loop.\n  // We rely on MapVector insertions adding new elements to the end\n  // of the container.\n  for (unsigned I = 0; I != MangledDeclNames.size(); ++I) {\n    auto Val = *(MangledDeclNames.begin() + I);\n    llvm::GlobalValue *GV = CGM.GetGlobalValue(Val.second);\n    if (GV) {\n      const Decl *D = Val.first.getDecl()->getMostRecentDecl();\n      emitTargetMD(D, GV, CGM);\n    }\n  }\n}\n//===----------------------------------------------------------------------===//\n// SPIR ABI Implementation\n//===----------------------------------------------------------------------===//\n\nnamespace {\nclass SPIRABIInfo : public DefaultABIInfo {\npublic:\n  SPIRABIInfo(CodeGenTypes &CGT) : DefaultABIInfo(CGT) { setCCs(); }\n\nprivate:\n  void setCCs();\n};\n} // end anonymous namespace\nnamespace {\nclass SPIRTargetCodeGenInfo : public TargetCodeGenInfo {\npublic:\n  SPIRTargetCodeGenInfo(CodeGen::CodeGenTypes &CGT)\n      : TargetCodeGenInfo(std::make_unique<SPIRABIInfo>(CGT)) {}\n  unsigned getOpenCLKernelCallingConv() const override;\n};\n\n} // End anonymous namespace.\nvoid SPIRABIInfo::setCCs() {\n  assert(getRuntimeCC() == llvm::CallingConv::C);\n  RuntimeCC = llvm::CallingConv::SPIR_FUNC;\n}\n\nnamespace clang {\nnamespace CodeGen {\nvoid computeSPIRKernelABIInfo(CodeGenModule &CGM, CGFunctionInfo &FI) {\n  DefaultABIInfo SPIRABI(CGM.getTypes());\n  SPIRABI.computeInfo(FI);\n}\n}\n}\n\nunsigned SPIRTargetCodeGenInfo::getOpenCLKernelCallingConv() const {\n  return llvm::CallingConv::SPIR_KERNEL;\n}\n\nstatic bool appendType(SmallStringEnc &Enc, QualType QType,\n                       const CodeGen::CodeGenModule &CGM,\n                       TypeStringCache &TSC);\n\n/// Helper function for appendRecordType().\n/// Builds a SmallVector containing the encoded field types in declaration\n/// order.\nstatic bool extractFieldType(SmallVectorImpl<FieldEncoding> &FE,\n                             const RecordDecl *RD,\n                             const CodeGen::CodeGenModule &CGM,\n                             TypeStringCache &TSC) {\n  for (const auto *Field : RD->fields()) {\n    SmallStringEnc Enc;\n    Enc += \"m(\";\n    Enc += Field->getName();\n    Enc += \"){\";\n    if (Field->isBitField()) {\n      Enc += \"b(\";\n      llvm::raw_svector_ostream OS(Enc);\n      OS << Field->getBitWidthValue(CGM.getContext());\n      Enc += ':';\n    }\n    if (!appendType(Enc, Field->getType(), CGM, TSC))\n      return false;\n    if (Field->isBitField())\n      Enc += ')';\n    Enc += '}';\n    FE.emplace_back(!Field->getName().empty(), Enc);\n  }\n  return true;\n}\n\n/// Appends structure and union types to Enc and adds encoding to cache.\n/// Recursively calls appendType (via extractFieldType) for each field.\n/// Union types have their fields ordered according to the ABI.\nstatic bool appendRecordType(SmallStringEnc &Enc, const RecordType *RT,\n                             const CodeGen::CodeGenModule &CGM,\n                             TypeStringCache &TSC, const IdentifierInfo *ID) {\n  // Append the cached TypeString if we have one.\n  StringRef TypeString = TSC.lookupStr(ID);\n  if (!TypeString.empty()) {\n    Enc += TypeString;\n    return true;\n  }\n\n  // Start to emit an incomplete TypeString.\n  size_t Start = Enc.size();\n  Enc += (RT->isUnionType()? 'u' : 's');\n  Enc += '(';\n  if (ID)\n    Enc += ID->getName();\n  Enc += \"){\";\n\n  // We collect all encoded fields and order as necessary.\n  bool IsRecursive = false;\n  const RecordDecl *RD = RT->getDecl()->getDefinition();\n  if (RD && !RD->field_empty()) {\n    // An incomplete TypeString stub is placed in the cache for this RecordType\n    // so that recursive calls to this RecordType will use it whilst building a\n    // complete TypeString for this RecordType.\n    SmallVector<FieldEncoding, 16> FE;\n    std::string StubEnc(Enc.substr(Start).str());\n    StubEnc += '}';  // StubEnc now holds a valid incomplete TypeString.\n    TSC.addIncomplete(ID, std::move(StubEnc));\n    if (!extractFieldType(FE, RD, CGM, TSC)) {\n      (void) TSC.removeIncomplete(ID);\n      return false;\n    }\n    IsRecursive = TSC.removeIncomplete(ID);\n    // The ABI requires unions to be sorted but not structures.\n    // See FieldEncoding::operator< for sort algorithm.\n    if (RT->isUnionType())\n      llvm::sort(FE);\n    // We can now complete the TypeString.\n    unsigned E = FE.size();\n    for (unsigned I = 0; I != E; ++I) {\n      if (I)\n        Enc += ',';\n      Enc += FE[I].str();\n    }\n  }\n  Enc += '}';\n  TSC.addIfComplete(ID, Enc.substr(Start), IsRecursive);\n  return true;\n}\n\n/// Appends enum types to Enc and adds the encoding to the cache.\nstatic bool appendEnumType(SmallStringEnc &Enc, const EnumType *ET,\n                           TypeStringCache &TSC,\n                           const IdentifierInfo *ID) {\n  // Append the cached TypeString if we have one.\n  StringRef TypeString = TSC.lookupStr(ID);\n  if (!TypeString.empty()) {\n    Enc += TypeString;\n    return true;\n  }\n\n  size_t Start = Enc.size();\n  Enc += \"e(\";\n  if (ID)\n    Enc += ID->getName();\n  Enc += \"){\";\n\n  // We collect all encoded enumerations and order them alphanumerically.\n  if (const EnumDecl *ED = ET->getDecl()->getDefinition()) {\n    SmallVector<FieldEncoding, 16> FE;\n    for (auto I = ED->enumerator_begin(), E = ED->enumerator_end(); I != E;\n         ++I) {\n      SmallStringEnc EnumEnc;\n      EnumEnc += \"m(\";\n      EnumEnc += I->getName();\n      EnumEnc += \"){\";\n      I->getInitVal().toString(EnumEnc);\n      EnumEnc += '}';\n      FE.push_back(FieldEncoding(!I->getName().empty(), EnumEnc));\n    }\n    llvm::sort(FE);\n    unsigned E = FE.size();\n    for (unsigned I = 0; I != E; ++I) {\n      if (I)\n        Enc += ',';\n      Enc += FE[I].str();\n    }\n  }\n  Enc += '}';\n  TSC.addIfComplete(ID, Enc.substr(Start), false);\n  return true;\n}\n\n/// Appends type's qualifier to Enc.\n/// This is done prior to appending the type's encoding.\nstatic void appendQualifier(SmallStringEnc &Enc, QualType QT) {\n  // Qualifiers are emitted in alphabetical order.\n  static const char *const Table[]={\"\",\"c:\",\"r:\",\"cr:\",\"v:\",\"cv:\",\"rv:\",\"crv:\"};\n  int Lookup = 0;\n  if (QT.isConstQualified())\n    Lookup += 1<<0;\n  if (QT.isRestrictQualified())\n    Lookup += 1<<1;\n  if (QT.isVolatileQualified())\n    Lookup += 1<<2;\n  Enc += Table[Lookup];\n}\n\n/// Appends built-in types to Enc.\nstatic bool appendBuiltinType(SmallStringEnc &Enc, const BuiltinType *BT) {\n  const char *EncType;\n  switch (BT->getKind()) {\n    case BuiltinType::Void:\n      EncType = \"0\";\n      break;\n    case BuiltinType::Bool:\n      EncType = \"b\";\n      break;\n    case BuiltinType::Char_U:\n      EncType = \"uc\";\n      break;\n    case BuiltinType::UChar:\n      EncType = \"uc\";\n      break;\n    case BuiltinType::SChar:\n      EncType = \"sc\";\n      break;\n    case BuiltinType::UShort:\n      EncType = \"us\";\n      break;\n    case BuiltinType::Short:\n      EncType = \"ss\";\n      break;\n    case BuiltinType::UInt:\n      EncType = \"ui\";\n      break;\n    case BuiltinType::Int:\n      EncType = \"si\";\n      break;\n    case BuiltinType::ULong:\n      EncType = \"ul\";\n      break;\n    case BuiltinType::Long:\n      EncType = \"sl\";\n      break;\n    case BuiltinType::ULongLong:\n      EncType = \"ull\";\n      break;\n    case BuiltinType::LongLong:\n      EncType = \"sll\";\n      break;\n    case BuiltinType::Float:\n      EncType = \"ft\";\n      break;\n    case BuiltinType::Double:\n      EncType = \"d\";\n      break;\n    case BuiltinType::LongDouble:\n      EncType = \"ld\";\n      break;\n    default:\n      return false;\n  }\n  Enc += EncType;\n  return true;\n}\n\n/// Appends a pointer encoding to Enc before calling appendType for the pointee.\nstatic bool appendPointerType(SmallStringEnc &Enc, const PointerType *PT,\n                              const CodeGen::CodeGenModule &CGM,\n                              TypeStringCache &TSC) {\n  Enc += \"p(\";\n  if (!appendType(Enc, PT->getPointeeType(), CGM, TSC))\n    return false;\n  Enc += ')';\n  return true;\n}\n\n/// Appends array encoding to Enc before calling appendType for the element.\nstatic bool appendArrayType(SmallStringEnc &Enc, QualType QT,\n                            const ArrayType *AT,\n                            const CodeGen::CodeGenModule &CGM,\n                            TypeStringCache &TSC, StringRef NoSizeEnc) {\n  if (AT->getSizeModifier() != ArrayType::Normal)\n    return false;\n  Enc += \"a(\";\n  if (const ConstantArrayType *CAT = dyn_cast<ConstantArrayType>(AT))\n    CAT->getSize().toStringUnsigned(Enc);\n  else\n    Enc += NoSizeEnc; // Global arrays use \"*\", otherwise it is \"\".\n  Enc += ':';\n  // The Qualifiers should be attached to the type rather than the array.\n  appendQualifier(Enc, QT);\n  if (!appendType(Enc, AT->getElementType(), CGM, TSC))\n    return false;\n  Enc += ')';\n  return true;\n}\n\n/// Appends a function encoding to Enc, calling appendType for the return type\n/// and the arguments.\nstatic bool appendFunctionType(SmallStringEnc &Enc, const FunctionType *FT,\n                             const CodeGen::CodeGenModule &CGM,\n                             TypeStringCache &TSC) {\n  Enc += \"f{\";\n  if (!appendType(Enc, FT->getReturnType(), CGM, TSC))\n    return false;\n  Enc += \"}(\";\n  if (const FunctionProtoType *FPT = FT->getAs<FunctionProtoType>()) {\n    // N.B. we are only interested in the adjusted param types.\n    auto I = FPT->param_type_begin();\n    auto E = FPT->param_type_end();\n    if (I != E) {\n      do {\n        if (!appendType(Enc, *I, CGM, TSC))\n          return false;\n        ++I;\n        if (I != E)\n          Enc += ',';\n      } while (I != E);\n      if (FPT->isVariadic())\n        Enc += \",va\";\n    } else {\n      if (FPT->isVariadic())\n        Enc += \"va\";\n      else\n        Enc += '0';\n    }\n  }\n  Enc += ')';\n  return true;\n}\n\n/// Handles the type's qualifier before dispatching a call to handle specific\n/// type encodings.\nstatic bool appendType(SmallStringEnc &Enc, QualType QType,\n                       const CodeGen::CodeGenModule &CGM,\n                       TypeStringCache &TSC) {\n\n  QualType QT = QType.getCanonicalType();\n\n  if (const ArrayType *AT = QT->getAsArrayTypeUnsafe())\n    // The Qualifiers should be attached to the type rather than the array.\n    // Thus we don't call appendQualifier() here.\n    return appendArrayType(Enc, QT, AT, CGM, TSC, \"\");\n\n  appendQualifier(Enc, QT);\n\n  if (const BuiltinType *BT = QT->getAs<BuiltinType>())\n    return appendBuiltinType(Enc, BT);\n\n  if (const PointerType *PT = QT->getAs<PointerType>())\n    return appendPointerType(Enc, PT, CGM, TSC);\n\n  if (const EnumType *ET = QT->getAs<EnumType>())\n    return appendEnumType(Enc, ET, TSC, QT.getBaseTypeIdentifier());\n\n  if (const RecordType *RT = QT->getAsStructureType())\n    return appendRecordType(Enc, RT, CGM, TSC, QT.getBaseTypeIdentifier());\n\n  if (const RecordType *RT = QT->getAsUnionType())\n    return appendRecordType(Enc, RT, CGM, TSC, QT.getBaseTypeIdentifier());\n\n  if (const FunctionType *FT = QT->getAs<FunctionType>())\n    return appendFunctionType(Enc, FT, CGM, TSC);\n\n  return false;\n}\n\nstatic bool getTypeString(SmallStringEnc &Enc, const Decl *D,\n                          const CodeGen::CodeGenModule &CGM,\n                          TypeStringCache &TSC) {\n  if (!D)\n    return false;\n\n  if (const FunctionDecl *FD = dyn_cast<FunctionDecl>(D)) {\n    if (FD->getLanguageLinkage() != CLanguageLinkage)\n      return false;\n    return appendType(Enc, FD->getType(), CGM, TSC);\n  }\n\n  if (const VarDecl *VD = dyn_cast<VarDecl>(D)) {\n    if (VD->getLanguageLinkage() != CLanguageLinkage)\n      return false;\n    QualType QT = VD->getType().getCanonicalType();\n    if (const ArrayType *AT = QT->getAsArrayTypeUnsafe()) {\n      // Global ArrayTypes are given a size of '*' if the size is unknown.\n      // The Qualifiers should be attached to the type rather than the array.\n      // Thus we don't call appendQualifier() here.\n      return appendArrayType(Enc, QT, AT, CGM, TSC, \"*\");\n    }\n    return appendType(Enc, QT, CGM, TSC);\n  }\n  return false;\n}\n\n//===----------------------------------------------------------------------===//\n// RISCV ABI Implementation\n//===----------------------------------------------------------------------===//\n\nnamespace {\nclass RISCVABIInfo : public DefaultABIInfo {\nprivate:\n  // Size of the integer ('x') registers in bits.\n  unsigned XLen;\n  // Size of the floating point ('f') registers in bits. Note that the target\n  // ISA might have a wider FLen than the selected ABI (e.g. an RV32IF target\n  // with soft float ABI has FLen==0).\n  unsigned FLen;\n  static const int NumArgGPRs = 8;\n  static const int NumArgFPRs = 8;\n  bool detectFPCCEligibleStructHelper(QualType Ty, CharUnits CurOff,\n                                      llvm::Type *&Field1Ty,\n                                      CharUnits &Field1Off,\n                                      llvm::Type *&Field2Ty,\n                                      CharUnits &Field2Off) const;\n\npublic:\n  RISCVABIInfo(CodeGen::CodeGenTypes &CGT, unsigned XLen, unsigned FLen)\n      : DefaultABIInfo(CGT), XLen(XLen), FLen(FLen) {}\n\n  // DefaultABIInfo's classifyReturnType and classifyArgumentType are\n  // non-virtual, but computeInfo is virtual, so we overload it.\n  void computeInfo(CGFunctionInfo &FI) const override;\n\n  ABIArgInfo classifyArgumentType(QualType Ty, bool IsFixed, int &ArgGPRsLeft,\n                                  int &ArgFPRsLeft) const;\n  ABIArgInfo classifyReturnType(QualType RetTy) const;\n\n  Address EmitVAArg(CodeGenFunction &CGF, Address VAListAddr,\n                    QualType Ty) const override;\n\n  ABIArgInfo extendType(QualType Ty) const;\n\n  bool detectFPCCEligibleStruct(QualType Ty, llvm::Type *&Field1Ty,\n                                CharUnits &Field1Off, llvm::Type *&Field2Ty,\n                                CharUnits &Field2Off, int &NeededArgGPRs,\n                                int &NeededArgFPRs) const;\n  ABIArgInfo coerceAndExpandFPCCEligibleStruct(llvm::Type *Field1Ty,\n                                               CharUnits Field1Off,\n                                               llvm::Type *Field2Ty,\n                                               CharUnits Field2Off) const;\n};\n} // end anonymous namespace\n\nvoid RISCVABIInfo::computeInfo(CGFunctionInfo &FI) const {\n  QualType RetTy = FI.getReturnType();\n  if (!getCXXABI().classifyReturnType(FI))\n    FI.getReturnInfo() = classifyReturnType(RetTy);\n\n  // IsRetIndirect is true if classifyArgumentType indicated the value should\n  // be passed indirect, or if the type size is a scalar greater than 2*XLen\n  // and not a complex type with elements <= FLen. e.g. fp128 is passed direct\n  // in LLVM IR, relying on the backend lowering code to rewrite the argument\n  // list and pass indirectly on RV32.\n  bool IsRetIndirect = FI.getReturnInfo().getKind() == ABIArgInfo::Indirect;\n  if (!IsRetIndirect && RetTy->isScalarType() &&\n      getContext().getTypeSize(RetTy) > (2 * XLen)) {\n    if (RetTy->isComplexType() && FLen) {\n      QualType EltTy = RetTy->castAs<ComplexType>()->getElementType();\n      IsRetIndirect = getContext().getTypeSize(EltTy) > FLen;\n    } else {\n      // This is a normal scalar > 2*XLen, such as fp128 on RV32.\n      IsRetIndirect = true;\n    }\n  }\n\n  // We must track the number of GPRs used in order to conform to the RISC-V\n  // ABI, as integer scalars passed in registers should have signext/zeroext\n  // when promoted, but are anyext if passed on the stack. As GPR usage is\n  // different for variadic arguments, we must also track whether we are\n  // examining a vararg or not.\n  int ArgGPRsLeft = IsRetIndirect ? NumArgGPRs - 1 : NumArgGPRs;\n  int ArgFPRsLeft = FLen ? NumArgFPRs : 0;\n  int NumFixedArgs = FI.getNumRequiredArgs();\n\n  int ArgNum = 0;\n  for (auto &ArgInfo : FI.arguments()) {\n    bool IsFixed = ArgNum < NumFixedArgs;\n    ArgInfo.info =\n        classifyArgumentType(ArgInfo.type, IsFixed, ArgGPRsLeft, ArgFPRsLeft);\n    ArgNum++;\n  }\n}\n\n// Returns true if the struct is a potential candidate for the floating point\n// calling convention. If this function returns true, the caller is\n// responsible for checking that if there is only a single field then that\n// field is a float.\nbool RISCVABIInfo::detectFPCCEligibleStructHelper(QualType Ty, CharUnits CurOff,\n                                                  llvm::Type *&Field1Ty,\n                                                  CharUnits &Field1Off,\n                                                  llvm::Type *&Field2Ty,\n                                                  CharUnits &Field2Off) const {\n  bool IsInt = Ty->isIntegralOrEnumerationType();\n  bool IsFloat = Ty->isRealFloatingType();\n\n  if (IsInt || IsFloat) {\n    uint64_t Size = getContext().getTypeSize(Ty);\n    if (IsInt && Size > XLen)\n      return false;\n    // Can't be eligible if larger than the FP registers. Half precision isn't\n    // currently supported on RISC-V and the ABI hasn't been confirmed, so\n    // default to the integer ABI in that case.\n    if (IsFloat && (Size > FLen || Size < 32))\n      return false;\n    // Can't be eligible if an integer type was already found (int+int pairs\n    // are not eligible).\n    if (IsInt && Field1Ty && Field1Ty->isIntegerTy())\n      return false;\n    if (!Field1Ty) {\n      Field1Ty = CGT.ConvertType(Ty);\n      Field1Off = CurOff;\n      return true;\n    }\n    if (!Field2Ty) {\n      Field2Ty = CGT.ConvertType(Ty);\n      Field2Off = CurOff;\n      return true;\n    }\n    return false;\n  }\n\n  if (auto CTy = Ty->getAs<ComplexType>()) {\n    if (Field1Ty)\n      return false;\n    QualType EltTy = CTy->getElementType();\n    if (getContext().getTypeSize(EltTy) > FLen)\n      return false;\n    Field1Ty = CGT.ConvertType(EltTy);\n    Field1Off = CurOff;\n    Field2Ty = Field1Ty;\n    Field2Off = Field1Off + getContext().getTypeSizeInChars(EltTy);\n    return true;\n  }\n\n  if (const ConstantArrayType *ATy = getContext().getAsConstantArrayType(Ty)) {\n    uint64_t ArraySize = ATy->getSize().getZExtValue();\n    QualType EltTy = ATy->getElementType();\n    CharUnits EltSize = getContext().getTypeSizeInChars(EltTy);\n    for (uint64_t i = 0; i < ArraySize; ++i) {\n      bool Ret = detectFPCCEligibleStructHelper(EltTy, CurOff, Field1Ty,\n                                                Field1Off, Field2Ty, Field2Off);\n      if (!Ret)\n        return false;\n      CurOff += EltSize;\n    }\n    return true;\n  }\n\n  if (const auto *RTy = Ty->getAs<RecordType>()) {\n    // Structures with either a non-trivial destructor or a non-trivial\n    // copy constructor are not eligible for the FP calling convention.\n    if (getRecordArgABI(Ty, CGT.getCXXABI()))\n      return false;\n    if (isEmptyRecord(getContext(), Ty, true))\n      return true;\n    const RecordDecl *RD = RTy->getDecl();\n    // Unions aren't eligible unless they're empty (which is caught above).\n    if (RD->isUnion())\n      return false;\n    int ZeroWidthBitFieldCount = 0;\n    for (const FieldDecl *FD : RD->fields()) {\n      const ASTRecordLayout &Layout = getContext().getASTRecordLayout(RD);\n      uint64_t FieldOffInBits = Layout.getFieldOffset(FD->getFieldIndex());\n      QualType QTy = FD->getType();\n      if (FD->isBitField()) {\n        unsigned BitWidth = FD->getBitWidthValue(getContext());\n        // Allow a bitfield with a type greater than XLen as long as the\n        // bitwidth is XLen or less.\n        if (getContext().getTypeSize(QTy) > XLen && BitWidth <= XLen)\n          QTy = getContext().getIntTypeForBitwidth(XLen, false);\n        if (BitWidth == 0) {\n          ZeroWidthBitFieldCount++;\n          continue;\n        }\n      }\n\n      bool Ret = detectFPCCEligibleStructHelper(\n          QTy, CurOff + getContext().toCharUnitsFromBits(FieldOffInBits),\n          Field1Ty, Field1Off, Field2Ty, Field2Off);\n      if (!Ret)\n        return false;\n\n      // As a quirk of the ABI, zero-width bitfields aren't ignored for fp+fp\n      // or int+fp structs, but are ignored for a struct with an fp field and\n      // any number of zero-width bitfields.\n      if (Field2Ty && ZeroWidthBitFieldCount > 0)\n        return false;\n    }\n    return Field1Ty != nullptr;\n  }\n\n  return false;\n}\n\n// Determine if a struct is eligible for passing according to the floating\n// point calling convention (i.e., when flattened it contains a single fp\n// value, fp+fp, or int+fp of appropriate size). If so, NeededArgFPRs and\n// NeededArgGPRs are incremented appropriately.\nbool RISCVABIInfo::detectFPCCEligibleStruct(QualType Ty, llvm::Type *&Field1Ty,\n                                            CharUnits &Field1Off,\n                                            llvm::Type *&Field2Ty,\n                                            CharUnits &Field2Off,\n                                            int &NeededArgGPRs,\n                                            int &NeededArgFPRs) const {\n  Field1Ty = nullptr;\n  Field2Ty = nullptr;\n  NeededArgGPRs = 0;\n  NeededArgFPRs = 0;\n  bool IsCandidate = detectFPCCEligibleStructHelper(\n      Ty, CharUnits::Zero(), Field1Ty, Field1Off, Field2Ty, Field2Off);\n  // Not really a candidate if we have a single int but no float.\n  if (Field1Ty && !Field2Ty && !Field1Ty->isFloatingPointTy())\n    return false;\n  if (!IsCandidate)\n    return false;\n  if (Field1Ty && Field1Ty->isFloatingPointTy())\n    NeededArgFPRs++;\n  else if (Field1Ty)\n    NeededArgGPRs++;\n  if (Field2Ty && Field2Ty->isFloatingPointTy())\n    NeededArgFPRs++;\n  else if (Field2Ty)\n    NeededArgGPRs++;\n  return true;\n}\n\n// Call getCoerceAndExpand for the two-element flattened struct described by\n// Field1Ty, Field1Off, Field2Ty, Field2Off. This method will create an\n// appropriate coerceToType and unpaddedCoerceToType.\nABIArgInfo RISCVABIInfo::coerceAndExpandFPCCEligibleStruct(\n    llvm::Type *Field1Ty, CharUnits Field1Off, llvm::Type *Field2Ty,\n    CharUnits Field2Off) const {\n  SmallVector<llvm::Type *, 3> CoerceElts;\n  SmallVector<llvm::Type *, 2> UnpaddedCoerceElts;\n  if (!Field1Off.isZero())\n    CoerceElts.push_back(llvm::ArrayType::get(\n        llvm::Type::getInt8Ty(getVMContext()), Field1Off.getQuantity()));\n\n  CoerceElts.push_back(Field1Ty);\n  UnpaddedCoerceElts.push_back(Field1Ty);\n\n  if (!Field2Ty) {\n    return ABIArgInfo::getCoerceAndExpand(\n        llvm::StructType::get(getVMContext(), CoerceElts, !Field1Off.isZero()),\n        UnpaddedCoerceElts[0]);\n  }\n\n  CharUnits Field2Align =\n      CharUnits::fromQuantity(getDataLayout().getABITypeAlignment(Field2Ty));\n  CharUnits Field1End = Field1Off +\n      CharUnits::fromQuantity(getDataLayout().getTypeStoreSize(Field1Ty));\n  CharUnits Field2OffNoPadNoPack = Field1End.alignTo(Field2Align);\n\n  CharUnits Padding = CharUnits::Zero();\n  if (Field2Off > Field2OffNoPadNoPack)\n    Padding = Field2Off - Field2OffNoPadNoPack;\n  else if (Field2Off != Field2Align && Field2Off > Field1End)\n    Padding = Field2Off - Field1End;\n\n  bool IsPacked = !Field2Off.isMultipleOf(Field2Align);\n\n  if (!Padding.isZero())\n    CoerceElts.push_back(llvm::ArrayType::get(\n        llvm::Type::getInt8Ty(getVMContext()), Padding.getQuantity()));\n\n  CoerceElts.push_back(Field2Ty);\n  UnpaddedCoerceElts.push_back(Field2Ty);\n\n  auto CoerceToType =\n      llvm::StructType::get(getVMContext(), CoerceElts, IsPacked);\n  auto UnpaddedCoerceToType =\n      llvm::StructType::get(getVMContext(), UnpaddedCoerceElts, IsPacked);\n\n  return ABIArgInfo::getCoerceAndExpand(CoerceToType, UnpaddedCoerceToType);\n}\n\nABIArgInfo RISCVABIInfo::classifyArgumentType(QualType Ty, bool IsFixed,\n                                              int &ArgGPRsLeft,\n                                              int &ArgFPRsLeft) const {\n  assert(ArgGPRsLeft <= NumArgGPRs && \"Arg GPR tracking underflow\");\n  Ty = useFirstFieldIfTransparentUnion(Ty);\n\n  // Structures with either a non-trivial destructor or a non-trivial\n  // copy constructor are always passed indirectly.\n  if (CGCXXABI::RecordArgABI RAA = getRecordArgABI(Ty, getCXXABI())) {\n    if (ArgGPRsLeft)\n      ArgGPRsLeft -= 1;\n    return getNaturalAlignIndirect(Ty, /*ByVal=*/RAA ==\n                                           CGCXXABI::RAA_DirectInMemory);\n  }\n\n  // Ignore empty structs/unions.\n  if (isEmptyRecord(getContext(), Ty, true))\n    return ABIArgInfo::getIgnore();\n\n  uint64_t Size = getContext().getTypeSize(Ty);\n\n  // Pass floating point values via FPRs if possible.\n  if (IsFixed && Ty->isFloatingType() && !Ty->isComplexType() &&\n      FLen >= Size && ArgFPRsLeft) {\n    ArgFPRsLeft--;\n    return ABIArgInfo::getDirect();\n  }\n\n  // Complex types for the hard float ABI must be passed direct rather than\n  // using CoerceAndExpand.\n  if (IsFixed && Ty->isComplexType() && FLen && ArgFPRsLeft >= 2) {\n    QualType EltTy = Ty->castAs<ComplexType>()->getElementType();\n    if (getContext().getTypeSize(EltTy) <= FLen) {\n      ArgFPRsLeft -= 2;\n      return ABIArgInfo::getDirect();\n    }\n  }\n\n  if (IsFixed && FLen && Ty->isStructureOrClassType()) {\n    llvm::Type *Field1Ty = nullptr;\n    llvm::Type *Field2Ty = nullptr;\n    CharUnits Field1Off = CharUnits::Zero();\n    CharUnits Field2Off = CharUnits::Zero();\n    int NeededArgGPRs;\n    int NeededArgFPRs;\n    bool IsCandidate =\n        detectFPCCEligibleStruct(Ty, Field1Ty, Field1Off, Field2Ty, Field2Off,\n                                 NeededArgGPRs, NeededArgFPRs);\n    if (IsCandidate && NeededArgGPRs <= ArgGPRsLeft &&\n        NeededArgFPRs <= ArgFPRsLeft) {\n      ArgGPRsLeft -= NeededArgGPRs;\n      ArgFPRsLeft -= NeededArgFPRs;\n      return coerceAndExpandFPCCEligibleStruct(Field1Ty, Field1Off, Field2Ty,\n                                               Field2Off);\n    }\n  }\n\n  uint64_t NeededAlign = getContext().getTypeAlign(Ty);\n  bool MustUseStack = false;\n  // Determine the number of GPRs needed to pass the current argument\n  // according to the ABI. 2*XLen-aligned varargs are passed in \"aligned\"\n  // register pairs, so may consume 3 registers.\n  int NeededArgGPRs = 1;\n  if (!IsFixed && NeededAlign == 2 * XLen)\n    NeededArgGPRs = 2 + (ArgGPRsLeft % 2);\n  else if (Size > XLen && Size <= 2 * XLen)\n    NeededArgGPRs = 2;\n\n  if (NeededArgGPRs > ArgGPRsLeft) {\n    MustUseStack = true;\n    NeededArgGPRs = ArgGPRsLeft;\n  }\n\n  ArgGPRsLeft -= NeededArgGPRs;\n\n  if (!isAggregateTypeForABI(Ty) && !Ty->isVectorType()) {\n    // Treat an enum type as its underlying type.\n    if (const EnumType *EnumTy = Ty->getAs<EnumType>())\n      Ty = EnumTy->getDecl()->getIntegerType();\n\n    // All integral types are promoted to XLen width, unless passed on the\n    // stack.\n    if (Size < XLen && Ty->isIntegralOrEnumerationType() && !MustUseStack) {\n      return extendType(Ty);\n    }\n\n    if (const auto *EIT = Ty->getAs<ExtIntType>()) {\n      if (EIT->getNumBits() < XLen && !MustUseStack)\n        return extendType(Ty);\n      if (EIT->getNumBits() > 128 ||\n          (!getContext().getTargetInfo().hasInt128Type() &&\n           EIT->getNumBits() > 64))\n        return getNaturalAlignIndirect(Ty, /*ByVal=*/false);\n    }\n\n    return ABIArgInfo::getDirect();\n  }\n\n  // Aggregates which are <= 2*XLen will be passed in registers if possible,\n  // so coerce to integers.\n  if (Size <= 2 * XLen) {\n    unsigned Alignment = getContext().getTypeAlign(Ty);\n\n    // Use a single XLen int if possible, 2*XLen if 2*XLen alignment is\n    // required, and a 2-element XLen array if only XLen alignment is required.\n    if (Size <= XLen) {\n      return ABIArgInfo::getDirect(\n          llvm::IntegerType::get(getVMContext(), XLen));\n    } else if (Alignment == 2 * XLen) {\n      return ABIArgInfo::getDirect(\n          llvm::IntegerType::get(getVMContext(), 2 * XLen));\n    } else {\n      return ABIArgInfo::getDirect(llvm::ArrayType::get(\n          llvm::IntegerType::get(getVMContext(), XLen), 2));\n    }\n  }\n  return getNaturalAlignIndirect(Ty, /*ByVal=*/false);\n}\n\nABIArgInfo RISCVABIInfo::classifyReturnType(QualType RetTy) const {\n  if (RetTy->isVoidType())\n    return ABIArgInfo::getIgnore();\n\n  int ArgGPRsLeft = 2;\n  int ArgFPRsLeft = FLen ? 2 : 0;\n\n  // The rules for return and argument types are the same, so defer to\n  // classifyArgumentType.\n  return classifyArgumentType(RetTy, /*IsFixed=*/true, ArgGPRsLeft,\n                              ArgFPRsLeft);\n}\n\nAddress RISCVABIInfo::EmitVAArg(CodeGenFunction &CGF, Address VAListAddr,\n                                QualType Ty) const {\n  CharUnits SlotSize = CharUnits::fromQuantity(XLen / 8);\n\n  // Empty records are ignored for parameter passing purposes.\n  if (isEmptyRecord(getContext(), Ty, true)) {\n    Address Addr(CGF.Builder.CreateLoad(VAListAddr), SlotSize);\n    Addr = CGF.Builder.CreateElementBitCast(Addr, CGF.ConvertTypeForMem(Ty));\n    return Addr;\n  }\n\n  auto TInfo = getContext().getTypeInfoInChars(Ty);\n\n  // Arguments bigger than 2*Xlen bytes are passed indirectly.\n  bool IsIndirect = TInfo.Width > 2 * SlotSize;\n\n  return emitVoidPtrVAArg(CGF, VAListAddr, Ty, IsIndirect, TInfo,\n                          SlotSize, /*AllowHigherAlign=*/true);\n}\n\nABIArgInfo RISCVABIInfo::extendType(QualType Ty) const {\n  int TySize = getContext().getTypeSize(Ty);\n  // RV64 ABI requires unsigned 32 bit integers to be sign extended.\n  if (XLen == 64 && Ty->isUnsignedIntegerOrEnumerationType() && TySize == 32)\n    return ABIArgInfo::getSignExtend(Ty);\n  return ABIArgInfo::getExtend(Ty);\n}\n\nnamespace {\nclass RISCVTargetCodeGenInfo : public TargetCodeGenInfo {\npublic:\n  RISCVTargetCodeGenInfo(CodeGen::CodeGenTypes &CGT, unsigned XLen,\n                         unsigned FLen)\n      : TargetCodeGenInfo(std::make_unique<RISCVABIInfo>(CGT, XLen, FLen)) {}\n\n  void setTargetAttributes(const Decl *D, llvm::GlobalValue *GV,\n                           CodeGen::CodeGenModule &CGM) const override {\n    const auto *FD = dyn_cast_or_null<FunctionDecl>(D);\n    if (!FD) return;\n\n    const auto *Attr = FD->getAttr<RISCVInterruptAttr>();\n    if (!Attr)\n      return;\n\n    const char *Kind;\n    switch (Attr->getInterrupt()) {\n    case RISCVInterruptAttr::user: Kind = \"user\"; break;\n    case RISCVInterruptAttr::supervisor: Kind = \"supervisor\"; break;\n    case RISCVInterruptAttr::machine: Kind = \"machine\"; break;\n    }\n\n    auto *Fn = cast<llvm::Function>(GV);\n\n    Fn->addFnAttr(\"interrupt\", Kind);\n  }\n};\n} // namespace\n\n//===----------------------------------------------------------------------===//\n// VE ABI Implementation.\n//\nnamespace {\nclass VEABIInfo : public DefaultABIInfo {\npublic:\n  VEABIInfo(CodeGenTypes &CGT) : DefaultABIInfo(CGT) {}\n\nprivate:\n  ABIArgInfo classifyReturnType(QualType RetTy) const;\n  ABIArgInfo classifyArgumentType(QualType RetTy) const;\n  void computeInfo(CGFunctionInfo &FI) const override;\n};\n} // end anonymous namespace\n\nABIArgInfo VEABIInfo::classifyReturnType(QualType Ty) const {\n  if (Ty->isAnyComplexType())\n    return ABIArgInfo::getDirect();\n  uint64_t Size = getContext().getTypeSize(Ty);\n  if (Size < 64 && Ty->isIntegerType())\n    return ABIArgInfo::getExtend(Ty);\n  return DefaultABIInfo::classifyReturnType(Ty);\n}\n\nABIArgInfo VEABIInfo::classifyArgumentType(QualType Ty) const {\n  if (Ty->isAnyComplexType())\n    return ABIArgInfo::getDirect();\n  uint64_t Size = getContext().getTypeSize(Ty);\n  if (Size < 64 && Ty->isIntegerType())\n    return ABIArgInfo::getExtend(Ty);\n  return DefaultABIInfo::classifyArgumentType(Ty);\n}\n\nvoid VEABIInfo::computeInfo(CGFunctionInfo &FI) const {\n  FI.getReturnInfo() = classifyReturnType(FI.getReturnType());\n  for (auto &Arg : FI.arguments())\n    Arg.info = classifyArgumentType(Arg.type);\n}\n\nnamespace {\nclass VETargetCodeGenInfo : public TargetCodeGenInfo {\npublic:\n  VETargetCodeGenInfo(CodeGenTypes &CGT)\n      : TargetCodeGenInfo(std::make_unique<VEABIInfo>(CGT)) {}\n  // VE ABI requires the arguments of variadic and prototype-less functions\n  // are passed in both registers and memory.\n  bool isNoProtoCallVariadic(const CallArgList &args,\n                             const FunctionNoProtoType *fnType) const override {\n    return true;\n  }\n};\n} // end anonymous namespace\n\n//===----------------------------------------------------------------------===//\n// Driver code\n//===----------------------------------------------------------------------===//\n\nbool CodeGenModule::supportsCOMDAT() const {\n  return getTriple().supportsCOMDAT();\n}\n\nconst TargetCodeGenInfo &CodeGenModule::getTargetCodeGenInfo() {\n  if (TheTargetCodeGenInfo)\n    return *TheTargetCodeGenInfo;\n\n  // Helper to set the unique_ptr while still keeping the return value.\n  auto SetCGInfo = [&](TargetCodeGenInfo *P) -> const TargetCodeGenInfo & {\n    this->TheTargetCodeGenInfo.reset(P);\n    return *P;\n  };\n\n  const llvm::Triple &Triple = getTarget().getTriple();\n  switch (Triple.getArch()) {\n  default:\n    return SetCGInfo(new DefaultTargetCodeGenInfo(Types));\n\n  case llvm::Triple::le32:\n    return SetCGInfo(new PNaClTargetCodeGenInfo(Types));\n  case llvm::Triple::mips:\n  case llvm::Triple::mipsel:\n    if (Triple.getOS() == llvm::Triple::NaCl)\n      return SetCGInfo(new PNaClTargetCodeGenInfo(Types));\n    return SetCGInfo(new MIPSTargetCodeGenInfo(Types, true));\n\n  case llvm::Triple::mips64:\n  case llvm::Triple::mips64el:\n    return SetCGInfo(new MIPSTargetCodeGenInfo(Types, false));\n\n  case llvm::Triple::avr:\n    return SetCGInfo(new AVRTargetCodeGenInfo(Types));\n\n  case llvm::Triple::aarch64:\n  case llvm::Triple::aarch64_32:\n  case llvm::Triple::aarch64_be: {\n    AArch64ABIInfo::ABIKind Kind = AArch64ABIInfo::AAPCS;\n    if (getTarget().getABI() == \"darwinpcs\")\n      Kind = AArch64ABIInfo::DarwinPCS;\n    else if (Triple.isOSWindows())\n      return SetCGInfo(\n          new WindowsAArch64TargetCodeGenInfo(Types, AArch64ABIInfo::Win64));\n\n    return SetCGInfo(new AArch64TargetCodeGenInfo(Types, Kind));\n  }\n\n  case llvm::Triple::wasm32:\n  case llvm::Triple::wasm64: {\n    WebAssemblyABIInfo::ABIKind Kind = WebAssemblyABIInfo::MVP;\n    if (getTarget().getABI() == \"experimental-mv\")\n      Kind = WebAssemblyABIInfo::ExperimentalMV;\n    return SetCGInfo(new WebAssemblyTargetCodeGenInfo(Types, Kind));\n  }\n\n  case llvm::Triple::arm:\n  case llvm::Triple::armeb:\n  case llvm::Triple::thumb:\n  case llvm::Triple::thumbeb: {\n    if (Triple.getOS() == llvm::Triple::Win32) {\n      return SetCGInfo(\n          new WindowsARMTargetCodeGenInfo(Types, ARMABIInfo::AAPCS_VFP));\n    }\n\n    ARMABIInfo::ABIKind Kind = ARMABIInfo::AAPCS;\n    StringRef ABIStr = getTarget().getABI();\n    if (ABIStr == \"apcs-gnu\")\n      Kind = ARMABIInfo::APCS;\n    else if (ABIStr == \"aapcs16\")\n      Kind = ARMABIInfo::AAPCS16_VFP;\n    else if (CodeGenOpts.FloatABI == \"hard\" ||\n             (CodeGenOpts.FloatABI != \"soft\" &&\n              (Triple.getEnvironment() == llvm::Triple::GNUEABIHF ||\n               Triple.getEnvironment() == llvm::Triple::MuslEABIHF ||\n               Triple.getEnvironment() == llvm::Triple::EABIHF)))\n      Kind = ARMABIInfo::AAPCS_VFP;\n\n    return SetCGInfo(new ARMTargetCodeGenInfo(Types, Kind));\n  }\n\n  case llvm::Triple::ppc: {\n    if (Triple.isOSAIX())\n      return SetCGInfo(new AIXTargetCodeGenInfo(Types, /*Is64Bit*/ false));\n\n    bool IsSoftFloat =\n        CodeGenOpts.FloatABI == \"soft\" || getTarget().hasFeature(\"spe\");\n    bool RetSmallStructInRegABI =\n        PPC32TargetCodeGenInfo::isStructReturnInRegABI(Triple, CodeGenOpts);\n    return SetCGInfo(\n        new PPC32TargetCodeGenInfo(Types, IsSoftFloat, RetSmallStructInRegABI));\n  }\n  case llvm::Triple::ppcle: {\n    bool IsSoftFloat = CodeGenOpts.FloatABI == \"soft\";\n    bool RetSmallStructInRegABI =\n        PPC32TargetCodeGenInfo::isStructReturnInRegABI(Triple, CodeGenOpts);\n    return SetCGInfo(\n        new PPC32TargetCodeGenInfo(Types, IsSoftFloat, RetSmallStructInRegABI));\n  }\n  case llvm::Triple::ppc64:\n    if (Triple.isOSAIX())\n      return SetCGInfo(new AIXTargetCodeGenInfo(Types, /*Is64Bit*/ true));\n\n    if (Triple.isOSBinFormatELF()) {\n      PPC64_SVR4_ABIInfo::ABIKind Kind = PPC64_SVR4_ABIInfo::ELFv1;\n      if (getTarget().getABI() == \"elfv2\")\n        Kind = PPC64_SVR4_ABIInfo::ELFv2;\n      bool IsSoftFloat = CodeGenOpts.FloatABI == \"soft\";\n\n      return SetCGInfo(\n          new PPC64_SVR4_TargetCodeGenInfo(Types, Kind, IsSoftFloat));\n    }\n    return SetCGInfo(new PPC64TargetCodeGenInfo(Types));\n  case llvm::Triple::ppc64le: {\n    assert(Triple.isOSBinFormatELF() && \"PPC64 LE non-ELF not supported!\");\n    PPC64_SVR4_ABIInfo::ABIKind Kind = PPC64_SVR4_ABIInfo::ELFv2;\n    if (getTarget().getABI() == \"elfv1\")\n      Kind = PPC64_SVR4_ABIInfo::ELFv1;\n    bool IsSoftFloat = CodeGenOpts.FloatABI == \"soft\";\n\n    return SetCGInfo(\n        new PPC64_SVR4_TargetCodeGenInfo(Types, Kind, IsSoftFloat));\n  }\n\n  case llvm::Triple::nvptx:\n  case llvm::Triple::nvptx64:\n    return SetCGInfo(new NVPTXTargetCodeGenInfo(Types));\n\n  case llvm::Triple::msp430:\n    return SetCGInfo(new MSP430TargetCodeGenInfo(Types));\n\n  case llvm::Triple::riscv32:\n  case llvm::Triple::riscv64: {\n    StringRef ABIStr = getTarget().getABI();\n    unsigned XLen = getTarget().getPointerWidth(0);\n    unsigned ABIFLen = 0;\n    if (ABIStr.endswith(\"f\"))\n      ABIFLen = 32;\n    else if (ABIStr.endswith(\"d\"))\n      ABIFLen = 64;\n    return SetCGInfo(new RISCVTargetCodeGenInfo(Types, XLen, ABIFLen));\n  }\n\n  case llvm::Triple::systemz: {\n    bool SoftFloat = CodeGenOpts.FloatABI == \"soft\";\n    bool HasVector = !SoftFloat && getTarget().getABI() == \"vector\";\n    return SetCGInfo(new SystemZTargetCodeGenInfo(Types, HasVector, SoftFloat));\n  }\n\n  case llvm::Triple::tce:\n  case llvm::Triple::tcele:\n    return SetCGInfo(new TCETargetCodeGenInfo(Types));\n\n  case llvm::Triple::x86: {\n    bool IsDarwinVectorABI = Triple.isOSDarwin();\n    bool RetSmallStructInRegABI =\n        X86_32TargetCodeGenInfo::isStructReturnInRegABI(Triple, CodeGenOpts);\n    bool IsWin32FloatStructABI = Triple.isOSWindows() && !Triple.isOSCygMing();\n\n    if (Triple.getOS() == llvm::Triple::Win32) {\n      return SetCGInfo(new WinX86_32TargetCodeGenInfo(\n          Types, IsDarwinVectorABI, RetSmallStructInRegABI,\n          IsWin32FloatStructABI, CodeGenOpts.NumRegisterParameters));\n    } else {\n      return SetCGInfo(new X86_32TargetCodeGenInfo(\n          Types, IsDarwinVectorABI, RetSmallStructInRegABI,\n          IsWin32FloatStructABI, CodeGenOpts.NumRegisterParameters,\n          CodeGenOpts.FloatABI == \"soft\"));\n    }\n  }\n\n  case llvm::Triple::x86_64: {\n    StringRef ABI = getTarget().getABI();\n    X86AVXABILevel AVXLevel =\n        (ABI == \"avx512\"\n             ? X86AVXABILevel::AVX512\n             : ABI == \"avx\" ? X86AVXABILevel::AVX : X86AVXABILevel::None);\n\n    switch (Triple.getOS()) {\n    case llvm::Triple::Win32:\n      return SetCGInfo(new WinX86_64TargetCodeGenInfo(Types, AVXLevel));\n    default:\n      return SetCGInfo(new X86_64TargetCodeGenInfo(Types, AVXLevel));\n    }\n  }\n  case llvm::Triple::hexagon:\n    return SetCGInfo(new HexagonTargetCodeGenInfo(Types));\n  case llvm::Triple::lanai:\n    return SetCGInfo(new LanaiTargetCodeGenInfo(Types));\n  case llvm::Triple::r600:\n    return SetCGInfo(new AMDGPUTargetCodeGenInfo(Types));\n  case llvm::Triple::amdgcn:\n    return SetCGInfo(new AMDGPUTargetCodeGenInfo(Types));\n  case llvm::Triple::sparc:\n    return SetCGInfo(new SparcV8TargetCodeGenInfo(Types));\n  case llvm::Triple::sparcv9:\n    return SetCGInfo(new SparcV9TargetCodeGenInfo(Types));\n  case llvm::Triple::xcore:\n    return SetCGInfo(new XCoreTargetCodeGenInfo(Types));\n  case llvm::Triple::arc:\n    return SetCGInfo(new ARCTargetCodeGenInfo(Types));\n  case llvm::Triple::spir:\n  case llvm::Triple::spir64:\n    return SetCGInfo(new SPIRTargetCodeGenInfo(Types));\n  case llvm::Triple::ve:\n    return SetCGInfo(new VETargetCodeGenInfo(Types));\n  }\n}\n\n/// Create an OpenCL kernel for an enqueued block.\n///\n/// The kernel has the same function type as the block invoke function. Its\n/// name is the name of the block invoke function postfixed with \"_kernel\".\n/// It simply calls the block invoke function then returns.\nllvm::Function *\nTargetCodeGenInfo::createEnqueuedBlockKernel(CodeGenFunction &CGF,\n                                             llvm::Function *Invoke,\n                                             llvm::Value *BlockLiteral) const {\n  auto *InvokeFT = Invoke->getFunctionType();\n  llvm::SmallVector<llvm::Type *, 2> ArgTys;\n  for (auto &P : InvokeFT->params())\n    ArgTys.push_back(P);\n  auto &C = CGF.getLLVMContext();\n  std::string Name = Invoke->getName().str() + \"_kernel\";\n  auto *FT = llvm::FunctionType::get(llvm::Type::getVoidTy(C), ArgTys, false);\n  auto *F = llvm::Function::Create(FT, llvm::GlobalValue::InternalLinkage, Name,\n                                   &CGF.CGM.getModule());\n  auto IP = CGF.Builder.saveIP();\n  auto *BB = llvm::BasicBlock::Create(C, \"entry\", F);\n  auto &Builder = CGF.Builder;\n  Builder.SetInsertPoint(BB);\n  llvm::SmallVector<llvm::Value *, 2> Args;\n  for (auto &A : F->args())\n    Args.push_back(&A);\n  llvm::CallInst *call = Builder.CreateCall(Invoke, Args);\n  call->setCallingConv(Invoke->getCallingConv());\n  Builder.CreateRetVoid();\n  Builder.restoreIP(IP);\n  return F;\n}\n\n/// Create an OpenCL kernel for an enqueued block.\n///\n/// The type of the first argument (the block literal) is the struct type\n/// of the block literal instead of a pointer type. The first argument\n/// (block literal) is passed directly by value to the kernel. The kernel\n/// allocates the same type of struct on stack and stores the block literal\n/// to it and passes its pointer to the block invoke function. The kernel\n/// has \"enqueued-block\" function attribute and kernel argument metadata.\nllvm::Function *AMDGPUTargetCodeGenInfo::createEnqueuedBlockKernel(\n    CodeGenFunction &CGF, llvm::Function *Invoke,\n    llvm::Value *BlockLiteral) const {\n  auto &Builder = CGF.Builder;\n  auto &C = CGF.getLLVMContext();\n\n  auto *BlockTy = BlockLiteral->getType()->getPointerElementType();\n  auto *InvokeFT = Invoke->getFunctionType();\n  llvm::SmallVector<llvm::Type *, 2> ArgTys;\n  llvm::SmallVector<llvm::Metadata *, 8> AddressQuals;\n  llvm::SmallVector<llvm::Metadata *, 8> AccessQuals;\n  llvm::SmallVector<llvm::Metadata *, 8> ArgTypeNames;\n  llvm::SmallVector<llvm::Metadata *, 8> ArgBaseTypeNames;\n  llvm::SmallVector<llvm::Metadata *, 8> ArgTypeQuals;\n  llvm::SmallVector<llvm::Metadata *, 8> ArgNames;\n\n  ArgTys.push_back(BlockTy);\n  ArgTypeNames.push_back(llvm::MDString::get(C, \"__block_literal\"));\n  AddressQuals.push_back(llvm::ConstantAsMetadata::get(Builder.getInt32(0)));\n  ArgBaseTypeNames.push_back(llvm::MDString::get(C, \"__block_literal\"));\n  ArgTypeQuals.push_back(llvm::MDString::get(C, \"\"));\n  AccessQuals.push_back(llvm::MDString::get(C, \"none\"));\n  ArgNames.push_back(llvm::MDString::get(C, \"block_literal\"));\n  for (unsigned I = 1, E = InvokeFT->getNumParams(); I < E; ++I) {\n    ArgTys.push_back(InvokeFT->getParamType(I));\n    ArgTypeNames.push_back(llvm::MDString::get(C, \"void*\"));\n    AddressQuals.push_back(llvm::ConstantAsMetadata::get(Builder.getInt32(3)));\n    AccessQuals.push_back(llvm::MDString::get(C, \"none\"));\n    ArgBaseTypeNames.push_back(llvm::MDString::get(C, \"void*\"));\n    ArgTypeQuals.push_back(llvm::MDString::get(C, \"\"));\n    ArgNames.push_back(\n        llvm::MDString::get(C, (Twine(\"local_arg\") + Twine(I)).str()));\n  }\n  std::string Name = Invoke->getName().str() + \"_kernel\";\n  auto *FT = llvm::FunctionType::get(llvm::Type::getVoidTy(C), ArgTys, false);\n  auto *F = llvm::Function::Create(FT, llvm::GlobalValue::InternalLinkage, Name,\n                                   &CGF.CGM.getModule());\n  F->addFnAttr(\"enqueued-block\");\n  auto IP = CGF.Builder.saveIP();\n  auto *BB = llvm::BasicBlock::Create(C, \"entry\", F);\n  Builder.SetInsertPoint(BB);\n  const auto BlockAlign = CGF.CGM.getDataLayout().getPrefTypeAlign(BlockTy);\n  auto *BlockPtr = Builder.CreateAlloca(BlockTy, nullptr);\n  BlockPtr->setAlignment(BlockAlign);\n  Builder.CreateAlignedStore(F->arg_begin(), BlockPtr, BlockAlign);\n  auto *Cast = Builder.CreatePointerCast(BlockPtr, InvokeFT->getParamType(0));\n  llvm::SmallVector<llvm::Value *, 2> Args;\n  Args.push_back(Cast);\n  for (auto I = F->arg_begin() + 1, E = F->arg_end(); I != E; ++I)\n    Args.push_back(I);\n  llvm::CallInst *call = Builder.CreateCall(Invoke, Args);\n  call->setCallingConv(Invoke->getCallingConv());\n  Builder.CreateRetVoid();\n  Builder.restoreIP(IP);\n\n  F->setMetadata(\"kernel_arg_addr_space\", llvm::MDNode::get(C, AddressQuals));\n  F->setMetadata(\"kernel_arg_access_qual\", llvm::MDNode::get(C, AccessQuals));\n  F->setMetadata(\"kernel_arg_type\", llvm::MDNode::get(C, ArgTypeNames));\n  F->setMetadata(\"kernel_arg_base_type\",\n                 llvm::MDNode::get(C, ArgBaseTypeNames));\n  F->setMetadata(\"kernel_arg_type_qual\", llvm::MDNode::get(C, ArgTypeQuals));\n  if (CGF.CGM.getCodeGenOpts().EmitOpenCLArgMetadata)\n    F->setMetadata(\"kernel_arg_name\", llvm::MDNode::get(C, ArgNames));\n\n  return F;\n}\n"}}, "reports": [{"events": [{"location": {"col": 26, "file": 0, "line": 5177}, "message": "the definition seen here"}, {"location": {"col": 8, "file": 0, "line": 4892}, "message": "differing parameters are named here: ('Ty'), in definition: ('Base')"}, {"location": {"col": 8, "file": 0, "line": 4892}, "message": "function '(anonymous namespace)::PPC64_SVR4_ABIInfo::isHomogeneousAggregateSmallEnough' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/TargetInfo.cpp", "reportHash": "72e1e753fe39d2447191977c28b0e3c5", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 0, "line": 5831}, "message": "the definition seen here"}, {"location": {"col": 8, "file": 0, "line": 5419}, "message": "differing parameters are named here: ('Ty'), in definition: ('Base')"}, {"location": {"col": 8, "file": 0, "line": 5419}, "message": "function '(anonymous namespace)::AArch64ABIInfo::isHomogeneousAggregateSmallEnough' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/TargetInfo.cpp", "reportHash": "90650a5f52693e107b7780b1108ceb78", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 0, "line": 6810}, "message": "the definition seen here"}, {"location": {"col": 8, "file": 0, "line": 6196}, "message": "differing parameters are named here: ('Ty'), in definition: ('Base')"}, {"location": {"col": 8, "file": 0, "line": 6196}, "message": "function '(anonymous namespace)::ARMABIInfo::isHomogeneousAggregateSmallEnough' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/TargetInfo.cpp", "reportHash": "4f97efbbf0d076da11547d4ad18d3754", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 0, "line": 6780}, "message": "the definition seen here"}, {"location": {"col": 8, "file": 0, "line": 6217}, "message": "differing parameters are named here: ('totalSize'), in definition: ('vectorSize')"}, {"location": {"col": 8, "file": 0, "line": 6217}, "message": "function '(anonymous namespace)::ARMABIInfo::isLegalVectorTypeForSwift' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/TargetInfo.cpp", "reportHash": "fb2ea6c242660d60c83259440f9d1f25", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 0, "line": 7802}, "message": "the definition seen here"}, {"location": {"col": 15, "file": 0, "line": 7646}, "message": "differing parameters are named here: ('Align'), in definition: ('OrigOffset')"}, {"location": {"col": 15, "file": 0, "line": 7646}, "message": "function '(anonymous namespace)::MipsABIInfo::getPaddingType' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/TargetInfo.cpp", "reportHash": "1030be8b93bec24ed85039c6d8dbab69", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 25, "file": 0, "line": 8316}, "message": "the definition seen here"}, {"location": {"col": 11, "file": 0, "line": 8166}, "message": "differing parameters are named here: ('CFG'), in definition: ('CGF')"}, {"location": {"col": 11, "file": 0, "line": 8166}, "message": "function '(anonymous namespace)::HexagonABIInfo::EmitVAArgFromMemory' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/TargetInfo.cpp", "reportHash": "5ac24c4baa0d4479479b0d1f0d0c37a6", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 25, "file": 0, "line": 8365}, "message": "the definition seen here"}, {"location": {"col": 11, "file": 0, "line": 8168}, "message": "differing parameters are named here: ('CFG'), in definition: ('CGF')"}, {"location": {"col": 11, "file": 0, "line": 8168}, "message": "function '(anonymous namespace)::HexagonABIInfo::EmitVAArgForHexagon' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/TargetInfo.cpp", "reportHash": "7e98ec272cbad580ad8c3c34d581a641", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 25, "file": 0, "line": 8395}, "message": "the definition seen here"}, {"location": {"col": 11, "file": 0, "line": 8170}, "message": "differing parameters are named here: ('CFG'), in definition: ('CGF')"}, {"location": {"col": 11, "file": 0, "line": 8170}, "message": "function '(anonymous namespace)::HexagonABIInfo::EmitVAArgForHexagonLinux' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/TargetInfo.cpp", "reportHash": "47a9da57371cfe9f5d7fd00e0d8d198b", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 42, "file": 0, "line": 11110}, "message": "the definition seen here"}, {"location": {"col": 3, "file": 0, "line": 8956}, "message": "differing parameters are named here: ('BlockInvokeFunc'), in definition: ('Invoke')"}, {"location": {"col": 3, "file": 0, "line": 8956}, "message": "function '(anonymous namespace)::AMDGPUTargetCodeGenInfo::createEnqueuedBlockKernel' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/TargetInfo.cpp", "reportHash": "531487eb94c7accc2640bc28907c9912", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
