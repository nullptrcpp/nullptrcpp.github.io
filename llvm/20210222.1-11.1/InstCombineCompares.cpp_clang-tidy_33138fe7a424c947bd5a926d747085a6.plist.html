<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"4": {"id": 4, "path": "/home/vsts/work/1/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp", "content": "//===- InstCombineCompares.cpp --------------------------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file implements the visitICmp and visitFCmp functions.\n//\n//===----------------------------------------------------------------------===//\n\n#include \"InstCombineInternal.h\"\n#include \"llvm/ADT/APSInt.h\"\n#include \"llvm/ADT/SetVector.h\"\n#include \"llvm/ADT/Statistic.h\"\n#include \"llvm/Analysis/ConstantFolding.h\"\n#include \"llvm/Analysis/InstructionSimplify.h\"\n#include \"llvm/Analysis/TargetLibraryInfo.h\"\n#include \"llvm/IR/ConstantRange.h\"\n#include \"llvm/IR/DataLayout.h\"\n#include \"llvm/IR/GetElementPtrTypeIterator.h\"\n#include \"llvm/IR/IntrinsicInst.h\"\n#include \"llvm/IR/PatternMatch.h\"\n#include \"llvm/Support/Debug.h\"\n#include \"llvm/Support/KnownBits.h\"\n#include \"llvm/Transforms/InstCombine/InstCombiner.h\"\n\nusing namespace llvm;\nusing namespace PatternMatch;\n\n#define DEBUG_TYPE \"instcombine\"\n\n// How many times is a select replaced by one of its operands?\nSTATISTIC(NumSel, \"Number of select opts\");\n\n\n/// Compute Result = In1+In2, returning true if the result overflowed for this\n/// type.\nstatic bool addWithOverflow(APInt &Result, const APInt &In1,\n                            const APInt &In2, bool IsSigned = false) {\n  bool Overflow;\n  if (IsSigned)\n    Result = In1.sadd_ov(In2, Overflow);\n  else\n    Result = In1.uadd_ov(In2, Overflow);\n\n  return Overflow;\n}\n\n/// Compute Result = In1-In2, returning true if the result overflowed for this\n/// type.\nstatic bool subWithOverflow(APInt &Result, const APInt &In1,\n                            const APInt &In2, bool IsSigned = false) {\n  bool Overflow;\n  if (IsSigned)\n    Result = In1.ssub_ov(In2, Overflow);\n  else\n    Result = In1.usub_ov(In2, Overflow);\n\n  return Overflow;\n}\n\n/// Given an icmp instruction, return true if any use of this comparison is a\n/// branch on sign bit comparison.\nstatic bool hasBranchUse(ICmpInst &I) {\n  for (auto *U : I.users())\n    if (isa<BranchInst>(U))\n      return true;\n  return false;\n}\n\n/// Returns true if the exploded icmp can be expressed as a signed comparison\n/// to zero and updates the predicate accordingly.\n/// The signedness of the comparison is preserved.\n/// TODO: Refactor with decomposeBitTestICmp()?\nstatic bool isSignTest(ICmpInst::Predicate &Pred, const APInt &C) {\n  if (!ICmpInst::isSigned(Pred))\n    return false;\n\n  if (C.isNullValue())\n    return ICmpInst::isRelational(Pred);\n\n  if (C.isOneValue()) {\n    if (Pred == ICmpInst::ICMP_SLT) {\n      Pred = ICmpInst::ICMP_SLE;\n      return true;\n    }\n  } else if (C.isAllOnesValue()) {\n    if (Pred == ICmpInst::ICMP_SGT) {\n      Pred = ICmpInst::ICMP_SGE;\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/// This is called when we see this pattern:\n///   cmp pred (load (gep GV, ...)), cmpcst\n/// where GV is a global variable with a constant initializer. Try to simplify\n/// this into some simple computation that does not need the load. For example\n/// we can optimize \"icmp eq (load (gep \"foo\", 0, i)), 0\" into \"icmp eq i, 3\".\n///\n/// If AndCst is non-null, then the loaded value is masked with that constant\n/// before doing the comparison. This handles cases like \"A[i]&4 == 0\".\nInstruction *\nInstCombinerImpl::foldCmpLoadFromIndexedGlobal(GetElementPtrInst *GEP,\n                                               GlobalVariable *GV, CmpInst &ICI,\n                                               ConstantInt *AndCst) {\n  Constant *Init = GV->getInitializer();\n  if (!isa<ConstantArray>(Init) && !isa<ConstantDataArray>(Init))\n    return nullptr;\n\n  uint64_t ArrayElementCount = Init->getType()->getArrayNumElements();\n  // Don't blow up on huge arrays.\n  if (ArrayElementCount > MaxArraySizeForCombine)\n    return nullptr;\n\n  // There are many forms of this optimization we can handle, for now, just do\n  // the simple index into a single-dimensional array.\n  //\n  // Require: GEP GV, 0, i {{, constant indices}}\n  if (GEP->getNumOperands() < 3 ||\n      !isa<ConstantInt>(GEP->getOperand(1)) ||\n      !cast<ConstantInt>(GEP->getOperand(1))->isZero() ||\n      isa<Constant>(GEP->getOperand(2)))\n    return nullptr;\n\n  // Check that indices after the variable are constants and in-range for the\n  // type they index.  Collect the indices.  This is typically for arrays of\n  // structs.\n  SmallVector<unsigned, 4> LaterIndices;\n\n  Type *EltTy = Init->getType()->getArrayElementType();\n  for (unsigned i = 3, e = GEP->getNumOperands(); i != e; ++i) {\n    ConstantInt *Idx = dyn_cast<ConstantInt>(GEP->getOperand(i));\n    if (!Idx) return nullptr;  // Variable index.\n\n    uint64_t IdxVal = Idx->getZExtValue();\n    if ((unsigned)IdxVal != IdxVal) return nullptr; // Too large array index.\n\n    if (StructType *STy = dyn_cast<StructType>(EltTy))\n      EltTy = STy->getElementType(IdxVal);\n    else if (ArrayType *ATy = dyn_cast<ArrayType>(EltTy)) {\n      if (IdxVal >= ATy->getNumElements()) return nullptr;\n      EltTy = ATy->getElementType();\n    } else {\n      return nullptr; // Unknown type.\n    }\n\n    LaterIndices.push_back(IdxVal);\n  }\n\n  enum { Overdefined = -3, Undefined = -2 };\n\n  // Variables for our state machines.\n\n  // FirstTrueElement/SecondTrueElement - Used to emit a comparison of the form\n  // \"i == 47 | i == 87\", where 47 is the first index the condition is true for,\n  // and 87 is the second (and last) index.  FirstTrueElement is -2 when\n  // undefined, otherwise set to the first true element.  SecondTrueElement is\n  // -2 when undefined, -3 when overdefined and >= 0 when that index is true.\n  int FirstTrueElement = Undefined, SecondTrueElement = Undefined;\n\n  // FirstFalseElement/SecondFalseElement - Used to emit a comparison of the\n  // form \"i != 47 & i != 87\".  Same state transitions as for true elements.\n  int FirstFalseElement = Undefined, SecondFalseElement = Undefined;\n\n  /// TrueRangeEnd/FalseRangeEnd - In conjunction with First*Element, these\n  /// define a state machine that triggers for ranges of values that the index\n  /// is true or false for.  This triggers on things like \"abbbbc\"[i] == 'b'.\n  /// This is -2 when undefined, -3 when overdefined, and otherwise the last\n  /// index in the range (inclusive).  We use -2 for undefined here because we\n  /// use relative comparisons and don't want 0-1 to match -1.\n  int TrueRangeEnd = Undefined, FalseRangeEnd = Undefined;\n\n  // MagicBitvector - This is a magic bitvector where we set a bit if the\n  // comparison is true for element 'i'.  If there are 64 elements or less in\n  // the array, this will fully represent all the comparison results.\n  uint64_t MagicBitvector = 0;\n\n  // Scan the array and see if one of our patterns matches.\n  Constant *CompareRHS = cast<Constant>(ICI.getOperand(1));\n  for (unsigned i = 0, e = ArrayElementCount; i != e; ++i) {\n    Constant *Elt = Init->getAggregateElement(i);\n    if (!Elt) return nullptr;\n\n    // If this is indexing an array of structures, get the structure element.\n    if (!LaterIndices.empty())\n      Elt = ConstantExpr::getExtractValue(Elt, LaterIndices);\n\n    // If the element is masked, handle it.\n    if (AndCst) Elt = ConstantExpr::getAnd(Elt, AndCst);\n\n    // Find out if the comparison would be true or false for the i'th element.\n    Constant *C = ConstantFoldCompareInstOperands(ICI.getPredicate(), Elt,\n                                                  CompareRHS, DL, &TLI);\n    // If the result is undef for this element, ignore it.\n    if (isa<UndefValue>(C)) {\n      // Extend range state machines to cover this element in case there is an\n      // undef in the middle of the range.\n      if (TrueRangeEnd == (int)i-1)\n        TrueRangeEnd = i;\n      if (FalseRangeEnd == (int)i-1)\n        FalseRangeEnd = i;\n      continue;\n    }\n\n    // If we can't compute the result for any of the elements, we have to give\n    // up evaluating the entire conditional.\n    if (!isa<ConstantInt>(C)) return nullptr;\n\n    // Otherwise, we know if the comparison is true or false for this element,\n    // update our state machines.\n    bool IsTrueForElt = !cast<ConstantInt>(C)->isZero();\n\n    // State machine for single/double/range index comparison.\n    if (IsTrueForElt) {\n      // Update the TrueElement state machine.\n      if (FirstTrueElement == Undefined)\n        FirstTrueElement = TrueRangeEnd = i;  // First true element.\n      else {\n        // Update double-compare state machine.\n        if (SecondTrueElement == Undefined)\n          SecondTrueElement = i;\n        else\n          SecondTrueElement = Overdefined;\n\n        // Update range state machine.\n        if (TrueRangeEnd == (int)i-1)\n          TrueRangeEnd = i;\n        else\n          TrueRangeEnd = Overdefined;\n      }\n    } else {\n      // Update the FalseElement state machine.\n      if (FirstFalseElement == Undefined)\n        FirstFalseElement = FalseRangeEnd = i; // First false element.\n      else {\n        // Update double-compare state machine.\n        if (SecondFalseElement == Undefined)\n          SecondFalseElement = i;\n        else\n          SecondFalseElement = Overdefined;\n\n        // Update range state machine.\n        if (FalseRangeEnd == (int)i-1)\n          FalseRangeEnd = i;\n        else\n          FalseRangeEnd = Overdefined;\n      }\n    }\n\n    // If this element is in range, update our magic bitvector.\n    if (i < 64 && IsTrueForElt)\n      MagicBitvector |= 1ULL << i;\n\n    // If all of our states become overdefined, bail out early.  Since the\n    // predicate is expensive, only check it every 8 elements.  This is only\n    // really useful for really huge arrays.\n    if ((i & 8) == 0 && i >= 64 && SecondTrueElement == Overdefined &&\n        SecondFalseElement == Overdefined && TrueRangeEnd == Overdefined &&\n        FalseRangeEnd == Overdefined)\n      return nullptr;\n  }\n\n  // Now that we've scanned the entire array, emit our new comparison(s).  We\n  // order the state machines in complexity of the generated code.\n  Value *Idx = GEP->getOperand(2);\n\n  // If the index is larger than the pointer size of the target, truncate the\n  // index down like the GEP would do implicitly.  We don't have to do this for\n  // an inbounds GEP because the index can't be out of range.\n  if (!GEP->isInBounds()) {\n    Type *IntPtrTy = DL.getIntPtrType(GEP->getType());\n    unsigned PtrSize = IntPtrTy->getIntegerBitWidth();\n    if (Idx->getType()->getPrimitiveSizeInBits().getFixedSize() > PtrSize)\n      Idx = Builder.CreateTrunc(Idx, IntPtrTy);\n  }\n\n  // If the comparison is only true for one or two elements, emit direct\n  // comparisons.\n  if (SecondTrueElement != Overdefined) {\n    // None true -> false.\n    if (FirstTrueElement == Undefined)\n      return replaceInstUsesWith(ICI, Builder.getFalse());\n\n    Value *FirstTrueIdx = ConstantInt::get(Idx->getType(), FirstTrueElement);\n\n    // True for one element -> 'i == 47'.\n    if (SecondTrueElement == Undefined)\n      return new ICmpInst(ICmpInst::ICMP_EQ, Idx, FirstTrueIdx);\n\n    // True for two elements -> 'i == 47 | i == 72'.\n    Value *C1 = Builder.CreateICmpEQ(Idx, FirstTrueIdx);\n    Value *SecondTrueIdx = ConstantInt::get(Idx->getType(), SecondTrueElement);\n    Value *C2 = Builder.CreateICmpEQ(Idx, SecondTrueIdx);\n    return BinaryOperator::CreateOr(C1, C2);\n  }\n\n  // If the comparison is only false for one or two elements, emit direct\n  // comparisons.\n  if (SecondFalseElement != Overdefined) {\n    // None false -> true.\n    if (FirstFalseElement == Undefined)\n      return replaceInstUsesWith(ICI, Builder.getTrue());\n\n    Value *FirstFalseIdx = ConstantInt::get(Idx->getType(), FirstFalseElement);\n\n    // False for one element -> 'i != 47'.\n    if (SecondFalseElement == Undefined)\n      return new ICmpInst(ICmpInst::ICMP_NE, Idx, FirstFalseIdx);\n\n    // False for two elements -> 'i != 47 & i != 72'.\n    Value *C1 = Builder.CreateICmpNE(Idx, FirstFalseIdx);\n    Value *SecondFalseIdx = ConstantInt::get(Idx->getType(),SecondFalseElement);\n    Value *C2 = Builder.CreateICmpNE(Idx, SecondFalseIdx);\n    return BinaryOperator::CreateAnd(C1, C2);\n  }\n\n  // If the comparison can be replaced with a range comparison for the elements\n  // where it is true, emit the range check.\n  if (TrueRangeEnd != Overdefined) {\n    assert(TrueRangeEnd != FirstTrueElement && \"Should emit single compare\");\n\n    // Generate (i-FirstTrue) <u (TrueRangeEnd-FirstTrue+1).\n    if (FirstTrueElement) {\n      Value *Offs = ConstantInt::get(Idx->getType(), -FirstTrueElement);\n      Idx = Builder.CreateAdd(Idx, Offs);\n    }\n\n    Value *End = ConstantInt::get(Idx->getType(),\n                                  TrueRangeEnd-FirstTrueElement+1);\n    return new ICmpInst(ICmpInst::ICMP_ULT, Idx, End);\n  }\n\n  // False range check.\n  if (FalseRangeEnd != Overdefined) {\n    assert(FalseRangeEnd != FirstFalseElement && \"Should emit single compare\");\n    // Generate (i-FirstFalse) >u (FalseRangeEnd-FirstFalse).\n    if (FirstFalseElement) {\n      Value *Offs = ConstantInt::get(Idx->getType(), -FirstFalseElement);\n      Idx = Builder.CreateAdd(Idx, Offs);\n    }\n\n    Value *End = ConstantInt::get(Idx->getType(),\n                                  FalseRangeEnd-FirstFalseElement);\n    return new ICmpInst(ICmpInst::ICMP_UGT, Idx, End);\n  }\n\n  // If a magic bitvector captures the entire comparison state\n  // of this load, replace it with computation that does:\n  //   ((magic_cst >> i) & 1) != 0\n  {\n    Type *Ty = nullptr;\n\n    // Look for an appropriate type:\n    // - The type of Idx if the magic fits\n    // - The smallest fitting legal type\n    if (ArrayElementCount <= Idx->getType()->getIntegerBitWidth())\n      Ty = Idx->getType();\n    else\n      Ty = DL.getSmallestLegalIntType(Init->getContext(), ArrayElementCount);\n\n    if (Ty) {\n      Value *V = Builder.CreateIntCast(Idx, Ty, false);\n      V = Builder.CreateLShr(ConstantInt::get(Ty, MagicBitvector), V);\n      V = Builder.CreateAnd(ConstantInt::get(Ty, 1), V);\n      return new ICmpInst(ICmpInst::ICMP_NE, V, ConstantInt::get(Ty, 0));\n    }\n  }\n\n  return nullptr;\n}\n\n/// Return a value that can be used to compare the *offset* implied by a GEP to\n/// zero. For example, if we have &A[i], we want to return 'i' for\n/// \"icmp ne i, 0\". Note that, in general, indices can be complex, and scales\n/// are involved. The above expression would also be legal to codegen as\n/// \"icmp ne (i*4), 0\" (assuming A is a pointer to i32).\n/// This latter form is less amenable to optimization though, and we are allowed\n/// to generate the first by knowing that pointer arithmetic doesn't overflow.\n///\n/// If we can't emit an optimized form for this expression, this returns null.\n///\nstatic Value *evaluateGEPOffsetExpression(User *GEP, InstCombinerImpl &IC,\n                                          const DataLayout &DL) {\n  gep_type_iterator GTI = gep_type_begin(GEP);\n\n  // Check to see if this gep only has a single variable index.  If so, and if\n  // any constant indices are a multiple of its scale, then we can compute this\n  // in terms of the scale of the variable index.  For example, if the GEP\n  // implies an offset of \"12 + i*4\", then we can codegen this as \"3 + i\",\n  // because the expression will cross zero at the same point.\n  unsigned i, e = GEP->getNumOperands();\n  int64_t Offset = 0;\n  for (i = 1; i != e; ++i, ++GTI) {\n    if (ConstantInt *CI = dyn_cast<ConstantInt>(GEP->getOperand(i))) {\n      // Compute the aggregate offset of constant indices.\n      if (CI->isZero()) continue;\n\n      // Handle a struct index, which adds its field offset to the pointer.\n      if (StructType *STy = GTI.getStructTypeOrNull()) {\n        Offset += DL.getStructLayout(STy)->getElementOffset(CI->getZExtValue());\n      } else {\n        uint64_t Size = DL.getTypeAllocSize(GTI.getIndexedType());\n        Offset += Size*CI->getSExtValue();\n      }\n    } else {\n      // Found our variable index.\n      break;\n    }\n  }\n\n  // If there are no variable indices, we must have a constant offset, just\n  // evaluate it the general way.\n  if (i == e) return nullptr;\n\n  Value *VariableIdx = GEP->getOperand(i);\n  // Determine the scale factor of the variable element.  For example, this is\n  // 4 if the variable index is into an array of i32.\n  uint64_t VariableScale = DL.getTypeAllocSize(GTI.getIndexedType());\n\n  // Verify that there are no other variable indices.  If so, emit the hard way.\n  for (++i, ++GTI; i != e; ++i, ++GTI) {\n    ConstantInt *CI = dyn_cast<ConstantInt>(GEP->getOperand(i));\n    if (!CI) return nullptr;\n\n    // Compute the aggregate offset of constant indices.\n    if (CI->isZero()) continue;\n\n    // Handle a struct index, which adds its field offset to the pointer.\n    if (StructType *STy = GTI.getStructTypeOrNull()) {\n      Offset += DL.getStructLayout(STy)->getElementOffset(CI->getZExtValue());\n    } else {\n      uint64_t Size = DL.getTypeAllocSize(GTI.getIndexedType());\n      Offset += Size*CI->getSExtValue();\n    }\n  }\n\n  // Okay, we know we have a single variable index, which must be a\n  // pointer/array/vector index.  If there is no offset, life is simple, return\n  // the index.\n  Type *IntPtrTy = DL.getIntPtrType(GEP->getOperand(0)->getType());\n  unsigned IntPtrWidth = IntPtrTy->getIntegerBitWidth();\n  if (Offset == 0) {\n    // Cast to intptrty in case a truncation occurs.  If an extension is needed,\n    // we don't need to bother extending: the extension won't affect where the\n    // computation crosses zero.\n    if (VariableIdx->getType()->getPrimitiveSizeInBits().getFixedSize() >\n        IntPtrWidth) {\n      VariableIdx = IC.Builder.CreateTrunc(VariableIdx, IntPtrTy);\n    }\n    return VariableIdx;\n  }\n\n  // Otherwise, there is an index.  The computation we will do will be modulo\n  // the pointer size.\n  Offset = SignExtend64(Offset, IntPtrWidth);\n  VariableScale = SignExtend64(VariableScale, IntPtrWidth);\n\n  // To do this transformation, any constant index must be a multiple of the\n  // variable scale factor.  For example, we can evaluate \"12 + 4*i\" as \"3 + i\",\n  // but we can't evaluate \"10 + 3*i\" in terms of i.  Check that the offset is a\n  // multiple of the variable scale.\n  int64_t NewOffs = Offset / (int64_t)VariableScale;\n  if (Offset != NewOffs*(int64_t)VariableScale)\n    return nullptr;\n\n  // Okay, we can do this evaluation.  Start by converting the index to intptr.\n  if (VariableIdx->getType() != IntPtrTy)\n    VariableIdx = IC.Builder.CreateIntCast(VariableIdx, IntPtrTy,\n                                            true /*Signed*/);\n  Constant *OffsetVal = ConstantInt::get(IntPtrTy, NewOffs);\n  return IC.Builder.CreateAdd(VariableIdx, OffsetVal, \"offset\");\n}\n\n/// Returns true if we can rewrite Start as a GEP with pointer Base\n/// and some integer offset. The nodes that need to be re-written\n/// for this transformation will be added to Explored.\nstatic bool canRewriteGEPAsOffset(Value *Start, Value *Base,\n                                  const DataLayout &DL,\n                                  SetVector<Value *> &Explored) {\n  SmallVector<Value *, 16> WorkList(1, Start);\n  Explored.insert(Base);\n\n  // The following traversal gives us an order which can be used\n  // when doing the final transformation. Since in the final\n  // transformation we create the PHI replacement instructions first,\n  // we don't have to get them in any particular order.\n  //\n  // However, for other instructions we will have to traverse the\n  // operands of an instruction first, which means that we have to\n  // do a post-order traversal.\n  while (!WorkList.empty()) {\n    SetVector<PHINode *> PHIs;\n\n    while (!WorkList.empty()) {\n      if (Explored.size() >= 100)\n        return false;\n\n      Value *V = WorkList.back();\n\n      if (Explored.contains(V)) {\n        WorkList.pop_back();\n        continue;\n      }\n\n      if (!isa<IntToPtrInst>(V) && !isa<PtrToIntInst>(V) &&\n          !isa<GetElementPtrInst>(V) && !isa<PHINode>(V))\n        // We've found some value that we can't explore which is different from\n        // the base. Therefore we can't do this transformation.\n        return false;\n\n      if (isa<IntToPtrInst>(V) || isa<PtrToIntInst>(V)) {\n        auto *CI = cast<CastInst>(V);\n        if (!CI->isNoopCast(DL))\n          return false;\n\n        if (Explored.count(CI->getOperand(0)) == 0)\n          WorkList.push_back(CI->getOperand(0));\n      }\n\n      if (auto *GEP = dyn_cast<GEPOperator>(V)) {\n        // We're limiting the GEP to having one index. This will preserve\n        // the original pointer type. We could handle more cases in the\n        // future.\n        if (GEP->getNumIndices() != 1 || !GEP->isInBounds() ||\n            GEP->getType() != Start->getType())\n          return false;\n\n        if (Explored.count(GEP->getOperand(0)) == 0)\n          WorkList.push_back(GEP->getOperand(0));\n      }\n\n      if (WorkList.back() == V) {\n        WorkList.pop_back();\n        // We've finished visiting this node, mark it as such.\n        Explored.insert(V);\n      }\n\n      if (auto *PN = dyn_cast<PHINode>(V)) {\n        // We cannot transform PHIs on unsplittable basic blocks.\n        if (isa<CatchSwitchInst>(PN->getParent()->getTerminator()))\n          return false;\n        Explored.insert(PN);\n        PHIs.insert(PN);\n      }\n    }\n\n    // Explore the PHI nodes further.\n    for (auto *PN : PHIs)\n      for (Value *Op : PN->incoming_values())\n        if (Explored.count(Op) == 0)\n          WorkList.push_back(Op);\n  }\n\n  // Make sure that we can do this. Since we can't insert GEPs in a basic\n  // block before a PHI node, we can't easily do this transformation if\n  // we have PHI node users of transformed instructions.\n  for (Value *Val : Explored) {\n    for (Value *Use : Val->uses()) {\n\n      auto *PHI = dyn_cast<PHINode>(Use);\n      auto *Inst = dyn_cast<Instruction>(Val);\n\n      if (Inst == Base || Inst == PHI || !Inst || !PHI ||\n          Explored.count(PHI) == 0)\n        continue;\n\n      if (PHI->getParent() == Inst->getParent())\n        return false;\n    }\n  }\n  return true;\n}\n\n// Sets the appropriate insert point on Builder where we can add\n// a replacement Instruction for V (if that is possible).\nstatic void setInsertionPoint(IRBuilder<> &Builder, Value *V,\n                              bool Before = true) {\n  if (auto *PHI = dyn_cast<PHINode>(V)) {\n    Builder.SetInsertPoint(&*PHI->getParent()->getFirstInsertionPt());\n    return;\n  }\n  if (auto *I = dyn_cast<Instruction>(V)) {\n    if (!Before)\n      I = &*std::next(I->getIterator());\n    Builder.SetInsertPoint(I);\n    return;\n  }\n  if (auto *A = dyn_cast<Argument>(V)) {\n    // Set the insertion point in the entry block.\n    BasicBlock &Entry = A->getParent()->getEntryBlock();\n    Builder.SetInsertPoint(&*Entry.getFirstInsertionPt());\n    return;\n  }\n  // Otherwise, this is a constant and we don't need to set a new\n  // insertion point.\n  assert(isa<Constant>(V) && \"Setting insertion point for unknown value!\");\n}\n\n/// Returns a re-written value of Start as an indexed GEP using Base as a\n/// pointer.\nstatic Value *rewriteGEPAsOffset(Value *Start, Value *Base,\n                                 const DataLayout &DL,\n                                 SetVector<Value *> &Explored) {\n  // Perform all the substitutions. This is a bit tricky because we can\n  // have cycles in our use-def chains.\n  // 1. Create the PHI nodes without any incoming values.\n  // 2. Create all the other values.\n  // 3. Add the edges for the PHI nodes.\n  // 4. Emit GEPs to get the original pointers.\n  // 5. Remove the original instructions.\n  Type *IndexType = IntegerType::get(\n      Base->getContext(), DL.getIndexTypeSizeInBits(Start->getType()));\n\n  DenseMap<Value *, Value *> NewInsts;\n  NewInsts[Base] = ConstantInt::getNullValue(IndexType);\n\n  // Create the new PHI nodes, without adding any incoming values.\n  for (Value *Val : Explored) {\n    if (Val == Base)\n      continue;\n    // Create empty phi nodes. This avoids cyclic dependencies when creating\n    // the remaining instructions.\n    if (auto *PHI = dyn_cast<PHINode>(Val))\n      NewInsts[PHI] = PHINode::Create(IndexType, PHI->getNumIncomingValues(),\n                                      PHI->getName() + \".idx\", PHI);\n  }\n  IRBuilder<> Builder(Base->getContext());\n\n  // Create all the other instructions.\n  for (Value *Val : Explored) {\n\n    if (NewInsts.find(Val) != NewInsts.end())\n      continue;\n\n    if (auto *CI = dyn_cast<CastInst>(Val)) {\n      // Don't get rid of the intermediate variable here; the store can grow\n      // the map which will invalidate the reference to the input value.\n      Value *V = NewInsts[CI->getOperand(0)];\n      NewInsts[CI] = V;\n      continue;\n    }\n    if (auto *GEP = dyn_cast<GEPOperator>(Val)) {\n      Value *Index = NewInsts[GEP->getOperand(1)] ? NewInsts[GEP->getOperand(1)]\n                                                  : GEP->getOperand(1);\n      setInsertionPoint(Builder, GEP);\n      // Indices might need to be sign extended. GEPs will magically do\n      // this, but we need to do it ourselves here.\n      if (Index->getType()->getScalarSizeInBits() !=\n          NewInsts[GEP->getOperand(0)]->getType()->getScalarSizeInBits()) {\n        Index = Builder.CreateSExtOrTrunc(\n            Index, NewInsts[GEP->getOperand(0)]->getType(),\n            GEP->getOperand(0)->getName() + \".sext\");\n      }\n\n      auto *Op = NewInsts[GEP->getOperand(0)];\n      if (isa<ConstantInt>(Op) && cast<ConstantInt>(Op)->isZero())\n        NewInsts[GEP] = Index;\n      else\n        NewInsts[GEP] = Builder.CreateNSWAdd(\n            Op, Index, GEP->getOperand(0)->getName() + \".add\");\n      continue;\n    }\n    if (isa<PHINode>(Val))\n      continue;\n\n    llvm_unreachable(\"Unexpected instruction type\");\n  }\n\n  // Add the incoming values to the PHI nodes.\n  for (Value *Val : Explored) {\n    if (Val == Base)\n      continue;\n    // All the instructions have been created, we can now add edges to the\n    // phi nodes.\n    if (auto *PHI = dyn_cast<PHINode>(Val)) {\n      PHINode *NewPhi = static_cast<PHINode *>(NewInsts[PHI]);\n      for (unsigned I = 0, E = PHI->getNumIncomingValues(); I < E; ++I) {\n        Value *NewIncoming = PHI->getIncomingValue(I);\n\n        if (NewInsts.find(NewIncoming) != NewInsts.end())\n          NewIncoming = NewInsts[NewIncoming];\n\n        NewPhi->addIncoming(NewIncoming, PHI->getIncomingBlock(I));\n      }\n    }\n  }\n\n  for (Value *Val : Explored) {\n    if (Val == Base)\n      continue;\n\n    // Depending on the type, for external users we have to emit\n    // a GEP or a GEP + ptrtoint.\n    setInsertionPoint(Builder, Val, false);\n\n    // If required, create an inttoptr instruction for Base.\n    Value *NewBase = Base;\n    if (!Base->getType()->isPointerTy())\n      NewBase = Builder.CreateBitOrPointerCast(Base, Start->getType(),\n                                               Start->getName() + \"to.ptr\");\n\n    Value *GEP = Builder.CreateInBoundsGEP(\n        Start->getType()->getPointerElementType(), NewBase,\n        makeArrayRef(NewInsts[Val]), Val->getName() + \".ptr\");\n\n    if (!Val->getType()->isPointerTy()) {\n      Value *Cast = Builder.CreatePointerCast(GEP, Val->getType(),\n                                              Val->getName() + \".conv\");\n      GEP = Cast;\n    }\n    Val->replaceAllUsesWith(GEP);\n  }\n\n  return NewInsts[Start];\n}\n\n/// Looks through GEPs, IntToPtrInsts and PtrToIntInsts in order to express\n/// the input Value as a constant indexed GEP. Returns a pair containing\n/// the GEPs Pointer and Index.\nstatic std::pair<Value *, Value *>\ngetAsConstantIndexedAddress(Value *V, const DataLayout &DL) {\n  Type *IndexType = IntegerType::get(V->getContext(),\n                                     DL.getIndexTypeSizeInBits(V->getType()));\n\n  Constant *Index = ConstantInt::getNullValue(IndexType);\n  while (true) {\n    if (GEPOperator *GEP = dyn_cast<GEPOperator>(V)) {\n      // We accept only inbouds GEPs here to exclude the possibility of\n      // overflow.\n      if (!GEP->isInBounds())\n        break;\n      if (GEP->hasAllConstantIndices() && GEP->getNumIndices() == 1 &&\n          GEP->getType() == V->getType()) {\n        V = GEP->getOperand(0);\n        Constant *GEPIndex = static_cast<Constant *>(GEP->getOperand(1));\n        Index = ConstantExpr::getAdd(\n            Index, ConstantExpr::getSExtOrBitCast(GEPIndex, IndexType));\n        continue;\n      }\n      break;\n    }\n    if (auto *CI = dyn_cast<IntToPtrInst>(V)) {\n      if (!CI->isNoopCast(DL))\n        break;\n      V = CI->getOperand(0);\n      continue;\n    }\n    if (auto *CI = dyn_cast<PtrToIntInst>(V)) {\n      if (!CI->isNoopCast(DL))\n        break;\n      V = CI->getOperand(0);\n      continue;\n    }\n    break;\n  }\n  return {V, Index};\n}\n\n/// Converts (CMP GEPLHS, RHS) if this change would make RHS a constant.\n/// We can look through PHIs, GEPs and casts in order to determine a common base\n/// between GEPLHS and RHS.\nstatic Instruction *transformToIndexedCompare(GEPOperator *GEPLHS, Value *RHS,\n                                              ICmpInst::Predicate Cond,\n                                              const DataLayout &DL) {\n  // FIXME: Support vector of pointers.\n  if (GEPLHS->getType()->isVectorTy())\n    return nullptr;\n\n  if (!GEPLHS->hasAllConstantIndices())\n    return nullptr;\n\n  // Make sure the pointers have the same type.\n  if (GEPLHS->getType() != RHS->getType())\n    return nullptr;\n\n  Value *PtrBase, *Index;\n  std::tie(PtrBase, Index) = getAsConstantIndexedAddress(GEPLHS, DL);\n\n  // The set of nodes that will take part in this transformation.\n  SetVector<Value *> Nodes;\n\n  if (!canRewriteGEPAsOffset(RHS, PtrBase, DL, Nodes))\n    return nullptr;\n\n  // We know we can re-write this as\n  //  ((gep Ptr, OFFSET1) cmp (gep Ptr, OFFSET2)\n  // Since we've only looked through inbouds GEPs we know that we\n  // can't have overflow on either side. We can therefore re-write\n  // this as:\n  //   OFFSET1 cmp OFFSET2\n  Value *NewRHS = rewriteGEPAsOffset(RHS, PtrBase, DL, Nodes);\n\n  // RewriteGEPAsOffset has replaced RHS and all of its uses with a re-written\n  // GEP having PtrBase as the pointer base, and has returned in NewRHS the\n  // offset. Since Index is the offset of LHS to the base pointer, we will now\n  // compare the offsets instead of comparing the pointers.\n  return new ICmpInst(ICmpInst::getSignedPredicate(Cond), Index, NewRHS);\n}\n\n/// Fold comparisons between a GEP instruction and something else. At this point\n/// we know that the GEP is on the LHS of the comparison.\nInstruction *InstCombinerImpl::foldGEPICmp(GEPOperator *GEPLHS, Value *RHS,\n                                           ICmpInst::Predicate Cond,\n                                           Instruction &I) {\n  // Don't transform signed compares of GEPs into index compares. Even if the\n  // GEP is inbounds, the final add of the base pointer can have signed overflow\n  // and would change the result of the icmp.\n  // e.g. \"&foo[0] <s &foo[1]\" can't be folded to \"true\" because \"foo\" could be\n  // the maximum signed value for the pointer type.\n  if (ICmpInst::isSigned(Cond))\n    return nullptr;\n\n  // Look through bitcasts and addrspacecasts. We do not however want to remove\n  // 0 GEPs.\n  if (!isa<GetElementPtrInst>(RHS))\n    RHS = RHS->stripPointerCasts();\n\n  Value *PtrBase = GEPLHS->getOperand(0);\n  // FIXME: Support vector pointer GEPs.\n  if (PtrBase == RHS && GEPLHS->isInBounds() &&\n      !GEPLHS->getType()->isVectorTy()) {\n    // ((gep Ptr, OFFSET) cmp Ptr)   ---> (OFFSET cmp 0).\n    // This transformation (ignoring the base and scales) is valid because we\n    // know pointers can't overflow since the gep is inbounds.  See if we can\n    // output an optimized form.\n    Value *Offset = evaluateGEPOffsetExpression(GEPLHS, *this, DL);\n\n    // If not, synthesize the offset the hard way.\n    if (!Offset)\n      Offset = EmitGEPOffset(GEPLHS);\n    return new ICmpInst(ICmpInst::getSignedPredicate(Cond), Offset,\n                        Constant::getNullValue(Offset->getType()));\n  }\n\n  if (GEPLHS->isInBounds() && ICmpInst::isEquality(Cond) &&\n      isa<Constant>(RHS) && cast<Constant>(RHS)->isNullValue() &&\n      !NullPointerIsDefined(I.getFunction(),\n                            RHS->getType()->getPointerAddressSpace())) {\n    // For most address spaces, an allocation can't be placed at null, but null\n    // itself is treated as a 0 size allocation in the in bounds rules.  Thus,\n    // the only valid inbounds address derived from null, is null itself.\n    // Thus, we have four cases to consider:\n    // 1) Base == nullptr, Offset == 0 -> inbounds, null\n    // 2) Base == nullptr, Offset != 0 -> poison as the result is out of bounds\n    // 3) Base != nullptr, Offset == (-base) -> poison (crossing allocations)\n    // 4) Base != nullptr, Offset != (-base) -> nonnull (and possibly poison)\n    //\n    // (Note if we're indexing a type of size 0, that simply collapses into one\n    //  of the buckets above.)\n    //\n    // In general, we're allowed to make values less poison (i.e. remove\n    //   sources of full UB), so in this case, we just select between the two\n    //   non-poison cases (1 and 4 above).\n    //\n    // For vectors, we apply the same reasoning on a per-lane basis.\n    auto *Base = GEPLHS->getPointerOperand();\n    if (GEPLHS->getType()->isVectorTy() && Base->getType()->isPointerTy()) {\n      auto EC = cast<VectorType>(GEPLHS->getType())->getElementCount();\n      Base = Builder.CreateVectorSplat(EC, Base);\n    }\n    return new ICmpInst(Cond, Base,\n                        ConstantExpr::getPointerBitCastOrAddrSpaceCast(\n                            cast<Constant>(RHS), Base->getType()));\n  } else if (GEPOperator *GEPRHS = dyn_cast<GEPOperator>(RHS)) {\n    // If the base pointers are different, but the indices are the same, just\n    // compare the base pointer.\n    if (PtrBase != GEPRHS->getOperand(0)) {\n      bool IndicesTheSame = GEPLHS->getNumOperands()==GEPRHS->getNumOperands();\n      IndicesTheSame &= GEPLHS->getOperand(0)->getType() ==\n                        GEPRHS->getOperand(0)->getType();\n      if (IndicesTheSame)\n        for (unsigned i = 1, e = GEPLHS->getNumOperands(); i != e; ++i)\n          if (GEPLHS->getOperand(i) != GEPRHS->getOperand(i)) {\n            IndicesTheSame = false;\n            break;\n          }\n\n      // If all indices are the same, just compare the base pointers.\n      Type *BaseType = GEPLHS->getOperand(0)->getType();\n      if (IndicesTheSame && CmpInst::makeCmpResultType(BaseType) == I.getType())\n        return new ICmpInst(Cond, GEPLHS->getOperand(0), GEPRHS->getOperand(0));\n\n      // If we're comparing GEPs with two base pointers that only differ in type\n      // and both GEPs have only constant indices or just one use, then fold\n      // the compare with the adjusted indices.\n      // FIXME: Support vector of pointers.\n      if (GEPLHS->isInBounds() && GEPRHS->isInBounds() &&\n          (GEPLHS->hasAllConstantIndices() || GEPLHS->hasOneUse()) &&\n          (GEPRHS->hasAllConstantIndices() || GEPRHS->hasOneUse()) &&\n          PtrBase->stripPointerCasts() ==\n              GEPRHS->getOperand(0)->stripPointerCasts() &&\n          !GEPLHS->getType()->isVectorTy()) {\n        Value *LOffset = EmitGEPOffset(GEPLHS);\n        Value *ROffset = EmitGEPOffset(GEPRHS);\n\n        // If we looked through an addrspacecast between different sized address\n        // spaces, the LHS and RHS pointers are different sized\n        // integers. Truncate to the smaller one.\n        Type *LHSIndexTy = LOffset->getType();\n        Type *RHSIndexTy = ROffset->getType();\n        if (LHSIndexTy != RHSIndexTy) {\n          if (LHSIndexTy->getPrimitiveSizeInBits().getFixedSize() <\n              RHSIndexTy->getPrimitiveSizeInBits().getFixedSize()) {\n            ROffset = Builder.CreateTrunc(ROffset, LHSIndexTy);\n          } else\n            LOffset = Builder.CreateTrunc(LOffset, RHSIndexTy);\n        }\n\n        Value *Cmp = Builder.CreateICmp(ICmpInst::getSignedPredicate(Cond),\n                                        LOffset, ROffset);\n        return replaceInstUsesWith(I, Cmp);\n      }\n\n      // Otherwise, the base pointers are different and the indices are\n      // different. Try convert this to an indexed compare by looking through\n      // PHIs/casts.\n      return transformToIndexedCompare(GEPLHS, RHS, Cond, DL);\n    }\n\n    // If one of the GEPs has all zero indices, recurse.\n    // FIXME: Handle vector of pointers.\n    if (!GEPLHS->getType()->isVectorTy() && GEPLHS->hasAllZeroIndices())\n      return foldGEPICmp(GEPRHS, GEPLHS->getOperand(0),\n                         ICmpInst::getSwappedPredicate(Cond), I);\n\n    // If the other GEP has all zero indices, recurse.\n    // FIXME: Handle vector of pointers.\n    if (!GEPRHS->getType()->isVectorTy() && GEPRHS->hasAllZeroIndices())\n      return foldGEPICmp(GEPLHS, GEPRHS->getOperand(0), Cond, I);\n\n    bool GEPsInBounds = GEPLHS->isInBounds() && GEPRHS->isInBounds();\n    if (GEPLHS->getNumOperands() == GEPRHS->getNumOperands()) {\n      // If the GEPs only differ by one index, compare it.\n      unsigned NumDifferences = 0;  // Keep track of # differences.\n      unsigned DiffOperand = 0;     // The operand that differs.\n      for (unsigned i = 1, e = GEPRHS->getNumOperands(); i != e; ++i)\n        if (GEPLHS->getOperand(i) != GEPRHS->getOperand(i)) {\n          Type *LHSType = GEPLHS->getOperand(i)->getType();\n          Type *RHSType = GEPRHS->getOperand(i)->getType();\n          // FIXME: Better support for vector of pointers.\n          if (LHSType->getPrimitiveSizeInBits() !=\n                   RHSType->getPrimitiveSizeInBits() ||\n              (GEPLHS->getType()->isVectorTy() &&\n               (!LHSType->isVectorTy() || !RHSType->isVectorTy()))) {\n            // Irreconcilable differences.\n            NumDifferences = 2;\n            break;\n          }\n\n          if (NumDifferences++) break;\n          DiffOperand = i;\n        }\n\n      if (NumDifferences == 0)   // SAME GEP?\n        return replaceInstUsesWith(I, // No comparison is needed here.\n          ConstantInt::get(I.getType(), ICmpInst::isTrueWhenEqual(Cond)));\n\n      else if (NumDifferences == 1 && GEPsInBounds) {\n        Value *LHSV = GEPLHS->getOperand(DiffOperand);\n        Value *RHSV = GEPRHS->getOperand(DiffOperand);\n        // Make sure we do a signed comparison here.\n        return new ICmpInst(ICmpInst::getSignedPredicate(Cond), LHSV, RHSV);\n      }\n    }\n\n    // Only lower this if the icmp is the only user of the GEP or if we expect\n    // the result to fold to a constant!\n    if (GEPsInBounds && (isa<ConstantExpr>(GEPLHS) || GEPLHS->hasOneUse()) &&\n        (isa<ConstantExpr>(GEPRHS) || GEPRHS->hasOneUse())) {\n      // ((gep Ptr, OFFSET1) cmp (gep Ptr, OFFSET2)  --->  (OFFSET1 cmp OFFSET2)\n      Value *L = EmitGEPOffset(GEPLHS);\n      Value *R = EmitGEPOffset(GEPRHS);\n      return new ICmpInst(ICmpInst::getSignedPredicate(Cond), L, R);\n    }\n  }\n\n  // Try convert this to an indexed compare by looking through PHIs/casts as a\n  // last resort.\n  return transformToIndexedCompare(GEPLHS, RHS, Cond, DL);\n}\n\nInstruction *InstCombinerImpl::foldAllocaCmp(ICmpInst &ICI,\n                                             const AllocaInst *Alloca,\n                                             const Value *Other) {\n  assert(ICI.isEquality() && \"Cannot fold non-equality comparison.\");\n\n  // It would be tempting to fold away comparisons between allocas and any\n  // pointer not based on that alloca (e.g. an argument). However, even\n  // though such pointers cannot alias, they can still compare equal.\n  //\n  // But LLVM doesn't specify where allocas get their memory, so if the alloca\n  // doesn't escape we can argue that it's impossible to guess its value, and we\n  // can therefore act as if any such guesses are wrong.\n  //\n  // The code below checks that the alloca doesn't escape, and that it's only\n  // used in a comparison once (the current instruction). The\n  // single-comparison-use condition ensures that we're trivially folding all\n  // comparisons against the alloca consistently, and avoids the risk of\n  // erroneously folding a comparison of the pointer with itself.\n\n  unsigned MaxIter = 32; // Break cycles and bound to constant-time.\n\n  SmallVector<const Use *, 32> Worklist;\n  for (const Use &U : Alloca->uses()) {\n    if (Worklist.size() >= MaxIter)\n      return nullptr;\n    Worklist.push_back(&U);\n  }\n\n  unsigned NumCmps = 0;\n  while (!Worklist.empty()) {\n    assert(Worklist.size() <= MaxIter);\n    const Use *U = Worklist.pop_back_val();\n    const Value *V = U->getUser();\n    --MaxIter;\n\n    if (isa<BitCastInst>(V) || isa<GetElementPtrInst>(V) || isa<PHINode>(V) ||\n        isa<SelectInst>(V)) {\n      // Track the uses.\n    } else if (isa<LoadInst>(V)) {\n      // Loading from the pointer doesn't escape it.\n      continue;\n    } else if (const auto *SI = dyn_cast<StoreInst>(V)) {\n      // Storing *to* the pointer is fine, but storing the pointer escapes it.\n      if (SI->getValueOperand() == U->get())\n        return nullptr;\n      continue;\n    } else if (isa<ICmpInst>(V)) {\n      if (NumCmps++)\n        return nullptr; // Found more than one cmp.\n      continue;\n    } else if (const auto *Intrin = dyn_cast<IntrinsicInst>(V)) {\n      switch (Intrin->getIntrinsicID()) {\n        // These intrinsics don't escape or compare the pointer. Memset is safe\n        // because we don't allow ptrtoint. Memcpy and memmove are safe because\n        // we don't allow stores, so src cannot point to V.\n        case Intrinsic::lifetime_start: case Intrinsic::lifetime_end:\n        case Intrinsic::memcpy: case Intrinsic::memmove: case Intrinsic::memset:\n          continue;\n        default:\n          return nullptr;\n      }\n    } else {\n      return nullptr;\n    }\n    for (const Use &U : V->uses()) {\n      if (Worklist.size() >= MaxIter)\n        return nullptr;\n      Worklist.push_back(&U);\n    }\n  }\n\n  Type *CmpTy = CmpInst::makeCmpResultType(Other->getType());\n  return replaceInstUsesWith(\n      ICI,\n      ConstantInt::get(CmpTy, !CmpInst::isTrueWhenEqual(ICI.getPredicate())));\n}\n\n/// Fold \"icmp pred (X+C), X\".\nInstruction *InstCombinerImpl::foldICmpAddOpConst(Value *X, const APInt &C,\n                                                  ICmpInst::Predicate Pred) {\n  // From this point on, we know that (X+C <= X) --> (X+C < X) because C != 0,\n  // so the values can never be equal.  Similarly for all other \"or equals\"\n  // operators.\n  assert(!!C && \"C should not be zero!\");\n\n  // (X+1) <u X        --> X >u (MAXUINT-1)        --> X == 255\n  // (X+2) <u X        --> X >u (MAXUINT-2)        --> X > 253\n  // (X+MAXUINT) <u X  --> X >u (MAXUINT-MAXUINT)  --> X != 0\n  if (Pred == ICmpInst::ICMP_ULT || Pred == ICmpInst::ICMP_ULE) {\n    Constant *R = ConstantInt::get(X->getType(),\n                                   APInt::getMaxValue(C.getBitWidth()) - C);\n    return new ICmpInst(ICmpInst::ICMP_UGT, X, R);\n  }\n\n  // (X+1) >u X        --> X <u (0-1)        --> X != 255\n  // (X+2) >u X        --> X <u (0-2)        --> X <u 254\n  // (X+MAXUINT) >u X  --> X <u (0-MAXUINT)  --> X <u 1  --> X == 0\n  if (Pred == ICmpInst::ICMP_UGT || Pred == ICmpInst::ICMP_UGE)\n    return new ICmpInst(ICmpInst::ICMP_ULT, X,\n                        ConstantInt::get(X->getType(), -C));\n\n  APInt SMax = APInt::getSignedMaxValue(C.getBitWidth());\n\n  // (X+ 1) <s X       --> X >s (MAXSINT-1)          --> X == 127\n  // (X+ 2) <s X       --> X >s (MAXSINT-2)          --> X >s 125\n  // (X+MAXSINT) <s X  --> X >s (MAXSINT-MAXSINT)    --> X >s 0\n  // (X+MINSINT) <s X  --> X >s (MAXSINT-MINSINT)    --> X >s -1\n  // (X+ -2) <s X      --> X >s (MAXSINT- -2)        --> X >s 126\n  // (X+ -1) <s X      --> X >s (MAXSINT- -1)        --> X != 127\n  if (Pred == ICmpInst::ICMP_SLT || Pred == ICmpInst::ICMP_SLE)\n    return new ICmpInst(ICmpInst::ICMP_SGT, X,\n                        ConstantInt::get(X->getType(), SMax - C));\n\n  // (X+ 1) >s X       --> X <s (MAXSINT-(1-1))       --> X != 127\n  // (X+ 2) >s X       --> X <s (MAXSINT-(2-1))       --> X <s 126\n  // (X+MAXSINT) >s X  --> X <s (MAXSINT-(MAXSINT-1)) --> X <s 1\n  // (X+MINSINT) >s X  --> X <s (MAXSINT-(MINSINT-1)) --> X <s -2\n  // (X+ -2) >s X      --> X <s (MAXSINT-(-2-1))      --> X <s -126\n  // (X+ -1) >s X      --> X <s (MAXSINT-(-1-1))      --> X == -128\n\n  assert(Pred == ICmpInst::ICMP_SGT || Pred == ICmpInst::ICMP_SGE);\n  return new ICmpInst(ICmpInst::ICMP_SLT, X,\n                      ConstantInt::get(X->getType(), SMax - (C - 1)));\n}\n\n/// Handle \"(icmp eq/ne (ashr/lshr AP2, A), AP1)\" ->\n/// (icmp eq/ne A, Log2(AP2/AP1)) ->\n/// (icmp eq/ne A, Log2(AP2) - Log2(AP1)).\nInstruction *InstCombinerImpl::foldICmpShrConstConst(ICmpInst &I, Value *A,\n                                                     const APInt &AP1,\n                                                     const APInt &AP2) {\n  assert(I.isEquality() && \"Cannot fold icmp gt/lt\");\n\n  auto getICmp = [&I](CmpInst::Predicate Pred, Value *LHS, Value *RHS) {\n    if (I.getPredicate() == I.ICMP_NE)\n      Pred = CmpInst::getInversePredicate(Pred);\n    return new ICmpInst(Pred, LHS, RHS);\n  };\n\n  // Don't bother doing any work for cases which InstSimplify handles.\n  if (AP2.isNullValue())\n    return nullptr;\n\n  bool IsAShr = isa<AShrOperator>(I.getOperand(0));\n  if (IsAShr) {\n    if (AP2.isAllOnesValue())\n      return nullptr;\n    if (AP2.isNegative() != AP1.isNegative())\n      return nullptr;\n    if (AP2.sgt(AP1))\n      return nullptr;\n  }\n\n  if (!AP1)\n    // 'A' must be large enough to shift out the highest set bit.\n    return getICmp(I.ICMP_UGT, A,\n                   ConstantInt::get(A->getType(), AP2.logBase2()));\n\n  if (AP1 == AP2)\n    return getICmp(I.ICMP_EQ, A, ConstantInt::getNullValue(A->getType()));\n\n  int Shift;\n  if (IsAShr && AP1.isNegative())\n    Shift = AP1.countLeadingOnes() - AP2.countLeadingOnes();\n  else\n    Shift = AP1.countLeadingZeros() - AP2.countLeadingZeros();\n\n  if (Shift > 0) {\n    if (IsAShr && AP1 == AP2.ashr(Shift)) {\n      // There are multiple solutions if we are comparing against -1 and the LHS\n      // of the ashr is not a power of two.\n      if (AP1.isAllOnesValue() && !AP2.isPowerOf2())\n        return getICmp(I.ICMP_UGE, A, ConstantInt::get(A->getType(), Shift));\n      return getICmp(I.ICMP_EQ, A, ConstantInt::get(A->getType(), Shift));\n    } else if (AP1 == AP2.lshr(Shift)) {\n      return getICmp(I.ICMP_EQ, A, ConstantInt::get(A->getType(), Shift));\n    }\n  }\n\n  // Shifting const2 will never be equal to const1.\n  // FIXME: This should always be handled by InstSimplify?\n  auto *TorF = ConstantInt::get(I.getType(), I.getPredicate() == I.ICMP_NE);\n  return replaceInstUsesWith(I, TorF);\n}\n\n/// Handle \"(icmp eq/ne (shl AP2, A), AP1)\" ->\n/// (icmp eq/ne A, TrailingZeros(AP1) - TrailingZeros(AP2)).\nInstruction *InstCombinerImpl::foldICmpShlConstConst(ICmpInst &I, Value *A,\n                                                     const APInt &AP1,\n                                                     const APInt &AP2) {\n  assert(I.isEquality() && \"Cannot fold icmp gt/lt\");\n\n  auto getICmp = [&I](CmpInst::Predicate Pred, Value *LHS, Value *RHS) {\n    if (I.getPredicate() == I.ICMP_NE)\n      Pred = CmpInst::getInversePredicate(Pred);\n    return new ICmpInst(Pred, LHS, RHS);\n  };\n\n  // Don't bother doing any work for cases which InstSimplify handles.\n  if (AP2.isNullValue())\n    return nullptr;\n\n  unsigned AP2TrailingZeros = AP2.countTrailingZeros();\n\n  if (!AP1 && AP2TrailingZeros != 0)\n    return getICmp(\n        I.ICMP_UGE, A,\n        ConstantInt::get(A->getType(), AP2.getBitWidth() - AP2TrailingZeros));\n\n  if (AP1 == AP2)\n    return getICmp(I.ICMP_EQ, A, ConstantInt::getNullValue(A->getType()));\n\n  // Get the distance between the lowest bits that are set.\n  int Shift = AP1.countTrailingZeros() - AP2TrailingZeros;\n\n  if (Shift > 0 && AP2.shl(Shift) == AP1)\n    return getICmp(I.ICMP_EQ, A, ConstantInt::get(A->getType(), Shift));\n\n  // Shifting const2 will never be equal to const1.\n  // FIXME: This should always be handled by InstSimplify?\n  auto *TorF = ConstantInt::get(I.getType(), I.getPredicate() == I.ICMP_NE);\n  return replaceInstUsesWith(I, TorF);\n}\n\n/// The caller has matched a pattern of the form:\n///   I = icmp ugt (add (add A, B), CI2), CI1\n/// If this is of the form:\n///   sum = a + b\n///   if (sum+128 >u 255)\n/// Then replace it with llvm.sadd.with.overflow.i8.\n///\nstatic Instruction *processUGT_ADDCST_ADD(ICmpInst &I, Value *A, Value *B,\n                                          ConstantInt *CI2, ConstantInt *CI1,\n                                          InstCombinerImpl &IC) {\n  // The transformation we're trying to do here is to transform this into an\n  // llvm.sadd.with.overflow.  To do this, we have to replace the original add\n  // with a narrower add, and discard the add-with-constant that is part of the\n  // range check (if we can't eliminate it, this isn't profitable).\n\n  // In order to eliminate the add-with-constant, the compare can be its only\n  // use.\n  Instruction *AddWithCst = cast<Instruction>(I.getOperand(0));\n  if (!AddWithCst->hasOneUse())\n    return nullptr;\n\n  // If CI2 is 2^7, 2^15, 2^31, then it might be an sadd.with.overflow.\n  if (!CI2->getValue().isPowerOf2())\n    return nullptr;\n  unsigned NewWidth = CI2->getValue().countTrailingZeros();\n  if (NewWidth != 7 && NewWidth != 15 && NewWidth != 31)\n    return nullptr;\n\n  // The width of the new add formed is 1 more than the bias.\n  ++NewWidth;\n\n  // Check to see that CI1 is an all-ones value with NewWidth bits.\n  if (CI1->getBitWidth() == NewWidth ||\n      CI1->getValue() != APInt::getLowBitsSet(CI1->getBitWidth(), NewWidth))\n    return nullptr;\n\n  // This is only really a signed overflow check if the inputs have been\n  // sign-extended; check for that condition. For example, if CI2 is 2^31 and\n  // the operands of the add are 64 bits wide, we need at least 33 sign bits.\n  unsigned NeededSignBits = CI1->getBitWidth() - NewWidth + 1;\n  if (IC.ComputeNumSignBits(A, 0, &I) < NeededSignBits ||\n      IC.ComputeNumSignBits(B, 0, &I) < NeededSignBits)\n    return nullptr;\n\n  // In order to replace the original add with a narrower\n  // llvm.sadd.with.overflow, the only uses allowed are the add-with-constant\n  // and truncates that discard the high bits of the add.  Verify that this is\n  // the case.\n  Instruction *OrigAdd = cast<Instruction>(AddWithCst->getOperand(0));\n  for (User *U : OrigAdd->users()) {\n    if (U == AddWithCst)\n      continue;\n\n    // Only accept truncates for now.  We would really like a nice recursive\n    // predicate like SimplifyDemandedBits, but which goes downwards the use-def\n    // chain to see which bits of a value are actually demanded.  If the\n    // original add had another add which was then immediately truncated, we\n    // could still do the transformation.\n    TruncInst *TI = dyn_cast<TruncInst>(U);\n    if (!TI || TI->getType()->getPrimitiveSizeInBits() > NewWidth)\n      return nullptr;\n  }\n\n  // If the pattern matches, truncate the inputs to the narrower type and\n  // use the sadd_with_overflow intrinsic to efficiently compute both the\n  // result and the overflow bit.\n  Type *NewType = IntegerType::get(OrigAdd->getContext(), NewWidth);\n  Function *F = Intrinsic::getDeclaration(\n      I.getModule(), Intrinsic::sadd_with_overflow, NewType);\n\n  InstCombiner::BuilderTy &Builder = IC.Builder;\n\n  // Put the new code above the original add, in case there are any uses of the\n  // add between the add and the compare.\n  Builder.SetInsertPoint(OrigAdd);\n\n  Value *TruncA = Builder.CreateTrunc(A, NewType, A->getName() + \".trunc\");\n  Value *TruncB = Builder.CreateTrunc(B, NewType, B->getName() + \".trunc\");\n  CallInst *Call = Builder.CreateCall(F, {TruncA, TruncB}, \"sadd\");\n  Value *Add = Builder.CreateExtractValue(Call, 0, \"sadd.result\");\n  Value *ZExt = Builder.CreateZExt(Add, OrigAdd->getType());\n\n  // The inner add was the result of the narrow add, zero extended to the\n  // wider type.  Replace it with the result computed by the intrinsic.\n  IC.replaceInstUsesWith(*OrigAdd, ZExt);\n  IC.eraseInstFromFunction(*OrigAdd);\n\n  // The original icmp gets replaced with the overflow value.\n  return ExtractValueInst::Create(Call, 1, \"sadd.overflow\");\n}\n\n/// If we have:\n///   icmp eq/ne (urem/srem %x, %y), 0\n/// iff %y is a power-of-two, we can replace this with a bit test:\n///   icmp eq/ne (and %x, (add %y, -1)), 0\nInstruction *InstCombinerImpl::foldIRemByPowerOfTwoToBitTest(ICmpInst &I) {\n  // This fold is only valid for equality predicates.\n  if (!I.isEquality())\n    return nullptr;\n  ICmpInst::Predicate Pred;\n  Value *X, *Y, *Zero;\n  if (!match(&I, m_ICmp(Pred, m_OneUse(m_IRem(m_Value(X), m_Value(Y))),\n                        m_CombineAnd(m_Zero(), m_Value(Zero)))))\n    return nullptr;\n  if (!isKnownToBeAPowerOfTwo(Y, /*OrZero*/ true, 0, &I))\n    return nullptr;\n  // This may increase instruction count, we don't enforce that Y is a constant.\n  Value *Mask = Builder.CreateAdd(Y, Constant::getAllOnesValue(Y->getType()));\n  Value *Masked = Builder.CreateAnd(X, Mask);\n  return ICmpInst::Create(Instruction::ICmp, Pred, Masked, Zero);\n}\n\n/// Fold equality-comparison between zero and any (maybe truncated) right-shift\n/// by one-less-than-bitwidth into a sign test on the original value.\nInstruction *InstCombinerImpl::foldSignBitTest(ICmpInst &I) {\n  Instruction *Val;\n  ICmpInst::Predicate Pred;\n  if (!I.isEquality() || !match(&I, m_ICmp(Pred, m_Instruction(Val), m_Zero())))\n    return nullptr;\n\n  Value *X;\n  Type *XTy;\n\n  Constant *C;\n  if (match(Val, m_TruncOrSelf(m_Shr(m_Value(X), m_Constant(C))))) {\n    XTy = X->getType();\n    unsigned XBitWidth = XTy->getScalarSizeInBits();\n    if (!match(C, m_SpecificInt_ICMP(ICmpInst::Predicate::ICMP_EQ,\n                                     APInt(XBitWidth, XBitWidth - 1))))\n      return nullptr;\n  } else if (isa<BinaryOperator>(Val) &&\n             (X = reassociateShiftAmtsOfTwoSameDirectionShifts(\n                  cast<BinaryOperator>(Val), SQ.getWithInstruction(Val),\n                  /*AnalyzeForSignBitExtraction=*/true))) {\n    XTy = X->getType();\n  } else\n    return nullptr;\n\n  return ICmpInst::Create(Instruction::ICmp,\n                          Pred == ICmpInst::ICMP_EQ ? ICmpInst::ICMP_SGE\n                                                    : ICmpInst::ICMP_SLT,\n                          X, ConstantInt::getNullValue(XTy));\n}\n\n// Handle  icmp pred X, 0\nInstruction *InstCombinerImpl::foldICmpWithZero(ICmpInst &Cmp) {\n  CmpInst::Predicate Pred = Cmp.getPredicate();\n  if (!match(Cmp.getOperand(1), m_Zero()))\n    return nullptr;\n\n  // (icmp sgt smin(PosA, B) 0) -> (icmp sgt B 0)\n  if (Pred == ICmpInst::ICMP_SGT) {\n    Value *A, *B;\n    SelectPatternResult SPR = matchSelectPattern(Cmp.getOperand(0), A, B);\n    if (SPR.Flavor == SPF_SMIN) {\n      if (isKnownPositive(A, DL, 0, &AC, &Cmp, &DT))\n        return new ICmpInst(Pred, B, Cmp.getOperand(1));\n      if (isKnownPositive(B, DL, 0, &AC, &Cmp, &DT))\n        return new ICmpInst(Pred, A, Cmp.getOperand(1));\n    }\n  }\n\n  if (Instruction *New = foldIRemByPowerOfTwoToBitTest(Cmp))\n    return New;\n\n  // Given:\n  //   icmp eq/ne (urem %x, %y), 0\n  // Iff %x has 0 or 1 bits set, and %y has at least 2 bits set, omit 'urem':\n  //   icmp eq/ne %x, 0\n  Value *X, *Y;\n  if (match(Cmp.getOperand(0), m_URem(m_Value(X), m_Value(Y))) &&\n      ICmpInst::isEquality(Pred)) {\n    KnownBits XKnown = computeKnownBits(X, 0, &Cmp);\n    KnownBits YKnown = computeKnownBits(Y, 0, &Cmp);\n    if (XKnown.countMaxPopulation() == 1 && YKnown.countMinPopulation() >= 2)\n      return new ICmpInst(Pred, X, Cmp.getOperand(1));\n  }\n\n  return nullptr;\n}\n\n/// Fold icmp Pred X, C.\n/// TODO: This code structure does not make sense. The saturating add fold\n/// should be moved to some other helper and extended as noted below (it is also\n/// possible that code has been made unnecessary - do we canonicalize IR to\n/// overflow/saturating intrinsics or not?).\nInstruction *InstCombinerImpl::foldICmpWithConstant(ICmpInst &Cmp) {\n  // Match the following pattern, which is a common idiom when writing\n  // overflow-safe integer arithmetic functions. The source performs an addition\n  // in wider type and explicitly checks for overflow using comparisons against\n  // INT_MIN and INT_MAX. Simplify by using the sadd_with_overflow intrinsic.\n  //\n  // TODO: This could probably be generalized to handle other overflow-safe\n  // operations if we worked out the formulas to compute the appropriate magic\n  // constants.\n  //\n  // sum = a + b\n  // if (sum+128 >u 255)  ...  -> llvm.sadd.with.overflow.i8\n  CmpInst::Predicate Pred = Cmp.getPredicate();\n  Value *Op0 = Cmp.getOperand(0), *Op1 = Cmp.getOperand(1);\n  Value *A, *B;\n  ConstantInt *CI, *CI2; // I = icmp ugt (add (add A, B), CI2), CI\n  if (Pred == ICmpInst::ICMP_UGT && match(Op1, m_ConstantInt(CI)) &&\n      match(Op0, m_Add(m_Add(m_Value(A), m_Value(B)), m_ConstantInt(CI2))))\n    if (Instruction *Res = processUGT_ADDCST_ADD(Cmp, A, B, CI2, CI, *this))\n      return Res;\n\n  // icmp(phi(C1, C2, ...), C) -> phi(icmp(C1, C), icmp(C2, C), ...).\n  Constant *C = dyn_cast<Constant>(Op1);\n  if (!C)\n    return nullptr;\n\n  if (auto *Phi = dyn_cast<PHINode>(Op0))\n    if (all_of(Phi->operands(), [](Value *V) { return isa<Constant>(V); })) {\n      Type *Ty = Cmp.getType();\n      Builder.SetInsertPoint(Phi);\n      PHINode *NewPhi =\n          Builder.CreatePHI(Ty, Phi->getNumOperands());\n      for (BasicBlock *Predecessor : predecessors(Phi->getParent())) {\n        auto *Input =\n            cast<Constant>(Phi->getIncomingValueForBlock(Predecessor));\n        auto *BoolInput = ConstantExpr::getCompare(Pred, Input, C);\n        NewPhi->addIncoming(BoolInput, Predecessor);\n      }\n      NewPhi->takeName(&Cmp);\n      return replaceInstUsesWith(Cmp, NewPhi);\n    }\n\n  return nullptr;\n}\n\n/// Canonicalize icmp instructions based on dominating conditions.\nInstruction *InstCombinerImpl::foldICmpWithDominatingICmp(ICmpInst &Cmp) {\n  // This is a cheap/incomplete check for dominance - just match a single\n  // predecessor with a conditional branch.\n  BasicBlock *CmpBB = Cmp.getParent();\n  BasicBlock *DomBB = CmpBB->getSinglePredecessor();\n  if (!DomBB)\n    return nullptr;\n\n  Value *DomCond;\n  BasicBlock *TrueBB, *FalseBB;\n  if (!match(DomBB->getTerminator(), m_Br(m_Value(DomCond), TrueBB, FalseBB)))\n    return nullptr;\n\n  assert((TrueBB == CmpBB || FalseBB == CmpBB) &&\n         \"Predecessor block does not point to successor?\");\n\n  // The branch should get simplified. Don't bother simplifying this condition.\n  if (TrueBB == FalseBB)\n    return nullptr;\n\n  // Try to simplify this compare to T/F based on the dominating condition.\n  Optional<bool> Imp = isImpliedCondition(DomCond, &Cmp, DL, TrueBB == CmpBB);\n  if (Imp)\n    return replaceInstUsesWith(Cmp, ConstantInt::get(Cmp.getType(), *Imp));\n\n  CmpInst::Predicate Pred = Cmp.getPredicate();\n  Value *X = Cmp.getOperand(0), *Y = Cmp.getOperand(1);\n  ICmpInst::Predicate DomPred;\n  const APInt *C, *DomC;\n  if (match(DomCond, m_ICmp(DomPred, m_Specific(X), m_APInt(DomC))) &&\n      match(Y, m_APInt(C))) {\n    // We have 2 compares of a variable with constants. Calculate the constant\n    // ranges of those compares to see if we can transform the 2nd compare:\n    // DomBB:\n    //   DomCond = icmp DomPred X, DomC\n    //   br DomCond, CmpBB, FalseBB\n    // CmpBB:\n    //   Cmp = icmp Pred X, C\n    ConstantRange CR = ConstantRange::makeAllowedICmpRegion(Pred, *C);\n    ConstantRange DominatingCR =\n        (CmpBB == TrueBB) ? ConstantRange::makeExactICmpRegion(DomPred, *DomC)\n                          : ConstantRange::makeExactICmpRegion(\n                                CmpInst::getInversePredicate(DomPred), *DomC);\n    ConstantRange Intersection = DominatingCR.intersectWith(CR);\n    ConstantRange Difference = DominatingCR.difference(CR);\n    if (Intersection.isEmptySet())\n      return replaceInstUsesWith(Cmp, Builder.getFalse());\n    if (Difference.isEmptySet())\n      return replaceInstUsesWith(Cmp, Builder.getTrue());\n\n    // Canonicalizing a sign bit comparison that gets used in a branch,\n    // pessimizes codegen by generating branch on zero instruction instead\n    // of a test and branch. So we avoid canonicalizing in such situations\n    // because test and branch instruction has better branch displacement\n    // than compare and branch instruction.\n    bool UnusedBit;\n    bool IsSignBit = isSignBitCheck(Pred, *C, UnusedBit);\n    if (Cmp.isEquality() || (IsSignBit && hasBranchUse(Cmp)))\n      return nullptr;\n\n    if (const APInt *EqC = Intersection.getSingleElement())\n      return new ICmpInst(ICmpInst::ICMP_EQ, X, Builder.getInt(*EqC));\n    if (const APInt *NeC = Difference.getSingleElement())\n      return new ICmpInst(ICmpInst::ICMP_NE, X, Builder.getInt(*NeC));\n  }\n\n  return nullptr;\n}\n\n/// Fold icmp (trunc X, Y), C.\nInstruction *InstCombinerImpl::foldICmpTruncConstant(ICmpInst &Cmp,\n                                                     TruncInst *Trunc,\n                                                     const APInt &C) {\n  ICmpInst::Predicate Pred = Cmp.getPredicate();\n  Value *X = Trunc->getOperand(0);\n  if (C.isOneValue() && C.getBitWidth() > 1) {\n    // icmp slt trunc(signum(V)) 1 --> icmp slt V, 1\n    Value *V = nullptr;\n    if (Pred == ICmpInst::ICMP_SLT && match(X, m_Signum(m_Value(V))))\n      return new ICmpInst(ICmpInst::ICMP_SLT, V,\n                          ConstantInt::get(V->getType(), 1));\n  }\n\n  if (Cmp.isEquality() && Trunc->hasOneUse()) {\n    // Simplify icmp eq (trunc x to i8), 42 -> icmp eq x, 42|highbits if all\n    // of the high bits truncated out of x are known.\n    unsigned DstBits = Trunc->getType()->getScalarSizeInBits(),\n             SrcBits = X->getType()->getScalarSizeInBits();\n    KnownBits Known = computeKnownBits(X, 0, &Cmp);\n\n    // If all the high bits are known, we can do this xform.\n    if ((Known.Zero | Known.One).countLeadingOnes() >= SrcBits - DstBits) {\n      // Pull in the high bits from known-ones set.\n      APInt NewRHS = C.zext(SrcBits);\n      NewRHS |= Known.One & APInt::getHighBitsSet(SrcBits, SrcBits - DstBits);\n      return new ICmpInst(Pred, X, ConstantInt::get(X->getType(), NewRHS));\n    }\n  }\n\n  return nullptr;\n}\n\n/// Fold icmp (xor X, Y), C.\nInstruction *InstCombinerImpl::foldICmpXorConstant(ICmpInst &Cmp,\n                                                   BinaryOperator *Xor,\n                                                   const APInt &C) {\n  Value *X = Xor->getOperand(0);\n  Value *Y = Xor->getOperand(1);\n  const APInt *XorC;\n  if (!match(Y, m_APInt(XorC)))\n    return nullptr;\n\n  // If this is a comparison that tests the signbit (X < 0) or (x > -1),\n  // fold the xor.\n  ICmpInst::Predicate Pred = Cmp.getPredicate();\n  bool TrueIfSigned = false;\n  if (isSignBitCheck(Cmp.getPredicate(), C, TrueIfSigned)) {\n\n    // If the sign bit of the XorCst is not set, there is no change to\n    // the operation, just stop using the Xor.\n    if (!XorC->isNegative())\n      return replaceOperand(Cmp, 0, X);\n\n    // Emit the opposite comparison.\n    if (TrueIfSigned)\n      return new ICmpInst(ICmpInst::ICMP_SGT, X,\n                          ConstantInt::getAllOnesValue(X->getType()));\n    else\n      return new ICmpInst(ICmpInst::ICMP_SLT, X,\n                          ConstantInt::getNullValue(X->getType()));\n  }\n\n  if (Xor->hasOneUse()) {\n    // (icmp u/s (xor X SignMask), C) -> (icmp s/u X, (xor C SignMask))\n    if (!Cmp.isEquality() && XorC->isSignMask()) {\n      Pred = Cmp.getFlippedSignednessPredicate();\n      return new ICmpInst(Pred, X, ConstantInt::get(X->getType(), C ^ *XorC));\n    }\n\n    // (icmp u/s (xor X ~SignMask), C) -> (icmp s/u X, (xor C ~SignMask))\n    if (!Cmp.isEquality() && XorC->isMaxSignedValue()) {\n      Pred = Cmp.getFlippedSignednessPredicate();\n      Pred = Cmp.getSwappedPredicate(Pred);\n      return new ICmpInst(Pred, X, ConstantInt::get(X->getType(), C ^ *XorC));\n    }\n  }\n\n  // Mask constant magic can eliminate an 'xor' with unsigned compares.\n  if (Pred == ICmpInst::ICMP_UGT) {\n    // (xor X, ~C) >u C --> X <u ~C (when C+1 is a power of 2)\n    if (*XorC == ~C && (C + 1).isPowerOf2())\n      return new ICmpInst(ICmpInst::ICMP_ULT, X, Y);\n    // (xor X, C) >u C --> X >u C (when C+1 is a power of 2)\n    if (*XorC == C && (C + 1).isPowerOf2())\n      return new ICmpInst(ICmpInst::ICMP_UGT, X, Y);\n  }\n  if (Pred == ICmpInst::ICMP_ULT) {\n    // (xor X, -C) <u C --> X >u ~C (when C is a power of 2)\n    if (*XorC == -C && C.isPowerOf2())\n      return new ICmpInst(ICmpInst::ICMP_UGT, X,\n                          ConstantInt::get(X->getType(), ~C));\n    // (xor X, C) <u C --> X >u ~C (when -C is a power of 2)\n    if (*XorC == C && (-C).isPowerOf2())\n      return new ICmpInst(ICmpInst::ICMP_UGT, X,\n                          ConstantInt::get(X->getType(), ~C));\n  }\n  return nullptr;\n}\n\n/// Fold icmp (and (sh X, Y), C2), C1.\nInstruction *InstCombinerImpl::foldICmpAndShift(ICmpInst &Cmp,\n                                                BinaryOperator *And,\n                                                const APInt &C1,\n                                                const APInt &C2) {\n  BinaryOperator *Shift = dyn_cast<BinaryOperator>(And->getOperand(0));\n  if (!Shift || !Shift->isShift())\n    return nullptr;\n\n  // If this is: (X >> C3) & C2 != C1 (where any shift and any compare could\n  // exist), turn it into (X & (C2 << C3)) != (C1 << C3). This happens a LOT in\n  // code produced by the clang front-end, for bitfield access.\n  // This seemingly simple opportunity to fold away a shift turns out to be\n  // rather complicated. See PR17827 for details.\n  unsigned ShiftOpcode = Shift->getOpcode();\n  bool IsShl = ShiftOpcode == Instruction::Shl;\n  const APInt *C3;\n  if (match(Shift->getOperand(1), m_APInt(C3))) {\n    APInt NewAndCst, NewCmpCst;\n    bool AnyCmpCstBitsShiftedOut;\n    if (ShiftOpcode == Instruction::Shl) {\n      // For a left shift, we can fold if the comparison is not signed. We can\n      // also fold a signed comparison if the mask value and comparison value\n      // are not negative. These constraints may not be obvious, but we can\n      // prove that they are correct using an SMT solver.\n      if (Cmp.isSigned() && (C2.isNegative() || C1.isNegative()))\n        return nullptr;\n\n      NewCmpCst = C1.lshr(*C3);\n      NewAndCst = C2.lshr(*C3);\n      AnyCmpCstBitsShiftedOut = NewCmpCst.shl(*C3) != C1;\n    } else if (ShiftOpcode == Instruction::LShr) {\n      // For a logical right shift, we can fold if the comparison is not signed.\n      // We can also fold a signed comparison if the shifted mask value and the\n      // shifted comparison value are not negative. These constraints may not be\n      // obvious, but we can prove that they are correct using an SMT solver.\n      NewCmpCst = C1.shl(*C3);\n      NewAndCst = C2.shl(*C3);\n      AnyCmpCstBitsShiftedOut = NewCmpCst.lshr(*C3) != C1;\n      if (Cmp.isSigned() && (NewAndCst.isNegative() || NewCmpCst.isNegative()))\n        return nullptr;\n    } else {\n      // For an arithmetic shift, check that both constants don't use (in a\n      // signed sense) the top bits being shifted out.\n      assert(ShiftOpcode == Instruction::AShr && \"Unknown shift opcode\");\n      NewCmpCst = C1.shl(*C3);\n      NewAndCst = C2.shl(*C3);\n      AnyCmpCstBitsShiftedOut = NewCmpCst.ashr(*C3) != C1;\n      if (NewAndCst.ashr(*C3) != C2)\n        return nullptr;\n    }\n\n    if (AnyCmpCstBitsShiftedOut) {\n      // If we shifted bits out, the fold is not going to work out. As a\n      // special case, check to see if this means that the result is always\n      // true or false now.\n      if (Cmp.getPredicate() == ICmpInst::ICMP_EQ)\n        return replaceInstUsesWith(Cmp, ConstantInt::getFalse(Cmp.getType()));\n      if (Cmp.getPredicate() == ICmpInst::ICMP_NE)\n        return replaceInstUsesWith(Cmp, ConstantInt::getTrue(Cmp.getType()));\n    } else {\n      Value *NewAnd = Builder.CreateAnd(\n          Shift->getOperand(0), ConstantInt::get(And->getType(), NewAndCst));\n      return new ICmpInst(Cmp.getPredicate(),\n          NewAnd, ConstantInt::get(And->getType(), NewCmpCst));\n    }\n  }\n\n  // Turn ((X >> Y) & C2) == 0  into  (X & (C2 << Y)) == 0.  The latter is\n  // preferable because it allows the C2 << Y expression to be hoisted out of a\n  // loop if Y is invariant and X is not.\n  if (Shift->hasOneUse() && C1.isNullValue() && Cmp.isEquality() &&\n      !Shift->isArithmeticShift() && !isa<Constant>(Shift->getOperand(0))) {\n    // Compute C2 << Y.\n    Value *NewShift =\n        IsShl ? Builder.CreateLShr(And->getOperand(1), Shift->getOperand(1))\n              : Builder.CreateShl(And->getOperand(1), Shift->getOperand(1));\n\n    // Compute X & (C2 << Y).\n    Value *NewAnd = Builder.CreateAnd(Shift->getOperand(0), NewShift);\n    return replaceOperand(Cmp, 0, NewAnd);\n  }\n\n  return nullptr;\n}\n\n/// Fold icmp (and X, C2), C1.\nInstruction *InstCombinerImpl::foldICmpAndConstConst(ICmpInst &Cmp,\n                                                     BinaryOperator *And,\n                                                     const APInt &C1) {\n  bool isICMP_NE = Cmp.getPredicate() == ICmpInst::ICMP_NE;\n\n  // For vectors: icmp ne (and X, 1), 0 --> trunc X to N x i1\n  // TODO: We canonicalize to the longer form for scalars because we have\n  // better analysis/folds for icmp, and codegen may be better with icmp.\n  if (isICMP_NE && Cmp.getType()->isVectorTy() && C1.isNullValue() &&\n      match(And->getOperand(1), m_One()))\n    return new TruncInst(And->getOperand(0), Cmp.getType());\n\n  const APInt *C2;\n  Value *X;\n  if (!match(And, m_And(m_Value(X), m_APInt(C2))))\n    return nullptr;\n\n  // Don't perform the following transforms if the AND has multiple uses\n  if (!And->hasOneUse())\n    return nullptr;\n\n  if (Cmp.isEquality() && C1.isNullValue()) {\n    // Restrict this fold to single-use 'and' (PR10267).\n    // Replace (and X, (1 << size(X)-1) != 0) with X s< 0\n    if (C2->isSignMask()) {\n      Constant *Zero = Constant::getNullValue(X->getType());\n      auto NewPred = isICMP_NE ? ICmpInst::ICMP_SLT : ICmpInst::ICMP_SGE;\n      return new ICmpInst(NewPred, X, Zero);\n    }\n\n    // Restrict this fold only for single-use 'and' (PR10267).\n    // ((%x & C) == 0) --> %x u< (-C)  iff (-C) is power of two.\n    if ((~(*C2) + 1).isPowerOf2()) {\n      Constant *NegBOC =\n          ConstantExpr::getNeg(cast<Constant>(And->getOperand(1)));\n      auto NewPred = isICMP_NE ? ICmpInst::ICMP_UGE : ICmpInst::ICMP_ULT;\n      return new ICmpInst(NewPred, X, NegBOC);\n    }\n  }\n\n  // If the LHS is an 'and' of a truncate and we can widen the and/compare to\n  // the input width without changing the value produced, eliminate the cast:\n  //\n  // icmp (and (trunc W), C2), C1 -> icmp (and W, C2'), C1'\n  //\n  // We can do this transformation if the constants do not have their sign bits\n  // set or if it is an equality comparison. Extending a relational comparison\n  // when we're checking the sign bit would not work.\n  Value *W;\n  if (match(And->getOperand(0), m_OneUse(m_Trunc(m_Value(W)))) &&\n      (Cmp.isEquality() || (!C1.isNegative() && !C2->isNegative()))) {\n    // TODO: Is this a good transform for vectors? Wider types may reduce\n    // throughput. Should this transform be limited (even for scalars) by using\n    // shouldChangeType()?\n    if (!Cmp.getType()->isVectorTy()) {\n      Type *WideType = W->getType();\n      unsigned WideScalarBits = WideType->getScalarSizeInBits();\n      Constant *ZextC1 = ConstantInt::get(WideType, C1.zext(WideScalarBits));\n      Constant *ZextC2 = ConstantInt::get(WideType, C2->zext(WideScalarBits));\n      Value *NewAnd = Builder.CreateAnd(W, ZextC2, And->getName());\n      return new ICmpInst(Cmp.getPredicate(), NewAnd, ZextC1);\n    }\n  }\n\n  if (Instruction *I = foldICmpAndShift(Cmp, And, C1, *C2))\n    return I;\n\n  // (icmp pred (and (or (lshr A, B), A), 1), 0) -->\n  // (icmp pred (and A, (or (shl 1, B), 1), 0))\n  //\n  // iff pred isn't signed\n  if (!Cmp.isSigned() && C1.isNullValue() && And->getOperand(0)->hasOneUse() &&\n      match(And->getOperand(1), m_One())) {\n    Constant *One = cast<Constant>(And->getOperand(1));\n    Value *Or = And->getOperand(0);\n    Value *A, *B, *LShr;\n    if (match(Or, m_Or(m_Value(LShr), m_Value(A))) &&\n        match(LShr, m_LShr(m_Specific(A), m_Value(B)))) {\n      unsigned UsesRemoved = 0;\n      if (And->hasOneUse())\n        ++UsesRemoved;\n      if (Or->hasOneUse())\n        ++UsesRemoved;\n      if (LShr->hasOneUse())\n        ++UsesRemoved;\n\n      // Compute A & ((1 << B) | 1)\n      Value *NewOr = nullptr;\n      if (auto *C = dyn_cast<Constant>(B)) {\n        if (UsesRemoved >= 1)\n          NewOr = ConstantExpr::getOr(ConstantExpr::getNUWShl(One, C), One);\n      } else {\n        if (UsesRemoved >= 3)\n          NewOr = Builder.CreateOr(Builder.CreateShl(One, B, LShr->getName(),\n                                                     /*HasNUW=*/true),\n                                   One, Or->getName());\n      }\n      if (NewOr) {\n        Value *NewAnd = Builder.CreateAnd(A, NewOr, And->getName());\n        return replaceOperand(Cmp, 0, NewAnd);\n      }\n    }\n  }\n\n  return nullptr;\n}\n\n/// Fold icmp (and X, Y), C.\nInstruction *InstCombinerImpl::foldICmpAndConstant(ICmpInst &Cmp,\n                                                   BinaryOperator *And,\n                                                   const APInt &C) {\n  if (Instruction *I = foldICmpAndConstConst(Cmp, And, C))\n    return I;\n\n  // TODO: These all require that Y is constant too, so refactor with the above.\n\n  // Try to optimize things like \"A[i] & 42 == 0\" to index computations.\n  Value *X = And->getOperand(0);\n  Value *Y = And->getOperand(1);\n  if (auto *LI = dyn_cast<LoadInst>(X))\n    if (auto *GEP = dyn_cast<GetElementPtrInst>(LI->getOperand(0)))\n      if (auto *GV = dyn_cast<GlobalVariable>(GEP->getOperand(0)))\n        if (GV->isConstant() && GV->hasDefinitiveInitializer() &&\n            !LI->isVolatile() && isa<ConstantInt>(Y)) {\n          ConstantInt *C2 = cast<ConstantInt>(Y);\n          if (Instruction *Res = foldCmpLoadFromIndexedGlobal(GEP, GV, Cmp, C2))\n            return Res;\n        }\n\n  if (!Cmp.isEquality())\n    return nullptr;\n\n  // X & -C == -C -> X >  u ~C\n  // X & -C != -C -> X <= u ~C\n  //   iff C is a power of 2\n  if (Cmp.getOperand(1) == Y && (-C).isPowerOf2()) {\n    auto NewPred = Cmp.getPredicate() == CmpInst::ICMP_EQ ? CmpInst::ICMP_UGT\n                                                          : CmpInst::ICMP_ULE;\n    return new ICmpInst(NewPred, X, SubOne(cast<Constant>(Cmp.getOperand(1))));\n  }\n\n  // (X & C2) == 0 -> (trunc X) >= 0\n  // (X & C2) != 0 -> (trunc X) <  0\n  //   iff C2 is a power of 2 and it masks the sign bit of a legal integer type.\n  const APInt *C2;\n  if (And->hasOneUse() && C.isNullValue() && match(Y, m_APInt(C2))) {\n    int32_t ExactLogBase2 = C2->exactLogBase2();\n    if (ExactLogBase2 != -1 && DL.isLegalInteger(ExactLogBase2 + 1)) {\n      Type *NTy = IntegerType::get(Cmp.getContext(), ExactLogBase2 + 1);\n      if (auto *AndVTy = dyn_cast<VectorType>(And->getType()))\n        NTy = VectorType::get(NTy, AndVTy->getElementCount());\n      Value *Trunc = Builder.CreateTrunc(X, NTy);\n      auto NewPred = Cmp.getPredicate() == CmpInst::ICMP_EQ ? CmpInst::ICMP_SGE\n                                                            : CmpInst::ICMP_SLT;\n      return new ICmpInst(NewPred, Trunc, Constant::getNullValue(NTy));\n    }\n  }\n\n  return nullptr;\n}\n\n/// Fold icmp (or X, Y), C.\nInstruction *InstCombinerImpl::foldICmpOrConstant(ICmpInst &Cmp,\n                                                  BinaryOperator *Or,\n                                                  const APInt &C) {\n  ICmpInst::Predicate Pred = Cmp.getPredicate();\n  if (C.isOneValue()) {\n    // icmp slt signum(V) 1 --> icmp slt V, 1\n    Value *V = nullptr;\n    if (Pred == ICmpInst::ICMP_SLT && match(Or, m_Signum(m_Value(V))))\n      return new ICmpInst(ICmpInst::ICMP_SLT, V,\n                          ConstantInt::get(V->getType(), 1));\n  }\n\n  Value *OrOp0 = Or->getOperand(0), *OrOp1 = Or->getOperand(1);\n  const APInt *MaskC;\n  if (match(OrOp1, m_APInt(MaskC)) && Cmp.isEquality()) {\n    if (*MaskC == C && (C + 1).isPowerOf2()) {\n      // X | C == C --> X <=u C\n      // X | C != C --> X  >u C\n      //   iff C+1 is a power of 2 (C is a bitmask of the low bits)\n      Pred = (Pred == CmpInst::ICMP_EQ) ? CmpInst::ICMP_ULE : CmpInst::ICMP_UGT;\n      return new ICmpInst(Pred, OrOp0, OrOp1);\n    }\n\n    // More general: canonicalize 'equality with set bits mask' to\n    // 'equality with clear bits mask'.\n    // (X | MaskC) == C --> (X & ~MaskC) == C ^ MaskC\n    // (X | MaskC) != C --> (X & ~MaskC) != C ^ MaskC\n    if (Or->hasOneUse()) {\n      Value *And = Builder.CreateAnd(OrOp0, ~(*MaskC));\n      Constant *NewC = ConstantInt::get(Or->getType(), C ^ (*MaskC));\n      return new ICmpInst(Pred, And, NewC);\n    }\n  }\n\n  if (!Cmp.isEquality() || !C.isNullValue() || !Or->hasOneUse())\n    return nullptr;\n\n  Value *P, *Q;\n  if (match(Or, m_Or(m_PtrToInt(m_Value(P)), m_PtrToInt(m_Value(Q))))) {\n    // Simplify icmp eq (or (ptrtoint P), (ptrtoint Q)), 0\n    // -> and (icmp eq P, null), (icmp eq Q, null).\n    Value *CmpP =\n        Builder.CreateICmp(Pred, P, ConstantInt::getNullValue(P->getType()));\n    Value *CmpQ =\n        Builder.CreateICmp(Pred, Q, ConstantInt::getNullValue(Q->getType()));\n    auto BOpc = Pred == CmpInst::ICMP_EQ ? Instruction::And : Instruction::Or;\n    return BinaryOperator::Create(BOpc, CmpP, CmpQ);\n  }\n\n  // Are we using xors to bitwise check for a pair of (in)equalities? Convert to\n  // a shorter form that has more potential to be folded even further.\n  Value *X1, *X2, *X3, *X4;\n  if (match(OrOp0, m_OneUse(m_Xor(m_Value(X1), m_Value(X2)))) &&\n      match(OrOp1, m_OneUse(m_Xor(m_Value(X3), m_Value(X4))))) {\n    // ((X1 ^ X2) || (X3 ^ X4)) == 0 --> (X1 == X2) && (X3 == X4)\n    // ((X1 ^ X2) || (X3 ^ X4)) != 0 --> (X1 != X2) || (X3 != X4)\n    Value *Cmp12 = Builder.CreateICmp(Pred, X1, X2);\n    Value *Cmp34 = Builder.CreateICmp(Pred, X3, X4);\n    auto BOpc = Pred == CmpInst::ICMP_EQ ? Instruction::And : Instruction::Or;\n    return BinaryOperator::Create(BOpc, Cmp12, Cmp34);\n  }\n\n  return nullptr;\n}\n\n/// Fold icmp (mul X, Y), C.\nInstruction *InstCombinerImpl::foldICmpMulConstant(ICmpInst &Cmp,\n                                                   BinaryOperator *Mul,\n                                                   const APInt &C) {\n  const APInt *MulC;\n  if (!match(Mul->getOperand(1), m_APInt(MulC)))\n    return nullptr;\n\n  // If this is a test of the sign bit and the multiply is sign-preserving with\n  // a constant operand, use the multiply LHS operand instead.\n  ICmpInst::Predicate Pred = Cmp.getPredicate();\n  if (isSignTest(Pred, C) && Mul->hasNoSignedWrap()) {\n    if (MulC->isNegative())\n      Pred = ICmpInst::getSwappedPredicate(Pred);\n    return new ICmpInst(Pred, Mul->getOperand(0),\n                        Constant::getNullValue(Mul->getType()));\n  }\n\n  // If the multiply does not wrap, try to divide the compare constant by the\n  // multiplication factor.\n  if (Cmp.isEquality() && !MulC->isNullValue()) {\n    // (mul nsw X, MulC) == C --> X == C /s MulC\n    if (Mul->hasNoSignedWrap() && C.srem(*MulC).isNullValue()) {\n      Constant *NewC = ConstantInt::get(Mul->getType(), C.sdiv(*MulC));\n      return new ICmpInst(Pred, Mul->getOperand(0), NewC);\n    }\n    // (mul nuw X, MulC) == C --> X == C /u MulC\n    if (Mul->hasNoUnsignedWrap() && C.urem(*MulC).isNullValue()) {\n      Constant *NewC = ConstantInt::get(Mul->getType(), C.udiv(*MulC));\n      return new ICmpInst(Pred, Mul->getOperand(0), NewC);\n    }\n  }\n\n  return nullptr;\n}\n\n/// Fold icmp (shl 1, Y), C.\nstatic Instruction *foldICmpShlOne(ICmpInst &Cmp, Instruction *Shl,\n                                   const APInt &C) {\n  Value *Y;\n  if (!match(Shl, m_Shl(m_One(), m_Value(Y))))\n    return nullptr;\n\n  Type *ShiftType = Shl->getType();\n  unsigned TypeBits = C.getBitWidth();\n  bool CIsPowerOf2 = C.isPowerOf2();\n  ICmpInst::Predicate Pred = Cmp.getPredicate();\n  if (Cmp.isUnsigned()) {\n    // (1 << Y) pred C -> Y pred Log2(C)\n    if (!CIsPowerOf2) {\n      // (1 << Y) <  30 -> Y <= 4\n      // (1 << Y) <= 30 -> Y <= 4\n      // (1 << Y) >= 30 -> Y >  4\n      // (1 << Y) >  30 -> Y >  4\n      if (Pred == ICmpInst::ICMP_ULT)\n        Pred = ICmpInst::ICMP_ULE;\n      else if (Pred == ICmpInst::ICMP_UGE)\n        Pred = ICmpInst::ICMP_UGT;\n    }\n\n    // (1 << Y) >= 2147483648 -> Y >= 31 -> Y == 31\n    // (1 << Y) <  2147483648 -> Y <  31 -> Y != 31\n    unsigned CLog2 = C.logBase2();\n    if (CLog2 == TypeBits - 1) {\n      if (Pred == ICmpInst::ICMP_UGE)\n        Pred = ICmpInst::ICMP_EQ;\n      else if (Pred == ICmpInst::ICMP_ULT)\n        Pred = ICmpInst::ICMP_NE;\n    }\n    return new ICmpInst(Pred, Y, ConstantInt::get(ShiftType, CLog2));\n  } else if (Cmp.isSigned()) {\n    Constant *BitWidthMinusOne = ConstantInt::get(ShiftType, TypeBits - 1);\n    if (C.isAllOnesValue()) {\n      // (1 << Y) <= -1 -> Y == 31\n      if (Pred == ICmpInst::ICMP_SLE)\n        return new ICmpInst(ICmpInst::ICMP_EQ, Y, BitWidthMinusOne);\n\n      // (1 << Y) >  -1 -> Y != 31\n      if (Pred == ICmpInst::ICMP_SGT)\n        return new ICmpInst(ICmpInst::ICMP_NE, Y, BitWidthMinusOne);\n    } else if (!C) {\n      // (1 << Y) <  0 -> Y == 31\n      // (1 << Y) <= 0 -> Y == 31\n      if (Pred == ICmpInst::ICMP_SLT || Pred == ICmpInst::ICMP_SLE)\n        return new ICmpInst(ICmpInst::ICMP_EQ, Y, BitWidthMinusOne);\n\n      // (1 << Y) >= 0 -> Y != 31\n      // (1 << Y) >  0 -> Y != 31\n      if (Pred == ICmpInst::ICMP_SGT || Pred == ICmpInst::ICMP_SGE)\n        return new ICmpInst(ICmpInst::ICMP_NE, Y, BitWidthMinusOne);\n    }\n  } else if (Cmp.isEquality() && CIsPowerOf2) {\n    return new ICmpInst(Pred, Y, ConstantInt::get(ShiftType, C.logBase2()));\n  }\n\n  return nullptr;\n}\n\n/// Fold icmp (shl X, Y), C.\nInstruction *InstCombinerImpl::foldICmpShlConstant(ICmpInst &Cmp,\n                                                   BinaryOperator *Shl,\n                                                   const APInt &C) {\n  const APInt *ShiftVal;\n  if (Cmp.isEquality() && match(Shl->getOperand(0), m_APInt(ShiftVal)))\n    return foldICmpShlConstConst(Cmp, Shl->getOperand(1), C, *ShiftVal);\n\n  const APInt *ShiftAmt;\n  if (!match(Shl->getOperand(1), m_APInt(ShiftAmt)))\n    return foldICmpShlOne(Cmp, Shl, C);\n\n  // Check that the shift amount is in range. If not, don't perform undefined\n  // shifts. When the shift is visited, it will be simplified.\n  unsigned TypeBits = C.getBitWidth();\n  if (ShiftAmt->uge(TypeBits))\n    return nullptr;\n\n  ICmpInst::Predicate Pred = Cmp.getPredicate();\n  Value *X = Shl->getOperand(0);\n  Type *ShType = Shl->getType();\n\n  // NSW guarantees that we are only shifting out sign bits from the high bits,\n  // so we can ASHR the compare constant without needing a mask and eliminate\n  // the shift.\n  if (Shl->hasNoSignedWrap()) {\n    if (Pred == ICmpInst::ICMP_SGT) {\n      // icmp Pred (shl nsw X, ShiftAmt), C --> icmp Pred X, (C >>s ShiftAmt)\n      APInt ShiftedC = C.ashr(*ShiftAmt);\n      return new ICmpInst(Pred, X, ConstantInt::get(ShType, ShiftedC));\n    }\n    if ((Pred == ICmpInst::ICMP_EQ || Pred == ICmpInst::ICMP_NE) &&\n        C.ashr(*ShiftAmt).shl(*ShiftAmt) == C) {\n      APInt ShiftedC = C.ashr(*ShiftAmt);\n      return new ICmpInst(Pred, X, ConstantInt::get(ShType, ShiftedC));\n    }\n    if (Pred == ICmpInst::ICMP_SLT) {\n      // SLE is the same as above, but SLE is canonicalized to SLT, so convert:\n      // (X << S) <=s C is equiv to X <=s (C >> S) for all C\n      // (X << S) <s (C + 1) is equiv to X <s (C >> S) + 1 if C <s SMAX\n      // (X << S) <s C is equiv to X <s ((C - 1) >> S) + 1 if C >s SMIN\n      assert(!C.isMinSignedValue() && \"Unexpected icmp slt\");\n      APInt ShiftedC = (C - 1).ashr(*ShiftAmt) + 1;\n      return new ICmpInst(Pred, X, ConstantInt::get(ShType, ShiftedC));\n    }\n    // If this is a signed comparison to 0 and the shift is sign preserving,\n    // use the shift LHS operand instead; isSignTest may change 'Pred', so only\n    // do that if we're sure to not continue on in this function.\n    if (isSignTest(Pred, C))\n      return new ICmpInst(Pred, X, Constant::getNullValue(ShType));\n  }\n\n  // NUW guarantees that we are only shifting out zero bits from the high bits,\n  // so we can LSHR the compare constant without needing a mask and eliminate\n  // the shift.\n  if (Shl->hasNoUnsignedWrap()) {\n    if (Pred == ICmpInst::ICMP_UGT) {\n      // icmp Pred (shl nuw X, ShiftAmt), C --> icmp Pred X, (C >>u ShiftAmt)\n      APInt ShiftedC = C.lshr(*ShiftAmt);\n      return new ICmpInst(Pred, X, ConstantInt::get(ShType, ShiftedC));\n    }\n    if ((Pred == ICmpInst::ICMP_EQ || Pred == ICmpInst::ICMP_NE) &&\n        C.lshr(*ShiftAmt).shl(*ShiftAmt) == C) {\n      APInt ShiftedC = C.lshr(*ShiftAmt);\n      return new ICmpInst(Pred, X, ConstantInt::get(ShType, ShiftedC));\n    }\n    if (Pred == ICmpInst::ICMP_ULT) {\n      // ULE is the same as above, but ULE is canonicalized to ULT, so convert:\n      // (X << S) <=u C is equiv to X <=u (C >> S) for all C\n      // (X << S) <u (C + 1) is equiv to X <u (C >> S) + 1 if C <u ~0u\n      // (X << S) <u C is equiv to X <u ((C - 1) >> S) + 1 if C >u 0\n      assert(C.ugt(0) && \"ult 0 should have been eliminated\");\n      APInt ShiftedC = (C - 1).lshr(*ShiftAmt) + 1;\n      return new ICmpInst(Pred, X, ConstantInt::get(ShType, ShiftedC));\n    }\n  }\n\n  if (Cmp.isEquality() && Shl->hasOneUse()) {\n    // Strength-reduce the shift into an 'and'.\n    Constant *Mask = ConstantInt::get(\n        ShType,\n        APInt::getLowBitsSet(TypeBits, TypeBits - ShiftAmt->getZExtValue()));\n    Value *And = Builder.CreateAnd(X, Mask, Shl->getName() + \".mask\");\n    Constant *LShrC = ConstantInt::get(ShType, C.lshr(*ShiftAmt));\n    return new ICmpInst(Pred, And, LShrC);\n  }\n\n  // Otherwise, if this is a comparison of the sign bit, simplify to and/test.\n  bool TrueIfSigned = false;\n  if (Shl->hasOneUse() && isSignBitCheck(Pred, C, TrueIfSigned)) {\n    // (X << 31) <s 0  --> (X & 1) != 0\n    Constant *Mask = ConstantInt::get(\n        ShType,\n        APInt::getOneBitSet(TypeBits, TypeBits - ShiftAmt->getZExtValue() - 1));\n    Value *And = Builder.CreateAnd(X, Mask, Shl->getName() + \".mask\");\n    return new ICmpInst(TrueIfSigned ? ICmpInst::ICMP_NE : ICmpInst::ICMP_EQ,\n                        And, Constant::getNullValue(ShType));\n  }\n\n  // Simplify 'shl' inequality test into 'and' equality test.\n  if (Cmp.isUnsigned() && Shl->hasOneUse()) {\n    // (X l<< C2) u<=/u> C1 iff C1+1 is power of two -> X & (~C1 l>> C2) ==/!= 0\n    if ((C + 1).isPowerOf2() &&\n        (Pred == ICmpInst::ICMP_ULE || Pred == ICmpInst::ICMP_UGT)) {\n      Value *And = Builder.CreateAnd(X, (~C).lshr(ShiftAmt->getZExtValue()));\n      return new ICmpInst(Pred == ICmpInst::ICMP_ULE ? ICmpInst::ICMP_EQ\n                                                     : ICmpInst::ICMP_NE,\n                          And, Constant::getNullValue(ShType));\n    }\n    // (X l<< C2) u</u>= C1 iff C1 is power of two -> X & (-C1 l>> C2) ==/!= 0\n    if (C.isPowerOf2() &&\n        (Pred == ICmpInst::ICMP_ULT || Pred == ICmpInst::ICMP_UGE)) {\n      Value *And =\n          Builder.CreateAnd(X, (~(C - 1)).lshr(ShiftAmt->getZExtValue()));\n      return new ICmpInst(Pred == ICmpInst::ICMP_ULT ? ICmpInst::ICMP_EQ\n                                                     : ICmpInst::ICMP_NE,\n                          And, Constant::getNullValue(ShType));\n    }\n  }\n\n  // Transform (icmp pred iM (shl iM %v, N), C)\n  // -> (icmp pred i(M-N) (trunc %v iM to i(M-N)), (trunc (C>>N))\n  // Transform the shl to a trunc if (trunc (C>>N)) has no loss and M-N.\n  // This enables us to get rid of the shift in favor of a trunc that may be\n  // free on the target. It has the additional benefit of comparing to a\n  // smaller constant that may be more target-friendly.\n  unsigned Amt = ShiftAmt->getLimitedValue(TypeBits - 1);\n  if (Shl->hasOneUse() && Amt != 0 && C.countTrailingZeros() >= Amt &&\n      DL.isLegalInteger(TypeBits - Amt)) {\n    Type *TruncTy = IntegerType::get(Cmp.getContext(), TypeBits - Amt);\n    if (auto *ShVTy = dyn_cast<VectorType>(ShType))\n      TruncTy = VectorType::get(TruncTy, ShVTy->getElementCount());\n    Constant *NewC =\n        ConstantInt::get(TruncTy, C.ashr(*ShiftAmt).trunc(TypeBits - Amt));\n    return new ICmpInst(Pred, Builder.CreateTrunc(X, TruncTy), NewC);\n  }\n\n  return nullptr;\n}\n\n/// Fold icmp ({al}shr X, Y), C.\nInstruction *InstCombinerImpl::foldICmpShrConstant(ICmpInst &Cmp,\n                                                   BinaryOperator *Shr,\n                                                   const APInt &C) {\n  // An exact shr only shifts out zero bits, so:\n  // icmp eq/ne (shr X, Y), 0 --> icmp eq/ne X, 0\n  Value *X = Shr->getOperand(0);\n  CmpInst::Predicate Pred = Cmp.getPredicate();\n  if (Cmp.isEquality() && Shr->isExact() && Shr->hasOneUse() &&\n      C.isNullValue())\n    return new ICmpInst(Pred, X, Cmp.getOperand(1));\n\n  const APInt *ShiftVal;\n  if (Cmp.isEquality() && match(Shr->getOperand(0), m_APInt(ShiftVal)))\n    return foldICmpShrConstConst(Cmp, Shr->getOperand(1), C, *ShiftVal);\n\n  const APInt *ShiftAmt;\n  if (!match(Shr->getOperand(1), m_APInt(ShiftAmt)))\n    return nullptr;\n\n  // Check that the shift amount is in range. If not, don't perform undefined\n  // shifts. When the shift is visited it will be simplified.\n  unsigned TypeBits = C.getBitWidth();\n  unsigned ShAmtVal = ShiftAmt->getLimitedValue(TypeBits);\n  if (ShAmtVal >= TypeBits || ShAmtVal == 0)\n    return nullptr;\n\n  bool IsAShr = Shr->getOpcode() == Instruction::AShr;\n  bool IsExact = Shr->isExact();\n  Type *ShrTy = Shr->getType();\n  // TODO: If we could guarantee that InstSimplify would handle all of the\n  // constant-value-based preconditions in the folds below, then we could assert\n  // those conditions rather than checking them. This is difficult because of\n  // undef/poison (PR34838).\n  if (IsAShr) {\n    if (Pred == CmpInst::ICMP_SLT || (Pred == CmpInst::ICMP_SGT && IsExact)) {\n      // icmp slt (ashr X, ShAmtC), C --> icmp slt X, (C << ShAmtC)\n      // icmp sgt (ashr exact X, ShAmtC), C --> icmp sgt X, (C << ShAmtC)\n      APInt ShiftedC = C.shl(ShAmtVal);\n      if (ShiftedC.ashr(ShAmtVal) == C)\n        return new ICmpInst(Pred, X, ConstantInt::get(ShrTy, ShiftedC));\n    }\n    if (Pred == CmpInst::ICMP_SGT) {\n      // icmp sgt (ashr X, ShAmtC), C --> icmp sgt X, ((C + 1) << ShAmtC) - 1\n      APInt ShiftedC = (C + 1).shl(ShAmtVal) - 1;\n      if (!C.isMaxSignedValue() && !(C + 1).shl(ShAmtVal).isMinSignedValue() &&\n          (ShiftedC + 1).ashr(ShAmtVal) == (C + 1))\n        return new ICmpInst(Pred, X, ConstantInt::get(ShrTy, ShiftedC));\n    }\n\n    // If the compare constant has significant bits above the lowest sign-bit,\n    // then convert an unsigned cmp to a test of the sign-bit:\n    // (ashr X, ShiftC) u> C --> X s< 0\n    // (ashr X, ShiftC) u< C --> X s> -1\n    if (C.getBitWidth() > 2 && C.getNumSignBits() <= ShAmtVal) {\n      if (Pred == CmpInst::ICMP_UGT) {\n        return new ICmpInst(CmpInst::ICMP_SLT, X,\n                            ConstantInt::getNullValue(ShrTy));\n      }\n      if (Pred == CmpInst::ICMP_ULT) {\n        return new ICmpInst(CmpInst::ICMP_SGT, X,\n                            ConstantInt::getAllOnesValue(ShrTy));\n      }\n    }\n  } else {\n    if (Pred == CmpInst::ICMP_ULT || (Pred == CmpInst::ICMP_UGT && IsExact)) {\n      // icmp ult (lshr X, ShAmtC), C --> icmp ult X, (C << ShAmtC)\n      // icmp ugt (lshr exact X, ShAmtC), C --> icmp ugt X, (C << ShAmtC)\n      APInt ShiftedC = C.shl(ShAmtVal);\n      if (ShiftedC.lshr(ShAmtVal) == C)\n        return new ICmpInst(Pred, X, ConstantInt::get(ShrTy, ShiftedC));\n    }\n    if (Pred == CmpInst::ICMP_UGT) {\n      // icmp ugt (lshr X, ShAmtC), C --> icmp ugt X, ((C + 1) << ShAmtC) - 1\n      APInt ShiftedC = (C + 1).shl(ShAmtVal) - 1;\n      if ((ShiftedC + 1).lshr(ShAmtVal) == (C + 1))\n        return new ICmpInst(Pred, X, ConstantInt::get(ShrTy, ShiftedC));\n    }\n  }\n\n  if (!Cmp.isEquality())\n    return nullptr;\n\n  // Handle equality comparisons of shift-by-constant.\n\n  // If the comparison constant changes with the shift, the comparison cannot\n  // succeed (bits of the comparison constant cannot match the shifted value).\n  // This should be known by InstSimplify and already be folded to true/false.\n  assert(((IsAShr && C.shl(ShAmtVal).ashr(ShAmtVal) == C) ||\n          (!IsAShr && C.shl(ShAmtVal).lshr(ShAmtVal) == C)) &&\n         \"Expected icmp+shr simplify did not occur.\");\n\n  // If the bits shifted out are known zero, compare the unshifted value:\n  //  (X & 4) >> 1 == 2  --> (X & 4) == 4.\n  if (Shr->isExact())\n    return new ICmpInst(Pred, X, ConstantInt::get(ShrTy, C << ShAmtVal));\n\n  if (Shr->hasOneUse()) {\n    // Canonicalize the shift into an 'and':\n    // icmp eq/ne (shr X, ShAmt), C --> icmp eq/ne (and X, HiMask), (C << ShAmt)\n    APInt Val(APInt::getHighBitsSet(TypeBits, TypeBits - ShAmtVal));\n    Constant *Mask = ConstantInt::get(ShrTy, Val);\n    Value *And = Builder.CreateAnd(X, Mask, Shr->getName() + \".mask\");\n    return new ICmpInst(Pred, And, ConstantInt::get(ShrTy, C << ShAmtVal));\n  }\n\n  return nullptr;\n}\n\nInstruction *InstCombinerImpl::foldICmpSRemConstant(ICmpInst &Cmp,\n                                                    BinaryOperator *SRem,\n                                                    const APInt &C) {\n  // Match an 'is positive' or 'is negative' comparison of remainder by a\n  // constant power-of-2 value:\n  // (X % pow2C) sgt/slt 0\n  const ICmpInst::Predicate Pred = Cmp.getPredicate();\n  if (Pred != ICmpInst::ICMP_SGT && Pred != ICmpInst::ICMP_SLT)\n    return nullptr;\n\n  // TODO: The one-use check is standard because we do not typically want to\n  //       create longer instruction sequences, but this might be a special-case\n  //       because srem is not good for analysis or codegen.\n  if (!SRem->hasOneUse())\n    return nullptr;\n\n  const APInt *DivisorC;\n  if (!C.isNullValue() || !match(SRem->getOperand(1), m_Power2(DivisorC)))\n    return nullptr;\n\n  // Mask off the sign bit and the modulo bits (low-bits).\n  Type *Ty = SRem->getType();\n  APInt SignMask = APInt::getSignMask(Ty->getScalarSizeInBits());\n  Constant *MaskC = ConstantInt::get(Ty, SignMask | (*DivisorC - 1));\n  Value *And = Builder.CreateAnd(SRem->getOperand(0), MaskC);\n\n  // For 'is positive?' check that the sign-bit is clear and at least 1 masked\n  // bit is set. Example:\n  // (i8 X % 32) s> 0 --> (X & 159) s> 0\n  if (Pred == ICmpInst::ICMP_SGT)\n    return new ICmpInst(ICmpInst::ICMP_SGT, And, ConstantInt::getNullValue(Ty));\n\n  // For 'is negative?' check that the sign-bit is set and at least 1 masked\n  // bit is set. Example:\n  // (i16 X % 4) s< 0 --> (X & 32771) u> 32768\n  return new ICmpInst(ICmpInst::ICMP_UGT, And, ConstantInt::get(Ty, SignMask));\n}\n\n/// Fold icmp (udiv X, Y), C.\nInstruction *InstCombinerImpl::foldICmpUDivConstant(ICmpInst &Cmp,\n                                                    BinaryOperator *UDiv,\n                                                    const APInt &C) {\n  const APInt *C2;\n  if (!match(UDiv->getOperand(0), m_APInt(C2)))\n    return nullptr;\n\n  assert(*C2 != 0 && \"udiv 0, X should have been simplified already.\");\n\n  // (icmp ugt (udiv C2, Y), C) -> (icmp ule Y, C2/(C+1))\n  Value *Y = UDiv->getOperand(1);\n  if (Cmp.getPredicate() == ICmpInst::ICMP_UGT) {\n    assert(!C.isMaxValue() &&\n           \"icmp ugt X, UINT_MAX should have been simplified already.\");\n    return new ICmpInst(ICmpInst::ICMP_ULE, Y,\n                        ConstantInt::get(Y->getType(), C2->udiv(C + 1)));\n  }\n\n  // (icmp ult (udiv C2, Y), C) -> (icmp ugt Y, C2/C)\n  if (Cmp.getPredicate() == ICmpInst::ICMP_ULT) {\n    assert(C != 0 && \"icmp ult X, 0 should have been simplified already.\");\n    return new ICmpInst(ICmpInst::ICMP_UGT, Y,\n                        ConstantInt::get(Y->getType(), C2->udiv(C)));\n  }\n\n  return nullptr;\n}\n\n/// Fold icmp ({su}div X, Y), C.\nInstruction *InstCombinerImpl::foldICmpDivConstant(ICmpInst &Cmp,\n                                                   BinaryOperator *Div,\n                                                   const APInt &C) {\n  // Fold: icmp pred ([us]div X, C2), C -> range test\n  // Fold this div into the comparison, producing a range check.\n  // Determine, based on the divide type, what the range is being\n  // checked.  If there is an overflow on the low or high side, remember\n  // it, otherwise compute the range [low, hi) bounding the new value.\n  // See: InsertRangeTest above for the kinds of replacements possible.\n  const APInt *C2;\n  if (!match(Div->getOperand(1), m_APInt(C2)))\n    return nullptr;\n\n  // FIXME: If the operand types don't match the type of the divide\n  // then don't attempt this transform. The code below doesn't have the\n  // logic to deal with a signed divide and an unsigned compare (and\n  // vice versa). This is because (x /s C2) <s C  produces different\n  // results than (x /s C2) <u C or (x /u C2) <s C or even\n  // (x /u C2) <u C.  Simply casting the operands and result won't\n  // work. :(  The if statement below tests that condition and bails\n  // if it finds it.\n  bool DivIsSigned = Div->getOpcode() == Instruction::SDiv;\n  if (!Cmp.isEquality() && DivIsSigned != Cmp.isSigned())\n    return nullptr;\n\n  // The ProdOV computation fails on divide by 0 and divide by -1. Cases with\n  // INT_MIN will also fail if the divisor is 1. Although folds of all these\n  // division-by-constant cases should be present, we can not assert that they\n  // have happened before we reach this icmp instruction.\n  if (C2->isNullValue() || C2->isOneValue() ||\n      (DivIsSigned && C2->isAllOnesValue()))\n    return nullptr;\n\n  // Compute Prod = C * C2. We are essentially solving an equation of\n  // form X / C2 = C. We solve for X by multiplying C2 and C.\n  // By solving for X, we can turn this into a range check instead of computing\n  // a divide.\n  APInt Prod = C * *C2;\n\n  // Determine if the product overflows by seeing if the product is not equal to\n  // the divide. Make sure we do the same kind of divide as in the LHS\n  // instruction that we're folding.\n  bool ProdOV = (DivIsSigned ? Prod.sdiv(*C2) : Prod.udiv(*C2)) != C;\n\n  ICmpInst::Predicate Pred = Cmp.getPredicate();\n\n  // If the division is known to be exact, then there is no remainder from the\n  // divide, so the covered range size is unit, otherwise it is the divisor.\n  APInt RangeSize = Div->isExact() ? APInt(C2->getBitWidth(), 1) : *C2;\n\n  // Figure out the interval that is being checked.  For example, a comparison\n  // like \"X /u 5 == 0\" is really checking that X is in the interval [0, 5).\n  // Compute this interval based on the constants involved and the signedness of\n  // the compare/divide.  This computes a half-open interval, keeping track of\n  // whether either value in the interval overflows.  After analysis each\n  // overflow variable is set to 0 if it's corresponding bound variable is valid\n  // -1 if overflowed off the bottom end, or +1 if overflowed off the top end.\n  int LoOverflow = 0, HiOverflow = 0;\n  APInt LoBound, HiBound;\n\n  if (!DivIsSigned) {  // udiv\n    // e.g. X/5 op 3  --> [15, 20)\n    LoBound = Prod;\n    HiOverflow = LoOverflow = ProdOV;\n    if (!HiOverflow) {\n      // If this is not an exact divide, then many values in the range collapse\n      // to the same result value.\n      HiOverflow = addWithOverflow(HiBound, LoBound, RangeSize, false);\n    }\n  } else if (C2->isStrictlyPositive()) { // Divisor is > 0.\n    if (C.isNullValue()) {       // (X / pos) op 0\n      // Can't overflow.  e.g.  X/2 op 0 --> [-1, 2)\n      LoBound = -(RangeSize - 1);\n      HiBound = RangeSize;\n    } else if (C.isStrictlyPositive()) {   // (X / pos) op pos\n      LoBound = Prod;     // e.g.   X/5 op 3 --> [15, 20)\n      HiOverflow = LoOverflow = ProdOV;\n      if (!HiOverflow)\n        HiOverflow = addWithOverflow(HiBound, Prod, RangeSize, true);\n    } else {                       // (X / pos) op neg\n      // e.g. X/5 op -3  --> [-15-4, -15+1) --> [-19, -14)\n      HiBound = Prod + 1;\n      LoOverflow = HiOverflow = ProdOV ? -1 : 0;\n      if (!LoOverflow) {\n        APInt DivNeg = -RangeSize;\n        LoOverflow = addWithOverflow(LoBound, HiBound, DivNeg, true) ? -1 : 0;\n      }\n    }\n  } else if (C2->isNegative()) { // Divisor is < 0.\n    if (Div->isExact())\n      RangeSize.negate();\n    if (C.isNullValue()) { // (X / neg) op 0\n      // e.g. X/-5 op 0  --> [-4, 5)\n      LoBound = RangeSize + 1;\n      HiBound = -RangeSize;\n      if (HiBound == *C2) {        // -INTMIN = INTMIN\n        HiOverflow = 1;            // [INTMIN+1, overflow)\n        HiBound = APInt();         // e.g. X/INTMIN = 0 --> X > INTMIN\n      }\n    } else if (C.isStrictlyPositive()) {   // (X / neg) op pos\n      // e.g. X/-5 op 3  --> [-19, -14)\n      HiBound = Prod + 1;\n      HiOverflow = LoOverflow = ProdOV ? -1 : 0;\n      if (!LoOverflow)\n        LoOverflow = addWithOverflow(LoBound, HiBound, RangeSize, true) ? -1:0;\n    } else {                       // (X / neg) op neg\n      LoBound = Prod;       // e.g. X/-5 op -3  --> [15, 20)\n      LoOverflow = HiOverflow = ProdOV;\n      if (!HiOverflow)\n        HiOverflow = subWithOverflow(HiBound, Prod, RangeSize, true);\n    }\n\n    // Dividing by a negative swaps the condition.  LT <-> GT\n    Pred = ICmpInst::getSwappedPredicate(Pred);\n  }\n\n  Value *X = Div->getOperand(0);\n  switch (Pred) {\n    default: llvm_unreachable(\"Unhandled icmp opcode!\");\n    case ICmpInst::ICMP_EQ:\n      if (LoOverflow && HiOverflow)\n        return replaceInstUsesWith(Cmp, Builder.getFalse());\n      if (HiOverflow)\n        return new ICmpInst(DivIsSigned ? ICmpInst::ICMP_SGE :\n                            ICmpInst::ICMP_UGE, X,\n                            ConstantInt::get(Div->getType(), LoBound));\n      if (LoOverflow)\n        return new ICmpInst(DivIsSigned ? ICmpInst::ICMP_SLT :\n                            ICmpInst::ICMP_ULT, X,\n                            ConstantInt::get(Div->getType(), HiBound));\n      return replaceInstUsesWith(\n          Cmp, insertRangeTest(X, LoBound, HiBound, DivIsSigned, true));\n    case ICmpInst::ICMP_NE:\n      if (LoOverflow && HiOverflow)\n        return replaceInstUsesWith(Cmp, Builder.getTrue());\n      if (HiOverflow)\n        return new ICmpInst(DivIsSigned ? ICmpInst::ICMP_SLT :\n                            ICmpInst::ICMP_ULT, X,\n                            ConstantInt::get(Div->getType(), LoBound));\n      if (LoOverflow)\n        return new ICmpInst(DivIsSigned ? ICmpInst::ICMP_SGE :\n                            ICmpInst::ICMP_UGE, X,\n                            ConstantInt::get(Div->getType(), HiBound));\n      return replaceInstUsesWith(Cmp,\n                                 insertRangeTest(X, LoBound, HiBound,\n                                                 DivIsSigned, false));\n    case ICmpInst::ICMP_ULT:\n    case ICmpInst::ICMP_SLT:\n      if (LoOverflow == +1)   // Low bound is greater than input range.\n        return replaceInstUsesWith(Cmp, Builder.getTrue());\n      if (LoOverflow == -1)   // Low bound is less than input range.\n        return replaceInstUsesWith(Cmp, Builder.getFalse());\n      return new ICmpInst(Pred, X, ConstantInt::get(Div->getType(), LoBound));\n    case ICmpInst::ICMP_UGT:\n    case ICmpInst::ICMP_SGT:\n      if (HiOverflow == +1)       // High bound greater than input range.\n        return replaceInstUsesWith(Cmp, Builder.getFalse());\n      if (HiOverflow == -1)       // High bound less than input range.\n        return replaceInstUsesWith(Cmp, Builder.getTrue());\n      if (Pred == ICmpInst::ICMP_UGT)\n        return new ICmpInst(ICmpInst::ICMP_UGE, X,\n                            ConstantInt::get(Div->getType(), HiBound));\n      return new ICmpInst(ICmpInst::ICMP_SGE, X,\n                          ConstantInt::get(Div->getType(), HiBound));\n  }\n\n  return nullptr;\n}\n\n/// Fold icmp (sub X, Y), C.\nInstruction *InstCombinerImpl::foldICmpSubConstant(ICmpInst &Cmp,\n                                                   BinaryOperator *Sub,\n                                                   const APInt &C) {\n  Value *X = Sub->getOperand(0), *Y = Sub->getOperand(1);\n  ICmpInst::Predicate Pred = Cmp.getPredicate();\n  const APInt *C2;\n  APInt SubResult;\n\n  // icmp eq/ne (sub C, Y), C -> icmp eq/ne Y, 0\n  if (match(X, m_APInt(C2)) && *C2 == C && Cmp.isEquality())\n    return new ICmpInst(Cmp.getPredicate(), Y,\n                        ConstantInt::get(Y->getType(), 0));\n\n  // (icmp P (sub nuw|nsw C2, Y), C) -> (icmp swap(P) Y, C2-C)\n  if (match(X, m_APInt(C2)) &&\n      ((Cmp.isUnsigned() && Sub->hasNoUnsignedWrap()) ||\n       (Cmp.isSigned() && Sub->hasNoSignedWrap())) &&\n      !subWithOverflow(SubResult, *C2, C, Cmp.isSigned()))\n    return new ICmpInst(Cmp.getSwappedPredicate(), Y,\n                        ConstantInt::get(Y->getType(), SubResult));\n\n  // The following transforms are only worth it if the only user of the subtract\n  // is the icmp.\n  if (!Sub->hasOneUse())\n    return nullptr;\n\n  if (Sub->hasNoSignedWrap()) {\n    // (icmp sgt (sub nsw X, Y), -1) -> (icmp sge X, Y)\n    if (Pred == ICmpInst::ICMP_SGT && C.isAllOnesValue())\n      return new ICmpInst(ICmpInst::ICMP_SGE, X, Y);\n\n    // (icmp sgt (sub nsw X, Y), 0) -> (icmp sgt X, Y)\n    if (Pred == ICmpInst::ICMP_SGT && C.isNullValue())\n      return new ICmpInst(ICmpInst::ICMP_SGT, X, Y);\n\n    // (icmp slt (sub nsw X, Y), 0) -> (icmp slt X, Y)\n    if (Pred == ICmpInst::ICMP_SLT && C.isNullValue())\n      return new ICmpInst(ICmpInst::ICMP_SLT, X, Y);\n\n    // (icmp slt (sub nsw X, Y), 1) -> (icmp sle X, Y)\n    if (Pred == ICmpInst::ICMP_SLT && C.isOneValue())\n      return new ICmpInst(ICmpInst::ICMP_SLE, X, Y);\n  }\n\n  if (!match(X, m_APInt(C2)))\n    return nullptr;\n\n  // C2 - Y <u C -> (Y | (C - 1)) == C2\n  //   iff (C2 & (C - 1)) == C - 1 and C is a power of 2\n  if (Pred == ICmpInst::ICMP_ULT && C.isPowerOf2() &&\n      (*C2 & (C - 1)) == (C - 1))\n    return new ICmpInst(ICmpInst::ICMP_EQ, Builder.CreateOr(Y, C - 1), X);\n\n  // C2 - Y >u C -> (Y | C) != C2\n  //   iff C2 & C == C and C + 1 is a power of 2\n  if (Pred == ICmpInst::ICMP_UGT && (C + 1).isPowerOf2() && (*C2 & C) == C)\n    return new ICmpInst(ICmpInst::ICMP_NE, Builder.CreateOr(Y, C), X);\n\n  return nullptr;\n}\n\n/// Fold icmp (add X, Y), C.\nInstruction *InstCombinerImpl::foldICmpAddConstant(ICmpInst &Cmp,\n                                                   BinaryOperator *Add,\n                                                   const APInt &C) {\n  Value *Y = Add->getOperand(1);\n  const APInt *C2;\n  if (Cmp.isEquality() || !match(Y, m_APInt(C2)))\n    return nullptr;\n\n  // Fold icmp pred (add X, C2), C.\n  Value *X = Add->getOperand(0);\n  Type *Ty = Add->getType();\n  CmpInst::Predicate Pred = Cmp.getPredicate();\n\n  // If the add does not wrap, we can always adjust the compare by subtracting\n  // the constants. Equality comparisons are handled elsewhere. SGE/SLE/UGE/ULE\n  // are canonicalized to SGT/SLT/UGT/ULT.\n  if ((Add->hasNoSignedWrap() &&\n       (Pred == ICmpInst::ICMP_SGT || Pred == ICmpInst::ICMP_SLT)) ||\n      (Add->hasNoUnsignedWrap() &&\n       (Pred == ICmpInst::ICMP_UGT || Pred == ICmpInst::ICMP_ULT))) {\n    bool Overflow;\n    APInt NewC =\n        Cmp.isSigned() ? C.ssub_ov(*C2, Overflow) : C.usub_ov(*C2, Overflow);\n    // If there is overflow, the result must be true or false.\n    // TODO: Can we assert there is no overflow because InstSimplify always\n    // handles those cases?\n    if (!Overflow)\n      // icmp Pred (add nsw X, C2), C --> icmp Pred X, (C - C2)\n      return new ICmpInst(Pred, X, ConstantInt::get(Ty, NewC));\n  }\n\n  auto CR = ConstantRange::makeExactICmpRegion(Pred, C).subtract(*C2);\n  const APInt &Upper = CR.getUpper();\n  const APInt &Lower = CR.getLower();\n  if (Cmp.isSigned()) {\n    if (Lower.isSignMask())\n      return new ICmpInst(ICmpInst::ICMP_SLT, X, ConstantInt::get(Ty, Upper));\n    if (Upper.isSignMask())\n      return new ICmpInst(ICmpInst::ICMP_SGE, X, ConstantInt::get(Ty, Lower));\n  } else {\n    if (Lower.isMinValue())\n      return new ICmpInst(ICmpInst::ICMP_ULT, X, ConstantInt::get(Ty, Upper));\n    if (Upper.isMinValue())\n      return new ICmpInst(ICmpInst::ICMP_UGE, X, ConstantInt::get(Ty, Lower));\n  }\n\n  if (!Add->hasOneUse())\n    return nullptr;\n\n  // X+C <u C2 -> (X & -C2) == C\n  //   iff C & (C2-1) == 0\n  //       C2 is a power of 2\n  if (Pred == ICmpInst::ICMP_ULT && C.isPowerOf2() && (*C2 & (C - 1)) == 0)\n    return new ICmpInst(ICmpInst::ICMP_EQ, Builder.CreateAnd(X, -C),\n                        ConstantExpr::getNeg(cast<Constant>(Y)));\n\n  // X+C >u C2 -> (X & ~C2) != C\n  //   iff C & C2 == 0\n  //       C2+1 is a power of 2\n  if (Pred == ICmpInst::ICMP_UGT && (C + 1).isPowerOf2() && (*C2 & C) == 0)\n    return new ICmpInst(ICmpInst::ICMP_NE, Builder.CreateAnd(X, ~C),\n                        ConstantExpr::getNeg(cast<Constant>(Y)));\n\n  return nullptr;\n}\n\nbool InstCombinerImpl::matchThreeWayIntCompare(SelectInst *SI, Value *&LHS,\n                                               Value *&RHS, ConstantInt *&Less,\n                                               ConstantInt *&Equal,\n                                               ConstantInt *&Greater) {\n  // TODO: Generalize this to work with other comparison idioms or ensure\n  // they get canonicalized into this form.\n\n  // select i1 (a == b),\n  //        i32 Equal,\n  //        i32 (select i1 (a < b), i32 Less, i32 Greater)\n  // where Equal, Less and Greater are placeholders for any three constants.\n  ICmpInst::Predicate PredA;\n  if (!match(SI->getCondition(), m_ICmp(PredA, m_Value(LHS), m_Value(RHS))) ||\n      !ICmpInst::isEquality(PredA))\n    return false;\n  Value *EqualVal = SI->getTrueValue();\n  Value *UnequalVal = SI->getFalseValue();\n  // We still can get non-canonical predicate here, so canonicalize.\n  if (PredA == ICmpInst::ICMP_NE)\n    std::swap(EqualVal, UnequalVal);\n  if (!match(EqualVal, m_ConstantInt(Equal)))\n    return false;\n  ICmpInst::Predicate PredB;\n  Value *LHS2, *RHS2;\n  if (!match(UnequalVal, m_Select(m_ICmp(PredB, m_Value(LHS2), m_Value(RHS2)),\n                                  m_ConstantInt(Less), m_ConstantInt(Greater))))\n    return false;\n  // We can get predicate mismatch here, so canonicalize if possible:\n  // First, ensure that 'LHS' match.\n  if (LHS2 != LHS) {\n    // x sgt y <--> y slt x\n    std::swap(LHS2, RHS2);\n    PredB = ICmpInst::getSwappedPredicate(PredB);\n  }\n  if (LHS2 != LHS)\n    return false;\n  // We also need to canonicalize 'RHS'.\n  if (PredB == ICmpInst::ICMP_SGT && isa<Constant>(RHS2)) {\n    // x sgt C-1  <-->  x sge C  <-->  not(x slt C)\n    auto FlippedStrictness =\n        InstCombiner::getFlippedStrictnessPredicateAndConstant(\n            PredB, cast<Constant>(RHS2));\n    if (!FlippedStrictness)\n      return false;\n    assert(FlippedStrictness->first == ICmpInst::ICMP_SGE && \"Sanity check\");\n    RHS2 = FlippedStrictness->second;\n    // And kind-of perform the result swap.\n    std::swap(Less, Greater);\n    PredB = ICmpInst::ICMP_SLT;\n  }\n  return PredB == ICmpInst::ICMP_SLT && RHS == RHS2;\n}\n\nInstruction *InstCombinerImpl::foldICmpSelectConstant(ICmpInst &Cmp,\n                                                      SelectInst *Select,\n                                                      ConstantInt *C) {\n\n  assert(C && \"Cmp RHS should be a constant int!\");\n  // If we're testing a constant value against the result of a three way\n  // comparison, the result can be expressed directly in terms of the\n  // original values being compared.  Note: We could possibly be more\n  // aggressive here and remove the hasOneUse test. The original select is\n  // really likely to simplify or sink when we remove a test of the result.\n  Value *OrigLHS, *OrigRHS;\n  ConstantInt *C1LessThan, *C2Equal, *C3GreaterThan;\n  if (Cmp.hasOneUse() &&\n      matchThreeWayIntCompare(Select, OrigLHS, OrigRHS, C1LessThan, C2Equal,\n                              C3GreaterThan)) {\n    assert(C1LessThan && C2Equal && C3GreaterThan);\n\n    bool TrueWhenLessThan =\n        ConstantExpr::getCompare(Cmp.getPredicate(), C1LessThan, C)\n            ->isAllOnesValue();\n    bool TrueWhenEqual =\n        ConstantExpr::getCompare(Cmp.getPredicate(), C2Equal, C)\n            ->isAllOnesValue();\n    bool TrueWhenGreaterThan =\n        ConstantExpr::getCompare(Cmp.getPredicate(), C3GreaterThan, C)\n            ->isAllOnesValue();\n\n    // This generates the new instruction that will replace the original Cmp\n    // Instruction. Instead of enumerating the various combinations when\n    // TrueWhenLessThan, TrueWhenEqual and TrueWhenGreaterThan are true versus\n    // false, we rely on chaining of ORs and future passes of InstCombine to\n    // simplify the OR further (i.e. a s< b || a == b becomes a s<= b).\n\n    // When none of the three constants satisfy the predicate for the RHS (C),\n    // the entire original Cmp can be simplified to a false.\n    Value *Cond = Builder.getFalse();\n    if (TrueWhenLessThan)\n      Cond = Builder.CreateOr(Cond, Builder.CreateICmp(ICmpInst::ICMP_SLT,\n                                                       OrigLHS, OrigRHS));\n    if (TrueWhenEqual)\n      Cond = Builder.CreateOr(Cond, Builder.CreateICmp(ICmpInst::ICMP_EQ,\n                                                       OrigLHS, OrigRHS));\n    if (TrueWhenGreaterThan)\n      Cond = Builder.CreateOr(Cond, Builder.CreateICmp(ICmpInst::ICMP_SGT,\n                                                       OrigLHS, OrigRHS));\n\n    return replaceInstUsesWith(Cmp, Cond);\n  }\n  return nullptr;\n}\n\nstatic Instruction *foldICmpBitCast(ICmpInst &Cmp,\n                                    InstCombiner::BuilderTy &Builder) {\n  auto *Bitcast = dyn_cast<BitCastInst>(Cmp.getOperand(0));\n  if (!Bitcast)\n    return nullptr;\n\n  ICmpInst::Predicate Pred = Cmp.getPredicate();\n  Value *Op1 = Cmp.getOperand(1);\n  Value *BCSrcOp = Bitcast->getOperand(0);\n\n  // Make sure the bitcast doesn't change the number of vector elements.\n  if (Bitcast->getSrcTy()->getScalarSizeInBits() ==\n          Bitcast->getDestTy()->getScalarSizeInBits()) {\n    // Zero-equality and sign-bit checks are preserved through sitofp + bitcast.\n    Value *X;\n    if (match(BCSrcOp, m_SIToFP(m_Value(X)))) {\n      // icmp  eq (bitcast (sitofp X)), 0 --> icmp  eq X, 0\n      // icmp  ne (bitcast (sitofp X)), 0 --> icmp  ne X, 0\n      // icmp slt (bitcast (sitofp X)), 0 --> icmp slt X, 0\n      // icmp sgt (bitcast (sitofp X)), 0 --> icmp sgt X, 0\n      if ((Pred == ICmpInst::ICMP_EQ || Pred == ICmpInst::ICMP_SLT ||\n           Pred == ICmpInst::ICMP_NE || Pred == ICmpInst::ICMP_SGT) &&\n          match(Op1, m_Zero()))\n        return new ICmpInst(Pred, X, ConstantInt::getNullValue(X->getType()));\n\n      // icmp slt (bitcast (sitofp X)), 1 --> icmp slt X, 1\n      if (Pred == ICmpInst::ICMP_SLT && match(Op1, m_One()))\n        return new ICmpInst(Pred, X, ConstantInt::get(X->getType(), 1));\n\n      // icmp sgt (bitcast (sitofp X)), -1 --> icmp sgt X, -1\n      if (Pred == ICmpInst::ICMP_SGT && match(Op1, m_AllOnes()))\n        return new ICmpInst(Pred, X,\n                            ConstantInt::getAllOnesValue(X->getType()));\n    }\n\n    // Zero-equality checks are preserved through unsigned floating-point casts:\n    // icmp eq (bitcast (uitofp X)), 0 --> icmp eq X, 0\n    // icmp ne (bitcast (uitofp X)), 0 --> icmp ne X, 0\n    if (match(BCSrcOp, m_UIToFP(m_Value(X))))\n      if (Cmp.isEquality() && match(Op1, m_Zero()))\n        return new ICmpInst(Pred, X, ConstantInt::getNullValue(X->getType()));\n\n    // If this is a sign-bit test of a bitcast of a casted FP value, eliminate\n    // the FP extend/truncate because that cast does not change the sign-bit.\n    // This is true for all standard IEEE-754 types and the X86 80-bit type.\n    // The sign-bit is always the most significant bit in those types.\n    const APInt *C;\n    bool TrueIfSigned;\n    if (match(Op1, m_APInt(C)) && Bitcast->hasOneUse() &&\n        InstCombiner::isSignBitCheck(Pred, *C, TrueIfSigned)) {\n      if (match(BCSrcOp, m_FPExt(m_Value(X))) ||\n          match(BCSrcOp, m_FPTrunc(m_Value(X)))) {\n        // (bitcast (fpext/fptrunc X)) to iX) < 0 --> (bitcast X to iY) < 0\n        // (bitcast (fpext/fptrunc X)) to iX) > -1 --> (bitcast X to iY) > -1\n        Type *XType = X->getType();\n\n        // We can't currently handle Power style floating point operations here.\n        if (!(XType->isPPC_FP128Ty() || BCSrcOp->getType()->isPPC_FP128Ty())) {\n\n          Type *NewType = Builder.getIntNTy(XType->getScalarSizeInBits());\n          if (auto *XVTy = dyn_cast<VectorType>(XType))\n            NewType = VectorType::get(NewType, XVTy->getElementCount());\n          Value *NewBitcast = Builder.CreateBitCast(X, NewType);\n          if (TrueIfSigned)\n            return new ICmpInst(ICmpInst::ICMP_SLT, NewBitcast,\n                                ConstantInt::getNullValue(NewType));\n          else\n            return new ICmpInst(ICmpInst::ICMP_SGT, NewBitcast,\n                                ConstantInt::getAllOnesValue(NewType));\n        }\n      }\n    }\n  }\n\n  // Test to see if the operands of the icmp are casted versions of other\n  // values. If the ptr->ptr cast can be stripped off both arguments, do so.\n  if (Bitcast->getType()->isPointerTy() &&\n      (isa<Constant>(Op1) || isa<BitCastInst>(Op1))) {\n    // If operand #1 is a bitcast instruction, it must also be a ptr->ptr cast\n    // so eliminate it as well.\n    if (auto *BC2 = dyn_cast<BitCastInst>(Op1))\n      Op1 = BC2->getOperand(0);\n\n    Op1 = Builder.CreateBitCast(Op1, BCSrcOp->getType());\n    return new ICmpInst(Pred, BCSrcOp, Op1);\n  }\n\n  // Folding: icmp <pred> iN X, C\n  //  where X = bitcast <M x iK> (shufflevector <M x iK> %vec, undef, SC)) to iN\n  //    and C is a splat of a K-bit pattern\n  //    and SC is a constant vector = <C', C', C', ..., C'>\n  // Into:\n  //   %E = extractelement <M x iK> %vec, i32 C'\n  //   icmp <pred> iK %E, trunc(C)\n  const APInt *C;\n  if (!match(Cmp.getOperand(1), m_APInt(C)) ||\n      !Bitcast->getType()->isIntegerTy() ||\n      !Bitcast->getSrcTy()->isIntOrIntVectorTy())\n    return nullptr;\n\n  Value *Vec;\n  ArrayRef<int> Mask;\n  if (match(BCSrcOp, m_Shuffle(m_Value(Vec), m_Undef(), m_Mask(Mask)))) {\n    // Check whether every element of Mask is the same constant\n    if (is_splat(Mask)) {\n      auto *VecTy = cast<VectorType>(BCSrcOp->getType());\n      auto *EltTy = cast<IntegerType>(VecTy->getElementType());\n      if (C->isSplat(EltTy->getBitWidth())) {\n        // Fold the icmp based on the value of C\n        // If C is M copies of an iK sized bit pattern,\n        // then:\n        //   =>  %E = extractelement <N x iK> %vec, i32 Elem\n        //       icmp <pred> iK %SplatVal, <pattern>\n        Value *Elem = Builder.getInt32(Mask[0]);\n        Value *Extract = Builder.CreateExtractElement(Vec, Elem);\n        Value *NewC = ConstantInt::get(EltTy, C->trunc(EltTy->getBitWidth()));\n        return new ICmpInst(Pred, Extract, NewC);\n      }\n    }\n  }\n  return nullptr;\n}\n\n/// Try to fold integer comparisons with a constant operand: icmp Pred X, C\n/// where X is some kind of instruction.\nInstruction *InstCombinerImpl::foldICmpInstWithConstant(ICmpInst &Cmp) {\n  const APInt *C;\n  if (!match(Cmp.getOperand(1), m_APInt(C)))\n    return nullptr;\n\n  if (auto *BO = dyn_cast<BinaryOperator>(Cmp.getOperand(0))) {\n    switch (BO->getOpcode()) {\n    case Instruction::Xor:\n      if (Instruction *I = foldICmpXorConstant(Cmp, BO, *C))\n        return I;\n      break;\n    case Instruction::And:\n      if (Instruction *I = foldICmpAndConstant(Cmp, BO, *C))\n        return I;\n      break;\n    case Instruction::Or:\n      if (Instruction *I = foldICmpOrConstant(Cmp, BO, *C))\n        return I;\n      break;\n    case Instruction::Mul:\n      if (Instruction *I = foldICmpMulConstant(Cmp, BO, *C))\n        return I;\n      break;\n    case Instruction::Shl:\n      if (Instruction *I = foldICmpShlConstant(Cmp, BO, *C))\n        return I;\n      break;\n    case Instruction::LShr:\n    case Instruction::AShr:\n      if (Instruction *I = foldICmpShrConstant(Cmp, BO, *C))\n        return I;\n      break;\n    case Instruction::SRem:\n      if (Instruction *I = foldICmpSRemConstant(Cmp, BO, *C))\n        return I;\n      break;\n    case Instruction::UDiv:\n      if (Instruction *I = foldICmpUDivConstant(Cmp, BO, *C))\n        return I;\n      LLVM_FALLTHROUGH;\n    case Instruction::SDiv:\n      if (Instruction *I = foldICmpDivConstant(Cmp, BO, *C))\n        return I;\n      break;\n    case Instruction::Sub:\n      if (Instruction *I = foldICmpSubConstant(Cmp, BO, *C))\n        return I;\n      break;\n    case Instruction::Add:\n      if (Instruction *I = foldICmpAddConstant(Cmp, BO, *C))\n        return I;\n      break;\n    default:\n      break;\n    }\n    // TODO: These folds could be refactored to be part of the above calls.\n    if (Instruction *I = foldICmpBinOpEqualityWithConstant(Cmp, BO, *C))\n      return I;\n  }\n\n  // Match against CmpInst LHS being instructions other than binary operators.\n\n  if (auto *SI = dyn_cast<SelectInst>(Cmp.getOperand(0))) {\n    // For now, we only support constant integers while folding the\n    // ICMP(SELECT)) pattern. We can extend this to support vector of integers\n    // similar to the cases handled by binary ops above.\n    if (ConstantInt *ConstRHS = dyn_cast<ConstantInt>(Cmp.getOperand(1)))\n      if (Instruction *I = foldICmpSelectConstant(Cmp, SI, ConstRHS))\n        return I;\n  }\n\n  if (auto *TI = dyn_cast<TruncInst>(Cmp.getOperand(0))) {\n    if (Instruction *I = foldICmpTruncConstant(Cmp, TI, *C))\n      return I;\n  }\n\n  if (auto *II = dyn_cast<IntrinsicInst>(Cmp.getOperand(0)))\n    if (Instruction *I = foldICmpIntrinsicWithConstant(Cmp, II, *C))\n      return I;\n\n  return nullptr;\n}\n\n/// Fold an icmp equality instruction with binary operator LHS and constant RHS:\n/// icmp eq/ne BO, C.\nInstruction *InstCombinerImpl::foldICmpBinOpEqualityWithConstant(\n    ICmpInst &Cmp, BinaryOperator *BO, const APInt &C) {\n  // TODO: Some of these folds could work with arbitrary constants, but this\n  // function is limited to scalar and vector splat constants.\n  if (!Cmp.isEquality())\n    return nullptr;\n\n  ICmpInst::Predicate Pred = Cmp.getPredicate();\n  bool isICMP_NE = Pred == ICmpInst::ICMP_NE;\n  Constant *RHS = cast<Constant>(Cmp.getOperand(1));\n  Value *BOp0 = BO->getOperand(0), *BOp1 = BO->getOperand(1);\n\n  switch (BO->getOpcode()) {\n  case Instruction::SRem:\n    // If we have a signed (X % (2^c)) == 0, turn it into an unsigned one.\n    if (C.isNullValue() && BO->hasOneUse()) {\n      const APInt *BOC;\n      if (match(BOp1, m_APInt(BOC)) && BOC->sgt(1) && BOC->isPowerOf2()) {\n        Value *NewRem = Builder.CreateURem(BOp0, BOp1, BO->getName());\n        return new ICmpInst(Pred, NewRem,\n                            Constant::getNullValue(BO->getType()));\n      }\n    }\n    break;\n  case Instruction::Add: {\n    // Replace ((add A, B) != C) with (A != C-B) if B & C are constants.\n    if (Constant *BOC = dyn_cast<Constant>(BOp1)) {\n      if (BO->hasOneUse())\n        return new ICmpInst(Pred, BOp0, ConstantExpr::getSub(RHS, BOC));\n    } else if (C.isNullValue()) {\n      // Replace ((add A, B) != 0) with (A != -B) if A or B is\n      // efficiently invertible, or if the add has just this one use.\n      if (Value *NegVal = dyn_castNegVal(BOp1))\n        return new ICmpInst(Pred, BOp0, NegVal);\n      if (Value *NegVal = dyn_castNegVal(BOp0))\n        return new ICmpInst(Pred, NegVal, BOp1);\n      if (BO->hasOneUse()) {\n        Value *Neg = Builder.CreateNeg(BOp1);\n        Neg->takeName(BO);\n        return new ICmpInst(Pred, BOp0, Neg);\n      }\n    }\n    break;\n  }\n  case Instruction::Xor:\n    if (BO->hasOneUse()) {\n      if (Constant *BOC = dyn_cast<Constant>(BOp1)) {\n        // For the xor case, we can xor two constants together, eliminating\n        // the explicit xor.\n        return new ICmpInst(Pred, BOp0, ConstantExpr::getXor(RHS, BOC));\n      } else if (C.isNullValue()) {\n        // Replace ((xor A, B) != 0) with (A != B)\n        return new ICmpInst(Pred, BOp0, BOp1);\n      }\n    }\n    break;\n  case Instruction::Sub:\n    if (BO->hasOneUse()) {\n      // Only check for constant LHS here, as constant RHS will be canonicalized\n      // to add and use the fold above.\n      if (Constant *BOC = dyn_cast<Constant>(BOp0)) {\n        // Replace ((sub BOC, B) != C) with (B != BOC-C).\n        return new ICmpInst(Pred, BOp1, ConstantExpr::getSub(BOC, RHS));\n      } else if (C.isNullValue()) {\n        // Replace ((sub A, B) != 0) with (A != B).\n        return new ICmpInst(Pred, BOp0, BOp1);\n      }\n    }\n    break;\n  case Instruction::Or: {\n    const APInt *BOC;\n    if (match(BOp1, m_APInt(BOC)) && BO->hasOneUse() && RHS->isAllOnesValue()) {\n      // Comparing if all bits outside of a constant mask are set?\n      // Replace (X | C) == -1 with (X & ~C) == ~C.\n      // This removes the -1 constant.\n      Constant *NotBOC = ConstantExpr::getNot(cast<Constant>(BOp1));\n      Value *And = Builder.CreateAnd(BOp0, NotBOC);\n      return new ICmpInst(Pred, And, NotBOC);\n    }\n    break;\n  }\n  case Instruction::And: {\n    const APInt *BOC;\n    if (match(BOp1, m_APInt(BOC))) {\n      // If we have ((X & C) == C), turn it into ((X & C) != 0).\n      if (C == *BOC && C.isPowerOf2())\n        return new ICmpInst(isICMP_NE ? ICmpInst::ICMP_EQ : ICmpInst::ICMP_NE,\n                            BO, Constant::getNullValue(RHS->getType()));\n    }\n    break;\n  }\n  case Instruction::UDiv:\n    if (C.isNullValue()) {\n      // (icmp eq/ne (udiv A, B), 0) -> (icmp ugt/ule i32 B, A)\n      auto NewPred = isICMP_NE ? ICmpInst::ICMP_ULE : ICmpInst::ICMP_UGT;\n      return new ICmpInst(NewPred, BOp1, BOp0);\n    }\n    break;\n  default:\n    break;\n  }\n  return nullptr;\n}\n\n/// Fold an equality icmp with LLVM intrinsic and constant operand.\nInstruction *InstCombinerImpl::foldICmpEqIntrinsicWithConstant(\n    ICmpInst &Cmp, IntrinsicInst *II, const APInt &C) {\n  Type *Ty = II->getType();\n  unsigned BitWidth = C.getBitWidth();\n  switch (II->getIntrinsicID()) {\n  case Intrinsic::abs:\n    // abs(A) == 0  ->  A == 0\n    // abs(A) == INT_MIN  ->  A == INT_MIN\n    if (C.isNullValue() || C.isMinSignedValue())\n      return new ICmpInst(Cmp.getPredicate(), II->getArgOperand(0),\n                          ConstantInt::get(Ty, C));\n    break;\n\n  case Intrinsic::bswap:\n    // bswap(A) == C  ->  A == bswap(C)\n    return new ICmpInst(Cmp.getPredicate(), II->getArgOperand(0),\n                        ConstantInt::get(Ty, C.byteSwap()));\n\n  case Intrinsic::ctlz:\n  case Intrinsic::cttz: {\n    // ctz(A) == bitwidth(A)  ->  A == 0 and likewise for !=\n    if (C == BitWidth)\n      return new ICmpInst(Cmp.getPredicate(), II->getArgOperand(0),\n                          ConstantInt::getNullValue(Ty));\n\n    // ctz(A) == C -> A & Mask1 == Mask2, where Mask2 only has bit C set\n    // and Mask1 has bits 0..C+1 set. Similar for ctl, but for high bits.\n    // Limit to one use to ensure we don't increase instruction count.\n    unsigned Num = C.getLimitedValue(BitWidth);\n    if (Num != BitWidth && II->hasOneUse()) {\n      bool IsTrailing = II->getIntrinsicID() == Intrinsic::cttz;\n      APInt Mask1 = IsTrailing ? APInt::getLowBitsSet(BitWidth, Num + 1)\n                               : APInt::getHighBitsSet(BitWidth, Num + 1);\n      APInt Mask2 = IsTrailing\n        ? APInt::getOneBitSet(BitWidth, Num)\n        : APInt::getOneBitSet(BitWidth, BitWidth - Num - 1);\n      return new ICmpInst(Cmp.getPredicate(),\n          Builder.CreateAnd(II->getArgOperand(0), Mask1),\n          ConstantInt::get(Ty, Mask2));\n    }\n    break;\n  }\n\n  case Intrinsic::ctpop: {\n    // popcount(A) == 0  ->  A == 0 and likewise for !=\n    // popcount(A) == bitwidth(A)  ->  A == -1 and likewise for !=\n    bool IsZero = C.isNullValue();\n    if (IsZero || C == BitWidth)\n      return new ICmpInst(Cmp.getPredicate(), II->getArgOperand(0),\n          IsZero ? Constant::getNullValue(Ty) : Constant::getAllOnesValue(Ty));\n\n    break;\n  }\n\n  case Intrinsic::uadd_sat: {\n    // uadd.sat(a, b) == 0  ->  (a | b) == 0\n    if (C.isNullValue()) {\n      Value *Or = Builder.CreateOr(II->getArgOperand(0), II->getArgOperand(1));\n      return new ICmpInst(Cmp.getPredicate(), Or, Constant::getNullValue(Ty));\n    }\n    break;\n  }\n\n  case Intrinsic::usub_sat: {\n    // usub.sat(a, b) == 0  ->  a <= b\n    if (C.isNullValue()) {\n      ICmpInst::Predicate NewPred = Cmp.getPredicate() == ICmpInst::ICMP_EQ\n          ? ICmpInst::ICMP_ULE : ICmpInst::ICMP_UGT;\n      return new ICmpInst(NewPred, II->getArgOperand(0), II->getArgOperand(1));\n    }\n    break;\n  }\n  default:\n    break;\n  }\n\n  return nullptr;\n}\n\n/// Fold an icmp with LLVM intrinsic and constant operand: icmp Pred II, C.\nInstruction *InstCombinerImpl::foldICmpIntrinsicWithConstant(ICmpInst &Cmp,\n                                                             IntrinsicInst *II,\n                                                             const APInt &C) {\n  if (Cmp.isEquality())\n    return foldICmpEqIntrinsicWithConstant(Cmp, II, C);\n\n  Type *Ty = II->getType();\n  unsigned BitWidth = C.getBitWidth();\n  ICmpInst::Predicate Pred = Cmp.getPredicate();\n  switch (II->getIntrinsicID()) {\n  case Intrinsic::ctpop: {\n    // (ctpop X > BitWidth - 1) --> X == -1\n    Value *X = II->getArgOperand(0);\n    if (C == BitWidth - 1 && Pred == ICmpInst::ICMP_UGT)\n      return CmpInst::Create(Instruction::ICmp, ICmpInst::ICMP_EQ, X,\n                             ConstantInt::getAllOnesValue(Ty));\n    // (ctpop X < BitWidth) --> X != -1\n    if (C == BitWidth && Pred == ICmpInst::ICMP_ULT)\n      return CmpInst::Create(Instruction::ICmp, ICmpInst::ICMP_NE, X,\n                             ConstantInt::getAllOnesValue(Ty));\n    break;\n  }\n  case Intrinsic::ctlz: {\n    // ctlz(0bXXXXXXXX) > 3 -> 0bXXXXXXXX < 0b00010000\n    if (Pred == ICmpInst::ICMP_UGT && C.ult(BitWidth)) {\n      unsigned Num = C.getLimitedValue();\n      APInt Limit = APInt::getOneBitSet(BitWidth, BitWidth - Num - 1);\n      return CmpInst::Create(Instruction::ICmp, ICmpInst::ICMP_ULT,\n                             II->getArgOperand(0), ConstantInt::get(Ty, Limit));\n    }\n\n    // ctlz(0bXXXXXXXX) < 3 -> 0bXXXXXXXX > 0b00011111\n    if (Pred == ICmpInst::ICMP_ULT && C.uge(1) && C.ule(BitWidth)) {\n      unsigned Num = C.getLimitedValue();\n      APInt Limit = APInt::getLowBitsSet(BitWidth, BitWidth - Num);\n      return CmpInst::Create(Instruction::ICmp, ICmpInst::ICMP_UGT,\n                             II->getArgOperand(0), ConstantInt::get(Ty, Limit));\n    }\n    break;\n  }\n  case Intrinsic::cttz: {\n    // Limit to one use to ensure we don't increase instruction count.\n    if (!II->hasOneUse())\n      return nullptr;\n\n    // cttz(0bXXXXXXXX) > 3 -> 0bXXXXXXXX & 0b00001111 == 0\n    if (Pred == ICmpInst::ICMP_UGT && C.ult(BitWidth)) {\n      APInt Mask = APInt::getLowBitsSet(BitWidth, C.getLimitedValue() + 1);\n      return CmpInst::Create(Instruction::ICmp, ICmpInst::ICMP_EQ,\n                             Builder.CreateAnd(II->getArgOperand(0), Mask),\n                             ConstantInt::getNullValue(Ty));\n    }\n\n    // cttz(0bXXXXXXXX) < 3 -> 0bXXXXXXXX & 0b00000111 != 0\n    if (Pred == ICmpInst::ICMP_ULT && C.uge(1) && C.ule(BitWidth)) {\n      APInt Mask = APInt::getLowBitsSet(BitWidth, C.getLimitedValue());\n      return CmpInst::Create(Instruction::ICmp, ICmpInst::ICMP_NE,\n                             Builder.CreateAnd(II->getArgOperand(0), Mask),\n                             ConstantInt::getNullValue(Ty));\n    }\n    break;\n  }\n  default:\n    break;\n  }\n\n  return nullptr;\n}\n\n/// Handle icmp with constant (but not simple integer constant) RHS.\nInstruction *InstCombinerImpl::foldICmpInstWithConstantNotInt(ICmpInst &I) {\n  Value *Op0 = I.getOperand(0), *Op1 = I.getOperand(1);\n  Constant *RHSC = dyn_cast<Constant>(Op1);\n  Instruction *LHSI = dyn_cast<Instruction>(Op0);\n  if (!RHSC || !LHSI)\n    return nullptr;\n\n  switch (LHSI->getOpcode()) {\n  case Instruction::GetElementPtr:\n    // icmp pred GEP (P, int 0, int 0, int 0), null -> icmp pred P, null\n    if (RHSC->isNullValue() &&\n        cast<GetElementPtrInst>(LHSI)->hasAllZeroIndices())\n      return new ICmpInst(\n          I.getPredicate(), LHSI->getOperand(0),\n          Constant::getNullValue(LHSI->getOperand(0)->getType()));\n    break;\n  case Instruction::PHI:\n    // Only fold icmp into the PHI if the phi and icmp are in the same\n    // block.  If in the same block, we're encouraging jump threading.  If\n    // not, we are just pessimizing the code by making an i1 phi.\n    if (LHSI->getParent() == I.getParent())\n      if (Instruction *NV = foldOpIntoPhi(I, cast<PHINode>(LHSI)))\n        return NV;\n    break;\n  case Instruction::Select: {\n    // If either operand of the select is a constant, we can fold the\n    // comparison into the select arms, which will cause one to be\n    // constant folded and the select turned into a bitwise or.\n    Value *Op1 = nullptr, *Op2 = nullptr;\n    ConstantInt *CI = nullptr;\n    if (Constant *C = dyn_cast<Constant>(LHSI->getOperand(1))) {\n      Op1 = ConstantExpr::getICmp(I.getPredicate(), C, RHSC);\n      CI = dyn_cast<ConstantInt>(Op1);\n    }\n    if (Constant *C = dyn_cast<Constant>(LHSI->getOperand(2))) {\n      Op2 = ConstantExpr::getICmp(I.getPredicate(), C, RHSC);\n      CI = dyn_cast<ConstantInt>(Op2);\n    }\n\n    // We only want to perform this transformation if it will not lead to\n    // additional code. This is true if either both sides of the select\n    // fold to a constant (in which case the icmp is replaced with a select\n    // which will usually simplify) or this is the only user of the\n    // select (in which case we are trading a select+icmp for a simpler\n    // select+icmp) or all uses of the select can be replaced based on\n    // dominance information (\"Global cases\").\n    bool Transform = false;\n    if (Op1 && Op2)\n      Transform = true;\n    else if (Op1 || Op2) {\n      // Local case\n      if (LHSI->hasOneUse())\n        Transform = true;\n      // Global cases\n      else if (CI && !CI->isZero())\n        // When Op1 is constant try replacing select with second operand.\n        // Otherwise Op2 is constant and try replacing select with first\n        // operand.\n        Transform =\n            replacedSelectWithOperand(cast<SelectInst>(LHSI), &I, Op1 ? 2 : 1);\n    }\n    if (Transform) {\n      if (!Op1)\n        Op1 = Builder.CreateICmp(I.getPredicate(), LHSI->getOperand(1), RHSC,\n                                 I.getName());\n      if (!Op2)\n        Op2 = Builder.CreateICmp(I.getPredicate(), LHSI->getOperand(2), RHSC,\n                                 I.getName());\n      return SelectInst::Create(LHSI->getOperand(0), Op1, Op2);\n    }\n    break;\n  }\n  case Instruction::IntToPtr:\n    // icmp pred inttoptr(X), null -> icmp pred X, 0\n    if (RHSC->isNullValue() &&\n        DL.getIntPtrType(RHSC->getType()) == LHSI->getOperand(0)->getType())\n      return new ICmpInst(\n          I.getPredicate(), LHSI->getOperand(0),\n          Constant::getNullValue(LHSI->getOperand(0)->getType()));\n    break;\n\n  case Instruction::Load:\n    // Try to optimize things like \"A[i] > 4\" to index computations.\n    if (GetElementPtrInst *GEP =\n            dyn_cast<GetElementPtrInst>(LHSI->getOperand(0))) {\n      if (GlobalVariable *GV = dyn_cast<GlobalVariable>(GEP->getOperand(0)))\n        if (GV->isConstant() && GV->hasDefinitiveInitializer() &&\n            !cast<LoadInst>(LHSI)->isVolatile())\n          if (Instruction *Res = foldCmpLoadFromIndexedGlobal(GEP, GV, I))\n            return Res;\n    }\n    break;\n  }\n\n  return nullptr;\n}\n\n/// Some comparisons can be simplified.\n/// In this case, we are looking for comparisons that look like\n/// a check for a lossy truncation.\n/// Folds:\n///   icmp SrcPred (x & Mask), x    to    icmp DstPred x, Mask\n/// Where Mask is some pattern that produces all-ones in low bits:\n///    (-1 >> y)\n///    ((-1 << y) >> y)     <- non-canonical, has extra uses\n///   ~(-1 << y)\n///    ((1 << y) + (-1))    <- non-canonical, has extra uses\n/// The Mask can be a constant, too.\n/// For some predicates, the operands are commutative.\n/// For others, x can only be on a specific side.\nstatic Value *foldICmpWithLowBitMaskedVal(ICmpInst &I,\n                                          InstCombiner::BuilderTy &Builder) {\n  ICmpInst::Predicate SrcPred;\n  Value *X, *M, *Y;\n  auto m_VariableMask = m_CombineOr(\n      m_CombineOr(m_Not(m_Shl(m_AllOnes(), m_Value())),\n                  m_Add(m_Shl(m_One(), m_Value()), m_AllOnes())),\n      m_CombineOr(m_LShr(m_AllOnes(), m_Value()),\n                  m_LShr(m_Shl(m_AllOnes(), m_Value(Y)), m_Deferred(Y))));\n  auto m_Mask = m_CombineOr(m_VariableMask, m_LowBitMask());\n  if (!match(&I, m_c_ICmp(SrcPred,\n                          m_c_And(m_CombineAnd(m_Mask, m_Value(M)), m_Value(X)),\n                          m_Deferred(X))))\n    return nullptr;\n\n  ICmpInst::Predicate DstPred;\n  switch (SrcPred) {\n  case ICmpInst::Predicate::ICMP_EQ:\n    //  x & (-1 >> y) == x    ->    x u<= (-1 >> y)\n    DstPred = ICmpInst::Predicate::ICMP_ULE;\n    break;\n  case ICmpInst::Predicate::ICMP_NE:\n    //  x & (-1 >> y) != x    ->    x u> (-1 >> y)\n    DstPred = ICmpInst::Predicate::ICMP_UGT;\n    break;\n  case ICmpInst::Predicate::ICMP_ULT:\n    //  x & (-1 >> y) u< x    ->    x u> (-1 >> y)\n    //  x u> x & (-1 >> y)    ->    x u> (-1 >> y)\n    DstPred = ICmpInst::Predicate::ICMP_UGT;\n    break;\n  case ICmpInst::Predicate::ICMP_UGE:\n    //  x & (-1 >> y) u>= x    ->    x u<= (-1 >> y)\n    //  x u<= x & (-1 >> y)    ->    x u<= (-1 >> y)\n    DstPred = ICmpInst::Predicate::ICMP_ULE;\n    break;\n  case ICmpInst::Predicate::ICMP_SLT:\n    //  x & (-1 >> y) s< x    ->    x s> (-1 >> y)\n    //  x s> x & (-1 >> y)    ->    x s> (-1 >> y)\n    if (!match(M, m_Constant())) // Can not do this fold with non-constant.\n      return nullptr;\n    if (!match(M, m_NonNegative())) // Must not have any -1 vector elements.\n      return nullptr;\n    DstPred = ICmpInst::Predicate::ICMP_SGT;\n    break;\n  case ICmpInst::Predicate::ICMP_SGE:\n    //  x & (-1 >> y) s>= x    ->    x s<= (-1 >> y)\n    //  x s<= x & (-1 >> y)    ->    x s<= (-1 >> y)\n    if (!match(M, m_Constant())) // Can not do this fold with non-constant.\n      return nullptr;\n    if (!match(M, m_NonNegative())) // Must not have any -1 vector elements.\n      return nullptr;\n    DstPred = ICmpInst::Predicate::ICMP_SLE;\n    break;\n  case ICmpInst::Predicate::ICMP_SGT:\n  case ICmpInst::Predicate::ICMP_SLE:\n    return nullptr;\n  case ICmpInst::Predicate::ICMP_UGT:\n  case ICmpInst::Predicate::ICMP_ULE:\n    llvm_unreachable(\"Instsimplify took care of commut. variant\");\n    break;\n  default:\n    llvm_unreachable(\"All possible folds are handled.\");\n  }\n\n  // The mask value may be a vector constant that has undefined elements. But it\n  // may not be safe to propagate those undefs into the new compare, so replace\n  // those elements by copying an existing, defined, and safe scalar constant.\n  Type *OpTy = M->getType();\n  auto *VecC = dyn_cast<Constant>(M);\n  auto *OpVTy = dyn_cast<FixedVectorType>(OpTy);\n  if (OpVTy && VecC && VecC->containsUndefOrPoisonElement()) {\n    Constant *SafeReplacementConstant = nullptr;\n    for (unsigned i = 0, e = OpVTy->getNumElements(); i != e; ++i) {\n      if (!isa<UndefValue>(VecC->getAggregateElement(i))) {\n        SafeReplacementConstant = VecC->getAggregateElement(i);\n        break;\n      }\n    }\n    assert(SafeReplacementConstant && \"Failed to find undef replacement\");\n    M = Constant::replaceUndefsWith(VecC, SafeReplacementConstant);\n  }\n\n  return Builder.CreateICmp(DstPred, X, M);\n}\n\n/// Some comparisons can be simplified.\n/// In this case, we are looking for comparisons that look like\n/// a check for a lossy signed truncation.\n/// Folds:   (MaskedBits is a constant.)\n///   ((%x << MaskedBits) a>> MaskedBits) SrcPred %x\n/// Into:\n///   (add %x, (1 << (KeptBits-1))) DstPred (1 << KeptBits)\n/// Where  KeptBits = bitwidth(%x) - MaskedBits\nstatic Value *\nfoldICmpWithTruncSignExtendedVal(ICmpInst &I,\n                                 InstCombiner::BuilderTy &Builder) {\n  ICmpInst::Predicate SrcPred;\n  Value *X;\n  const APInt *C0, *C1; // FIXME: non-splats, potentially with undef.\n  // We are ok with 'shl' having multiple uses, but 'ashr' must be one-use.\n  if (!match(&I, m_c_ICmp(SrcPred,\n                          m_OneUse(m_AShr(m_Shl(m_Value(X), m_APInt(C0)),\n                                          m_APInt(C1))),\n                          m_Deferred(X))))\n    return nullptr;\n\n  // Potential handling of non-splats: for each element:\n  //  * if both are undef, replace with constant 0.\n  //    Because (1<<0) is OK and is 1, and ((1<<0)>>1) is also OK and is 0.\n  //  * if both are not undef, and are different, bailout.\n  //  * else, only one is undef, then pick the non-undef one.\n\n  // The shift amount must be equal.\n  if (*C0 != *C1)\n    return nullptr;\n  const APInt &MaskedBits = *C0;\n  assert(MaskedBits != 0 && \"shift by zero should be folded away already.\");\n\n  ICmpInst::Predicate DstPred;\n  switch (SrcPred) {\n  case ICmpInst::Predicate::ICMP_EQ:\n    // ((%x << MaskedBits) a>> MaskedBits) == %x\n    //   =>\n    // (add %x, (1 << (KeptBits-1))) u< (1 << KeptBits)\n    DstPred = ICmpInst::Predicate::ICMP_ULT;\n    break;\n  case ICmpInst::Predicate::ICMP_NE:\n    // ((%x << MaskedBits) a>> MaskedBits) != %x\n    //   =>\n    // (add %x, (1 << (KeptBits-1))) u>= (1 << KeptBits)\n    DstPred = ICmpInst::Predicate::ICMP_UGE;\n    break;\n  // FIXME: are more folds possible?\n  default:\n    return nullptr;\n  }\n\n  auto *XType = X->getType();\n  const unsigned XBitWidth = XType->getScalarSizeInBits();\n  const APInt BitWidth = APInt(XBitWidth, XBitWidth);\n  assert(BitWidth.ugt(MaskedBits) && \"shifts should leave some bits untouched\");\n\n  // KeptBits = bitwidth(%x) - MaskedBits\n  const APInt KeptBits = BitWidth - MaskedBits;\n  assert(KeptBits.ugt(0) && KeptBits.ult(BitWidth) && \"unreachable\");\n  // ICmpCst = (1 << KeptBits)\n  const APInt ICmpCst = APInt(XBitWidth, 1).shl(KeptBits);\n  assert(ICmpCst.isPowerOf2());\n  // AddCst = (1 << (KeptBits-1))\n  const APInt AddCst = ICmpCst.lshr(1);\n  assert(AddCst.ult(ICmpCst) && AddCst.isPowerOf2());\n\n  // T0 = add %x, AddCst\n  Value *T0 = Builder.CreateAdd(X, ConstantInt::get(XType, AddCst));\n  // T1 = T0 DstPred ICmpCst\n  Value *T1 = Builder.CreateICmp(DstPred, T0, ConstantInt::get(XType, ICmpCst));\n\n  return T1;\n}\n\n// Given pattern:\n//   icmp eq/ne (and ((x shift Q), (y oppositeshift K))), 0\n// we should move shifts to the same hand of 'and', i.e. rewrite as\n//   icmp eq/ne (and (x shift (Q+K)), y), 0  iff (Q+K) u< bitwidth(x)\n// We are only interested in opposite logical shifts here.\n// One of the shifts can be truncated.\n// If we can, we want to end up creating 'lshr' shift.\nstatic Value *\nfoldShiftIntoShiftInAnotherHandOfAndInICmp(ICmpInst &I, const SimplifyQuery SQ,\n                                           InstCombiner::BuilderTy &Builder) {\n  if (!I.isEquality() || !match(I.getOperand(1), m_Zero()) ||\n      !I.getOperand(0)->hasOneUse())\n    return nullptr;\n\n  auto m_AnyLogicalShift = m_LogicalShift(m_Value(), m_Value());\n\n  // Look for an 'and' of two logical shifts, one of which may be truncated.\n  // We use m_TruncOrSelf() on the RHS to correctly handle commutative case.\n  Instruction *XShift, *MaybeTruncation, *YShift;\n  if (!match(\n          I.getOperand(0),\n          m_c_And(m_CombineAnd(m_AnyLogicalShift, m_Instruction(XShift)),\n                  m_CombineAnd(m_TruncOrSelf(m_CombineAnd(\n                                   m_AnyLogicalShift, m_Instruction(YShift))),\n                               m_Instruction(MaybeTruncation)))))\n    return nullptr;\n\n  // We potentially looked past 'trunc', but only when matching YShift,\n  // therefore YShift must have the widest type.\n  Instruction *WidestShift = YShift;\n  // Therefore XShift must have the shallowest type.\n  // Or they both have identical types if there was no truncation.\n  Instruction *NarrowestShift = XShift;\n\n  Type *WidestTy = WidestShift->getType();\n  Type *NarrowestTy = NarrowestShift->getType();\n  assert(NarrowestTy == I.getOperand(0)->getType() &&\n         \"We did not look past any shifts while matching XShift though.\");\n  bool HadTrunc = WidestTy != I.getOperand(0)->getType();\n\n  // If YShift is a 'lshr', swap the shifts around.\n  if (match(YShift, m_LShr(m_Value(), m_Value())))\n    std::swap(XShift, YShift);\n\n  // The shifts must be in opposite directions.\n  auto XShiftOpcode = XShift->getOpcode();\n  if (XShiftOpcode == YShift->getOpcode())\n    return nullptr; // Do not care about same-direction shifts here.\n\n  Value *X, *XShAmt, *Y, *YShAmt;\n  match(XShift, m_BinOp(m_Value(X), m_ZExtOrSelf(m_Value(XShAmt))));\n  match(YShift, m_BinOp(m_Value(Y), m_ZExtOrSelf(m_Value(YShAmt))));\n\n  // If one of the values being shifted is a constant, then we will end with\n  // and+icmp, and [zext+]shift instrs will be constant-folded. If they are not,\n  // however, we will need to ensure that we won't increase instruction count.\n  if (!isa<Constant>(X) && !isa<Constant>(Y)) {\n    // At least one of the hands of the 'and' should be one-use shift.\n    if (!match(I.getOperand(0),\n               m_c_And(m_OneUse(m_AnyLogicalShift), m_Value())))\n      return nullptr;\n    if (HadTrunc) {\n      // Due to the 'trunc', we will need to widen X. For that either the old\n      // 'trunc' or the shift amt in the non-truncated shift should be one-use.\n      if (!MaybeTruncation->hasOneUse() &&\n          !NarrowestShift->getOperand(1)->hasOneUse())\n        return nullptr;\n    }\n  }\n\n  // We have two shift amounts from two different shifts. The types of those\n  // shift amounts may not match. If that's the case let's bailout now.\n  if (XShAmt->getType() != YShAmt->getType())\n    return nullptr;\n\n  // As input, we have the following pattern:\n  //   icmp eq/ne (and ((x shift Q), (y oppositeshift K))), 0\n  // We want to rewrite that as:\n  //   icmp eq/ne (and (x shift (Q+K)), y), 0  iff (Q+K) u< bitwidth(x)\n  // While we know that originally (Q+K) would not overflow\n  // (because  2 * (N-1) u<= iN -1), we have looked past extensions of\n  // shift amounts. so it may now overflow in smaller bitwidth.\n  // To ensure that does not happen, we need to ensure that the total maximal\n  // shift amount is still representable in that smaller bit width.\n  unsigned MaximalPossibleTotalShiftAmount =\n      (WidestTy->getScalarSizeInBits() - 1) +\n      (NarrowestTy->getScalarSizeInBits() - 1);\n  APInt MaximalRepresentableShiftAmount =\n      APInt::getAllOnesValue(XShAmt->getType()->getScalarSizeInBits());\n  if (MaximalRepresentableShiftAmount.ult(MaximalPossibleTotalShiftAmount))\n    return nullptr;\n\n  // Can we fold (XShAmt+YShAmt) ?\n  auto *NewShAmt = dyn_cast_or_null<Constant>(\n      SimplifyAddInst(XShAmt, YShAmt, /*isNSW=*/false,\n                      /*isNUW=*/false, SQ.getWithInstruction(&I)));\n  if (!NewShAmt)\n    return nullptr;\n  NewShAmt = ConstantExpr::getZExtOrBitCast(NewShAmt, WidestTy);\n  unsigned WidestBitWidth = WidestTy->getScalarSizeInBits();\n\n  // Is the new shift amount smaller than the bit width?\n  // FIXME: could also rely on ConstantRange.\n  if (!match(NewShAmt,\n             m_SpecificInt_ICMP(ICmpInst::Predicate::ICMP_ULT,\n                                APInt(WidestBitWidth, WidestBitWidth))))\n    return nullptr;\n\n  // An extra legality check is needed if we had trunc-of-lshr.\n  if (HadTrunc && match(WidestShift, m_LShr(m_Value(), m_Value()))) {\n    auto CanFold = [NewShAmt, WidestBitWidth, NarrowestShift, SQ,\n                    WidestShift]() {\n      // It isn't obvious whether it's worth it to analyze non-constants here.\n      // Also, let's basically give up on non-splat cases, pessimizing vectors.\n      // If *any* of these preconditions matches we can perform the fold.\n      Constant *NewShAmtSplat = NewShAmt->getType()->isVectorTy()\n                                    ? NewShAmt->getSplatValue()\n                                    : NewShAmt;\n      // If it's edge-case shift (by 0 or by WidestBitWidth-1) we can fold.\n      if (NewShAmtSplat &&\n          (NewShAmtSplat->isNullValue() ||\n           NewShAmtSplat->getUniqueInteger() == WidestBitWidth - 1))\n        return true;\n      // We consider *min* leading zeros so a single outlier\n      // blocks the transform as opposed to allowing it.\n      if (auto *C = dyn_cast<Constant>(NarrowestShift->getOperand(0))) {\n        KnownBits Known = computeKnownBits(C, SQ.DL);\n        unsigned MinLeadZero = Known.countMinLeadingZeros();\n        // If the value being shifted has at most lowest bit set we can fold.\n        unsigned MaxActiveBits = Known.getBitWidth() - MinLeadZero;\n        if (MaxActiveBits <= 1)\n          return true;\n        // Precondition:  NewShAmt u<= countLeadingZeros(C)\n        if (NewShAmtSplat && NewShAmtSplat->getUniqueInteger().ule(MinLeadZero))\n          return true;\n      }\n      if (auto *C = dyn_cast<Constant>(WidestShift->getOperand(0))) {\n        KnownBits Known = computeKnownBits(C, SQ.DL);\n        unsigned MinLeadZero = Known.countMinLeadingZeros();\n        // If the value being shifted has at most lowest bit set we can fold.\n        unsigned MaxActiveBits = Known.getBitWidth() - MinLeadZero;\n        if (MaxActiveBits <= 1)\n          return true;\n        // Precondition:  ((WidestBitWidth-1)-NewShAmt) u<= countLeadingZeros(C)\n        if (NewShAmtSplat) {\n          APInt AdjNewShAmt =\n              (WidestBitWidth - 1) - NewShAmtSplat->getUniqueInteger();\n          if (AdjNewShAmt.ule(MinLeadZero))\n            return true;\n        }\n      }\n      return false; // Can't tell if it's ok.\n    };\n    if (!CanFold())\n      return nullptr;\n  }\n\n  // All good, we can do this fold.\n  X = Builder.CreateZExt(X, WidestTy);\n  Y = Builder.CreateZExt(Y, WidestTy);\n  // The shift is the same that was for X.\n  Value *T0 = XShiftOpcode == Instruction::BinaryOps::LShr\n                  ? Builder.CreateLShr(X, NewShAmt)\n                  : Builder.CreateShl(X, NewShAmt);\n  Value *T1 = Builder.CreateAnd(T0, Y);\n  return Builder.CreateICmp(I.getPredicate(), T1,\n                            Constant::getNullValue(WidestTy));\n}\n\n/// Fold\n///   (-1 u/ x) u< y\n///   ((x * y) u/ x) != y\n/// to\n///   @llvm.umul.with.overflow(x, y) plus extraction of overflow bit\n/// Note that the comparison is commutative, while inverted (u>=, ==) predicate\n/// will mean that we are looking for the opposite answer.\nValue *InstCombinerImpl::foldUnsignedMultiplicationOverflowCheck(ICmpInst &I) {\n  ICmpInst::Predicate Pred;\n  Value *X, *Y;\n  Instruction *Mul;\n  bool NeedNegation;\n  // Look for: (-1 u/ x) u</u>= y\n  if (!I.isEquality() &&\n      match(&I, m_c_ICmp(Pred, m_OneUse(m_UDiv(m_AllOnes(), m_Value(X))),\n                         m_Value(Y)))) {\n    Mul = nullptr;\n\n    // Are we checking that overflow does not happen, or does happen?\n    switch (Pred) {\n    case ICmpInst::Predicate::ICMP_ULT:\n      NeedNegation = false;\n      break; // OK\n    case ICmpInst::Predicate::ICMP_UGE:\n      NeedNegation = true;\n      break; // OK\n    default:\n      return nullptr; // Wrong predicate.\n    }\n  } else // Look for: ((x * y) u/ x) !=/== y\n      if (I.isEquality() &&\n          match(&I, m_c_ICmp(Pred, m_Value(Y),\n                             m_OneUse(m_UDiv(m_CombineAnd(m_c_Mul(m_Deferred(Y),\n                                                                  m_Value(X)),\n                                                          m_Instruction(Mul)),\n                                             m_Deferred(X)))))) {\n    NeedNegation = Pred == ICmpInst::Predicate::ICMP_EQ;\n  } else\n    return nullptr;\n\n  BuilderTy::InsertPointGuard Guard(Builder);\n  // If the pattern included (x * y), we'll want to insert new instructions\n  // right before that original multiplication so that we can replace it.\n  bool MulHadOtherUses = Mul && !Mul->hasOneUse();\n  if (MulHadOtherUses)\n    Builder.SetInsertPoint(Mul);\n\n  Function *F = Intrinsic::getDeclaration(\n      I.getModule(), Intrinsic::umul_with_overflow, X->getType());\n  CallInst *Call = Builder.CreateCall(F, {X, Y}, \"umul\");\n\n  // If the multiplication was used elsewhere, to ensure that we don't leave\n  // \"duplicate\" instructions, replace uses of that original multiplication\n  // with the multiplication result from the with.overflow intrinsic.\n  if (MulHadOtherUses)\n    replaceInstUsesWith(*Mul, Builder.CreateExtractValue(Call, 0, \"umul.val\"));\n\n  Value *Res = Builder.CreateExtractValue(Call, 1, \"umul.ov\");\n  if (NeedNegation) // This technically increases instruction count.\n    Res = Builder.CreateNot(Res, \"umul.not.ov\");\n\n  // If we replaced the mul, erase it. Do this after all uses of Builder,\n  // as the mul is used as insertion point.\n  if (MulHadOtherUses)\n    eraseInstFromFunction(*Mul);\n\n  return Res;\n}\n\nstatic Instruction *foldICmpXNegX(ICmpInst &I) {\n  CmpInst::Predicate Pred;\n  Value *X;\n  if (!match(&I, m_c_ICmp(Pred, m_NSWNeg(m_Value(X)), m_Deferred(X))))\n    return nullptr;\n\n  if (ICmpInst::isSigned(Pred))\n    Pred = ICmpInst::getSwappedPredicate(Pred);\n  else if (ICmpInst::isUnsigned(Pred))\n    Pred = ICmpInst::getSignedPredicate(Pred);\n  // else for equality-comparisons just keep the predicate.\n\n  return ICmpInst::Create(Instruction::ICmp, Pred, X,\n                          Constant::getNullValue(X->getType()), I.getName());\n}\n\n/// Try to fold icmp (binop), X or icmp X, (binop).\n/// TODO: A large part of this logic is duplicated in InstSimplify's\n/// simplifyICmpWithBinOp(). We should be able to share that and avoid the code\n/// duplication.\nInstruction *InstCombinerImpl::foldICmpBinOp(ICmpInst &I,\n                                             const SimplifyQuery &SQ) {\n  const SimplifyQuery Q = SQ.getWithInstruction(&I);\n  Value *Op0 = I.getOperand(0), *Op1 = I.getOperand(1);\n\n  // Special logic for binary operators.\n  BinaryOperator *BO0 = dyn_cast<BinaryOperator>(Op0);\n  BinaryOperator *BO1 = dyn_cast<BinaryOperator>(Op1);\n  if (!BO0 && !BO1)\n    return nullptr;\n\n  if (Instruction *NewICmp = foldICmpXNegX(I))\n    return NewICmp;\n\n  const CmpInst::Predicate Pred = I.getPredicate();\n  Value *X;\n\n  // Convert add-with-unsigned-overflow comparisons into a 'not' with compare.\n  // (Op1 + X) u</u>= Op1 --> ~Op1 u</u>= X\n  if (match(Op0, m_OneUse(m_c_Add(m_Specific(Op1), m_Value(X)))) &&\n      (Pred == ICmpInst::ICMP_ULT || Pred == ICmpInst::ICMP_UGE))\n    return new ICmpInst(Pred, Builder.CreateNot(Op1), X);\n  // Op0 u>/u<= (Op0 + X) --> X u>/u<= ~Op0\n  if (match(Op1, m_OneUse(m_c_Add(m_Specific(Op0), m_Value(X)))) &&\n      (Pred == ICmpInst::ICMP_UGT || Pred == ICmpInst::ICMP_ULE))\n    return new ICmpInst(Pred, X, Builder.CreateNot(Op0));\n\n  bool NoOp0WrapProblem = false, NoOp1WrapProblem = false;\n  if (BO0 && isa<OverflowingBinaryOperator>(BO0))\n    NoOp0WrapProblem =\n        ICmpInst::isEquality(Pred) ||\n        (CmpInst::isUnsigned(Pred) && BO0->hasNoUnsignedWrap()) ||\n        (CmpInst::isSigned(Pred) && BO0->hasNoSignedWrap());\n  if (BO1 && isa<OverflowingBinaryOperator>(BO1))\n    NoOp1WrapProblem =\n        ICmpInst::isEquality(Pred) ||\n        (CmpInst::isUnsigned(Pred) && BO1->hasNoUnsignedWrap()) ||\n        (CmpInst::isSigned(Pred) && BO1->hasNoSignedWrap());\n\n  // Analyze the case when either Op0 or Op1 is an add instruction.\n  // Op0 = A + B (or A and B are null); Op1 = C + D (or C and D are null).\n  Value *A = nullptr, *B = nullptr, *C = nullptr, *D = nullptr;\n  if (BO0 && BO0->getOpcode() == Instruction::Add) {\n    A = BO0->getOperand(0);\n    B = BO0->getOperand(1);\n  }\n  if (BO1 && BO1->getOpcode() == Instruction::Add) {\n    C = BO1->getOperand(0);\n    D = BO1->getOperand(1);\n  }\n\n  // icmp (A+B), A -> icmp B, 0 for equalities or if there is no overflow.\n  // icmp (A+B), B -> icmp A, 0 for equalities or if there is no overflow.\n  if ((A == Op1 || B == Op1) && NoOp0WrapProblem)\n    return new ICmpInst(Pred, A == Op1 ? B : A,\n                        Constant::getNullValue(Op1->getType()));\n\n  // icmp C, (C+D) -> icmp 0, D for equalities or if there is no overflow.\n  // icmp D, (C+D) -> icmp 0, C for equalities or if there is no overflow.\n  if ((C == Op0 || D == Op0) && NoOp1WrapProblem)\n    return new ICmpInst(Pred, Constant::getNullValue(Op0->getType()),\n                        C == Op0 ? D : C);\n\n  // icmp (A+B), (A+D) -> icmp B, D for equalities or if there is no overflow.\n  if (A && C && (A == C || A == D || B == C || B == D) && NoOp0WrapProblem &&\n      NoOp1WrapProblem) {\n    // Determine Y and Z in the form icmp (X+Y), (X+Z).\n    Value *Y, *Z;\n    if (A == C) {\n      // C + B == C + D  ->  B == D\n      Y = B;\n      Z = D;\n    } else if (A == D) {\n      // D + B == C + D  ->  B == C\n      Y = B;\n      Z = C;\n    } else if (B == C) {\n      // A + C == C + D  ->  A == D\n      Y = A;\n      Z = D;\n    } else {\n      assert(B == D);\n      // A + D == C + D  ->  A == C\n      Y = A;\n      Z = C;\n    }\n    return new ICmpInst(Pred, Y, Z);\n  }\n\n  // icmp slt (A + -1), Op1 -> icmp sle A, Op1\n  if (A && NoOp0WrapProblem && Pred == CmpInst::ICMP_SLT &&\n      match(B, m_AllOnes()))\n    return new ICmpInst(CmpInst::ICMP_SLE, A, Op1);\n\n  // icmp sge (A + -1), Op1 -> icmp sgt A, Op1\n  if (A && NoOp0WrapProblem && Pred == CmpInst::ICMP_SGE &&\n      match(B, m_AllOnes()))\n    return new ICmpInst(CmpInst::ICMP_SGT, A, Op1);\n\n  // icmp sle (A + 1), Op1 -> icmp slt A, Op1\n  if (A && NoOp0WrapProblem && Pred == CmpInst::ICMP_SLE && match(B, m_One()))\n    return new ICmpInst(CmpInst::ICMP_SLT, A, Op1);\n\n  // icmp sgt (A + 1), Op1 -> icmp sge A, Op1\n  if (A && NoOp0WrapProblem && Pred == CmpInst::ICMP_SGT && match(B, m_One()))\n    return new ICmpInst(CmpInst::ICMP_SGE, A, Op1);\n\n  // icmp sgt Op0, (C + -1) -> icmp sge Op0, C\n  if (C && NoOp1WrapProblem && Pred == CmpInst::ICMP_SGT &&\n      match(D, m_AllOnes()))\n    return new ICmpInst(CmpInst::ICMP_SGE, Op0, C);\n\n  // icmp sle Op0, (C + -1) -> icmp slt Op0, C\n  if (C && NoOp1WrapProblem && Pred == CmpInst::ICMP_SLE &&\n      match(D, m_AllOnes()))\n    return new ICmpInst(CmpInst::ICMP_SLT, Op0, C);\n\n  // icmp sge Op0, (C + 1) -> icmp sgt Op0, C\n  if (C && NoOp1WrapProblem && Pred == CmpInst::ICMP_SGE && match(D, m_One()))\n    return new ICmpInst(CmpInst::ICMP_SGT, Op0, C);\n\n  // icmp slt Op0, (C + 1) -> icmp sle Op0, C\n  if (C && NoOp1WrapProblem && Pred == CmpInst::ICMP_SLT && match(D, m_One()))\n    return new ICmpInst(CmpInst::ICMP_SLE, Op0, C);\n\n  // TODO: The subtraction-related identities shown below also hold, but\n  // canonicalization from (X -nuw 1) to (X + -1) means that the combinations\n  // wouldn't happen even if they were implemented.\n  //\n  // icmp ult (A - 1), Op1 -> icmp ule A, Op1\n  // icmp uge (A - 1), Op1 -> icmp ugt A, Op1\n  // icmp ugt Op0, (C - 1) -> icmp uge Op0, C\n  // icmp ule Op0, (C - 1) -> icmp ult Op0, C\n\n  // icmp ule (A + 1), Op0 -> icmp ult A, Op1\n  if (A && NoOp0WrapProblem && Pred == CmpInst::ICMP_ULE && match(B, m_One()))\n    return new ICmpInst(CmpInst::ICMP_ULT, A, Op1);\n\n  // icmp ugt (A + 1), Op0 -> icmp uge A, Op1\n  if (A && NoOp0WrapProblem && Pred == CmpInst::ICMP_UGT && match(B, m_One()))\n    return new ICmpInst(CmpInst::ICMP_UGE, A, Op1);\n\n  // icmp uge Op0, (C + 1) -> icmp ugt Op0, C\n  if (C && NoOp1WrapProblem && Pred == CmpInst::ICMP_UGE && match(D, m_One()))\n    return new ICmpInst(CmpInst::ICMP_UGT, Op0, C);\n\n  // icmp ult Op0, (C + 1) -> icmp ule Op0, C\n  if (C && NoOp1WrapProblem && Pred == CmpInst::ICMP_ULT && match(D, m_One()))\n    return new ICmpInst(CmpInst::ICMP_ULE, Op0, C);\n\n  // if C1 has greater magnitude than C2:\n  //  icmp (A + C1), (C + C2) -> icmp (A + C3), C\n  //  s.t. C3 = C1 - C2\n  //\n  // if C2 has greater magnitude than C1:\n  //  icmp (A + C1), (C + C2) -> icmp A, (C + C3)\n  //  s.t. C3 = C2 - C1\n  if (A && C && NoOp0WrapProblem && NoOp1WrapProblem &&\n      (BO0->hasOneUse() || BO1->hasOneUse()) && !I.isUnsigned())\n    if (ConstantInt *C1 = dyn_cast<ConstantInt>(B))\n      if (ConstantInt *C2 = dyn_cast<ConstantInt>(D)) {\n        const APInt &AP1 = C1->getValue();\n        const APInt &AP2 = C2->getValue();\n        if (AP1.isNegative() == AP2.isNegative()) {\n          APInt AP1Abs = C1->getValue().abs();\n          APInt AP2Abs = C2->getValue().abs();\n          if (AP1Abs.uge(AP2Abs)) {\n            ConstantInt *C3 = Builder.getInt(AP1 - AP2);\n            Value *NewAdd = Builder.CreateNSWAdd(A, C3);\n            return new ICmpInst(Pred, NewAdd, C);\n          } else {\n            ConstantInt *C3 = Builder.getInt(AP2 - AP1);\n            Value *NewAdd = Builder.CreateNSWAdd(C, C3);\n            return new ICmpInst(Pred, A, NewAdd);\n          }\n        }\n      }\n\n  // Analyze the case when either Op0 or Op1 is a sub instruction.\n  // Op0 = A - B (or A and B are null); Op1 = C - D (or C and D are null).\n  A = nullptr;\n  B = nullptr;\n  C = nullptr;\n  D = nullptr;\n  if (BO0 && BO0->getOpcode() == Instruction::Sub) {\n    A = BO0->getOperand(0);\n    B = BO0->getOperand(1);\n  }\n  if (BO1 && BO1->getOpcode() == Instruction::Sub) {\n    C = BO1->getOperand(0);\n    D = BO1->getOperand(1);\n  }\n\n  // icmp (A-B), A -> icmp 0, B for equalities or if there is no overflow.\n  if (A == Op1 && NoOp0WrapProblem)\n    return new ICmpInst(Pred, Constant::getNullValue(Op1->getType()), B);\n  // icmp C, (C-D) -> icmp D, 0 for equalities or if there is no overflow.\n  if (C == Op0 && NoOp1WrapProblem)\n    return new ICmpInst(Pred, D, Constant::getNullValue(Op0->getType()));\n\n  // Convert sub-with-unsigned-overflow comparisons into a comparison of args.\n  // (A - B) u>/u<= A --> B u>/u<= A\n  if (A == Op1 && (Pred == ICmpInst::ICMP_UGT || Pred == ICmpInst::ICMP_ULE))\n    return new ICmpInst(Pred, B, A);\n  // C u</u>= (C - D) --> C u</u>= D\n  if (C == Op0 && (Pred == ICmpInst::ICMP_ULT || Pred == ICmpInst::ICMP_UGE))\n    return new ICmpInst(Pred, C, D);\n  // (A - B) u>=/u< A --> B u>/u<= A  iff B != 0\n  if (A == Op1 && (Pred == ICmpInst::ICMP_UGE || Pred == ICmpInst::ICMP_ULT) &&\n      isKnownNonZero(B, Q.DL, /*Depth=*/0, Q.AC, Q.CxtI, Q.DT))\n    return new ICmpInst(CmpInst::getFlippedStrictnessPredicate(Pred), B, A);\n  // C u<=/u> (C - D) --> C u</u>= D  iff B != 0\n  if (C == Op0 && (Pred == ICmpInst::ICMP_ULE || Pred == ICmpInst::ICMP_UGT) &&\n      isKnownNonZero(D, Q.DL, /*Depth=*/0, Q.AC, Q.CxtI, Q.DT))\n    return new ICmpInst(CmpInst::getFlippedStrictnessPredicate(Pred), C, D);\n\n  // icmp (A-B), (C-B) -> icmp A, C for equalities or if there is no overflow.\n  if (B && D && B == D && NoOp0WrapProblem && NoOp1WrapProblem)\n    return new ICmpInst(Pred, A, C);\n\n  // icmp (A-B), (A-D) -> icmp D, B for equalities or if there is no overflow.\n  if (A && C && A == C && NoOp0WrapProblem && NoOp1WrapProblem)\n    return new ICmpInst(Pred, D, B);\n\n  // icmp (0-X) < cst --> x > -cst\n  if (NoOp0WrapProblem && ICmpInst::isSigned(Pred)) {\n    Value *X;\n    if (match(BO0, m_Neg(m_Value(X))))\n      if (Constant *RHSC = dyn_cast<Constant>(Op1))\n        if (RHSC->isNotMinSignedValue())\n          return new ICmpInst(I.getSwappedPredicate(), X,\n                              ConstantExpr::getNeg(RHSC));\n  }\n\n  {\n    // Try to remove shared constant multiplier from equality comparison:\n    // X * C == Y * C (with no overflowing/aliasing) --> X == Y\n    Value *X, *Y;\n    const APInt *C;\n    if (match(Op0, m_Mul(m_Value(X), m_APInt(C))) && *C != 0 &&\n        match(Op1, m_Mul(m_Value(Y), m_SpecificInt(*C))) && I.isEquality())\n      if (!C->countTrailingZeros() ||\n          (BO0->hasNoSignedWrap() && BO1->hasNoSignedWrap()) ||\n          (BO0->hasNoUnsignedWrap() && BO1->hasNoUnsignedWrap()))\n      return new ICmpInst(Pred, X, Y);\n  }\n\n  BinaryOperator *SRem = nullptr;\n  // icmp (srem X, Y), Y\n  if (BO0 && BO0->getOpcode() == Instruction::SRem && Op1 == BO0->getOperand(1))\n    SRem = BO0;\n  // icmp Y, (srem X, Y)\n  else if (BO1 && BO1->getOpcode() == Instruction::SRem &&\n           Op0 == BO1->getOperand(1))\n    SRem = BO1;\n  if (SRem) {\n    // We don't check hasOneUse to avoid increasing register pressure because\n    // the value we use is the same value this instruction was already using.\n    switch (SRem == BO0 ? ICmpInst::getSwappedPredicate(Pred) : Pred) {\n    default:\n      break;\n    case ICmpInst::ICMP_EQ:\n      return replaceInstUsesWith(I, ConstantInt::getFalse(I.getType()));\n    case ICmpInst::ICMP_NE:\n      return replaceInstUsesWith(I, ConstantInt::getTrue(I.getType()));\n    case ICmpInst::ICMP_SGT:\n    case ICmpInst::ICMP_SGE:\n      return new ICmpInst(ICmpInst::ICMP_SGT, SRem->getOperand(1),\n                          Constant::getAllOnesValue(SRem->getType()));\n    case ICmpInst::ICMP_SLT:\n    case ICmpInst::ICMP_SLE:\n      return new ICmpInst(ICmpInst::ICMP_SLT, SRem->getOperand(1),\n                          Constant::getNullValue(SRem->getType()));\n    }\n  }\n\n  if (BO0 && BO1 && BO0->getOpcode() == BO1->getOpcode() && BO0->hasOneUse() &&\n      BO1->hasOneUse() && BO0->getOperand(1) == BO1->getOperand(1)) {\n    switch (BO0->getOpcode()) {\n    default:\n      break;\n    case Instruction::Add:\n    case Instruction::Sub:\n    case Instruction::Xor: {\n      if (I.isEquality()) // a+x icmp eq/ne b+x --> a icmp b\n        return new ICmpInst(Pred, BO0->getOperand(0), BO1->getOperand(0));\n\n      const APInt *C;\n      if (match(BO0->getOperand(1), m_APInt(C))) {\n        // icmp u/s (a ^ signmask), (b ^ signmask) --> icmp s/u a, b\n        if (C->isSignMask()) {\n          ICmpInst::Predicate NewPred = I.getFlippedSignednessPredicate();\n          return new ICmpInst(NewPred, BO0->getOperand(0), BO1->getOperand(0));\n        }\n\n        // icmp u/s (a ^ maxsignval), (b ^ maxsignval) --> icmp s/u' a, b\n        if (BO0->getOpcode() == Instruction::Xor && C->isMaxSignedValue()) {\n          ICmpInst::Predicate NewPred = I.getFlippedSignednessPredicate();\n          NewPred = I.getSwappedPredicate(NewPred);\n          return new ICmpInst(NewPred, BO0->getOperand(0), BO1->getOperand(0));\n        }\n      }\n      break;\n    }\n    case Instruction::Mul: {\n      if (!I.isEquality())\n        break;\n\n      const APInt *C;\n      if (match(BO0->getOperand(1), m_APInt(C)) && !C->isNullValue() &&\n          !C->isOneValue()) {\n        // icmp eq/ne (X * C), (Y * C) --> icmp (X & Mask), (Y & Mask)\n        // Mask = -1 >> count-trailing-zeros(C).\n        if (unsigned TZs = C->countTrailingZeros()) {\n          Constant *Mask = ConstantInt::get(\n              BO0->getType(),\n              APInt::getLowBitsSet(C->getBitWidth(), C->getBitWidth() - TZs));\n          Value *And1 = Builder.CreateAnd(BO0->getOperand(0), Mask);\n          Value *And2 = Builder.CreateAnd(BO1->getOperand(0), Mask);\n          return new ICmpInst(Pred, And1, And2);\n        }\n      }\n      break;\n    }\n    case Instruction::UDiv:\n    case Instruction::LShr:\n      if (I.isSigned() || !BO0->isExact() || !BO1->isExact())\n        break;\n      return new ICmpInst(Pred, BO0->getOperand(0), BO1->getOperand(0));\n\n    case Instruction::SDiv:\n      if (!I.isEquality() || !BO0->isExact() || !BO1->isExact())\n        break;\n      return new ICmpInst(Pred, BO0->getOperand(0), BO1->getOperand(0));\n\n    case Instruction::AShr:\n      if (!BO0->isExact() || !BO1->isExact())\n        break;\n      return new ICmpInst(Pred, BO0->getOperand(0), BO1->getOperand(0));\n\n    case Instruction::Shl: {\n      bool NUW = BO0->hasNoUnsignedWrap() && BO1->hasNoUnsignedWrap();\n      bool NSW = BO0->hasNoSignedWrap() && BO1->hasNoSignedWrap();\n      if (!NUW && !NSW)\n        break;\n      if (!NSW && I.isSigned())\n        break;\n      return new ICmpInst(Pred, BO0->getOperand(0), BO1->getOperand(0));\n    }\n    }\n  }\n\n  if (BO0) {\n    // Transform  A & (L - 1) `ult` L --> L != 0\n    auto LSubOne = m_Add(m_Specific(Op1), m_AllOnes());\n    auto BitwiseAnd = m_c_And(m_Value(), LSubOne);\n\n    if (match(BO0, BitwiseAnd) && Pred == ICmpInst::ICMP_ULT) {\n      auto *Zero = Constant::getNullValue(BO0->getType());\n      return new ICmpInst(ICmpInst::ICMP_NE, Op1, Zero);\n    }\n  }\n\n  if (Value *V = foldUnsignedMultiplicationOverflowCheck(I))\n    return replaceInstUsesWith(I, V);\n\n  if (Value *V = foldICmpWithLowBitMaskedVal(I, Builder))\n    return replaceInstUsesWith(I, V);\n\n  if (Value *V = foldICmpWithTruncSignExtendedVal(I, Builder))\n    return replaceInstUsesWith(I, V);\n\n  if (Value *V = foldShiftIntoShiftInAnotherHandOfAndInICmp(I, SQ, Builder))\n    return replaceInstUsesWith(I, V);\n\n  return nullptr;\n}\n\n/// Fold icmp Pred min|max(X, Y), X.\nstatic Instruction *foldICmpWithMinMax(ICmpInst &Cmp) {\n  ICmpInst::Predicate Pred = Cmp.getPredicate();\n  Value *Op0 = Cmp.getOperand(0);\n  Value *X = Cmp.getOperand(1);\n\n  // Canonicalize minimum or maximum operand to LHS of the icmp.\n  if (match(X, m_c_SMin(m_Specific(Op0), m_Value())) ||\n      match(X, m_c_SMax(m_Specific(Op0), m_Value())) ||\n      match(X, m_c_UMin(m_Specific(Op0), m_Value())) ||\n      match(X, m_c_UMax(m_Specific(Op0), m_Value()))) {\n    std::swap(Op0, X);\n    Pred = Cmp.getSwappedPredicate();\n  }\n\n  Value *Y;\n  if (match(Op0, m_c_SMin(m_Specific(X), m_Value(Y)))) {\n    // smin(X, Y)  == X --> X s<= Y\n    // smin(X, Y) s>= X --> X s<= Y\n    if (Pred == CmpInst::ICMP_EQ || Pred == CmpInst::ICMP_SGE)\n      return new ICmpInst(ICmpInst::ICMP_SLE, X, Y);\n\n    // smin(X, Y) != X --> X s> Y\n    // smin(X, Y) s< X --> X s> Y\n    if (Pred == CmpInst::ICMP_NE || Pred == CmpInst::ICMP_SLT)\n      return new ICmpInst(ICmpInst::ICMP_SGT, X, Y);\n\n    // These cases should be handled in InstSimplify:\n    // smin(X, Y) s<= X --> true\n    // smin(X, Y) s> X --> false\n    return nullptr;\n  }\n\n  if (match(Op0, m_c_SMax(m_Specific(X), m_Value(Y)))) {\n    // smax(X, Y)  == X --> X s>= Y\n    // smax(X, Y) s<= X --> X s>= Y\n    if (Pred == CmpInst::ICMP_EQ || Pred == CmpInst::ICMP_SLE)\n      return new ICmpInst(ICmpInst::ICMP_SGE, X, Y);\n\n    // smax(X, Y) != X --> X s< Y\n    // smax(X, Y) s> X --> X s< Y\n    if (Pred == CmpInst::ICMP_NE || Pred == CmpInst::ICMP_SGT)\n      return new ICmpInst(ICmpInst::ICMP_SLT, X, Y);\n\n    // These cases should be handled in InstSimplify:\n    // smax(X, Y) s>= X --> true\n    // smax(X, Y) s< X --> false\n    return nullptr;\n  }\n\n  if (match(Op0, m_c_UMin(m_Specific(X), m_Value(Y)))) {\n    // umin(X, Y)  == X --> X u<= Y\n    // umin(X, Y) u>= X --> X u<= Y\n    if (Pred == CmpInst::ICMP_EQ || Pred == CmpInst::ICMP_UGE)\n      return new ICmpInst(ICmpInst::ICMP_ULE, X, Y);\n\n    // umin(X, Y) != X --> X u> Y\n    // umin(X, Y) u< X --> X u> Y\n    if (Pred == CmpInst::ICMP_NE || Pred == CmpInst::ICMP_ULT)\n      return new ICmpInst(ICmpInst::ICMP_UGT, X, Y);\n\n    // These cases should be handled in InstSimplify:\n    // umin(X, Y) u<= X --> true\n    // umin(X, Y) u> X --> false\n    return nullptr;\n  }\n\n  if (match(Op0, m_c_UMax(m_Specific(X), m_Value(Y)))) {\n    // umax(X, Y)  == X --> X u>= Y\n    // umax(X, Y) u<= X --> X u>= Y\n    if (Pred == CmpInst::ICMP_EQ || Pred == CmpInst::ICMP_ULE)\n      return new ICmpInst(ICmpInst::ICMP_UGE, X, Y);\n\n    // umax(X, Y) != X --> X u< Y\n    // umax(X, Y) u> X --> X u< Y\n    if (Pred == CmpInst::ICMP_NE || Pred == CmpInst::ICMP_UGT)\n      return new ICmpInst(ICmpInst::ICMP_ULT, X, Y);\n\n    // These cases should be handled in InstSimplify:\n    // umax(X, Y) u>= X --> true\n    // umax(X, Y) u< X --> false\n    return nullptr;\n  }\n\n  return nullptr;\n}\n\nInstruction *InstCombinerImpl::foldICmpEquality(ICmpInst &I) {\n  if (!I.isEquality())\n    return nullptr;\n\n  Value *Op0 = I.getOperand(0), *Op1 = I.getOperand(1);\n  const CmpInst::Predicate Pred = I.getPredicate();\n  Value *A, *B, *C, *D;\n  if (match(Op0, m_Xor(m_Value(A), m_Value(B)))) {\n    if (A == Op1 || B == Op1) { // (A^B) == A  ->  B == 0\n      Value *OtherVal = A == Op1 ? B : A;\n      return new ICmpInst(Pred, OtherVal, Constant::getNullValue(A->getType()));\n    }\n\n    if (match(Op1, m_Xor(m_Value(C), m_Value(D)))) {\n      // A^c1 == C^c2 --> A == C^(c1^c2)\n      ConstantInt *C1, *C2;\n      if (match(B, m_ConstantInt(C1)) && match(D, m_ConstantInt(C2)) &&\n          Op1->hasOneUse()) {\n        Constant *NC = Builder.getInt(C1->getValue() ^ C2->getValue());\n        Value *Xor = Builder.CreateXor(C, NC);\n        return new ICmpInst(Pred, A, Xor);\n      }\n\n      // A^B == A^D -> B == D\n      if (A == C)\n        return new ICmpInst(Pred, B, D);\n      if (A == D)\n        return new ICmpInst(Pred, B, C);\n      if (B == C)\n        return new ICmpInst(Pred, A, D);\n      if (B == D)\n        return new ICmpInst(Pred, A, C);\n    }\n  }\n\n  if (match(Op1, m_Xor(m_Value(A), m_Value(B))) && (A == Op0 || B == Op0)) {\n    // A == (A^B)  ->  B == 0\n    Value *OtherVal = A == Op0 ? B : A;\n    return new ICmpInst(Pred, OtherVal, Constant::getNullValue(A->getType()));\n  }\n\n  // (X&Z) == (Y&Z) -> (X^Y) & Z == 0\n  if (match(Op0, m_OneUse(m_And(m_Value(A), m_Value(B)))) &&\n      match(Op1, m_OneUse(m_And(m_Value(C), m_Value(D))))) {\n    Value *X = nullptr, *Y = nullptr, *Z = nullptr;\n\n    if (A == C) {\n      X = B;\n      Y = D;\n      Z = A;\n    } else if (A == D) {\n      X = B;\n      Y = C;\n      Z = A;\n    } else if (B == C) {\n      X = A;\n      Y = D;\n      Z = B;\n    } else if (B == D) {\n      X = A;\n      Y = C;\n      Z = B;\n    }\n\n    if (X) { // Build (X^Y) & Z\n      Op1 = Builder.CreateXor(X, Y);\n      Op1 = Builder.CreateAnd(Op1, Z);\n      return new ICmpInst(Pred, Op1, Constant::getNullValue(Op1->getType()));\n    }\n  }\n\n  // Transform (zext A) == (B & (1<<X)-1) --> A == (trunc B)\n  // and       (B & (1<<X)-1) == (zext A) --> A == (trunc B)\n  ConstantInt *Cst1;\n  if ((Op0->hasOneUse() && match(Op0, m_ZExt(m_Value(A))) &&\n       match(Op1, m_And(m_Value(B), m_ConstantInt(Cst1)))) ||\n      (Op1->hasOneUse() && match(Op0, m_And(m_Value(B), m_ConstantInt(Cst1))) &&\n       match(Op1, m_ZExt(m_Value(A))))) {\n    APInt Pow2 = Cst1->getValue() + 1;\n    if (Pow2.isPowerOf2() && isa<IntegerType>(A->getType()) &&\n        Pow2.logBase2() == cast<IntegerType>(A->getType())->getBitWidth())\n      return new ICmpInst(Pred, A, Builder.CreateTrunc(B, A->getType()));\n  }\n\n  // (A >> C) == (B >> C) --> (A^B) u< (1 << C)\n  // For lshr and ashr pairs.\n  if ((match(Op0, m_OneUse(m_LShr(m_Value(A), m_ConstantInt(Cst1)))) &&\n       match(Op1, m_OneUse(m_LShr(m_Value(B), m_Specific(Cst1))))) ||\n      (match(Op0, m_OneUse(m_AShr(m_Value(A), m_ConstantInt(Cst1)))) &&\n       match(Op1, m_OneUse(m_AShr(m_Value(B), m_Specific(Cst1)))))) {\n    unsigned TypeBits = Cst1->getBitWidth();\n    unsigned ShAmt = (unsigned)Cst1->getLimitedValue(TypeBits);\n    if (ShAmt < TypeBits && ShAmt != 0) {\n      ICmpInst::Predicate NewPred =\n          Pred == ICmpInst::ICMP_NE ? ICmpInst::ICMP_UGE : ICmpInst::ICMP_ULT;\n      Value *Xor = Builder.CreateXor(A, B, I.getName() + \".unshifted\");\n      APInt CmpVal = APInt::getOneBitSet(TypeBits, ShAmt);\n      return new ICmpInst(NewPred, Xor, Builder.getInt(CmpVal));\n    }\n  }\n\n  // (A << C) == (B << C) --> ((A^B) & (~0U >> C)) == 0\n  if (match(Op0, m_OneUse(m_Shl(m_Value(A), m_ConstantInt(Cst1)))) &&\n      match(Op1, m_OneUse(m_Shl(m_Value(B), m_Specific(Cst1))))) {\n    unsigned TypeBits = Cst1->getBitWidth();\n    unsigned ShAmt = (unsigned)Cst1->getLimitedValue(TypeBits);\n    if (ShAmt < TypeBits && ShAmt != 0) {\n      Value *Xor = Builder.CreateXor(A, B, I.getName() + \".unshifted\");\n      APInt AndVal = APInt::getLowBitsSet(TypeBits, TypeBits - ShAmt);\n      Value *And = Builder.CreateAnd(Xor, Builder.getInt(AndVal),\n                                      I.getName() + \".mask\");\n      return new ICmpInst(Pred, And, Constant::getNullValue(Cst1->getType()));\n    }\n  }\n\n  // Transform \"icmp eq (trunc (lshr(X, cst1)), cst\" to\n  // \"icmp (and X, mask), cst\"\n  uint64_t ShAmt = 0;\n  if (Op0->hasOneUse() &&\n      match(Op0, m_Trunc(m_OneUse(m_LShr(m_Value(A), m_ConstantInt(ShAmt))))) &&\n      match(Op1, m_ConstantInt(Cst1)) &&\n      // Only do this when A has multiple uses.  This is most important to do\n      // when it exposes other optimizations.\n      !A->hasOneUse()) {\n    unsigned ASize = cast<IntegerType>(A->getType())->getPrimitiveSizeInBits();\n\n    if (ShAmt < ASize) {\n      APInt MaskV =\n          APInt::getLowBitsSet(ASize, Op0->getType()->getPrimitiveSizeInBits());\n      MaskV <<= ShAmt;\n\n      APInt CmpV = Cst1->getValue().zext(ASize);\n      CmpV <<= ShAmt;\n\n      Value *Mask = Builder.CreateAnd(A, Builder.getInt(MaskV));\n      return new ICmpInst(Pred, Mask, Builder.getInt(CmpV));\n    }\n  }\n\n  // If both operands are byte-swapped or bit-reversed, just compare the\n  // original values.\n  // TODO: Move this to a function similar to foldICmpIntrinsicWithConstant()\n  // and handle more intrinsics.\n  if ((match(Op0, m_BSwap(m_Value(A))) && match(Op1, m_BSwap(m_Value(B)))) ||\n      (match(Op0, m_BitReverse(m_Value(A))) &&\n       match(Op1, m_BitReverse(m_Value(B)))))\n    return new ICmpInst(Pred, A, B);\n\n  // Canonicalize checking for a power-of-2-or-zero value:\n  // (A & (A-1)) == 0 --> ctpop(A) < 2 (two commuted variants)\n  // ((A-1) & A) != 0 --> ctpop(A) > 1 (two commuted variants)\n  if (!match(Op0, m_OneUse(m_c_And(m_Add(m_Value(A), m_AllOnes()),\n                                   m_Deferred(A)))) ||\n      !match(Op1, m_ZeroInt()))\n    A = nullptr;\n\n  // (A & -A) == A --> ctpop(A) < 2 (four commuted variants)\n  // (-A & A) != A --> ctpop(A) > 1 (four commuted variants)\n  if (match(Op0, m_OneUse(m_c_And(m_Neg(m_Specific(Op1)), m_Specific(Op1)))))\n    A = Op1;\n  else if (match(Op1,\n                 m_OneUse(m_c_And(m_Neg(m_Specific(Op0)), m_Specific(Op0)))))\n    A = Op0;\n\n  if (A) {\n    Type *Ty = A->getType();\n    CallInst *CtPop = Builder.CreateUnaryIntrinsic(Intrinsic::ctpop, A);\n    return Pred == ICmpInst::ICMP_EQ\n        ? new ICmpInst(ICmpInst::ICMP_ULT, CtPop, ConstantInt::get(Ty, 2))\n        : new ICmpInst(ICmpInst::ICMP_UGT, CtPop, ConstantInt::get(Ty, 1));\n  }\n\n  return nullptr;\n}\n\nstatic Instruction *foldICmpWithZextOrSext(ICmpInst &ICmp,\n                                           InstCombiner::BuilderTy &Builder) {\n  assert(isa<CastInst>(ICmp.getOperand(0)) && \"Expected cast for operand 0\");\n  auto *CastOp0 = cast<CastInst>(ICmp.getOperand(0));\n  Value *X;\n  if (!match(CastOp0, m_ZExtOrSExt(m_Value(X))))\n    return nullptr;\n\n  bool IsSignedExt = CastOp0->getOpcode() == Instruction::SExt;\n  bool IsSignedCmp = ICmp.isSigned();\n  if (auto *CastOp1 = dyn_cast<CastInst>(ICmp.getOperand(1))) {\n    // If the signedness of the two casts doesn't agree (i.e. one is a sext\n    // and the other is a zext), then we can't handle this.\n    // TODO: This is too strict. We can handle some predicates (equality?).\n    if (CastOp0->getOpcode() != CastOp1->getOpcode())\n      return nullptr;\n\n    // Not an extension from the same type?\n    Value *Y = CastOp1->getOperand(0);\n    Type *XTy = X->getType(), *YTy = Y->getType();\n    if (XTy != YTy) {\n      // One of the casts must have one use because we are creating a new cast.\n      if (!CastOp0->hasOneUse() && !CastOp1->hasOneUse())\n        return nullptr;\n      // Extend the narrower operand to the type of the wider operand.\n      if (XTy->getScalarSizeInBits() < YTy->getScalarSizeInBits())\n        X = Builder.CreateCast(CastOp0->getOpcode(), X, YTy);\n      else if (YTy->getScalarSizeInBits() < XTy->getScalarSizeInBits())\n        Y = Builder.CreateCast(CastOp0->getOpcode(), Y, XTy);\n      else\n        return nullptr;\n    }\n\n    // (zext X) == (zext Y) --> X == Y\n    // (sext X) == (sext Y) --> X == Y\n    if (ICmp.isEquality())\n      return new ICmpInst(ICmp.getPredicate(), X, Y);\n\n    // A signed comparison of sign extended values simplifies into a\n    // signed comparison.\n    if (IsSignedCmp && IsSignedExt)\n      return new ICmpInst(ICmp.getPredicate(), X, Y);\n\n    // The other three cases all fold into an unsigned comparison.\n    return new ICmpInst(ICmp.getUnsignedPredicate(), X, Y);\n  }\n\n  // Below here, we are only folding a compare with constant.\n  auto *C = dyn_cast<Constant>(ICmp.getOperand(1));\n  if (!C)\n    return nullptr;\n\n  // Compute the constant that would happen if we truncated to SrcTy then\n  // re-extended to DestTy.\n  Type *SrcTy = CastOp0->getSrcTy();\n  Type *DestTy = CastOp0->getDestTy();\n  Constant *Res1 = ConstantExpr::getTrunc(C, SrcTy);\n  Constant *Res2 = ConstantExpr::getCast(CastOp0->getOpcode(), Res1, DestTy);\n\n  // If the re-extended constant didn't change...\n  if (Res2 == C) {\n    if (ICmp.isEquality())\n      return new ICmpInst(ICmp.getPredicate(), X, Res1);\n\n    // A signed comparison of sign extended values simplifies into a\n    // signed comparison.\n    if (IsSignedExt && IsSignedCmp)\n      return new ICmpInst(ICmp.getPredicate(), X, Res1);\n\n    // The other three cases all fold into an unsigned comparison.\n    return new ICmpInst(ICmp.getUnsignedPredicate(), X, Res1);\n  }\n\n  // The re-extended constant changed, partly changed (in the case of a vector),\n  // or could not be determined to be equal (in the case of a constant\n  // expression), so the constant cannot be represented in the shorter type.\n  // All the cases that fold to true or false will have already been handled\n  // by SimplifyICmpInst, so only deal with the tricky case.\n  if (IsSignedCmp || !IsSignedExt || !isa<ConstantInt>(C))\n    return nullptr;\n\n  // Is source op positive?\n  // icmp ult (sext X), C --> icmp sgt X, -1\n  if (ICmp.getPredicate() == ICmpInst::ICMP_ULT)\n    return new ICmpInst(CmpInst::ICMP_SGT, X, Constant::getAllOnesValue(SrcTy));\n\n  // Is source op negative?\n  // icmp ugt (sext X), C --> icmp slt X, 0\n  assert(ICmp.getPredicate() == ICmpInst::ICMP_UGT && \"ICmp should be folded!\");\n  return new ICmpInst(CmpInst::ICMP_SLT, X, Constant::getNullValue(SrcTy));\n}\n\n/// Handle icmp (cast x), (cast or constant).\nInstruction *InstCombinerImpl::foldICmpWithCastOp(ICmpInst &ICmp) {\n  auto *CastOp0 = dyn_cast<CastInst>(ICmp.getOperand(0));\n  if (!CastOp0)\n    return nullptr;\n  if (!isa<Constant>(ICmp.getOperand(1)) && !isa<CastInst>(ICmp.getOperand(1)))\n    return nullptr;\n\n  Value *Op0Src = CastOp0->getOperand(0);\n  Type *SrcTy = CastOp0->getSrcTy();\n  Type *DestTy = CastOp0->getDestTy();\n\n  // Turn icmp (ptrtoint x), (ptrtoint/c) into a compare of the input if the\n  // integer type is the same size as the pointer type.\n  auto CompatibleSizes = [&](Type *SrcTy, Type *DestTy) {\n    if (isa<VectorType>(SrcTy)) {\n      SrcTy = cast<VectorType>(SrcTy)->getElementType();\n      DestTy = cast<VectorType>(DestTy)->getElementType();\n    }\n    return DL.getPointerTypeSizeInBits(SrcTy) == DestTy->getIntegerBitWidth();\n  };\n  if (CastOp0->getOpcode() == Instruction::PtrToInt &&\n      CompatibleSizes(SrcTy, DestTy)) {\n    Value *NewOp1 = nullptr;\n    if (auto *PtrToIntOp1 = dyn_cast<PtrToIntOperator>(ICmp.getOperand(1))) {\n      Value *PtrSrc = PtrToIntOp1->getOperand(0);\n      if (PtrSrc->getType()->getPointerAddressSpace() ==\n          Op0Src->getType()->getPointerAddressSpace()) {\n        NewOp1 = PtrToIntOp1->getOperand(0);\n        // If the pointer types don't match, insert a bitcast.\n        if (Op0Src->getType() != NewOp1->getType())\n          NewOp1 = Builder.CreateBitCast(NewOp1, Op0Src->getType());\n      }\n    } else if (auto *RHSC = dyn_cast<Constant>(ICmp.getOperand(1))) {\n      NewOp1 = ConstantExpr::getIntToPtr(RHSC, SrcTy);\n    }\n\n    if (NewOp1)\n      return new ICmpInst(ICmp.getPredicate(), Op0Src, NewOp1);\n  }\n\n  return foldICmpWithZextOrSext(ICmp, Builder);\n}\n\nstatic bool isNeutralValue(Instruction::BinaryOps BinaryOp, Value *RHS) {\n  switch (BinaryOp) {\n    default:\n      llvm_unreachable(\"Unsupported binary op\");\n    case Instruction::Add:\n    case Instruction::Sub:\n      return match(RHS, m_Zero());\n    case Instruction::Mul:\n      return match(RHS, m_One());\n  }\n}\n\nOverflowResult\nInstCombinerImpl::computeOverflow(Instruction::BinaryOps BinaryOp,\n                                  bool IsSigned, Value *LHS, Value *RHS,\n                                  Instruction *CxtI) const {\n  switch (BinaryOp) {\n    default:\n      llvm_unreachable(\"Unsupported binary op\");\n    case Instruction::Add:\n      if (IsSigned)\n        return computeOverflowForSignedAdd(LHS, RHS, CxtI);\n      else\n        return computeOverflowForUnsignedAdd(LHS, RHS, CxtI);\n    case Instruction::Sub:\n      if (IsSigned)\n        return computeOverflowForSignedSub(LHS, RHS, CxtI);\n      else\n        return computeOverflowForUnsignedSub(LHS, RHS, CxtI);\n    case Instruction::Mul:\n      if (IsSigned)\n        return computeOverflowForSignedMul(LHS, RHS, CxtI);\n      else\n        return computeOverflowForUnsignedMul(LHS, RHS, CxtI);\n  }\n}\n\nbool InstCombinerImpl::OptimizeOverflowCheck(Instruction::BinaryOps BinaryOp,\n                                             bool IsSigned, Value *LHS,\n                                             Value *RHS, Instruction &OrigI,\n                                             Value *&Result,\n                                             Constant *&Overflow) {\n  if (OrigI.isCommutative() && isa<Constant>(LHS) && !isa<Constant>(RHS))\n    std::swap(LHS, RHS);\n\n  // If the overflow check was an add followed by a compare, the insertion point\n  // may be pointing to the compare.  We want to insert the new instructions\n  // before the add in case there are uses of the add between the add and the\n  // compare.\n  Builder.SetInsertPoint(&OrigI);\n\n  Type *OverflowTy = Type::getInt1Ty(LHS->getContext());\n  if (auto *LHSTy = dyn_cast<VectorType>(LHS->getType()))\n    OverflowTy = VectorType::get(OverflowTy, LHSTy->getElementCount());\n\n  if (isNeutralValue(BinaryOp, RHS)) {\n    Result = LHS;\n    Overflow = ConstantInt::getFalse(OverflowTy);\n    return true;\n  }\n\n  switch (computeOverflow(BinaryOp, IsSigned, LHS, RHS, &OrigI)) {\n    case OverflowResult::MayOverflow:\n      return false;\n    case OverflowResult::AlwaysOverflowsLow:\n    case OverflowResult::AlwaysOverflowsHigh:\n      Result = Builder.CreateBinOp(BinaryOp, LHS, RHS);\n      Result->takeName(&OrigI);\n      Overflow = ConstantInt::getTrue(OverflowTy);\n      return true;\n    case OverflowResult::NeverOverflows:\n      Result = Builder.CreateBinOp(BinaryOp, LHS, RHS);\n      Result->takeName(&OrigI);\n      Overflow = ConstantInt::getFalse(OverflowTy);\n      if (auto *Inst = dyn_cast<Instruction>(Result)) {\n        if (IsSigned)\n          Inst->setHasNoSignedWrap();\n        else\n          Inst->setHasNoUnsignedWrap();\n      }\n      return true;\n  }\n\n  llvm_unreachable(\"Unexpected overflow result\");\n}\n\n/// Recognize and process idiom involving test for multiplication\n/// overflow.\n///\n/// The caller has matched a pattern of the form:\n///   I = cmp u (mul(zext A, zext B), V\n/// The function checks if this is a test for overflow and if so replaces\n/// multiplication with call to 'mul.with.overflow' intrinsic.\n///\n/// \\param I Compare instruction.\n/// \\param MulVal Result of 'mult' instruction.  It is one of the arguments of\n///               the compare instruction.  Must be of integer type.\n/// \\param OtherVal The other argument of compare instruction.\n/// \\returns Instruction which must replace the compare instruction, NULL if no\n///          replacement required.\nstatic Instruction *processUMulZExtIdiom(ICmpInst &I, Value *MulVal,\n                                         Value *OtherVal,\n                                         InstCombinerImpl &IC) {\n  // Don't bother doing this transformation for pointers, don't do it for\n  // vectors.\n  if (!isa<IntegerType>(MulVal->getType()))\n    return nullptr;\n\n  assert(I.getOperand(0) == MulVal || I.getOperand(1) == MulVal);\n  assert(I.getOperand(0) == OtherVal || I.getOperand(1) == OtherVal);\n  auto *MulInstr = dyn_cast<Instruction>(MulVal);\n  if (!MulInstr)\n    return nullptr;\n  assert(MulInstr->getOpcode() == Instruction::Mul);\n\n  auto *LHS = cast<ZExtOperator>(MulInstr->getOperand(0)),\n       *RHS = cast<ZExtOperator>(MulInstr->getOperand(1));\n  assert(LHS->getOpcode() == Instruction::ZExt);\n  assert(RHS->getOpcode() == Instruction::ZExt);\n  Value *A = LHS->getOperand(0), *B = RHS->getOperand(0);\n\n  // Calculate type and width of the result produced by mul.with.overflow.\n  Type *TyA = A->getType(), *TyB = B->getType();\n  unsigned WidthA = TyA->getPrimitiveSizeInBits(),\n           WidthB = TyB->getPrimitiveSizeInBits();\n  unsigned MulWidth;\n  Type *MulType;\n  if (WidthB > WidthA) {\n    MulWidth = WidthB;\n    MulType = TyB;\n  } else {\n    MulWidth = WidthA;\n    MulType = TyA;\n  }\n\n  // In order to replace the original mul with a narrower mul.with.overflow,\n  // all uses must ignore upper bits of the product.  The number of used low\n  // bits must be not greater than the width of mul.with.overflow.\n  if (MulVal->hasNUsesOrMore(2))\n    for (User *U : MulVal->users()) {\n      if (U == &I)\n        continue;\n      if (TruncInst *TI = dyn_cast<TruncInst>(U)) {\n        // Check if truncation ignores bits above MulWidth.\n        unsigned TruncWidth = TI->getType()->getPrimitiveSizeInBits();\n        if (TruncWidth > MulWidth)\n          return nullptr;\n      } else if (BinaryOperator *BO = dyn_cast<BinaryOperator>(U)) {\n        // Check if AND ignores bits above MulWidth.\n        if (BO->getOpcode() != Instruction::And)\n          return nullptr;\n        if (ConstantInt *CI = dyn_cast<ConstantInt>(BO->getOperand(1))) {\n          const APInt &CVal = CI->getValue();\n          if (CVal.getBitWidth() - CVal.countLeadingZeros() > MulWidth)\n            return nullptr;\n        } else {\n          // In this case we could have the operand of the binary operation\n          // being defined in another block, and performing the replacement\n          // could break the dominance relation.\n          return nullptr;\n        }\n      } else {\n        // Other uses prohibit this transformation.\n        return nullptr;\n      }\n    }\n\n  // Recognize patterns\n  switch (I.getPredicate()) {\n  case ICmpInst::ICMP_EQ:\n  case ICmpInst::ICMP_NE:\n    // Recognize pattern:\n    //   mulval = mul(zext A, zext B)\n    //   cmp eq/neq mulval, and(mulval, mask), mask selects low MulWidth bits.\n    ConstantInt *CI;\n    Value *ValToMask;\n    if (match(OtherVal, m_And(m_Value(ValToMask), m_ConstantInt(CI)))) {\n      if (ValToMask != MulVal)\n        return nullptr;\n      const APInt &CVal = CI->getValue() + 1;\n      if (CVal.isPowerOf2()) {\n        unsigned MaskWidth = CVal.logBase2();\n        if (MaskWidth == MulWidth)\n          break; // Recognized\n      }\n    }\n    return nullptr;\n\n  case ICmpInst::ICMP_UGT:\n    // Recognize pattern:\n    //   mulval = mul(zext A, zext B)\n    //   cmp ugt mulval, max\n    if (ConstantInt *CI = dyn_cast<ConstantInt>(OtherVal)) {\n      APInt MaxVal = APInt::getMaxValue(MulWidth);\n      MaxVal = MaxVal.zext(CI->getBitWidth());\n      if (MaxVal.eq(CI->getValue()))\n        break; // Recognized\n    }\n    return nullptr;\n\n  case ICmpInst::ICMP_UGE:\n    // Recognize pattern:\n    //   mulval = mul(zext A, zext B)\n    //   cmp uge mulval, max+1\n    if (ConstantInt *CI = dyn_cast<ConstantInt>(OtherVal)) {\n      APInt MaxVal = APInt::getOneBitSet(CI->getBitWidth(), MulWidth);\n      if (MaxVal.eq(CI->getValue()))\n        break; // Recognized\n    }\n    return nullptr;\n\n  case ICmpInst::ICMP_ULE:\n    // Recognize pattern:\n    //   mulval = mul(zext A, zext B)\n    //   cmp ule mulval, max\n    if (ConstantInt *CI = dyn_cast<ConstantInt>(OtherVal)) {\n      APInt MaxVal = APInt::getMaxValue(MulWidth);\n      MaxVal = MaxVal.zext(CI->getBitWidth());\n      if (MaxVal.eq(CI->getValue()))\n        break; // Recognized\n    }\n    return nullptr;\n\n  case ICmpInst::ICMP_ULT:\n    // Recognize pattern:\n    //   mulval = mul(zext A, zext B)\n    //   cmp ule mulval, max + 1\n    if (ConstantInt *CI = dyn_cast<ConstantInt>(OtherVal)) {\n      APInt MaxVal = APInt::getOneBitSet(CI->getBitWidth(), MulWidth);\n      if (MaxVal.eq(CI->getValue()))\n        break; // Recognized\n    }\n    return nullptr;\n\n  default:\n    return nullptr;\n  }\n\n  InstCombiner::BuilderTy &Builder = IC.Builder;\n  Builder.SetInsertPoint(MulInstr);\n\n  // Replace: mul(zext A, zext B) --> mul.with.overflow(A, B)\n  Value *MulA = A, *MulB = B;\n  if (WidthA < MulWidth)\n    MulA = Builder.CreateZExt(A, MulType);\n  if (WidthB < MulWidth)\n    MulB = Builder.CreateZExt(B, MulType);\n  Function *F = Intrinsic::getDeclaration(\n      I.getModule(), Intrinsic::umul_with_overflow, MulType);\n  CallInst *Call = Builder.CreateCall(F, {MulA, MulB}, \"umul\");\n  IC.addToWorklist(MulInstr);\n\n  // If there are uses of mul result other than the comparison, we know that\n  // they are truncation or binary AND. Change them to use result of\n  // mul.with.overflow and adjust properly mask/size.\n  if (MulVal->hasNUsesOrMore(2)) {\n    Value *Mul = Builder.CreateExtractValue(Call, 0, \"umul.value\");\n    for (User *U : make_early_inc_range(MulVal->users())) {\n      if (U == &I || U == OtherVal)\n        continue;\n      if (TruncInst *TI = dyn_cast<TruncInst>(U)) {\n        if (TI->getType()->getPrimitiveSizeInBits() == MulWidth)\n          IC.replaceInstUsesWith(*TI, Mul);\n        else\n          TI->setOperand(0, Mul);\n      } else if (BinaryOperator *BO = dyn_cast<BinaryOperator>(U)) {\n        assert(BO->getOpcode() == Instruction::And);\n        // Replace (mul & mask) --> zext (mul.with.overflow & short_mask)\n        ConstantInt *CI = cast<ConstantInt>(BO->getOperand(1));\n        APInt ShortMask = CI->getValue().trunc(MulWidth);\n        Value *ShortAnd = Builder.CreateAnd(Mul, ShortMask);\n        Value *Zext = Builder.CreateZExt(ShortAnd, BO->getType());\n        IC.replaceInstUsesWith(*BO, Zext);\n      } else {\n        llvm_unreachable(\"Unexpected Binary operation\");\n      }\n      IC.addToWorklist(cast<Instruction>(U));\n    }\n  }\n  if (isa<Instruction>(OtherVal))\n    IC.addToWorklist(cast<Instruction>(OtherVal));\n\n  // The original icmp gets replaced with the overflow value, maybe inverted\n  // depending on predicate.\n  bool Inverse = false;\n  switch (I.getPredicate()) {\n  case ICmpInst::ICMP_NE:\n    break;\n  case ICmpInst::ICMP_EQ:\n    Inverse = true;\n    break;\n  case ICmpInst::ICMP_UGT:\n  case ICmpInst::ICMP_UGE:\n    if (I.getOperand(0) == MulVal)\n      break;\n    Inverse = true;\n    break;\n  case ICmpInst::ICMP_ULT:\n  case ICmpInst::ICMP_ULE:\n    if (I.getOperand(1) == MulVal)\n      break;\n    Inverse = true;\n    break;\n  default:\n    llvm_unreachable(\"Unexpected predicate\");\n  }\n  if (Inverse) {\n    Value *Res = Builder.CreateExtractValue(Call, 1);\n    return BinaryOperator::CreateNot(Res);\n  }\n\n  return ExtractValueInst::Create(Call, 1);\n}\n\n/// When performing a comparison against a constant, it is possible that not all\n/// the bits in the LHS are demanded. This helper method computes the mask that\n/// IS demanded.\nstatic APInt getDemandedBitsLHSMask(ICmpInst &I, unsigned BitWidth) {\n  const APInt *RHS;\n  if (!match(I.getOperand(1), m_APInt(RHS)))\n    return APInt::getAllOnesValue(BitWidth);\n\n  // If this is a normal comparison, it demands all bits. If it is a sign bit\n  // comparison, it only demands the sign bit.\n  bool UnusedBit;\n  if (InstCombiner::isSignBitCheck(I.getPredicate(), *RHS, UnusedBit))\n    return APInt::getSignMask(BitWidth);\n\n  switch (I.getPredicate()) {\n  // For a UGT comparison, we don't care about any bits that\n  // correspond to the trailing ones of the comparand.  The value of these\n  // bits doesn't impact the outcome of the comparison, because any value\n  // greater than the RHS must differ in a bit higher than these due to carry.\n  case ICmpInst::ICMP_UGT:\n    return APInt::getBitsSetFrom(BitWidth, RHS->countTrailingOnes());\n\n  // Similarly, for a ULT comparison, we don't care about the trailing zeros.\n  // Any value less than the RHS must differ in a higher bit because of carries.\n  case ICmpInst::ICMP_ULT:\n    return APInt::getBitsSetFrom(BitWidth, RHS->countTrailingZeros());\n\n  default:\n    return APInt::getAllOnesValue(BitWidth);\n  }\n}\n\n/// Check if the order of \\p Op0 and \\p Op1 as operands in an ICmpInst\n/// should be swapped.\n/// The decision is based on how many times these two operands are reused\n/// as subtract operands and their positions in those instructions.\n/// The rationale is that several architectures use the same instruction for\n/// both subtract and cmp. Thus, it is better if the order of those operands\n/// match.\n/// \\return true if Op0 and Op1 should be swapped.\nstatic bool swapMayExposeCSEOpportunities(const Value *Op0, const Value *Op1) {\n  // Filter out pointer values as those cannot appear directly in subtract.\n  // FIXME: we may want to go through inttoptrs or bitcasts.\n  if (Op0->getType()->isPointerTy())\n    return false;\n  // If a subtract already has the same operands as a compare, swapping would be\n  // bad. If a subtract has the same operands as a compare but in reverse order,\n  // then swapping is good.\n  int GoodToSwap = 0;\n  for (const User *U : Op0->users()) {\n    if (match(U, m_Sub(m_Specific(Op1), m_Specific(Op0))))\n      GoodToSwap++;\n    else if (match(U, m_Sub(m_Specific(Op0), m_Specific(Op1))))\n      GoodToSwap--;\n  }\n  return GoodToSwap > 0;\n}\n\n/// Check that one use is in the same block as the definition and all\n/// other uses are in blocks dominated by a given block.\n///\n/// \\param DI Definition\n/// \\param UI Use\n/// \\param DB Block that must dominate all uses of \\p DI outside\n///           the parent block\n/// \\return true when \\p UI is the only use of \\p DI in the parent block\n/// and all other uses of \\p DI are in blocks dominated by \\p DB.\n///\nbool InstCombinerImpl::dominatesAllUses(const Instruction *DI,\n                                        const Instruction *UI,\n                                        const BasicBlock *DB) const {\n  assert(DI && UI && \"Instruction not defined\\n\");\n  // Ignore incomplete definitions.\n  if (!DI->getParent())\n    return false;\n  // DI and UI must be in the same block.\n  if (DI->getParent() != UI->getParent())\n    return false;\n  // Protect from self-referencing blocks.\n  if (DI->getParent() == DB)\n    return false;\n  for (const User *U : DI->users()) {\n    auto *Usr = cast<Instruction>(U);\n    if (Usr != UI && !DT.dominates(DB, Usr->getParent()))\n      return false;\n  }\n  return true;\n}\n\n/// Return true when the instruction sequence within a block is select-cmp-br.\nstatic bool isChainSelectCmpBranch(const SelectInst *SI) {\n  const BasicBlock *BB = SI->getParent();\n  if (!BB)\n    return false;\n  auto *BI = dyn_cast_or_null<BranchInst>(BB->getTerminator());\n  if (!BI || BI->getNumSuccessors() != 2)\n    return false;\n  auto *IC = dyn_cast<ICmpInst>(BI->getCondition());\n  if (!IC || (IC->getOperand(0) != SI && IC->getOperand(1) != SI))\n    return false;\n  return true;\n}\n\n/// True when a select result is replaced by one of its operands\n/// in select-icmp sequence. This will eventually result in the elimination\n/// of the select.\n///\n/// \\param SI    Select instruction\n/// \\param Icmp  Compare instruction\n/// \\param SIOpd Operand that replaces the select\n///\n/// Notes:\n/// - The replacement is global and requires dominator information\n/// - The caller is responsible for the actual replacement\n///\n/// Example:\n///\n/// entry:\n///  %4 = select i1 %3, %C* %0, %C* null\n///  %5 = icmp eq %C* %4, null\n///  br i1 %5, label %9, label %7\n///  ...\n///  ; <label>:7                                       ; preds = %entry\n///  %8 = getelementptr inbounds %C* %4, i64 0, i32 0\n///  ...\n///\n/// can be transformed to\n///\n///  %5 = icmp eq %C* %0, null\n///  %6 = select i1 %3, i1 %5, i1 true\n///  br i1 %6, label %9, label %7\n///  ...\n///  ; <label>:7                                       ; preds = %entry\n///  %8 = getelementptr inbounds %C* %0, i64 0, i32 0  // replace by %0!\n///\n/// Similar when the first operand of the select is a constant or/and\n/// the compare is for not equal rather than equal.\n///\n/// NOTE: The function is only called when the select and compare constants\n/// are equal, the optimization can work only for EQ predicates. This is not a\n/// major restriction since a NE compare should be 'normalized' to an equal\n/// compare, which usually happens in the combiner and test case\n/// select-cmp-br.ll checks for it.\nbool InstCombinerImpl::replacedSelectWithOperand(SelectInst *SI,\n                                                 const ICmpInst *Icmp,\n                                                 const unsigned SIOpd) {\n  assert((SIOpd == 1 || SIOpd == 2) && \"Invalid select operand!\");\n  if (isChainSelectCmpBranch(SI) && Icmp->getPredicate() == ICmpInst::ICMP_EQ) {\n    BasicBlock *Succ = SI->getParent()->getTerminator()->getSuccessor(1);\n    // The check for the single predecessor is not the best that can be\n    // done. But it protects efficiently against cases like when SI's\n    // home block has two successors, Succ and Succ1, and Succ1 predecessor\n    // of Succ. Then SI can't be replaced by SIOpd because the use that gets\n    // replaced can be reached on either path. So the uniqueness check\n    // guarantees that the path all uses of SI (outside SI's parent) are on\n    // is disjoint from all other paths out of SI. But that information\n    // is more expensive to compute, and the trade-off here is in favor\n    // of compile-time. It should also be noticed that we check for a single\n    // predecessor and not only uniqueness. This to handle the situation when\n    // Succ and Succ1 points to the same basic block.\n    if (Succ->getSinglePredecessor() && dominatesAllUses(SI, Icmp, Succ)) {\n      NumSel++;\n      SI->replaceUsesOutsideBlock(SI->getOperand(SIOpd), SI->getParent());\n      return true;\n    }\n  }\n  return false;\n}\n\n/// Try to fold the comparison based on range information we can get by checking\n/// whether bits are known to be zero or one in the inputs.\nInstruction *InstCombinerImpl::foldICmpUsingKnownBits(ICmpInst &I) {\n  Value *Op0 = I.getOperand(0), *Op1 = I.getOperand(1);\n  Type *Ty = Op0->getType();\n  ICmpInst::Predicate Pred = I.getPredicate();\n\n  // Get scalar or pointer size.\n  unsigned BitWidth = Ty->isIntOrIntVectorTy()\n                          ? Ty->getScalarSizeInBits()\n                          : DL.getPointerTypeSizeInBits(Ty->getScalarType());\n\n  if (!BitWidth)\n    return nullptr;\n\n  KnownBits Op0Known(BitWidth);\n  KnownBits Op1Known(BitWidth);\n\n  if (SimplifyDemandedBits(&I, 0,\n                           getDemandedBitsLHSMask(I, BitWidth),\n                           Op0Known, 0))\n    return &I;\n\n  if (SimplifyDemandedBits(&I, 1, APInt::getAllOnesValue(BitWidth),\n                           Op1Known, 0))\n    return &I;\n\n  // Given the known and unknown bits, compute a range that the LHS could be\n  // in.  Compute the Min, Max and RHS values based on the known bits. For the\n  // EQ and NE we use unsigned values.\n  APInt Op0Min(BitWidth, 0), Op0Max(BitWidth, 0);\n  APInt Op1Min(BitWidth, 0), Op1Max(BitWidth, 0);\n  if (I.isSigned()) {\n    Op0Min = Op0Known.getSignedMinValue();\n    Op0Max = Op0Known.getSignedMaxValue();\n    Op1Min = Op1Known.getSignedMinValue();\n    Op1Max = Op1Known.getSignedMaxValue();\n  } else {\n    Op0Min = Op0Known.getMinValue();\n    Op0Max = Op0Known.getMaxValue();\n    Op1Min = Op1Known.getMinValue();\n    Op1Max = Op1Known.getMaxValue();\n  }\n\n  // If Min and Max are known to be the same, then SimplifyDemandedBits figured\n  // out that the LHS or RHS is a constant. Constant fold this now, so that\n  // code below can assume that Min != Max.\n  if (!isa<Constant>(Op0) && Op0Min == Op0Max)\n    return new ICmpInst(Pred, ConstantExpr::getIntegerValue(Ty, Op0Min), Op1);\n  if (!isa<Constant>(Op1) && Op1Min == Op1Max)\n    return new ICmpInst(Pred, Op0, ConstantExpr::getIntegerValue(Ty, Op1Min));\n\n  // Based on the range information we know about the LHS, see if we can\n  // simplify this comparison.  For example, (x&4) < 8 is always true.\n  switch (Pred) {\n  default:\n    llvm_unreachable(\"Unknown icmp opcode!\");\n  case ICmpInst::ICMP_EQ:\n  case ICmpInst::ICMP_NE: {\n    if (Op0Max.ult(Op1Min) || Op0Min.ugt(Op1Max))\n      return replaceInstUsesWith(\n          I, ConstantInt::getBool(I.getType(), Pred == CmpInst::ICMP_NE));\n\n    // If all bits are known zero except for one, then we know at most one bit\n    // is set. If the comparison is against zero, then this is a check to see if\n    // *that* bit is set.\n    APInt Op0KnownZeroInverted = ~Op0Known.Zero;\n    if (Op1Known.isZero()) {\n      // If the LHS is an AND with the same constant, look through it.\n      Value *LHS = nullptr;\n      const APInt *LHSC;\n      if (!match(Op0, m_And(m_Value(LHS), m_APInt(LHSC))) ||\n          *LHSC != Op0KnownZeroInverted)\n        LHS = Op0;\n\n      Value *X;\n      if (match(LHS, m_Shl(m_One(), m_Value(X)))) {\n        APInt ValToCheck = Op0KnownZeroInverted;\n        Type *XTy = X->getType();\n        if (ValToCheck.isPowerOf2()) {\n          // ((1 << X) & 8) == 0 -> X != 3\n          // ((1 << X) & 8) != 0 -> X == 3\n          auto *CmpC = ConstantInt::get(XTy, ValToCheck.countTrailingZeros());\n          auto NewPred = ICmpInst::getInversePredicate(Pred);\n          return new ICmpInst(NewPred, X, CmpC);\n        } else if ((++ValToCheck).isPowerOf2()) {\n          // ((1 << X) & 7) == 0 -> X >= 3\n          // ((1 << X) & 7) != 0 -> X  < 3\n          auto *CmpC = ConstantInt::get(XTy, ValToCheck.countTrailingZeros());\n          auto NewPred =\n              Pred == CmpInst::ICMP_EQ ? CmpInst::ICMP_UGE : CmpInst::ICMP_ULT;\n          return new ICmpInst(NewPred, X, CmpC);\n        }\n      }\n\n      // Check if the LHS is 8 >>u x and the result is a power of 2 like 1.\n      const APInt *CI;\n      if (Op0KnownZeroInverted.isOneValue() &&\n          match(LHS, m_LShr(m_Power2(CI), m_Value(X)))) {\n        // ((8 >>u X) & 1) == 0 -> X != 3\n        // ((8 >>u X) & 1) != 0 -> X == 3\n        unsigned CmpVal = CI->countTrailingZeros();\n        auto NewPred = ICmpInst::getInversePredicate(Pred);\n        return new ICmpInst(NewPred, X, ConstantInt::get(X->getType(), CmpVal));\n      }\n    }\n    break;\n  }\n  case ICmpInst::ICMP_ULT: {\n    if (Op0Max.ult(Op1Min)) // A <u B -> true if max(A) < min(B)\n      return replaceInstUsesWith(I, ConstantInt::getTrue(I.getType()));\n    if (Op0Min.uge(Op1Max)) // A <u B -> false if min(A) >= max(B)\n      return replaceInstUsesWith(I, ConstantInt::getFalse(I.getType()));\n    if (Op1Min == Op0Max) // A <u B -> A != B if max(A) == min(B)\n      return new ICmpInst(ICmpInst::ICMP_NE, Op0, Op1);\n\n    const APInt *CmpC;\n    if (match(Op1, m_APInt(CmpC))) {\n      // A <u C -> A == C-1 if min(A)+1 == C\n      if (*CmpC == Op0Min + 1)\n        return new ICmpInst(ICmpInst::ICMP_EQ, Op0,\n                            ConstantInt::get(Op1->getType(), *CmpC - 1));\n      // X <u C --> X == 0, if the number of zero bits in the bottom of X\n      // exceeds the log2 of C.\n      if (Op0Known.countMinTrailingZeros() >= CmpC->ceilLogBase2())\n        return new ICmpInst(ICmpInst::ICMP_EQ, Op0,\n                            Constant::getNullValue(Op1->getType()));\n    }\n    break;\n  }\n  case ICmpInst::ICMP_UGT: {\n    if (Op0Min.ugt(Op1Max)) // A >u B -> true if min(A) > max(B)\n      return replaceInstUsesWith(I, ConstantInt::getTrue(I.getType()));\n    if (Op0Max.ule(Op1Min)) // A >u B -> false if max(A) <= max(B)\n      return replaceInstUsesWith(I, ConstantInt::getFalse(I.getType()));\n    if (Op1Max == Op0Min) // A >u B -> A != B if min(A) == max(B)\n      return new ICmpInst(ICmpInst::ICMP_NE, Op0, Op1);\n\n    const APInt *CmpC;\n    if (match(Op1, m_APInt(CmpC))) {\n      // A >u C -> A == C+1 if max(a)-1 == C\n      if (*CmpC == Op0Max - 1)\n        return new ICmpInst(ICmpInst::ICMP_EQ, Op0,\n                            ConstantInt::get(Op1->getType(), *CmpC + 1));\n      // X >u C --> X != 0, if the number of zero bits in the bottom of X\n      // exceeds the log2 of C.\n      if (Op0Known.countMinTrailingZeros() >= CmpC->getActiveBits())\n        return new ICmpInst(ICmpInst::ICMP_NE, Op0,\n                            Constant::getNullValue(Op1->getType()));\n    }\n    break;\n  }\n  case ICmpInst::ICMP_SLT: {\n    if (Op0Max.slt(Op1Min)) // A <s B -> true if max(A) < min(C)\n      return replaceInstUsesWith(I, ConstantInt::getTrue(I.getType()));\n    if (Op0Min.sge(Op1Max)) // A <s B -> false if min(A) >= max(C)\n      return replaceInstUsesWith(I, ConstantInt::getFalse(I.getType()));\n    if (Op1Min == Op0Max) // A <s B -> A != B if max(A) == min(B)\n      return new ICmpInst(ICmpInst::ICMP_NE, Op0, Op1);\n    const APInt *CmpC;\n    if (match(Op1, m_APInt(CmpC))) {\n      if (*CmpC == Op0Min + 1) // A <s C -> A == C-1 if min(A)+1 == C\n        return new ICmpInst(ICmpInst::ICMP_EQ, Op0,\n                            ConstantInt::get(Op1->getType(), *CmpC - 1));\n    }\n    break;\n  }\n  case ICmpInst::ICMP_SGT: {\n    if (Op0Min.sgt(Op1Max)) // A >s B -> true if min(A) > max(B)\n      return replaceInstUsesWith(I, ConstantInt::getTrue(I.getType()));\n    if (Op0Max.sle(Op1Min)) // A >s B -> false if max(A) <= min(B)\n      return replaceInstUsesWith(I, ConstantInt::getFalse(I.getType()));\n    if (Op1Max == Op0Min) // A >s B -> A != B if min(A) == max(B)\n      return new ICmpInst(ICmpInst::ICMP_NE, Op0, Op1);\n    const APInt *CmpC;\n    if (match(Op1, m_APInt(CmpC))) {\n      if (*CmpC == Op0Max - 1) // A >s C -> A == C+1 if max(A)-1 == C\n        return new ICmpInst(ICmpInst::ICMP_EQ, Op0,\n                            ConstantInt::get(Op1->getType(), *CmpC + 1));\n    }\n    break;\n  }\n  case ICmpInst::ICMP_SGE:\n    assert(!isa<ConstantInt>(Op1) && \"ICMP_SGE with ConstantInt not folded!\");\n    if (Op0Min.sge(Op1Max)) // A >=s B -> true if min(A) >= max(B)\n      return replaceInstUsesWith(I, ConstantInt::getTrue(I.getType()));\n    if (Op0Max.slt(Op1Min)) // A >=s B -> false if max(A) < min(B)\n      return replaceInstUsesWith(I, ConstantInt::getFalse(I.getType()));\n    if (Op1Min == Op0Max) // A >=s B -> A == B if max(A) == min(B)\n      return new ICmpInst(ICmpInst::ICMP_EQ, Op0, Op1);\n    break;\n  case ICmpInst::ICMP_SLE:\n    assert(!isa<ConstantInt>(Op1) && \"ICMP_SLE with ConstantInt not folded!\");\n    if (Op0Max.sle(Op1Min)) // A <=s B -> true if max(A) <= min(B)\n      return replaceInstUsesWith(I, ConstantInt::getTrue(I.getType()));\n    if (Op0Min.sgt(Op1Max)) // A <=s B -> false if min(A) > max(B)\n      return replaceInstUsesWith(I, ConstantInt::getFalse(I.getType()));\n    if (Op1Max == Op0Min) // A <=s B -> A == B if min(A) == max(B)\n      return new ICmpInst(ICmpInst::ICMP_EQ, Op0, Op1);\n    break;\n  case ICmpInst::ICMP_UGE:\n    assert(!isa<ConstantInt>(Op1) && \"ICMP_UGE with ConstantInt not folded!\");\n    if (Op0Min.uge(Op1Max)) // A >=u B -> true if min(A) >= max(B)\n      return replaceInstUsesWith(I, ConstantInt::getTrue(I.getType()));\n    if (Op0Max.ult(Op1Min)) // A >=u B -> false if max(A) < min(B)\n      return replaceInstUsesWith(I, ConstantInt::getFalse(I.getType()));\n    if (Op1Min == Op0Max) // A >=u B -> A == B if max(A) == min(B)\n      return new ICmpInst(ICmpInst::ICMP_EQ, Op0, Op1);\n    break;\n  case ICmpInst::ICMP_ULE:\n    assert(!isa<ConstantInt>(Op1) && \"ICMP_ULE with ConstantInt not folded!\");\n    if (Op0Max.ule(Op1Min)) // A <=u B -> true if max(A) <= min(B)\n      return replaceInstUsesWith(I, ConstantInt::getTrue(I.getType()));\n    if (Op0Min.ugt(Op1Max)) // A <=u B -> false if min(A) > max(B)\n      return replaceInstUsesWith(I, ConstantInt::getFalse(I.getType()));\n    if (Op1Max == Op0Min) // A <=u B -> A == B if min(A) == max(B)\n      return new ICmpInst(ICmpInst::ICMP_EQ, Op0, Op1);\n    break;\n  }\n\n  // Turn a signed comparison into an unsigned one if both operands are known to\n  // have the same sign.\n  if (I.isSigned() &&\n      ((Op0Known.Zero.isNegative() && Op1Known.Zero.isNegative()) ||\n       (Op0Known.One.isNegative() && Op1Known.One.isNegative())))\n    return new ICmpInst(I.getUnsignedPredicate(), Op0, Op1);\n\n  return nullptr;\n}\n\nllvm::Optional<std::pair<CmpInst::Predicate, Constant *>>\nInstCombiner::getFlippedStrictnessPredicateAndConstant(CmpInst::Predicate Pred,\n                                                       Constant *C) {\n  assert(ICmpInst::isRelational(Pred) && ICmpInst::isIntPredicate(Pred) &&\n         \"Only for relational integer predicates.\");\n\n  Type *Type = C->getType();\n  bool IsSigned = ICmpInst::isSigned(Pred);\n\n  CmpInst::Predicate UnsignedPred = ICmpInst::getUnsignedPredicate(Pred);\n  bool WillIncrement =\n      UnsignedPred == ICmpInst::ICMP_ULE || UnsignedPred == ICmpInst::ICMP_UGT;\n\n  // Check if the constant operand can be safely incremented/decremented\n  // without overflowing/underflowing.\n  auto ConstantIsOk = [WillIncrement, IsSigned](ConstantInt *C) {\n    return WillIncrement ? !C->isMaxValue(IsSigned) : !C->isMinValue(IsSigned);\n  };\n\n  Constant *SafeReplacementConstant = nullptr;\n  if (auto *CI = dyn_cast<ConstantInt>(C)) {\n    // Bail out if the constant can't be safely incremented/decremented.\n    if (!ConstantIsOk(CI))\n      return llvm::None;\n  } else if (auto *FVTy = dyn_cast<FixedVectorType>(Type)) {\n    unsigned NumElts = FVTy->getNumElements();\n    for (unsigned i = 0; i != NumElts; ++i) {\n      Constant *Elt = C->getAggregateElement(i);\n      if (!Elt)\n        return llvm::None;\n\n      if (isa<UndefValue>(Elt))\n        continue;\n\n      // Bail out if we can't determine if this constant is min/max or if we\n      // know that this constant is min/max.\n      auto *CI = dyn_cast<ConstantInt>(Elt);\n      if (!CI || !ConstantIsOk(CI))\n        return llvm::None;\n\n      if (!SafeReplacementConstant)\n        SafeReplacementConstant = CI;\n    }\n  } else {\n    // ConstantExpr?\n    return llvm::None;\n  }\n\n  // It may not be safe to change a compare predicate in the presence of\n  // undefined elements, so replace those elements with the first safe constant\n  // that we found.\n  // TODO: in case of poison, it is safe; let's replace undefs only.\n  if (C->containsUndefOrPoisonElement()) {\n    assert(SafeReplacementConstant && \"Replacement constant not set\");\n    C = Constant::replaceUndefsWith(C, SafeReplacementConstant);\n  }\n\n  CmpInst::Predicate NewPred = CmpInst::getFlippedStrictnessPredicate(Pred);\n\n  // Increment or decrement the constant.\n  Constant *OneOrNegOne = ConstantInt::get(Type, WillIncrement ? 1 : -1, true);\n  Constant *NewC = ConstantExpr::getAdd(C, OneOrNegOne);\n\n  return std::make_pair(NewPred, NewC);\n}\n\n/// If we have an icmp le or icmp ge instruction with a constant operand, turn\n/// it into the appropriate icmp lt or icmp gt instruction. This transform\n/// allows them to be folded in visitICmpInst.\nstatic ICmpInst *canonicalizeCmpWithConstant(ICmpInst &I) {\n  ICmpInst::Predicate Pred = I.getPredicate();\n  if (ICmpInst::isEquality(Pred) || !ICmpInst::isIntPredicate(Pred) ||\n      InstCombiner::isCanonicalPredicate(Pred))\n    return nullptr;\n\n  Value *Op0 = I.getOperand(0);\n  Value *Op1 = I.getOperand(1);\n  auto *Op1C = dyn_cast<Constant>(Op1);\n  if (!Op1C)\n    return nullptr;\n\n  auto FlippedStrictness =\n      InstCombiner::getFlippedStrictnessPredicateAndConstant(Pred, Op1C);\n  if (!FlippedStrictness)\n    return nullptr;\n\n  return new ICmpInst(FlippedStrictness->first, Op0, FlippedStrictness->second);\n}\n\n/// If we have a comparison with a non-canonical predicate, if we can update\n/// all the users, invert the predicate and adjust all the users.\nCmpInst *InstCombinerImpl::canonicalizeICmpPredicate(CmpInst &I) {\n  // Is the predicate already canonical?\n  CmpInst::Predicate Pred = I.getPredicate();\n  if (InstCombiner::isCanonicalPredicate(Pred))\n    return nullptr;\n\n  // Can all users be adjusted to predicate inversion?\n  if (!InstCombiner::canFreelyInvertAllUsersOf(&I, /*IgnoredUser=*/nullptr))\n    return nullptr;\n\n  // Ok, we can canonicalize comparison!\n  // Let's first invert the comparison's predicate.\n  I.setPredicate(CmpInst::getInversePredicate(Pred));\n  I.setName(I.getName() + \".not\");\n\n  // And, adapt users.\n  freelyInvertAllUsersOf(&I);\n\n  return &I;\n}\n\n/// Integer compare with boolean values can always be turned into bitwise ops.\nstatic Instruction *canonicalizeICmpBool(ICmpInst &I,\n                                         InstCombiner::BuilderTy &Builder) {\n  Value *A = I.getOperand(0), *B = I.getOperand(1);\n  assert(A->getType()->isIntOrIntVectorTy(1) && \"Bools only\");\n\n  // A boolean compared to true/false can be simplified to Op0/true/false in\n  // 14 out of the 20 (10 predicates * 2 constants) possible combinations.\n  // Cases not handled by InstSimplify are always 'not' of Op0.\n  if (match(B, m_Zero())) {\n    switch (I.getPredicate()) {\n      case CmpInst::ICMP_EQ:  // A ==   0 -> !A\n      case CmpInst::ICMP_ULE: // A <=u  0 -> !A\n      case CmpInst::ICMP_SGE: // A >=s  0 -> !A\n        return BinaryOperator::CreateNot(A);\n      default:\n        llvm_unreachable(\"ICmp i1 X, C not simplified as expected.\");\n    }\n  } else if (match(B, m_One())) {\n    switch (I.getPredicate()) {\n      case CmpInst::ICMP_NE:  // A !=  1 -> !A\n      case CmpInst::ICMP_ULT: // A <u  1 -> !A\n      case CmpInst::ICMP_SGT: // A >s -1 -> !A\n        return BinaryOperator::CreateNot(A);\n      default:\n        llvm_unreachable(\"ICmp i1 X, C not simplified as expected.\");\n    }\n  }\n\n  switch (I.getPredicate()) {\n  default:\n    llvm_unreachable(\"Invalid icmp instruction!\");\n  case ICmpInst::ICMP_EQ:\n    // icmp eq i1 A, B -> ~(A ^ B)\n    return BinaryOperator::CreateNot(Builder.CreateXor(A, B));\n\n  case ICmpInst::ICMP_NE:\n    // icmp ne i1 A, B -> A ^ B\n    return BinaryOperator::CreateXor(A, B);\n\n  case ICmpInst::ICMP_UGT:\n    // icmp ugt -> icmp ult\n    std::swap(A, B);\n    LLVM_FALLTHROUGH;\n  case ICmpInst::ICMP_ULT:\n    // icmp ult i1 A, B -> ~A & B\n    return BinaryOperator::CreateAnd(Builder.CreateNot(A), B);\n\n  case ICmpInst::ICMP_SGT:\n    // icmp sgt -> icmp slt\n    std::swap(A, B);\n    LLVM_FALLTHROUGH;\n  case ICmpInst::ICMP_SLT:\n    // icmp slt i1 A, B -> A & ~B\n    return BinaryOperator::CreateAnd(Builder.CreateNot(B), A);\n\n  case ICmpInst::ICMP_UGE:\n    // icmp uge -> icmp ule\n    std::swap(A, B);\n    LLVM_FALLTHROUGH;\n  case ICmpInst::ICMP_ULE:\n    // icmp ule i1 A, B -> ~A | B\n    return BinaryOperator::CreateOr(Builder.CreateNot(A), B);\n\n  case ICmpInst::ICMP_SGE:\n    // icmp sge -> icmp sle\n    std::swap(A, B);\n    LLVM_FALLTHROUGH;\n  case ICmpInst::ICMP_SLE:\n    // icmp sle i1 A, B -> A | ~B\n    return BinaryOperator::CreateOr(Builder.CreateNot(B), A);\n  }\n}\n\n// Transform pattern like:\n//   (1 << Y) u<= X  or  ~(-1 << Y) u<  X  or  ((1 << Y)+(-1)) u<  X\n//   (1 << Y) u>  X  or  ~(-1 << Y) u>= X  or  ((1 << Y)+(-1)) u>= X\n// Into:\n//   (X l>> Y) != 0\n//   (X l>> Y) == 0\nstatic Instruction *foldICmpWithHighBitMask(ICmpInst &Cmp,\n                                            InstCombiner::BuilderTy &Builder) {\n  ICmpInst::Predicate Pred, NewPred;\n  Value *X, *Y;\n  if (match(&Cmp,\n            m_c_ICmp(Pred, m_OneUse(m_Shl(m_One(), m_Value(Y))), m_Value(X)))) {\n    switch (Pred) {\n    case ICmpInst::ICMP_ULE:\n      NewPred = ICmpInst::ICMP_NE;\n      break;\n    case ICmpInst::ICMP_UGT:\n      NewPred = ICmpInst::ICMP_EQ;\n      break;\n    default:\n      return nullptr;\n    }\n  } else if (match(&Cmp, m_c_ICmp(Pred,\n                                  m_OneUse(m_CombineOr(\n                                      m_Not(m_Shl(m_AllOnes(), m_Value(Y))),\n                                      m_Add(m_Shl(m_One(), m_Value(Y)),\n                                            m_AllOnes()))),\n                                  m_Value(X)))) {\n    // The variant with 'add' is not canonical, (the variant with 'not' is)\n    // we only get it because it has extra uses, and can't be canonicalized,\n\n    switch (Pred) {\n    case ICmpInst::ICMP_ULT:\n      NewPred = ICmpInst::ICMP_NE;\n      break;\n    case ICmpInst::ICMP_UGE:\n      NewPred = ICmpInst::ICMP_EQ;\n      break;\n    default:\n      return nullptr;\n    }\n  } else\n    return nullptr;\n\n  Value *NewX = Builder.CreateLShr(X, Y, X->getName() + \".highbits\");\n  Constant *Zero = Constant::getNullValue(NewX->getType());\n  return CmpInst::Create(Instruction::ICmp, NewPred, NewX, Zero);\n}\n\nstatic Instruction *foldVectorCmp(CmpInst &Cmp,\n                                  InstCombiner::BuilderTy &Builder) {\n  const CmpInst::Predicate Pred = Cmp.getPredicate();\n  Value *LHS = Cmp.getOperand(0), *RHS = Cmp.getOperand(1);\n  Value *V1, *V2;\n  ArrayRef<int> M;\n  if (!match(LHS, m_Shuffle(m_Value(V1), m_Undef(), m_Mask(M))))\n    return nullptr;\n\n  // If both arguments of the cmp are shuffles that use the same mask and\n  // shuffle within a single vector, move the shuffle after the cmp:\n  // cmp (shuffle V1, M), (shuffle V2, M) --> shuffle (cmp V1, V2), M\n  Type *V1Ty = V1->getType();\n  if (match(RHS, m_Shuffle(m_Value(V2), m_Undef(), m_SpecificMask(M))) &&\n      V1Ty == V2->getType() && (LHS->hasOneUse() || RHS->hasOneUse())) {\n    Value *NewCmp = Builder.CreateCmp(Pred, V1, V2);\n    return new ShuffleVectorInst(NewCmp, UndefValue::get(NewCmp->getType()), M);\n  }\n\n  // Try to canonicalize compare with splatted operand and splat constant.\n  // TODO: We could generalize this for more than splats. See/use the code in\n  //       InstCombiner::foldVectorBinop().\n  Constant *C;\n  if (!LHS->hasOneUse() || !match(RHS, m_Constant(C)))\n    return nullptr;\n\n  // Length-changing splats are ok, so adjust the constants as needed:\n  // cmp (shuffle V1, M), C --> shuffle (cmp V1, C'), M\n  Constant *ScalarC = C->getSplatValue(/* AllowUndefs */ true);\n  int MaskSplatIndex;\n  if (ScalarC && match(M, m_SplatOrUndefMask(MaskSplatIndex))) {\n    // We allow undefs in matching, but this transform removes those for safety.\n    // Demanded elements analysis should be able to recover some/all of that.\n    C = ConstantVector::getSplat(cast<VectorType>(V1Ty)->getElementCount(),\n                                 ScalarC);\n    SmallVector<int, 8> NewM(M.size(), MaskSplatIndex);\n    Value *NewCmp = Builder.CreateCmp(Pred, V1, C);\n    return new ShuffleVectorInst(NewCmp, UndefValue::get(NewCmp->getType()),\n                                 NewM);\n  }\n\n  return nullptr;\n}\n\n// extract(uadd.with.overflow(A, B), 0) ult A\n//  -> extract(uadd.with.overflow(A, B), 1)\nstatic Instruction *foldICmpOfUAddOv(ICmpInst &I) {\n  CmpInst::Predicate Pred = I.getPredicate();\n  Value *Op0 = I.getOperand(0), *Op1 = I.getOperand(1);\n\n  Value *UAddOv;\n  Value *A, *B;\n  auto UAddOvResultPat = m_ExtractValue<0>(\n      m_Intrinsic<Intrinsic::uadd_with_overflow>(m_Value(A), m_Value(B)));\n  if (match(Op0, UAddOvResultPat) &&\n      ((Pred == ICmpInst::ICMP_ULT && (Op1 == A || Op1 == B)) ||\n       (Pred == ICmpInst::ICMP_EQ && match(Op1, m_ZeroInt()) &&\n        (match(A, m_One()) || match(B, m_One()))) ||\n       (Pred == ICmpInst::ICMP_NE && match(Op1, m_AllOnes()) &&\n        (match(A, m_AllOnes()) || match(B, m_AllOnes())))))\n    // extract(uadd.with.overflow(A, B), 0) < A\n    // extract(uadd.with.overflow(A, 1), 0) == 0\n    // extract(uadd.with.overflow(A, -1), 0) != -1\n    UAddOv = cast<ExtractValueInst>(Op0)->getAggregateOperand();\n  else if (match(Op1, UAddOvResultPat) &&\n           Pred == ICmpInst::ICMP_UGT && (Op0 == A || Op0 == B))\n    // A > extract(uadd.with.overflow(A, B), 0)\n    UAddOv = cast<ExtractValueInst>(Op1)->getAggregateOperand();\n  else\n    return nullptr;\n\n  return ExtractValueInst::Create(UAddOv, 1);\n}\n\nInstruction *InstCombinerImpl::visitICmpInst(ICmpInst &I) {\n  bool Changed = false;\n  const SimplifyQuery Q = SQ.getWithInstruction(&I);\n  Value *Op0 = I.getOperand(0), *Op1 = I.getOperand(1);\n  unsigned Op0Cplxity = getComplexity(Op0);\n  unsigned Op1Cplxity = getComplexity(Op1);\n\n  /// Orders the operands of the compare so that they are listed from most\n  /// complex to least complex.  This puts constants before unary operators,\n  /// before binary operators.\n  if (Op0Cplxity < Op1Cplxity ||\n      (Op0Cplxity == Op1Cplxity && swapMayExposeCSEOpportunities(Op0, Op1))) {\n    I.swapOperands();\n    std::swap(Op0, Op1);\n    Changed = true;\n  }\n\n  if (Value *V = SimplifyICmpInst(I.getPredicate(), Op0, Op1, Q))\n    return replaceInstUsesWith(I, V);\n\n  // Comparing -val or val with non-zero is the same as just comparing val\n  // ie, abs(val) != 0 -> val != 0\n  if (I.getPredicate() == ICmpInst::ICMP_NE && match(Op1, m_Zero())) {\n    Value *Cond, *SelectTrue, *SelectFalse;\n    if (match(Op0, m_Select(m_Value(Cond), m_Value(SelectTrue),\n                            m_Value(SelectFalse)))) {\n      if (Value *V = dyn_castNegVal(SelectTrue)) {\n        if (V == SelectFalse)\n          return CmpInst::Create(Instruction::ICmp, I.getPredicate(), V, Op1);\n      }\n      else if (Value *V = dyn_castNegVal(SelectFalse)) {\n        if (V == SelectTrue)\n          return CmpInst::Create(Instruction::ICmp, I.getPredicate(), V, Op1);\n      }\n    }\n  }\n\n  if (Op0->getType()->isIntOrIntVectorTy(1))\n    if (Instruction *Res = canonicalizeICmpBool(I, Builder))\n      return Res;\n\n  if (Instruction *Res = canonicalizeCmpWithConstant(I))\n    return Res;\n\n  if (Instruction *Res = canonicalizeICmpPredicate(I))\n    return Res;\n\n  if (Instruction *Res = foldICmpWithConstant(I))\n    return Res;\n\n  if (Instruction *Res = foldICmpWithDominatingICmp(I))\n    return Res;\n\n  if (Instruction *Res = foldICmpBinOp(I, Q))\n    return Res;\n\n  if (Instruction *Res = foldICmpUsingKnownBits(I))\n    return Res;\n\n  // Test if the ICmpInst instruction is used exclusively by a select as\n  // part of a minimum or maximum operation. If so, refrain from doing\n  // any other folding. This helps out other analyses which understand\n  // non-obfuscated minimum and maximum idioms, such as ScalarEvolution\n  // and CodeGen. And in this case, at least one of the comparison\n  // operands has at least one user besides the compare (the select),\n  // which would often largely negate the benefit of folding anyway.\n  //\n  // Do the same for the other patterns recognized by matchSelectPattern.\n  if (I.hasOneUse())\n    if (SelectInst *SI = dyn_cast<SelectInst>(I.user_back())) {\n      Value *A, *B;\n      SelectPatternResult SPR = matchSelectPattern(SI, A, B);\n      if (SPR.Flavor != SPF_UNKNOWN)\n        return nullptr;\n    }\n\n  // Do this after checking for min/max to prevent infinite looping.\n  if (Instruction *Res = foldICmpWithZero(I))\n    return Res;\n\n  // FIXME: We only do this after checking for min/max to prevent infinite\n  // looping caused by a reverse canonicalization of these patterns for min/max.\n  // FIXME: The organization of folds is a mess. These would naturally go into\n  // canonicalizeCmpWithConstant(), but we can't move all of the above folds\n  // down here after the min/max restriction.\n  ICmpInst::Predicate Pred = I.getPredicate();\n  const APInt *C;\n  if (match(Op1, m_APInt(C))) {\n    // For i32: x >u 2147483647 -> x <s 0  -> true if sign bit set\n    if (Pred == ICmpInst::ICMP_UGT && C->isMaxSignedValue()) {\n      Constant *Zero = Constant::getNullValue(Op0->getType());\n      return new ICmpInst(ICmpInst::ICMP_SLT, Op0, Zero);\n    }\n\n    // For i32: x <u 2147483648 -> x >s -1  -> true if sign bit clear\n    if (Pred == ICmpInst::ICMP_ULT && C->isMinSignedValue()) {\n      Constant *AllOnes = Constant::getAllOnesValue(Op0->getType());\n      return new ICmpInst(ICmpInst::ICMP_SGT, Op0, AllOnes);\n    }\n  }\n\n  if (Instruction *Res = foldICmpInstWithConstant(I))\n    return Res;\n\n  // Try to match comparison as a sign bit test. Intentionally do this after\n  // foldICmpInstWithConstant() to potentially let other folds to happen first.\n  if (Instruction *New = foldSignBitTest(I))\n    return New;\n\n  if (Instruction *Res = foldICmpInstWithConstantNotInt(I))\n    return Res;\n\n  // If we can optimize a 'icmp GEP, P' or 'icmp P, GEP', do so now.\n  if (GEPOperator *GEP = dyn_cast<GEPOperator>(Op0))\n    if (Instruction *NI = foldGEPICmp(GEP, Op1, I.getPredicate(), I))\n      return NI;\n  if (GEPOperator *GEP = dyn_cast<GEPOperator>(Op1))\n    if (Instruction *NI = foldGEPICmp(GEP, Op0,\n                           ICmpInst::getSwappedPredicate(I.getPredicate()), I))\n      return NI;\n\n  // Try to optimize equality comparisons against alloca-based pointers.\n  if (Op0->getType()->isPointerTy() && I.isEquality()) {\n    assert(Op1->getType()->isPointerTy() && \"Comparing pointer with non-pointer?\");\n    if (auto *Alloca = dyn_cast<AllocaInst>(getUnderlyingObject(Op0)))\n      if (Instruction *New = foldAllocaCmp(I, Alloca, Op1))\n        return New;\n    if (auto *Alloca = dyn_cast<AllocaInst>(getUnderlyingObject(Op1)))\n      if (Instruction *New = foldAllocaCmp(I, Alloca, Op0))\n        return New;\n  }\n\n  if (Instruction *Res = foldICmpBitCast(I, Builder))\n    return Res;\n\n  // TODO: Hoist this above the min/max bailout.\n  if (Instruction *R = foldICmpWithCastOp(I))\n    return R;\n\n  if (Instruction *Res = foldICmpWithMinMax(I))\n    return Res;\n\n  {\n    Value *A, *B;\n    // Transform (A & ~B) == 0 --> (A & B) != 0\n    // and       (A & ~B) != 0 --> (A & B) == 0\n    // if A is a power of 2.\n    if (match(Op0, m_And(m_Value(A), m_Not(m_Value(B)))) &&\n        match(Op1, m_Zero()) &&\n        isKnownToBeAPowerOfTwo(A, false, 0, &I) && I.isEquality())\n      return new ICmpInst(I.getInversePredicate(), Builder.CreateAnd(A, B),\n                          Op1);\n\n    // ~X < ~Y --> Y < X\n    // ~X < C -->  X > ~C\n    if (match(Op0, m_Not(m_Value(A)))) {\n      if (match(Op1, m_Not(m_Value(B))))\n        return new ICmpInst(I.getPredicate(), B, A);\n\n      const APInt *C;\n      if (match(Op1, m_APInt(C)))\n        return new ICmpInst(I.getSwappedPredicate(), A,\n                            ConstantInt::get(Op1->getType(), ~(*C)));\n    }\n\n    Instruction *AddI = nullptr;\n    if (match(&I, m_UAddWithOverflow(m_Value(A), m_Value(B),\n                                     m_Instruction(AddI))) &&\n        isa<IntegerType>(A->getType())) {\n      Value *Result;\n      Constant *Overflow;\n      // m_UAddWithOverflow can match patterns that do not include  an explicit\n      // \"add\" instruction, so check the opcode of the matched op.\n      if (AddI->getOpcode() == Instruction::Add &&\n          OptimizeOverflowCheck(Instruction::Add, /*Signed*/ false, A, B, *AddI,\n                                Result, Overflow)) {\n        replaceInstUsesWith(*AddI, Result);\n        eraseInstFromFunction(*AddI);\n        return replaceInstUsesWith(I, Overflow);\n      }\n    }\n\n    // (zext a) * (zext b)  --> llvm.umul.with.overflow.\n    if (match(Op0, m_Mul(m_ZExt(m_Value(A)), m_ZExt(m_Value(B))))) {\n      if (Instruction *R = processUMulZExtIdiom(I, Op0, Op1, *this))\n        return R;\n    }\n    if (match(Op1, m_Mul(m_ZExt(m_Value(A)), m_ZExt(m_Value(B))))) {\n      if (Instruction *R = processUMulZExtIdiom(I, Op1, Op0, *this))\n        return R;\n    }\n  }\n\n  if (Instruction *Res = foldICmpEquality(I))\n    return Res;\n\n  if (Instruction *Res = foldICmpOfUAddOv(I))\n    return Res;\n\n  // The 'cmpxchg' instruction returns an aggregate containing the old value and\n  // an i1 which indicates whether or not we successfully did the swap.\n  //\n  // Replace comparisons between the old value and the expected value with the\n  // indicator that 'cmpxchg' returns.\n  //\n  // N.B.  This transform is only valid when the 'cmpxchg' is not permitted to\n  // spuriously fail.  In those cases, the old value may equal the expected\n  // value but it is possible for the swap to not occur.\n  if (I.getPredicate() == ICmpInst::ICMP_EQ)\n    if (auto *EVI = dyn_cast<ExtractValueInst>(Op0))\n      if (auto *ACXI = dyn_cast<AtomicCmpXchgInst>(EVI->getAggregateOperand()))\n        if (EVI->getIndices()[0] == 0 && ACXI->getCompareOperand() == Op1 &&\n            !ACXI->isWeak())\n          return ExtractValueInst::Create(ACXI, 1);\n\n  {\n    Value *X;\n    const APInt *C;\n    // icmp X+Cst, X\n    if (match(Op0, m_Add(m_Value(X), m_APInt(C))) && Op1 == X)\n      return foldICmpAddOpConst(X, *C, I.getPredicate());\n\n    // icmp X, X+Cst\n    if (match(Op1, m_Add(m_Value(X), m_APInt(C))) && Op0 == X)\n      return foldICmpAddOpConst(X, *C, I.getSwappedPredicate());\n  }\n\n  if (Instruction *Res = foldICmpWithHighBitMask(I, Builder))\n    return Res;\n\n  if (I.getType()->isVectorTy())\n    if (Instruction *Res = foldVectorCmp(I, Builder))\n      return Res;\n\n  return Changed ? &I : nullptr;\n}\n\n/// Fold fcmp ([us]itofp x, cst) if possible.\nInstruction *InstCombinerImpl::foldFCmpIntToFPConst(FCmpInst &I,\n                                                    Instruction *LHSI,\n                                                    Constant *RHSC) {\n  if (!isa<ConstantFP>(RHSC)) return nullptr;\n  const APFloat &RHS = cast<ConstantFP>(RHSC)->getValueAPF();\n\n  // Get the width of the mantissa.  We don't want to hack on conversions that\n  // might lose information from the integer, e.g. \"i64 -> float\"\n  int MantissaWidth = LHSI->getType()->getFPMantissaWidth();\n  if (MantissaWidth == -1) return nullptr;  // Unknown.\n\n  IntegerType *IntTy = cast<IntegerType>(LHSI->getOperand(0)->getType());\n\n  bool LHSUnsigned = isa<UIToFPInst>(LHSI);\n\n  if (I.isEquality()) {\n    FCmpInst::Predicate P = I.getPredicate();\n    bool IsExact = false;\n    APSInt RHSCvt(IntTy->getBitWidth(), LHSUnsigned);\n    RHS.convertToInteger(RHSCvt, APFloat::rmNearestTiesToEven, &IsExact);\n\n    // If the floating point constant isn't an integer value, we know if we will\n    // ever compare equal / not equal to it.\n    if (!IsExact) {\n      // TODO: Can never be -0.0 and other non-representable values\n      APFloat RHSRoundInt(RHS);\n      RHSRoundInt.roundToIntegral(APFloat::rmNearestTiesToEven);\n      if (RHS != RHSRoundInt) {\n        if (P == FCmpInst::FCMP_OEQ || P == FCmpInst::FCMP_UEQ)\n          return replaceInstUsesWith(I, Builder.getFalse());\n\n        assert(P == FCmpInst::FCMP_ONE || P == FCmpInst::FCMP_UNE);\n        return replaceInstUsesWith(I, Builder.getTrue());\n      }\n    }\n\n    // TODO: If the constant is exactly representable, is it always OK to do\n    // equality compares as integer?\n  }\n\n  // Check to see that the input is converted from an integer type that is small\n  // enough that preserves all bits.  TODO: check here for \"known\" sign bits.\n  // This would allow us to handle (fptosi (x >>s 62) to float) if x is i64 f.e.\n  unsigned InputSize = IntTy->getScalarSizeInBits();\n\n  // Following test does NOT adjust InputSize downwards for signed inputs,\n  // because the most negative value still requires all the mantissa bits\n  // to distinguish it from one less than that value.\n  if ((int)InputSize > MantissaWidth) {\n    // Conversion would lose accuracy. Check if loss can impact comparison.\n    int Exp = ilogb(RHS);\n    if (Exp == APFloat::IEK_Inf) {\n      int MaxExponent = ilogb(APFloat::getLargest(RHS.getSemantics()));\n      if (MaxExponent < (int)InputSize - !LHSUnsigned)\n        // Conversion could create infinity.\n        return nullptr;\n    } else {\n      // Note that if RHS is zero or NaN, then Exp is negative\n      // and first condition is trivially false.\n      if (MantissaWidth <= Exp && Exp <= (int)InputSize - !LHSUnsigned)\n        // Conversion could affect comparison.\n        return nullptr;\n    }\n  }\n\n  // Otherwise, we can potentially simplify the comparison.  We know that it\n  // will always come through as an integer value and we know the constant is\n  // not a NAN (it would have been previously simplified).\n  assert(!RHS.isNaN() && \"NaN comparison not already folded!\");\n\n  ICmpInst::Predicate Pred;\n  switch (I.getPredicate()) {\n  default: llvm_unreachable(\"Unexpected predicate!\");\n  case FCmpInst::FCMP_UEQ:\n  case FCmpInst::FCMP_OEQ:\n    Pred = ICmpInst::ICMP_EQ;\n    break;\n  case FCmpInst::FCMP_UGT:\n  case FCmpInst::FCMP_OGT:\n    Pred = LHSUnsigned ? ICmpInst::ICMP_UGT : ICmpInst::ICMP_SGT;\n    break;\n  case FCmpInst::FCMP_UGE:\n  case FCmpInst::FCMP_OGE:\n    Pred = LHSUnsigned ? ICmpInst::ICMP_UGE : ICmpInst::ICMP_SGE;\n    break;\n  case FCmpInst::FCMP_ULT:\n  case FCmpInst::FCMP_OLT:\n    Pred = LHSUnsigned ? ICmpInst::ICMP_ULT : ICmpInst::ICMP_SLT;\n    break;\n  case FCmpInst::FCMP_ULE:\n  case FCmpInst::FCMP_OLE:\n    Pred = LHSUnsigned ? ICmpInst::ICMP_ULE : ICmpInst::ICMP_SLE;\n    break;\n  case FCmpInst::FCMP_UNE:\n  case FCmpInst::FCMP_ONE:\n    Pred = ICmpInst::ICMP_NE;\n    break;\n  case FCmpInst::FCMP_ORD:\n    return replaceInstUsesWith(I, Builder.getTrue());\n  case FCmpInst::FCMP_UNO:\n    return replaceInstUsesWith(I, Builder.getFalse());\n  }\n\n  // Now we know that the APFloat is a normal number, zero or inf.\n\n  // See if the FP constant is too large for the integer.  For example,\n  // comparing an i8 to 300.0.\n  unsigned IntWidth = IntTy->getScalarSizeInBits();\n\n  if (!LHSUnsigned) {\n    // If the RHS value is > SignedMax, fold the comparison.  This handles +INF\n    // and large values.\n    APFloat SMax(RHS.getSemantics());\n    SMax.convertFromAPInt(APInt::getSignedMaxValue(IntWidth), true,\n                          APFloat::rmNearestTiesToEven);\n    if (SMax < RHS) { // smax < 13123.0\n      if (Pred == ICmpInst::ICMP_NE  || Pred == ICmpInst::ICMP_SLT ||\n          Pred == ICmpInst::ICMP_SLE)\n        return replaceInstUsesWith(I, Builder.getTrue());\n      return replaceInstUsesWith(I, Builder.getFalse());\n    }\n  } else {\n    // If the RHS value is > UnsignedMax, fold the comparison. This handles\n    // +INF and large values.\n    APFloat UMax(RHS.getSemantics());\n    UMax.convertFromAPInt(APInt::getMaxValue(IntWidth), false,\n                          APFloat::rmNearestTiesToEven);\n    if (UMax < RHS) { // umax < 13123.0\n      if (Pred == ICmpInst::ICMP_NE  || Pred == ICmpInst::ICMP_ULT ||\n          Pred == ICmpInst::ICMP_ULE)\n        return replaceInstUsesWith(I, Builder.getTrue());\n      return replaceInstUsesWith(I, Builder.getFalse());\n    }\n  }\n\n  if (!LHSUnsigned) {\n    // See if the RHS value is < SignedMin.\n    APFloat SMin(RHS.getSemantics());\n    SMin.convertFromAPInt(APInt::getSignedMinValue(IntWidth), true,\n                          APFloat::rmNearestTiesToEven);\n    if (SMin > RHS) { // smin > 12312.0\n      if (Pred == ICmpInst::ICMP_NE || Pred == ICmpInst::ICMP_SGT ||\n          Pred == ICmpInst::ICMP_SGE)\n        return replaceInstUsesWith(I, Builder.getTrue());\n      return replaceInstUsesWith(I, Builder.getFalse());\n    }\n  } else {\n    // See if the RHS value is < UnsignedMin.\n    APFloat UMin(RHS.getSemantics());\n    UMin.convertFromAPInt(APInt::getMinValue(IntWidth), false,\n                          APFloat::rmNearestTiesToEven);\n    if (UMin > RHS) { // umin > 12312.0\n      if (Pred == ICmpInst::ICMP_NE || Pred == ICmpInst::ICMP_UGT ||\n          Pred == ICmpInst::ICMP_UGE)\n        return replaceInstUsesWith(I, Builder.getTrue());\n      return replaceInstUsesWith(I, Builder.getFalse());\n    }\n  }\n\n  // Okay, now we know that the FP constant fits in the range [SMIN, SMAX] or\n  // [0, UMAX], but it may still be fractional.  See if it is fractional by\n  // casting the FP value to the integer value and back, checking for equality.\n  // Don't do this for zero, because -0.0 is not fractional.\n  Constant *RHSInt = LHSUnsigned\n    ? ConstantExpr::getFPToUI(RHSC, IntTy)\n    : ConstantExpr::getFPToSI(RHSC, IntTy);\n  if (!RHS.isZero()) {\n    bool Equal = LHSUnsigned\n      ? ConstantExpr::getUIToFP(RHSInt, RHSC->getType()) == RHSC\n      : ConstantExpr::getSIToFP(RHSInt, RHSC->getType()) == RHSC;\n    if (!Equal) {\n      // If we had a comparison against a fractional value, we have to adjust\n      // the compare predicate and sometimes the value.  RHSC is rounded towards\n      // zero at this point.\n      switch (Pred) {\n      default: llvm_unreachable(\"Unexpected integer comparison!\");\n      case ICmpInst::ICMP_NE:  // (float)int != 4.4   --> true\n        return replaceInstUsesWith(I, Builder.getTrue());\n      case ICmpInst::ICMP_EQ:  // (float)int == 4.4   --> false\n        return replaceInstUsesWith(I, Builder.getFalse());\n      case ICmpInst::ICMP_ULE:\n        // (float)int <= 4.4   --> int <= 4\n        // (float)int <= -4.4  --> false\n        if (RHS.isNegative())\n          return replaceInstUsesWith(I, Builder.getFalse());\n        break;\n      case ICmpInst::ICMP_SLE:\n        // (float)int <= 4.4   --> int <= 4\n        // (float)int <= -4.4  --> int < -4\n        if (RHS.isNegative())\n          Pred = ICmpInst::ICMP_SLT;\n        break;\n      case ICmpInst::ICMP_ULT:\n        // (float)int < -4.4   --> false\n        // (float)int < 4.4    --> int <= 4\n        if (RHS.isNegative())\n          return replaceInstUsesWith(I, Builder.getFalse());\n        Pred = ICmpInst::ICMP_ULE;\n        break;\n      case ICmpInst::ICMP_SLT:\n        // (float)int < -4.4   --> int < -4\n        // (float)int < 4.4    --> int <= 4\n        if (!RHS.isNegative())\n          Pred = ICmpInst::ICMP_SLE;\n        break;\n      case ICmpInst::ICMP_UGT:\n        // (float)int > 4.4    --> int > 4\n        // (float)int > -4.4   --> true\n        if (RHS.isNegative())\n          return replaceInstUsesWith(I, Builder.getTrue());\n        break;\n      case ICmpInst::ICMP_SGT:\n        // (float)int > 4.4    --> int > 4\n        // (float)int > -4.4   --> int >= -4\n        if (RHS.isNegative())\n          Pred = ICmpInst::ICMP_SGE;\n        break;\n      case ICmpInst::ICMP_UGE:\n        // (float)int >= -4.4   --> true\n        // (float)int >= 4.4    --> int > 4\n        if (RHS.isNegative())\n          return replaceInstUsesWith(I, Builder.getTrue());\n        Pred = ICmpInst::ICMP_UGT;\n        break;\n      case ICmpInst::ICMP_SGE:\n        // (float)int >= -4.4   --> int >= -4\n        // (float)int >= 4.4    --> int > 4\n        if (!RHS.isNegative())\n          Pred = ICmpInst::ICMP_SGT;\n        break;\n      }\n    }\n  }\n\n  // Lower this FP comparison into an appropriate integer version of the\n  // comparison.\n  return new ICmpInst(Pred, LHSI->getOperand(0), RHSInt);\n}\n\n/// Fold (C / X) < 0.0 --> X < 0.0 if possible. Swap predicate if necessary.\nstatic Instruction *foldFCmpReciprocalAndZero(FCmpInst &I, Instruction *LHSI,\n                                              Constant *RHSC) {\n  // When C is not 0.0 and infinities are not allowed:\n  // (C / X) < 0.0 is a sign-bit test of X\n  // (C / X) < 0.0 --> X < 0.0 (if C is positive)\n  // (C / X) < 0.0 --> X > 0.0 (if C is negative, swap the predicate)\n  //\n  // Proof:\n  // Multiply (C / X) < 0.0 by X * X / C.\n  // - X is non zero, if it is the flag 'ninf' is violated.\n  // - C defines the sign of X * X * C. Thus it also defines whether to swap\n  //   the predicate. C is also non zero by definition.\n  //\n  // Thus X * X / C is non zero and the transformation is valid. [qed]\n\n  FCmpInst::Predicate Pred = I.getPredicate();\n\n  // Check that predicates are valid.\n  if ((Pred != FCmpInst::FCMP_OGT) && (Pred != FCmpInst::FCMP_OLT) &&\n      (Pred != FCmpInst::FCMP_OGE) && (Pred != FCmpInst::FCMP_OLE))\n    return nullptr;\n\n  // Check that RHS operand is zero.\n  if (!match(RHSC, m_AnyZeroFP()))\n    return nullptr;\n\n  // Check fastmath flags ('ninf').\n  if (!LHSI->hasNoInfs() || !I.hasNoInfs())\n    return nullptr;\n\n  // Check the properties of the dividend. It must not be zero to avoid a\n  // division by zero (see Proof).\n  const APFloat *C;\n  if (!match(LHSI->getOperand(0), m_APFloat(C)))\n    return nullptr;\n\n  if (C->isZero())\n    return nullptr;\n\n  // Get swapped predicate if necessary.\n  if (C->isNegative())\n    Pred = I.getSwappedPredicate();\n\n  return new FCmpInst(Pred, LHSI->getOperand(1), RHSC, \"\", &I);\n}\n\n/// Optimize fabs(X) compared with zero.\nstatic Instruction *foldFabsWithFcmpZero(FCmpInst &I, InstCombinerImpl &IC) {\n  Value *X;\n  if (!match(I.getOperand(0), m_FAbs(m_Value(X))) ||\n      !match(I.getOperand(1), m_PosZeroFP()))\n    return nullptr;\n\n  auto replacePredAndOp0 = [&IC](FCmpInst *I, FCmpInst::Predicate P, Value *X) {\n    I->setPredicate(P);\n    return IC.replaceOperand(*I, 0, X);\n  };\n\n  switch (I.getPredicate()) {\n  case FCmpInst::FCMP_UGE:\n  case FCmpInst::FCMP_OLT:\n    // fabs(X) >= 0.0 --> true\n    // fabs(X) <  0.0 --> false\n    llvm_unreachable(\"fcmp should have simplified\");\n\n  case FCmpInst::FCMP_OGT:\n    // fabs(X) > 0.0 --> X != 0.0\n    return replacePredAndOp0(&I, FCmpInst::FCMP_ONE, X);\n\n  case FCmpInst::FCMP_UGT:\n    // fabs(X) u> 0.0 --> X u!= 0.0\n    return replacePredAndOp0(&I, FCmpInst::FCMP_UNE, X);\n\n  case FCmpInst::FCMP_OLE:\n    // fabs(X) <= 0.0 --> X == 0.0\n    return replacePredAndOp0(&I, FCmpInst::FCMP_OEQ, X);\n\n  case FCmpInst::FCMP_ULE:\n    // fabs(X) u<= 0.0 --> X u== 0.0\n    return replacePredAndOp0(&I, FCmpInst::FCMP_UEQ, X);\n\n  case FCmpInst::FCMP_OGE:\n    // fabs(X) >= 0.0 --> !isnan(X)\n    assert(!I.hasNoNaNs() && \"fcmp should have simplified\");\n    return replacePredAndOp0(&I, FCmpInst::FCMP_ORD, X);\n\n  case FCmpInst::FCMP_ULT:\n    // fabs(X) u< 0.0 --> isnan(X)\n    assert(!I.hasNoNaNs() && \"fcmp should have simplified\");\n    return replacePredAndOp0(&I, FCmpInst::FCMP_UNO, X);\n\n  case FCmpInst::FCMP_OEQ:\n  case FCmpInst::FCMP_UEQ:\n  case FCmpInst::FCMP_ONE:\n  case FCmpInst::FCMP_UNE:\n  case FCmpInst::FCMP_ORD:\n  case FCmpInst::FCMP_UNO:\n    // Look through the fabs() because it doesn't change anything but the sign.\n    // fabs(X) == 0.0 --> X == 0.0,\n    // fabs(X) != 0.0 --> X != 0.0\n    // isnan(fabs(X)) --> isnan(X)\n    // !isnan(fabs(X) --> !isnan(X)\n    return replacePredAndOp0(&I, I.getPredicate(), X);\n\n  default:\n    return nullptr;\n  }\n}\n\nInstruction *InstCombinerImpl::visitFCmpInst(FCmpInst &I) {\n  bool Changed = false;\n\n  /// Orders the operands of the compare so that they are listed from most\n  /// complex to least complex.  This puts constants before unary operators,\n  /// before binary operators.\n  if (getComplexity(I.getOperand(0)) < getComplexity(I.getOperand(1))) {\n    I.swapOperands();\n    Changed = true;\n  }\n\n  const CmpInst::Predicate Pred = I.getPredicate();\n  Value *Op0 = I.getOperand(0), *Op1 = I.getOperand(1);\n  if (Value *V = SimplifyFCmpInst(Pred, Op0, Op1, I.getFastMathFlags(),\n                                  SQ.getWithInstruction(&I)))\n    return replaceInstUsesWith(I, V);\n\n  // Simplify 'fcmp pred X, X'\n  Type *OpType = Op0->getType();\n  assert(OpType == Op1->getType() && \"fcmp with different-typed operands?\");\n  if (Op0 == Op1) {\n    switch (Pred) {\n      default: break;\n    case FCmpInst::FCMP_UNO:    // True if unordered: isnan(X) | isnan(Y)\n    case FCmpInst::FCMP_ULT:    // True if unordered or less than\n    case FCmpInst::FCMP_UGT:    // True if unordered or greater than\n    case FCmpInst::FCMP_UNE:    // True if unordered or not equal\n      // Canonicalize these to be 'fcmp uno %X, 0.0'.\n      I.setPredicate(FCmpInst::FCMP_UNO);\n      I.setOperand(1, Constant::getNullValue(OpType));\n      return &I;\n\n    case FCmpInst::FCMP_ORD:    // True if ordered (no nans)\n    case FCmpInst::FCMP_OEQ:    // True if ordered and equal\n    case FCmpInst::FCMP_OGE:    // True if ordered and greater than or equal\n    case FCmpInst::FCMP_OLE:    // True if ordered and less than or equal\n      // Canonicalize these to be 'fcmp ord %X, 0.0'.\n      I.setPredicate(FCmpInst::FCMP_ORD);\n      I.setOperand(1, Constant::getNullValue(OpType));\n      return &I;\n    }\n  }\n\n  // If we're just checking for a NaN (ORD/UNO) and have a non-NaN operand,\n  // then canonicalize the operand to 0.0.\n  if (Pred == CmpInst::FCMP_ORD || Pred == CmpInst::FCMP_UNO) {\n    if (!match(Op0, m_PosZeroFP()) && isKnownNeverNaN(Op0, &TLI))\n      return replaceOperand(I, 0, ConstantFP::getNullValue(OpType));\n\n    if (!match(Op1, m_PosZeroFP()) && isKnownNeverNaN(Op1, &TLI))\n      return replaceOperand(I, 1, ConstantFP::getNullValue(OpType));\n  }\n\n  // fcmp pred (fneg X), (fneg Y) -> fcmp swap(pred) X, Y\n  Value *X, *Y;\n  if (match(Op0, m_FNeg(m_Value(X))) && match(Op1, m_FNeg(m_Value(Y))))\n    return new FCmpInst(I.getSwappedPredicate(), X, Y, \"\", &I);\n\n  // Test if the FCmpInst instruction is used exclusively by a select as\n  // part of a minimum or maximum operation. If so, refrain from doing\n  // any other folding. This helps out other analyses which understand\n  // non-obfuscated minimum and maximum idioms, such as ScalarEvolution\n  // and CodeGen. And in this case, at least one of the comparison\n  // operands has at least one user besides the compare (the select),\n  // which would often largely negate the benefit of folding anyway.\n  if (I.hasOneUse())\n    if (SelectInst *SI = dyn_cast<SelectInst>(I.user_back())) {\n      Value *A, *B;\n      SelectPatternResult SPR = matchSelectPattern(SI, A, B);\n      if (SPR.Flavor != SPF_UNKNOWN)\n        return nullptr;\n    }\n\n  // The sign of 0.0 is ignored by fcmp, so canonicalize to +0.0:\n  // fcmp Pred X, -0.0 --> fcmp Pred X, 0.0\n  if (match(Op1, m_AnyZeroFP()) && !match(Op1, m_PosZeroFP()))\n    return replaceOperand(I, 1, ConstantFP::getNullValue(OpType));\n\n  // Handle fcmp with instruction LHS and constant RHS.\n  Instruction *LHSI;\n  Constant *RHSC;\n  if (match(Op0, m_Instruction(LHSI)) && match(Op1, m_Constant(RHSC))) {\n    switch (LHSI->getOpcode()) {\n    case Instruction::PHI:\n      // Only fold fcmp into the PHI if the phi and fcmp are in the same\n      // block.  If in the same block, we're encouraging jump threading.  If\n      // not, we are just pessimizing the code by making an i1 phi.\n      if (LHSI->getParent() == I.getParent())\n        if (Instruction *NV = foldOpIntoPhi(I, cast<PHINode>(LHSI)))\n          return NV;\n      break;\n    case Instruction::SIToFP:\n    case Instruction::UIToFP:\n      if (Instruction *NV = foldFCmpIntToFPConst(I, LHSI, RHSC))\n        return NV;\n      break;\n    case Instruction::FDiv:\n      if (Instruction *NV = foldFCmpReciprocalAndZero(I, LHSI, RHSC))\n        return NV;\n      break;\n    case Instruction::Load:\n      if (auto *GEP = dyn_cast<GetElementPtrInst>(LHSI->getOperand(0)))\n        if (auto *GV = dyn_cast<GlobalVariable>(GEP->getOperand(0)))\n          if (GV->isConstant() && GV->hasDefinitiveInitializer() &&\n              !cast<LoadInst>(LHSI)->isVolatile())\n            if (Instruction *Res = foldCmpLoadFromIndexedGlobal(GEP, GV, I))\n              return Res;\n      break;\n  }\n  }\n\n  if (Instruction *R = foldFabsWithFcmpZero(I, *this))\n    return R;\n\n  if (match(Op0, m_FNeg(m_Value(X)))) {\n    // fcmp pred (fneg X), C --> fcmp swap(pred) X, -C\n    Constant *C;\n    if (match(Op1, m_Constant(C))) {\n      Constant *NegC = ConstantExpr::getFNeg(C);\n      return new FCmpInst(I.getSwappedPredicate(), X, NegC, \"\", &I);\n    }\n  }\n\n  if (match(Op0, m_FPExt(m_Value(X)))) {\n    // fcmp (fpext X), (fpext Y) -> fcmp X, Y\n    if (match(Op1, m_FPExt(m_Value(Y))) && X->getType() == Y->getType())\n      return new FCmpInst(Pred, X, Y, \"\", &I);\n\n    // fcmp (fpext X), C -> fcmp X, (fptrunc C) if fptrunc is lossless\n    const APFloat *C;\n    if (match(Op1, m_APFloat(C))) {\n      const fltSemantics &FPSem =\n          X->getType()->getScalarType()->getFltSemantics();\n      bool Lossy;\n      APFloat TruncC = *C;\n      TruncC.convert(FPSem, APFloat::rmNearestTiesToEven, &Lossy);\n\n      // Avoid lossy conversions and denormals.\n      // Zero is a special case that's OK to convert.\n      APFloat Fabs = TruncC;\n      Fabs.clearSign();\n      if (!Lossy &&\n          (!(Fabs < APFloat::getSmallestNormalized(FPSem)) || Fabs.isZero())) {\n        Constant *NewC = ConstantFP::get(X->getType(), TruncC);\n        return new FCmpInst(Pred, X, NewC, \"\", &I);\n      }\n    }\n  }\n\n  // Convert a sign-bit test of an FP value into a cast and integer compare.\n  // TODO: Simplify if the copysign constant is 0.0 or NaN.\n  // TODO: Handle non-zero compare constants.\n  // TODO: Handle other predicates.\n  const APFloat *C;\n  if (match(Op0, m_OneUse(m_Intrinsic<Intrinsic::copysign>(m_APFloat(C),\n                                                           m_Value(X)))) &&\n      match(Op1, m_AnyZeroFP()) && !C->isZero() && !C->isNaN()) {\n    Type *IntType = Builder.getIntNTy(X->getType()->getScalarSizeInBits());\n    if (auto *VecTy = dyn_cast<VectorType>(OpType))\n      IntType = VectorType::get(IntType, VecTy->getElementCount());\n\n    // copysign(non-zero constant, X) < 0.0 --> (bitcast X) < 0\n    if (Pred == FCmpInst::FCMP_OLT) {\n      Value *IntX = Builder.CreateBitCast(X, IntType);\n      return new ICmpInst(ICmpInst::ICMP_SLT, IntX,\n                          ConstantInt::getNullValue(IntType));\n    }\n  }\n\n  if (I.getType()->isVectorTy())\n    if (Instruction *Res = foldVectorCmp(I, Builder))\n      return Res;\n\n  return Changed ? &I : nullptr;\n}\n"}, "3": {"id": 3, "path": "/home/vsts/work/1/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h", "content": "//===- InstCombineInternal.h - InstCombine pass internals -------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n///\n/// This file provides internal interfaces used to implement the InstCombine.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_LIB_TRANSFORMS_INSTCOMBINE_INSTCOMBINEINTERNAL_H\n#define LLVM_LIB_TRANSFORMS_INSTCOMBINE_INSTCOMBINEINTERNAL_H\n\n#include \"llvm/ADT/Statistic.h\"\n#include \"llvm/Analysis/InstructionSimplify.h\"\n#include \"llvm/Analysis/TargetFolder.h\"\n#include \"llvm/Analysis/ValueTracking.h\"\n#include \"llvm/IR/IRBuilder.h\"\n#include \"llvm/IR/InstVisitor.h\"\n#include \"llvm/IR/PatternMatch.h\"\n#include \"llvm/Support/Debug.h\"\n#include \"llvm/Support/KnownBits.h\"\n#include \"llvm/Transforms/InstCombine/InstCombineWorklist.h\"\n#include \"llvm/Transforms/InstCombine/InstCombiner.h\"\n#include \"llvm/Transforms/Utils/Local.h\"\n#include <cassert>\n\n#define DEBUG_TYPE \"instcombine\"\n\nusing namespace llvm::PatternMatch;\n\n// As a default, let's assume that we want to be aggressive,\n// and attempt to traverse with no limits in attempt to sink negation.\nstatic constexpr unsigned NegatorDefaultMaxDepth = ~0U;\n\n// Let's guesstimate that most often we will end up visiting/producing\n// fairly small number of new instructions.\nstatic constexpr unsigned NegatorMaxNodesSSO = 16;\n\nnamespace llvm {\n\nclass AAResults;\nclass APInt;\nclass AssumptionCache;\nclass BlockFrequencyInfo;\nclass DataLayout;\nclass DominatorTree;\nclass GEPOperator;\nclass GlobalVariable;\nclass LoopInfo;\nclass OptimizationRemarkEmitter;\nclass ProfileSummaryInfo;\nclass TargetLibraryInfo;\nclass User;\n\nclass LLVM_LIBRARY_VISIBILITY InstCombinerImpl final\n    : public InstCombiner,\n      public InstVisitor<InstCombinerImpl, Instruction *> {\npublic:\n  InstCombinerImpl(InstCombineWorklist &Worklist, BuilderTy &Builder,\n                   bool MinimizeSize, AAResults *AA, AssumptionCache &AC,\n                   TargetLibraryInfo &TLI, TargetTransformInfo &TTI,\n                   DominatorTree &DT, OptimizationRemarkEmitter &ORE,\n                   BlockFrequencyInfo *BFI, ProfileSummaryInfo *PSI,\n                   const DataLayout &DL, LoopInfo *LI)\n      : InstCombiner(Worklist, Builder, MinimizeSize, AA, AC, TLI, TTI, DT, ORE,\n                     BFI, PSI, DL, LI) {}\n\n  virtual ~InstCombinerImpl() {}\n\n  /// Run the combiner over the entire worklist until it is empty.\n  ///\n  /// \\returns true if the IR is changed.\n  bool run();\n\n  // Visitation implementation - Implement instruction combining for different\n  // instruction types.  The semantics are as follows:\n  // Return Value:\n  //    null        - No change was made\n  //     I          - Change was made, I is still valid, I may be dead though\n  //   otherwise    - Change was made, replace I with returned instruction\n  //\n  Instruction *visitFNeg(UnaryOperator &I);\n  Instruction *visitAdd(BinaryOperator &I);\n  Instruction *visitFAdd(BinaryOperator &I);\n  Value *OptimizePointerDifference(\n      Value *LHS, Value *RHS, Type *Ty, bool isNUW);\n  Instruction *visitSub(BinaryOperator &I);\n  Instruction *visitFSub(BinaryOperator &I);\n  Instruction *visitMul(BinaryOperator &I);\n  Instruction *visitFMul(BinaryOperator &I);\n  Instruction *visitURem(BinaryOperator &I);\n  Instruction *visitSRem(BinaryOperator &I);\n  Instruction *visitFRem(BinaryOperator &I);\n  bool simplifyDivRemOfSelectWithZeroOp(BinaryOperator &I);\n  Instruction *commonIRemTransforms(BinaryOperator &I);\n  Instruction *commonIDivTransforms(BinaryOperator &I);\n  Instruction *visitUDiv(BinaryOperator &I);\n  Instruction *visitSDiv(BinaryOperator &I);\n  Instruction *visitFDiv(BinaryOperator &I);\n  Value *simplifyRangeCheck(ICmpInst *Cmp0, ICmpInst *Cmp1, bool Inverted);\n  Instruction *visitAnd(BinaryOperator &I);\n  Instruction *visitOr(BinaryOperator &I);\n  bool sinkNotIntoOtherHandOfAndOrOr(BinaryOperator &I);\n  Instruction *visitXor(BinaryOperator &I);\n  Instruction *visitShl(BinaryOperator &I);\n  Value *reassociateShiftAmtsOfTwoSameDirectionShifts(\n      BinaryOperator *Sh0, const SimplifyQuery &SQ,\n      bool AnalyzeForSignBitExtraction = false);\n  Instruction *canonicalizeCondSignextOfHighBitExtractToSignextHighBitExtract(\n      BinaryOperator &I);\n  Instruction *foldVariableSignZeroExtensionOfVariableHighBitExtract(\n      BinaryOperator &OldAShr);\n  Instruction *visitAShr(BinaryOperator &I);\n  Instruction *visitLShr(BinaryOperator &I);\n  Instruction *commonShiftTransforms(BinaryOperator &I);\n  Instruction *visitFCmpInst(FCmpInst &I);\n  CmpInst *canonicalizeICmpPredicate(CmpInst &I);\n  Instruction *visitICmpInst(ICmpInst &I);\n  Instruction *FoldShiftByConstant(Value *Op0, Constant *Op1,\n                                   BinaryOperator &I);\n  Instruction *commonCastTransforms(CastInst &CI);\n  Instruction *commonPointerCastTransforms(CastInst &CI);\n  Instruction *visitTrunc(TruncInst &CI);\n  Instruction *visitZExt(ZExtInst &CI);\n  Instruction *visitSExt(SExtInst &CI);\n  Instruction *visitFPTrunc(FPTruncInst &CI);\n  Instruction *visitFPExt(CastInst &CI);\n  Instruction *visitFPToUI(FPToUIInst &FI);\n  Instruction *visitFPToSI(FPToSIInst &FI);\n  Instruction *visitUIToFP(CastInst &CI);\n  Instruction *visitSIToFP(CastInst &CI);\n  Instruction *visitPtrToInt(PtrToIntInst &CI);\n  Instruction *visitIntToPtr(IntToPtrInst &CI);\n  Instruction *visitBitCast(BitCastInst &CI);\n  Instruction *visitAddrSpaceCast(AddrSpaceCastInst &CI);\n  Instruction *foldItoFPtoI(CastInst &FI);\n  Instruction *visitSelectInst(SelectInst &SI);\n  Instruction *visitCallInst(CallInst &CI);\n  Instruction *visitInvokeInst(InvokeInst &II);\n  Instruction *visitCallBrInst(CallBrInst &CBI);\n\n  Instruction *SliceUpIllegalIntegerPHI(PHINode &PN);\n  Instruction *visitPHINode(PHINode &PN);\n  Instruction *visitGetElementPtrInst(GetElementPtrInst &GEP);\n  Instruction *visitAllocaInst(AllocaInst &AI);\n  Instruction *visitAllocSite(Instruction &FI);\n  Instruction *visitFree(CallInst &FI);\n  Instruction *visitLoadInst(LoadInst &LI);\n  Instruction *visitStoreInst(StoreInst &SI);\n  Instruction *visitAtomicRMWInst(AtomicRMWInst &SI);\n  Instruction *visitUnconditionalBranchInst(BranchInst &BI);\n  Instruction *visitBranchInst(BranchInst &BI);\n  Instruction *visitFenceInst(FenceInst &FI);\n  Instruction *visitSwitchInst(SwitchInst &SI);\n  Instruction *visitReturnInst(ReturnInst &RI);\n  Instruction *visitUnreachableInst(UnreachableInst &I);\n  Instruction *\n  foldAggregateConstructionIntoAggregateReuse(InsertValueInst &OrigIVI);\n  Instruction *visitInsertValueInst(InsertValueInst &IV);\n  Instruction *visitInsertElementInst(InsertElementInst &IE);\n  Instruction *visitExtractElementInst(ExtractElementInst &EI);\n  Instruction *visitShuffleVectorInst(ShuffleVectorInst &SVI);\n  Instruction *visitExtractValueInst(ExtractValueInst &EV);\n  Instruction *visitLandingPadInst(LandingPadInst &LI);\n  Instruction *visitVAEndInst(VAEndInst &I);\n  Instruction *visitFreeze(FreezeInst &I);\n\n  /// Specify what to return for unhandled instructions.\n  Instruction *visitInstruction(Instruction &I) { return nullptr; }\n\n  /// True when DB dominates all uses of DI except UI.\n  /// UI must be in the same block as DI.\n  /// The routine checks that the DI parent and DB are different.\n  bool dominatesAllUses(const Instruction *DI, const Instruction *UI,\n                        const BasicBlock *DB) const;\n\n  /// Try to replace select with select operand SIOpd in SI-ICmp sequence.\n  bool replacedSelectWithOperand(SelectInst *SI, const ICmpInst *Icmp,\n                                 const unsigned SIOpd);\n\n  LoadInst *combineLoadToNewType(LoadInst &LI, Type *NewTy,\n                                 const Twine &Suffix = \"\");\n\nprivate:\n  bool shouldChangeType(unsigned FromBitWidth, unsigned ToBitWidth) const;\n  bool shouldChangeType(Type *From, Type *To) const;\n  Value *dyn_castNegVal(Value *V) const;\n  Type *FindElementAtOffset(PointerType *PtrTy, int64_t Offset,\n                            SmallVectorImpl<Value *> &NewIndices);\n\n  /// Classify whether a cast is worth optimizing.\n  ///\n  /// This is a helper to decide whether the simplification of\n  /// logic(cast(A), cast(B)) to cast(logic(A, B)) should be performed.\n  ///\n  /// \\param CI The cast we are interested in.\n  ///\n  /// \\return true if this cast actually results in any code being generated and\n  /// if it cannot already be eliminated by some other transformation.\n  bool shouldOptimizeCast(CastInst *CI);\n\n  /// Try to optimize a sequence of instructions checking if an operation\n  /// on LHS and RHS overflows.\n  ///\n  /// If this overflow check is done via one of the overflow check intrinsics,\n  /// then CtxI has to be the call instruction calling that intrinsic.  If this\n  /// overflow check is done by arithmetic followed by a compare, then CtxI has\n  /// to be the arithmetic instruction.\n  ///\n  /// If a simplification is possible, stores the simplified result of the\n  /// operation in OperationResult and result of the overflow check in\n  /// OverflowResult, and return true.  If no simplification is possible,\n  /// returns false.\n  bool OptimizeOverflowCheck(Instruction::BinaryOps BinaryOp, bool IsSigned,\n                             Value *LHS, Value *RHS,\n                             Instruction &CtxI, Value *&OperationResult,\n                             Constant *&OverflowResult);\n\n  Instruction *visitCallBase(CallBase &Call);\n  Instruction *tryOptimizeCall(CallInst *CI);\n  bool transformConstExprCastCall(CallBase &Call);\n  Instruction *transformCallThroughTrampoline(CallBase &Call,\n                                              IntrinsicInst &Tramp);\n\n  Value *simplifyMaskedLoad(IntrinsicInst &II);\n  Instruction *simplifyMaskedStore(IntrinsicInst &II);\n  Instruction *simplifyMaskedGather(IntrinsicInst &II);\n  Instruction *simplifyMaskedScatter(IntrinsicInst &II);\n\n  /// Transform (zext icmp) to bitwise / integer operations in order to\n  /// eliminate it.\n  ///\n  /// \\param ICI The icmp of the (zext icmp) pair we are interested in.\n  /// \\parem CI The zext of the (zext icmp) pair we are interested in.\n  /// \\param DoTransform Pass false to just test whether the given (zext icmp)\n  /// would be transformed. Pass true to actually perform the transformation.\n  ///\n  /// \\return null if the transformation cannot be performed. If the\n  /// transformation can be performed the new instruction that replaces the\n  /// (zext icmp) pair will be returned (if \\p DoTransform is false the\n  /// unmodified \\p ICI will be returned in this case).\n  Instruction *transformZExtICmp(ICmpInst *ICI, ZExtInst &CI,\n                                 bool DoTransform = true);\n\n  Instruction *transformSExtICmp(ICmpInst *ICI, Instruction &CI);\n\n  bool willNotOverflowSignedAdd(const Value *LHS, const Value *RHS,\n                                const Instruction &CxtI) const {\n    return computeOverflowForSignedAdd(LHS, RHS, &CxtI) ==\n           OverflowResult::NeverOverflows;\n  }\n\n  bool willNotOverflowUnsignedAdd(const Value *LHS, const Value *RHS,\n                                  const Instruction &CxtI) const {\n    return computeOverflowForUnsignedAdd(LHS, RHS, &CxtI) ==\n           OverflowResult::NeverOverflows;\n  }\n\n  bool willNotOverflowAdd(const Value *LHS, const Value *RHS,\n                          const Instruction &CxtI, bool IsSigned) const {\n    return IsSigned ? willNotOverflowSignedAdd(LHS, RHS, CxtI)\n                    : willNotOverflowUnsignedAdd(LHS, RHS, CxtI);\n  }\n\n  bool willNotOverflowSignedSub(const Value *LHS, const Value *RHS,\n                                const Instruction &CxtI) const {\n    return computeOverflowForSignedSub(LHS, RHS, &CxtI) ==\n           OverflowResult::NeverOverflows;\n  }\n\n  bool willNotOverflowUnsignedSub(const Value *LHS, const Value *RHS,\n                                  const Instruction &CxtI) const {\n    return computeOverflowForUnsignedSub(LHS, RHS, &CxtI) ==\n           OverflowResult::NeverOverflows;\n  }\n\n  bool willNotOverflowSub(const Value *LHS, const Value *RHS,\n                          const Instruction &CxtI, bool IsSigned) const {\n    return IsSigned ? willNotOverflowSignedSub(LHS, RHS, CxtI)\n                    : willNotOverflowUnsignedSub(LHS, RHS, CxtI);\n  }\n\n  bool willNotOverflowSignedMul(const Value *LHS, const Value *RHS,\n                                const Instruction &CxtI) const {\n    return computeOverflowForSignedMul(LHS, RHS, &CxtI) ==\n           OverflowResult::NeverOverflows;\n  }\n\n  bool willNotOverflowUnsignedMul(const Value *LHS, const Value *RHS,\n                                  const Instruction &CxtI) const {\n    return computeOverflowForUnsignedMul(LHS, RHS, &CxtI) ==\n           OverflowResult::NeverOverflows;\n  }\n\n  bool willNotOverflowMul(const Value *LHS, const Value *RHS,\n                          const Instruction &CxtI, bool IsSigned) const {\n    return IsSigned ? willNotOverflowSignedMul(LHS, RHS, CxtI)\n                    : willNotOverflowUnsignedMul(LHS, RHS, CxtI);\n  }\n\n  bool willNotOverflow(BinaryOperator::BinaryOps Opcode, const Value *LHS,\n                       const Value *RHS, const Instruction &CxtI,\n                       bool IsSigned) const {\n    switch (Opcode) {\n    case Instruction::Add: return willNotOverflowAdd(LHS, RHS, CxtI, IsSigned);\n    case Instruction::Sub: return willNotOverflowSub(LHS, RHS, CxtI, IsSigned);\n    case Instruction::Mul: return willNotOverflowMul(LHS, RHS, CxtI, IsSigned);\n    default: llvm_unreachable(\"Unexpected opcode for overflow query\");\n    }\n  }\n\n  Value *EmitGEPOffset(User *GEP);\n  Instruction *scalarizePHI(ExtractElementInst &EI, PHINode *PN);\n  Instruction *foldCastedBitwiseLogic(BinaryOperator &I);\n  Instruction *narrowBinOp(TruncInst &Trunc);\n  Instruction *narrowMaskedBinOp(BinaryOperator &And);\n  Instruction *narrowMathIfNoOverflow(BinaryOperator &I);\n  Instruction *narrowFunnelShift(TruncInst &Trunc);\n  Instruction *optimizeBitCastFromPhi(CastInst &CI, PHINode *PN);\n  Instruction *matchSAddSubSat(SelectInst &MinMax1);\n\n  void freelyInvertAllUsersOf(Value *V);\n\n  /// Determine if a pair of casts can be replaced by a single cast.\n  ///\n  /// \\param CI1 The first of a pair of casts.\n  /// \\param CI2 The second of a pair of casts.\n  ///\n  /// \\return 0 if the cast pair cannot be eliminated, otherwise returns an\n  /// Instruction::CastOps value for a cast that can replace the pair, casting\n  /// CI1->getSrcTy() to CI2->getDstTy().\n  ///\n  /// \\see CastInst::isEliminableCastPair\n  Instruction::CastOps isEliminableCastPair(const CastInst *CI1,\n                                            const CastInst *CI2);\n\n  Value *foldAndOfICmps(ICmpInst *LHS, ICmpInst *RHS, BinaryOperator &And);\n  Value *foldOrOfICmps(ICmpInst *LHS, ICmpInst *RHS, BinaryOperator &Or);\n  Value *foldXorOfICmps(ICmpInst *LHS, ICmpInst *RHS, BinaryOperator &Xor);\n\n  /// Optimize (fcmp)&(fcmp) or (fcmp)|(fcmp).\n  /// NOTE: Unlike most of instcombine, this returns a Value which should\n  /// already be inserted into the function.\n  Value *foldLogicOfFCmps(FCmpInst *LHS, FCmpInst *RHS, bool IsAnd);\n\n  Value *foldAndOrOfICmpsOfAndWithPow2(ICmpInst *LHS, ICmpInst *RHS,\n                                       BinaryOperator &Logic);\n  Value *matchSelectFromAndOr(Value *A, Value *B, Value *C, Value *D);\n  Value *getSelectCondition(Value *A, Value *B);\n\n  Instruction *foldIntrinsicWithOverflowCommon(IntrinsicInst *II);\n  Instruction *foldFPSignBitOps(BinaryOperator &I);\n\npublic:\n  /// Inserts an instruction \\p New before instruction \\p Old\n  ///\n  /// Also adds the new instruction to the worklist and returns \\p New so that\n  /// it is suitable for use as the return from the visitation patterns.\n  Instruction *InsertNewInstBefore(Instruction *New, Instruction &Old) {\n    assert(New && !New->getParent() &&\n           \"New instruction already inserted into a basic block!\");\n    BasicBlock *BB = Old.getParent();\n    BB->getInstList().insert(Old.getIterator(), New); // Insert inst\n    Worklist.add(New);\n    return New;\n  }\n\n  /// Same as InsertNewInstBefore, but also sets the debug loc.\n  Instruction *InsertNewInstWith(Instruction *New, Instruction &Old) {\n    New->setDebugLoc(Old.getDebugLoc());\n    return InsertNewInstBefore(New, Old);\n  }\n\n  /// A combiner-aware RAUW-like routine.\n  ///\n  /// This method is to be used when an instruction is found to be dead,\n  /// replaceable with another preexisting expression. Here we add all uses of\n  /// I to the worklist, replace all uses of I with the new value, then return\n  /// I, so that the inst combiner will know that I was modified.\n  Instruction *replaceInstUsesWith(Instruction &I, Value *V) {\n    // If there are no uses to replace, then we return nullptr to indicate that\n    // no changes were made to the program.\n    if (I.use_empty()) return nullptr;\n\n    Worklist.pushUsersToWorkList(I); // Add all modified instrs to worklist.\n\n    // If we are replacing the instruction with itself, this must be in a\n    // segment of unreachable code, so just clobber the instruction.\n    if (&I == V)\n      V = UndefValue::get(I.getType());\n\n    LLVM_DEBUG(dbgs() << \"IC: Replacing \" << I << \"\\n\"\n                      << \"    with \" << *V << '\\n');\n\n    I.replaceAllUsesWith(V);\n    MadeIRChange = true;\n    return &I;\n  }\n\n  /// Replace operand of instruction and add old operand to the worklist.\n  Instruction *replaceOperand(Instruction &I, unsigned OpNum, Value *V) {\n    Worklist.addValue(I.getOperand(OpNum));\n    I.setOperand(OpNum, V);\n    return &I;\n  }\n\n  /// Replace use and add the previously used value to the worklist.\n  void replaceUse(Use &U, Value *NewValue) {\n    Worklist.addValue(U);\n    U = NewValue;\n  }\n\n  /// Creates a result tuple for an overflow intrinsic \\p II with a given\n  /// \\p Result and a constant \\p Overflow value.\n  Instruction *CreateOverflowTuple(IntrinsicInst *II, Value *Result,\n                                   Constant *Overflow) {\n    Constant *V[] = {UndefValue::get(Result->getType()), Overflow};\n    StructType *ST = cast<StructType>(II->getType());\n    Constant *Struct = ConstantStruct::get(ST, V);\n    return InsertValueInst::Create(Struct, Result, 0);\n  }\n\n  /// Create and insert the idiom we use to indicate a block is unreachable\n  /// without having to rewrite the CFG from within InstCombine.\n  void CreateNonTerminatorUnreachable(Instruction *InsertAt) {\n    auto &Ctx = InsertAt->getContext();\n    new StoreInst(ConstantInt::getTrue(Ctx),\n                  UndefValue::get(Type::getInt1PtrTy(Ctx)),\n                  InsertAt);\n  }\n\n\n  /// Combiner aware instruction erasure.\n  ///\n  /// When dealing with an instruction that has side effects or produces a void\n  /// value, we can't rely on DCE to delete the instruction. Instead, visit\n  /// methods should return the value returned by this function.\n  Instruction *eraseInstFromFunction(Instruction &I) override {\n    LLVM_DEBUG(dbgs() << \"IC: ERASE \" << I << '\\n');\n    assert(I.use_empty() && \"Cannot erase instruction that is used!\");\n    salvageDebugInfo(I);\n\n    // Make sure that we reprocess all operands now that we reduced their\n    // use counts.\n    for (Use &Operand : I.operands())\n      if (auto *Inst = dyn_cast<Instruction>(Operand))\n        Worklist.add(Inst);\n\n    Worklist.remove(&I);\n    I.eraseFromParent();\n    MadeIRChange = true;\n    return nullptr; // Don't do anything with FI\n  }\n\n  void computeKnownBits(const Value *V, KnownBits &Known,\n                        unsigned Depth, const Instruction *CxtI) const {\n    llvm::computeKnownBits(V, Known, DL, Depth, &AC, CxtI, &DT);\n  }\n\n  KnownBits computeKnownBits(const Value *V, unsigned Depth,\n                             const Instruction *CxtI) const {\n    return llvm::computeKnownBits(V, DL, Depth, &AC, CxtI, &DT);\n  }\n\n  bool isKnownToBeAPowerOfTwo(const Value *V, bool OrZero = false,\n                              unsigned Depth = 0,\n                              const Instruction *CxtI = nullptr) {\n    return llvm::isKnownToBeAPowerOfTwo(V, DL, OrZero, Depth, &AC, CxtI, &DT);\n  }\n\n  bool MaskedValueIsZero(const Value *V, const APInt &Mask, unsigned Depth = 0,\n                         const Instruction *CxtI = nullptr) const {\n    return llvm::MaskedValueIsZero(V, Mask, DL, Depth, &AC, CxtI, &DT);\n  }\n\n  unsigned ComputeNumSignBits(const Value *Op, unsigned Depth = 0,\n                              const Instruction *CxtI = nullptr) const {\n    return llvm::ComputeNumSignBits(Op, DL, Depth, &AC, CxtI, &DT);\n  }\n\n  OverflowResult computeOverflowForUnsignedMul(const Value *LHS,\n                                               const Value *RHS,\n                                               const Instruction *CxtI) const {\n    return llvm::computeOverflowForUnsignedMul(LHS, RHS, DL, &AC, CxtI, &DT);\n  }\n\n  OverflowResult computeOverflowForSignedMul(const Value *LHS,\n                                             const Value *RHS,\n                                             const Instruction *CxtI) const {\n    return llvm::computeOverflowForSignedMul(LHS, RHS, DL, &AC, CxtI, &DT);\n  }\n\n  OverflowResult computeOverflowForUnsignedAdd(const Value *LHS,\n                                               const Value *RHS,\n                                               const Instruction *CxtI) const {\n    return llvm::computeOverflowForUnsignedAdd(LHS, RHS, DL, &AC, CxtI, &DT);\n  }\n\n  OverflowResult computeOverflowForSignedAdd(const Value *LHS,\n                                             const Value *RHS,\n                                             const Instruction *CxtI) const {\n    return llvm::computeOverflowForSignedAdd(LHS, RHS, DL, &AC, CxtI, &DT);\n  }\n\n  OverflowResult computeOverflowForUnsignedSub(const Value *LHS,\n                                               const Value *RHS,\n                                               const Instruction *CxtI) const {\n    return llvm::computeOverflowForUnsignedSub(LHS, RHS, DL, &AC, CxtI, &DT);\n  }\n\n  OverflowResult computeOverflowForSignedSub(const Value *LHS, const Value *RHS,\n                                             const Instruction *CxtI) const {\n    return llvm::computeOverflowForSignedSub(LHS, RHS, DL, &AC, CxtI, &DT);\n  }\n\n  OverflowResult computeOverflow(\n      Instruction::BinaryOps BinaryOp, bool IsSigned,\n      Value *LHS, Value *RHS, Instruction *CxtI) const;\n\n  /// Performs a few simplifications for operators which are associative\n  /// or commutative.\n  bool SimplifyAssociativeOrCommutative(BinaryOperator &I);\n\n  /// Tries to simplify binary operations which some other binary\n  /// operation distributes over.\n  ///\n  /// It does this by either by factorizing out common terms (eg \"(A*B)+(A*C)\"\n  /// -> \"A*(B+C)\") or expanding out if this results in simplifications (eg: \"A\n  /// & (B | C) -> (A&B) | (A&C)\" if this is a win).  Returns the simplified\n  /// value, or null if it didn't simplify.\n  Value *SimplifyUsingDistributiveLaws(BinaryOperator &I);\n\n  /// Tries to simplify add operations using the definition of remainder.\n  ///\n  /// The definition of remainder is X % C = X - (X / C ) * C. The add\n  /// expression X % C0 + (( X / C0 ) % C1) * C0 can be simplified to\n  /// X % (C0 * C1)\n  Value *SimplifyAddWithRemainder(BinaryOperator &I);\n\n  // Binary Op helper for select operations where the expression can be\n  // efficiently reorganized.\n  Value *SimplifySelectsFeedingBinaryOp(BinaryOperator &I, Value *LHS,\n                                        Value *RHS);\n\n  /// This tries to simplify binary operations by factorizing out common terms\n  /// (e. g. \"(A*B)+(A*C)\" -> \"A*(B+C)\").\n  Value *tryFactorization(BinaryOperator &, Instruction::BinaryOps, Value *,\n                          Value *, Value *, Value *);\n\n  /// Match a select chain which produces one of three values based on whether\n  /// the LHS is less than, equal to, or greater than RHS respectively.\n  /// Return true if we matched a three way compare idiom. The LHS, RHS, Less,\n  /// Equal and Greater values are saved in the matching process and returned to\n  /// the caller.\n  bool matchThreeWayIntCompare(SelectInst *SI, Value *&LHS, Value *&RHS,\n                               ConstantInt *&Less, ConstantInt *&Equal,\n                               ConstantInt *&Greater);\n\n  /// Attempts to replace V with a simpler value based on the demanded\n  /// bits.\n  Value *SimplifyDemandedUseBits(Value *V, APInt DemandedMask, KnownBits &Known,\n                                 unsigned Depth, Instruction *CxtI);\n  bool SimplifyDemandedBits(Instruction *I, unsigned Op,\n                            const APInt &DemandedMask, KnownBits &Known,\n                            unsigned Depth = 0) override;\n\n  /// Helper routine of SimplifyDemandedUseBits. It computes KnownZero/KnownOne\n  /// bits. It also tries to handle simplifications that can be done based on\n  /// DemandedMask, but without modifying the Instruction.\n  Value *SimplifyMultipleUseDemandedBits(Instruction *I,\n                                         const APInt &DemandedMask,\n                                         KnownBits &Known,\n                                         unsigned Depth, Instruction *CxtI);\n\n  /// Helper routine of SimplifyDemandedUseBits. It tries to simplify demanded\n  /// bit for \"r1 = shr x, c1; r2 = shl r1, c2\" instruction sequence.\n  Value *simplifyShrShlDemandedBits(\n      Instruction *Shr, const APInt &ShrOp1, Instruction *Shl,\n      const APInt &ShlOp1, const APInt &DemandedMask, KnownBits &Known);\n\n  /// Tries to simplify operands to an integer instruction based on its\n  /// demanded bits.\n  bool SimplifyDemandedInstructionBits(Instruction &Inst);\n\n  virtual Value *\n  SimplifyDemandedVectorElts(Value *V, APInt DemandedElts, APInt &UndefElts,\n                             unsigned Depth = 0,\n                             bool AllowMultipleUsers = false) override;\n\n  /// Canonicalize the position of binops relative to shufflevector.\n  Instruction *foldVectorBinop(BinaryOperator &Inst);\n  Instruction *foldVectorSelect(SelectInst &Sel);\n\n  /// Given a binary operator, cast instruction, or select which has a PHI node\n  /// as operand #0, see if we can fold the instruction into the PHI (which is\n  /// only possible if all operands to the PHI are constants).\n  Instruction *foldOpIntoPhi(Instruction &I, PHINode *PN);\n\n  /// Given an instruction with a select as one operand and a constant as the\n  /// other operand, try to fold the binary operator into the select arguments.\n  /// This also works for Cast instructions, which obviously do not have a\n  /// second operand.\n  Instruction *FoldOpIntoSelect(Instruction &Op, SelectInst *SI);\n\n  /// This is a convenience wrapper function for the above two functions.\n  Instruction *foldBinOpIntoSelectOrPhi(BinaryOperator &I);\n\n  Instruction *foldAddWithConstant(BinaryOperator &Add);\n\n  /// Try to rotate an operation below a PHI node, using PHI nodes for\n  /// its operands.\n  Instruction *foldPHIArgOpIntoPHI(PHINode &PN);\n  Instruction *foldPHIArgBinOpIntoPHI(PHINode &PN);\n  Instruction *foldPHIArgInsertValueInstructionIntoPHI(PHINode &PN);\n  Instruction *foldPHIArgExtractValueInstructionIntoPHI(PHINode &PN);\n  Instruction *foldPHIArgGEPIntoPHI(PHINode &PN);\n  Instruction *foldPHIArgLoadIntoPHI(PHINode &PN);\n  Instruction *foldPHIArgZextsIntoPHI(PHINode &PN);\n\n  /// If an integer typed PHI has only one use which is an IntToPtr operation,\n  /// replace the PHI with an existing pointer typed PHI if it exists. Otherwise\n  /// insert a new pointer typed PHI and replace the original one.\n  Instruction *foldIntegerTypedPHI(PHINode &PN);\n\n  /// Helper function for FoldPHIArgXIntoPHI() to set debug location for the\n  /// folded operation.\n  void PHIArgMergedDebugLoc(Instruction *Inst, PHINode &PN);\n\n  Instruction *foldGEPICmp(GEPOperator *GEPLHS, Value *RHS,\n                           ICmpInst::Predicate Cond, Instruction &I);\n  Instruction *foldAllocaCmp(ICmpInst &ICI, const AllocaInst *Alloca,\n                             const Value *Other);\n  Instruction *foldCmpLoadFromIndexedGlobal(GetElementPtrInst *GEP,\n                                            GlobalVariable *GV, CmpInst &ICI,\n                                            ConstantInt *AndCst = nullptr);\n  Instruction *foldFCmpIntToFPConst(FCmpInst &I, Instruction *LHSI,\n                                    Constant *RHSC);\n  Instruction *foldICmpAddOpConst(Value *X, const APInt &C,\n                                  ICmpInst::Predicate Pred);\n  Instruction *foldICmpWithCastOp(ICmpInst &ICI);\n\n  Instruction *foldICmpUsingKnownBits(ICmpInst &Cmp);\n  Instruction *foldICmpWithDominatingICmp(ICmpInst &Cmp);\n  Instruction *foldICmpWithConstant(ICmpInst &Cmp);\n  Instruction *foldICmpInstWithConstant(ICmpInst &Cmp);\n  Instruction *foldICmpInstWithConstantNotInt(ICmpInst &Cmp);\n  Instruction *foldICmpBinOp(ICmpInst &Cmp, const SimplifyQuery &SQ);\n  Instruction *foldICmpEquality(ICmpInst &Cmp);\n  Instruction *foldIRemByPowerOfTwoToBitTest(ICmpInst &I);\n  Instruction *foldSignBitTest(ICmpInst &I);\n  Instruction *foldICmpWithZero(ICmpInst &Cmp);\n\n  Value *foldUnsignedMultiplicationOverflowCheck(ICmpInst &Cmp);\n\n  Instruction *foldICmpSelectConstant(ICmpInst &Cmp, SelectInst *Select,\n                                      ConstantInt *C);\n  Instruction *foldICmpTruncConstant(ICmpInst &Cmp, TruncInst *Trunc,\n                                     const APInt &C);\n  Instruction *foldICmpAndConstant(ICmpInst &Cmp, BinaryOperator *And,\n                                   const APInt &C);\n  Instruction *foldICmpXorConstant(ICmpInst &Cmp, BinaryOperator *Xor,\n                                   const APInt &C);\n  Instruction *foldICmpOrConstant(ICmpInst &Cmp, BinaryOperator *Or,\n                                  const APInt &C);\n  Instruction *foldICmpMulConstant(ICmpInst &Cmp, BinaryOperator *Mul,\n                                   const APInt &C);\n  Instruction *foldICmpShlConstant(ICmpInst &Cmp, BinaryOperator *Shl,\n                                   const APInt &C);\n  Instruction *foldICmpShrConstant(ICmpInst &Cmp, BinaryOperator *Shr,\n                                   const APInt &C);\n  Instruction *foldICmpSRemConstant(ICmpInst &Cmp, BinaryOperator *UDiv,\n                                    const APInt &C);\n  Instruction *foldICmpUDivConstant(ICmpInst &Cmp, BinaryOperator *UDiv,\n                                    const APInt &C);\n  Instruction *foldICmpDivConstant(ICmpInst &Cmp, BinaryOperator *Div,\n                                   const APInt &C);\n  Instruction *foldICmpSubConstant(ICmpInst &Cmp, BinaryOperator *Sub,\n                                   const APInt &C);\n  Instruction *foldICmpAddConstant(ICmpInst &Cmp, BinaryOperator *Add,\n                                   const APInt &C);\n  Instruction *foldICmpAndConstConst(ICmpInst &Cmp, BinaryOperator *And,\n                                     const APInt &C1);\n  Instruction *foldICmpAndShift(ICmpInst &Cmp, BinaryOperator *And,\n                                const APInt &C1, const APInt &C2);\n  Instruction *foldICmpShrConstConst(ICmpInst &I, Value *ShAmt, const APInt &C1,\n                                     const APInt &C2);\n  Instruction *foldICmpShlConstConst(ICmpInst &I, Value *ShAmt, const APInt &C1,\n                                     const APInt &C2);\n\n  Instruction *foldICmpBinOpEqualityWithConstant(ICmpInst &Cmp,\n                                                 BinaryOperator *BO,\n                                                 const APInt &C);\n  Instruction *foldICmpIntrinsicWithConstant(ICmpInst &ICI, IntrinsicInst *II,\n                                             const APInt &C);\n  Instruction *foldICmpEqIntrinsicWithConstant(ICmpInst &ICI, IntrinsicInst *II,\n                                               const APInt &C);\n\n  // Helpers of visitSelectInst().\n  Instruction *foldSelectExtConst(SelectInst &Sel);\n  Instruction *foldSelectOpOp(SelectInst &SI, Instruction *TI, Instruction *FI);\n  Instruction *foldSelectIntoOp(SelectInst &SI, Value *, Value *);\n  Instruction *foldSPFofSPF(Instruction *Inner, SelectPatternFlavor SPF1,\n                            Value *A, Value *B, Instruction &Outer,\n                            SelectPatternFlavor SPF2, Value *C);\n  Instruction *foldSelectInstWithICmp(SelectInst &SI, ICmpInst *ICI);\n  Instruction *foldSelectValueEquivalence(SelectInst &SI, ICmpInst &ICI);\n\n  Value *insertRangeTest(Value *V, const APInt &Lo, const APInt &Hi,\n                         bool isSigned, bool Inside);\n  Instruction *PromoteCastOfAllocation(BitCastInst &CI, AllocaInst &AI);\n  bool mergeStoreIntoSuccessor(StoreInst &SI);\n\n  /// Given an initial instruction, check to see if it is the root of a\n  /// bswap/bitreverse idiom. If so, return the equivalent bswap/bitreverse\n  /// intrinsic.\n  Instruction *matchBSwapOrBitReverse(Instruction &I, bool MatchBSwaps,\n                                      bool MatchBitReversals);\n\n  Instruction *SimplifyAnyMemTransfer(AnyMemTransferInst *MI);\n  Instruction *SimplifyAnyMemSet(AnyMemSetInst *MI);\n\n  Value *EvaluateInDifferentType(Value *V, Type *Ty, bool isSigned);\n\n  /// Returns a value X such that Val = X * Scale, or null if none.\n  ///\n  /// If the multiplication is known not to overflow then NoSignedWrap is set.\n  Value *Descale(Value *Val, APInt Scale, bool &NoSignedWrap);\n};\n\nclass Negator final {\n  /// Top-to-bottom, def-to-use negated instruction tree we produced.\n  SmallVector<Instruction *, NegatorMaxNodesSSO> NewInstructions;\n\n  using BuilderTy = IRBuilder<TargetFolder, IRBuilderCallbackInserter>;\n  BuilderTy Builder;\n\n  const DataLayout &DL;\n  AssumptionCache &AC;\n  const DominatorTree &DT;\n\n  const bool IsTrulyNegation;\n\n  SmallDenseMap<Value *, Value *> NegationsCache;\n\n  Negator(LLVMContext &C, const DataLayout &DL, AssumptionCache &AC,\n          const DominatorTree &DT, bool IsTrulyNegation);\n\n#if LLVM_ENABLE_STATS\n  unsigned NumValuesVisitedInThisNegator = 0;\n  ~Negator();\n#endif\n\n  using Result = std::pair<ArrayRef<Instruction *> /*NewInstructions*/,\n                           Value * /*NegatedRoot*/>;\n\n  std::array<Value *, 2> getSortedOperandsOfBinOp(Instruction *I);\n\n  LLVM_NODISCARD Value *visitImpl(Value *V, unsigned Depth);\n\n  LLVM_NODISCARD Value *negate(Value *V, unsigned Depth);\n\n  /// Recurse depth-first and attempt to sink the negation.\n  /// FIXME: use worklist?\n  LLVM_NODISCARD Optional<Result> run(Value *Root);\n\n  Negator(const Negator &) = delete;\n  Negator(Negator &&) = delete;\n  Negator &operator=(const Negator &) = delete;\n  Negator &operator=(Negator &&) = delete;\n\npublic:\n  /// Attempt to negate \\p Root. Retuns nullptr if negation can't be performed,\n  /// otherwise returns negated value.\n  LLVM_NODISCARD static Value *Negate(bool LHSIsZero, Value *Root,\n                                      InstCombinerImpl &IC);\n};\n\n} // end namespace llvm\n\n#undef DEBUG_TYPE\n\n#endif // LLVM_LIB_TRANSFORMS_INSTCOMBINE_INSTCOMBINEINTERNAL_H\n"}}, "reports": [{"events": [{"location": {"col": 24, "file": 4, "line": 4549}, "message": "the definition seen here"}, {"location": {"col": 8, "file": 3, "line": 219}, "message": "differing parameters are named here: ('CtxI'), in definition: ('OrigI')"}, {"location": {"col": 8, "file": 3, "line": 219}, "message": "function 'llvm::InstCombinerImpl::OptimizeOverflowCheck' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h", "reportHash": "7a7b98f1e68d7f8caea44447890665f9", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 32, "file": 4, "line": 4469}, "message": "the definition seen here"}, {"location": {"col": 16, "file": 3, "line": 645}, "message": "differing parameters are named here: ('ICI'), in definition: ('ICmp')"}, {"location": {"col": 16, "file": 3, "line": 645}, "message": "function 'llvm::InstCombinerImpl::foldICmpWithCastOp' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h", "reportHash": "b7eb781b7f66e086406efe4284e4e638", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 32, "file": 4, "line": 4997}, "message": "the definition seen here"}, {"location": {"col": 16, "file": 3, "line": 647}, "message": "differing parameters are named here: ('Cmp'), in definition: ('I')"}, {"location": {"col": 16, "file": 3, "line": 647}, "message": "function 'llvm::InstCombinerImpl::foldICmpUsingKnownBits' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h", "reportHash": "fa38d0d05eb4d0ba5dae3e4da3d5a6f0", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 32, "file": 4, "line": 3208}, "message": "the definition seen here"}, {"location": {"col": 16, "file": 3, "line": 651}, "message": "differing parameters are named here: ('Cmp'), in definition: ('I')"}, {"location": {"col": 16, "file": 3, "line": 651}, "message": "function 'llvm::InstCombinerImpl::foldICmpInstWithConstantNotInt' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h", "reportHash": "f4bfd769694986d84404503ed44b33e7", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 32, "file": 4, "line": 3736}, "message": "the definition seen here"}, {"location": {"col": 16, "file": 3, "line": 652}, "message": "differing parameters are named here: ('Cmp'), in definition: ('I')"}, {"location": {"col": 16, "file": 3, "line": 652}, "message": "function 'llvm::InstCombinerImpl::foldICmpBinOp' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h", "reportHash": "99527ecddb5d1673491553ae4f464b58", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 32, "file": 4, "line": 4201}, "message": "the definition seen here"}, {"location": {"col": 16, "file": 3, "line": 653}, "message": "differing parameters are named here: ('Cmp'), in definition: ('I')"}, {"location": {"col": 16, "file": 3, "line": 653}, "message": "function 'llvm::InstCombinerImpl::foldICmpEquality' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h", "reportHash": "dcc471b7a2d51b4da6e17692d6bea9e7", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 4, "line": 3654}, "message": "the definition seen here"}, {"location": {"col": 10, "file": 3, "line": 658}, "message": "differing parameters are named here: ('Cmp'), in definition: ('I')"}, {"location": {"col": 10, "file": 3, "line": 658}, "message": "function 'llvm::InstCombinerImpl::foldUnsignedMultiplicationOverflowCheck' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h", "reportHash": "80e1c8eb6b2ee452d4a06bd89c2c52f9", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 32, "file": 4, "line": 2273}, "message": "the definition seen here"}, {"location": {"col": 16, "file": 3, "line": 676}, "message": "differing parameters are named here: ('UDiv'), in definition: ('SRem')"}, {"location": {"col": 16, "file": 3, "line": 676}, "message": "function 'llvm::InstCombinerImpl::foldICmpSRemConstant' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h", "reportHash": "9c4ef416e794c0bb19cbb1b6b4670d5e", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 32, "file": 4, "line": 1115}, "message": "the definition seen here"}, {"location": {"col": 16, "file": 3, "line": 690}, "message": "differing parameters are named here: ('ShAmt', 'C1', 'C2'), in definition: ('A', 'AP1', 'AP2')"}, {"location": {"col": 16, "file": 3, "line": 690}, "message": "function 'llvm::InstCombinerImpl::foldICmpShrConstConst' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h", "reportHash": "f4c322e1279359de3e485e461e057bf4", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 32, "file": 4, "line": 1174}, "message": "the definition seen here"}, {"location": {"col": 16, "file": 3, "line": 692}, "message": "differing parameters are named here: ('ShAmt', 'C1', 'C2'), in definition: ('A', 'AP1', 'AP2')"}, {"location": {"col": 16, "file": 3, "line": 692}, "message": "function 'llvm::InstCombinerImpl::foldICmpShlConstConst' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h", "reportHash": "6828ca2b42053b3f4f8e7e6fe90715d2", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 32, "file": 4, "line": 3138}, "message": "the definition seen here"}, {"location": {"col": 16, "file": 3, "line": 698}, "message": "differing parameters are named here: ('ICI'), in definition: ('Cmp')"}, {"location": {"col": 16, "file": 3, "line": 698}, "message": "function 'llvm::InstCombinerImpl::foldICmpIntrinsicWithConstant' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h", "reportHash": "ee11dd759bcc16b9f0d54e9e15b84b42", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 32, "file": 4, "line": 3058}, "message": "the definition seen here"}, {"location": {"col": 16, "file": 3, "line": 700}, "message": "differing parameters are named here: ('ICI'), in definition: ('Cmp')"}, {"location": {"col": 16, "file": 3, "line": 700}, "message": "function 'llvm::InstCombinerImpl::foldICmpEqIntrinsicWithConstant' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h", "reportHash": "f17f426f4b7bcd0e1d997659c207ed74", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
