<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"2": {"id": 2, "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp", "content": "//===- lib/CodeGen/MachineInstr.cpp ---------------------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// Methods common to all machine instructions.\n//\n//===----------------------------------------------------------------------===//\n\n#include \"llvm/CodeGen/MachineInstr.h\"\n#include \"llvm/ADT/APFloat.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/Hashing.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallBitVector.h\"\n#include \"llvm/ADT/SmallString.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/Analysis/AliasAnalysis.h\"\n#include \"llvm/Analysis/Loads.h\"\n#include \"llvm/Analysis/MemoryLocation.h\"\n#include \"llvm/CodeGen/GlobalISel/RegisterBank.h\"\n#include \"llvm/CodeGen/MachineBasicBlock.h\"\n#include \"llvm/CodeGen/MachineFrameInfo.h\"\n#include \"llvm/CodeGen/MachineFunction.h\"\n#include \"llvm/CodeGen/MachineInstrBuilder.h\"\n#include \"llvm/CodeGen/MachineInstrBundle.h\"\n#include \"llvm/CodeGen/MachineMemOperand.h\"\n#include \"llvm/CodeGen/MachineModuleInfo.h\"\n#include \"llvm/CodeGen/MachineOperand.h\"\n#include \"llvm/CodeGen/MachineRegisterInfo.h\"\n#include \"llvm/CodeGen/PseudoSourceValue.h\"\n#include \"llvm/CodeGen/StackMaps.h\"\n#include \"llvm/CodeGen/TargetInstrInfo.h\"\n#include \"llvm/CodeGen/TargetRegisterInfo.h\"\n#include \"llvm/CodeGen/TargetSubtargetInfo.h\"\n#include \"llvm/Config/llvm-config.h\"\n#include \"llvm/IR/Constants.h\"\n#include \"llvm/IR/DebugInfoMetadata.h\"\n#include \"llvm/IR/DebugLoc.h\"\n#include \"llvm/IR/DerivedTypes.h\"\n#include \"llvm/IR/Function.h\"\n#include \"llvm/IR/InlineAsm.h\"\n#include \"llvm/IR/InstrTypes.h\"\n#include \"llvm/IR/Intrinsics.h\"\n#include \"llvm/IR/LLVMContext.h\"\n#include \"llvm/IR/Metadata.h\"\n#include \"llvm/IR/Module.h\"\n#include \"llvm/IR/ModuleSlotTracker.h\"\n#include \"llvm/IR/Operator.h\"\n#include \"llvm/IR/Type.h\"\n#include \"llvm/IR/Value.h\"\n#include \"llvm/MC/MCInstrDesc.h\"\n#include \"llvm/MC/MCRegisterInfo.h\"\n#include \"llvm/MC/MCSymbol.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/CommandLine.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/Debug.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/FormattedStream.h\"\n#include \"llvm/Support/LowLevelTypeImpl.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include \"llvm/Target/TargetIntrinsicInfo.h\"\n#include \"llvm/Target/TargetMachine.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <cstring>\n#include <iterator>\n#include <utility>\n\nusing namespace llvm;\n\nstatic const MachineFunction *getMFIfAvailable(const MachineInstr &MI) {\n  if (const MachineBasicBlock *MBB = MI.getParent())\n    if (const MachineFunction *MF = MBB->getParent())\n      return MF;\n  return nullptr;\n}\n\n// Try to crawl up to the machine function and get TRI and IntrinsicInfo from\n// it.\nstatic void tryToGetTargetInfo(const MachineInstr &MI,\n                               const TargetRegisterInfo *&TRI,\n                               const MachineRegisterInfo *&MRI,\n                               const TargetIntrinsicInfo *&IntrinsicInfo,\n                               const TargetInstrInfo *&TII) {\n\n  if (const MachineFunction *MF = getMFIfAvailable(MI)) {\n    TRI = MF->getSubtarget().getRegisterInfo();\n    MRI = &MF->getRegInfo();\n    IntrinsicInfo = MF->getTarget().getIntrinsicInfo();\n    TII = MF->getSubtarget().getInstrInfo();\n  }\n}\n\nvoid MachineInstr::addImplicitDefUseOperands(MachineFunction &MF) {\n  if (MCID->ImplicitDefs)\n    for (const MCPhysReg *ImpDefs = MCID->getImplicitDefs(); *ImpDefs;\n           ++ImpDefs)\n      addOperand(MF, MachineOperand::CreateReg(*ImpDefs, true, true));\n  if (MCID->ImplicitUses)\n    for (const MCPhysReg *ImpUses = MCID->getImplicitUses(); *ImpUses;\n           ++ImpUses)\n      addOperand(MF, MachineOperand::CreateReg(*ImpUses, false, true));\n}\n\n/// MachineInstr ctor - This constructor creates a MachineInstr and adds the\n/// implicit operands. It reserves space for the number of operands specified by\n/// the MCInstrDesc.\nMachineInstr::MachineInstr(MachineFunction &MF, const MCInstrDesc &tid,\n                           DebugLoc dl, bool NoImp)\n    : MCID(&tid), debugLoc(std::move(dl)), DebugInstrNum(0) {\n  assert(debugLoc.hasTrivialDestructor() && \"Expected trivial destructor\");\n\n  // Reserve space for the expected number of operands.\n  if (unsigned NumOps = MCID->getNumOperands() +\n    MCID->getNumImplicitDefs() + MCID->getNumImplicitUses()) {\n    CapOperands = OperandCapacity::get(NumOps);\n    Operands = MF.allocateOperandArray(CapOperands);\n  }\n\n  if (!NoImp)\n    addImplicitDefUseOperands(MF);\n}\n\n/// MachineInstr ctor - Copies MachineInstr arg exactly.\n/// Does not copy the number from debug instruction numbering, to preserve\n/// uniqueness.\nMachineInstr::MachineInstr(MachineFunction &MF, const MachineInstr &MI)\n    : MCID(&MI.getDesc()), Info(MI.Info), debugLoc(MI.getDebugLoc()),\n      DebugInstrNum(0) {\n  assert(debugLoc.hasTrivialDestructor() && \"Expected trivial destructor\");\n\n  CapOperands = OperandCapacity::get(MI.getNumOperands());\n  Operands = MF.allocateOperandArray(CapOperands);\n\n  // Copy operands.\n  for (const MachineOperand &MO : MI.operands())\n    addOperand(MF, MO);\n\n  // Copy all the sensible flags.\n  setFlags(MI.Flags);\n}\n\nvoid MachineInstr::moveBefore(MachineInstr *MovePos) {\n  MovePos->getParent()->splice(MovePos, getParent(), getIterator());\n}\n\n/// getRegInfo - If this instruction is embedded into a MachineFunction,\n/// return the MachineRegisterInfo object for the current function, otherwise\n/// return null.\nMachineRegisterInfo *MachineInstr::getRegInfo() {\n  if (MachineBasicBlock *MBB = getParent())\n    return &MBB->getParent()->getRegInfo();\n  return nullptr;\n}\n\n/// RemoveRegOperandsFromUseLists - Unlink all of the register operands in\n/// this instruction from their respective use lists.  This requires that the\n/// operands already be on their use lists.\nvoid MachineInstr::RemoveRegOperandsFromUseLists(MachineRegisterInfo &MRI) {\n  for (MachineOperand &MO : operands())\n    if (MO.isReg())\n      MRI.removeRegOperandFromUseList(&MO);\n}\n\n/// AddRegOperandsToUseLists - Add all of the register operands in\n/// this instruction from their respective use lists.  This requires that the\n/// operands not be on their use lists yet.\nvoid MachineInstr::AddRegOperandsToUseLists(MachineRegisterInfo &MRI) {\n  for (MachineOperand &MO : operands())\n    if (MO.isReg())\n      MRI.addRegOperandToUseList(&MO);\n}\n\nvoid MachineInstr::addOperand(const MachineOperand &Op) {\n  MachineBasicBlock *MBB = getParent();\n  assert(MBB && \"Use MachineInstrBuilder to add operands to dangling instrs\");\n  MachineFunction *MF = MBB->getParent();\n  assert(MF && \"Use MachineInstrBuilder to add operands to dangling instrs\");\n  addOperand(*MF, Op);\n}\n\n/// Move NumOps MachineOperands from Src to Dst, with support for overlapping\n/// ranges. If MRI is non-null also update use-def chains.\nstatic void moveOperands(MachineOperand *Dst, MachineOperand *Src,\n                         unsigned NumOps, MachineRegisterInfo *MRI) {\n  if (MRI)\n    return MRI->moveOperands(Dst, Src, NumOps);\n  // MachineOperand is a trivially copyable type so we can just use memmove.\n  assert(Dst && Src && \"Unknown operands\");\n  std::memmove(Dst, Src, NumOps * sizeof(MachineOperand));\n}\n\n/// addOperand - Add the specified operand to the instruction.  If it is an\n/// implicit operand, it is added to the end of the operand list.  If it is\n/// an explicit operand it is added at the end of the explicit operand list\n/// (before the first implicit operand).\nvoid MachineInstr::addOperand(MachineFunction &MF, const MachineOperand &Op) {\n  assert(MCID && \"Cannot add operands before providing an instr descriptor\");\n\n  // Check if we're adding one of our existing operands.\n  if (&Op >= Operands && &Op < Operands + NumOperands) {\n    // This is unusual: MI->addOperand(MI->getOperand(i)).\n    // If adding Op requires reallocating or moving existing operands around,\n    // the Op reference could go stale. Support it by copying Op.\n    MachineOperand CopyOp(Op);\n    return addOperand(MF, CopyOp);\n  }\n\n  // Find the insert location for the new operand.  Implicit registers go at\n  // the end, everything else goes before the implicit regs.\n  //\n  // FIXME: Allow mixed explicit and implicit operands on inline asm.\n  // InstrEmitter::EmitSpecialNode() is marking inline asm clobbers as\n  // implicit-defs, but they must not be moved around.  See the FIXME in\n  // InstrEmitter.cpp.\n  unsigned OpNo = getNumOperands();\n  bool isImpReg = Op.isReg() && Op.isImplicit();\n  if (!isImpReg && !isInlineAsm()) {\n    while (OpNo && Operands[OpNo-1].isReg() && Operands[OpNo-1].isImplicit()) {\n      --OpNo;\n      assert(!Operands[OpNo].isTied() && \"Cannot move tied operands\");\n    }\n  }\n\n#ifndef NDEBUG\n  bool isDebugOp = Op.getType() == MachineOperand::MO_Metadata ||\n                   Op.getType() == MachineOperand::MO_MCSymbol;\n  // OpNo now points as the desired insertion point.  Unless this is a variadic\n  // instruction, only implicit regs are allowed beyond MCID->getNumOperands().\n  // RegMask operands go between the explicit and implicit operands.\n  assert((isImpReg || Op.isRegMask() || MCID->isVariadic() ||\n          OpNo < MCID->getNumOperands() || isDebugOp) &&\n         \"Trying to add an operand to a machine instr that is already done!\");\n#endif\n\n  MachineRegisterInfo *MRI = getRegInfo();\n\n  // Determine if the Operands array needs to be reallocated.\n  // Save the old capacity and operand array.\n  OperandCapacity OldCap = CapOperands;\n  MachineOperand *OldOperands = Operands;\n  if (!OldOperands || OldCap.getSize() == getNumOperands()) {\n    CapOperands = OldOperands ? OldCap.getNext() : OldCap.get(1);\n    Operands = MF.allocateOperandArray(CapOperands);\n    // Move the operands before the insertion point.\n    if (OpNo)\n      moveOperands(Operands, OldOperands, OpNo, MRI);\n  }\n\n  // Move the operands following the insertion point.\n  if (OpNo != NumOperands)\n    moveOperands(Operands + OpNo + 1, OldOperands + OpNo, NumOperands - OpNo,\n                 MRI);\n  ++NumOperands;\n\n  // Deallocate the old operand array.\n  if (OldOperands != Operands && OldOperands)\n    MF.deallocateOperandArray(OldCap, OldOperands);\n\n  // Copy Op into place. It still needs to be inserted into the MRI use lists.\n  MachineOperand *NewMO = new (Operands + OpNo) MachineOperand(Op);\n  NewMO->ParentMI = this;\n\n  // When adding a register operand, tell MRI about it.\n  if (NewMO->isReg()) {\n    // Ensure isOnRegUseList() returns false, regardless of Op's status.\n    NewMO->Contents.Reg.Prev = nullptr;\n    // Ignore existing ties. This is not a property that can be copied.\n    NewMO->TiedTo = 0;\n    // Add the new operand to MRI, but only for instructions in an MBB.\n    if (MRI)\n      MRI->addRegOperandToUseList(NewMO);\n    // The MCID operand information isn't accurate until we start adding\n    // explicit operands. The implicit operands are added first, then the\n    // explicits are inserted before them.\n    if (!isImpReg) {\n      // Tie uses to defs as indicated in MCInstrDesc.\n      if (NewMO->isUse()) {\n        int DefIdx = MCID->getOperandConstraint(OpNo, MCOI::TIED_TO);\n        if (DefIdx != -1)\n          tieOperands(DefIdx, OpNo);\n      }\n      // If the register operand is flagged as early, mark the operand as such.\n      if (MCID->getOperandConstraint(OpNo, MCOI::EARLY_CLOBBER) != -1)\n        NewMO->setIsEarlyClobber(true);\n    }\n  }\n}\n\n/// RemoveOperand - Erase an operand  from an instruction, leaving it with one\n/// fewer operand than it started with.\n///\nvoid MachineInstr::RemoveOperand(unsigned OpNo) {\n  assert(OpNo < getNumOperands() && \"Invalid operand number\");\n  untieRegOperand(OpNo);\n\n#ifndef NDEBUG\n  // Moving tied operands would break the ties.\n  for (unsigned i = OpNo + 1, e = getNumOperands(); i != e; ++i)\n    if (Operands[i].isReg())\n      assert(!Operands[i].isTied() && \"Cannot move tied operands\");\n#endif\n\n  MachineRegisterInfo *MRI = getRegInfo();\n  if (MRI && Operands[OpNo].isReg())\n    MRI->removeRegOperandFromUseList(Operands + OpNo);\n\n  // Don't call the MachineOperand destructor. A lot of this code depends on\n  // MachineOperand having a trivial destructor anyway, and adding a call here\n  // wouldn't make it 'destructor-correct'.\n\n  if (unsigned N = NumOperands - 1 - OpNo)\n    moveOperands(Operands + OpNo, Operands + OpNo + 1, N, MRI);\n  --NumOperands;\n}\n\nvoid MachineInstr::setExtraInfo(MachineFunction &MF,\n                                ArrayRef<MachineMemOperand *> MMOs,\n                                MCSymbol *PreInstrSymbol,\n                                MCSymbol *PostInstrSymbol,\n                                MDNode *HeapAllocMarker) {\n  bool HasPreInstrSymbol = PreInstrSymbol != nullptr;\n  bool HasPostInstrSymbol = PostInstrSymbol != nullptr;\n  bool HasHeapAllocMarker = HeapAllocMarker != nullptr;\n  int NumPointers =\n      MMOs.size() + HasPreInstrSymbol + HasPostInstrSymbol + HasHeapAllocMarker;\n\n  // Drop all extra info if there is none.\n  if (NumPointers <= 0) {\n    Info.clear();\n    return;\n  }\n\n  // If more than one pointer, then store out of line. Store heap alloc markers\n  // out of line because PointerSumType cannot hold more than 4 tag types with\n  // 32-bit pointers.\n  // FIXME: Maybe we should make the symbols in the extra info mutable?\n  else if (NumPointers > 1 || HasHeapAllocMarker) {\n    Info.set<EIIK_OutOfLine>(MF.createMIExtraInfo(\n        MMOs, PreInstrSymbol, PostInstrSymbol, HeapAllocMarker));\n    return;\n  }\n\n  // Otherwise store the single pointer inline.\n  if (HasPreInstrSymbol)\n    Info.set<EIIK_PreInstrSymbol>(PreInstrSymbol);\n  else if (HasPostInstrSymbol)\n    Info.set<EIIK_PostInstrSymbol>(PostInstrSymbol);\n  else\n    Info.set<EIIK_MMO>(MMOs[0]);\n}\n\nvoid MachineInstr::dropMemRefs(MachineFunction &MF) {\n  if (memoperands_empty())\n    return;\n\n  setExtraInfo(MF, {}, getPreInstrSymbol(), getPostInstrSymbol(),\n               getHeapAllocMarker());\n}\n\nvoid MachineInstr::setMemRefs(MachineFunction &MF,\n                              ArrayRef<MachineMemOperand *> MMOs) {\n  if (MMOs.empty()) {\n    dropMemRefs(MF);\n    return;\n  }\n\n  setExtraInfo(MF, MMOs, getPreInstrSymbol(), getPostInstrSymbol(),\n               getHeapAllocMarker());\n}\n\nvoid MachineInstr::addMemOperand(MachineFunction &MF,\n                                 MachineMemOperand *MO) {\n  SmallVector<MachineMemOperand *, 2> MMOs;\n  MMOs.append(memoperands_begin(), memoperands_end());\n  MMOs.push_back(MO);\n  setMemRefs(MF, MMOs);\n}\n\nvoid MachineInstr::cloneMemRefs(MachineFunction &MF, const MachineInstr &MI) {\n  if (this == &MI)\n    // Nothing to do for a self-clone!\n    return;\n\n  assert(&MF == MI.getMF() &&\n         \"Invalid machine functions when cloning memory refrences!\");\n  // See if we can just steal the extra info already allocated for the\n  // instruction. We can do this whenever the pre- and post-instruction symbols\n  // are the same (including null).\n  if (getPreInstrSymbol() == MI.getPreInstrSymbol() &&\n      getPostInstrSymbol() == MI.getPostInstrSymbol() &&\n      getHeapAllocMarker() == MI.getHeapAllocMarker()) {\n    Info = MI.Info;\n    return;\n  }\n\n  // Otherwise, fall back on a copy-based clone.\n  setMemRefs(MF, MI.memoperands());\n}\n\n/// Check to see if the MMOs pointed to by the two MemRefs arrays are\n/// identical.\nstatic bool hasIdenticalMMOs(ArrayRef<MachineMemOperand *> LHS,\n                             ArrayRef<MachineMemOperand *> RHS) {\n  if (LHS.size() != RHS.size())\n    return false;\n\n  auto LHSPointees = make_pointee_range(LHS);\n  auto RHSPointees = make_pointee_range(RHS);\n  return std::equal(LHSPointees.begin(), LHSPointees.end(),\n                    RHSPointees.begin());\n}\n\nvoid MachineInstr::cloneMergedMemRefs(MachineFunction &MF,\n                                      ArrayRef<const MachineInstr *> MIs) {\n  // Try handling easy numbers of MIs with simpler mechanisms.\n  if (MIs.empty()) {\n    dropMemRefs(MF);\n    return;\n  }\n  if (MIs.size() == 1) {\n    cloneMemRefs(MF, *MIs[0]);\n    return;\n  }\n  // Because an empty memoperands list provides *no* information and must be\n  // handled conservatively (assuming the instruction can do anything), the only\n  // way to merge with it is to drop all other memoperands.\n  if (MIs[0]->memoperands_empty()) {\n    dropMemRefs(MF);\n    return;\n  }\n\n  // Handle the general case.\n  SmallVector<MachineMemOperand *, 2> MergedMMOs;\n  // Start with the first instruction.\n  assert(&MF == MIs[0]->getMF() &&\n         \"Invalid machine functions when cloning memory references!\");\n  MergedMMOs.append(MIs[0]->memoperands_begin(), MIs[0]->memoperands_end());\n  // Now walk all the other instructions and accumulate any different MMOs.\n  for (const MachineInstr &MI : make_pointee_range(MIs.slice(1))) {\n    assert(&MF == MI.getMF() &&\n           \"Invalid machine functions when cloning memory references!\");\n\n    // Skip MIs with identical operands to the first. This is a somewhat\n    // arbitrary hack but will catch common cases without being quadratic.\n    // TODO: We could fully implement merge semantics here if needed.\n    if (hasIdenticalMMOs(MIs[0]->memoperands(), MI.memoperands()))\n      continue;\n\n    // Because an empty memoperands list provides *no* information and must be\n    // handled conservatively (assuming the instruction can do anything), the\n    // only way to merge with it is to drop all other memoperands.\n    if (MI.memoperands_empty()) {\n      dropMemRefs(MF);\n      return;\n    }\n\n    // Otherwise accumulate these into our temporary buffer of the merged state.\n    MergedMMOs.append(MI.memoperands_begin(), MI.memoperands_end());\n  }\n\n  setMemRefs(MF, MergedMMOs);\n}\n\nvoid MachineInstr::setPreInstrSymbol(MachineFunction &MF, MCSymbol *Symbol) {\n  // Do nothing if old and new symbols are the same.\n  if (Symbol == getPreInstrSymbol())\n    return;\n\n  // If there was only one symbol and we're removing it, just clear info.\n  if (!Symbol && Info.is<EIIK_PreInstrSymbol>()) {\n    Info.clear();\n    return;\n  }\n\n  setExtraInfo(MF, memoperands(), Symbol, getPostInstrSymbol(),\n               getHeapAllocMarker());\n}\n\nvoid MachineInstr::setPostInstrSymbol(MachineFunction &MF, MCSymbol *Symbol) {\n  // Do nothing if old and new symbols are the same.\n  if (Symbol == getPostInstrSymbol())\n    return;\n\n  // If there was only one symbol and we're removing it, just clear info.\n  if (!Symbol && Info.is<EIIK_PostInstrSymbol>()) {\n    Info.clear();\n    return;\n  }\n\n  setExtraInfo(MF, memoperands(), getPreInstrSymbol(), Symbol,\n               getHeapAllocMarker());\n}\n\nvoid MachineInstr::setHeapAllocMarker(MachineFunction &MF, MDNode *Marker) {\n  // Do nothing if old and new symbols are the same.\n  if (Marker == getHeapAllocMarker())\n    return;\n\n  setExtraInfo(MF, memoperands(), getPreInstrSymbol(), getPostInstrSymbol(),\n               Marker);\n}\n\nvoid MachineInstr::cloneInstrSymbols(MachineFunction &MF,\n                                     const MachineInstr &MI) {\n  if (this == &MI)\n    // Nothing to do for a self-clone!\n    return;\n\n  assert(&MF == MI.getMF() &&\n         \"Invalid machine functions when cloning instruction symbols!\");\n\n  setPreInstrSymbol(MF, MI.getPreInstrSymbol());\n  setPostInstrSymbol(MF, MI.getPostInstrSymbol());\n  setHeapAllocMarker(MF, MI.getHeapAllocMarker());\n}\n\nuint16_t MachineInstr::mergeFlagsWith(const MachineInstr &Other) const {\n  // For now, the just return the union of the flags. If the flags get more\n  // complicated over time, we might need more logic here.\n  return getFlags() | Other.getFlags();\n}\n\nuint16_t MachineInstr::copyFlagsFromInstruction(const Instruction &I) {\n  uint16_t MIFlags = 0;\n  // Copy the wrapping flags.\n  if (const OverflowingBinaryOperator *OB =\n          dyn_cast<OverflowingBinaryOperator>(&I)) {\n    if (OB->hasNoSignedWrap())\n      MIFlags |= MachineInstr::MIFlag::NoSWrap;\n    if (OB->hasNoUnsignedWrap())\n      MIFlags |= MachineInstr::MIFlag::NoUWrap;\n  }\n\n  // Copy the exact flag.\n  if (const PossiblyExactOperator *PE = dyn_cast<PossiblyExactOperator>(&I))\n    if (PE->isExact())\n      MIFlags |= MachineInstr::MIFlag::IsExact;\n\n  // Copy the fast-math flags.\n  if (const FPMathOperator *FP = dyn_cast<FPMathOperator>(&I)) {\n    const FastMathFlags Flags = FP->getFastMathFlags();\n    if (Flags.noNaNs())\n      MIFlags |= MachineInstr::MIFlag::FmNoNans;\n    if (Flags.noInfs())\n      MIFlags |= MachineInstr::MIFlag::FmNoInfs;\n    if (Flags.noSignedZeros())\n      MIFlags |= MachineInstr::MIFlag::FmNsz;\n    if (Flags.allowReciprocal())\n      MIFlags |= MachineInstr::MIFlag::FmArcp;\n    if (Flags.allowContract())\n      MIFlags |= MachineInstr::MIFlag::FmContract;\n    if (Flags.approxFunc())\n      MIFlags |= MachineInstr::MIFlag::FmAfn;\n    if (Flags.allowReassoc())\n      MIFlags |= MachineInstr::MIFlag::FmReassoc;\n  }\n\n  return MIFlags;\n}\n\nvoid MachineInstr::copyIRFlags(const Instruction &I) {\n  Flags = copyFlagsFromInstruction(I);\n}\n\nbool MachineInstr::hasPropertyInBundle(uint64_t Mask, QueryType Type) const {\n  assert(!isBundledWithPred() && \"Must be called on bundle header\");\n  for (MachineBasicBlock::const_instr_iterator MII = getIterator();; ++MII) {\n    if (MII->getDesc().getFlags() & Mask) {\n      if (Type == AnyInBundle)\n        return true;\n    } else {\n      if (Type == AllInBundle && !MII->isBundle())\n        return false;\n    }\n    // This was the last instruction in the bundle.\n    if (!MII->isBundledWithSucc())\n      return Type == AllInBundle;\n  }\n}\n\nbool MachineInstr::isIdenticalTo(const MachineInstr &Other,\n                                 MICheckType Check) const {\n  // If opcodes or number of operands are not the same then the two\n  // instructions are obviously not identical.\n  if (Other.getOpcode() != getOpcode() ||\n      Other.getNumOperands() != getNumOperands())\n    return false;\n\n  if (isBundle()) {\n    // We have passed the test above that both instructions have the same\n    // opcode, so we know that both instructions are bundles here. Let's compare\n    // MIs inside the bundle.\n    assert(Other.isBundle() && \"Expected that both instructions are bundles.\");\n    MachineBasicBlock::const_instr_iterator I1 = getIterator();\n    MachineBasicBlock::const_instr_iterator I2 = Other.getIterator();\n    // Loop until we analysed the last intruction inside at least one of the\n    // bundles.\n    while (I1->isBundledWithSucc() && I2->isBundledWithSucc()) {\n      ++I1;\n      ++I2;\n      if (!I1->isIdenticalTo(*I2, Check))\n        return false;\n    }\n    // If we've reached the end of just one of the two bundles, but not both,\n    // the instructions are not identical.\n    if (I1->isBundledWithSucc() || I2->isBundledWithSucc())\n      return false;\n  }\n\n  // Check operands to make sure they match.\n  for (unsigned i = 0, e = getNumOperands(); i != e; ++i) {\n    const MachineOperand &MO = getOperand(i);\n    const MachineOperand &OMO = Other.getOperand(i);\n    if (!MO.isReg()) {\n      if (!MO.isIdenticalTo(OMO))\n        return false;\n      continue;\n    }\n\n    // Clients may or may not want to ignore defs when testing for equality.\n    // For example, machine CSE pass only cares about finding common\n    // subexpressions, so it's safe to ignore virtual register defs.\n    if (MO.isDef()) {\n      if (Check == IgnoreDefs)\n        continue;\n      else if (Check == IgnoreVRegDefs) {\n        if (!Register::isVirtualRegister(MO.getReg()) ||\n            !Register::isVirtualRegister(OMO.getReg()))\n          if (!MO.isIdenticalTo(OMO))\n            return false;\n      } else {\n        if (!MO.isIdenticalTo(OMO))\n          return false;\n        if (Check == CheckKillDead && MO.isDead() != OMO.isDead())\n          return false;\n      }\n    } else {\n      if (!MO.isIdenticalTo(OMO))\n        return false;\n      if (Check == CheckKillDead && MO.isKill() != OMO.isKill())\n        return false;\n    }\n  }\n  // If DebugLoc does not match then two debug instructions are not identical.\n  if (isDebugInstr())\n    if (getDebugLoc() && Other.getDebugLoc() &&\n        getDebugLoc() != Other.getDebugLoc())\n      return false;\n  return true;\n}\n\nconst MachineFunction *MachineInstr::getMF() const {\n  return getParent()->getParent();\n}\n\nMachineInstr *MachineInstr::removeFromParent() {\n  assert(getParent() && \"Not embedded in a basic block!\");\n  return getParent()->remove(this);\n}\n\nMachineInstr *MachineInstr::removeFromBundle() {\n  assert(getParent() && \"Not embedded in a basic block!\");\n  return getParent()->remove_instr(this);\n}\n\nvoid MachineInstr::eraseFromParent() {\n  assert(getParent() && \"Not embedded in a basic block!\");\n  getParent()->erase(this);\n}\n\nvoid MachineInstr::eraseFromParentAndMarkDBGValuesForRemoval() {\n  assert(getParent() && \"Not embedded in a basic block!\");\n  MachineBasicBlock *MBB = getParent();\n  MachineFunction *MF = MBB->getParent();\n  assert(MF && \"Not embedded in a function!\");\n\n  MachineInstr *MI = (MachineInstr *)this;\n  MachineRegisterInfo &MRI = MF->getRegInfo();\n\n  for (const MachineOperand &MO : MI->operands()) {\n    if (!MO.isReg() || !MO.isDef())\n      continue;\n    Register Reg = MO.getReg();\n    if (!Reg.isVirtual())\n      continue;\n    MRI.markUsesInDebugValueAsUndef(Reg);\n  }\n  MI->eraseFromParent();\n}\n\nvoid MachineInstr::eraseFromBundle() {\n  assert(getParent() && \"Not embedded in a basic block!\");\n  getParent()->erase_instr(this);\n}\n\nbool MachineInstr::isCandidateForCallSiteEntry(QueryType Type) const {\n  if (!isCall(Type))\n    return false;\n  switch (getOpcode()) {\n  case TargetOpcode::PATCHPOINT:\n  case TargetOpcode::STACKMAP:\n  case TargetOpcode::STATEPOINT:\n  case TargetOpcode::FENTRY_CALL:\n    return false;\n  }\n  return true;\n}\n\nbool MachineInstr::shouldUpdateCallSiteInfo() const {\n  if (isBundle())\n    return isCandidateForCallSiteEntry(MachineInstr::AnyInBundle);\n  return isCandidateForCallSiteEntry();\n}\n\nunsigned MachineInstr::getNumExplicitOperands() const {\n  unsigned NumOperands = MCID->getNumOperands();\n  if (!MCID->isVariadic())\n    return NumOperands;\n\n  for (unsigned I = NumOperands, E = getNumOperands(); I != E; ++I) {\n    const MachineOperand &MO = getOperand(I);\n    // The operands must always be in the following order:\n    // - explicit reg defs,\n    // - other explicit operands (reg uses, immediates, etc.),\n    // - implicit reg defs\n    // - implicit reg uses\n    if (MO.isReg() && MO.isImplicit())\n      break;\n    ++NumOperands;\n  }\n  return NumOperands;\n}\n\nunsigned MachineInstr::getNumExplicitDefs() const {\n  unsigned NumDefs = MCID->getNumDefs();\n  if (!MCID->isVariadic())\n    return NumDefs;\n\n  for (unsigned I = NumDefs, E = getNumOperands(); I != E; ++I) {\n    const MachineOperand &MO = getOperand(I);\n    if (!MO.isReg() || !MO.isDef() || MO.isImplicit())\n      break;\n    ++NumDefs;\n  }\n  return NumDefs;\n}\n\nvoid MachineInstr::bundleWithPred() {\n  assert(!isBundledWithPred() && \"MI is already bundled with its predecessor\");\n  setFlag(BundledPred);\n  MachineBasicBlock::instr_iterator Pred = getIterator();\n  --Pred;\n  assert(!Pred->isBundledWithSucc() && \"Inconsistent bundle flags\");\n  Pred->setFlag(BundledSucc);\n}\n\nvoid MachineInstr::bundleWithSucc() {\n  assert(!isBundledWithSucc() && \"MI is already bundled with its successor\");\n  setFlag(BundledSucc);\n  MachineBasicBlock::instr_iterator Succ = getIterator();\n  ++Succ;\n  assert(!Succ->isBundledWithPred() && \"Inconsistent bundle flags\");\n  Succ->setFlag(BundledPred);\n}\n\nvoid MachineInstr::unbundleFromPred() {\n  assert(isBundledWithPred() && \"MI isn't bundled with its predecessor\");\n  clearFlag(BundledPred);\n  MachineBasicBlock::instr_iterator Pred = getIterator();\n  --Pred;\n  assert(Pred->isBundledWithSucc() && \"Inconsistent bundle flags\");\n  Pred->clearFlag(BundledSucc);\n}\n\nvoid MachineInstr::unbundleFromSucc() {\n  assert(isBundledWithSucc() && \"MI isn't bundled with its successor\");\n  clearFlag(BundledSucc);\n  MachineBasicBlock::instr_iterator Succ = getIterator();\n  ++Succ;\n  assert(Succ->isBundledWithPred() && \"Inconsistent bundle flags\");\n  Succ->clearFlag(BundledPred);\n}\n\nbool MachineInstr::isStackAligningInlineAsm() const {\n  if (isInlineAsm()) {\n    unsigned ExtraInfo = getOperand(InlineAsm::MIOp_ExtraInfo).getImm();\n    if (ExtraInfo & InlineAsm::Extra_IsAlignStack)\n      return true;\n  }\n  return false;\n}\n\nInlineAsm::AsmDialect MachineInstr::getInlineAsmDialect() const {\n  assert(isInlineAsm() && \"getInlineAsmDialect() only works for inline asms!\");\n  unsigned ExtraInfo = getOperand(InlineAsm::MIOp_ExtraInfo).getImm();\n  return InlineAsm::AsmDialect((ExtraInfo & InlineAsm::Extra_AsmDialect) != 0);\n}\n\nint MachineInstr::findInlineAsmFlagIdx(unsigned OpIdx,\n                                       unsigned *GroupNo) const {\n  assert(isInlineAsm() && \"Expected an inline asm instruction\");\n  assert(OpIdx < getNumOperands() && \"OpIdx out of range\");\n\n  // Ignore queries about the initial operands.\n  if (OpIdx < InlineAsm::MIOp_FirstOperand)\n    return -1;\n\n  unsigned Group = 0;\n  unsigned NumOps;\n  for (unsigned i = InlineAsm::MIOp_FirstOperand, e = getNumOperands(); i < e;\n       i += NumOps) {\n    const MachineOperand &FlagMO = getOperand(i);\n    // If we reach the implicit register operands, stop looking.\n    if (!FlagMO.isImm())\n      return -1;\n    NumOps = 1 + InlineAsm::getNumOperandRegisters(FlagMO.getImm());\n    if (i + NumOps > OpIdx) {\n      if (GroupNo)\n        *GroupNo = Group;\n      return i;\n    }\n    ++Group;\n  }\n  return -1;\n}\n\nconst DILabel *MachineInstr::getDebugLabel() const {\n  assert(isDebugLabel() && \"not a DBG_LABEL\");\n  return cast<DILabel>(getOperand(0).getMetadata());\n}\n\nconst MachineOperand &MachineInstr::getDebugVariableOp() const {\n  assert((isDebugValue() || isDebugRef()) && \"not a DBG_VALUE\");\n  return getOperand(2);\n}\n\nMachineOperand &MachineInstr::getDebugVariableOp() {\n  assert((isDebugValue() || isDebugRef()) && \"not a DBG_VALUE\");\n  return getOperand(2);\n}\n\nconst DILocalVariable *MachineInstr::getDebugVariable() const {\n  assert((isDebugValue() || isDebugRef()) && \"not a DBG_VALUE\");\n  return cast<DILocalVariable>(getOperand(2).getMetadata());\n}\n\nMachineOperand &MachineInstr::getDebugExpressionOp() {\n  assert((isDebugValue() || isDebugRef()) && \"not a DBG_VALUE\");\n  return getOperand(3);\n}\n\nconst DIExpression *MachineInstr::getDebugExpression() const {\n  assert((isDebugValue() || isDebugRef()) && \"not a DBG_VALUE\");\n  return cast<DIExpression>(getOperand(3).getMetadata());\n}\n\nbool MachineInstr::isDebugEntryValue() const {\n  return isDebugValue() && getDebugExpression()->isEntryValue();\n}\n\nconst TargetRegisterClass*\nMachineInstr::getRegClassConstraint(unsigned OpIdx,\n                                    const TargetInstrInfo *TII,\n                                    const TargetRegisterInfo *TRI) const {\n  assert(getParent() && \"Can't have an MBB reference here!\");\n  assert(getMF() && \"Can't have an MF reference here!\");\n  const MachineFunction &MF = *getMF();\n\n  // Most opcodes have fixed constraints in their MCInstrDesc.\n  if (!isInlineAsm())\n    return TII->getRegClass(getDesc(), OpIdx, TRI, MF);\n\n  if (!getOperand(OpIdx).isReg())\n    return nullptr;\n\n  // For tied uses on inline asm, get the constraint from the def.\n  unsigned DefIdx;\n  if (getOperand(OpIdx).isUse() && isRegTiedToDefOperand(OpIdx, &DefIdx))\n    OpIdx = DefIdx;\n\n  // Inline asm stores register class constraints in the flag word.\n  int FlagIdx = findInlineAsmFlagIdx(OpIdx);\n  if (FlagIdx < 0)\n    return nullptr;\n\n  unsigned Flag = getOperand(FlagIdx).getImm();\n  unsigned RCID;\n  if ((InlineAsm::getKind(Flag) == InlineAsm::Kind_RegUse ||\n       InlineAsm::getKind(Flag) == InlineAsm::Kind_RegDef ||\n       InlineAsm::getKind(Flag) == InlineAsm::Kind_RegDefEarlyClobber) &&\n      InlineAsm::hasRegClassConstraint(Flag, RCID))\n    return TRI->getRegClass(RCID);\n\n  // Assume that all registers in a memory operand are pointers.\n  if (InlineAsm::getKind(Flag) == InlineAsm::Kind_Mem)\n    return TRI->getPointerRegClass(MF);\n\n  return nullptr;\n}\n\nconst TargetRegisterClass *MachineInstr::getRegClassConstraintEffectForVReg(\n    Register Reg, const TargetRegisterClass *CurRC, const TargetInstrInfo *TII,\n    const TargetRegisterInfo *TRI, bool ExploreBundle) const {\n  // Check every operands inside the bundle if we have\n  // been asked to.\n  if (ExploreBundle)\n    for (ConstMIBundleOperands OpndIt(*this); OpndIt.isValid() && CurRC;\n         ++OpndIt)\n      CurRC = OpndIt->getParent()->getRegClassConstraintEffectForVRegImpl(\n          OpndIt.getOperandNo(), Reg, CurRC, TII, TRI);\n  else\n    // Otherwise, just check the current operands.\n    for (unsigned i = 0, e = NumOperands; i < e && CurRC; ++i)\n      CurRC = getRegClassConstraintEffectForVRegImpl(i, Reg, CurRC, TII, TRI);\n  return CurRC;\n}\n\nconst TargetRegisterClass *MachineInstr::getRegClassConstraintEffectForVRegImpl(\n    unsigned OpIdx, Register Reg, const TargetRegisterClass *CurRC,\n    const TargetInstrInfo *TII, const TargetRegisterInfo *TRI) const {\n  assert(CurRC && \"Invalid initial register class\");\n  // Check if Reg is constrained by some of its use/def from MI.\n  const MachineOperand &MO = getOperand(OpIdx);\n  if (!MO.isReg() || MO.getReg() != Reg)\n    return CurRC;\n  // If yes, accumulate the constraints through the operand.\n  return getRegClassConstraintEffect(OpIdx, CurRC, TII, TRI);\n}\n\nconst TargetRegisterClass *MachineInstr::getRegClassConstraintEffect(\n    unsigned OpIdx, const TargetRegisterClass *CurRC,\n    const TargetInstrInfo *TII, const TargetRegisterInfo *TRI) const {\n  const TargetRegisterClass *OpRC = getRegClassConstraint(OpIdx, TII, TRI);\n  const MachineOperand &MO = getOperand(OpIdx);\n  assert(MO.isReg() &&\n         \"Cannot get register constraints for non-register operand\");\n  assert(CurRC && \"Invalid initial register class\");\n  if (unsigned SubIdx = MO.getSubReg()) {\n    if (OpRC)\n      CurRC = TRI->getMatchingSuperRegClass(CurRC, OpRC, SubIdx);\n    else\n      CurRC = TRI->getSubClassWithSubReg(CurRC, SubIdx);\n  } else if (OpRC)\n    CurRC = TRI->getCommonSubClass(CurRC, OpRC);\n  return CurRC;\n}\n\n/// Return the number of instructions inside the MI bundle, not counting the\n/// header instruction.\nunsigned MachineInstr::getBundleSize() const {\n  MachineBasicBlock::const_instr_iterator I = getIterator();\n  unsigned Size = 0;\n  while (I->isBundledWithSucc()) {\n    ++Size;\n    ++I;\n  }\n  return Size;\n}\n\n/// Returns true if the MachineInstr has an implicit-use operand of exactly\n/// the given register (not considering sub/super-registers).\nbool MachineInstr::hasRegisterImplicitUseOperand(Register Reg) const {\n  for (unsigned i = 0, e = getNumOperands(); i != e; ++i) {\n    const MachineOperand &MO = getOperand(i);\n    if (MO.isReg() && MO.isUse() && MO.isImplicit() && MO.getReg() == Reg)\n      return true;\n  }\n  return false;\n}\n\n/// findRegisterUseOperandIdx() - Returns the MachineOperand that is a use of\n/// the specific register or -1 if it is not found. It further tightens\n/// the search criteria to a use that kills the register if isKill is true.\nint MachineInstr::findRegisterUseOperandIdx(\n    Register Reg, bool isKill, const TargetRegisterInfo *TRI) const {\n  for (unsigned i = 0, e = getNumOperands(); i != e; ++i) {\n    const MachineOperand &MO = getOperand(i);\n    if (!MO.isReg() || !MO.isUse())\n      continue;\n    Register MOReg = MO.getReg();\n    if (!MOReg)\n      continue;\n    if (MOReg == Reg || (TRI && Reg && MOReg && TRI->regsOverlap(MOReg, Reg)))\n      if (!isKill || MO.isKill())\n        return i;\n  }\n  return -1;\n}\n\n/// readsWritesVirtualRegister - Return a pair of bools (reads, writes)\n/// indicating if this instruction reads or writes Reg. This also considers\n/// partial defines.\nstd::pair<bool,bool>\nMachineInstr::readsWritesVirtualRegister(Register Reg,\n                                         SmallVectorImpl<unsigned> *Ops) const {\n  bool PartDef = false; // Partial redefine.\n  bool FullDef = false; // Full define.\n  bool Use = false;\n\n  for (unsigned i = 0, e = getNumOperands(); i != e; ++i) {\n    const MachineOperand &MO = getOperand(i);\n    if (!MO.isReg() || MO.getReg() != Reg)\n      continue;\n    if (Ops)\n      Ops->push_back(i);\n    if (MO.isUse())\n      Use |= !MO.isUndef();\n    else if (MO.getSubReg() && !MO.isUndef())\n      // A partial def undef doesn't count as reading the register.\n      PartDef = true;\n    else\n      FullDef = true;\n  }\n  // A partial redefine uses Reg unless there is also a full define.\n  return std::make_pair(Use || (PartDef && !FullDef), PartDef || FullDef);\n}\n\n/// findRegisterDefOperandIdx() - Returns the operand index that is a def of\n/// the specified register or -1 if it is not found. If isDead is true, defs\n/// that are not dead are skipped. If TargetRegisterInfo is non-null, then it\n/// also checks if there is a def of a super-register.\nint\nMachineInstr::findRegisterDefOperandIdx(Register Reg, bool isDead, bool Overlap,\n                                        const TargetRegisterInfo *TRI) const {\n  bool isPhys = Register::isPhysicalRegister(Reg);\n  for (unsigned i = 0, e = getNumOperands(); i != e; ++i) {\n    const MachineOperand &MO = getOperand(i);\n    // Accept regmask operands when Overlap is set.\n    // Ignore them when looking for a specific def operand (Overlap == false).\n    if (isPhys && Overlap && MO.isRegMask() && MO.clobbersPhysReg(Reg))\n      return i;\n    if (!MO.isReg() || !MO.isDef())\n      continue;\n    Register MOReg = MO.getReg();\n    bool Found = (MOReg == Reg);\n    if (!Found && TRI && isPhys && Register::isPhysicalRegister(MOReg)) {\n      if (Overlap)\n        Found = TRI->regsOverlap(MOReg, Reg);\n      else\n        Found = TRI->isSubRegister(MOReg, Reg);\n    }\n    if (Found && (!isDead || MO.isDead()))\n      return i;\n  }\n  return -1;\n}\n\n/// findFirstPredOperandIdx() - Find the index of the first operand in the\n/// operand list that is used to represent the predicate. It returns -1 if\n/// none is found.\nint MachineInstr::findFirstPredOperandIdx() const {\n  // Don't call MCID.findFirstPredOperandIdx() because this variant\n  // is sometimes called on an instruction that's not yet complete, and\n  // so the number of operands is less than the MCID indicates. In\n  // particular, the PTX target does this.\n  const MCInstrDesc &MCID = getDesc();\n  if (MCID.isPredicable()) {\n    for (unsigned i = 0, e = getNumOperands(); i != e; ++i)\n      if (MCID.OpInfo[i].isPredicate())\n        return i;\n  }\n\n  return -1;\n}\n\n// MachineOperand::TiedTo is 4 bits wide.\nconst unsigned TiedMax = 15;\n\n/// tieOperands - Mark operands at DefIdx and UseIdx as tied to each other.\n///\n/// Use and def operands can be tied together, indicated by a non-zero TiedTo\n/// field. TiedTo can have these values:\n///\n/// 0:              Operand is not tied to anything.\n/// 1 to TiedMax-1: Tied to getOperand(TiedTo-1).\n/// TiedMax:        Tied to an operand >= TiedMax-1.\n///\n/// The tied def must be one of the first TiedMax operands on a normal\n/// instruction. INLINEASM instructions allow more tied defs.\n///\nvoid MachineInstr::tieOperands(unsigned DefIdx, unsigned UseIdx) {\n  MachineOperand &DefMO = getOperand(DefIdx);\n  MachineOperand &UseMO = getOperand(UseIdx);\n  assert(DefMO.isDef() && \"DefIdx must be a def operand\");\n  assert(UseMO.isUse() && \"UseIdx must be a use operand\");\n  assert(!DefMO.isTied() && \"Def is already tied to another use\");\n  assert(!UseMO.isTied() && \"Use is already tied to another def\");\n\n  if (DefIdx < TiedMax)\n    UseMO.TiedTo = DefIdx + 1;\n  else {\n    // Inline asm can use the group descriptors to find tied operands,\n    // statepoint tied operands are trivial to match (1-1 reg def with reg use),\n    // but on normal instruction, the tied def must be within the first TiedMax\n    // operands.\n    assert((isInlineAsm() || getOpcode() == TargetOpcode::STATEPOINT) &&\n           \"DefIdx out of range\");\n    UseMO.TiedTo = TiedMax;\n  }\n\n  // UseIdx can be out of range, we'll search for it in findTiedOperandIdx().\n  DefMO.TiedTo = std::min(UseIdx + 1, TiedMax);\n}\n\n/// Given the index of a tied register operand, find the operand it is tied to.\n/// Defs are tied to uses and vice versa. Returns the index of the tied operand\n/// which must exist.\nunsigned MachineInstr::findTiedOperandIdx(unsigned OpIdx) const {\n  const MachineOperand &MO = getOperand(OpIdx);\n  assert(MO.isTied() && \"Operand isn't tied\");\n\n  // Normally TiedTo is in range.\n  if (MO.TiedTo < TiedMax)\n    return MO.TiedTo - 1;\n\n  // Uses on normal instructions can be out of range.\n  if (!isInlineAsm() && getOpcode() != TargetOpcode::STATEPOINT) {\n    // Normal tied defs must be in the 0..TiedMax-1 range.\n    if (MO.isUse())\n      return TiedMax - 1;\n    // MO is a def. Search for the tied use.\n    for (unsigned i = TiedMax - 1, e = getNumOperands(); i != e; ++i) {\n      const MachineOperand &UseMO = getOperand(i);\n      if (UseMO.isReg() && UseMO.isUse() && UseMO.TiedTo == OpIdx + 1)\n        return i;\n    }\n    llvm_unreachable(\"Can't find tied use\");\n  }\n\n  if (getOpcode() == TargetOpcode::STATEPOINT) {\n    // In STATEPOINT defs correspond 1-1 to GC pointer operands passed\n    // on registers.\n    StatepointOpers SO(this);\n    unsigned CurUseIdx = SO.getFirstGCPtrIdx();\n    assert(CurUseIdx != -1U && \"only gc pointer statepoint operands can be tied\");\n    unsigned NumDefs = getNumDefs();\n    for (unsigned CurDefIdx = 0; CurDefIdx < NumDefs; ++CurDefIdx) {\n      while (!getOperand(CurUseIdx).isReg())\n        CurUseIdx = StackMaps::getNextMetaArgIdx(this, CurUseIdx);\n      if (OpIdx == CurDefIdx)\n        return CurUseIdx;\n      if (OpIdx == CurUseIdx)\n        return CurDefIdx;\n      CurUseIdx = StackMaps::getNextMetaArgIdx(this, CurUseIdx);\n    }\n    llvm_unreachable(\"Can't find tied use\");\n  }\n\n  // Now deal with inline asm by parsing the operand group descriptor flags.\n  // Find the beginning of each operand group.\n  SmallVector<unsigned, 8> GroupIdx;\n  unsigned OpIdxGroup = ~0u;\n  unsigned NumOps;\n  for (unsigned i = InlineAsm::MIOp_FirstOperand, e = getNumOperands(); i < e;\n       i += NumOps) {\n    const MachineOperand &FlagMO = getOperand(i);\n    assert(FlagMO.isImm() && \"Invalid tied operand on inline asm\");\n    unsigned CurGroup = GroupIdx.size();\n    GroupIdx.push_back(i);\n    NumOps = 1 + InlineAsm::getNumOperandRegisters(FlagMO.getImm());\n    // OpIdx belongs to this operand group.\n    if (OpIdx > i && OpIdx < i + NumOps)\n      OpIdxGroup = CurGroup;\n    unsigned TiedGroup;\n    if (!InlineAsm::isUseOperandTiedToDef(FlagMO.getImm(), TiedGroup))\n      continue;\n    // Operands in this group are tied to operands in TiedGroup which must be\n    // earlier. Find the number of operands between the two groups.\n    unsigned Delta = i - GroupIdx[TiedGroup];\n\n    // OpIdx is a use tied to TiedGroup.\n    if (OpIdxGroup == CurGroup)\n      return OpIdx - Delta;\n\n    // OpIdx is a def tied to this use group.\n    if (OpIdxGroup == TiedGroup)\n      return OpIdx + Delta;\n  }\n  llvm_unreachable(\"Invalid tied operand on inline asm\");\n}\n\n/// clearKillInfo - Clears kill flags on all operands.\n///\nvoid MachineInstr::clearKillInfo() {\n  for (MachineOperand &MO : operands()) {\n    if (MO.isReg() && MO.isUse())\n      MO.setIsKill(false);\n  }\n}\n\nvoid MachineInstr::substituteRegister(Register FromReg, Register ToReg,\n                                      unsigned SubIdx,\n                                      const TargetRegisterInfo &RegInfo) {\n  if (Register::isPhysicalRegister(ToReg)) {\n    if (SubIdx)\n      ToReg = RegInfo.getSubReg(ToReg, SubIdx);\n    for (MachineOperand &MO : operands()) {\n      if (!MO.isReg() || MO.getReg() != FromReg)\n        continue;\n      MO.substPhysReg(ToReg, RegInfo);\n    }\n  } else {\n    for (MachineOperand &MO : operands()) {\n      if (!MO.isReg() || MO.getReg() != FromReg)\n        continue;\n      MO.substVirtReg(ToReg, SubIdx, RegInfo);\n    }\n  }\n}\n\n/// isSafeToMove - Return true if it is safe to move this instruction. If\n/// SawStore is set to true, it means that there is a store (or call) between\n/// the instruction's location and its intended destination.\nbool MachineInstr::isSafeToMove(AAResults *AA, bool &SawStore) const {\n  // Ignore stuff that we obviously can't move.\n  //\n  // Treat volatile loads as stores. This is not strictly necessary for\n  // volatiles, but it is required for atomic loads. It is not allowed to move\n  // a load across an atomic load with Ordering > Monotonic.\n  if (mayStore() || isCall() || isPHI() ||\n      (mayLoad() && hasOrderedMemoryRef())) {\n    SawStore = true;\n    return false;\n  }\n\n  if (isPosition() || isDebugInstr() || isTerminator() ||\n      mayRaiseFPException() || hasUnmodeledSideEffects())\n    return false;\n\n  // See if this instruction does a load.  If so, we have to guarantee that the\n  // loaded value doesn't change between the load and the its intended\n  // destination. The check for isInvariantLoad gives the target the chance to\n  // classify the load as always returning a constant, e.g. a constant pool\n  // load.\n  if (mayLoad() && !isDereferenceableInvariantLoad(AA))\n    // Otherwise, this is a real load.  If there is a store between the load and\n    // end of block, we can't move it.\n    return !SawStore;\n\n  return true;\n}\n\nstatic bool MemOperandsHaveAlias(const MachineFrameInfo &MFI, AAResults *AA,\n                                 bool UseTBAA, const MachineMemOperand *MMOa,\n                                 const MachineMemOperand *MMOb) {\n  // The following interface to AA is fashioned after DAGCombiner::isAlias and\n  // operates with MachineMemOperand offset with some important assumptions:\n  //   - LLVM fundamentally assumes flat address spaces.\n  //   - MachineOperand offset can *only* result from legalization and cannot\n  //     affect queries other than the trivial case of overlap checking.\n  //   - These offsets never wrap and never step outside of allocated objects.\n  //   - There should never be any negative offsets here.\n  //\n  // FIXME: Modify API to hide this math from \"user\"\n  // Even before we go to AA we can reason locally about some memory objects. It\n  // can save compile time, and possibly catch some corner cases not currently\n  // covered.\n\n  int64_t OffsetA = MMOa->getOffset();\n  int64_t OffsetB = MMOb->getOffset();\n  int64_t MinOffset = std::min(OffsetA, OffsetB);\n\n  uint64_t WidthA = MMOa->getSize();\n  uint64_t WidthB = MMOb->getSize();\n  bool KnownWidthA = WidthA != MemoryLocation::UnknownSize;\n  bool KnownWidthB = WidthB != MemoryLocation::UnknownSize;\n\n  const Value *ValA = MMOa->getValue();\n  const Value *ValB = MMOb->getValue();\n  bool SameVal = (ValA && ValB && (ValA == ValB));\n  if (!SameVal) {\n    const PseudoSourceValue *PSVa = MMOa->getPseudoValue();\n    const PseudoSourceValue *PSVb = MMOb->getPseudoValue();\n    if (PSVa && ValB && !PSVa->mayAlias(&MFI))\n      return false;\n    if (PSVb && ValA && !PSVb->mayAlias(&MFI))\n      return false;\n    if (PSVa && PSVb && (PSVa == PSVb))\n      SameVal = true;\n  }\n\n  if (SameVal) {\n    if (!KnownWidthA || !KnownWidthB)\n      return true;\n    int64_t MaxOffset = std::max(OffsetA, OffsetB);\n    int64_t LowWidth = (MinOffset == OffsetA) ? WidthA : WidthB;\n    return (MinOffset + LowWidth > MaxOffset);\n  }\n\n  if (!AA)\n    return true;\n\n  if (!ValA || !ValB)\n    return true;\n\n  assert((OffsetA >= 0) && \"Negative MachineMemOperand offset\");\n  assert((OffsetB >= 0) && \"Negative MachineMemOperand offset\");\n\n  int64_t OverlapA =\n      KnownWidthA ? WidthA + OffsetA - MinOffset : MemoryLocation::UnknownSize;\n  int64_t OverlapB =\n      KnownWidthB ? WidthB + OffsetB - MinOffset : MemoryLocation::UnknownSize;\n\n  AliasResult AAResult = AA->alias(\n      MemoryLocation(ValA, OverlapA, UseTBAA ? MMOa->getAAInfo() : AAMDNodes()),\n      MemoryLocation(ValB, OverlapB,\n                     UseTBAA ? MMOb->getAAInfo() : AAMDNodes()));\n\n  return (AAResult != NoAlias);\n}\n\nbool MachineInstr::mayAlias(AAResults *AA, const MachineInstr &Other,\n                            bool UseTBAA) const {\n  const MachineFunction *MF = getMF();\n  const TargetInstrInfo *TII = MF->getSubtarget().getInstrInfo();\n  const MachineFrameInfo &MFI = MF->getFrameInfo();\n\n  // Exclude call instruction which may alter the memory but can not be handled\n  // by this function.\n  if (isCall() || Other.isCall())\n    return true;\n\n  // If neither instruction stores to memory, they can't alias in any\n  // meaningful way, even if they read from the same address.\n  if (!mayStore() && !Other.mayStore())\n    return false;\n\n  // Both instructions must be memory operations to be able to alias.\n  if (!mayLoadOrStore() || !Other.mayLoadOrStore())\n    return false;\n\n  // Let the target decide if memory accesses cannot possibly overlap.\n  if (TII->areMemAccessesTriviallyDisjoint(*this, Other))\n    return false;\n\n  // Memory operations without memory operands may access anything. Be\n  // conservative and assume `MayAlias`.\n  if (memoperands_empty() || Other.memoperands_empty())\n    return true;\n\n  // Skip if there are too many memory operands.\n  auto NumChecks = getNumMemOperands() * Other.getNumMemOperands();\n  if (NumChecks > TII->getMemOperandAACheckLimit())\n    return true;\n\n  // Check each pair of memory operands from both instructions, which can't\n  // alias only if all pairs won't alias.\n  for (auto *MMOa : memoperands())\n    for (auto *MMOb : Other.memoperands())\n      if (MemOperandsHaveAlias(MFI, AA, UseTBAA, MMOa, MMOb))\n        return true;\n\n  return false;\n}\n\n/// hasOrderedMemoryRef - Return true if this instruction may have an ordered\n/// or volatile memory reference, or if the information describing the memory\n/// reference is not available. Return false if it is known to have no ordered\n/// memory references.\nbool MachineInstr::hasOrderedMemoryRef() const {\n  // An instruction known never to access memory won't have a volatile access.\n  if (!mayStore() &&\n      !mayLoad() &&\n      !isCall() &&\n      !hasUnmodeledSideEffects())\n    return false;\n\n  // Otherwise, if the instruction has no memory reference information,\n  // conservatively assume it wasn't preserved.\n  if (memoperands_empty())\n    return true;\n\n  // Check if any of our memory operands are ordered.\n  return llvm::any_of(memoperands(), [](const MachineMemOperand *MMO) {\n    return !MMO->isUnordered();\n  });\n}\n\n/// isDereferenceableInvariantLoad - Return true if this instruction will never\n/// trap and is loading from a location whose value is invariant across a run of\n/// this function.\nbool MachineInstr::isDereferenceableInvariantLoad(AAResults *AA) const {\n  // If the instruction doesn't load at all, it isn't an invariant load.\n  if (!mayLoad())\n    return false;\n\n  // If the instruction has lost its memoperands, conservatively assume that\n  // it may not be an invariant load.\n  if (memoperands_empty())\n    return false;\n\n  const MachineFrameInfo &MFI = getParent()->getParent()->getFrameInfo();\n\n  for (MachineMemOperand *MMO : memoperands()) {\n    if (!MMO->isUnordered())\n      // If the memory operand has ordering side effects, we can't move the\n      // instruction.  Such an instruction is technically an invariant load,\n      // but the caller code would need updated to expect that.\n      return false;\n    if (MMO->isStore()) return false;\n    if (MMO->isInvariant() && MMO->isDereferenceable())\n      continue;\n\n    // A load from a constant PseudoSourceValue is invariant.\n    if (const PseudoSourceValue *PSV = MMO->getPseudoValue())\n      if (PSV->isConstant(&MFI))\n        continue;\n\n    if (const Value *V = MMO->getValue()) {\n      // If we have an AliasAnalysis, ask it whether the memory is constant.\n      if (AA &&\n          AA->pointsToConstantMemory(\n              MemoryLocation(V, MMO->getSize(), MMO->getAAInfo())))\n        continue;\n    }\n\n    // Otherwise assume conservatively.\n    return false;\n  }\n\n  // Everything checks out.\n  return true;\n}\n\n/// isConstantValuePHI - If the specified instruction is a PHI that always\n/// merges together the same virtual register, return the register, otherwise\n/// return 0.\nunsigned MachineInstr::isConstantValuePHI() const {\n  if (!isPHI())\n    return 0;\n  assert(getNumOperands() >= 3 &&\n         \"It's illegal to have a PHI without source operands\");\n\n  Register Reg = getOperand(1).getReg();\n  for (unsigned i = 3, e = getNumOperands(); i < e; i += 2)\n    if (getOperand(i).getReg() != Reg)\n      return 0;\n  return Reg;\n}\n\nbool MachineInstr::hasUnmodeledSideEffects() const {\n  if (hasProperty(MCID::UnmodeledSideEffects))\n    return true;\n  if (isInlineAsm()) {\n    unsigned ExtraInfo = getOperand(InlineAsm::MIOp_ExtraInfo).getImm();\n    if (ExtraInfo & InlineAsm::Extra_HasSideEffects)\n      return true;\n  }\n\n  return false;\n}\n\nbool MachineInstr::isLoadFoldBarrier() const {\n  return mayStore() || isCall() ||\n         (hasUnmodeledSideEffects() && !isPseudoProbe());\n}\n\n/// allDefsAreDead - Return true if all the defs of this instruction are dead.\n///\nbool MachineInstr::allDefsAreDead() const {\n  for (const MachineOperand &MO : operands()) {\n    if (!MO.isReg() || MO.isUse())\n      continue;\n    if (!MO.isDead())\n      return false;\n  }\n  return true;\n}\n\n/// copyImplicitOps - Copy implicit register operands from specified\n/// instruction to this instruction.\nvoid MachineInstr::copyImplicitOps(MachineFunction &MF,\n                                   const MachineInstr &MI) {\n  for (unsigned i = MI.getDesc().getNumOperands(), e = MI.getNumOperands();\n       i != e; ++i) {\n    const MachineOperand &MO = MI.getOperand(i);\n    if ((MO.isReg() && MO.isImplicit()) || MO.isRegMask())\n      addOperand(MF, MO);\n  }\n}\n\nbool MachineInstr::hasComplexRegisterTies() const {\n  const MCInstrDesc &MCID = getDesc();\n  if (MCID.Opcode == TargetOpcode::STATEPOINT)\n    return true;\n  for (unsigned I = 0, E = getNumOperands(); I < E; ++I) {\n    const auto &Operand = getOperand(I);\n    if (!Operand.isReg() || Operand.isDef())\n      // Ignore the defined registers as MCID marks only the uses as tied.\n      continue;\n    int ExpectedTiedIdx = MCID.getOperandConstraint(I, MCOI::TIED_TO);\n    int TiedIdx = Operand.isTied() ? int(findTiedOperandIdx(I)) : -1;\n    if (ExpectedTiedIdx != TiedIdx)\n      return true;\n  }\n  return false;\n}\n\nLLT MachineInstr::getTypeToPrint(unsigned OpIdx, SmallBitVector &PrintedTypes,\n                                 const MachineRegisterInfo &MRI) const {\n  const MachineOperand &Op = getOperand(OpIdx);\n  if (!Op.isReg())\n    return LLT{};\n\n  if (isVariadic() || OpIdx >= getNumExplicitOperands())\n    return MRI.getType(Op.getReg());\n\n  auto &OpInfo = getDesc().OpInfo[OpIdx];\n  if (!OpInfo.isGenericType())\n    return MRI.getType(Op.getReg());\n\n  if (PrintedTypes[OpInfo.getGenericTypeIndex()])\n    return LLT{};\n\n  LLT TypeToPrint = MRI.getType(Op.getReg());\n  // Don't mark the type index printed if it wasn't actually printed: maybe\n  // another operand with the same type index has an actual type attached:\n  if (TypeToPrint.isValid())\n    PrintedTypes.set(OpInfo.getGenericTypeIndex());\n  return TypeToPrint;\n}\n\n#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)\nLLVM_DUMP_METHOD void MachineInstr::dump() const {\n  dbgs() << \"  \";\n  print(dbgs());\n}\n\nLLVM_DUMP_METHOD void MachineInstr::dumprImpl(\n    const MachineRegisterInfo &MRI, unsigned Depth, unsigned MaxDepth,\n    SmallPtrSetImpl<const MachineInstr *> &AlreadySeenInstrs) const {\n  if (Depth >= MaxDepth)\n    return;\n  if (!AlreadySeenInstrs.insert(this).second)\n    return;\n  // PadToColumn always inserts at least one space.\n  // Don't mess up the alignment if we don't want any space.\n  if (Depth)\n    fdbgs().PadToColumn(Depth * 2);\n  print(fdbgs());\n  for (const MachineOperand &MO : operands()) {\n    if (!MO.isReg() || MO.isDef())\n      continue;\n    Register Reg = MO.getReg();\n    if (Reg.isPhysical())\n      continue;\n    const MachineInstr *NewMI = MRI.getUniqueVRegDef(Reg);\n    if (NewMI == nullptr)\n      continue;\n    NewMI->dumprImpl(MRI, Depth + 1, MaxDepth, AlreadySeenInstrs);\n  }\n}\n\nLLVM_DUMP_METHOD void MachineInstr::dumpr(const MachineRegisterInfo &MRI,\n                                          unsigned MaxDepth) const {\n  SmallPtrSet<const MachineInstr *, 16> AlreadySeenInstrs;\n  dumprImpl(MRI, 0, MaxDepth, AlreadySeenInstrs);\n}\n#endif\n\nvoid MachineInstr::print(raw_ostream &OS, bool IsStandalone, bool SkipOpers,\n                         bool SkipDebugLoc, bool AddNewLine,\n                         const TargetInstrInfo *TII) const {\n  const Module *M = nullptr;\n  const Function *F = nullptr;\n  if (const MachineFunction *MF = getMFIfAvailable(*this)) {\n    F = &MF->getFunction();\n    M = F->getParent();\n    if (!TII)\n      TII = MF->getSubtarget().getInstrInfo();\n  }\n\n  ModuleSlotTracker MST(M);\n  if (F)\n    MST.incorporateFunction(*F);\n  print(OS, MST, IsStandalone, SkipOpers, SkipDebugLoc, AddNewLine, TII);\n}\n\nvoid MachineInstr::print(raw_ostream &OS, ModuleSlotTracker &MST,\n                         bool IsStandalone, bool SkipOpers, bool SkipDebugLoc,\n                         bool AddNewLine, const TargetInstrInfo *TII) const {\n  // We can be a bit tidier if we know the MachineFunction.\n  const TargetRegisterInfo *TRI = nullptr;\n  const MachineRegisterInfo *MRI = nullptr;\n  const TargetIntrinsicInfo *IntrinsicInfo = nullptr;\n  tryToGetTargetInfo(*this, TRI, MRI, IntrinsicInfo, TII);\n\n  if (isCFIInstruction())\n    assert(getNumOperands() == 1 && \"Expected 1 operand in CFI instruction\");\n\n  SmallBitVector PrintedTypes(8);\n  bool ShouldPrintRegisterTies = IsStandalone || hasComplexRegisterTies();\n  auto getTiedOperandIdx = [&](unsigned OpIdx) {\n    if (!ShouldPrintRegisterTies)\n      return 0U;\n    const MachineOperand &MO = getOperand(OpIdx);\n    if (MO.isReg() && MO.isTied() && !MO.isDef())\n      return findTiedOperandIdx(OpIdx);\n    return 0U;\n  };\n  unsigned StartOp = 0;\n  unsigned e = getNumOperands();\n\n  // Print explicitly defined operands on the left of an assignment syntax.\n  while (StartOp < e) {\n    const MachineOperand &MO = getOperand(StartOp);\n    if (!MO.isReg() || !MO.isDef() || MO.isImplicit())\n      break;\n\n    if (StartOp != 0)\n      OS << \", \";\n\n    LLT TypeToPrint = MRI ? getTypeToPrint(StartOp, PrintedTypes, *MRI) : LLT{};\n    unsigned TiedOperandIdx = getTiedOperandIdx(StartOp);\n    MO.print(OS, MST, TypeToPrint, StartOp, /*PrintDef=*/false, IsStandalone,\n             ShouldPrintRegisterTies, TiedOperandIdx, TRI, IntrinsicInfo);\n    ++StartOp;\n  }\n\n  if (StartOp != 0)\n    OS << \" = \";\n\n  if (getFlag(MachineInstr::FrameSetup))\n    OS << \"frame-setup \";\n  if (getFlag(MachineInstr::FrameDestroy))\n    OS << \"frame-destroy \";\n  if (getFlag(MachineInstr::FmNoNans))\n    OS << \"nnan \";\n  if (getFlag(MachineInstr::FmNoInfs))\n    OS << \"ninf \";\n  if (getFlag(MachineInstr::FmNsz))\n    OS << \"nsz \";\n  if (getFlag(MachineInstr::FmArcp))\n    OS << \"arcp \";\n  if (getFlag(MachineInstr::FmContract))\n    OS << \"contract \";\n  if (getFlag(MachineInstr::FmAfn))\n    OS << \"afn \";\n  if (getFlag(MachineInstr::FmReassoc))\n    OS << \"reassoc \";\n  if (getFlag(MachineInstr::NoUWrap))\n    OS << \"nuw \";\n  if (getFlag(MachineInstr::NoSWrap))\n    OS << \"nsw \";\n  if (getFlag(MachineInstr::IsExact))\n    OS << \"exact \";\n  if (getFlag(MachineInstr::NoFPExcept))\n    OS << \"nofpexcept \";\n  if (getFlag(MachineInstr::NoMerge))\n    OS << \"nomerge \";\n\n  // Print the opcode name.\n  if (TII)\n    OS << TII->getName(getOpcode());\n  else\n    OS << \"UNKNOWN\";\n\n  if (SkipOpers)\n    return;\n\n  // Print the rest of the operands.\n  bool FirstOp = true;\n  unsigned AsmDescOp = ~0u;\n  unsigned AsmOpCount = 0;\n\n  if (isInlineAsm() && e >= InlineAsm::MIOp_FirstOperand) {\n    // Print asm string.\n    OS << \" \";\n    const unsigned OpIdx = InlineAsm::MIOp_AsmString;\n    LLT TypeToPrint = MRI ? getTypeToPrint(OpIdx, PrintedTypes, *MRI) : LLT{};\n    unsigned TiedOperandIdx = getTiedOperandIdx(OpIdx);\n    getOperand(OpIdx).print(OS, MST, TypeToPrint, OpIdx, /*PrintDef=*/true, IsStandalone,\n                            ShouldPrintRegisterTies, TiedOperandIdx, TRI,\n                            IntrinsicInfo);\n\n    // Print HasSideEffects, MayLoad, MayStore, IsAlignStack\n    unsigned ExtraInfo = getOperand(InlineAsm::MIOp_ExtraInfo).getImm();\n    if (ExtraInfo & InlineAsm::Extra_HasSideEffects)\n      OS << \" [sideeffect]\";\n    if (ExtraInfo & InlineAsm::Extra_MayLoad)\n      OS << \" [mayload]\";\n    if (ExtraInfo & InlineAsm::Extra_MayStore)\n      OS << \" [maystore]\";\n    if (ExtraInfo & InlineAsm::Extra_IsConvergent)\n      OS << \" [isconvergent]\";\n    if (ExtraInfo & InlineAsm::Extra_IsAlignStack)\n      OS << \" [alignstack]\";\n    if (getInlineAsmDialect() == InlineAsm::AD_ATT)\n      OS << \" [attdialect]\";\n    if (getInlineAsmDialect() == InlineAsm::AD_Intel)\n      OS << \" [inteldialect]\";\n\n    StartOp = AsmDescOp = InlineAsm::MIOp_FirstOperand;\n    FirstOp = false;\n  }\n\n  for (unsigned i = StartOp, e = getNumOperands(); i != e; ++i) {\n    const MachineOperand &MO = getOperand(i);\n\n    if (FirstOp) FirstOp = false; else OS << \",\";\n    OS << \" \";\n\n    if (isDebugValue() && MO.isMetadata()) {\n      // Pretty print DBG_VALUE instructions.\n      auto *DIV = dyn_cast<DILocalVariable>(MO.getMetadata());\n      if (DIV && !DIV->getName().empty())\n        OS << \"!\\\"\" << DIV->getName() << '\\\"';\n      else {\n        LLT TypeToPrint = MRI ? getTypeToPrint(i, PrintedTypes, *MRI) : LLT{};\n        unsigned TiedOperandIdx = getTiedOperandIdx(i);\n        MO.print(OS, MST, TypeToPrint, i, /*PrintDef=*/true, IsStandalone,\n                 ShouldPrintRegisterTies, TiedOperandIdx, TRI, IntrinsicInfo);\n      }\n    } else if (isDebugLabel() && MO.isMetadata()) {\n      // Pretty print DBG_LABEL instructions.\n      auto *DIL = dyn_cast<DILabel>(MO.getMetadata());\n      if (DIL && !DIL->getName().empty())\n        OS << \"\\\"\" << DIL->getName() << '\\\"';\n      else {\n        LLT TypeToPrint = MRI ? getTypeToPrint(i, PrintedTypes, *MRI) : LLT{};\n        unsigned TiedOperandIdx = getTiedOperandIdx(i);\n        MO.print(OS, MST, TypeToPrint, i, /*PrintDef=*/true, IsStandalone,\n                 ShouldPrintRegisterTies, TiedOperandIdx, TRI, IntrinsicInfo);\n      }\n    } else if (i == AsmDescOp && MO.isImm()) {\n      // Pretty print the inline asm operand descriptor.\n      OS << '$' << AsmOpCount++;\n      unsigned Flag = MO.getImm();\n      OS << \":[\";\n      OS << InlineAsm::getKindName(InlineAsm::getKind(Flag));\n\n      unsigned RCID = 0;\n      if (!InlineAsm::isImmKind(Flag) && !InlineAsm::isMemKind(Flag) &&\n          InlineAsm::hasRegClassConstraint(Flag, RCID)) {\n        if (TRI) {\n          OS << ':' << TRI->getRegClassName(TRI->getRegClass(RCID));\n        } else\n          OS << \":RC\" << RCID;\n      }\n\n      if (InlineAsm::isMemKind(Flag)) {\n        unsigned MCID = InlineAsm::getMemoryConstraintID(Flag);\n        OS << \":\" << InlineAsm::getMemConstraintName(MCID);\n      }\n\n      unsigned TiedTo = 0;\n      if (InlineAsm::isUseOperandTiedToDef(Flag, TiedTo))\n        OS << \" tiedto:$\" << TiedTo;\n\n      OS << ']';\n\n      // Compute the index of the next operand descriptor.\n      AsmDescOp += 1 + InlineAsm::getNumOperandRegisters(Flag);\n    } else {\n      LLT TypeToPrint = MRI ? getTypeToPrint(i, PrintedTypes, *MRI) : LLT{};\n      unsigned TiedOperandIdx = getTiedOperandIdx(i);\n      if (MO.isImm() && isOperandSubregIdx(i))\n        MachineOperand::printSubRegIdx(OS, MO.getImm(), TRI);\n      else\n        MO.print(OS, MST, TypeToPrint, i, /*PrintDef=*/true, IsStandalone,\n                 ShouldPrintRegisterTies, TiedOperandIdx, TRI, IntrinsicInfo);\n    }\n  }\n\n  // Print any optional symbols attached to this instruction as-if they were\n  // operands.\n  if (MCSymbol *PreInstrSymbol = getPreInstrSymbol()) {\n    if (!FirstOp) {\n      FirstOp = false;\n      OS << ',';\n    }\n    OS << \" pre-instr-symbol \";\n    MachineOperand::printSymbol(OS, *PreInstrSymbol);\n  }\n  if (MCSymbol *PostInstrSymbol = getPostInstrSymbol()) {\n    if (!FirstOp) {\n      FirstOp = false;\n      OS << ',';\n    }\n    OS << \" post-instr-symbol \";\n    MachineOperand::printSymbol(OS, *PostInstrSymbol);\n  }\n  if (MDNode *HeapAllocMarker = getHeapAllocMarker()) {\n    if (!FirstOp) {\n      FirstOp = false;\n      OS << ',';\n    }\n    OS << \" heap-alloc-marker \";\n    HeapAllocMarker->printAsOperand(OS, MST);\n  }\n\n  if (DebugInstrNum) {\n    if (!FirstOp)\n      OS << \",\";\n    OS << \" debug-instr-number \" << DebugInstrNum;\n  }\n\n  if (!SkipDebugLoc) {\n    if (const DebugLoc &DL = getDebugLoc()) {\n      if (!FirstOp)\n        OS << ',';\n      OS << \" debug-location \";\n      DL->printAsOperand(OS, MST);\n    }\n  }\n\n  if (!memoperands_empty()) {\n    SmallVector<StringRef, 0> SSNs;\n    const LLVMContext *Context = nullptr;\n    std::unique_ptr<LLVMContext> CtxPtr;\n    const MachineFrameInfo *MFI = nullptr;\n    if (const MachineFunction *MF = getMFIfAvailable(*this)) {\n      MFI = &MF->getFrameInfo();\n      Context = &MF->getFunction().getContext();\n    } else {\n      CtxPtr = std::make_unique<LLVMContext>();\n      Context = CtxPtr.get();\n    }\n\n    OS << \" :: \";\n    bool NeedComma = false;\n    for (const MachineMemOperand *Op : memoperands()) {\n      if (NeedComma)\n        OS << \", \";\n      Op->print(OS, MST, SSNs, *Context, MFI, TII);\n      NeedComma = true;\n    }\n  }\n\n  if (SkipDebugLoc)\n    return;\n\n  bool HaveSemi = false;\n\n  // Print debug location information.\n  if (const DebugLoc &DL = getDebugLoc()) {\n    if (!HaveSemi) {\n      OS << ';';\n      HaveSemi = true;\n    }\n    OS << ' ';\n    DL.print(OS);\n  }\n\n  // Print extra comments for DEBUG_VALUE.\n  if (isDebugValue() && getDebugVariableOp().isMetadata()) {\n    if (!HaveSemi) {\n      OS << \";\";\n      HaveSemi = true;\n    }\n    auto *DV = getDebugVariable();\n    OS << \" line no:\" <<  DV->getLine();\n    if (isIndirectDebugValue())\n      OS << \" indirect\";\n  }\n  // TODO: DBG_LABEL\n\n  if (AddNewLine)\n    OS << '\\n';\n}\n\nbool MachineInstr::addRegisterKilled(Register IncomingReg,\n                                     const TargetRegisterInfo *RegInfo,\n                                     bool AddIfNotFound) {\n  bool isPhysReg = Register::isPhysicalRegister(IncomingReg);\n  bool hasAliases = isPhysReg &&\n    MCRegAliasIterator(IncomingReg, RegInfo, false).isValid();\n  bool Found = false;\n  SmallVector<unsigned,4> DeadOps;\n  for (unsigned i = 0, e = getNumOperands(); i != e; ++i) {\n    MachineOperand &MO = getOperand(i);\n    if (!MO.isReg() || !MO.isUse() || MO.isUndef())\n      continue;\n\n    // DEBUG_VALUE nodes do not contribute to code generation and should\n    // always be ignored. Failure to do so may result in trying to modify\n    // KILL flags on DEBUG_VALUE nodes.\n    if (MO.isDebug())\n      continue;\n\n    Register Reg = MO.getReg();\n    if (!Reg)\n      continue;\n\n    if (Reg == IncomingReg) {\n      if (!Found) {\n        if (MO.isKill())\n          // The register is already marked kill.\n          return true;\n        if (isPhysReg && isRegTiedToDefOperand(i))\n          // Two-address uses of physregs must not be marked kill.\n          return true;\n        MO.setIsKill();\n        Found = true;\n      }\n    } else if (hasAliases && MO.isKill() && Register::isPhysicalRegister(Reg)) {\n      // A super-register kill already exists.\n      if (RegInfo->isSuperRegister(IncomingReg, Reg))\n        return true;\n      if (RegInfo->isSubRegister(IncomingReg, Reg))\n        DeadOps.push_back(i);\n    }\n  }\n\n  // Trim unneeded kill operands.\n  while (!DeadOps.empty()) {\n    unsigned OpIdx = DeadOps.back();\n    if (getOperand(OpIdx).isImplicit() &&\n        (!isInlineAsm() || findInlineAsmFlagIdx(OpIdx) < 0))\n      RemoveOperand(OpIdx);\n    else\n      getOperand(OpIdx).setIsKill(false);\n    DeadOps.pop_back();\n  }\n\n  // If not found, this means an alias of one of the operands is killed. Add a\n  // new implicit operand if required.\n  if (!Found && AddIfNotFound) {\n    addOperand(MachineOperand::CreateReg(IncomingReg,\n                                         false /*IsDef*/,\n                                         true  /*IsImp*/,\n                                         true  /*IsKill*/));\n    return true;\n  }\n  return Found;\n}\n\nvoid MachineInstr::clearRegisterKills(Register Reg,\n                                      const TargetRegisterInfo *RegInfo) {\n  if (!Register::isPhysicalRegister(Reg))\n    RegInfo = nullptr;\n  for (MachineOperand &MO : operands()) {\n    if (!MO.isReg() || !MO.isUse() || !MO.isKill())\n      continue;\n    Register OpReg = MO.getReg();\n    if ((RegInfo && RegInfo->regsOverlap(Reg, OpReg)) || Reg == OpReg)\n      MO.setIsKill(false);\n  }\n}\n\nbool MachineInstr::addRegisterDead(Register Reg,\n                                   const TargetRegisterInfo *RegInfo,\n                                   bool AddIfNotFound) {\n  bool isPhysReg = Register::isPhysicalRegister(Reg);\n  bool hasAliases = isPhysReg &&\n    MCRegAliasIterator(Reg, RegInfo, false).isValid();\n  bool Found = false;\n  SmallVector<unsigned,4> DeadOps;\n  for (unsigned i = 0, e = getNumOperands(); i != e; ++i) {\n    MachineOperand &MO = getOperand(i);\n    if (!MO.isReg() || !MO.isDef())\n      continue;\n    Register MOReg = MO.getReg();\n    if (!MOReg)\n      continue;\n\n    if (MOReg == Reg) {\n      MO.setIsDead();\n      Found = true;\n    } else if (hasAliases && MO.isDead() &&\n               Register::isPhysicalRegister(MOReg)) {\n      // There exists a super-register that's marked dead.\n      if (RegInfo->isSuperRegister(Reg, MOReg))\n        return true;\n      if (RegInfo->isSubRegister(Reg, MOReg))\n        DeadOps.push_back(i);\n    }\n  }\n\n  // Trim unneeded dead operands.\n  while (!DeadOps.empty()) {\n    unsigned OpIdx = DeadOps.back();\n    if (getOperand(OpIdx).isImplicit() &&\n        (!isInlineAsm() || findInlineAsmFlagIdx(OpIdx) < 0))\n      RemoveOperand(OpIdx);\n    else\n      getOperand(OpIdx).setIsDead(false);\n    DeadOps.pop_back();\n  }\n\n  // If not found, this means an alias of one of the operands is dead. Add a\n  // new implicit operand if required.\n  if (Found || !AddIfNotFound)\n    return Found;\n\n  addOperand(MachineOperand::CreateReg(Reg,\n                                       true  /*IsDef*/,\n                                       true  /*IsImp*/,\n                                       false /*IsKill*/,\n                                       true  /*IsDead*/));\n  return true;\n}\n\nvoid MachineInstr::clearRegisterDeads(Register Reg) {\n  for (MachineOperand &MO : operands()) {\n    if (!MO.isReg() || !MO.isDef() || MO.getReg() != Reg)\n      continue;\n    MO.setIsDead(false);\n  }\n}\n\nvoid MachineInstr::setRegisterDefReadUndef(Register Reg, bool IsUndef) {\n  for (MachineOperand &MO : operands()) {\n    if (!MO.isReg() || !MO.isDef() || MO.getReg() != Reg || MO.getSubReg() == 0)\n      continue;\n    MO.setIsUndef(IsUndef);\n  }\n}\n\nvoid MachineInstr::addRegisterDefined(Register Reg,\n                                      const TargetRegisterInfo *RegInfo) {\n  if (Register::isPhysicalRegister(Reg)) {\n    MachineOperand *MO = findRegisterDefOperand(Reg, false, false, RegInfo);\n    if (MO)\n      return;\n  } else {\n    for (const MachineOperand &MO : operands()) {\n      if (MO.isReg() && MO.getReg() == Reg && MO.isDef() &&\n          MO.getSubReg() == 0)\n        return;\n    }\n  }\n  addOperand(MachineOperand::CreateReg(Reg,\n                                       true  /*IsDef*/,\n                                       true  /*IsImp*/));\n}\n\nvoid MachineInstr::setPhysRegsDeadExcept(ArrayRef<Register> UsedRegs,\n                                         const TargetRegisterInfo &TRI) {\n  bool HasRegMask = false;\n  for (MachineOperand &MO : operands()) {\n    if (MO.isRegMask()) {\n      HasRegMask = true;\n      continue;\n    }\n    if (!MO.isReg() || !MO.isDef()) continue;\n    Register Reg = MO.getReg();\n    if (!Reg.isPhysical())\n      continue;\n    // If there are no uses, including partial uses, the def is dead.\n    if (llvm::none_of(UsedRegs,\n                      [&](MCRegister Use) { return TRI.regsOverlap(Use, Reg); }))\n      MO.setIsDead();\n  }\n\n  // This is a call with a register mask operand.\n  // Mask clobbers are always dead, so add defs for the non-dead defines.\n  if (HasRegMask)\n    for (ArrayRef<Register>::iterator I = UsedRegs.begin(), E = UsedRegs.end();\n         I != E; ++I)\n      addRegisterDefined(*I, &TRI);\n}\n\nunsigned\nMachineInstrExpressionTrait::getHashValue(const MachineInstr* const &MI) {\n  // Build up a buffer of hash code components.\n  SmallVector<size_t, 16> HashComponents;\n  HashComponents.reserve(MI->getNumOperands() + 1);\n  HashComponents.push_back(MI->getOpcode());\n  for (const MachineOperand &MO : MI->operands()) {\n    if (MO.isReg() && MO.isDef() && Register::isVirtualRegister(MO.getReg()))\n      continue;  // Skip virtual register defs.\n\n    HashComponents.push_back(hash_value(MO));\n  }\n  return hash_combine_range(HashComponents.begin(), HashComponents.end());\n}\n\nvoid MachineInstr::emitError(StringRef Msg) const {\n  // Find the source location cookie.\n  unsigned LocCookie = 0;\n  const MDNode *LocMD = nullptr;\n  for (unsigned i = getNumOperands(); i != 0; --i) {\n    if (getOperand(i-1).isMetadata() &&\n        (LocMD = getOperand(i-1).getMetadata()) &&\n        LocMD->getNumOperands() != 0) {\n      if (const ConstantInt *CI =\n              mdconst::dyn_extract<ConstantInt>(LocMD->getOperand(0))) {\n        LocCookie = CI->getZExtValue();\n        break;\n      }\n    }\n  }\n\n  if (const MachineBasicBlock *MBB = getParent())\n    if (const MachineFunction *MF = MBB->getParent())\n      return MF->getMMI().getModule()->getContext().emitError(LocCookie, Msg);\n  report_fatal_error(Msg);\n}\n\nMachineInstrBuilder llvm::BuildMI(MachineFunction &MF, const DebugLoc &DL,\n                                  const MCInstrDesc &MCID, bool IsIndirect,\n                                  Register Reg, const MDNode *Variable,\n                                  const MDNode *Expr) {\n  assert(isa<DILocalVariable>(Variable) && \"not a variable\");\n  assert(cast<DIExpression>(Expr)->isValid() && \"not an expression\");\n  assert(cast<DILocalVariable>(Variable)->isValidLocationForIntrinsic(DL) &&\n         \"Expected inlined-at fields to agree\");\n  auto MIB = BuildMI(MF, DL, MCID).addReg(Reg, RegState::Debug);\n  if (IsIndirect)\n    MIB.addImm(0U);\n  else\n    MIB.addReg(0U, RegState::Debug);\n  return MIB.addMetadata(Variable).addMetadata(Expr);\n}\n\nMachineInstrBuilder llvm::BuildMI(MachineFunction &MF, const DebugLoc &DL,\n                                  const MCInstrDesc &MCID, bool IsIndirect,\n                                  MachineOperand &MO, const MDNode *Variable,\n                                  const MDNode *Expr) {\n  assert(isa<DILocalVariable>(Variable) && \"not a variable\");\n  assert(cast<DIExpression>(Expr)->isValid() && \"not an expression\");\n  assert(cast<DILocalVariable>(Variable)->isValidLocationForIntrinsic(DL) &&\n         \"Expected inlined-at fields to agree\");\n  if (MO.isReg())\n    return BuildMI(MF, DL, MCID, IsIndirect, MO.getReg(), Variable, Expr);\n\n  auto MIB = BuildMI(MF, DL, MCID).add(MO);\n  if (IsIndirect)\n    MIB.addImm(0U);\n  else\n    MIB.addReg(0U, RegState::Debug);\n  return MIB.addMetadata(Variable).addMetadata(Expr);\n }\n\nMachineInstrBuilder llvm::BuildMI(MachineBasicBlock &BB,\n                                  MachineBasicBlock::iterator I,\n                                  const DebugLoc &DL, const MCInstrDesc &MCID,\n                                  bool IsIndirect, Register Reg,\n                                  const MDNode *Variable, const MDNode *Expr) {\n  MachineFunction &MF = *BB.getParent();\n  MachineInstr *MI = BuildMI(MF, DL, MCID, IsIndirect, Reg, Variable, Expr);\n  BB.insert(I, MI);\n  return MachineInstrBuilder(MF, MI);\n}\n\nMachineInstrBuilder llvm::BuildMI(MachineBasicBlock &BB,\n                                  MachineBasicBlock::iterator I,\n                                  const DebugLoc &DL, const MCInstrDesc &MCID,\n                                  bool IsIndirect, MachineOperand &MO,\n                                  const MDNode *Variable, const MDNode *Expr) {\n  MachineFunction &MF = *BB.getParent();\n  MachineInstr *MI = BuildMI(MF, DL, MCID, IsIndirect, MO, Variable, Expr);\n  BB.insert(I, MI);\n  return MachineInstrBuilder(MF, *MI);\n}\n\n/// Compute the new DIExpression to use with a DBG_VALUE for a spill slot.\n/// This prepends DW_OP_deref when spilling an indirect DBG_VALUE.\nstatic const DIExpression *computeExprForSpill(const MachineInstr &MI) {\n  assert(MI.getOperand(0).isReg() && \"can't spill non-register\");\n  assert(MI.getDebugVariable()->isValidLocationForIntrinsic(MI.getDebugLoc()) &&\n         \"Expected inlined-at fields to agree\");\n\n  const DIExpression *Expr = MI.getDebugExpression();\n  if (MI.isIndirectDebugValue()) {\n    assert(MI.getDebugOffset().getImm() == 0 &&\n           \"DBG_VALUE with nonzero offset\");\n    Expr = DIExpression::prepend(Expr, DIExpression::DerefBefore);\n  }\n  return Expr;\n}\n\nMachineInstr *llvm::buildDbgValueForSpill(MachineBasicBlock &BB,\n                                          MachineBasicBlock::iterator I,\n                                          const MachineInstr &Orig,\n                                          int FrameIndex) {\n  const DIExpression *Expr = computeExprForSpill(Orig);\n  return BuildMI(BB, I, Orig.getDebugLoc(), Orig.getDesc())\n      .addFrameIndex(FrameIndex)\n      .addImm(0U)\n      .addMetadata(Orig.getDebugVariable())\n      .addMetadata(Expr);\n}\n\nvoid llvm::updateDbgValueForSpill(MachineInstr &Orig, int FrameIndex) {\n  const DIExpression *Expr = computeExprForSpill(Orig);\n  Orig.getDebugOperand(0).ChangeToFrameIndex(FrameIndex);\n  Orig.getDebugOffset().ChangeToImmediate(0U);\n  Orig.getDebugExpressionOp().setMetadata(Expr);\n}\n\nvoid MachineInstr::collectDebugValues(\n                                SmallVectorImpl<MachineInstr *> &DbgValues) {\n  MachineInstr &MI = *this;\n  if (!MI.getOperand(0).isReg())\n    return;\n\n  MachineBasicBlock::iterator DI = MI; ++DI;\n  for (MachineBasicBlock::iterator DE = MI.getParent()->end();\n       DI != DE; ++DI) {\n    if (!DI->isDebugValue())\n      return;\n    if (DI->getDebugOperandForReg(MI.getOperand(0).getReg()))\n      DbgValues.push_back(&*DI);\n  }\n}\n\nvoid MachineInstr::changeDebugValuesDefReg(Register Reg) {\n  // Collect matching debug values.\n  SmallVector<MachineInstr *, 2> DbgValues;\n\n  if (!getOperand(0).isReg())\n    return;\n\n  Register DefReg = getOperand(0).getReg();\n  auto *MRI = getRegInfo();\n  for (auto &MO : MRI->use_operands(DefReg)) {\n    auto *DI = MO.getParent();\n    if (!DI->isDebugValue())\n      continue;\n    if (DI->getDebugOperandForReg(DefReg)) {\n      DbgValues.push_back(DI);\n    }\n  }\n\n  // Propagate Reg to debug value instructions.\n  for (auto *DBI : DbgValues)\n    DBI->getDebugOperandForReg(DefReg)->setReg(Reg);\n}\n\nusing MMOList = SmallVector<const MachineMemOperand *, 2>;\n\nstatic unsigned getSpillSlotSize(const MMOList &Accesses,\n                                 const MachineFrameInfo &MFI) {\n  unsigned Size = 0;\n  for (auto A : Accesses)\n    if (MFI.isSpillSlotObjectIndex(\n            cast<FixedStackPseudoSourceValue>(A->getPseudoValue())\n                ->getFrameIndex()))\n      Size += A->getSize();\n  return Size;\n}\n\nOptional<unsigned>\nMachineInstr::getSpillSize(const TargetInstrInfo *TII) const {\n  int FI;\n  if (TII->isStoreToStackSlotPostFE(*this, FI)) {\n    const MachineFrameInfo &MFI = getMF()->getFrameInfo();\n    if (MFI.isSpillSlotObjectIndex(FI))\n      return (*memoperands_begin())->getSize();\n  }\n  return None;\n}\n\nOptional<unsigned>\nMachineInstr::getFoldedSpillSize(const TargetInstrInfo *TII) const {\n  MMOList Accesses;\n  if (TII->hasStoreToStackSlot(*this, Accesses))\n    return getSpillSlotSize(Accesses, getMF()->getFrameInfo());\n  return None;\n}\n\nOptional<unsigned>\nMachineInstr::getRestoreSize(const TargetInstrInfo *TII) const {\n  int FI;\n  if (TII->isLoadFromStackSlotPostFE(*this, FI)) {\n    const MachineFrameInfo &MFI = getMF()->getFrameInfo();\n    if (MFI.isSpillSlotObjectIndex(FI))\n      return (*memoperands_begin())->getSize();\n  }\n  return None;\n}\n\nOptional<unsigned>\nMachineInstr::getFoldedRestoreSize(const TargetInstrInfo *TII) const {\n  MMOList Accesses;\n  if (TII->hasLoadFromStackSlot(*this, Accesses))\n    return getSpillSlotSize(Accesses, getMF()->getFrameInfo());\n  return None;\n}\n\nunsigned MachineInstr::getDebugInstrNum() {\n  if (DebugInstrNum == 0)\n    DebugInstrNum = getParent()->getParent()->getNewDebugInstrNum();\n  return DebugInstrNum;\n}\n"}, "1": {"id": 1, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h", "content": "//===- llvm/CodeGen/MachineInstr.h - MachineInstr class ---------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file contains the declaration of the MachineInstr class, which is the\n// basic representation for all target dependent machine instructions used by\n// the back end.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CODEGEN_MACHINEINSTR_H\n#define LLVM_CODEGEN_MACHINEINSTR_H\n\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/ADT/PointerSumType.h\"\n#include \"llvm/ADT/ilist.h\"\n#include \"llvm/ADT/ilist_node.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/CodeGen/MachineMemOperand.h\"\n#include \"llvm/CodeGen/MachineOperand.h\"\n#include \"llvm/CodeGen/TargetOpcodes.h\"\n#include \"llvm/IR/DebugLoc.h\"\n#include \"llvm/IR/InlineAsm.h\"\n#include \"llvm/MC/MCInstrDesc.h\"\n#include \"llvm/MC/MCSymbol.h\"\n#include \"llvm/Support/ArrayRecycler.h\"\n#include \"llvm/Support/TrailingObjects.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstdint>\n#include <utility>\n\nnamespace llvm {\n\nclass AAResults;\ntemplate <typename T> class ArrayRef;\nclass DIExpression;\nclass DILocalVariable;\nclass MachineBasicBlock;\nclass MachineFunction;\nclass MachineRegisterInfo;\nclass ModuleSlotTracker;\nclass raw_ostream;\ntemplate <typename T> class SmallVectorImpl;\nclass SmallBitVector;\nclass StringRef;\nclass TargetInstrInfo;\nclass TargetRegisterClass;\nclass TargetRegisterInfo;\n\n//===----------------------------------------------------------------------===//\n/// Representation of each machine instruction.\n///\n/// This class isn't a POD type, but it must have a trivial destructor. When a\n/// MachineFunction is deleted, all the contained MachineInstrs are deallocated\n/// without having their destructor called.\n///\nclass MachineInstr\n    : public ilist_node_with_parent<MachineInstr, MachineBasicBlock,\n                                    ilist_sentinel_tracking<true>> {\npublic:\n  using mmo_iterator = ArrayRef<MachineMemOperand *>::iterator;\n\n  /// Flags to specify different kinds of comments to output in\n  /// assembly code.  These flags carry semantic information not\n  /// otherwise easily derivable from the IR text.\n  ///\n  enum CommentFlag {\n    ReloadReuse = 0x1,    // higher bits are reserved for target dep comments.\n    NoSchedComment = 0x2,\n    TAsmComments = 0x4    // Target Asm comments should start from this value.\n  };\n\n  enum MIFlag {\n    NoFlags      = 0,\n    FrameSetup   = 1 << 0,              // Instruction is used as a part of\n                                        // function frame setup code.\n    FrameDestroy = 1 << 1,              // Instruction is used as a part of\n                                        // function frame destruction code.\n    BundledPred  = 1 << 2,              // Instruction has bundled predecessors.\n    BundledSucc  = 1 << 3,              // Instruction has bundled successors.\n    FmNoNans     = 1 << 4,              // Instruction does not support Fast\n                                        // math nan values.\n    FmNoInfs     = 1 << 5,              // Instruction does not support Fast\n                                        // math infinity values.\n    FmNsz        = 1 << 6,              // Instruction is not required to retain\n                                        // signed zero values.\n    FmArcp       = 1 << 7,              // Instruction supports Fast math\n                                        // reciprocal approximations.\n    FmContract   = 1 << 8,              // Instruction supports Fast math\n                                        // contraction operations like fma.\n    FmAfn        = 1 << 9,              // Instruction may map to Fast math\n                                        // instrinsic approximation.\n    FmReassoc    = 1 << 10,             // Instruction supports Fast math\n                                        // reassociation of operand order.\n    NoUWrap      = 1 << 11,             // Instruction supports binary operator\n                                        // no unsigned wrap.\n    NoSWrap      = 1 << 12,             // Instruction supports binary operator\n                                        // no signed wrap.\n    IsExact      = 1 << 13,             // Instruction supports division is\n                                        // known to be exact.\n    NoFPExcept   = 1 << 14,             // Instruction does not raise\n                                        // floatint-point exceptions.\n    NoMerge      = 1 << 15,             // Passes that drop source location info\n                                        // (e.g. branch folding) should skip\n                                        // this instruction.\n  };\n\nprivate:\n  const MCInstrDesc *MCID;              // Instruction descriptor.\n  MachineBasicBlock *Parent = nullptr;  // Pointer to the owning basic block.\n\n  // Operands are allocated by an ArrayRecycler.\n  MachineOperand *Operands = nullptr;   // Pointer to the first operand.\n  unsigned NumOperands = 0;             // Number of operands on instruction.\n\n  uint16_t Flags = 0;                   // Various bits of additional\n                                        // information about machine\n                                        // instruction.\n\n  uint8_t AsmPrinterFlags = 0;          // Various bits of information used by\n                                        // the AsmPrinter to emit helpful\n                                        // comments.  This is *not* semantic\n                                        // information.  Do not use this for\n                                        // anything other than to convey comment\n                                        // information to AsmPrinter.\n\n  // OperandCapacity has uint8_t size, so it should be next to AsmPrinterFlags\n  // to properly pack.\n  using OperandCapacity = ArrayRecycler<MachineOperand>::Capacity;\n  OperandCapacity CapOperands;          // Capacity of the Operands array.\n\n  /// Internal implementation detail class that provides out-of-line storage for\n  /// extra info used by the machine instruction when this info cannot be stored\n  /// in-line within the instruction itself.\n  ///\n  /// This has to be defined eagerly due to the implementation constraints of\n  /// `PointerSumType` where it is used.\n  class ExtraInfo final\n      : TrailingObjects<ExtraInfo, MachineMemOperand *, MCSymbol *, MDNode *> {\n  public:\n    static ExtraInfo *create(BumpPtrAllocator &Allocator,\n                             ArrayRef<MachineMemOperand *> MMOs,\n                             MCSymbol *PreInstrSymbol = nullptr,\n                             MCSymbol *PostInstrSymbol = nullptr,\n                             MDNode *HeapAllocMarker = nullptr) {\n      bool HasPreInstrSymbol = PreInstrSymbol != nullptr;\n      bool HasPostInstrSymbol = PostInstrSymbol != nullptr;\n      bool HasHeapAllocMarker = HeapAllocMarker != nullptr;\n      auto *Result = new (Allocator.Allocate(\n          totalSizeToAlloc<MachineMemOperand *, MCSymbol *, MDNode *>(\n              MMOs.size(), HasPreInstrSymbol + HasPostInstrSymbol,\n              HasHeapAllocMarker),\n          alignof(ExtraInfo)))\n          ExtraInfo(MMOs.size(), HasPreInstrSymbol, HasPostInstrSymbol,\n                    HasHeapAllocMarker);\n\n      // Copy the actual data into the trailing objects.\n      std::copy(MMOs.begin(), MMOs.end(),\n                Result->getTrailingObjects<MachineMemOperand *>());\n\n      if (HasPreInstrSymbol)\n        Result->getTrailingObjects<MCSymbol *>()[0] = PreInstrSymbol;\n      if (HasPostInstrSymbol)\n        Result->getTrailingObjects<MCSymbol *>()[HasPreInstrSymbol] =\n            PostInstrSymbol;\n      if (HasHeapAllocMarker)\n        Result->getTrailingObjects<MDNode *>()[0] = HeapAllocMarker;\n\n      return Result;\n    }\n\n    ArrayRef<MachineMemOperand *> getMMOs() const {\n      return makeArrayRef(getTrailingObjects<MachineMemOperand *>(), NumMMOs);\n    }\n\n    MCSymbol *getPreInstrSymbol() const {\n      return HasPreInstrSymbol ? getTrailingObjects<MCSymbol *>()[0] : nullptr;\n    }\n\n    MCSymbol *getPostInstrSymbol() const {\n      return HasPostInstrSymbol\n                 ? getTrailingObjects<MCSymbol *>()[HasPreInstrSymbol]\n                 : nullptr;\n    }\n\n    MDNode *getHeapAllocMarker() const {\n      return HasHeapAllocMarker ? getTrailingObjects<MDNode *>()[0] : nullptr;\n    }\n\n  private:\n    friend TrailingObjects;\n\n    // Description of the extra info, used to interpret the actual optional\n    // data appended.\n    //\n    // Note that this is not terribly space optimized. This leaves a great deal\n    // of flexibility to fit more in here later.\n    const int NumMMOs;\n    const bool HasPreInstrSymbol;\n    const bool HasPostInstrSymbol;\n    const bool HasHeapAllocMarker;\n\n    // Implement the `TrailingObjects` internal API.\n    size_t numTrailingObjects(OverloadToken<MachineMemOperand *>) const {\n      return NumMMOs;\n    }\n    size_t numTrailingObjects(OverloadToken<MCSymbol *>) const {\n      return HasPreInstrSymbol + HasPostInstrSymbol;\n    }\n    size_t numTrailingObjects(OverloadToken<MDNode *>) const {\n      return HasHeapAllocMarker;\n    }\n\n    // Just a boring constructor to allow us to initialize the sizes. Always use\n    // the `create` routine above.\n    ExtraInfo(int NumMMOs, bool HasPreInstrSymbol, bool HasPostInstrSymbol,\n              bool HasHeapAllocMarker)\n        : NumMMOs(NumMMOs), HasPreInstrSymbol(HasPreInstrSymbol),\n          HasPostInstrSymbol(HasPostInstrSymbol),\n          HasHeapAllocMarker(HasHeapAllocMarker) {}\n  };\n\n  /// Enumeration of the kinds of inline extra info available. It is important\n  /// that the `MachineMemOperand` inline kind has a tag value of zero to make\n  /// it accessible as an `ArrayRef`.\n  enum ExtraInfoInlineKinds {\n    EIIK_MMO = 0,\n    EIIK_PreInstrSymbol,\n    EIIK_PostInstrSymbol,\n    EIIK_OutOfLine\n  };\n\n  // We store extra information about the instruction here. The common case is\n  // expected to be nothing or a single pointer (typically a MMO or a symbol).\n  // We work to optimize this common case by storing it inline here rather than\n  // requiring a separate allocation, but we fall back to an allocation when\n  // multiple pointers are needed.\n  PointerSumType<ExtraInfoInlineKinds,\n                 PointerSumTypeMember<EIIK_MMO, MachineMemOperand *>,\n                 PointerSumTypeMember<EIIK_PreInstrSymbol, MCSymbol *>,\n                 PointerSumTypeMember<EIIK_PostInstrSymbol, MCSymbol *>,\n                 PointerSumTypeMember<EIIK_OutOfLine, ExtraInfo *>>\n      Info;\n\n  DebugLoc debugLoc;                    // Source line information.\n\n  /// Unique instruction number. Used by DBG_INSTR_REFs to refer to the values\n  /// defined by this instruction.\n  unsigned DebugInstrNum;\n\n  // Intrusive list support\n  friend struct ilist_traits<MachineInstr>;\n  friend struct ilist_callback_traits<MachineBasicBlock>;\n  void setParent(MachineBasicBlock *P) { Parent = P; }\n\n  /// This constructor creates a copy of the given\n  /// MachineInstr in the given MachineFunction.\n  MachineInstr(MachineFunction &, const MachineInstr &);\n\n  /// This constructor create a MachineInstr and add the implicit operands.\n  /// It reserves space for number of operands specified by\n  /// MCInstrDesc.  An explicit DebugLoc is supplied.\n  MachineInstr(MachineFunction &, const MCInstrDesc &tid, DebugLoc dl,\n               bool NoImp = false);\n\n  // MachineInstrs are pool-allocated and owned by MachineFunction.\n  friend class MachineFunction;\n\n  void\n  dumprImpl(const MachineRegisterInfo &MRI, unsigned Depth, unsigned MaxDepth,\n            SmallPtrSetImpl<const MachineInstr *> &AlreadySeenInstrs) const;\n\npublic:\n  MachineInstr(const MachineInstr &) = delete;\n  MachineInstr &operator=(const MachineInstr &) = delete;\n  // Use MachineFunction::DeleteMachineInstr() instead.\n  ~MachineInstr() = delete;\n\n  const MachineBasicBlock* getParent() const { return Parent; }\n  MachineBasicBlock* getParent() { return Parent; }\n\n  /// Move the instruction before \\p MovePos.\n  void moveBefore(MachineInstr *MovePos);\n\n  /// Return the function that contains the basic block that this instruction\n  /// belongs to.\n  ///\n  /// Note: this is undefined behaviour if the instruction does not have a\n  /// parent.\n  const MachineFunction *getMF() const;\n  MachineFunction *getMF() {\n    return const_cast<MachineFunction *>(\n        static_cast<const MachineInstr *>(this)->getMF());\n  }\n\n  /// Return the asm printer flags bitvector.\n  uint8_t getAsmPrinterFlags() const { return AsmPrinterFlags; }\n\n  /// Clear the AsmPrinter bitvector.\n  void clearAsmPrinterFlags() { AsmPrinterFlags = 0; }\n\n  /// Return whether an AsmPrinter flag is set.\n  bool getAsmPrinterFlag(CommentFlag Flag) const {\n    return AsmPrinterFlags & Flag;\n  }\n\n  /// Set a flag for the AsmPrinter.\n  void setAsmPrinterFlag(uint8_t Flag) {\n    AsmPrinterFlags |= Flag;\n  }\n\n  /// Clear specific AsmPrinter flags.\n  void clearAsmPrinterFlag(CommentFlag Flag) {\n    AsmPrinterFlags &= ~Flag;\n  }\n\n  /// Return the MI flags bitvector.\n  uint16_t getFlags() const {\n    return Flags;\n  }\n\n  /// Return whether an MI flag is set.\n  bool getFlag(MIFlag Flag) const {\n    return Flags & Flag;\n  }\n\n  /// Set a MI flag.\n  void setFlag(MIFlag Flag) {\n    Flags |= (uint16_t)Flag;\n  }\n\n  void setFlags(unsigned flags) {\n    // Filter out the automatically maintained flags.\n    unsigned Mask = BundledPred | BundledSucc;\n    Flags = (Flags & Mask) | (flags & ~Mask);\n  }\n\n  /// clearFlag - Clear a MI flag.\n  void clearFlag(MIFlag Flag) {\n    Flags &= ~((uint16_t)Flag);\n  }\n\n  /// Return true if MI is in a bundle (but not the first MI in a bundle).\n  ///\n  /// A bundle looks like this before it's finalized:\n  ///   ----------------\n  ///   |      MI      |\n  ///   ----------------\n  ///          |\n  ///   ----------------\n  ///   |      MI    * |\n  ///   ----------------\n  ///          |\n  ///   ----------------\n  ///   |      MI    * |\n  ///   ----------------\n  /// In this case, the first MI starts a bundle but is not inside a bundle, the\n  /// next 2 MIs are considered \"inside\" the bundle.\n  ///\n  /// After a bundle is finalized, it looks like this:\n  ///   ----------------\n  ///   |    Bundle    |\n  ///   ----------------\n  ///          |\n  ///   ----------------\n  ///   |      MI    * |\n  ///   ----------------\n  ///          |\n  ///   ----------------\n  ///   |      MI    * |\n  ///   ----------------\n  ///          |\n  ///   ----------------\n  ///   |      MI    * |\n  ///   ----------------\n  /// The first instruction has the special opcode \"BUNDLE\". It's not \"inside\"\n  /// a bundle, but the next three MIs are.\n  bool isInsideBundle() const {\n    return getFlag(BundledPred);\n  }\n\n  /// Return true if this instruction part of a bundle. This is true\n  /// if either itself or its following instruction is marked \"InsideBundle\".\n  bool isBundled() const {\n    return isBundledWithPred() || isBundledWithSucc();\n  }\n\n  /// Return true if this instruction is part of a bundle, and it is not the\n  /// first instruction in the bundle.\n  bool isBundledWithPred() const { return getFlag(BundledPred); }\n\n  /// Return true if this instruction is part of a bundle, and it is not the\n  /// last instruction in the bundle.\n  bool isBundledWithSucc() const { return getFlag(BundledSucc); }\n\n  /// Bundle this instruction with its predecessor. This can be an unbundled\n  /// instruction, or it can be the first instruction in a bundle.\n  void bundleWithPred();\n\n  /// Bundle this instruction with its successor. This can be an unbundled\n  /// instruction, or it can be the last instruction in a bundle.\n  void bundleWithSucc();\n\n  /// Break bundle above this instruction.\n  void unbundleFromPred();\n\n  /// Break bundle below this instruction.\n  void unbundleFromSucc();\n\n  /// Returns the debug location id of this MachineInstr.\n  const DebugLoc &getDebugLoc() const { return debugLoc; }\n\n  /// Return the operand containing the offset to be used if this DBG_VALUE\n  /// instruction is indirect; will be an invalid register if this value is\n  /// not indirect, and an immediate with value 0 otherwise.\n  const MachineOperand &getDebugOffset() const {\n    assert(isDebugValue() && \"not a DBG_VALUE\");\n    return getOperand(1);\n  }\n  MachineOperand &getDebugOffset() {\n    assert(isDebugValue() && \"not a DBG_VALUE\");\n    return getOperand(1);\n  }\n\n  /// Return the operand for the debug variable referenced by\n  /// this DBG_VALUE instruction.\n  const MachineOperand &getDebugVariableOp() const;\n  MachineOperand &getDebugVariableOp();\n\n  /// Return the debug variable referenced by\n  /// this DBG_VALUE instruction.\n  const DILocalVariable *getDebugVariable() const;\n\n  /// Return the operand for the complex address expression referenced by\n  /// this DBG_VALUE instruction.\n  MachineOperand &getDebugExpressionOp();\n\n  /// Return the complex address expression referenced by\n  /// this DBG_VALUE instruction.\n  const DIExpression *getDebugExpression() const;\n\n  /// Return the debug label referenced by\n  /// this DBG_LABEL instruction.\n  const DILabel *getDebugLabel() const;\n\n  /// Fetch the instruction number of this MachineInstr. If it does not have\n  /// one already, a new and unique number will be assigned.\n  unsigned getDebugInstrNum();\n\n  /// Examine the instruction number of this MachineInstr. May be zero if\n  /// it hasn't been assigned a number yet.\n  unsigned peekDebugInstrNum() const { return DebugInstrNum; }\n\n  /// Set instruction number of this MachineInstr. Avoid using unless you're\n  /// deserializing this information.\n  void setDebugInstrNum(unsigned Num) { DebugInstrNum = Num; }\n\n  /// Emit an error referring to the source location of this instruction.\n  /// This should only be used for inline assembly that is somehow\n  /// impossible to compile. Other errors should have been handled much\n  /// earlier.\n  ///\n  /// If this method returns, the caller should try to recover from the error.\n  void emitError(StringRef Msg) const;\n\n  /// Returns the target instruction descriptor of this MachineInstr.\n  const MCInstrDesc &getDesc() const { return *MCID; }\n\n  /// Returns the opcode of this MachineInstr.\n  unsigned getOpcode() const { return MCID->Opcode; }\n\n  /// Retuns the total number of operands.\n  unsigned getNumOperands() const { return NumOperands; }\n\n  /// Returns the total number of operands which are debug locations.\n  unsigned getNumDebugOperands() const {\n    return std::distance(debug_operands().begin(), debug_operands().end());\n  }\n\n  const MachineOperand& getOperand(unsigned i) const {\n    assert(i < getNumOperands() && \"getOperand() out of range!\");\n    return Operands[i];\n  }\n  MachineOperand& getOperand(unsigned i) {\n    assert(i < getNumOperands() && \"getOperand() out of range!\");\n    return Operands[i];\n  }\n\n  MachineOperand &getDebugOperand(unsigned Index) {\n    assert(Index < getNumDebugOperands() && \"getDebugOperand() out of range!\");\n    return *(debug_operands().begin() + Index);\n  }\n  const MachineOperand &getDebugOperand(unsigned Index) const {\n    assert(Index < getNumDebugOperands() && \"getDebugOperand() out of range!\");\n    return *(debug_operands().begin() + Index);\n  }\n\n  /// Returns a pointer to the operand corresponding to a debug use of Reg, or\n  /// nullptr if Reg is not used in any debug operand.\n  const MachineOperand *getDebugOperandForReg(Register Reg) const {\n    const MachineOperand *RegOp =\n        find_if(debug_operands(), [Reg](const MachineOperand &Op) {\n          return Op.isReg() && Op.getReg() == Reg;\n        });\n    return RegOp == adl_end(debug_operands()) ? nullptr : RegOp;\n  }\n  MachineOperand *getDebugOperandForReg(Register Reg) {\n    MachineOperand *RegOp =\n        find_if(debug_operands(), [Reg](const MachineOperand &Op) {\n          return Op.isReg() && Op.getReg() == Reg;\n        });\n    return RegOp == adl_end(debug_operands()) ? nullptr : RegOp;\n  }\n\n  unsigned getDebugOperandIndex(const MachineOperand *Op) const {\n    assert(Op >= adl_begin(debug_operands()) &&\n           Op <= adl_end(debug_operands()) && \"Expected a debug operand.\");\n    return std::distance(adl_begin(debug_operands()), Op);\n  }\n\n  /// Returns the total number of definitions.\n  unsigned getNumDefs() const {\n    return getNumExplicitDefs() + MCID->getNumImplicitDefs();\n  }\n\n  /// Returns true if the instruction has implicit definition.\n  bool hasImplicitDef() const {\n    for (unsigned I = getNumExplicitOperands(), E = getNumOperands();\n      I != E; ++I) {\n      const MachineOperand &MO = getOperand(I);\n      if (MO.isDef() && MO.isImplicit())\n        return true;\n    }\n    return false;\n  }\n\n  /// Returns the implicit operands number.\n  unsigned getNumImplicitOperands() const {\n    return getNumOperands() - getNumExplicitOperands();\n  }\n\n  /// Return true if operand \\p OpIdx is a subregister index.\n  bool isOperandSubregIdx(unsigned OpIdx) const {\n    assert(getOperand(OpIdx).getType() == MachineOperand::MO_Immediate &&\n           \"Expected MO_Immediate operand type.\");\n    if (isExtractSubreg() && OpIdx == 2)\n      return true;\n    if (isInsertSubreg() && OpIdx == 3)\n      return true;\n    if (isRegSequence() && OpIdx > 1 && (OpIdx % 2) == 0)\n      return true;\n    if (isSubregToReg() && OpIdx == 3)\n      return true;\n    return false;\n  }\n\n  /// Returns the number of non-implicit operands.\n  unsigned getNumExplicitOperands() const;\n\n  /// Returns the number of non-implicit definitions.\n  unsigned getNumExplicitDefs() const;\n\n  /// iterator/begin/end - Iterate over all operands of a machine instruction.\n  using mop_iterator = MachineOperand *;\n  using const_mop_iterator = const MachineOperand *;\n\n  mop_iterator operands_begin() { return Operands; }\n  mop_iterator operands_end() { return Operands + NumOperands; }\n\n  const_mop_iterator operands_begin() const { return Operands; }\n  const_mop_iterator operands_end() const { return Operands + NumOperands; }\n\n  iterator_range<mop_iterator> operands() {\n    return make_range(operands_begin(), operands_end());\n  }\n  iterator_range<const_mop_iterator> operands() const {\n    return make_range(operands_begin(), operands_end());\n  }\n  iterator_range<mop_iterator> explicit_operands() {\n    return make_range(operands_begin(),\n                      operands_begin() + getNumExplicitOperands());\n  }\n  iterator_range<const_mop_iterator> explicit_operands() const {\n    return make_range(operands_begin(),\n                      operands_begin() + getNumExplicitOperands());\n  }\n  iterator_range<mop_iterator> implicit_operands() {\n    return make_range(explicit_operands().end(), operands_end());\n  }\n  iterator_range<const_mop_iterator> implicit_operands() const {\n    return make_range(explicit_operands().end(), operands_end());\n  }\n  /// Returns a range over all operands that are used to determine the variable\n  /// location for this DBG_VALUE instruction.\n  iterator_range<mop_iterator> debug_operands() {\n    assert(isDebugValue() && \"Must be a debug value instruction.\");\n    return make_range(operands_begin(), operands_begin() + 1);\n  }\n  /// \\copydoc debug_operands()\n  iterator_range<const_mop_iterator> debug_operands() const {\n    assert(isDebugValue() && \"Must be a debug value instruction.\");\n    return make_range(operands_begin(), operands_begin() + 1);\n  }\n  /// Returns a range over all explicit operands that are register definitions.\n  /// Implicit definition are not included!\n  iterator_range<mop_iterator> defs() {\n    return make_range(operands_begin(),\n                      operands_begin() + getNumExplicitDefs());\n  }\n  /// \\copydoc defs()\n  iterator_range<const_mop_iterator> defs() const {\n    return make_range(operands_begin(),\n                      operands_begin() + getNumExplicitDefs());\n  }\n  /// Returns a range that includes all operands that are register uses.\n  /// This may include unrelated operands which are not register uses.\n  iterator_range<mop_iterator> uses() {\n    return make_range(operands_begin() + getNumExplicitDefs(), operands_end());\n  }\n  /// \\copydoc uses()\n  iterator_range<const_mop_iterator> uses() const {\n    return make_range(operands_begin() + getNumExplicitDefs(), operands_end());\n  }\n  iterator_range<mop_iterator> explicit_uses() {\n    return make_range(operands_begin() + getNumExplicitDefs(),\n                      operands_begin() + getNumExplicitOperands());\n  }\n  iterator_range<const_mop_iterator> explicit_uses() const {\n    return make_range(operands_begin() + getNumExplicitDefs(),\n                      operands_begin() + getNumExplicitOperands());\n  }\n\n  /// Returns the number of the operand iterator \\p I points to.\n  unsigned getOperandNo(const_mop_iterator I) const {\n    return I - operands_begin();\n  }\n\n  /// Access to memory operands of the instruction. If there are none, that does\n  /// not imply anything about whether the function accesses memory. Instead,\n  /// the caller must behave conservatively.\n  ArrayRef<MachineMemOperand *> memoperands() const {\n    if (!Info)\n      return {};\n\n    if (Info.is<EIIK_MMO>())\n      return makeArrayRef(Info.getAddrOfZeroTagPointer(), 1);\n\n    if (ExtraInfo *EI = Info.get<EIIK_OutOfLine>())\n      return EI->getMMOs();\n\n    return {};\n  }\n\n  /// Access to memory operands of the instruction.\n  ///\n  /// If `memoperands_begin() == memoperands_end()`, that does not imply\n  /// anything about whether the function accesses memory. Instead, the caller\n  /// must behave conservatively.\n  mmo_iterator memoperands_begin() const { return memoperands().begin(); }\n\n  /// Access to memory operands of the instruction.\n  ///\n  /// If `memoperands_begin() == memoperands_end()`, that does not imply\n  /// anything about whether the function accesses memory. Instead, the caller\n  /// must behave conservatively.\n  mmo_iterator memoperands_end() const { return memoperands().end(); }\n\n  /// Return true if we don't have any memory operands which described the\n  /// memory access done by this instruction.  If this is true, calling code\n  /// must be conservative.\n  bool memoperands_empty() const { return memoperands().empty(); }\n\n  /// Return true if this instruction has exactly one MachineMemOperand.\n  bool hasOneMemOperand() const { return memoperands().size() == 1; }\n\n  /// Return the number of memory operands.\n  unsigned getNumMemOperands() const { return memoperands().size(); }\n\n  /// Helper to extract a pre-instruction symbol if one has been added.\n  MCSymbol *getPreInstrSymbol() const {\n    if (!Info)\n      return nullptr;\n    if (MCSymbol *S = Info.get<EIIK_PreInstrSymbol>())\n      return S;\n    if (ExtraInfo *EI = Info.get<EIIK_OutOfLine>())\n      return EI->getPreInstrSymbol();\n\n    return nullptr;\n  }\n\n  /// Helper to extract a post-instruction symbol if one has been added.\n  MCSymbol *getPostInstrSymbol() const {\n    if (!Info)\n      return nullptr;\n    if (MCSymbol *S = Info.get<EIIK_PostInstrSymbol>())\n      return S;\n    if (ExtraInfo *EI = Info.get<EIIK_OutOfLine>())\n      return EI->getPostInstrSymbol();\n\n    return nullptr;\n  }\n\n  /// Helper to extract a heap alloc marker if one has been added.\n  MDNode *getHeapAllocMarker() const {\n    if (!Info)\n      return nullptr;\n    if (ExtraInfo *EI = Info.get<EIIK_OutOfLine>())\n      return EI->getHeapAllocMarker();\n\n    return nullptr;\n  }\n\n  /// API for querying MachineInstr properties. They are the same as MCInstrDesc\n  /// queries but they are bundle aware.\n\n  enum QueryType {\n    IgnoreBundle,    // Ignore bundles\n    AnyInBundle,     // Return true if any instruction in bundle has property\n    AllInBundle      // Return true if all instructions in bundle have property\n  };\n\n  /// Return true if the instruction (or in the case of a bundle,\n  /// the instructions inside the bundle) has the specified property.\n  /// The first argument is the property being queried.\n  /// The second argument indicates whether the query should look inside\n  /// instruction bundles.\n  bool hasProperty(unsigned MCFlag, QueryType Type = AnyInBundle) const {\n    assert(MCFlag < 64 &&\n           \"MCFlag out of range for bit mask in getFlags/hasPropertyInBundle.\");\n    // Inline the fast path for unbundled or bundle-internal instructions.\n    if (Type == IgnoreBundle || !isBundled() || isBundledWithPred())\n      return getDesc().getFlags() & (1ULL << MCFlag);\n\n    // If this is the first instruction in a bundle, take the slow path.\n    return hasPropertyInBundle(1ULL << MCFlag, Type);\n  }\n\n  /// Return true if this is an instruction that should go through the usual\n  /// legalization steps.\n  bool isPreISelOpcode(QueryType Type = IgnoreBundle) const {\n    return hasProperty(MCID::PreISelOpcode, Type);\n  }\n\n  /// Return true if this instruction can have a variable number of operands.\n  /// In this case, the variable operands will be after the normal\n  /// operands but before the implicit definitions and uses (if any are\n  /// present).\n  bool isVariadic(QueryType Type = IgnoreBundle) const {\n    return hasProperty(MCID::Variadic, Type);\n  }\n\n  /// Set if this instruction has an optional definition, e.g.\n  /// ARM instructions which can set condition code if 's' bit is set.\n  bool hasOptionalDef(QueryType Type = IgnoreBundle) const {\n    return hasProperty(MCID::HasOptionalDef, Type);\n  }\n\n  /// Return true if this is a pseudo instruction that doesn't\n  /// correspond to a real machine instruction.\n  bool isPseudo(QueryType Type = IgnoreBundle) const {\n    return hasProperty(MCID::Pseudo, Type);\n  }\n\n  bool isReturn(QueryType Type = AnyInBundle) const {\n    return hasProperty(MCID::Return, Type);\n  }\n\n  /// Return true if this is an instruction that marks the end of an EH scope,\n  /// i.e., a catchpad or a cleanuppad instruction.\n  bool isEHScopeReturn(QueryType Type = AnyInBundle) const {\n    return hasProperty(MCID::EHScopeReturn, Type);\n  }\n\n  bool isCall(QueryType Type = AnyInBundle) const {\n    return hasProperty(MCID::Call, Type);\n  }\n\n  /// Return true if this is a call instruction that may have an associated\n  /// call site entry in the debug info.\n  bool isCandidateForCallSiteEntry(QueryType Type = IgnoreBundle) const;\n  /// Return true if copying, moving, or erasing this instruction requires\n  /// updating Call Site Info (see \\ref copyCallSiteInfo, \\ref moveCallSiteInfo,\n  /// \\ref eraseCallSiteInfo).\n  bool shouldUpdateCallSiteInfo() const;\n\n  /// Returns true if the specified instruction stops control flow\n  /// from executing the instruction immediately following it.  Examples include\n  /// unconditional branches and return instructions.\n  bool isBarrier(QueryType Type = AnyInBundle) const {\n    return hasProperty(MCID::Barrier, Type);\n  }\n\n  /// Returns true if this instruction part of the terminator for a basic block.\n  /// Typically this is things like return and branch instructions.\n  ///\n  /// Various passes use this to insert code into the bottom of a basic block,\n  /// but before control flow occurs.\n  bool isTerminator(QueryType Type = AnyInBundle) const {\n    return hasProperty(MCID::Terminator, Type);\n  }\n\n  /// Returns true if this is a conditional, unconditional, or indirect branch.\n  /// Predicates below can be used to discriminate between\n  /// these cases, and the TargetInstrInfo::analyzeBranch method can be used to\n  /// get more information.\n  bool isBranch(QueryType Type = AnyInBundle) const {\n    return hasProperty(MCID::Branch, Type);\n  }\n\n  /// Return true if this is an indirect branch, such as a\n  /// branch through a register.\n  bool isIndirectBranch(QueryType Type = AnyInBundle) const {\n    return hasProperty(MCID::IndirectBranch, Type);\n  }\n\n  /// Return true if this is a branch which may fall\n  /// through to the next instruction or may transfer control flow to some other\n  /// block.  The TargetInstrInfo::analyzeBranch method can be used to get more\n  /// information about this branch.\n  bool isConditionalBranch(QueryType Type = AnyInBundle) const {\n    return isBranch(Type) && !isBarrier(Type) && !isIndirectBranch(Type);\n  }\n\n  /// Return true if this is a branch which always\n  /// transfers control flow to some other block.  The\n  /// TargetInstrInfo::analyzeBranch method can be used to get more information\n  /// about this branch.\n  bool isUnconditionalBranch(QueryType Type = AnyInBundle) const {\n    return isBranch(Type) && isBarrier(Type) && !isIndirectBranch(Type);\n  }\n\n  /// Return true if this instruction has a predicate operand that\n  /// controls execution.  It may be set to 'always', or may be set to other\n  /// values.   There are various methods in TargetInstrInfo that can be used to\n  /// control and modify the predicate in this instruction.\n  bool isPredicable(QueryType Type = AllInBundle) const {\n    // If it's a bundle than all bundled instructions must be predicable for this\n    // to return true.\n    return hasProperty(MCID::Predicable, Type);\n  }\n\n  /// Return true if this instruction is a comparison.\n  bool isCompare(QueryType Type = IgnoreBundle) const {\n    return hasProperty(MCID::Compare, Type);\n  }\n\n  /// Return true if this instruction is a move immediate\n  /// (including conditional moves) instruction.\n  bool isMoveImmediate(QueryType Type = IgnoreBundle) const {\n    return hasProperty(MCID::MoveImm, Type);\n  }\n\n  /// Return true if this instruction is a register move.\n  /// (including moving values from subreg to reg)\n  bool isMoveReg(QueryType Type = IgnoreBundle) const {\n    return hasProperty(MCID::MoveReg, Type);\n  }\n\n  /// Return true if this instruction is a bitcast instruction.\n  bool isBitcast(QueryType Type = IgnoreBundle) const {\n    return hasProperty(MCID::Bitcast, Type);\n  }\n\n  /// Return true if this instruction is a select instruction.\n  bool isSelect(QueryType Type = IgnoreBundle) const {\n    return hasProperty(MCID::Select, Type);\n  }\n\n  /// Return true if this instruction cannot be safely duplicated.\n  /// For example, if the instruction has a unique labels attached\n  /// to it, duplicating it would cause multiple definition errors.\n  bool isNotDuplicable(QueryType Type = AnyInBundle) const {\n    return hasProperty(MCID::NotDuplicable, Type);\n  }\n\n  /// Return true if this instruction is convergent.\n  /// Convergent instructions can not be made control-dependent on any\n  /// additional values.\n  bool isConvergent(QueryType Type = AnyInBundle) const {\n    if (isInlineAsm()) {\n      unsigned ExtraInfo = getOperand(InlineAsm::MIOp_ExtraInfo).getImm();\n      if (ExtraInfo & InlineAsm::Extra_IsConvergent)\n        return true;\n    }\n    return hasProperty(MCID::Convergent, Type);\n  }\n\n  /// Returns true if the specified instruction has a delay slot\n  /// which must be filled by the code generator.\n  bool hasDelaySlot(QueryType Type = AnyInBundle) const {\n    return hasProperty(MCID::DelaySlot, Type);\n  }\n\n  /// Return true for instructions that can be folded as\n  /// memory operands in other instructions. The most common use for this\n  /// is instructions that are simple loads from memory that don't modify\n  /// the loaded value in any way, but it can also be used for instructions\n  /// that can be expressed as constant-pool loads, such as V_SETALLONES\n  /// on x86, to allow them to be folded when it is beneficial.\n  /// This should only be set on instructions that return a value in their\n  /// only virtual register definition.\n  bool canFoldAsLoad(QueryType Type = IgnoreBundle) const {\n    return hasProperty(MCID::FoldableAsLoad, Type);\n  }\n\n  /// Return true if this instruction behaves\n  /// the same way as the generic REG_SEQUENCE instructions.\n  /// E.g., on ARM,\n  /// dX VMOVDRR rY, rZ\n  /// is equivalent to\n  /// dX = REG_SEQUENCE rY, ssub_0, rZ, ssub_1.\n  ///\n  /// Note that for the optimizers to be able to take advantage of\n  /// this property, TargetInstrInfo::getRegSequenceLikeInputs has to be\n  /// override accordingly.\n  bool isRegSequenceLike(QueryType Type = IgnoreBundle) const {\n    return hasProperty(MCID::RegSequence, Type);\n  }\n\n  /// Return true if this instruction behaves\n  /// the same way as the generic EXTRACT_SUBREG instructions.\n  /// E.g., on ARM,\n  /// rX, rY VMOVRRD dZ\n  /// is equivalent to two EXTRACT_SUBREG:\n  /// rX = EXTRACT_SUBREG dZ, ssub_0\n  /// rY = EXTRACT_SUBREG dZ, ssub_1\n  ///\n  /// Note that for the optimizers to be able to take advantage of\n  /// this property, TargetInstrInfo::getExtractSubregLikeInputs has to be\n  /// override accordingly.\n  bool isExtractSubregLike(QueryType Type = IgnoreBundle) const {\n    return hasProperty(MCID::ExtractSubreg, Type);\n  }\n\n  /// Return true if this instruction behaves\n  /// the same way as the generic INSERT_SUBREG instructions.\n  /// E.g., on ARM,\n  /// dX = VSETLNi32 dY, rZ, Imm\n  /// is equivalent to a INSERT_SUBREG:\n  /// dX = INSERT_SUBREG dY, rZ, translateImmToSubIdx(Imm)\n  ///\n  /// Note that for the optimizers to be able to take advantage of\n  /// this property, TargetInstrInfo::getInsertSubregLikeInputs has to be\n  /// override accordingly.\n  bool isInsertSubregLike(QueryType Type = IgnoreBundle) const {\n    return hasProperty(MCID::InsertSubreg, Type);\n  }\n\n  //===--------------------------------------------------------------------===//\n  // Side Effect Analysis\n  //===--------------------------------------------------------------------===//\n\n  /// Return true if this instruction could possibly read memory.\n  /// Instructions with this flag set are not necessarily simple load\n  /// instructions, they may load a value and modify it, for example.\n  bool mayLoad(QueryType Type = AnyInBundle) const {\n    if (isInlineAsm()) {\n      unsigned ExtraInfo = getOperand(InlineAsm::MIOp_ExtraInfo).getImm();\n      if (ExtraInfo & InlineAsm::Extra_MayLoad)\n        return true;\n    }\n    return hasProperty(MCID::MayLoad, Type);\n  }\n\n  /// Return true if this instruction could possibly modify memory.\n  /// Instructions with this flag set are not necessarily simple store\n  /// instructions, they may store a modified value based on their operands, or\n  /// may not actually modify anything, for example.\n  bool mayStore(QueryType Type = AnyInBundle) const {\n    if (isInlineAsm()) {\n      unsigned ExtraInfo = getOperand(InlineAsm::MIOp_ExtraInfo).getImm();\n      if (ExtraInfo & InlineAsm::Extra_MayStore)\n        return true;\n    }\n    return hasProperty(MCID::MayStore, Type);\n  }\n\n  /// Return true if this instruction could possibly read or modify memory.\n  bool mayLoadOrStore(QueryType Type = AnyInBundle) const {\n    return mayLoad(Type) || mayStore(Type);\n  }\n\n  /// Return true if this instruction could possibly raise a floating-point\n  /// exception.  This is the case if the instruction is a floating-point\n  /// instruction that can in principle raise an exception, as indicated\n  /// by the MCID::MayRaiseFPException property, *and* at the same time,\n  /// the instruction is used in a context where we expect floating-point\n  /// exceptions are not disabled, as indicated by the NoFPExcept MI flag.\n  bool mayRaiseFPException() const {\n    return hasProperty(MCID::MayRaiseFPException) &&\n           !getFlag(MachineInstr::MIFlag::NoFPExcept);\n  }\n\n  //===--------------------------------------------------------------------===//\n  // Flags that indicate whether an instruction can be modified by a method.\n  //===--------------------------------------------------------------------===//\n\n  /// Return true if this may be a 2- or 3-address\n  /// instruction (of the form \"X = op Y, Z, ...\"), which produces the same\n  /// result if Y and Z are exchanged.  If this flag is set, then the\n  /// TargetInstrInfo::commuteInstruction method may be used to hack on the\n  /// instruction.\n  ///\n  /// Note that this flag may be set on instructions that are only commutable\n  /// sometimes.  In these cases, the call to commuteInstruction will fail.\n  /// Also note that some instructions require non-trivial modification to\n  /// commute them.\n  bool isCommutable(QueryType Type = IgnoreBundle) const {\n    return hasProperty(MCID::Commutable, Type);\n  }\n\n  /// Return true if this is a 2-address instruction\n  /// which can be changed into a 3-address instruction if needed.  Doing this\n  /// transformation can be profitable in the register allocator, because it\n  /// means that the instruction can use a 2-address form if possible, but\n  /// degrade into a less efficient form if the source and dest register cannot\n  /// be assigned to the same register.  For example, this allows the x86\n  /// backend to turn a \"shl reg, 3\" instruction into an LEA instruction, which\n  /// is the same speed as the shift but has bigger code size.\n  ///\n  /// If this returns true, then the target must implement the\n  /// TargetInstrInfo::convertToThreeAddress method for this instruction, which\n  /// is allowed to fail if the transformation isn't valid for this specific\n  /// instruction (e.g. shl reg, 4 on x86).\n  ///\n  bool isConvertibleTo3Addr(QueryType Type = IgnoreBundle) const {\n    return hasProperty(MCID::ConvertibleTo3Addr, Type);\n  }\n\n  /// Return true if this instruction requires\n  /// custom insertion support when the DAG scheduler is inserting it into a\n  /// machine basic block.  If this is true for the instruction, it basically\n  /// means that it is a pseudo instruction used at SelectionDAG time that is\n  /// expanded out into magic code by the target when MachineInstrs are formed.\n  ///\n  /// If this is true, the TargetLoweringInfo::InsertAtEndOfBasicBlock method\n  /// is used to insert this into the MachineBasicBlock.\n  bool usesCustomInsertionHook(QueryType Type = IgnoreBundle) const {\n    return hasProperty(MCID::UsesCustomInserter, Type);\n  }\n\n  /// Return true if this instruction requires *adjustment*\n  /// after instruction selection by calling a target hook. For example, this\n  /// can be used to fill in ARM 's' optional operand depending on whether\n  /// the conditional flag register is used.\n  bool hasPostISelHook(QueryType Type = IgnoreBundle) const {\n    return hasProperty(MCID::HasPostISelHook, Type);\n  }\n\n  /// Returns true if this instruction is a candidate for remat.\n  /// This flag is deprecated, please don't use it anymore.  If this\n  /// flag is set, the isReallyTriviallyReMaterializable() method is called to\n  /// verify the instruction is really rematable.\n  bool isRematerializable(QueryType Type = AllInBundle) const {\n    // It's only possible to re-mat a bundle if all bundled instructions are\n    // re-materializable.\n    return hasProperty(MCID::Rematerializable, Type);\n  }\n\n  /// Returns true if this instruction has the same cost (or less) than a move\n  /// instruction. This is useful during certain types of optimizations\n  /// (e.g., remat during two-address conversion or machine licm)\n  /// where we would like to remat or hoist the instruction, but not if it costs\n  /// more than moving the instruction into the appropriate register. Note, we\n  /// are not marking copies from and to the same register class with this flag.\n  bool isAsCheapAsAMove(QueryType Type = AllInBundle) const {\n    // Only returns true for a bundle if all bundled instructions are cheap.\n    return hasProperty(MCID::CheapAsAMove, Type);\n  }\n\n  /// Returns true if this instruction source operands\n  /// have special register allocation requirements that are not captured by the\n  /// operand register classes. e.g. ARM::STRD's two source registers must be an\n  /// even / odd pair, ARM::STM registers have to be in ascending order.\n  /// Post-register allocation passes should not attempt to change allocations\n  /// for sources of instructions with this flag.\n  bool hasExtraSrcRegAllocReq(QueryType Type = AnyInBundle) const {\n    return hasProperty(MCID::ExtraSrcRegAllocReq, Type);\n  }\n\n  /// Returns true if this instruction def operands\n  /// have special register allocation requirements that are not captured by the\n  /// operand register classes. e.g. ARM::LDRD's two def registers must be an\n  /// even / odd pair, ARM::LDM registers have to be in ascending order.\n  /// Post-register allocation passes should not attempt to change allocations\n  /// for definitions of instructions with this flag.\n  bool hasExtraDefRegAllocReq(QueryType Type = AnyInBundle) const {\n    return hasProperty(MCID::ExtraDefRegAllocReq, Type);\n  }\n\n  enum MICheckType {\n    CheckDefs,      // Check all operands for equality\n    CheckKillDead,  // Check all operands including kill / dead markers\n    IgnoreDefs,     // Ignore all definitions\n    IgnoreVRegDefs  // Ignore virtual register definitions\n  };\n\n  /// Return true if this instruction is identical to \\p Other.\n  /// Two instructions are identical if they have the same opcode and all their\n  /// operands are identical (with respect to MachineOperand::isIdenticalTo()).\n  /// Note that this means liveness related flags (dead, undef, kill) do not\n  /// affect the notion of identical.\n  bool isIdenticalTo(const MachineInstr &Other,\n                     MICheckType Check = CheckDefs) const;\n\n  /// Unlink 'this' from the containing basic block, and return it without\n  /// deleting it.\n  ///\n  /// This function can not be used on bundled instructions, use\n  /// removeFromBundle() to remove individual instructions from a bundle.\n  MachineInstr *removeFromParent();\n\n  /// Unlink this instruction from its basic block and return it without\n  /// deleting it.\n  ///\n  /// If the instruction is part of a bundle, the other instructions in the\n  /// bundle remain bundled.\n  MachineInstr *removeFromBundle();\n\n  /// Unlink 'this' from the containing basic block and delete it.\n  ///\n  /// If this instruction is the header of a bundle, the whole bundle is erased.\n  /// This function can not be used for instructions inside a bundle, use\n  /// eraseFromBundle() to erase individual bundled instructions.\n  void eraseFromParent();\n\n  /// Unlink 'this' from the containing basic block and delete it.\n  ///\n  /// For all definitions mark their uses in DBG_VALUE nodes\n  /// as undefined. Otherwise like eraseFromParent().\n  void eraseFromParentAndMarkDBGValuesForRemoval();\n\n  /// Unlink 'this' form its basic block and delete it.\n  ///\n  /// If the instruction is part of a bundle, the other instructions in the\n  /// bundle remain bundled.\n  void eraseFromBundle();\n\n  bool isEHLabel() const { return getOpcode() == TargetOpcode::EH_LABEL; }\n  bool isGCLabel() const { return getOpcode() == TargetOpcode::GC_LABEL; }\n  bool isAnnotationLabel() const {\n    return getOpcode() == TargetOpcode::ANNOTATION_LABEL;\n  }\n\n  /// Returns true if the MachineInstr represents a label.\n  bool isLabel() const {\n    return isEHLabel() || isGCLabel() || isAnnotationLabel();\n  }\n\n  bool isCFIInstruction() const {\n    return getOpcode() == TargetOpcode::CFI_INSTRUCTION;\n  }\n\n  bool isPseudoProbe() const {\n    return getOpcode() == TargetOpcode::PSEUDO_PROBE;\n  }\n  \n  // True if the instruction represents a position in the function.\n  bool isPosition() const { return isLabel() || isCFIInstruction(); }\n\n  bool isDebugValue() const { return getOpcode() == TargetOpcode::DBG_VALUE; }\n  bool isDebugLabel() const { return getOpcode() == TargetOpcode::DBG_LABEL; }\n  bool isDebugRef() const { return getOpcode() == TargetOpcode::DBG_INSTR_REF; }\n  bool isDebugInstr() const {\n    return isDebugValue() || isDebugLabel() || isDebugRef();\n  }\n  bool isDebugOrPseudoInstr() const {\n    return isDebugInstr() || isPseudoProbe();\n  }\n\n  bool isDebugOffsetImm() const { return getDebugOffset().isImm(); }\n\n  /// A DBG_VALUE is indirect iff the location operand is a register and\n  /// the offset operand is an immediate.\n  bool isIndirectDebugValue() const {\n    return isDebugValue() && getDebugOperand(0).isReg() && isDebugOffsetImm();\n  }\n\n  /// A DBG_VALUE is an entry value iff its debug expression contains the\n  /// DW_OP_LLVM_entry_value operation.\n  bool isDebugEntryValue() const;\n\n  /// Return true if the instruction is a debug value which describes a part of\n  /// a variable as unavailable.\n  bool isUndefDebugValue() const {\n    return isDebugValue() && getDebugOperand(0).isReg() &&\n           !getDebugOperand(0).getReg().isValid();\n  }\n\n  bool isPHI() const {\n    return getOpcode() == TargetOpcode::PHI ||\n           getOpcode() == TargetOpcode::G_PHI;\n  }\n  bool isKill() const { return getOpcode() == TargetOpcode::KILL; }\n  bool isImplicitDef() const { return getOpcode()==TargetOpcode::IMPLICIT_DEF; }\n  bool isInlineAsm() const {\n    return getOpcode() == TargetOpcode::INLINEASM ||\n           getOpcode() == TargetOpcode::INLINEASM_BR;\n  }\n\n  /// FIXME: Seems like a layering violation that the AsmDialect, which is X86\n  /// specific, be attached to a generic MachineInstr.\n  bool isMSInlineAsm() const {\n    return isInlineAsm() && getInlineAsmDialect() == InlineAsm::AD_Intel;\n  }\n\n  bool isStackAligningInlineAsm() const;\n  InlineAsm::AsmDialect getInlineAsmDialect() const;\n\n  bool isInsertSubreg() const {\n    return getOpcode() == TargetOpcode::INSERT_SUBREG;\n  }\n\n  bool isSubregToReg() const {\n    return getOpcode() == TargetOpcode::SUBREG_TO_REG;\n  }\n\n  bool isRegSequence() const {\n    return getOpcode() == TargetOpcode::REG_SEQUENCE;\n  }\n\n  bool isBundle() const {\n    return getOpcode() == TargetOpcode::BUNDLE;\n  }\n\n  bool isCopy() const {\n    return getOpcode() == TargetOpcode::COPY;\n  }\n\n  bool isFullCopy() const {\n    return isCopy() && !getOperand(0).getSubReg() && !getOperand(1).getSubReg();\n  }\n\n  bool isExtractSubreg() const {\n    return getOpcode() == TargetOpcode::EXTRACT_SUBREG;\n  }\n\n  /// Return true if the instruction behaves like a copy.\n  /// This does not include native copy instructions.\n  bool isCopyLike() const {\n    return isCopy() || isSubregToReg();\n  }\n\n  /// Return true is the instruction is an identity copy.\n  bool isIdentityCopy() const {\n    return isCopy() && getOperand(0).getReg() == getOperand(1).getReg() &&\n      getOperand(0).getSubReg() == getOperand(1).getSubReg();\n  }\n\n  /// Return true if this instruction doesn't produce any output in the form of\n  /// executable instructions.\n  bool isMetaInstruction() const {\n    switch (getOpcode()) {\n    default:\n      return false;\n    case TargetOpcode::IMPLICIT_DEF:\n    case TargetOpcode::KILL:\n    case TargetOpcode::CFI_INSTRUCTION:\n    case TargetOpcode::EH_LABEL:\n    case TargetOpcode::GC_LABEL:\n    case TargetOpcode::DBG_VALUE:\n    case TargetOpcode::DBG_INSTR_REF:\n    case TargetOpcode::DBG_LABEL:\n    case TargetOpcode::LIFETIME_START:\n    case TargetOpcode::LIFETIME_END:\n    case TargetOpcode::PSEUDO_PROBE:\n      return true;\n    }\n  }\n\n  /// Return true if this is a transient instruction that is either very likely\n  /// to be eliminated during register allocation (such as copy-like\n  /// instructions), or if this instruction doesn't have an execution-time cost.\n  bool isTransient() const {\n    switch (getOpcode()) {\n    default:\n      return isMetaInstruction();\n    // Copy-like instructions are usually eliminated during register allocation.\n    case TargetOpcode::PHI:\n    case TargetOpcode::G_PHI:\n    case TargetOpcode::COPY:\n    case TargetOpcode::INSERT_SUBREG:\n    case TargetOpcode::SUBREG_TO_REG:\n    case TargetOpcode::REG_SEQUENCE:\n      return true;\n    }\n  }\n\n  /// Return the number of instructions inside the MI bundle, excluding the\n  /// bundle header.\n  ///\n  /// This is the number of instructions that MachineBasicBlock::iterator\n  /// skips, 0 for unbundled instructions.\n  unsigned getBundleSize() const;\n\n  /// Return true if the MachineInstr reads the specified register.\n  /// If TargetRegisterInfo is passed, then it also checks if there\n  /// is a read of a super-register.\n  /// This does not count partial redefines of virtual registers as reads:\n  ///   %reg1024:6 = OP.\n  bool readsRegister(Register Reg,\n                     const TargetRegisterInfo *TRI = nullptr) const {\n    return findRegisterUseOperandIdx(Reg, false, TRI) != -1;\n  }\n\n  /// Return true if the MachineInstr reads the specified virtual register.\n  /// Take into account that a partial define is a\n  /// read-modify-write operation.\n  bool readsVirtualRegister(Register Reg) const {\n    return readsWritesVirtualRegister(Reg).first;\n  }\n\n  /// Return a pair of bools (reads, writes) indicating if this instruction\n  /// reads or writes Reg. This also considers partial defines.\n  /// If Ops is not null, all operand indices for Reg are added.\n  std::pair<bool,bool> readsWritesVirtualRegister(Register Reg,\n                                SmallVectorImpl<unsigned> *Ops = nullptr) const;\n\n  /// Return true if the MachineInstr kills the specified register.\n  /// If TargetRegisterInfo is passed, then it also checks if there is\n  /// a kill of a super-register.\n  bool killsRegister(Register Reg,\n                     const TargetRegisterInfo *TRI = nullptr) const {\n    return findRegisterUseOperandIdx(Reg, true, TRI) != -1;\n  }\n\n  /// Return true if the MachineInstr fully defines the specified register.\n  /// If TargetRegisterInfo is passed, then it also checks\n  /// if there is a def of a super-register.\n  /// NOTE: It's ignoring subreg indices on virtual registers.\n  bool definesRegister(Register Reg,\n                       const TargetRegisterInfo *TRI = nullptr) const {\n    return findRegisterDefOperandIdx(Reg, false, false, TRI) != -1;\n  }\n\n  /// Return true if the MachineInstr modifies (fully define or partially\n  /// define) the specified register.\n  /// NOTE: It's ignoring subreg indices on virtual registers.\n  bool modifiesRegister(Register Reg,\n                        const TargetRegisterInfo *TRI = nullptr) const {\n    return findRegisterDefOperandIdx(Reg, false, true, TRI) != -1;\n  }\n\n  /// Returns true if the register is dead in this machine instruction.\n  /// If TargetRegisterInfo is passed, then it also checks\n  /// if there is a dead def of a super-register.\n  bool registerDefIsDead(Register Reg,\n                         const TargetRegisterInfo *TRI = nullptr) const {\n    return findRegisterDefOperandIdx(Reg, true, false, TRI) != -1;\n  }\n\n  /// Returns true if the MachineInstr has an implicit-use operand of exactly\n  /// the given register (not considering sub/super-registers).\n  bool hasRegisterImplicitUseOperand(Register Reg) const;\n\n  /// Returns the operand index that is a use of the specific register or -1\n  /// if it is not found. It further tightens the search criteria to a use\n  /// that kills the register if isKill is true.\n  int findRegisterUseOperandIdx(Register Reg, bool isKill = false,\n                                const TargetRegisterInfo *TRI = nullptr) const;\n\n  /// Wrapper for findRegisterUseOperandIdx, it returns\n  /// a pointer to the MachineOperand rather than an index.\n  MachineOperand *findRegisterUseOperand(Register Reg, bool isKill = false,\n                                      const TargetRegisterInfo *TRI = nullptr) {\n    int Idx = findRegisterUseOperandIdx(Reg, isKill, TRI);\n    return (Idx == -1) ? nullptr : &getOperand(Idx);\n  }\n\n  const MachineOperand *findRegisterUseOperand(\n    Register Reg, bool isKill = false,\n    const TargetRegisterInfo *TRI = nullptr) const {\n    return const_cast<MachineInstr *>(this)->\n      findRegisterUseOperand(Reg, isKill, TRI);\n  }\n\n  /// Returns the operand index that is a def of the specified register or\n  /// -1 if it is not found. If isDead is true, defs that are not dead are\n  /// skipped. If Overlap is true, then it also looks for defs that merely\n  /// overlap the specified register. If TargetRegisterInfo is non-null,\n  /// then it also checks if there is a def of a super-register.\n  /// This may also return a register mask operand when Overlap is true.\n  int findRegisterDefOperandIdx(Register Reg,\n                                bool isDead = false, bool Overlap = false,\n                                const TargetRegisterInfo *TRI = nullptr) const;\n\n  /// Wrapper for findRegisterDefOperandIdx, it returns\n  /// a pointer to the MachineOperand rather than an index.\n  MachineOperand *\n  findRegisterDefOperand(Register Reg, bool isDead = false,\n                         bool Overlap = false,\n                         const TargetRegisterInfo *TRI = nullptr) {\n    int Idx = findRegisterDefOperandIdx(Reg, isDead, Overlap, TRI);\n    return (Idx == -1) ? nullptr : &getOperand(Idx);\n  }\n\n  const MachineOperand *\n  findRegisterDefOperand(Register Reg, bool isDead = false,\n                         bool Overlap = false,\n                         const TargetRegisterInfo *TRI = nullptr) const {\n    return const_cast<MachineInstr *>(this)->findRegisterDefOperand(\n        Reg, isDead, Overlap, TRI);\n  }\n\n  /// Find the index of the first operand in the\n  /// operand list that is used to represent the predicate. It returns -1 if\n  /// none is found.\n  int findFirstPredOperandIdx() const;\n\n  /// Find the index of the flag word operand that\n  /// corresponds to operand OpIdx on an inline asm instruction.  Returns -1 if\n  /// getOperand(OpIdx) does not belong to an inline asm operand group.\n  ///\n  /// If GroupNo is not NULL, it will receive the number of the operand group\n  /// containing OpIdx.\n  ///\n  /// The flag operand is an immediate that can be decoded with methods like\n  /// InlineAsm::hasRegClassConstraint().\n  int findInlineAsmFlagIdx(unsigned OpIdx, unsigned *GroupNo = nullptr) const;\n\n  /// Compute the static register class constraint for operand OpIdx.\n  /// For normal instructions, this is derived from the MCInstrDesc.\n  /// For inline assembly it is derived from the flag words.\n  ///\n  /// Returns NULL if the static register class constraint cannot be\n  /// determined.\n  const TargetRegisterClass*\n  getRegClassConstraint(unsigned OpIdx,\n                        const TargetInstrInfo *TII,\n                        const TargetRegisterInfo *TRI) const;\n\n  /// Applies the constraints (def/use) implied by this MI on \\p Reg to\n  /// the given \\p CurRC.\n  /// If \\p ExploreBundle is set and MI is part of a bundle, all the\n  /// instructions inside the bundle will be taken into account. In other words,\n  /// this method accumulates all the constraints of the operand of this MI and\n  /// the related bundle if MI is a bundle or inside a bundle.\n  ///\n  /// Returns the register class that satisfies both \\p CurRC and the\n  /// constraints set by MI. Returns NULL if such a register class does not\n  /// exist.\n  ///\n  /// \\pre CurRC must not be NULL.\n  const TargetRegisterClass *getRegClassConstraintEffectForVReg(\n      Register Reg, const TargetRegisterClass *CurRC,\n      const TargetInstrInfo *TII, const TargetRegisterInfo *TRI,\n      bool ExploreBundle = false) const;\n\n  /// Applies the constraints (def/use) implied by the \\p OpIdx operand\n  /// to the given \\p CurRC.\n  ///\n  /// Returns the register class that satisfies both \\p CurRC and the\n  /// constraints set by \\p OpIdx MI. Returns NULL if such a register class\n  /// does not exist.\n  ///\n  /// \\pre CurRC must not be NULL.\n  /// \\pre The operand at \\p OpIdx must be a register.\n  const TargetRegisterClass *\n  getRegClassConstraintEffect(unsigned OpIdx, const TargetRegisterClass *CurRC,\n                              const TargetInstrInfo *TII,\n                              const TargetRegisterInfo *TRI) const;\n\n  /// Add a tie between the register operands at DefIdx and UseIdx.\n  /// The tie will cause the register allocator to ensure that the two\n  /// operands are assigned the same physical register.\n  ///\n  /// Tied operands are managed automatically for explicit operands in the\n  /// MCInstrDesc. This method is for exceptional cases like inline asm.\n  void tieOperands(unsigned DefIdx, unsigned UseIdx);\n\n  /// Given the index of a tied register operand, find the\n  /// operand it is tied to. Defs are tied to uses and vice versa. Returns the\n  /// index of the tied operand which must exist.\n  unsigned findTiedOperandIdx(unsigned OpIdx) const;\n\n  /// Given the index of a register def operand,\n  /// check if the register def is tied to a source operand, due to either\n  /// two-address elimination or inline assembly constraints. Returns the\n  /// first tied use operand index by reference if UseOpIdx is not null.\n  bool isRegTiedToUseOperand(unsigned DefOpIdx,\n                             unsigned *UseOpIdx = nullptr) const {\n    const MachineOperand &MO = getOperand(DefOpIdx);\n    if (!MO.isReg() || !MO.isDef() || !MO.isTied())\n      return false;\n    if (UseOpIdx)\n      *UseOpIdx = findTiedOperandIdx(DefOpIdx);\n    return true;\n  }\n\n  /// Return true if the use operand of the specified index is tied to a def\n  /// operand. It also returns the def operand index by reference if DefOpIdx\n  /// is not null.\n  bool isRegTiedToDefOperand(unsigned UseOpIdx,\n                             unsigned *DefOpIdx = nullptr) const {\n    const MachineOperand &MO = getOperand(UseOpIdx);\n    if (!MO.isReg() || !MO.isUse() || !MO.isTied())\n      return false;\n    if (DefOpIdx)\n      *DefOpIdx = findTiedOperandIdx(UseOpIdx);\n    return true;\n  }\n\n  /// Clears kill flags on all operands.\n  void clearKillInfo();\n\n  /// Replace all occurrences of FromReg with ToReg:SubIdx,\n  /// properly composing subreg indices where necessary.\n  void substituteRegister(Register FromReg, Register ToReg, unsigned SubIdx,\n                          const TargetRegisterInfo &RegInfo);\n\n  /// We have determined MI kills a register. Look for the\n  /// operand that uses it and mark it as IsKill. If AddIfNotFound is true,\n  /// add a implicit operand if it's not found. Returns true if the operand\n  /// exists / is added.\n  bool addRegisterKilled(Register IncomingReg,\n                         const TargetRegisterInfo *RegInfo,\n                         bool AddIfNotFound = false);\n\n  /// Clear all kill flags affecting Reg.  If RegInfo is provided, this includes\n  /// all aliasing registers.\n  void clearRegisterKills(Register Reg, const TargetRegisterInfo *RegInfo);\n\n  /// We have determined MI defined a register without a use.\n  /// Look for the operand that defines it and mark it as IsDead. If\n  /// AddIfNotFound is true, add a implicit operand if it's not found. Returns\n  /// true if the operand exists / is added.\n  bool addRegisterDead(Register Reg, const TargetRegisterInfo *RegInfo,\n                       bool AddIfNotFound = false);\n\n  /// Clear all dead flags on operands defining register @p Reg.\n  void clearRegisterDeads(Register Reg);\n\n  /// Mark all subregister defs of register @p Reg with the undef flag.\n  /// This function is used when we determined to have a subregister def in an\n  /// otherwise undefined super register.\n  void setRegisterDefReadUndef(Register Reg, bool IsUndef = true);\n\n  /// We have determined MI defines a register. Make sure there is an operand\n  /// defining Reg.\n  void addRegisterDefined(Register Reg,\n                          const TargetRegisterInfo *RegInfo = nullptr);\n\n  /// Mark every physreg used by this instruction as\n  /// dead except those in the UsedRegs list.\n  ///\n  /// On instructions with register mask operands, also add implicit-def\n  /// operands for all registers in UsedRegs.\n  void setPhysRegsDeadExcept(ArrayRef<Register> UsedRegs,\n                             const TargetRegisterInfo &TRI);\n\n  /// Return true if it is safe to move this instruction. If\n  /// SawStore is set to true, it means that there is a store (or call) between\n  /// the instruction's location and its intended destination.\n  bool isSafeToMove(AAResults *AA, bool &SawStore) const;\n\n  /// Returns true if this instruction's memory access aliases the memory\n  /// access of Other.\n  //\n  /// Assumes any physical registers used to compute addresses\n  /// have the same value for both instructions.  Returns false if neither\n  /// instruction writes to memory.\n  ///\n  /// @param AA Optional alias analysis, used to compare memory operands.\n  /// @param Other MachineInstr to check aliasing against.\n  /// @param UseTBAA Whether to pass TBAA information to alias analysis.\n  bool mayAlias(AAResults *AA, const MachineInstr &Other, bool UseTBAA) const;\n\n  /// Return true if this instruction may have an ordered\n  /// or volatile memory reference, or if the information describing the memory\n  /// reference is not available. Return false if it is known to have no\n  /// ordered or volatile memory references.\n  bool hasOrderedMemoryRef() const;\n\n  /// Return true if this load instruction never traps and points to a memory\n  /// location whose value doesn't change during the execution of this function.\n  ///\n  /// Examples include loading a value from the constant pool or from the\n  /// argument area of a function (if it does not change).  If the instruction\n  /// does multiple loads, this returns true only if all of the loads are\n  /// dereferenceable and invariant.\n  bool isDereferenceableInvariantLoad(AAResults *AA) const;\n\n  /// If the specified instruction is a PHI that always merges together the\n  /// same virtual register, return the register, otherwise return 0.\n  unsigned isConstantValuePHI() const;\n\n  /// Return true if this instruction has side effects that are not modeled\n  /// by mayLoad / mayStore, etc.\n  /// For all instructions, the property is encoded in MCInstrDesc::Flags\n  /// (see MCInstrDesc::hasUnmodeledSideEffects(). The only exception is\n  /// INLINEASM instruction, in which case the side effect property is encoded\n  /// in one of its operands (see InlineAsm::Extra_HasSideEffect).\n  ///\n  bool hasUnmodeledSideEffects() const;\n\n  /// Returns true if it is illegal to fold a load across this instruction.\n  bool isLoadFoldBarrier() const;\n\n  /// Return true if all the defs of this instruction are dead.\n  bool allDefsAreDead() const;\n\n  /// Return a valid size if the instruction is a spill instruction.\n  Optional<unsigned> getSpillSize(const TargetInstrInfo *TII) const;\n\n  /// Return a valid size if the instruction is a folded spill instruction.\n  Optional<unsigned> getFoldedSpillSize(const TargetInstrInfo *TII) const;\n\n  /// Return a valid size if the instruction is a restore instruction.\n  Optional<unsigned> getRestoreSize(const TargetInstrInfo *TII) const;\n\n  /// Return a valid size if the instruction is a folded restore instruction.\n  Optional<unsigned>\n  getFoldedRestoreSize(const TargetInstrInfo *TII) const;\n\n  /// Copy implicit register operands from specified\n  /// instruction to this instruction.\n  void copyImplicitOps(MachineFunction &MF, const MachineInstr &MI);\n\n  /// Debugging support\n  /// @{\n  /// Determine the generic type to be printed (if needed) on uses and defs.\n  LLT getTypeToPrint(unsigned OpIdx, SmallBitVector &PrintedTypes,\n                     const MachineRegisterInfo &MRI) const;\n\n  /// Return true when an instruction has tied register that can't be determined\n  /// by the instruction's descriptor. This is useful for MIR printing, to\n  /// determine whether we need to print the ties or not.\n  bool hasComplexRegisterTies() const;\n\n  /// Print this MI to \\p OS.\n  /// Don't print information that can be inferred from other instructions if\n  /// \\p IsStandalone is false. It is usually true when only a fragment of the\n  /// function is printed.\n  /// Only print the defs and the opcode if \\p SkipOpers is true.\n  /// Otherwise, also print operands if \\p SkipDebugLoc is true.\n  /// Otherwise, also print the debug loc, with a terminating newline.\n  /// \\p TII is used to print the opcode name.  If it's not present, but the\n  /// MI is in a function, the opcode will be printed using the function's TII.\n  void print(raw_ostream &OS, bool IsStandalone = true, bool SkipOpers = false,\n             bool SkipDebugLoc = false, bool AddNewLine = true,\n             const TargetInstrInfo *TII = nullptr) const;\n  void print(raw_ostream &OS, ModuleSlotTracker &MST, bool IsStandalone = true,\n             bool SkipOpers = false, bool SkipDebugLoc = false,\n             bool AddNewLine = true,\n             const TargetInstrInfo *TII = nullptr) const;\n  void dump() const;\n  /// Print on dbgs() the current instruction and the instructions defining its\n  /// operands and so on until we reach \\p MaxDepth.\n  void dumpr(const MachineRegisterInfo &MRI,\n             unsigned MaxDepth = UINT_MAX) const;\n  /// @}\n\n  //===--------------------------------------------------------------------===//\n  // Accessors used to build up machine instructions.\n\n  /// Add the specified operand to the instruction.  If it is an implicit\n  /// operand, it is added to the end of the operand list.  If it is an\n  /// explicit operand it is added at the end of the explicit operand list\n  /// (before the first implicit operand).\n  ///\n  /// MF must be the machine function that was used to allocate this\n  /// instruction.\n  ///\n  /// MachineInstrBuilder provides a more convenient interface for creating\n  /// instructions and adding operands.\n  void addOperand(MachineFunction &MF, const MachineOperand &Op);\n\n  /// Add an operand without providing an MF reference. This only works for\n  /// instructions that are inserted in a basic block.\n  ///\n  /// MachineInstrBuilder and the two-argument addOperand(MF, MO) should be\n  /// preferred.\n  void addOperand(const MachineOperand &Op);\n\n  /// Replace the instruction descriptor (thus opcode) of\n  /// the current instruction with a new one.\n  void setDesc(const MCInstrDesc &tid) { MCID = &tid; }\n\n  /// Replace current source information with new such.\n  /// Avoid using this, the constructor argument is preferable.\n  void setDebugLoc(DebugLoc dl) {\n    debugLoc = std::move(dl);\n    assert(debugLoc.hasTrivialDestructor() && \"Expected trivial destructor\");\n  }\n\n  /// Erase an operand from an instruction, leaving it with one\n  /// fewer operand than it started with.\n  void RemoveOperand(unsigned OpNo);\n\n  /// Clear this MachineInstr's memory reference descriptor list.  This resets\n  /// the memrefs to their most conservative state.  This should be used only\n  /// as a last resort since it greatly pessimizes our knowledge of the memory\n  /// access performed by the instruction.\n  void dropMemRefs(MachineFunction &MF);\n\n  /// Assign this MachineInstr's memory reference descriptor list.\n  ///\n  /// Unlike other methods, this *will* allocate them into a new array\n  /// associated with the provided `MachineFunction`.\n  void setMemRefs(MachineFunction &MF, ArrayRef<MachineMemOperand *> MemRefs);\n\n  /// Add a MachineMemOperand to the machine instruction.\n  /// This function should be used only occasionally. The setMemRefs function\n  /// is the primary method for setting up a MachineInstr's MemRefs list.\n  void addMemOperand(MachineFunction &MF, MachineMemOperand *MO);\n\n  /// Clone another MachineInstr's memory reference descriptor list and replace\n  /// ours with it.\n  ///\n  /// Note that `*this` may be the incoming MI!\n  ///\n  /// Prefer this API whenever possible as it can avoid allocations in common\n  /// cases.\n  void cloneMemRefs(MachineFunction &MF, const MachineInstr &MI);\n\n  /// Clone the merge of multiple MachineInstrs' memory reference descriptors\n  /// list and replace ours with it.\n  ///\n  /// Note that `*this` may be one of the incoming MIs!\n  ///\n  /// Prefer this API whenever possible as it can avoid allocations in common\n  /// cases.\n  void cloneMergedMemRefs(MachineFunction &MF,\n                          ArrayRef<const MachineInstr *> MIs);\n\n  /// Set a symbol that will be emitted just prior to the instruction itself.\n  ///\n  /// Setting this to a null pointer will remove any such symbol.\n  ///\n  /// FIXME: This is not fully implemented yet.\n  void setPreInstrSymbol(MachineFunction &MF, MCSymbol *Symbol);\n\n  /// Set a symbol that will be emitted just after the instruction itself.\n  ///\n  /// Setting this to a null pointer will remove any such symbol.\n  ///\n  /// FIXME: This is not fully implemented yet.\n  void setPostInstrSymbol(MachineFunction &MF, MCSymbol *Symbol);\n\n  /// Clone another MachineInstr's pre- and post- instruction symbols and\n  /// replace ours with it.\n  void cloneInstrSymbols(MachineFunction &MF, const MachineInstr &MI);\n\n  /// Set a marker on instructions that denotes where we should create and emit\n  /// heap alloc site labels. This waits until after instruction selection and\n  /// optimizations to create the label, so it should still work if the\n  /// instruction is removed or duplicated.\n  void setHeapAllocMarker(MachineFunction &MF, MDNode *MD);\n\n  /// Return the MIFlags which represent both MachineInstrs. This\n  /// should be used when merging two MachineInstrs into one. This routine does\n  /// not modify the MIFlags of this MachineInstr.\n  uint16_t mergeFlagsWith(const MachineInstr& Other) const;\n\n  static uint16_t copyFlagsFromInstruction(const Instruction &I);\n\n  /// Copy all flags to MachineInst MIFlags\n  void copyIRFlags(const Instruction &I);\n\n  /// Break any tie involving OpIdx.\n  void untieRegOperand(unsigned OpIdx) {\n    MachineOperand &MO = getOperand(OpIdx);\n    if (MO.isReg() && MO.isTied()) {\n      getOperand(findTiedOperandIdx(OpIdx)).TiedTo = 0;\n      MO.TiedTo = 0;\n    }\n  }\n\n  /// Add all implicit def and use operands to this instruction.\n  void addImplicitDefUseOperands(MachineFunction &MF);\n\n  /// Scan instructions immediately following MI and collect any matching\n  /// DBG_VALUEs.\n  void collectDebugValues(SmallVectorImpl<MachineInstr *> &DbgValues);\n\n  /// Find all DBG_VALUEs that point to the register def in this instruction\n  /// and point them to \\p Reg instead.\n  void changeDebugValuesDefReg(Register Reg);\n\n  /// Returns the Intrinsic::ID for this instruction.\n  /// \\pre Must have an intrinsic ID operand.\n  unsigned getIntrinsicID() const {\n    return getOperand(getNumExplicitDefs()).getIntrinsicID();\n  }\n\n  /// Sets all register debug operands in this debug value instruction to be\n  /// undef.\n  void setDebugValueUndef() {\n    assert(isDebugValue() && \"Must be a debug value instruction.\");\n    for (MachineOperand &MO : debug_operands()) {\n      if (MO.isReg()) {\n        MO.setReg(0);\n        MO.setSubReg(0);\n      }\n    }\n  }\n\nprivate:\n  /// If this instruction is embedded into a MachineFunction, return the\n  /// MachineRegisterInfo object for the current function, otherwise\n  /// return null.\n  MachineRegisterInfo *getRegInfo();\n\n  /// Unlink all of the register operands in this instruction from their\n  /// respective use lists.  This requires that the operands already be on their\n  /// use lists.\n  void RemoveRegOperandsFromUseLists(MachineRegisterInfo&);\n\n  /// Add all of the register operands in this instruction from their\n  /// respective use lists.  This requires that the operands not be on their\n  /// use lists yet.\n  void AddRegOperandsToUseLists(MachineRegisterInfo&);\n\n  /// Slow path for hasProperty when we're dealing with a bundle.\n  bool hasPropertyInBundle(uint64_t Mask, QueryType Type) const;\n\n  /// Implements the logic of getRegClassConstraintEffectForVReg for the\n  /// this MI and the given operand index \\p OpIdx.\n  /// If the related operand does not constrained Reg, this returns CurRC.\n  const TargetRegisterClass *getRegClassConstraintEffectForVRegImpl(\n      unsigned OpIdx, Register Reg, const TargetRegisterClass *CurRC,\n      const TargetInstrInfo *TII, const TargetRegisterInfo *TRI) const;\n\n  /// Stores extra instruction information inline or allocates as ExtraInfo\n  /// based on the number of pointers.\n  void setExtraInfo(MachineFunction &MF, ArrayRef<MachineMemOperand *> MMOs,\n                    MCSymbol *PreInstrSymbol, MCSymbol *PostInstrSymbol,\n                    MDNode *HeapAllocMarker);\n};\n\n/// Special DenseMapInfo traits to compare MachineInstr* by *value* of the\n/// instruction rather than by pointer value.\n/// The hashing and equality testing functions ignore definitions so this is\n/// useful for CSE, etc.\nstruct MachineInstrExpressionTrait : DenseMapInfo<MachineInstr*> {\n  static inline MachineInstr *getEmptyKey() {\n    return nullptr;\n  }\n\n  static inline MachineInstr *getTombstoneKey() {\n    return reinterpret_cast<MachineInstr*>(-1);\n  }\n\n  static unsigned getHashValue(const MachineInstr* const &MI);\n\n  static bool isEqual(const MachineInstr* const &LHS,\n                      const MachineInstr* const &RHS) {\n    if (RHS == getEmptyKey() || RHS == getTombstoneKey() ||\n        LHS == getEmptyKey() || LHS == getTombstoneKey())\n      return LHS == RHS;\n    return LHS->isIdenticalTo(*RHS, MachineInstr::IgnoreVRegDefs);\n  }\n};\n\n//===----------------------------------------------------------------------===//\n// Debugging Support\n\ninline raw_ostream& operator<<(raw_ostream &OS, const MachineInstr &MI) {\n  MI.print(OS);\n  return OS;\n}\n\n} // end namespace llvm\n\n#endif // LLVM_CODEGEN_MACHINEINSTR_H\n"}}, "reports": [{"events": [{"location": {"col": 20, "file": 2, "line": 371}, "message": "the definition seen here"}, {"location": {"col": 8, "file": 1, "line": 1705}, "message": "differing parameters are named here: ('MemRefs'), in definition: ('MMOs')"}, {"location": {"col": 8, "file": 1, "line": 1705}, "message": "function 'llvm::MachineInstr::setMemRefs' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h", "reportHash": "6299e25009acfd58eb4e9bf741024b5d", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 20, "file": 2, "line": 505}, "message": "the definition seen here"}, {"location": {"col": 8, "file": 1, "line": 1753}, "message": "differing parameters are named here: ('MD'), in definition: ('Marker')"}, {"location": {"col": 8, "file": 1, "line": 1753}, "message": "function 'llvm::MachineInstr::setHeapAllocMarker' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h", "reportHash": "b2e8d69d89b0dd4a3b218533e370922f", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
