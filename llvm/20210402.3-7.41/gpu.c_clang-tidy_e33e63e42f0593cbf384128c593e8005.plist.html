<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"4": {"id": 4, "path": "/home/vsts/work/1/llvm-project/polly/lib/External/ppcg/gpu.c", "content": "/*\n * Copyright 2010-2011 INRIA Saclay\n * Copyright 2012-2013 Ecole Normale Superieure\n * Copyright 2015-2016 Sven Verdoolaege\n *\n * Use of this software is governed by the MIT license\n *\n * Written by Sven Verdoolaege, INRIA Saclay - Ile-de-France,\n * Parc Club Orsay Universite, ZAC des vignes, 4 rue Jacques Monod,\n * 91893 Orsay, France\n * and Ecole Normale Superieure, 45 rue d\u2019Ulm, 75230 Paris, France\n */\n\n#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <isl/polynomial.h>\n#include <isl/union_set.h>\n#include <isl/aff.h>\n#include <isl/ilp.h>\n#include <isl/flow.h>\n#include <isl/schedule.h>\n#include <isl/schedule_node.h>\n#include <isl/options.h>\n#include <isl/ast_build.h>\n\n#include \"cpu.h\"\n#include \"gpu.h\"\n#include \"gpu_array_tile.h\"\n#include \"gpu_group.h\"\n#include \"gpu_hybrid.h\"\n#include \"gpu_tree.h\"\n#include \"hybrid.h\"\n#include \"schedule.h\"\n#include \"ppcg_options.h\"\n#include \"print.h\"\n#include \"util.h\"\n\nstruct gpu_array_info;\n\n/* Return the name of the outer array (of structs) accessed by \"access\".\n */\nstatic const char *get_outer_array_name(__isl_keep isl_map *access)\n{\n\tisl_space *space;\n\tconst char *name;\n\n\tspace = isl_space_range(isl_map_get_space(access));\n\twhile (space && isl_space_is_wrapping(space))\n\t\tspace = isl_space_domain(isl_space_unwrap(space));\n\tname = isl_space_get_tuple_name(space, isl_dim_set);\n\tisl_space_free(space);\n\n\treturn name;\n}\n\n/* Collect all references to the given array and store pointers to them\n * in array->refs.\n */\nvoid collect_references(struct gpu_prog *prog,\n\tstruct gpu_array_info *array)\n{\n\tint i;\n\tint n;\n\n\tn = 0;\n\tfor (i = 0; i < prog->n_stmts; ++i) {\n\t\tstruct gpu_stmt *stmt = &prog->stmts[i];\n\t\tstruct gpu_stmt_access *access;\n\n\t\tfor (access = stmt->accesses; access; access = access->next) {\n\t\t\tconst char *name;\n\t\t\tname = get_outer_array_name(access->access);\n\t\t\tif (name && !strcmp(array->name, name))\n\t\t\t\tn++;\n\t\t}\n\t}\n\n\tarray->n_ref = n;\n\tarray->refs = isl_alloc_array(prog->ctx, struct gpu_stmt_access *, n);\n\tassert(array->refs);\n\n\tn = 0;\n\tfor (i = 0; i < prog->n_stmts; ++i) {\n\t\tstruct gpu_stmt *stmt = &prog->stmts[i];\n\t\tstruct gpu_stmt_access *access;\n\n\t\tfor (access = stmt->accesses; access; access = access->next) {\n\t\t\tconst char *name;\n\t\t\tname = get_outer_array_name(access->access);\n\t\t\tif (!name || strcmp(array->name, name))\n\t\t\t\tcontinue;\n\n\t\t\tarray->refs[n++] = access;\n\t\t}\n\t}\n}\n\n/* Compute and return the extent of \"array\", taking into account the set of\n * accessed elements.\n *\n * In particular, the extent in the outer dimension is taken\n * from \"accessed\", while the extents in the remaining dimensions\n * are taken from array->extent.\n *\n * The extent in the outer dimension cannot be taken from array->extent\n * because that may be unbounded.  Furthermore, even if it is bounded,\n * it may be larger than the piece of the array that is being accessed.\n */\nstatic __isl_give isl_set *compute_extent(struct pet_array *array,\n\t__isl_keep isl_set *accessed)\n{\n\tint n_index;\n\tisl_id *id;\n\tisl_set *outer;\n\tisl_set *extent;\n\n\textent = isl_set_copy(array->extent);\n\n\tn_index = isl_set_dim(accessed, isl_dim_set);\n\tif (n_index == 0)\n\t\treturn extent;\n\n\textent = isl_set_project_out(extent, isl_dim_set, 0, 1);\n\touter = isl_set_copy(accessed);\n\touter = isl_set_project_out(outer, isl_dim_set, 1, n_index - 1);\n\textent = isl_set_flat_product(outer, extent);\n\tid = isl_set_get_tuple_id(accessed);\n\textent = isl_set_set_tuple_id(extent, id);\n\n\treturn extent;\n}\n\n/* Is the array \"array\" being extracted a read-only scalar?\n *\n * That is, is \"array\" a scalar that is never possibly written to.\n * An array containing structures is never considered to be a scalar.\n */\nstatic int is_read_only_scalar(struct gpu_array_info *array,\n\tstruct gpu_prog *prog)\n{\n\tisl_set *space;\n\tisl_union_map *write;\n\tint empty;\n\n\tif (array->has_compound_element)\n\t\treturn 0;\n\tif (array->n_index != 0)\n\t\treturn 0;\n\n\twrite = isl_union_map_copy(prog->may_write);\n\tspace = isl_set_universe(isl_space_copy(array->space));\n\twrite = isl_union_map_intersect_range(write,\n\t\t\t\t\t\tisl_union_set_from_set(space));\n\tempty = isl_union_map_is_empty(write);\n\tisl_union_map_free(write);\n\n\treturn empty;\n}\n\n/* Is \"array\" only accessed as individual, fixed elements?\n * That is, does each access to \"array\" access a single, fixed element?\n */\nisl_bool only_fixed_element_accessed(struct gpu_array_info *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->n_ref; ++i)\n\t\tif (!array->refs[i]->fixed_element)\n\t\t\treturn isl_bool_false;\n\n\treturn isl_bool_true;\n}\n\n/* Compute bounds on the host array \"pa\" based on the corresponding\n * accessed elements in \"arrays\"\n * and collect all references to the array.\n * Store the results in \"info\".\n *\n * If the array is zero-dimensional and does not contain structures,\n * i.e., if the array is a scalar, we check whether it is read-only.\n * We also check whether the array is accessed at all.\n */\nstatic int extract_array_info(struct gpu_prog *prog,\n\tstruct gpu_array_info *info, struct pet_array *pa,\n\t__isl_keep isl_union_set *arrays)\n{\n\tint empty;\n\tconst char *name;\n\tint n_index;\n\tisl_multi_pw_aff *bounds;\n\tisl_set *accessed, *extent;\n\n\tn_index = isl_set_dim(pa->extent, isl_dim_set);\n\tname = isl_set_get_tuple_name(pa->extent);\n\n\tinfo->space = isl_set_get_space(pa->extent);\n\tinfo->name = strdup(name);\n\tinfo->n_index = n_index;\n\tinfo->linearize = prog->scop->options->linearize_device_arrays;\n\n\tinfo->type = strdup(pa->element_type);\n\tinfo->size = pa->element_size;\n\tinfo->local = pa->declared && !pa->exposed;\n\tinfo->has_compound_element = pa->element_is_record;\n\tinfo->read_only_scalar = is_read_only_scalar(info, prog);\n\n\tinfo->declared_extent = isl_set_copy(pa->extent);\n\taccessed = isl_union_set_extract_set(arrays,\n\t\t\t\t\t    isl_space_copy(info->space));\n\tempty = isl_set_is_empty(accessed);\n\textent = compute_extent(pa, accessed);\n\tisl_set_free(accessed);\n\tinfo->extent = extent;\n\tif (empty < 0)\n\t\treturn -1;\n\tinfo->accessed = !empty;\n\tbounds = ppcg_size_from_extent(isl_set_copy(extent));\n\tbounds = isl_multi_pw_aff_gist(bounds, isl_set_copy(prog->context));\n\tif (!bounds)\n\t\treturn -1;\n\tif (!isl_multi_pw_aff_is_cst(bounds))\n\t\tinfo->linearize = 1;\n\tinfo->bound = bounds;\n\n\tcollect_references(prog, info);\n\tinfo->only_fixed_element = only_fixed_element_accessed(info);\n\n\treturn 0;\n}\n\n/* Remove independence from the order constraints \"order\" on array \"array\".\n * Since the pairs of iterations in the filter relation of an independence\n * are guaranteed to be completely independent by the user, there is\n * no need to ensure that live ranges are ordered along those pairs.\n * We make an exception for local variables, though, as the independence\n * guarantee does not apply to those.\n *\n * The order constraints are used in two places.\n * Those on scalars are used in check_scalar_live_ranges to check if\n * we need to force the scalar to be private.  Any non-local scalar\n * should not be forced scalar if it only appears in independent loops.\n * Those on non-scalars are added to the coincidence constraints\n * in compute_schedule because we do not support any array expansion.\n * Accesses to non-local arrays should not prevent a loop from being\n * considered coincident so we should indeed remove those constraints\n * from the order constraints.\n */\nstatic __isl_give isl_union_map *remove_independences(struct gpu_prog *prog,\n\tstruct gpu_array_info *array, __isl_take isl_union_map *order)\n{\n\t// We do not have independence information in Polly. Hence, make this\n\t// function a no-op.\n\treturn order;\n\tint i;\n\n\tfor (i = 0; i < prog->scop->pet->n_independence; ++i) {\n\t\tstruct pet_independence *pi = prog->scop->pet->independences[i];\n\t\tif (isl_union_set_contains(pi->local, array->space))\n\t\t\tcontinue;\n\n\t\torder = isl_union_map_subtract(order,\n\t\t\t\t\t\tisl_union_map_copy(pi->filter));\n\t}\n\n\treturn order;\n}\n\n/* For each array in \"prog\", store the (untagged) order dependences\n * derived from the array in array->dep_order.\n * In particular, consider all references that access the given array\n * and take the order dependences that have one of these references\n * as source.  (Since an order dependence relates two references to\n * the same array, the target of these order dependences will also\n * be one of these references.)\n * Additionally, store the union of these array->dep_order relations\n * for all arrays that cannot be mapped to private memory in prog->array_order.\n */\nvoid collect_order_dependences(struct gpu_prog *prog)\n{\n\tint i;\n\tisl_space *space;\n\tisl_union_map *accesses;\n\n\tspace = isl_union_map_get_space(prog->read);\n\tprog->array_order = isl_union_map_empty(space);\n\n\taccesses = isl_union_map_copy(prog->scop->tagged_reads);\n\taccesses = isl_union_map_union(accesses,\n\t\t\t    isl_union_map_copy(prog->scop->tagged_may_writes));\n\taccesses = isl_union_map_universe(accesses);\n\taccesses = isl_union_map_apply_range(accesses,\n\t\t\t\t\t    isl_union_map_copy(prog->to_outer));\n\n\tfor (i = 0; i < prog->n_array; ++i) {\n\t\tstruct gpu_array_info *array = &prog->array[i];\n\t\tisl_set *set;\n\t\tisl_union_set *uset;\n\t\tisl_union_map *order;\n\n\t\tset = isl_set_universe(isl_space_copy(array->space));\n\t\tuset = isl_union_set_from_set(set);\n\t\tuset = isl_union_map_domain(\n\t\t    isl_union_map_intersect_range(isl_union_map_copy(accesses),\n\t\t\t\t\t\t    uset));\n\t\torder = isl_union_map_copy(prog->scop->tagged_dep_order);\n\t\torder = isl_union_map_intersect_domain(order, uset);\n\t\torder = isl_union_map_zip(order);\n\t\torder = isl_union_set_unwrap(isl_union_map_domain(order));\n\t\torder = remove_independences(prog, array, order);\n\t\tarray->dep_order = order;\n\n\t\tif (gpu_array_can_be_private(array))\n\t\t\tcontinue;\n\n\t\tprog->array_order = isl_union_map_union(prog->array_order,\n\t\t\t\t\tisl_union_map_copy(array->dep_order));\n\t}\n\n\tisl_union_map_free(accesses);\n}\n\n/* Construct a gpu_array_info for each array referenced by prog->scop and\n * collect them in prog->array.\n *\n * The sizes are based on the extents and the set of possibly accessed\n * elements by \"prog\".\n * If there are any member accesses involved, then they are first mapped\n * to the outer arrays of structs.\n * Only extract gpu_array_info entries for these outer arrays.\n *\n * If we are allowing live range reordering, then also set\n * the dep_order field.  Otherwise leave it NULL.\n */\nstatic int collect_array_info(struct gpu_prog *prog)\n{\n\tint i;\n\tint r = 0;\n\tisl_union_set *arrays;\n\n\tarrays = isl_union_map_range(isl_union_map_copy(prog->read));\n\tarrays = isl_union_set_union(arrays,\n\t\t    isl_union_map_range(isl_union_map_copy(prog->may_write)));\n\n\tarrays = isl_union_set_apply(arrays,\n\t\t\t\t\tisl_union_map_copy(prog->to_outer));\n\n\tarrays = isl_union_set_coalesce(arrays);\n\n\tprog->n_array = prog->scop->pet->n_array;\n\tprog->array = isl_calloc_array(prog->ctx,\n\t\t\t\t     struct gpu_array_info, prog->n_array);\n\tassert(prog->array);\n\tprog->n_array = 0;\n\tfor (i = 0; i < prog->scop->pet->n_array; ++i) {\n\t\tisl_bool field;\n\n\t\tfield = isl_set_is_wrapping(prog->scop->pet->arrays[i]->extent);\n\t\tif (field < 0)\n\t\t\tbreak;\n\t\tif (field)\n\t\t\tcontinue;\n\t\tif (extract_array_info(prog, &prog->array[prog->n_array++],\n\t\t\t\t\tprog->scop->pet->arrays[i], arrays) < 0)\n\t\t\tr = -1;\n\t}\n\tif (i < prog->scop->pet->n_array)\n\t\tr = -1;\n\n\tisl_union_set_free(arrays);\n\n\tif (prog->scop->options->live_range_reordering)\n\t\tcollect_order_dependences(prog);\n\n\treturn r;\n}\n\nstatic void free_array_info(struct gpu_prog *prog)\n{\n\tint i;\n\n\tfor (i = 0; i < prog->n_array; ++i) {\n\t\tfree(prog->array[i].type);\n\t\tfree(prog->array[i].name);\n\t\tisl_multi_pw_aff_free(prog->array[i].bound);\n\t\tisl_ast_expr_free(prog->array[i].bound_expr);\n\t\tisl_space_free(prog->array[i].space);\n\t\tisl_set_free(prog->array[i].declared_extent);\n\t\tisl_set_free(prog->array[i].extent);\n\t\tisl_ast_expr_free(prog->array[i].declared_size);\n\t\tfree(prog->array[i].refs);\n\t\tisl_union_map_free(prog->array[i].dep_order);\n\t}\n\tfree(prog->array);\n}\n\n/* Check if a gpu array is a scalar.  A scalar is a value that is not stored\n * as an array or through a pointer reference, but as a single data element.\n * At the moment, scalars are represented as zero-dimensional arrays.\n * Note that the single data element may be an entire structure.\n */\nint gpu_array_is_scalar(struct gpu_array_info *array)\n{\n\treturn array->n_index == 0;\n}\n\n/* Can \"array\" be mapped to private memory?\n * That is, is it only accessed as individual elements with\n * constant index expressions?\n */\nisl_bool gpu_array_can_be_private(struct gpu_array_info *array)\n{\n\tif (!array)\n\t\treturn isl_bool_error;\n\treturn array->only_fixed_element;\n}\n\n/* Is \"array\" a read-only scalar?\n */\nint gpu_array_is_read_only_scalar(struct gpu_array_info *array)\n{\n\treturn array->read_only_scalar;\n}\n\n/* Does \"array\" need to be allocated on the device?\n * If it is a read-only scalar, then it will be passed as an argument\n * to the kernel and therefore does not require any allocation.\n * If this device memory is not accessed at all, then it does not\n * need to be allocated either.\n */\nint gpu_array_requires_device_allocation(struct gpu_array_info *array)\n{\n\tif (gpu_array_is_read_only_scalar(array))\n\t\treturn 0;\n\tif (!array->global)\n\t\treturn 0;\n\treturn 1;\n}\n\n/* Return the set of parameter values for which the array has a positive\n * size in all dimensions.\n * If the sizes are only valid for some parameter values, then those\n * constraints are also taken into account.\n */\n__isl_give isl_set *gpu_array_positive_size_guard(struct gpu_array_info *array)\n{\n\tint i;\n\tisl_space *space;\n\tisl_set *guard;\n\n\tif (!array)\n\t\treturn NULL;\n\n\tspace = isl_space_params(isl_space_copy(array->space));\n\tguard = isl_set_universe(space);\n\n\tfor (i = 0; i < array->n_index; ++i) {\n\t\tisl_pw_aff *bound;\n\t\tisl_set *guard_i, *zero;\n\n\t\tbound = isl_multi_pw_aff_get_pw_aff(array->bound, i);\n\t\tguard_i = isl_pw_aff_nonneg_set(isl_pw_aff_copy(bound));\n\t\tzero = isl_pw_aff_zero_set(bound);\n\t\tguard_i = isl_set_subtract(guard_i, zero);\n\t\tguard = isl_set_intersect(guard, guard_i);\n\t}\n\n\treturn guard;\n}\n\n/* Internal data structure for extract_size_of_type.\n * \"type\" specifies the name of the space that we want to extract.\n * \"res\" is used to store the subset of that space.\n */\nstruct ppcg_extract_size_data {\n\tconst char *type;\n\tisl_set *res;\n};\n\n/* This function is called for each set in a union_set.\n * If the name of the set matches data->type, we store the\n * set in data->res.\n */\nstatic isl_stat extract_size_of_type(__isl_take isl_set *size, void *user)\n{\n\tstruct ppcg_extract_size_data *data = user;\n\tconst char *name;\n\n\tname = isl_set_get_tuple_name(size);\n\tif (name && !strcmp(name, data->type)) {\n\t\tdata->res = size;\n\t\treturn isl_stat_error;\n\t}\n\n\tisl_set_free(size);\n\treturn isl_stat_ok;\n}\n\n/* Given a union map { kernel[i] -> *[...] },\n * return the range in the space called \"type\" for the kernel with\n * sequence number \"id\".\n */\nstatic __isl_give isl_set *extract_sizes(__isl_keep isl_union_map *sizes,\n\tconst char *type, int id)\n{\n\tisl_space *space;\n\tisl_set *dom;\n\tisl_union_set *local_sizes;\n\tstruct ppcg_extract_size_data data = { type, NULL };\n\n\tif (!sizes)\n\t\treturn NULL;\n\n\tspace = isl_union_map_get_space(sizes);\n\tspace = isl_space_set_from_params(space);\n\tspace = isl_space_add_dims(space, isl_dim_set, 1);\n\tspace = isl_space_set_tuple_name(space, isl_dim_set, \"kernel\");\n\tdom = isl_set_universe(space);\n\tdom = isl_set_fix_si(dom, isl_dim_set, 0, id);\n\n\tlocal_sizes = isl_union_set_apply(isl_union_set_from_set(dom),\n\t\t\t\t\tisl_union_map_copy(sizes));\n\tisl_union_set_foreach_set(local_sizes, &extract_size_of_type, &data);\n\tisl_union_set_free(local_sizes);\n\treturn data.res;\n}\n\n/* Given a singleton set, extract the first (at most *len) elements\n * of the single integer tuple into *sizes and update *len if needed.\n */\nstatic void read_sizes_from_set(__isl_take isl_set *set, int *sizes, int *len)\n{\n\tint i;\n\tint dim;\n\n\tif (!set)\n\t\treturn;\n\n\tdim = isl_set_dim(set, isl_dim_set);\n\tif (dim < *len)\n\t\t*len = dim;\n\n\tfor (i = 0; i < *len; ++i) {\n\t\tisl_val *v;\n\n\t\tv = isl_set_plain_get_val_if_fixed(set, isl_dim_set, i);\n\t\tassert(v);\n\n\t\tsizes[i] = isl_val_get_num_si(v);\n\t\tisl_val_free(v);\n\t}\n\n\tisl_set_free(set);\n}\n\n/* Add the map { kernel[id] -> type[sizes] } to gen->used_sizes,\n * if the option debug->dump_sizes is set.\n */\nstatic void set_used_sizes(struct gpu_gen *gen, const char *type, int id,\n\tint *sizes, int len)\n{\n\tint i;\n\tisl_space *space;\n\tisl_map *map;\n\n\tif (!gen->options->debug->dump_sizes)\n\t\treturn;\n\n\tspace = isl_union_map_get_space(gen->used_sizes);\n\tspace = isl_space_set_from_params(space);\n\tspace = isl_space_add_dims(space, isl_dim_set, 1);\n\tspace = isl_space_set_tuple_name(space, isl_dim_set, \"kernel\");\n\tspace = isl_space_from_domain(space);\n\tspace = isl_space_add_dims(space, isl_dim_out, len);\n\tspace = isl_space_set_tuple_name(space, isl_dim_out, type);\n\n\tmap = isl_map_universe(space);\n\tmap = isl_map_fix_si(map, isl_dim_in, 0, id);\n\tfor (i = 0; i < len; ++i)\n\t\tmap = isl_map_fix_si(map, isl_dim_out, i, sizes[i]);\n\n\tgen->used_sizes = isl_union_map_add_map(gen->used_sizes, map);\n}\n\n/* Extract user specified \"tile\" sizes from the \"sizes\" command line option,\n * defaulting to option->tile_size in each dimension.\n * *tile_len contains the maximum number of tile sizes needed.\n * Update *tile_len to the number of specified tile sizes, if any, and\n * return a pointer to the tile sizes (or NULL on error).\n * Add the effectively used sizes to gen->used_sizes.\n */\nstatic int *read_tile_sizes(struct gpu_gen *gen, int *tile_len)\n{\n\tint n;\n\tint *tile_size;\n\tisl_set *size;\n\n\ttile_size = isl_alloc_array(gen->ctx, int, *tile_len);\n\tif (!tile_size)\n\t\treturn NULL;\n\tfor (n = 0; n < *tile_len; ++n)\n\t\ttile_size[n] = gen->options->tile_size;\n\n\tsize = extract_sizes(gen->sizes, \"tile\", gen->kernel_id);\n\tread_sizes_from_set(size, tile_size, tile_len);\n\tset_used_sizes(gen, \"tile\", gen->kernel_id, tile_size, *tile_len);\n\n\treturn tile_size;\n}\n\n/* Extract user specified \"block\" sizes from the \"sizes\" command line option,\n * after filling in some potentially useful defaults.\n */\nstatic void read_block_sizes(struct ppcg_kernel *kernel,\n\t__isl_keep isl_union_map *sizes)\n{\n\tisl_set *size;\n\n\tif (kernel->n_block > 3)\n\t\tkernel->n_block = 3;\n\tswitch (kernel->n_block) {\n\tcase 1:\n\t\tkernel->block_dim[0] = 512;\n\t\tbreak;\n\tcase 2:\n\t\tkernel->block_dim[0] = 32;\n\t\tkernel->block_dim[1] = 16;\n\t\tbreak;\n\tdefault:\n\t\tkernel->block_dim[0] = 32;\n\t\tkernel->block_dim[1] = 4;\n\t\tkernel->block_dim[2] = 4;\n\t\tbreak;\n\t}\n\n\tsize = extract_sizes(sizes, \"block\", kernel->id);\n\tread_sizes_from_set(size, kernel->block_dim, &kernel->n_block);\n}\n\n/* Extract user specified \"grid\" sizes from the \"sizes\" command line option,\n * after filling in some potentially useful defaults.\n */\nstatic void read_grid_sizes(struct ppcg_kernel *kernel,\n\t__isl_keep isl_union_map *sizes)\n{\n\tisl_set *size;\n\n\tif (kernel->n_grid > 2)\n\t\tkernel->n_grid = 2;\n\tswitch (kernel->n_grid) {\n\tcase 1:\n\t\tkernel->grid_dim[0] = 32768;\n\t\tbreak;\n\tdefault:\n\t\tkernel->grid_dim[0] = 256;\n\t\tkernel->grid_dim[1] = 256;\n\t\tbreak;\n\t}\n\n\tsize = extract_sizes(sizes, \"grid\", kernel->id);\n\tread_sizes_from_set(size, kernel->grid_dim, &kernel->n_grid);\n}\n\n/* Extract user specified grid and block sizes from the gen->sizes\n * command line option after filling in some potentially useful defaults.\n * Store the extracted sizes in \"kernel\".\n * Add the effectively used sizes to gen->used_sizes.\n */\nstatic void read_grid_and_block_sizes(struct ppcg_kernel *kernel,\n\tstruct gpu_gen *gen)\n{\n\tread_block_sizes(kernel, gen->sizes);\n\tread_grid_sizes(kernel, gen->sizes);\n\tset_used_sizes(gen, \"block\", kernel->id,\n\t\t\t\t\t    kernel->block_dim, kernel->n_block);\n\tset_used_sizes(gen, \"grid\", kernel->id,\n\t\t\t\t\t    kernel->grid_dim, kernel->n_grid);\n}\n\nstatic void *free_stmts(struct gpu_stmt *stmts, int n)\n{\n\tint i;\n\n\tif (!stmts)\n\t\treturn NULL;\n\n\tfor (i = 0; i < n; ++i) {\n\t\tstruct gpu_stmt_access *access, *next;\n\n\t\tfor (access = stmts[i].accesses; access; access = next) {\n\t\t\tnext = access->next;\n\t\t\tisl_id_free(access->ref_id);\n\t\t\tisl_map_free(access->access);\n\t\t\tisl_map_free(access->tagged_access);\n\t\t\tfree(access);\n\t\t}\n\n\t\tisl_id_free(stmts[i].id);\n\t}\n\tfree(stmts);\n\n\treturn NULL;\n}\n\n/* Add parameters p[i] with identifiers \"ids\" to \"set\",\n * with bounds to 0 <= p[i] < size[i].\n */\n__isl_give isl_set *add_bounded_parameters(__isl_take isl_set *set,\n\tint *size, __isl_keep isl_id_list *ids)\n{\n\tint i, len;\n\tunsigned nparam;\n\n\tlen = isl_id_list_n_id(ids);\n\tnparam = isl_set_dim(set, isl_dim_param);\n\tset = isl_set_add_dims(set, isl_dim_param, len);\n\n\tfor (i = 0; i < len; ++i) {\n\t\tisl_id *id;\n\n\t\tid = isl_id_list_get_id(ids, i);\n\t\tset = isl_set_set_dim_id(set, isl_dim_param, nparam + i, id);\n\t\tset = isl_set_lower_bound_si(set, isl_dim_param, nparam + i, 0);\n\t\tset = isl_set_upper_bound_si(set, isl_dim_param,\n\t\t\t\t\t    nparam + i, size[i] - 1);\n\t}\n\n\treturn set;\n}\n\n/* Add \"len\" parameters p[i] with identifiers \"ids\" and intersect \"set\"\n * with\n *\n *\t{ : 0 <= p[i] < size[i] }\n *\n * or an overapproximation.\n */\nstatic __isl_give isl_set *add_bounded_parameters_dynamic(\n\t__isl_take isl_set *set, __isl_keep isl_multi_pw_aff *size,\n\t__isl_keep isl_id_list *ids)\n{\n\tint i, len;\n\tunsigned nparam;\n\tisl_space *space;\n\tisl_local_space *ls;\n\n\tlen = isl_multi_pw_aff_dim(size, isl_dim_out);\n\tnparam = isl_set_dim(set, isl_dim_param);\n\tset = isl_set_add_dims(set, isl_dim_param, len);\n\n\tfor (i = 0; i < len; ++i) {\n\t\tisl_id *id;\n\n\t\tid = isl_id_list_get_id(ids, i);\n\t\tset = isl_set_set_dim_id(set, isl_dim_param, nparam + i, id);\n\t}\n\n\tspace = isl_space_params(isl_set_get_space(set));\n\tls = isl_local_space_from_space(space);\n\tfor (i = 0; i < len; ++i) {\n\t\tisl_pw_aff *param, *size_i, *zero;\n\t\tisl_set *bound;\n\n\t\tparam = isl_pw_aff_var_on_domain(isl_local_space_copy(ls),\n\t\t\t\t\t\tisl_dim_param, nparam + i);\n\n\t\tsize_i = isl_multi_pw_aff_get_pw_aff(size, i);\n\t\tbound = isl_pw_aff_lt_set(isl_pw_aff_copy(param), size_i);\n\t\tbound = isl_set_from_basic_set(isl_set_simple_hull(bound));\n\t\tset = isl_set_intersect_params(set, bound);\n\n\t\tzero = isl_pw_aff_zero_on_domain(isl_local_space_copy(ls));\n\t\tbound = isl_pw_aff_ge_set(param, zero);\n\t\tset = isl_set_intersect_params(set, bound);\n\t}\n\tisl_local_space_free(ls);\n\n\treturn set;\n}\n\n/* Return the union of all tagged access relations in the group.\n */\nstatic __isl_give isl_union_map *group_tagged_access_relation(\n\tstruct gpu_array_ref_group *group)\n{\n\tint i;\n\tisl_union_map *access;\n\n\taccess = isl_union_map_empty(isl_map_get_space(group->access));\n\tfor (i = 0; i < group->n_ref; ++i) {\n\t\tisl_map *map_i;\n\n\t\tmap_i = isl_map_copy(group->refs[i]->tagged_access);\n\t\taccess = isl_union_map_union(access,\n\t\t\t\t\t    isl_union_map_from_map(map_i));\n\t}\n\n\treturn access;\n}\n\n/* Return the extent of \"array\", recomputed from the bounds.\n * The recomputed extent may be simpler than the original extent.\n */\nstatic __isl_give isl_set *array_extent(struct gpu_array_info *array)\n{\n\tint i;\n\tisl_id *id;\n\tisl_space *space;\n\tisl_local_space *ls;\n\tisl_set *extent;\n\n\tid = isl_set_get_tuple_id(array->extent);\n\tspace = isl_set_get_space(array->extent);\n\textent = isl_set_universe(isl_space_copy(space));\n\tls = isl_local_space_from_space(space);\n\tfor (i = 0; i < array->n_index; ++i) {\n\t\tisl_pw_aff *bound;\n\t\tisl_aff *aff;\n\t\tisl_pw_aff *index;\n\t\tisl_set *lt;\n\n\t\textent = isl_set_lower_bound_si(extent, isl_dim_set, i, 0);\n\n\t\taff = isl_aff_var_on_domain(isl_local_space_copy(ls),\n\t\t\t\t\t\tisl_dim_set, i);\n\t\tindex = isl_pw_aff_from_aff(aff);\n\t\tbound = isl_multi_pw_aff_get_pw_aff(array->bound, i);\n\t\tbound = isl_pw_aff_from_range(bound);\n\t\tbound = isl_pw_aff_add_dims(bound, isl_dim_in, array->n_index);\n\t\tbound = isl_pw_aff_set_tuple_id(bound, isl_dim_in,\n\t\t\t\t\t\tisl_id_copy(id));\n\t\tlt = isl_pw_aff_lt_set(index, bound);\n\t\textent = isl_set_intersect(extent, lt);\n\t}\n\tisl_local_space_free(ls);\n\tisl_id_free(id);\n\n\treturn extent;\n}\n\n/* Return a map from the first group->shared_tile->depth dimensions\n * of the computed schedule to the array tile in\n * global memory that corresponds to the shared memory copy.\n *\n * In particular, return a map\n *\n *\t{ D[i] -> A[a] }\n *\n * with constraints\n *\n *\ttile_offset(i) <= a <= tile_offset(i) + tile_size - 1\t\t(1)\n *\n * and\n *\n *\t0 <= a <= array_size - 1\t\t\t\t\t(2)\n *\n * Note that if some stride has been detected (i.e., when\n * group->shared_tile->bound[i].shift is set), then a in (1) refers\n * to the shifted and scaled down version.\n *\n * Constraints (1) are obtained by mapping the size constraints on the\n * shared/private memory tile back to the access relation.\n * Constraints (2) are obtained from the (recomputed) extent.\n */\nstatic __isl_give isl_map *group_tile(struct gpu_array_ref_group *group)\n{\n\tint i;\n\tint n_index = group->array->n_index;\n\tisl_map *tile;\n\tisl_space *space;\n\tisl_set *local;\n\tisl_set *extent;\n\n\tspace = isl_multi_aff_get_space(group->shared_tile->tiling);\n\tspace = isl_space_range(space);\n\tlocal = isl_set_universe(space);\n\tfor (i = 0; i < n_index; ++i) {\n\t\tisl_val *bound;\n\n\t\tlocal = isl_set_lower_bound_si(local, isl_dim_set, i, 0);\n\t\tbound = isl_val_copy(group->shared_tile->bound[i].size);\n\t\tbound = isl_val_sub_ui(bound, 1);\n\t\tlocal = isl_set_upper_bound_val(local, isl_dim_set, i, bound);\n\t}\n\tlocal = isl_set_preimage_multi_aff(local,\n\t\t\t\tisl_multi_aff_copy(group->shared_tile->tiling));\n\ttile = isl_set_unwrap(local);\n\textent = array_extent(group->array);\n\ttile = isl_map_intersect_range(tile, extent);\n\n\treturn tile;\n}\n\n/* Given a mapping \"iterator_map\" from the AST schedule to a domain,\n * return the corresponding mapping from the AST schedule to\n * to the outer kernel->copy_schedule_dim dimensions of\n * the schedule computed by PPCG for this kernel.\n *\n * Note that kernel->copy_schedule_dim is at least as large as\n * the largest depth of any array reference group associated to the kernel.\n * This is needed as the returned schedule is used to extract a mapping\n * to the outer tile->depth dimensions in transform_index.\n */\nstatic __isl_give isl_pw_multi_aff *compute_sched_to_copy(\n\tstruct ppcg_kernel *kernel, __isl_take isl_pw_multi_aff *iterator_map)\n{\n\tisl_union_pw_multi_aff *upma;\n\tisl_pw_multi_aff *pma;\n\tisl_space *space;\n\n\tspace = isl_space_range(isl_pw_multi_aff_get_space(iterator_map));\n\tspace = isl_space_from_domain(space);\n\tspace = isl_space_add_dims(space, isl_dim_out,\n\t\t\t\t\tkernel->copy_schedule_dim);\n\n\tupma = isl_union_pw_multi_aff_copy(kernel->copy_schedule);\n\tpma = isl_union_pw_multi_aff_extract_pw_multi_aff(upma, space);\n\tisl_union_pw_multi_aff_free(upma);\n\n\treturn isl_pw_multi_aff_pullback_pw_multi_aff(pma, iterator_map);\n}\n\n/* If max_shared_memory is not set to infinity (-1), then make\n * sure that the total amount of shared memory required by the\n * array reference groups mapped to shared memory by \"kernel\"\n * is no larger than this maximum.\n *\n * We apply a greedy approach and discard (keep in global memory)\n * those groups that would result in a total memory size that\n * is larger than the maximum.\n *\n * This function should be called after any function that may\n * affect the decision on whether to place a reference group\n * in private, shared or global memory.\n */\nstatic void check_shared_memory_bound(struct ppcg_kernel *kernel)\n{\n\tint i, j;\n\tisl_val *left, *size;\n\n\tif (kernel->options->max_shared_memory < 0)\n\t\treturn;\n\n\tleft = isl_val_int_from_si(kernel->ctx,\n\t\t\t\t    kernel->options->max_shared_memory);\n\n\tfor (i = 0; i < kernel->n_array; ++i) {\n\t\tstruct gpu_local_array_info *local = &kernel->array[i];\n\n\t\tfor (j = 0; j < local->n_group; ++j) {\n\t\t\tstruct gpu_array_ref_group *group;\n\t\t\tenum ppcg_group_access_type type;\n\n\t\t\tgroup = local->groups[j];\n\t\t\ttype = gpu_array_ref_group_type(group);\n\t\t\tif (type != ppcg_access_shared)\n\t\t\t\tcontinue;\n\n\t\t\tsize = gpu_array_tile_size(group->shared_tile);\n\t\t\tsize = isl_val_mul_ui(size, local->array->size);\n\n\t\t\tif (isl_val_le(size, left)) {\n\t\t\t\tleft = isl_val_sub(left, size);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tisl_val_free(size);\n\n\t\t\tgroup->shared_tile =\n\t\t\t\t\tgpu_array_tile_free(group->shared_tile);\n\t\t}\n\t}\n\n\tisl_val_free(left);\n}\n\n/* Mark all arrays of \"kernel\" that have an array reference group\n * that is not mapped to private or shared memory as\n * accessing the corresponding global device memory.\n */\nstatic void mark_global_arrays(struct ppcg_kernel *kernel)\n{\n\tint i, j;\n\n\tfor (i = 0; i < kernel->n_array; ++i) {\n\t\tstruct gpu_local_array_info *local = &kernel->array[i];\n\n\t\tif (local->global)\n\t\t\tcontinue;\n\t\tfor (j = 0; j < local->n_group; ++j) {\n\t\t\tif (gpu_array_ref_group_tile(local->groups[j]))\n\t\t\t\tcontinue;\n\n\t\t\tlocal->global = 1;\n\t\t\tlocal->array->global = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/* Compute a tiling for all the array reference groups in \"kernel\".\n */\nstatic void compute_group_tilings(struct ppcg_kernel *kernel)\n{\n\tint i, j;\n\n\tfor (i = 0; i < kernel->n_array; ++i) {\n\t\tstruct gpu_local_array_info *array = &kernel->array[i];\n\n\t\tfor (j = 0; j < array->n_group; ++j)\n\t\t\tgpu_array_ref_group_compute_tiling(array->groups[j]);\n\t}\n}\n\n/* Compute the effective grid size as a list of the sizes in each dimension.\n *\n * The grid size specified by the user or set by default\n * in read_grid_sizes() and applied by the block filter,\n * may be too large for the given code in the sense that\n * it may contain blocks that don't need to execute anything.\n * We therefore don't return this grid size, but instead the\n * smallest grid size that ensures that all blocks that actually\n * execute code are included in the grid.\n *\n * We first extract a description of the grid, i.e., the possible values\n * of the block ids, from the domain elements in \"domain\" and\n * kernel->block_filter.\n * The block ids are parameters in kernel->block_filter.\n * We simply need to change them into set dimensions.\n *\n * Then, for each block dimension, we compute the maximal value of the block id\n * and add one.\n */\nstatic __isl_give isl_multi_pw_aff *extract_grid_size(\n\tstruct ppcg_kernel *kernel, __isl_take isl_union_set *domain)\n{\n\tint i;\n\tisl_set *grid;\n\tisl_set *context;\n\tisl_multi_pw_aff *size;\n\n\tdomain = isl_union_set_intersect(domain,\n\t\t\t\t    isl_union_set_copy(kernel->block_filter));\n\tgrid = isl_union_set_params(domain);\n\tgrid = isl_set_from_params(grid);\n\tgrid = isl_set_add_dims(grid, isl_dim_set, kernel->n_grid);\n\tfor (i = 0; i < kernel->n_grid; ++i) {\n\t\tint pos;\n\t\tisl_id *id;\n\n\t\tid = isl_id_list_get_id(kernel->block_ids, i);\n\t\tpos = isl_set_find_dim_by_id(grid, isl_dim_param, id);\n\t\tisl_id_free(id);\n\t\tassert(pos >= 0);\n\t\tgrid = isl_set_equate(grid, isl_dim_param, pos, isl_dim_set, i);\n\t\tgrid = isl_set_project_out(grid, isl_dim_param, pos, 1);\n\t}\n\n\tgrid = isl_set_coalesce(grid);\n\tsize = ppcg_size_from_extent(grid);\n\tcontext = isl_set_params(isl_set_copy(kernel->context));\n\treturn isl_multi_pw_aff_gist(size, context);\n}\n\n/* Compute the size of a fixed bounding box around the origin and \"set\",\n * where \"set\" is assumed to contain only non-negative elements,\n * and store the results in \"size\".\n * In particular, compute the maximal value of \"set\" in each direction\n * and add one.\n */\nstatic void extract_fixed_size(__isl_take isl_set *set, int *size)\n{\n\tint i, n;\n\tisl_local_space *ls;\n\tisl_aff *obj;\n\n\tn = isl_set_dim(set, isl_dim_set);\n\tls = isl_local_space_from_space(isl_set_get_space(set));\n\tobj = isl_aff_zero_on_domain(ls);\n\tfor (i = 0; i < n; ++i) {\n\t\tisl_val *max;\n\n\t\tobj = isl_aff_set_coefficient_si(obj, isl_dim_in, i, 1);\n\t\tmax = isl_set_max_val(set, obj);\n\t\tsize[i] = isl_val_get_num_si(max) + 1;\n\t\tisl_val_free(max);\n\t\tobj = isl_aff_set_coefficient_si(obj, isl_dim_in, i, 0);\n\t}\n\tisl_aff_free(obj);\n\tisl_set_free(set);\n}\n\n/* Compute the effective block size as a list of the sizes in each dimension\n * and store the sizes in kernel->block_dim.\n *\n * The block size specified by the user or set by default\n * in read_block_sizes() and applied by the thread filter,\n * may be too large for the given code in the sense that\n * it may contain threads that don't need to execute anything.\n * We therefore update this block size in kernel->block_dim\n * to the smallest block size that ensures that all threads\n * that actually execute code are included in the block.\n *\n * The set of possible values of the thread ids is obtained from\n * the domain elements \"domain\" and kernel->thread_filter.\n * The current implementation eliminates all parameters, ensuring\n * that the size is a fixed constant in each dimension.\n * In principle we could also compute parametric sizes.\n * We would have to make sure to project out all b%d and t%d parameters,\n * however.\n */\nstatic isl_stat extract_block_size(struct ppcg_kernel *kernel,\n\t__isl_take isl_union_set *domain)\n{\n\tint i;\n\tint nparam;\n\tisl_set *block;\n\n\tdomain = isl_union_set_intersect(domain,\n\t\t\t\t    isl_union_set_copy(kernel->thread_filter));\n\tblock = isl_union_set_params(domain);\n\tblock = isl_set_from_params(block);\n\tblock = isl_set_add_dims(block, isl_dim_set, kernel->n_block);\n\tfor (i = 0; i < kernel->n_block; ++i) {\n\t\tint pos;\n\t\tisl_id *id;\n\n\t\tif (!block)\n\t\t\treturn isl_stat_error;\n\n\t\tid = isl_id_list_get_id(kernel->thread_ids, i);\n\t\tpos = isl_set_find_dim_by_id(block, isl_dim_param, id);\n\t\tisl_id_free(id);\n\t\tif (pos < 0)\n\t\t\tisl_die(isl_set_get_ctx(block), isl_error_internal,\n\t\t\t\t\"missing constraints on thread identifier\",\n\t\t\t\tblock = isl_set_free(block));\n\t\tblock = isl_set_equate(block, isl_dim_param, pos,\n\t\t\t\t\tisl_dim_set, i);\n\t}\n\tnparam = isl_set_dim(block, isl_dim_param);\n\tblock = isl_set_project_out(block, isl_dim_param, 0, nparam);\n\n\tif (!block)\n\t\treturn isl_stat_error;\n\n\textract_fixed_size(block, kernel->block_dim);\n\n\treturn isl_stat_ok;\n}\n\nstruct ppcg_kernel *ppcg_kernel_free(struct ppcg_kernel *kernel)\n{\n\tint i, j;\n\n\tif (!kernel)\n\t\treturn NULL;\n\n\tisl_id_list_free(kernel->block_ids);\n\tisl_id_list_free(kernel->thread_ids);\n\tisl_multi_pw_aff_free(kernel->grid_size);\n\tisl_ast_expr_free(kernel->grid_size_expr);\n\tisl_set_free(kernel->context);\n\tisl_union_set_free(kernel->core);\n\tisl_union_set_free(kernel->arrays);\n\tisl_union_pw_multi_aff_free(kernel->contraction);\n\tisl_union_set_free(kernel->expanded_domain);\n\tisl_space_free(kernel->space);\n\tisl_ast_node_free(kernel->tree);\n\tisl_union_set_free(kernel->block_filter);\n\tisl_union_set_free(kernel->thread_filter);\n\tisl_union_pw_multi_aff_free(kernel->copy_schedule);\n\tisl_union_set_free(kernel->sync_writes);\n\n\tfor (i = 0; i < kernel->n_array; ++i) {\n\t\tstruct gpu_local_array_info *array = &kernel->array[i];\n\n\t\tfor (j = 0; j < array->n_group; ++j)\n\t\t\tgpu_array_ref_group_free(array->groups[j]);\n\t\tfree(array->groups);\n\n\t\tisl_multi_pw_aff_free(array->bound);\n\t\tisl_ast_expr_free(array->bound_expr);\n\t}\n\tfree(kernel->array);\n\n\tfor (i = 0; i < kernel->n_var; ++i) {\n\t\tfree(kernel->var[i].name);\n\t\tisl_vec_free(kernel->var[i].size);\n\t}\n\tfree(kernel->var);\n\n\tfree(kernel);\n\n\treturn NULL;\n}\n\n/* Wrapper around ppcg_kernel_free for use as a isl_id_set_free_user callback.\n */\nstatic void ppcg_kernel_free_wrap(void *user)\n{\n\tstruct ppcg_kernel *kernel = user;\n\n\tppcg_kernel_free(kernel);\n}\n\nstatic void create_kernel_var(isl_ctx *ctx, struct gpu_array_ref_group *group,\n\tstruct ppcg_kernel_var *var)\n{\n\tint j;\n\tstruct gpu_array_tile *tile;\n\tisl_printer *p;\n\n\tvar->array = group->array;\n\n\tvar->type = gpu_array_ref_group_type(group);\n\ttile = gpu_array_ref_group_tile(group);\n\n\tp = isl_printer_to_str(ctx);\n\tp = gpu_array_ref_group_print_name(group, p);\n\tvar->name = isl_printer_get_str(p);\n\tisl_printer_free(p);\n\n\tvar->size = isl_vec_alloc(ctx, group->array->n_index);\n\n\tfor (j = 0; j < group->array->n_index; ++j)\n\t\tvar->size = isl_vec_set_element_val(var->size, j,\n\t\t\t\t\t    isl_val_copy(tile->bound[j].size));\n}\n\nstatic int create_kernel_vars(struct ppcg_kernel *kernel)\n{\n\tint i, j, n;\n\n\tn = 0;\n\tfor (i = 0; i < kernel->n_array; ++i) {\n\t\tstruct gpu_local_array_info *array = &kernel->array[i];\n\n\t\tfor (j = 0; j < array->n_group; ++j) {\n\t\t\tstruct gpu_array_ref_group *group = array->groups[j];\n\t\t\tenum ppcg_group_access_type type;\n\n\t\t\ttype = gpu_array_ref_group_type(group);\n\t\t\tif (type != ppcg_access_global)\n\t\t\t\t++n;\n\t\t}\n\t}\n\n\tkernel->n_var = n;\n\tkernel->var = isl_calloc_array(kernel->ctx, struct ppcg_kernel_var, n);\n\tif (!kernel->var)\n\t\treturn -1;\n\n\tn = 0;\n\tfor (i = 0; i < kernel->n_array; ++i) {\n\t\tstruct gpu_local_array_info *array = &kernel->array[i];\n\n\t\tfor (j = 0; j < array->n_group; ++j) {\n\t\t\tstruct gpu_array_ref_group *group = array->groups[j];\n\t\t\tenum ppcg_group_access_type type;\n\n\t\t\ttype = gpu_array_ref_group_type(group);\n\t\t\tif (type == ppcg_access_global)\n\t\t\t\tcontinue;\n\t\t\tcreate_kernel_var(kernel->ctx, group, &kernel->var[n]);\n\t\t\t++n;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/* Replace \"pa\" by the zero function defined over the universe domain\n * in the space of \"pa\".\n */\nstatic __isl_give isl_pw_aff *set_universally_zero(__isl_take isl_pw_aff *pa)\n{\n\tisl_space *space;\n\tisl_aff *zero;\n\n\tspace = isl_space_domain(isl_pw_aff_get_space(pa));\n\tisl_pw_aff_free(pa);\n\tzero = isl_aff_zero_on_domain(isl_local_space_from_space(space));\n\n\treturn isl_pw_aff_from_aff(zero);\n}\n\n/* The sizes of the arrays on the host that have been computed by\n * extract_array_info may depend on the parameters.  Use the extra\n * constraints on the parameters that are valid at \"host_domain\"\n * to simplify these expressions and store the results in kernel->array.\n *\n * We only need these localized bounds for arrays that are accessed\n * by the current kernel.  If we have found at least one reference group\n * then the array is accessed by the kernel.\n *\n * The resulting sizes may be functions that are nowhere defined\n * in case the access function cannot possibly access anything inside\n * the kernel for some reason.  If so, they are replaced by the zero\n * function.  Since the access function cannot actually access anything,\n * there is no harm in printing the array sizes as zero.\n */\nstatic void localize_bounds(struct ppcg_kernel *kernel,\n\t__isl_keep isl_set *host_domain)\n{\n\tint i, j;\n\tisl_set *context;\n\n\tcontext = isl_set_copy(host_domain);\n\tcontext = isl_set_params(context);\n\n\tfor (i = 0; i < kernel->n_array; ++i) {\n\t\tstruct gpu_local_array_info *local = &kernel->array[i];\n\t\tisl_multi_pw_aff *bound;\n\t\tint n_index;\n\n\t\tif (local->n_group == 0)\n\t\t\tcontinue;\n\n\t\tn_index = local->array->n_index;\n\t\tbound = isl_multi_pw_aff_copy(local->array->bound);\n\n\t\tfor (j = 0; j < n_index; ++j) {\n\t\t\tisl_pw_aff *pwaff;\n\t\t\tint empty;\n\n\t\t\tpwaff = isl_multi_pw_aff_get_pw_aff(bound, j);\n\t\t\tpwaff = isl_pw_aff_gist(pwaff, isl_set_copy(context));\n\t\t\tempty = isl_pw_aff_is_empty(pwaff);\n\t\t\tif (empty < 0)\n\t\t\t\tpwaff = isl_pw_aff_free(pwaff);\n\t\t\telse if (empty)\n\t\t\t\tpwaff = set_universally_zero(pwaff);\n\t\t\tbound = isl_multi_pw_aff_set_pw_aff(bound, j, pwaff);\n\t\t}\n\n\t\tlocal->n_index = n_index;\n\t\tlocal->bound = bound;\n\t}\n\tisl_set_free(context);\n}\n\n/* Create the array of gpu_local_array_info structures \"array\"\n * inside \"kernel\".  The number of elements in this array is\n * the same as the number of arrays in \"prog\".\n * Initialize the \"array\" field of each local array to point\n * to the corresponding array in \"prog\".\n */\nstatic struct ppcg_kernel *ppcg_kernel_create_local_arrays(\n\tstruct ppcg_kernel *kernel, struct gpu_prog *prog)\n{\n\tint i;\n\tisl_ctx *ctx;\n\n\tctx = isl_set_get_ctx(prog->context);\n\tkernel->array = isl_calloc_array(ctx,\n\t\t\t    struct gpu_local_array_info, prog->n_array);\n\tif (!kernel->array)\n\t\treturn ppcg_kernel_free(kernel);\n\tkernel->n_array = prog->n_array;\n\n\tfor (i = 0; i < prog->n_array; ++i)\n\t\tkernel->array[i].array = &prog->array[i];\n\n\treturn kernel;\n}\n\n/* Does \"kernel\" need to be passed an argument corresponding to array \"i\"?\n *\n * The argument is only needed if the kernel accesses this device memory.\n */\nint ppcg_kernel_requires_array_argument(struct ppcg_kernel *kernel, int i)\n{\n\treturn kernel->array[i].global;\n}\n\n/* Find the element in gen->stmt that has the given \"id\".\n * Return NULL if no such gpu_stmt can be found.\n */\nstatic struct gpu_stmt *find_stmt(struct gpu_prog *prog, __isl_keep isl_id *id)\n{\n\tint i;\n\n\tfor (i = 0; i < prog->n_stmts; ++i) {\n\t\tif (id == prog->stmts[i].id)\n\t\t\tbreak;\n\t}\n\n\treturn i < prog->n_stmts ? &prog->stmts[i] : NULL;\n}\n\nvoid ppcg_kernel_stmt_free(void *user)\n{\n\tstruct ppcg_kernel_stmt *stmt = user;\n\n\tif (!stmt)\n\t\treturn;\n\n\tswitch (stmt->type) {\n\tcase ppcg_kernel_copy:\n\t\tisl_ast_expr_free(stmt->u.c.index);\n\t\tisl_ast_expr_free(stmt->u.c.local_index);\n\t\tbreak;\n\tcase ppcg_kernel_domain:\n\t\tisl_id_to_ast_expr_free(stmt->u.d.ref2expr);\n\t\tbreak;\n\tcase ppcg_kernel_sync:\n\t\tbreak;\n\t}\n\n\tfree(stmt);\n}\n\n/* Return the gpu_stmt_access in the list \"accesses\" that corresponds\n * to \"ref_id\".\n */\nstatic struct gpu_stmt_access *find_access(struct gpu_stmt_access *accesses,\n\t__isl_keep isl_id *ref_id)\n{\n\tstruct gpu_stmt_access *access;\n\n\tfor (access = accesses; access; access = access->next)\n\t\tif (access->ref_id == ref_id)\n\t\t\treturn access;\n\n\treturn NULL;\n}\n\n/* Return the index of the array called \"name\" in the list of arrays.\n */\nstatic int find_array_index(struct ppcg_kernel *kernel, const char *name)\n{\n\tint i;\n\n\tfor (i = 0; i < kernel->n_array; ++i)\n\t\tif (!strcmp(name, kernel->array[i].array->name))\n\t\t\treturn i;\n\n\treturn -1;\n}\n\n/* Internal data structure for the index and AST expression transformation\n * callbacks for pet_stmt_build_ast_exprs.\n *\n * \"kernel\" is the kernel for which are computing AST expressions and\n * may be NULL if we are not inside a kernel.\n * \"accesses\" is the list of gpu_stmt_access in the statement.\n * \"iterator_map\" expresses the statement iterators in terms of\n * the AST loop iterators.\n * \"sched2copy\" expresses the outer copy_schedule_dim dimensions of\n * the kernel schedule in terms of the AST loop iterators and\n * may be NULL if we are not inside a kernel.\n *\n * The following fields are set in transform_index and used in transform_expr.\n * \"array\" is the array that is being accessed.\n * \"global\" is set if the global array is accessed (rather than\n * shared/private memory).\n * \"local_array\" refers to information on the array specialized\n * to the current kernel.\n */\nstruct ppcg_transform_data {\n    struct ppcg_options *options;\n    struct ppcg_kernel *kernel;\n\tstruct gpu_stmt_access *accesses;\n\tisl_pw_multi_aff *iterator_map;\n\tisl_pw_multi_aff *sched2copy;\n\n\tstruct gpu_array_info *array;\n\tint global;\n\tstruct gpu_local_array_info *local_array;\n};\n\n/* Return a pointer to the gpu_array_ref_group in \"local\"\n * that contains the reference \"access\".\n * Return NULL if no such group can be found.\n */\nstatic struct gpu_array_ref_group *find_ref_group(\n\tstruct gpu_local_array_info *local, struct gpu_stmt_access *access)\n{\n\tint i, j;\n\n\tfor (i = 0; i < local->n_group; ++i) {\n\t\tstruct gpu_array_ref_group *group = local->groups[i];\n\n\t\tfor (j = 0; j < group->n_ref; ++j)\n\t\t\tif (group->refs[j] == access)\n\t\t\t\treturn group;\n\t}\n\n\treturn NULL;\n}\n\n/* Given an index expression \"index\" of the form\n *\n *\tL -> F(A),\n *\n * with F(A) either A or some subfield of A and L the AST loop iterators,\n * and a tiling \"tiling\" of the form\n *\n *\t[L -> A] -> T\n *\n * apply the tiling to the outer array in the index expression to obtain\n *\n *\tL -> T(A)\n *\n * If F(A) is some subfield of A, then separate the member access\n * into the base index expression and the field index expression,\n * apply the tiling to the base index expression and combine the result\n * with the field index expression.\n *\n * If F(A) is A, then modify index to keep track of the iterators\n *\n *\tL -> [L -> A]\n *\n * and combine the result with the tiling to obtain a tiled index expression\n * in terms of the AST loop iterators\n *\n *\tL -> T\n */\nstatic __isl_give isl_multi_pw_aff *tile_outer(\n\t__isl_take isl_multi_pw_aff *index, __isl_take isl_multi_pw_aff *tiling)\n{\n\tisl_bool is_wrapping;\n\tisl_space *space;\n\tisl_multi_pw_aff *mpa;\n\n\tis_wrapping = isl_multi_pw_aff_range_is_wrapping(index);\n\tif (is_wrapping < 0)\n\t\tgoto error;\n\tif (is_wrapping) {\n\t\tisl_multi_pw_aff *field;\n\n\t\tfield = isl_multi_pw_aff_copy(index);\n\t\tfield = isl_multi_pw_aff_range_factor_range(field);\n\t\tindex = isl_multi_pw_aff_range_factor_domain(index);\n\t\tindex = tile_outer(index, tiling);\n\t\treturn isl_multi_pw_aff_range_product(index, field);\n\t}\n\n\tspace = isl_space_domain(isl_multi_pw_aff_get_space(index));\n\tspace = isl_space_map_from_set(space);\n\tmpa = isl_multi_pw_aff_identity(space);\n\tindex = isl_multi_pw_aff_range_product(mpa, index);\n\tindex = isl_multi_pw_aff_pullback_multi_pw_aff(tiling, index);\n\n\treturn index;\nerror:\n\tisl_multi_pw_aff_free(index);\n\tisl_multi_pw_aff_free(tiling);\n\treturn NULL;\n}\n\n/* Index transformation callback for pet_stmt_build_ast_exprs.\n *\n * \"index\" expresses the array indices in terms of statement iterators\n *\n * We first reformulate \"index\" in terms of the AST loop iterators.\n * Then we check if we are accessing the global array or\n * a shared/private copy.  In particular, if we are not inside a kernel\n * then we must be accessing a global array.\n * In the former case, we simply return\n * the updated index.  If \"index\" is an affine expression rather\n * than an array access, then we also return the updated index here.\n *\n * If no reference groups have been computed for the array,\n * then we can only be accessing the global array.\n *\n * Otherwise, we apply the tiling to the index.\n * This tiling is of the form\n *\n *\t[D -> A] -> T\n *\n * where D corresponds to the outer tile->depth dimensions of\n * the kernel schedule.\n * The index is of the form\n *\n *\tL -> A\n *\n * We update the tiling to refer to the AST loop iterators\n *\n *\t[L -> A] -> T\n *\n * and combine it with the index to obtain a tiled index expression in terms\n * of the AST loop iterators\n *\n *\tL -> T\n *\n * Note that while the tiling applies directly to an outer array.\n * the index may refer to some subfield of this outer array.\n * In such cases, the result will refer to the same subfield of the tile.\n * That is, an index expression of the form  L -> F(A) will be transformed\n * into an index expression of the form L -> F(T).\n */\nstatic __isl_give isl_multi_pw_aff *transform_index(\n\t__isl_take isl_multi_pw_aff *index, __isl_keep isl_id *ref_id,\n\tvoid *user)\n{\n\tstruct ppcg_transform_data *data = user;\n\tstruct gpu_stmt_access *access;\n\tstruct gpu_array_ref_group *group;\n\tstruct gpu_array_tile *tile;\n\tisl_pw_multi_aff *iterator_map;\n\tint i;\n\tint dim;\n\tconst char *name;\n\tisl_space *space;\n\tisl_multi_pw_aff *tiling;\n\tisl_pw_multi_aff *pma;\n\tisl_pw_multi_aff *sched2depth;\n\n\tdata->array = NULL;\n\n\titerator_map = isl_pw_multi_aff_copy(data->iterator_map);\n\tindex = isl_multi_pw_aff_pullback_pw_multi_aff(index, iterator_map);\n\n\tif (!data->kernel)\n\t\treturn index;\n\n\taccess = find_access(data->accesses, ref_id);\n\tif (!access)\n\t\treturn index;\n\tif (!isl_map_has_tuple_name(access->access, isl_dim_out))\n\t\treturn index;\n\n\tname = get_outer_array_name(access->access);\n\ti = find_array_index(data->kernel, name);\n\tif (i < 0)\n\t\tisl_die(isl_multi_pw_aff_get_ctx(index), isl_error_internal,\n\t\t\t\"cannot find array\",\n\t\t\treturn isl_multi_pw_aff_free(index));\n\tdata->local_array = &data->kernel->array[i];\n\tdata->array = data->local_array->array;\n\n\tgroup = find_ref_group(data->local_array, access);\n\tif (!group) {\n\t\tdata->global = 1;\n\t\treturn index;\n\t}\n\n\ttile = gpu_array_ref_group_tile(group);\n\tdata->global = !tile;\n\tif (!tile)\n\t\treturn index;\n\n\tspace = isl_space_domain(isl_multi_aff_get_space(tile->tiling));\n\tspace = isl_space_range(isl_space_unwrap(space));\n\tspace = isl_space_map_from_set(space);\n\tpma = isl_pw_multi_aff_identity(space);\n\tsched2depth = isl_pw_multi_aff_copy(data->sched2copy);\n\tdim = isl_pw_multi_aff_dim(sched2depth, isl_dim_out);\n\tsched2depth = isl_pw_multi_aff_drop_dims(sched2depth, isl_dim_out,\n\t\t\t\t\t    tile->depth, dim - tile->depth);\n\tpma = isl_pw_multi_aff_product(sched2depth, pma);\n\ttiling = isl_multi_pw_aff_from_multi_aff(\n\t\t\t\t    isl_multi_aff_copy(tile->tiling));\n\ttiling = isl_multi_pw_aff_pullback_pw_multi_aff(tiling, pma);\n\n\tindex = tile_outer(index, tiling);\n\n\treturn index;\n}\n\n/* Dereference \"expr\" by adding an index [0].\n * The original \"expr\" is assumed not to have any indices.\n *\n * If \"expr\" is a member access, then the dereferencing needs\n * to be applied to the structure argument of this member access.\n */\nstatic __isl_give isl_ast_expr *dereference(__isl_take isl_ast_expr *expr)\n{\n\tisl_ctx *ctx;\n\tisl_ast_expr *arg0, *res;\n\tisl_ast_expr_list *list;\n\n\targ0 = isl_ast_expr_get_op_arg(expr, 0);\n\tif (!arg0)\n\t\treturn isl_ast_expr_free(expr);\n\tif (isl_ast_expr_get_type(arg0) == isl_ast_expr_op &&\n\t    isl_ast_expr_get_op_type(arg0) == isl_ast_op_member) {\n\t\tisl_ast_expr *arg;\n\n\t\targ = isl_ast_expr_get_op_arg(arg0, 0);\n\t\targ = dereference(arg);\n\t\targ0 = isl_ast_expr_set_op_arg(arg0, 0, arg);\n\t\texpr = isl_ast_expr_set_op_arg(expr, 0, arg0);\n\n\t\treturn expr;\n\t}\n\tisl_ast_expr_free(arg0);\n\n\tctx = isl_ast_expr_get_ctx(expr);\n\tres = isl_ast_expr_from_val(isl_val_zero(ctx));\n\tlist = isl_ast_expr_list_from_ast_expr(res);\n\tres = isl_ast_expr_get_op_arg(expr, 0);\n\tres = isl_ast_expr_access(res, list);\n\tisl_ast_expr_free(expr);\n\n\treturn res;\n}\n\n/* Linearize the index expression \"expr\" based on the array bounds\n * of \"array\".\n *\n * That is, transform expression\n *\n *\tA[i_0][i_1]...[i_n]\n *\n * to\n *\n *\tA[(..((i_0 * b_1 + i_1) ... ) * b_n + i_n]\n *\n * where b_0, b_1, ..., b_n are the bounds on the array.\n *\n * If the base of \"expr\" is a member access, then the linearization needs\n * to be applied to the structure argument of this member access.\n *\n * In the base case, if \"expr\" has no arguments (other than the name of\n * the array), then we are passing an entire array to a function.\n * In this case, there is nothing to linearize.\n * Note that at this point an expression with no arguments can\n * only be an entire array because the scalar case and\n * the case of single struct are handled by the caller.\n *\n * If the number of specified index expressions in \"expr\"\n * is smaller than the dimension of the accessed array,\n * then the missing i_j also do not appear in the linearized expression.\n * Furthermore, since such an expression does not refer to a single\n * element while the default linearized expression would refer to\n * a single element, we return the expression\n *\n *\tA + (..((i_0 * b_1 + i_1) ... ) * b_l + i_l)\n *\n * instead.  Note that because of the special case handling above,\n * we can assume here that there is at least one index expression.\n */\n__isl_give isl_ast_expr *gpu_local_array_info_linearize_index(\n\tstruct gpu_local_array_info *array, __isl_take isl_ast_expr *expr)\n{\n\tint i, n;\n\tisl_ast_expr *arg0;\n\tisl_ast_expr *res;\n\tisl_ast_expr_list *list;\n\n\targ0 = isl_ast_expr_get_op_arg(expr, 0);\n\tif (isl_ast_expr_get_type(arg0) == isl_ast_expr_op &&\n\t    isl_ast_expr_get_op_type(arg0) == isl_ast_op_member) {\n\t\tisl_ast_expr *arg;\n\n\t\targ = isl_ast_expr_get_op_arg(arg0, 0);\n\t\targ = gpu_local_array_info_linearize_index(array, arg);\n\t\targ0 = isl_ast_expr_set_op_arg(arg0, 0, arg);\n\t\texpr = isl_ast_expr_set_op_arg(expr, 0, arg0);\n\n\t\treturn expr;\n\t}\n\tisl_ast_expr_free(arg0);\n\n\tif (isl_ast_expr_get_op_n_arg(expr) == 1)\n\t\treturn expr;\n\n\tn = isl_ast_expr_get_op_n_arg(expr);\n\tres = isl_ast_expr_get_op_arg(expr, 1);\n\tfor (i = 1; i < array->n_index; ++i) {\n\t\tisl_ast_expr *expr_i;\n\n\t\texpr_i = isl_ast_expr_get_op_arg(array->bound_expr, 1 + i);\n\t\tres = isl_ast_expr_mul(res, expr_i);\n\n\t\tif (i + 1 >= n)\n\t\t\tcontinue;\n\t\texpr_i = isl_ast_expr_get_op_arg(expr, i + 1);\n\t\tres = isl_ast_expr_add(res, expr_i);\n\t}\n\n\tif (1 + array->n_index > n) {\n\t\tres = isl_ast_expr_add(isl_ast_expr_get_op_arg(expr, 0), res);\n\t} else {\n\t\tlist = isl_ast_expr_list_from_ast_expr(res);\n\t\tres = isl_ast_expr_get_op_arg(expr, 0);\n\t\tres = isl_ast_expr_access(res, list);\n\t}\n\n\tisl_ast_expr_free(expr);\n\n\treturn res;\n}\n\n/* AST expression transformation callback for pet_stmt_build_ast_exprs.\n *\n * If the AST expression refers to an array that is not accessed\n * at all, then this means the value of the expression is not used,\n * so we might as well print zero (NULL pointer) instead.\n *\n * If the AST expression refers to a global scalar that is not\n * a read-only scalar, then its address was passed to the kernel and\n * we need to dereference it.\n *\n * If the AST expression refers to an access to a global array,\n * then we linearize the access exploiting the bounds in data->local_array.\n */\nstatic __isl_give isl_ast_expr *transform_expr(__isl_take isl_ast_expr *expr,\n\t__isl_keep isl_id *id, void *user)\n{\n\tstruct ppcg_transform_data *data = user;\n\n\tif (!data->array)\n\t\treturn expr;\n\tif (!data->array->accessed) {\n\t\tisl_ctx *ctx;\n\n\t\tctx = isl_ast_expr_get_ctx(expr);\n\t\tisl_ast_expr_free(expr);\n\t\treturn isl_ast_expr_from_val(isl_val_zero(ctx));\n\t}\n\tif (gpu_array_is_read_only_scalar(data->array))\n\t\treturn expr;\n\tif (!data->global)\n\t\treturn expr;\n\tif (data->array->n_index == 0)\n\t\treturn dereference(expr);\n\tif (!data->array->linearize)\n\t\treturn expr;\n\n\treturn gpu_local_array_info_linearize_index(data->local_array, expr);\n}\n\n/* This function is called for each instance of a user statement\n * in the kernel \"kernel\", identified by \"gpu_stmt\".\n * \"kernel\" may be NULL if we are not inside a kernel.\n *\n * We attach a struct ppcg_kernel_stmt to the \"node\", containing\n * a computed AST expression for each access, through an annotation\n * with name \"user\".\n * These AST expressions are computed from iterator_map,\n * which expresses the domain\n * elements in terms of the generated loops, and sched2copy,\n * which expresses the outer copy_schedule_dim dimensions of\n * the kernel schedule computed by PPCG in terms of the generated loops.\n */\nstatic __isl_give isl_ast_node *create_domain_leaf(\n\tstruct ppcg_kernel *kernel, __isl_take isl_ast_node *node,\n\t__isl_keep isl_ast_build *build, struct gpu_stmt *gpu_stmt,\n    struct gpu_gen *gen)\n{\n\tstruct ppcg_transform_data data;\n\tstruct ppcg_kernel_stmt *stmt;\n\tisl_ctx *ctx;\n\tisl_id *id;\n\tisl_pw_multi_aff *sched2copy;\n\tisl_map *map;\n\tisl_pw_multi_aff *iterator_map;\n\tisl_union_map *schedule;\n\n\tif (!node)\n\t\treturn NULL;\n\tctx = isl_ast_node_get_ctx(node);\n\n\tstmt = isl_calloc_type(ctx, struct ppcg_kernel_stmt);\n\tif (!stmt)\n\t\treturn isl_ast_node_free(node);\n\n\tschedule = isl_ast_build_get_schedule(build);\n\tmap = isl_map_reverse(isl_map_from_union_map(schedule));\n\titerator_map = isl_pw_multi_aff_from_map(map);\n\tif (kernel)\n\t\tsched2copy = compute_sched_to_copy(kernel,\n\t\t\t\t\tisl_pw_multi_aff_copy(iterator_map));\n\telse\n\t\tsched2copy = NULL;\n\n\tstmt->type = ppcg_kernel_domain;\n\tstmt->u.d.stmt = gpu_stmt;\n\n\tdata.kernel = kernel;\n\tdata.accesses = stmt->u.d.stmt->accesses;\n\tdata.iterator_map = iterator_map;\n\tdata.sched2copy = sched2copy;\n\tstmt->u.d.ref2expr = gen->build_ast_expr(stmt->u.d.stmt->stmt,\n\t\t\t\t\t    build, &transform_index, &data,\n\t\t\t\t\t    &transform_expr, &data);\n\n\tisl_pw_multi_aff_free(iterator_map);\n\tisl_pw_multi_aff_free(sched2copy);\n\n\tid = isl_id_alloc(ctx, \"user\", stmt);\n\tid = isl_id_set_free_user(id, &ppcg_kernel_stmt_free);\n\treturn isl_ast_node_set_annotation(node, id);\n}\n\n/* This function is called for each statement node in the AST\n * for copying to or from shared/private memory.\n * Attach a pointer to a ppcg_kernel_stmt representing the copy\n * statement to the node.\n * The statement name is \"read\" or \"write\", depending on whether we are\n * reading from global memory or writing to global memory.\n *\n * The schedule is of the form\n *\n *\ttype[D -> A] -> L\n *\n * where D corresponds to the outer tile->depth dimensions of\n * the kernel schedule, A to the global array and L to the outer\n * generated AST schedule.\n * We compute the inverse and strip off the type, resulting in\n *\n *\tL -> [D -> A]\n *\n * We combine this mapping with on the one hand the projection\n *\n *\t[D -> A] -> A\n *\n * and on the other hand the group tiling\n *\n *\t[D -> A] -> T\n *\n * resulting in\n *\n *\tL -> A\t\tand \tL -> T\n *\n * and store the corresponding expressions in stmt->index and stmt->local_index,\n * where stmt points to the ppcg_kernel_stmt that is attached to the node.\n * stmt->index is linearized if the global memory array is linearized.\n */\nstatic __isl_give isl_ast_node *create_access_leaf(struct ppcg_kernel *kernel,\n\tstruct gpu_array_ref_group *group, __isl_take isl_ast_node *node,\n\t__isl_keep isl_ast_build *build)\n{\n\tstruct ppcg_kernel_stmt *stmt;\n\tstruct gpu_array_tile *tile;\n\tisl_id *id;\n\tisl_ast_expr *expr;\n\tisl_space *space;\n\tisl_map *access;\n\tisl_pw_multi_aff *pma, *pma2;\n\tconst char *type;\n\n\tstmt = isl_calloc_type(kernel->ctx, struct ppcg_kernel_stmt);\n\tif (!stmt)\n\t\treturn isl_ast_node_free(node);\n\n\taccess = isl_map_from_union_map(isl_ast_build_get_schedule(build));\n\ttype = isl_map_get_tuple_name(access, isl_dim_in);\n\tstmt->u.c.read = !strcmp(type, \"read\");\n\taccess = isl_map_reverse(access);\n\tpma = isl_pw_multi_aff_from_map(access);\n\tpma = isl_pw_multi_aff_reset_tuple_id(pma, isl_dim_out);\n\n\tspace = isl_space_range(isl_pw_multi_aff_get_space(pma));\n\tspace = isl_space_unwrap(space);\n\tpma2 = isl_pw_multi_aff_range_map(space);\n\tpma2 = isl_pw_multi_aff_pullback_pw_multi_aff(pma2,\n\t\t\t\t\t\t    isl_pw_multi_aff_copy(pma));\n\texpr = isl_ast_build_access_from_pw_multi_aff(build, pma2);\n\tif (group->array->linearize)\n\t\texpr = gpu_local_array_info_linearize_index(group->local_array,\n\t\t\t\t\t\t\t    expr);\n\tstmt->u.c.index = expr;\n\n\ttile = gpu_array_ref_group_tile(group);\n\tpma2 = isl_pw_multi_aff_from_multi_aff(\n\t\t\t\t\t    isl_multi_aff_copy(tile->tiling));\n\tpma2 = isl_pw_multi_aff_pullback_pw_multi_aff(pma2, pma);\n\texpr = isl_ast_build_access_from_pw_multi_aff(build, pma2);\n\tstmt->u.c.local_index = expr;\n\n\tstmt->u.c.array = group->array;\n\tstmt->u.c.local_array = group->local_array;\n\tstmt->type = ppcg_kernel_copy;\n\n\tid = isl_id_alloc(kernel->ctx, \"copy\", stmt);\n\tid = isl_id_set_free_user(id, &ppcg_kernel_stmt_free);\n\treturn isl_ast_node_set_annotation(node, id);\n}\n\n/* Create a synchronization ppcg_kernel_stmt and\n * attach it to the node \"node\" representing the synchronization.\n */\nstatic __isl_give isl_ast_node *create_sync_leaf(\n\tstruct ppcg_kernel *kernel, __isl_take isl_ast_node *node,\n\t__isl_keep isl_ast_build *build)\n{\n\tstruct ppcg_kernel_stmt *stmt;\n\tisl_id *id;\n\n\tstmt = isl_calloc_type(kernel->ctx, struct ppcg_kernel_stmt);\n\tif (!stmt)\n\t\treturn isl_ast_node_free(node);\n\n\tstmt->type = ppcg_kernel_sync;\n\tid = isl_id_alloc(kernel->ctx, \"sync\", stmt);\n\tid = isl_id_set_free_user(id, &ppcg_kernel_stmt_free);\n\treturn isl_ast_node_set_annotation(node, id);\n}\n\n/* Build AST expressions for the device array sizes of all arrays in \"prog\"\n * that require allocation on the device using \"build\", as well as\n * for the original array sizes of all arrays that need to be declared\n * on the host.\n * \"node\" is freed in case of error.\n */\nstatic __isl_give isl_ast_node *build_array_bounds(\n\t__isl_take isl_ast_node *node, struct gpu_prog *prog,\n\t__isl_keep isl_ast_build *build)\n{\n\tint i;\n\n\tfor (i = 0; i < prog->n_array; ++i) {\n\t\tstruct gpu_array_info *array = &prog->array[i];\n\t\tisl_multi_pw_aff *size;\n\t\tisl_ast_expr *expr;\n\n\t\tif (!gpu_array_requires_device_allocation(array))\n\t\t\tcontinue;\n\n\t\tsize = isl_multi_pw_aff_copy(array->bound);\n\t\texpr = ppcg_build_size_expr(size, build);\n\t\tarray->bound_expr = expr;\n\t\tif (!expr)\n\t\t\treturn isl_ast_node_free(node);\n\t}\n\n\tfor (i = 0; i < prog->n_array; ++i) {\n\t\tstruct gpu_array_info *array = &prog->array[i];\n\t\tisl_set *extent;\n\t\tisl_multi_pw_aff *size;\n\t\tisl_ast_expr *expr;\n\n\t\tif (!array->declare_local)\n\t\t\tcontinue;\n\t\textent = isl_set_copy(array->declared_extent);\n\t\tsize = ppcg_size_from_extent(extent);\n\t\texpr = ppcg_build_size_expr(size, build);\n\t\tarray->declared_size = expr;\n\t\tif (!expr)\n\t\t\treturn isl_ast_node_free(node);\n\t}\n\n\treturn node;\n}\n\n/* Internal data structure for at_domain.\n *\n * \"prog\" represents the entire scop.\n * \"kernel\" points to the kernel to which the current schedule node\n * belongs.  It is set by before_mark and reset by after_mark.\n * It may be NULL if we are outside any kernel.\n */\nstruct ppcg_at_domain_data {\n    struct gpu_prog *prog;\n    struct gpu_gen *gen;\n    struct ppcg_kernel *kernel;\n};\n\n/* This function is called for each instance of a user statement\n * in the kernel.  This may be one of the original user statements\n * or a statement introduced by PPCG.\n *\n * We first check if the statement id corresponds to a gpu statement,\n * which indicates the statement is an original user statement. Any statement\n * that is not an original user statement has been introduced by PPCG and\n * requires special handling.\n *\n * If the user statement is one of the original user statements, then we call\n * create_domain_leaf.  If it is \"init_device\", then we call\n * build_array_bounds.  Otherwise, we check if it is a copy or synchronization\n * statement and call the appropriate functions.  Statements that copy an array\n * to/from the device do not need any further treatment.\n * Neither does \"clear_device\".\n */\nstatic __isl_give isl_ast_node *at_domain(__isl_take isl_ast_node *node,\n\t__isl_keep isl_ast_build *build, void *user)\n{\n\tstruct ppcg_at_domain_data *data = user;\n\tstruct gpu_stmt *gpu_stmt;\n\tisl_ast_expr *expr, *arg;\n\tisl_id *id;\n\tint is_sync;\n\tconst char *name;\n\tvoid *p;\n\n\texpr = isl_ast_node_user_get_expr(node);\n\targ = isl_ast_expr_get_op_arg(expr, 0);\n\tid = isl_ast_expr_get_id(arg);\n\tname = isl_id_get_name(id);\n\tp = isl_id_get_user(id);\n\tisl_ast_expr_free(expr);\n\tisl_ast_expr_free(arg);\n\n\tgpu_stmt = find_stmt(data->prog, id);\n\tis_sync = gpu_tree_id_is_sync(id, data->kernel);\n\tisl_id_free(id);\n\n\tif (gpu_stmt)\n\t\treturn create_domain_leaf(data->kernel, node, build, gpu_stmt,\n                                  data->gen);\n\n\tif (!prefixcmp(name, \"to_device_\") || !prefixcmp(name, \"from_device_\"))\n\t\treturn node;\n\tif (!strcmp(name, \"init_device\"))\n\t\treturn build_array_bounds(node, data->prog, build);\n\tif (!strcmp(name, \"clear_device\"))\n\t\treturn node;\n\tif (is_sync < 0)\n\t\treturn isl_ast_node_free(node);\n\tif (!strcmp(name, \"read\") || !strcmp(name, \"write\")) {\n\t\tstruct gpu_array_ref_group *group = p;\n\t\treturn create_access_leaf(data->kernel, group, node, build);\n\t}\n\tif (!is_sync)\n\t\tisl_die(data->prog->ctx, isl_error_internal,\n\t\t\t\"unknown statement type\",\n\t\t\treturn isl_ast_node_free(node));\n\treturn create_sync_leaf(data->kernel, node, build);\n}\n\n/* Given a set of wrapped references \"ref\", return the corresponding\n * access relations based on the tagged access relations \"tagged\".\n *\n * The elements of \"ref\" are of the form\n *\n *\t[D -> R]\n *\n * with D an iteration domains and R a reference.\n * The elements of \"tagged\" are of the form\n *\n *\t[D -> R] -> A\n *\n * with A an array.\n *\n * Extend \"tagged\" to include the iteration domain in the range, i.e.,\n *\n *\t[D -> R] -> [D -> A]\n *\n * apply the result to \"ref\" and then unwrap the resulting set\n * to obtain relations of the form\n *\n *\tD -> A\n */\nstatic __isl_give isl_union_map *wrapped_reference_to_access(\n\t__isl_take isl_union_set *ref, __isl_take isl_union_map *tagged)\n{\n\tisl_union_map *tag2access;\n\n\ttag2access = isl_union_map_copy(tagged);\n\ttag2access = isl_union_map_universe(tag2access);\n\ttag2access = isl_union_set_unwrap(isl_union_map_domain(tag2access));\n\ttag2access = isl_union_map_domain_map(tag2access);\n\ttag2access = isl_union_map_range_product(tag2access, tagged);\n\n\tref = isl_union_set_coalesce(ref);\n\tref = isl_union_set_apply(ref, tag2access);\n\n\treturn isl_union_set_unwrap(ref);\n}\n\n/* Given an access relation \"access\" from one or more array reference groups,\n * remove those reads if (\"read\" is 1) or writes (if \"read\" is 0)\n * that are only needed to communicate data within\n * the same iteration of \"sched\".\n * The domain of \"sched\" corresponds to the original statement instances,\n * i.e., those that appear in the domains of the access relations.\n * \"tagged\" contains all tagged access relations to all\n * the array reference groups accessed by \"access\" from statement\n * instances scheduled by \"sched\".\n *\n * If the access is a read then it is either an element of\n *\n *\tlive_in union (range flow)\n *\n * where live_in and flow may be overapproximations, or\n * it reads an uninitialized value (that is not live-in because\n * there is an intermediate kill) or it reads a value that was\n * written within the same (compound) statement instance.\n * If the access is a write then it is either an element of\n *\n *\tlive_out union (domain flow)\n *\n * or it writes a value that is never read (and is not live-out\n * because of an intermediate kill) or only\n * within the same (compound) statement instance.\n * In both cases, the access relation is also a subset of\n * the group access relation.\n *\n * The cases where an uninitialized value is read or a value is written\n * that is never read or where the dataflow occurs within a statement\n * instance are also considered local and may also be removed.\n *\n * Essentially, we compute the intersection of \"access\" with either\n *\n *\tlive_in union (range non-local-flow)\n *\n * or\n *\n *\tlive_out union (domain non-local-flow)\n *\n * We first construct a relation \"local\"\n *\n *\t[[D -> R] -> [D' -> R']]\n *\n * of pairs of domain iterations accessing the reference group\n * and references in the group that are coscheduled by \"sched\".\n *\n * If this relation does not intersect the dataflow dependences,\n * then there is nothing we can possibly remove, unless the dataflow\n * dependences themselves only relate a subset of the accesses.\n * In particular, the accesses may not be involved in any dataflow\n * dependences, either because they are uninitialized reads/dead writes\n * or because the dataflow occurs inside a statement instance.\n *\n * Since the computation below may break up the access relation\n * into smaller pieces, we only perform the intersection with\n * the non-local dependent accesses if the local pairs\n * intersect the dataflow dependences.  Otherwise, we intersect\n * with the universe of the non-local dependent accesses.\n * This should at least remove accesses from statements that\n * do not participate in any dependences.\n *\n * In particular, we remove the \"local\" dataflow dependences from\n * the set of all dataflow dependences, or at least those\n * that may contribute to a domain/range that intersects\n * the domain of \"access\".\n * Note that if the potential dataflow dependences are an overapproximation\n * of the actual dataflow dependences, then the result remains an\n * overapproximation of the non-local dataflow dependences.\n * Copying to/from global memory is only needed for the references\n * in the domain/range of the result or for accesses that are live out/in\n * for the entire scop.\n *\n * We therefore map the domain/range of the \"external\" relation\n * to the corresponding access relation and take the union with\n * the live out/in relation.\n */\nstatic __isl_give isl_union_map *remove_local_accesses(\n\tstruct gpu_prog *prog, __isl_take isl_union_map *tagged,\n\t__isl_take isl_union_map *access, __isl_take isl_union_map *sched,\n\tint read)\n{\n\tint empty;\n\tisl_union_pw_multi_aff *tagger;\n\tisl_union_set *domain, *access_domain;\n\tisl_union_map *local, *external, *universe;\n\tisl_union_set *tag_set;\n\n\tif (isl_union_map_is_empty(access)) {\n\t\tisl_union_map_free(sched);\n\t\tisl_union_map_free(tagged);\n\t\treturn access;\n\t}\n\n\ttagger = isl_union_pw_multi_aff_copy(prog->scop->tagger);\n\tdomain = isl_union_map_domain(isl_union_map_copy(tagged));\n\ttagger = isl_union_pw_multi_aff_intersect_domain(tagger,\n\t\t\t\t\tisl_union_set_copy(domain));\n\tsched = isl_union_map_preimage_domain_union_pw_multi_aff(sched, tagger);\n\n\tlocal = isl_union_map_apply_range(sched,\n\t\t\t    isl_union_map_reverse(isl_union_map_copy(sched)));\n\tlocal = isl_union_map_intersect(local,\n\t\t\tisl_union_map_copy(prog->scop->tagged_dep_flow));\n\n\tempty = isl_union_map_is_empty(local);\n\n\texternal = isl_union_map_copy(prog->scop->tagged_dep_flow);\n\tuniverse = isl_union_map_universe(isl_union_map_copy(access));\n\taccess_domain = isl_union_map_domain(universe);\n\tdomain = isl_union_set_universe(domain);\n\tuniverse = isl_union_set_unwrap(domain);\n\tuniverse = isl_union_map_intersect_domain(universe, access_domain);\n\tdomain = isl_union_map_wrap(universe);\n\tif (read)\n\t\texternal = isl_union_map_intersect_range(external, domain);\n\telse\n\t\texternal = isl_union_map_intersect_domain(external, domain);\n\texternal = isl_union_map_intersect_params(external,\n\t\t\t\tisl_set_copy(prog->scop->context));\n\texternal = isl_union_map_subtract(external, local);\n\n\tif (read) {\n\t\ttag_set = isl_union_map_range(external);\n\t\texternal = wrapped_reference_to_access(tag_set, tagged);\n\t\texternal = isl_union_map_union(external,\n\t\t\t\tisl_union_map_copy(prog->scop->live_in));\n\t} else {\n\t\ttag_set = isl_union_map_domain(external);\n\t\texternal = wrapped_reference_to_access(tag_set, tagged);\n\t\texternal = isl_union_map_union(external,\n\t\t\t\tisl_union_map_copy(prog->scop->live_out));\n\t}\n\n\tif (empty < 0)\n\t\texternal = isl_union_map_free(external);\n\telse if (empty)\n\t\texternal = isl_union_map_universe(external);\n\n\taccess = isl_union_map_intersect(access, external);\n\n\treturn access;\n}\n\n/* Given an access relation \"access\" from \"group\", remove those reads\n * if (\"read\" is 1) or writes (if \"read\" is 0) that are only needed to\n * communicate data within the same iteration of the schedule \"prefix\"\n * at the position where the copying of the group is inserted.\n * That is, the output dimension of \"prefix\"\n * is equal to tile->depth.\n * The domain of \"prefix\" corresponds to the original statement instances,\n * i.e., those that appear in the domains of the access relations.\n *\n * Extract the tagged access relation of \"group\" and\n * then call remove_local_accesses.\n */\nstatic __isl_give isl_union_map *remove_local_accesses_group(\n\tstruct ppcg_kernel *kernel, struct gpu_array_ref_group *group,\n\t__isl_take isl_union_map *access, __isl_keep isl_union_map *prefix,\n\tint read)\n{\n\tisl_union_map *sched, *tagged;\n\n\tif (isl_union_map_is_empty(access))\n\t\treturn access;\n\n\ttagged = group_tagged_access_relation(group);\n\tsched = isl_union_map_copy(prefix);\n\n\treturn remove_local_accesses(kernel->prog, tagged, access, sched, read);\n}\n\n/* Build an access AST expression for the effective grid size using \"build\".\n * Store the result in kernel->grid_size_expr.\n */\nstatic isl_stat build_grid_size(struct ppcg_kernel *kernel,\n\t__isl_keep isl_ast_build *build)\n{\n\tisl_multi_pw_aff *size;\n\n\tsize = isl_multi_pw_aff_copy(kernel->grid_size);\n\tsize = isl_multi_pw_aff_set_tuple_name(size, isl_dim_out, \"grid\");\n\tkernel->grid_size_expr = ppcg_build_size_expr(size, build);\n\n\tif (!kernel->grid_size_expr)\n\t\treturn isl_stat_error;\n\treturn isl_stat_ok;\n}\n\n/* Build access AST expressions for the localized array sizes using \"build\".\n * Store the result in local->bound_expr.\n * Only do this for arrays for which localized bounds have been computed.\n */\nstatic isl_stat build_local_array_sizes(struct ppcg_kernel *kernel,\n\t__isl_keep isl_ast_build *build)\n{\n\tint i;\n\n\tfor (i = 0; i < kernel->n_array; ++i) {\n\t\tstruct gpu_local_array_info *local = &kernel->array[i];\n\t\tisl_multi_pw_aff *size;\n\n\t\tif (local->n_group == 0)\n\t\t\tcontinue;\n\t\tsize = isl_multi_pw_aff_copy(local->bound);\n\t\tlocal->bound_expr = ppcg_build_size_expr(size, build);\n\t\tif (!local->bound_expr)\n\t\t\treturn isl_stat_error;\n\t}\n\n\treturn isl_stat_ok;\n}\n\n/* Build access AST expressions for the effective grid size and\n * the localized array sizes using \"build\".\n */\nstatic isl_stat build_grid_and_local_array_sizes(struct ppcg_kernel *kernel,\n\t__isl_keep isl_ast_build *build)\n{\n\tif (build_grid_size(kernel, build) < 0)\n\t\treturn isl_stat_error;\n\tif (build_local_array_sizes(kernel, build) < 0)\n\t\treturn isl_stat_error;\n\treturn isl_stat_ok;\n}\n\n/* This function is called before the AST generator starts traversing\n * the schedule subtree of a node with mark \"mark\".\n *\n * If the mark is called \"kernel\", store the kernel pointer in data->kernel\n * for use in at_domain and build AST expressions for the grid size and\n * the localized array sizes.\n */\nstatic isl_stat before_mark(__isl_keep isl_id *mark,\n\t__isl_keep isl_ast_build *build, void *user)\n{\n\tstruct ppcg_at_domain_data *data = user;\n\n\tif (!mark)\n\t\treturn isl_stat_error;\n\tif (!strcmp(isl_id_get_name(mark), \"kernel\")) {\n\t\tdata->kernel = isl_id_get_user(mark);\n\t\tif (build_grid_and_local_array_sizes(data->kernel, build) < 0)\n\t\t\treturn isl_stat_error;\n\t}\n\treturn isl_stat_ok;\n}\n\n/* This function is called after the AST generator has finished traversing\n * the schedule subtree of a mark node.  \"node\" points to the corresponding\n * mark AST node.\n *\n * If the mark is called \"kernel\", then replace \"node\" by a user node\n * that \"calls\" the kernel, representing the launch of the kernel.\n * The original \"node\" is stored inside the kernel object so that\n * it can be used to print the device code.\n * Note that this assumes that a kernel is only launched once.\n * Also clear data->kernel.\n */\nstatic __isl_give isl_ast_node *after_mark(__isl_take isl_ast_node *node,\n        __isl_keep isl_ast_build *build, void *user)\n{\n\tisl_ctx *ctx;\n\tisl_id *id;\n\tisl_ast_expr *expr;\n\tisl_ast_expr_list *list;\n\tstruct ppcg_kernel *kernel;\n\tstruct ppcg_at_domain_data *data = user;\n\n\tctx = isl_ast_node_get_ctx(node);\n\tid = isl_ast_node_mark_get_id(node);\n\tif (!id)\n\t\treturn isl_ast_node_free(node);\n\tif (strcmp(isl_id_get_name(id), \"kernel\") || !data->kernel) {\n\t\tisl_id_free(id);\n\t\treturn node;\n\t}\n\tkernel = data->kernel;\n\tdata->kernel = NULL;\n\tkernel->space = isl_ast_build_get_schedule_space(build);\n\tkernel->tree = isl_ast_node_mark_get_node(node);\n\tisl_ast_node_free(node);\n\n\texpr = isl_ast_expr_from_id(isl_id_copy(id));\n\tlist = isl_ast_expr_list_alloc(ctx, 0);\n\texpr = isl_ast_expr_call(expr, list);\n\tnode = isl_ast_node_alloc_user(expr);\n\tnode = isl_ast_node_set_annotation(node, id);\n\n\treturn node;\n}\n\nstatic isl_bool update_depth(__isl_keep isl_schedule_node *node, void *user)\n{\n\tint *depth = user;\n\tint node_depth;\n\n\tif (isl_schedule_node_get_type(node) != isl_schedule_node_leaf)\n\t\treturn isl_bool_true;\n\tnode_depth = isl_schedule_node_get_schedule_depth(node);\n\tif (node_depth > *depth)\n\t\t*depth = node_depth;\n\n\treturn isl_bool_false;\n}\n\n/* Use isl to generate code for both the host and the device\n * from \"schedule\".\n * The device code is marked by \"kernel\" mark nodes in the schedule tree,\n * containing a pointer to a ppcg_kernel object.\n * The returned AST only contains the AST for the host code.\n * The ASTs for the device code are embedded in ppcg_kernel objects\n * attached to the leaf nodes that call \"kernel\".\n */\n__isl_give isl_ast_node *generate_code(struct gpu_gen *gen,\n\t__isl_take isl_schedule *schedule)\n{\n\tstruct ppcg_at_domain_data data;\n\tisl_ast_build *build;\n\tisl_ast_node *tree;\n\tisl_id_list *iterators;\n\tint depth;\n\n    data.prog = gen->prog;\n    data.gen = gen;\n\tdata.kernel = NULL;\n\n\tdepth = 0;\n\tif (isl_schedule_foreach_schedule_node_top_down(schedule, &update_depth,\n\t\t\t\t\t\t&depth) < 0)\n\t\treturn NULL;\n\tbuild = isl_ast_build_alloc(gen->prog->ctx);\n\titerators = ppcg_scop_generate_names(gen->prog->scop, depth, \"c\");\n\tbuild = isl_ast_build_set_iterators(build, iterators);\n\tbuild = isl_ast_build_set_at_each_domain(build, &at_domain, &data);\n\tbuild = isl_ast_build_set_before_each_mark(build, &before_mark, &data);\n\tbuild = isl_ast_build_set_after_each_mark(build, &after_mark, &data);\n\tif (gen->prog->scop->options->debug->dump_final_schedule)\n\t\tisl_schedule_dump(schedule);\n\ttree = isl_ast_build_node_from_schedule(build, schedule);\n\tisl_ast_build_free(build);\n\n\treturn tree;\n}\n\n__isl_give isl_union_map *extract_sizes_from_str(isl_ctx *ctx, const char *str)\n{\n\tif (!str)\n\t\treturn NULL;\n\treturn isl_union_map_read_from_str(ctx, str);\n}\n\n/* Can \"node\" be tiled and then mapped to block and thread identifiers?\n * That is, is it permutable with at least one coincident dimension?\n */\nstatic int is_permutable(__isl_keep isl_schedule_node *node)\n{\n\tif (!node)\n\t\treturn -1;\n\n\tif (isl_schedule_node_get_type(node) != isl_schedule_node_band)\n\t\treturn 0;\n\tif (!isl_schedule_node_band_get_permutable(node))\n\t\treturn 0;\n\tif (isl_schedule_node_band_n_member(node) < 1)\n\t\treturn 0;\n\tif (!isl_schedule_node_band_member_get_coincident(node, 0))\n\t\treturn 0;\n\n\treturn 1;\n}\n\n/* A isl_schedule_foreach_schedule_node_top_down callback\n * for setting *any_permutable and aborting the search\n * if \"node\" is a permutable band with coincident dimensions.\n * Otherwise, continue searching.\n */\nstatic isl_bool set_permutable(__isl_keep isl_schedule_node *node, void *user)\n{\n\tint *any_permutable = user;\n\tint permutable;\n\n\tpermutable = is_permutable(node);\n\tif (permutable < 0)\n\t\treturn isl_bool_error;\n\tif (!permutable)\n\t\treturn isl_bool_true;\n\n\t*any_permutable = 1;\n\n\treturn isl_bool_error;\n}\n\n/* Does the subtree rooted at \"node\" have any suitably permutable band nodes?\n * That is, does it have any nodes that are permutable and that\n * have a least one coincident dimension?\n */\nstatic int subtree_has_permutable_bands(__isl_keep isl_schedule_node *node)\n{\n\tint any_parallelism = 0;\n\n\tif (isl_schedule_node_foreach_descendant_top_down(node, &set_permutable,\n\t\t\t\t\t\t&any_parallelism) < 0 &&\n\t    !any_parallelism)\n\t\treturn -1;\n\n\treturn any_parallelism;\n}\n\n/* Does \"schedule\" contain any permutable band with at least one coincident\n * member?\n */\nint has_any_permutable_node(__isl_keep isl_schedule *schedule)\n{\n\tisl_schedule_node *root;\n\tint any_permutable;\n\n\troot = isl_schedule_get_root(schedule);\n\tany_permutable = subtree_has_permutable_bands(root);\n\tisl_schedule_node_free(root);\n\n\treturn any_permutable;\n}\n\n/* Is \"node\" a candidate for mapping to block and thread identifiers?\n * In particular, is it permutable with at least one coincident dimension?\n * Alternatively, does the subtree rooted at \"node\" not contain\n * any such permutable node?  Filter nodes are skipped in this case,\n * because a band node will be inserted in front of the returned\n * node and this is not possible for filter nodes that are children\n * of set or sequence nodes.\n */\nstatic int is_candidate(__isl_keep isl_schedule_node *node)\n{\n\tint permutable;\n\n\tif (isl_schedule_node_get_type(node) == isl_schedule_node_leaf)\n\t\treturn 1;\n\tpermutable = is_permutable(node);\n\tif (permutable < 0 || permutable)\n\t\treturn permutable;\n\tif (isl_schedule_node_get_type(node) == isl_schedule_node_filter)\n\t\treturn 0;\n\tpermutable = subtree_has_permutable_bands(node);\n\tif (permutable < 0)\n\t\treturn -1;\n\treturn !permutable;\n}\n\n/* Is \"node\" the outermost node in its branch that can be tiled\n * and then mapped to block and thread identifiers?\n * If there are no such nodes in the subtree at \"node\" and\n * if \"node\" is not a filter node, then it is accepted too.\n */\nstatic int is_outer_tilable(__isl_keep isl_schedule_node *node)\n{\n\tint tilable;\n\tisl_schedule_node *ancestor;\n\n\ttilable = is_candidate(node);\n\tif (tilable < 0)\n\t\treturn -1;\n\tif (!tilable)\n\t\treturn 0;\n\n\ttilable = 0;\n\tancestor = isl_schedule_node_copy(node);\n\twhile (isl_schedule_node_has_parent(ancestor)) {\n\t\tancestor = isl_schedule_node_parent(ancestor);\n\n\t\ttilable = is_candidate(ancestor);\n\t\tif (tilable < 0 || tilable)\n\t\t\tbreak;\n\t}\n\n\tisl_schedule_node_free(ancestor);\n\treturn tilable < 0 ? -1 : !tilable;\n}\n\n/* Collect the references to all writes in \"group\".\n * Each reference is represented by a universe set in a space\n *\n *\t[S[i,j] -> R[]]\n *\n * with S[i,j] the statement instance space and R[] the array reference.\n */\nstatic __isl_give isl_union_set *group_tagged_writes(\n\tstruct gpu_array_ref_group *group)\n{\n\tint i;\n\tisl_space *space;\n\tisl_union_set *writes;\n\n\tspace = isl_map_get_space(group->access);\n\twrites = isl_union_set_empty(space);\n\tfor (i = 0; i < group->n_ref; ++i) {\n\t\tisl_space *space;\n\t\tisl_set *writes_i;\n\n\t\tif (!group->refs[i]->write)\n\t\t\tcontinue;\n\n\t\tspace = isl_map_get_space(group->refs[i]->tagged_access);\n\t\tspace = isl_space_domain(space);\n\t\twrites_i = isl_set_universe(space);\n\t\twrites = isl_union_set_add_set(writes, writes_i);\n\t}\n\n\treturn writes;\n}\n\n/* Is there any write access in \"group\" that requires synchronization\n * on a write to global memory?\n * We currently take into account all writes that would require\n * synchronization at the thread level depth, but if the copying\n * for this group is performed at an outer level, then we do not\n * actually need to take into account dependences at intermediate levels.\n */\nstatic int any_sync_writes_in_group(struct ppcg_kernel *kernel,\n\tstruct gpu_array_ref_group *group)\n{\n\tisl_union_set *writes;\n\tint empty, disjoint;\n\n\tempty = isl_union_set_is_empty(kernel->sync_writes);\n\tif (empty < 0)\n\t\treturn -1;\n\tif (empty)\n\t\treturn 0;\n\n\twrites = group_tagged_writes(group);\n\tdisjoint = isl_union_set_is_disjoint(kernel->sync_writes, writes);\n\tisl_union_set_free(writes);\n\n\treturn disjoint < 0 ? -1 : !disjoint;\n}\n\n/* Collect the references to all writes in \"kernel\" that write directly\n * to global or shared memory, i.e., that are not mapped to private memory.\n * Each reference is represented by a universe set in a space\n *\n *\t[S[i,j] -> R[]]\n *\n * with S[i,j] the statement instance space and R[] the array reference.\n */\nstatic __isl_give isl_union_set *collect_non_private_tagged_writes(\n\tstruct ppcg_kernel *kernel)\n{\n\tisl_union_set *writes;\n\tint i, j;\n\n\twrites = isl_union_set_empty(isl_union_set_get_space(kernel->arrays));\n\n\tfor (i = 0; i < kernel->n_array; ++i) {\n\t\tstruct gpu_local_array_info *array = &kernel->array[i];\n\n\t\tfor (j = 0; j < array->n_group; ++j) {\n\t\t\tstruct gpu_array_ref_group *group = array->groups[j];\n\t\t\tenum ppcg_group_access_type type;\n\t\t\tisl_union_set *writes_ij;\n\n\t\t\tif (!group->write)\n\t\t\t\tcontinue;\n\t\t\ttype = gpu_array_ref_group_type(group);\n\t\t\tif (type == ppcg_access_private)\n\t\t\t\tcontinue;\n\t\t\twrites_ij = group_tagged_writes(group);\n\t\t\twrites = isl_union_set_union(writes, writes_ij);\n\t\t}\n\t}\n\n\treturn writes;\n}\n\n/* Are there any direct writes to global memory that require\n * synchronization?\n */\nstatic int any_global_or_shared_sync_writes(struct ppcg_kernel *kernel)\n{\n\tisl_union_set *writes;\n\tint empty, disjoint;\n\n\tempty = isl_union_set_is_empty(kernel->sync_writes);\n\tif (empty < 0)\n\t\treturn -1;\n\tif (empty)\n\t\treturn 0;\n\n\twrites = collect_non_private_tagged_writes(kernel);\n\tdisjoint = isl_union_set_is_disjoint(kernel->sync_writes, writes);\n\tisl_union_set_free(writes);\n\n\treturn disjoint < 0 ? -1 : !disjoint;\n}\n\n/* Construct an isl_multi_val for use as tile sizes for tiling \"node\"\n * from the elements in \"tile_size\".\n */\nstatic __isl_give isl_multi_val *construct_band_tiles_sizes(\n\t__isl_keep isl_schedule_node *node, int *tile_size)\n{\n\tisl_space *space;\n\n\tif (!node)\n\t\treturn NULL;\n\n\tspace = isl_schedule_node_band_get_space(node);\n\treturn ppcg_multi_val_from_int_list(space, tile_size);\n}\n\n/* Replace the partial schedule S of the band node \"node\" by\n *\n *\tfloor(S/f)\n *\n * or\n *\n *\tf * floor(S/f)\n *\n * if scale_tile_loops is set, with f the integers in \"factor\".\n * The list that \"factor\" points to is assumed to contain at least\n * as many elements as the number of members in the band.\n */\nstatic __isl_give isl_schedule_node *snap_band_to_sizes(\n\t__isl_take isl_schedule_node *node, int *factor,\n\tstruct ppcg_options *options)\n{\n\tisl_multi_val *mv;\n\n\tmv = construct_band_tiles_sizes(node, factor);\n\tnode = isl_schedule_node_band_scale_down(node, isl_multi_val_copy(mv));\n\tif (options->scale_tile_loops)\n\t\tnode = isl_schedule_node_band_scale(node,\n\t\t\t\t\t\t\tisl_multi_val_copy(mv));\n\tisl_multi_val_free(mv);\n\n\treturn node;\n}\n\n/* Tile \"band\" with tile size specified by \"sizes\".\n *\n * Since the tile loops will be mapped to block ids, we forcibly\n * turn off tile loop scaling.  We may want to enable tile loop scaling\n * at some later point, but then we would have to support the detection\n * of strides during the mapping to block ids.\n * Similarly, since the point loops will be mapped to thread ids,\n * we forcibly shift the point loops so that they start at zero.\n */\nstatic __isl_give isl_schedule_node *tile_band(\n\t__isl_take isl_schedule_node *node, __isl_take isl_multi_val *sizes)\n{\n\tisl_ctx *ctx = isl_schedule_node_get_ctx(node);\n\tint scale_tile;\n\tint shift_point;\n\n\tscale_tile = isl_options_get_tile_scale_tile_loops(ctx);\n\tisl_options_set_tile_scale_tile_loops(ctx, 0);\n\tshift_point = isl_options_get_tile_shift_point_loops(ctx);\n\tisl_options_set_tile_shift_point_loops(ctx, 1);\n\n\tnode = isl_schedule_node_band_tile(node, sizes);\n\n\tisl_options_set_tile_scale_tile_loops(ctx, scale_tile);\n\tisl_options_set_tile_shift_point_loops(ctx, shift_point);\n\n\treturn node;\n}\n\n/* Extract the set of parameter values and outer schedule dimensions\n * for which any statement instance\n * in the kernel inserted at \"node\" needs to be executed.\n * Intersect the set of parameter values derived from the host schedule\n * relation with the context of \"prog\".\n */\nstatic __isl_give isl_set *extract_context(__isl_keep isl_schedule_node *node,\n\tstruct gpu_prog *prog)\n{\n\tisl_union_map *schedule;\n\tisl_union_set *schedule_domain;\n\tisl_set *context;\n\tint empty;\n\n\tschedule = isl_schedule_node_get_prefix_schedule_relation(node);\n\tschedule_domain = isl_union_map_range(schedule);\n\tempty = isl_union_set_is_empty(schedule_domain);\n\tif (empty < 0) {\n\t\tisl_union_set_free(schedule_domain);\n\t\treturn NULL;\n\t}\n\tif (empty) {\n\t\tint depth;\n\t\tisl_space *space;\n\n\t\tspace = isl_union_set_get_space(schedule_domain);\n\t\tisl_union_set_free(schedule_domain);\n\t\tspace = isl_space_set_from_params(space);\n\t\tdepth = isl_schedule_node_get_schedule_depth(node);\n\t\tspace = isl_space_add_dims(space, isl_dim_set, depth);\n\t\tcontext = isl_set_empty(space);\n\t} else {\n\t\tcontext = isl_set_from_union_set(schedule_domain);\n\t}\n\tcontext = isl_set_intersect_params(context,\n\t\t\t\t\t    isl_set_copy(prog->context));\n\n\treturn context;\n}\n\n/* Return the set of outer array elements accessed by\n * by the statement instances in \"domain\" in \"prog\".\n * The instances in \"domain\" are those that appear\n * in the domains of the access relations in \"prog\".\n */\nstatic __isl_give isl_union_set *accessed_by_domain(\n\t__isl_take isl_union_set *domain, struct gpu_prog *prog)\n{\n\tisl_union_map *access;\n\tisl_union_set *arrays;\n\n\taccess = isl_union_map_union(isl_union_map_copy(prog->read),\n\t\t\t\t     isl_union_map_copy(prog->may_write));\n\taccess = isl_union_map_intersect_domain(access, domain);\n\tarrays = isl_union_map_range(access);\n\tarrays = isl_union_set_apply(arrays,\n\t\t\t\tisl_union_map_copy(prog->to_outer));\n\n\treturn arrays;\n}\n\n/* Return the number of outer band members of the band node \"node\"\n * that are marked coincident.\n */\nstatic int n_outer_coincidence(__isl_keep isl_schedule_node *node)\n{\n\tint i, n;\n\n\tn = isl_schedule_node_band_n_member(node);\n\n\tfor (i = 0; i < n; ++i)\n\t\tif (!isl_schedule_node_band_member_get_coincident(node, i))\n\t\t\tbreak;\n\n\treturn i;\n}\n\n/* If the band node \"node\" has more than \"n\" members, then split off\n * the first \"n\" of them.\n */\nstatic __isl_give isl_schedule_node *split_band(\n\t__isl_take isl_schedule_node *node, int n)\n{\n\tint dim;\n\n\tdim = isl_schedule_node_band_n_member(node);\n\tif (n < dim)\n\t\tnode = isl_schedule_node_band_split(node, n);\n\n\treturn node;\n}\n\n/* Scale a band node that may have been split by split_band.\n * \"sizes\" are the scaling factors for the original node.\n * \"node\" either points to the original band node, or the outer\n * of the two pieces after splitting.\n *\n * If the number of elements in \"node\" is smaller than the number of\n * elements in \"sizes\", then some splitting has occurred and we split\n * \"sizes\" in the same way.\n */\nstatic __isl_give isl_schedule_node *scale_band(\n\t__isl_take isl_schedule_node *node, __isl_take isl_multi_val *sizes)\n{\n\tint n, dim;\n\n\tn = isl_multi_val_dim(sizes, isl_dim_set);\n\tdim = isl_schedule_node_band_n_member(node);\n\tif (n > dim) {\n\t\tisl_multi_val *sizes2;\n\n\t\tsizes2 = isl_multi_val_copy(sizes);\n\t\tsizes = isl_multi_val_drop_dims(sizes,\n\t\t\t\t\t\tisl_dim_set, dim, n - dim);\n\t\tsizes2 = isl_multi_val_drop_dims(sizes2, isl_dim_set, 0, dim);\n\t\tnode = isl_schedule_node_child(node, 0);\n\t\tnode = isl_schedule_node_band_scale(node, sizes2);\n\t\tnode = isl_schedule_node_parent(node);\n\t}\n\n\treturn isl_schedule_node_band_scale(node, sizes);\n}\n\n/* Return an isl_multi_aff, with as elements the parameters in \"space\"\n * that have the names specified by the elements in \"names\".\n * If (some of) these parameters do not already appear in \"space\",\n * then they are added first.\n */\nstatic __isl_give isl_multi_aff *parameter_vector(__isl_take isl_space *space,\n\t__isl_keep isl_id_list *names)\n{\n\tint i, n;\n\tisl_local_space *ls;\n\tisl_multi_aff *ma;\n\n\tif (!names)\n\t\tspace = isl_space_free(space);\n\n\tn = isl_id_list_n_id(names);\n\tfor (i = 0; i < n; ++i) {\n\t\tint pos;\n\t\tisl_id *id;\n\n\t\tid = isl_id_list_get_id(names, i);\n\t\tpos = isl_space_find_dim_by_id(space, isl_dim_param, id);\n\t\tif (pos >= 0) {\n\t\t\tisl_id_free(id);\n\t\t\tcontinue;\n\t\t}\n\t\tpos = isl_space_dim(space, isl_dim_param);\n\t\tspace = isl_space_add_dims(space, isl_dim_param, 1);\n\t\tspace = isl_space_set_dim_id(space, isl_dim_param, pos, id);\n\t}\n\tma = isl_multi_aff_zero(isl_space_copy(space));\n\tls = isl_local_space_from_space(isl_space_domain(space));\n\tfor (i = 0; i < n; ++i) {\n\t\tint pos;\n\t\tisl_id *id;\n\t\tisl_aff *aff;\n\n\t\tid = isl_id_list_get_id(names, i);\n\t\tpos = isl_space_find_dim_by_id(space, isl_dim_param, id);\n\t\tisl_id_free(id);\n\t\taff = isl_aff_var_on_domain(isl_local_space_copy(ls),\n\t\t\t\t\t    isl_dim_param, pos);\n\t\tma = isl_multi_aff_set_aff(ma, i, aff);\n\t}\n\tisl_local_space_free(ls);\n\n\treturn ma;\n}\n\n/* Return constraints on the domain elements that equate a sequence of\n * parameters called \"names\", to the partial schedule\n * of \"node\" modulo the integers in \"size\".\n * The number of elements in the array \"size\" should be equal\n * to the number of elements in \"names\".\n * The number of members of the band node \"node\" should be smaller\n * than or equal to this number.  If it is smaller, then the first\n * elements of \"names\" are equated to zero.\n */\nstatic __isl_give isl_union_set *set_schedule_modulo(\n\t__isl_keep isl_schedule_node *node, __isl_keep isl_id_list *names,\n\tint *size)\n{\n\tint n, n_zero;\n\tisl_space *space;\n\tisl_multi_aff *ma;\n\tisl_multi_union_pw_aff *mupa, *mupa2;\n\tisl_multi_val *mv;\n\tisl_union_set *domain;\n\n\tif (!node)\n\t\treturn NULL;\n\tn = isl_id_list_n_id(names);\n\tif (n == 0)\n\t\treturn isl_schedule_node_get_universe_domain(node);\n\tn_zero = n - isl_schedule_node_band_n_member(node);\n\n\tmupa = isl_schedule_node_band_get_partial_schedule(node);\n\tmv = construct_band_tiles_sizes(node, size + n_zero);\n\tmupa = isl_multi_union_pw_aff_mod_multi_val(mupa, mv);\n\n\tspace = isl_multi_union_pw_aff_get_space(mupa);\n\tspace = isl_space_params(space);\n\tspace = isl_space_set_from_params(space);\n\tspace = isl_space_add_dims(space, isl_dim_set, n_zero);\n\tma = isl_multi_aff_zero(space);\n\n\tdomain = isl_schedule_node_get_universe_domain(node);\n\tmupa2 = isl_multi_union_pw_aff_multi_aff_on_domain(\n\t\t\t\t\t\tisl_union_set_copy(domain), ma);\n\tmupa = isl_multi_union_pw_aff_range_product(mupa2, mupa);\n\n\tspace = isl_multi_union_pw_aff_get_space(mupa);\n\tma = parameter_vector(space, names);\n\n\tmupa2 = isl_multi_union_pw_aff_multi_aff_on_domain(domain, ma);\n\tmupa = isl_multi_union_pw_aff_sub(mupa, mupa2);\n\n\treturn isl_multi_union_pw_aff_zero_union_set(mupa);\n}\n\n/* Insert a context node at \"node\" introducing the block and thread\n * identifiers along with their bounds, which are stored in kernel->grid_size\n * and kernel->block_dim.\n * Note that the bounds on the block identifiers may implicitly impose\n * constraints on the parameters.  A guard needs to be inserted\n * in the schedule tree to ensure that those bounds hold at \"node\".\n * This guard is inserted in insert_guard.\n */\nstatic __isl_give isl_schedule_node *insert_context(struct ppcg_kernel *kernel,\n\t__isl_take isl_schedule_node *node)\n{\n\tisl_set *context;\n\n\tcontext = isl_set_universe(isl_set_get_space(kernel->context));\n\n\tcontext = add_bounded_parameters_dynamic(context,\n\t\t\t\t\tkernel->grid_size, kernel->block_ids);\n\tcontext = add_bounded_parameters(context,\n\t\t\t\t\tkernel->block_dim, kernel->thread_ids);\n\n\tnode = isl_schedule_node_insert_context(node, context);\n\n\treturn node;\n}\n\n/* Insert a guard that eliminates kernel launches where the kernel\n * obviously does not have any work to do.\n *\n * In particular, eliminate kernel launches where there are obviously\n * zero blocks.\n * Use the same block size constraints that are used to create the context\n * to ensure that all constraints implicit in the constructed context\n * are imposed by the guard.\n *\n * Additionally, add other constraints that are valid\n * for each executed instance (\"context\"), as long as this does not result\n * in a disjunction.\n */\nstatic __isl_give isl_schedule_node *insert_guard(\n\t__isl_take isl_schedule_node *node, __isl_keep isl_set *context,\n\t__isl_keep isl_multi_pw_aff *size, struct ppcg_scop *scop)\n{\n\tunsigned nparam, n;\n\tisl_set *guard;\n\tisl_id_list *ids;\n\n\tguard = isl_set_copy(context);\n\tguard = isl_set_compute_divs(guard);\n\tguard = isl_set_from_basic_set(isl_set_simple_hull(guard));\n\n\tnparam = isl_set_dim(guard, isl_dim_param);\n\tn = isl_multi_pw_aff_dim(size, isl_dim_out);\n\tids = ppcg_scop_generate_names(scop, n, \"__ppcg_tmp\");\n\tguard = add_bounded_parameters_dynamic(guard, size, ids);\n\tisl_id_list_free(ids);\n\tguard = isl_set_project_out(guard, isl_dim_param, nparam, n);\n\n\tnode = isl_schedule_node_insert_guard(node, guard);\n\n\treturn node;\n}\n\n/* Does any array reference group mapping require the band that is mapped\n * to threads to be unrolled?\n */\nstatic int kernel_requires_unroll(struct ppcg_kernel *kernel)\n{\n\tint i, j;\n\n\tfor (i = 0; i < kernel->n_array; ++i) {\n\t\tstruct gpu_local_array_info *array = &kernel->array[i];\n\n\t\tfor (j = 0; j < array->n_group; ++j) {\n\t\t\tstruct gpu_array_ref_group *group = array->groups[j];\n\t\t\tif (gpu_array_ref_group_requires_unroll(group))\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/* Mark the given band node \"node\" for unrolling by the AST generator and\n * then sink it to the leaves of the schedule tree.\n * All dimensions of \"node\" are assumed to be coincident, such that this\n * sinking is a valid operation.\n */\nstatic __isl_give isl_schedule_node *unroll(__isl_take isl_schedule_node *node)\n{\n\tnode = ppcg_set_schedule_node_type(node, isl_ast_loop_unroll);\n\n\tnode = isl_schedule_node_band_sink(node);\n\n\treturn node;\n}\n\n/* Insert a synchronization node in the schedule tree of \"node\"\n * after the core computation of \"kernel\" at the level of the band\n * that is mapped to threads, except if that level is equal to\n * that of the band that is mapped to blocks or if there are no writes\n * to global or shared memory in the core computation that require\n * synchronization.\n * If there are any writes to shared memory and the shared memory\n * copying is performed at the same level, then synchronization\n * is needed between the core and the copying anyway, so we might\n * as well add it here.  If the copying is performed at a higher\n * level, then different iterations of intermediate schedule dimensions\n * may have a different mapping from between shared memory elements and\n * threads, such that synchronization is required after the core.\n * \"node\" is assumed to point to the kernel node.\n *\n * If the shared and the thread mark point to the same node, then make\n * sure the synchronization is inserted outside of the shared mark.\n */\nstatic __isl_give isl_schedule_node *add_sync(struct ppcg_kernel *kernel,\n\t__isl_take isl_schedule_node *node)\n{\n\tint depth;\n\tint need_sync;\n\n\tneed_sync = any_global_or_shared_sync_writes(kernel);\n\tif (need_sync < 0)\n\t\treturn isl_schedule_node_free(node);\n\tif (!need_sync)\n\t\treturn node;\n\n\tnode = gpu_tree_move_down_to_thread(node, kernel->core);\n\tdepth = isl_schedule_node_get_schedule_depth(node);\n\tnode = gpu_tree_move_up_to_kernel(node);\n\tif (depth == isl_schedule_node_get_schedule_depth(node))\n\t\treturn node;\n\n\tnode = gpu_tree_move_down_to_depth(node, depth, kernel->core);\n\tnode = gpu_tree_ensure_following_sync(node, kernel);\n\n\tnode = gpu_tree_move_up_to_kernel(node);\n\n\treturn node;\n}\n\n/* Return a read (\"read\" is 1) or write access relation for \"group\"\n * with those accesses removed that are only needed to communicate data\n * within the subtree of the schedule rooted at \"node\".\n * Furthermore, include the prefix schedule at \"node\".\n * That is, return a relation of the form\n *\n *\tS -> [D -> A]\n *\n * with D the outer schedule dimensions at \"node\".\n */\nstatic __isl_give isl_union_map *anchored_non_local_accesses(\n\tstruct ppcg_kernel *kernel, struct gpu_array_ref_group *group,\n\t__isl_take isl_schedule_node *node, int read)\n{\n\tisl_union_map *access;\n\tisl_union_map *prefix;\n\n\tprefix = isl_schedule_node_get_prefix_schedule_relation(node);\n\tprefix = isl_union_map_preimage_domain_union_pw_multi_aff(prefix,\n\t\t\t    isl_union_pw_multi_aff_copy(kernel->contraction));\n\taccess = gpu_array_ref_group_access_relation(group, read, !read);\n\taccess = remove_local_accesses_group(kernel, group, access, prefix,\n\t\t\t\t\t\tread);\n\taccess = isl_union_map_range_product(prefix, access);\n\n\treturn access;\n}\n\n/* Given an array reference group \"group\", create a mapping\n *\n *\tread[D -> A] -> [D -> A]\n *\n * if \"read\" is set or\n *\n *\twrite[D -> A] -> [D -> A]\n *\n * if \"read\" is not set.\n * D corresponds to the outer tile->depth dimensions of\n * the kernel schedule.\n */\nstatic __isl_give isl_multi_aff *create_from_access(isl_ctx *ctx,\n\tstruct gpu_array_ref_group *group, int read)\n{\n\tstruct gpu_array_tile *tile;\n\tisl_space *space;\n\tisl_id *id;\n\n\ttile = gpu_array_ref_group_tile(group);\n\tspace = isl_space_copy(group->array->space);\n\tspace = isl_space_from_range(space);\n\tspace = isl_space_add_dims(space, isl_dim_in, tile->depth);\n\tspace = isl_space_wrap(space);\n\tspace = isl_space_map_from_set(space);\n\n\tid = isl_id_alloc(ctx, read ? \"read\" : \"write\", group);\n\tspace = isl_space_set_tuple_id(space, isl_dim_in, id);\n\n\treturn isl_multi_aff_identity(space);\n}\n\n/* If any writes in \"group\" require synchronization, then make sure\n * that there is a synchronization node for \"kernel\" after the node\n * following \"node\" in a sequence.\n *\n * If \"shared\" is set and no synchronization is needed for\n * the writes to global memory, then add synchronization before\n * the kernel to protect shared memory from being overwritten\n * by the next iteration of the core computation.\n * No additional synchronization is needed to protect against\n * the next copy into shared memory because each element of\n * the shared memory tile is always copied by the same thread.\n */\nstatic __isl_give isl_schedule_node *add_group_write_sync(\n\t__isl_take isl_schedule_node *node, struct ppcg_kernel *kernel,\n\tstruct gpu_array_ref_group *group, int shared)\n{\n\tint need_sync;\n\n\tneed_sync = any_sync_writes_in_group(kernel, group);\n\tif (need_sync < 0)\n\t\treturn isl_schedule_node_free(node);\n\tif (need_sync) {\n\t\tnode = isl_schedule_node_parent(node);\n\t\tnode = isl_schedule_node_next_sibling(node);\n\t\tnode = isl_schedule_node_child(node, 0);\n\t\tnode = gpu_tree_ensure_following_sync(node, kernel);\n\t} else if (shared) {\n\t\tstruct gpu_array_tile *tile;\n\n\t\ttile = gpu_array_ref_group_tile(group);\n\t\tnode = isl_schedule_node_parent(node);\n\t\tnode = isl_schedule_node_parent(node);\n\t\tnode = gpu_tree_move_down_to_depth(node, tile->depth,\n\t\t\t\t\t\t\tkernel->core);\n\t\tnode = gpu_tree_move_left_to_sync(node, kernel);\n\t}\n\n\treturn node;\n}\n\n/* Add copy statements to the schedule tree of \"node\"\n * for reading from global memory to private memory (if \"read\" is set) or\n * for writing back from private memory to global memory\n * (if \"read\" is not set) for the array reference group \"group\" that\n * is mapped to private memory.\n * On input, \"node\" points to the kernel node, and it is moved\n * back there on output.\n *\n * The copies are performed in the order of the array elements.\n * The copy statement instances include a reference to the outer\n * tile->depth dimensions of the kernel schedule for ease of\n * combining them with the group tiling.\n *\n * That is, the extra schedule is of the form\n *\n *\ttype[D -> A] -> A\n *\n * where D corresponds to the outer tile->depth dimensions of\n * the kernel schedule and A to the global array.\n * This schedule is unrolled because registers are not addressable.\n *\n * The copying is inserted in the schedule tree through an extension\n * of the form\n *\n *\tD -> type[D -> A]\n *\n * where the extra domain elements type[D -> A] are those accessed\n * by the group.\n * A filter is inserted on type[D -> A] to ensure that the element\n * is read/written by the same thread that needs the element.\n * This filter is obtained by applying\n *\n *\tS -> type[D -> A]\n *\n * to the thread filter for the core statements.\n *\n * The extension is inserted before the core computation in case of a read\n * and after the core computation in case of a write.\n * In the latter case, we also make sure that there is a synchronization\n * node after the write to global memory, unless this write is performed\n * at the outer level of the kernel.\n * In principle, this synchronization could be inserted higher\n * in the schedule tree depending on where the corresponding reads\n * from global memory are performed.\n */\nstatic __isl_give isl_schedule_node *add_copies_group_private(\n\tstruct ppcg_kernel *kernel, struct gpu_array_ref_group *group,\n\t__isl_take isl_schedule_node *node, int read)\n{\n\tstruct gpu_array_tile *tile;\n\tisl_union_map *access;\n\tisl_union_set *domain;\n\tisl_space *space;\n\tisl_multi_aff *from_access;\n\tisl_multi_pw_aff *mpa;\n\tisl_multi_union_pw_aff *mupa;\n\tisl_union_pw_multi_aff *contraction;\n\tisl_schedule_node *graft;\n\tisl_union_set *filter;\n\tint kernel_depth;\n\tint empty;\n\n\tkernel_depth = isl_schedule_node_get_schedule_depth(node);\n\ttile = gpu_array_ref_group_tile(group);\n\tnode = gpu_tree_move_down_to_depth(node, tile->depth, kernel->core);\n\n\taccess = anchored_non_local_accesses(kernel, group, node, read);\n\tempty = isl_union_map_is_empty(access);\n\tif (empty < 0 || empty) {\n\t\tisl_union_map_free(access);\n\t\tif (empty < 0)\n\t\t\treturn isl_schedule_node_free(node);\n\t\treturn gpu_tree_move_up_to_kernel(node);\n\t}\n\n\tgroup->array->global = 1;\n\tgroup->local_array->global = 1;\n\n\tfrom_access = create_from_access(kernel->ctx, group, read);\n\tspace = isl_space_domain(isl_multi_aff_get_space(from_access));\n\taccess = isl_union_map_preimage_range_multi_aff(access, from_access);\n\n\tfilter = isl_union_set_copy(kernel->thread_filter);\n\tcontraction = isl_union_pw_multi_aff_copy(kernel->contraction);\n\tfilter = isl_union_set_preimage_union_pw_multi_aff(filter, contraction);\n\tfilter = isl_union_set_apply(filter, isl_union_map_copy(access));\n\tfilter = isl_union_set_detect_equalities(filter);\n\tfilter = isl_union_set_coalesce(filter);\n\n\tdomain = isl_union_map_range(access);\n\taccess = isl_union_set_wrapped_domain_map(domain);\n\taccess = isl_union_map_reverse(access);\n\taccess = isl_union_map_coalesce(access);\n\tgraft = isl_schedule_node_from_extension(access);\n\n\tspace = isl_space_map_from_set(space);\n\tmpa = isl_multi_pw_aff_identity(space);\n\tmpa = isl_multi_pw_aff_range_factor_range(mpa);\n\tmupa = isl_multi_union_pw_aff_from_multi_pw_aff(mpa);\n\n\tgraft = isl_schedule_node_child(graft, 0);\n\tgraft = isl_schedule_node_insert_partial_schedule(graft, mupa);\n\tgraft = unroll(graft);\n\n\tgraft = isl_schedule_node_insert_filter(graft, filter);\n\n\tgraft = isl_schedule_node_parent(graft);\n\n\tif (read)\n\t\tnode = isl_schedule_node_graft_before(node, graft);\n\telse {\n\t\tnode = isl_schedule_node_graft_after(node, graft);\n\t\tif (kernel_depth < tile->depth)\n\t\t\tnode = add_group_write_sync(node, kernel, group, 0);\n\t}\n\n\tnode = gpu_tree_move_up_to_kernel(node);\n\n\treturn node;\n}\n\n/* Add copy statements to the schedule tree of \"node\"\n * for reading from global memory to shared memory (if \"read\" is set) or\n * for writing back from shared memory to global memory\n * (if \"read\" is not set) for the array reference group \"group\" that\n * is mapped to shared memory.\n * On input, \"node\" points to the kernel node, and it is moved\n * back there on output.\n *\n * The copies are performed in the order of the corresponding shared\n * memory tile.\n * The copy statement instances include a reference to the outer\n * tile->depth dimensions of the kernel schedule for ease of\n * combining them with the group tiling.\n *\n * If we are performing a read from global memory to shared memory and\n * if the array involved is not a scalar, then we copy\n * the entire tile to shared memory.  This may result in some extra\n * elements getting copied, but it should lead to simpler code\n * (which means that fewer registers may be needed) and less divergence.\n *\n * Otherwise, we only copy the elements that will be read or have been written\n * in the kernel.\n *\n * That is, the extra schedule is of the form\n *\n *\ttype[D -> A] -> T\n *\n * where D corresponds to the outer tile->depth dimensions of\n * the kernel schedule, A to the global array and T is the corresponding\n * shared memory tile.\n *\n * The copying is inserted in the schedule tree through an extension\n * of the form\n *\n *\tD -> type[D -> A]\n *\n * where the extra domain elements type[D -> A] are those accessed\n * by the group.  In the case of read from a non-scalar, this set\n * is replaced by the entire shared memory tile.\n *\n * If the \"unroll_copy_shared\" option is set, then the AST generator\n * is instructed to unroll the copying code.\n *\n * A filter is inserted on type[D -> A] to map the copy instances\n * to the threads.  In particular, the thread identifiers are\n * equated to the position inside the shared memory tile (T)\n * modulo the block size.\n * We try to align the innermost tile dimension with the innermost\n * thread identifier (x) as a heuristic to improve coalescing.\n * In particular, if the dimension of the tile is greater than\n * the dimension of the block, then the schedule mapping to the tile\n * is broken up into two pieces and the filter is applied to the inner part.\n * If, on the other hand, the dimension of the tile is smaller than\n * the dimension of the block, then the initial thread identifiers\n * are equated to zero and the remaining thread identifiers are\n * matched to the memory tile.\n *\n * The extension is inserted before the core computation in case of a read\n * and after the core computation in case of a write.\n * In the case of a read, we first need to make sure there is some\n * synchronization before the core computation such that we can put the read\n * from global memory to shared memory before that synchronization.\n * This ensures that all threads have finished copying into shared memory\n * before the shared memory is used.\n * We also need to make sure that there is a synchronization node after\n * the core computation to ensure that the next load into shared memory\n * only happens after all data has been used.  There is no need for\n * this synchronization if we are at the outer level since then there\n * won't be a next load.\n * In the case of a write, we need to make sure there is some synchronization\n * after the core computation such taht we can put the write from shared\n * memory to global memory after that synchronization.\n * Unless we are at the outer level, we also need a synchronization node\n * after the write to ensure the data is saved to global memory\n * before the next iteration write to the same shared memory.\n * It also makes sure the data has arrived in global memory before\n * it is read in a subsequent iteration.\n */\nstatic __isl_give isl_schedule_node *add_copies_group_shared(\n\tstruct ppcg_kernel *kernel, struct gpu_array_ref_group *group,\n\t__isl_take isl_schedule_node *node, int read)\n{\n\tstruct gpu_array_tile *tile;\n\tisl_union_map *access;\n\tisl_union_set *domain;\n\tisl_multi_aff *ma;\n\tisl_multi_aff *from_access;\n\tisl_multi_pw_aff *mpa;\n\tisl_multi_union_pw_aff *mupa;\n\tisl_schedule_node *graft;\n\tisl_union_set *filter;\n\tint skip;\n\tint kernel_depth;\n\tint empty;\n\n\ttile = gpu_array_ref_group_tile(group);\n\tkernel_depth = isl_schedule_node_get_schedule_depth(node);\n\tnode = gpu_tree_move_down_to_depth(node, tile->depth, kernel->core);\n\n\taccess = anchored_non_local_accesses(kernel, group, node, read);\n\tempty = isl_union_map_is_empty(access);\n\tif (empty < 0 || empty) {\n\t\tisl_union_map_free(access);\n\t\tif (empty < 0)\n\t\t\treturn isl_schedule_node_free(node);\n\t\treturn gpu_tree_move_up_to_kernel(node);\n\t}\n\n\tgroup->array->global = 1;\n\tgroup->local_array->global = 1;\n\n\tfrom_access = create_from_access(kernel->ctx, group, read);\n\n\tma = isl_multi_aff_copy(tile->tiling);\n\tma = isl_multi_aff_pullback_multi_aff(ma,\n\t\t\t\t\t    isl_multi_aff_copy(from_access));\n\tmpa = isl_multi_pw_aff_from_multi_aff(ma);\n\tmupa = isl_multi_union_pw_aff_from_multi_pw_aff(mpa);\n\n\tdomain = isl_union_map_range(access);\n\n\tif (read && !gpu_array_is_scalar(group->array)) {\n\t\tisl_map *map;\n\t\tisl_union_set_free(domain);\n\t\tmap = group_tile(group);\n\t\tdomain = isl_union_set_from_set(isl_map_wrap(map));\n\t}\n\n\tdomain = isl_union_set_preimage_multi_aff(domain, from_access);\n\taccess = isl_union_set_wrapped_domain_map(domain);\n\taccess = isl_union_map_reverse(access);\n\taccess = isl_union_map_coalesce(access);\n\tgraft = isl_schedule_node_from_extension(access);\n\n\tgraft = isl_schedule_node_child(graft, 0);\n\n\tgraft = isl_schedule_node_insert_partial_schedule(graft, mupa);\n\tif (kernel->options->unroll_copy_shared)\n\t\tgraft = ppcg_set_schedule_node_type(graft, isl_ast_loop_unroll);\n\n\tif (tile->n > kernel->n_block && kernel->n_block > 0) {\n\t\tgraft = isl_schedule_node_band_split(graft,\n\t\t\t\t\t\ttile->n - kernel->n_block);\n\t\tgraft = isl_schedule_node_child(graft, 0);\n\t}\n\tif (tile->n < kernel->n_block)\n\t\tskip = kernel->n_block - tile->n;\n\telse\n\t\tskip = 0;\n\tfilter = set_schedule_modulo(graft, kernel->thread_ids,\n\t\t\t\t\tkernel->block_dim);\n\tif (!kernel->options->wrap)\n\t\tgraft = snap_band_to_sizes(graft, kernel->block_dim + skip,\n\t\t\t    kernel->options);\n\tif (tile->n > kernel->n_block && kernel->n_block > 0)\n\t\tgraft = isl_schedule_node_parent(graft);\n\tgraft = isl_schedule_node_insert_filter(graft, filter);\n\n\twhile (graft && isl_schedule_node_has_parent(graft))\n\t\tgraft = isl_schedule_node_parent(graft);\n\n\tif (read) {\n\t\tif (kernel_depth < tile->depth)\n\t\t\tnode = gpu_tree_ensure_sync_after_core(node, kernel);\n\t\tnode = gpu_tree_move_left_to_sync(node, kernel);\n\t\tnode = isl_schedule_node_graft_before(node, graft);\n\t} else {\n\t\tnode = gpu_tree_move_right_to_sync(node, kernel);\n\t\tnode = isl_schedule_node_graft_after(node, graft);\n\t\tif (kernel_depth < tile->depth)\n\t\t\tnode = add_group_write_sync(node, kernel, group, 1);\n\t}\n\n\tnode = gpu_tree_move_up_to_kernel(node);\n\n\treturn node;\n}\n\n/* Check whether the array reference group \"group\" is mapped to\n * private or shared memory and, if so,\n * add copy statements to the schedule tree of \"node\"\n * for reading from global memory to private or shared memory\n * (if \"read\" is set) or for writing back from private or shared memory\n * to global memory (if \"read\" is not set) for this group.\n * On input, \"node\" points to the kernel node, and it is moved\n * back there on output.\n */\nstatic __isl_give isl_schedule_node *add_copies_group(\n\tstruct ppcg_kernel *kernel, struct gpu_array_ref_group *group,\n\t__isl_take isl_schedule_node *node, int read)\n{\n\tenum ppcg_group_access_type type;\n\n\ttype = gpu_array_ref_group_type(group);\n\tif (type == ppcg_access_private)\n\t\treturn add_copies_group_private(kernel, group, node, read);\n\tif (type == ppcg_access_shared)\n\t\treturn add_copies_group_shared(kernel, group, node, read);\n\treturn node;\n}\n\n/* For each array reference group that is mapped to private or shared memory,\n * add copy statements to the schedule tree of \"node\"\n * for reading from global memory to private or shared memory\n * and for writing back.\n * On input, \"node\" points to the kernel node, and it is moved\n * back there on output.\n */\nstatic __isl_give isl_schedule_node *add_copies(struct ppcg_kernel *kernel,\n\t__isl_take isl_schedule_node *node)\n{\n\tint i, j;\n\n\tfor (i = 0; i < kernel->n_array; ++i) {\n\t\tstruct gpu_local_array_info *array = &kernel->array[i];\n\n\t\tfor (j = 0; j < array->n_group; ++j) {\n\t\t\tstruct gpu_array_ref_group *group = array->groups[j];\n\n\t\t\tnode = add_copies_group(kernel, group, node, 1);\n\t\t\tif (!node)\n\t\t\t\treturn NULL;\n\t\t\tnode = add_copies_group(kernel, group, node, 0);\n\t\t\tif (!node)\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn node;\n}\n\n/* Mark all dimensions in the current band node atomic.\n */\nstatic __isl_give isl_schedule_node *atomic(__isl_take isl_schedule_node *node)\n{\n\treturn ppcg_set_schedule_node_type(node, isl_ast_loop_atomic);\n}\n\n/* Mark \"node\" atomic, if it is a band node.\n * Do the same for all ancestors.\n * Return a pointer to \"node\" (in the updated schedule tree).\n */\nstatic __isl_give isl_schedule_node *atomic_ancestors(\n\t__isl_take isl_schedule_node *node)\n{\n\tint pos;\n\n\tif (!node)\n\t\treturn NULL;\n\tif (!isl_schedule_node_has_parent(node))\n\t\treturn node;\n\n\tpos = isl_schedule_node_get_child_position(node);\n\tnode = isl_schedule_node_parent(node);\n\tif (isl_schedule_node_get_type(node) == isl_schedule_node_band)\n\t\tnode = atomic(node);\n\tnode = atomic_ancestors(node);\n\tnode = isl_schedule_node_child(node, pos);\n\n\treturn node;\n}\n\n/* Collect all write references that require synchronization.\n * \"node\" is assumed to point to the kernel node.\n * Each reference is represented by a universe set in a space\n *\n *\t[S[i,j] -> R[]]\n *\n * with S[i,j] the statement instance space and R[] the array reference.\n *\n * This function should be called before block and thread filters are added.\n *\n * Synchronization is needed after a write if there is a subsequent read\n * within the same block that may not be performed by the same thread.\n * There should not be any dependences between different blocks,\n * so we start with the flow dependences within the same kernel invocation\n * and we subtract from these those dependences that are mapped\n * to the same iteration of the bands where synchronization is inserted.\n * We do not remove pairs of instances that are known to map to\n * the same thread across different iterations of the intermediate\n * bands because the read may be performed by a different thread\n * than the one that needs the value if shared memory is involved.\n *\n * We also consider all pairs of possible writes that access the same\n * memory location and that may be mapped to the same block but not\n * to the same iteration of the intermediate bands.\n * In theory, it would be possible for one thread to still be in\n * a previous iteration of a loop in these bands.\n * A write to global memory in this delayed thread could then overwrite\n * a write from another thread that has already moved on to\n * the next iteration.\n *\n * After computing the above writes paired off with reads or writes\n * that depend on them, we project onto the domain writes.\n * Sychronization is needed after writes to global memory\n * through these references.\n */\nstatic __isl_give isl_union_set *compute_sync_writes(\n\tstruct ppcg_kernel *kernel, __isl_keep isl_schedule_node *node)\n{\n\tisl_union_map *local;\n\tisl_union_map *may_writes, *shared_access;\n\tisl_union_map *kernel_prefix, *thread_prefix;\n\tisl_union_map *equal;\n\tisl_union_set *wrap;\n\tisl_union_set *domain;\n\tisl_union_pw_multi_aff *contraction;\n\n\tkernel_prefix = isl_schedule_node_get_prefix_schedule_union_map(node);\n\tnode = isl_schedule_node_copy(node);\n\tnode = gpu_tree_move_down_to_thread(node, kernel->core);\n\tthread_prefix = isl_schedule_node_get_prefix_schedule_union_map(node);\n\tisl_schedule_node_free(node);\n\n\tcontraction = kernel->contraction;\n\tkernel_prefix = isl_union_map_preimage_domain_union_pw_multi_aff(\n\t\t    kernel_prefix, isl_union_pw_multi_aff_copy(contraction));\n\tthread_prefix = isl_union_map_preimage_domain_union_pw_multi_aff(\n\t\t    thread_prefix, isl_union_pw_multi_aff_copy(contraction));\n\tdomain = isl_union_set_copy(kernel->expanded_domain);\n\tdomain = isl_union_set_universe(domain);\n\n\tmay_writes = isl_union_map_copy(kernel->prog->scop->tagged_may_writes);\n\tmay_writes = isl_union_map_curry(may_writes);\n\tmay_writes = isl_union_map_intersect_domain(may_writes, domain);\n\tmay_writes = isl_union_map_uncurry(may_writes);\n\tshared_access = isl_union_map_copy(may_writes);\n\tshared_access = isl_union_map_apply_range(shared_access,\n\t\t\t\t\tisl_union_map_reverse(may_writes));\n\n\tlocal = isl_union_map_copy(kernel->prog->scop->tagged_dep_flow);\n\tlocal = isl_union_map_union(local, shared_access);\n\tlocal = isl_union_map_zip(local);\n\n\tequal = isl_union_map_apply_range(kernel_prefix,\n\t\t    isl_union_map_reverse(isl_union_map_copy(kernel_prefix)));\n\twrap = isl_union_map_wrap(equal);\n\tlocal = isl_union_map_intersect_domain(local, wrap);\n\tequal = isl_union_map_apply_range(thread_prefix,\n\t\t    isl_union_map_reverse(isl_union_map_copy(thread_prefix)));\n\twrap = isl_union_map_wrap(equal);\n\tlocal = isl_union_map_subtract_domain(local, wrap);\n\n\tlocal = isl_union_map_zip(local);\n\tlocal = isl_union_map_universe(local);\n\n\treturn isl_union_map_domain(local);\n}\n\n/* Group the domain elements into a single space, named kernelX,\n * with X the kernel sequence number \"kernel_id\".\n */\nstatic __isl_give isl_schedule_node *group_statements(\n\t__isl_take isl_schedule_node *node, int kernel_id)\n{\n\tchar buffer[20];\n\tisl_id *id;\n\n\tif (!node)\n\t\treturn NULL;\n\n\tsnprintf(buffer, sizeof(buffer), \"kernel%d\", kernel_id);\n\tid = isl_id_alloc(isl_schedule_node_get_ctx(node), buffer, NULL);\n\treturn isl_schedule_node_group(node, id);\n}\n\n/* Create a ppcg_kernel representing the domain instances that reach \"node\"\n * and insert a mark node pointing to the ppcg_kernel before \"node\".\n * The band that \"node\" points to is the band that needs to be mapped\n * to block identifiers.  The band that needs to be mapped to thread\n * identifiers should be marked by a \"thread\" mark by the caller.\n * The linear branch between the current node and the \"thread\" mark\n * may also have a \"shared\" mark.  If present, the mapping to shared\n * memory is computed at that point.\n * Both marks are removed by this function.\n * If \"scale\" is set, then the band that \"node\" points to is scaled\n * by \"sizes\".\n *\n * Mark all outer band nodes as atomic to ensure each kernel is only\n * scheduled once.\n * If the domain elements that reach \"node\" live in more than one space,\n * then group the domain elements into a single space, named kernelX,\n * with X the kernel sequence number.\n *\n * Insert a guard node governing the kernel node to ensure that\n * no kernels with zero blocks are launched.\n *\n * Insert a context node describing the block and thread\n * identifiers inside the kernel mark.\n * The context node needs to be inserted after the effective block size\n * has been determined such that the bounds on the thread identifiers\n * would reflect the effective block size.\n * Insert a filter node inside the context node mapping the statement\n * instances to block identifiers.  In particular, the block identifiers\n * are equated to the partial schedule of band that was marked for mapping\n * to blocks modulo the grid size.\n * Insert a filter node inside the \"thread\" mark mapping the statement\n * instances to thread identifiers.  In particular, the thread identifiers\n * are equated to the partial schedule of band that was marked for mapping\n * to threads modulo the block size.\n *\n * Compute array reference groups for all arrays, set the local\n * array bounds based on the set of domain instances that reach\n * the kernel node, check the total amount of shared memory used\n * and compute all group tilings.\n * The array reference groups are computed after the block filter\n * has been inserted because it affects the mapping to shared or\n * private memory.  This computation also requires the thread filter\n * (in the ppcg_kernel object), but this thread filter should not\n * have been added to the schedule tree yet since the computation\n * requires the schedule of the band that needs to be mapped to\n * threads before the privatization is applied.\n *\n * If any array reference group requires the band mapped to threads\n * to be unrolled, then we perform the required unrolling.\n *\n * We save a copy of the schedule that may influence the mappings\n * to shared or private memory in kernel->copy_schedule.\n *\n * Finally, we add synchronization and copy statements to the schedule tree,\n * remove the \"thread\" mark and create representations for the local\n * variables in the kernel.\n *\n * We keep a copy of the isl_id that points to the kernel to ensure\n * that the kernel does not get destroyed if the schedule node\n * is freed due to some error condition.\n */\n__isl_give isl_schedule_node *gpu_create_kernel(struct gpu_gen *gen,\n\t__isl_take isl_schedule_node *node, int scale,\n\t__isl_keep isl_multi_val *sizes)\n{\n\tstruct ppcg_kernel *kernel;\n\tisl_id *id;\n\tisl_schedule_node *node_thread;\n\tisl_union_map *host_schedule;\n\tisl_union_pw_multi_aff *contraction;\n\tisl_set *host_domain;\n\tisl_union_set *domain, *expanded;\n\tint single_statement;\n\n\tnode = gpu_tree_insert_shared_before_thread(node);\n\tif (!node)\n\t\treturn NULL;\n\n\tkernel = isl_calloc_type(gen->ctx, struct ppcg_kernel);\n\tkernel = ppcg_kernel_create_local_arrays(kernel, gen->prog);\n\tif (!kernel)\n\t\treturn isl_schedule_node_free(node);\n\n\tdomain = isl_schedule_node_get_domain(node);\n\tsingle_statement = isl_union_set_n_set(domain) == 1;\n\n\tkernel->ctx = gen->ctx;\n\tkernel->prog = gen->prog;\n\tkernel->options = gen->options;\n\tkernel->context = extract_context(node, gen->prog);\n\tkernel->core = isl_union_set_universe(isl_union_set_copy(domain));\n\tcontraction = isl_schedule_node_get_subtree_contraction(node);\n\tkernel->contraction = isl_union_pw_multi_aff_copy(contraction);\n\texpanded = isl_union_set_copy(domain);\n\texpanded = isl_union_set_preimage_union_pw_multi_aff(expanded,\n\t\t\t\t\t\tcontraction);\n\tkernel->expanded_domain = isl_union_set_copy(expanded);\n\tkernel->arrays = accessed_by_domain(expanded, gen->prog);\n\tkernel->n_grid = n_outer_coincidence(node);\n\tnode_thread = isl_schedule_node_copy(node);\n\tnode_thread = gpu_tree_move_down_to_thread(node_thread, kernel->core);\n\tnode_thread = isl_schedule_node_child(node_thread, 0);\n\tkernel->n_block = n_outer_coincidence(node_thread);\n\tisl_schedule_node_free(node_thread);\n\tkernel->id = gen->kernel_id++;\n\tread_grid_and_block_sizes(kernel, gen);\n\n\tkernel->sync_writes = compute_sync_writes(kernel, node);\n\n\thost_schedule = isl_schedule_node_get_prefix_schedule_union_map(node);\n\thost_domain = isl_set_from_union_set(isl_union_map_range(\n\t\t\t\t\t\t\t\thost_schedule));\n\n\tnode = atomic_ancestors(node);\n\n\tid = isl_id_alloc(gen->ctx, \"kernel\", kernel);\n\tid = isl_id_set_free_user(id, &ppcg_kernel_free_wrap);\n\tnode = isl_schedule_node_insert_mark(node, isl_id_copy(id));\n\n\tif (!single_statement)\n\t\tnode = group_statements(node, kernel->id);\n\n\tnode = isl_schedule_node_child(node, 0);\n\tnode = split_band(node, kernel->n_grid);\n\tkernel->block_ids = ppcg_scop_generate_names(gen->prog->scop,\n\t\t\t\t\t\tkernel->n_grid, \"b\");\n\tkernel->block_filter = set_schedule_modulo(node, kernel->block_ids,\n\t\t\t\t\t\tkernel->grid_dim);\n\tkernel->grid_size = extract_grid_size(kernel,\n\t\t\t\t\t\tisl_union_set_copy(domain));\n\tif (!kernel->options->wrap)\n\t\tnode = snap_band_to_sizes(node, kernel->grid_dim,\n\t\t\t\t\t\tkernel->options);\n\tif (scale)\n\t\tnode = scale_band(node, isl_multi_val_copy(sizes));\n\tnode = isl_schedule_node_parent(node);\n\tif (!single_statement)\n\t\tnode = isl_schedule_node_parent(node);\n\tnode = insert_guard(node, kernel->context, kernel->grid_size,\n\t\t\t\tgen->prog->scop);\n\tnode = gpu_tree_move_down_to_thread(node, kernel->core);\n\tnode = isl_schedule_node_child(node, 0);\n\tnode = split_band(node, kernel->n_block);\n\tkernel->thread_ids = ppcg_scop_generate_names(gen->prog->scop,\n\t\t\t\t\t\tkernel->n_block, \"t\");\n\tkernel->thread_filter = set_schedule_modulo(node, kernel->thread_ids,\n\t\t\t\t\t\tkernel->block_dim);\n\tif (extract_block_size(kernel, domain) < 0)\n\t\tnode = isl_schedule_node_free(node);\n\n\tnode = gpu_tree_move_up_to_kernel(node);\n\tnode = isl_schedule_node_child(node, 0);\n\tnode = insert_context(kernel, node);\n\tnode = isl_schedule_node_child(node, 0);\n\tnode = isl_schedule_node_insert_filter(node,\n\t\t\t\t    isl_union_set_copy(kernel->block_filter));\n\n\tnode = gpu_tree_move_up_to_kernel(node);\n\n\tif (gpu_group_references(kernel, node) < 0)\n\t\tnode = isl_schedule_node_free(node);\n\tlocalize_bounds(kernel, host_domain);\n\tisl_set_free(host_domain);\n\n\tcheck_shared_memory_bound(kernel);\n\tmark_global_arrays(kernel);\n\tcompute_group_tilings(kernel);\n\n\tnode = gpu_tree_move_down_to_thread(node, kernel->core);\n\tnode = isl_schedule_node_child(node, 0);\n\tif (!kernel->options->wrap)\n\t\tnode = snap_band_to_sizes(node, kernel->block_dim,\n\t\t\t\t\t\tkernel->options);\n\tnode = isl_schedule_node_insert_filter(node,\n\t\t\t\t    isl_union_set_copy(kernel->thread_filter));\n\tif (kernel_requires_unroll(kernel)) {\n\t\tnode = isl_schedule_node_child(node, 0);\n\t\tnode = unroll(node);\n\t}\n\n\tnode = gpu_tree_move_up_to_thread(node);\n\tkernel->copy_schedule_dim = isl_schedule_node_get_schedule_depth(node);\n\tkernel->copy_schedule =\n\t\tisl_schedule_node_get_prefix_schedule_union_pw_multi_aff(node);\n\tcontraction = isl_union_pw_multi_aff_copy(kernel->contraction);\n\tkernel->copy_schedule =\n\t\tisl_union_pw_multi_aff_pullback_union_pw_multi_aff(\n\t\t\t\t\t    kernel->copy_schedule, contraction);\n\n\tnode = gpu_tree_move_up_to_kernel(node);\n\n\tnode = add_sync(kernel, node);\n\tnode = add_copies(kernel, node);\n\n\tnode = gpu_tree_move_down_to_shared(node, kernel->core);\n\tnode = isl_schedule_node_delete(node);\n\n\tnode = gpu_tree_move_down_to_thread(node, kernel->core);\n\tnode = isl_schedule_node_delete(node);\n\n\tnode = gpu_tree_move_up_to_kernel(node);\n\n\tif (create_kernel_vars(kernel) < 0)\n\t\tnode = isl_schedule_node_free(node);\n\n\tif (!single_statement)\n\t\tnode = isl_schedule_node_parent(node);\n\tnode = isl_schedule_node_parent(node);\n\n\tisl_id_free(id);\n\treturn node;\n}\n\n/* Insert a zero-dimensional permutable band at \"node\".\n */\nstatic __isl_give isl_schedule_node *insert_empty_permutable_band(\n\t__isl_take isl_schedule_node *node)\n{\n\tisl_space *space;\n\tisl_schedule *schedule;\n\tisl_union_set *domain;\n\tisl_multi_union_pw_aff *mupa;\n\n\tschedule = isl_schedule_node_get_schedule(node);\n\tdomain = isl_schedule_get_domain(schedule);\n\tspace = isl_union_set_get_space(domain);\n\tisl_union_set_free(domain);\n\tisl_schedule_free(schedule);\n\n\tspace = isl_space_set_from_params(space);\n\tmupa = isl_multi_union_pw_aff_zero(space);\n\tnode = isl_schedule_node_insert_partial_schedule(node, mupa);\n\tnode = isl_schedule_node_band_set_permutable(node, 1);\n\n\treturn node;\n}\n\n/* See if hybrid tiling can be performed on \"node\" and its parent.\n * If so, apply hybrid tiling and return the updated schedule tree.\n * If not, return the original schedule tree.\n * Return NULL on error.\n *\n * First check if \"node\", together with its parent, meets\n * the basic requirements for hybrid tiling.\n * If so, compute the relative dependence distances of \"node\"\n * with respect to its parent and check if they are sufficiently bounded.\n * If so, apply hybrid tiling using user specified tile sizes.\n *\n * The tile sizes are read before the dependence distance bounds are\n * computed, because the user may have specified fewer dimensions\n * than are available.  In this case, the remaining schedule dimensions\n * are split off and the dependence distances should be computed\n * after these dimensions have been split off.\n */\nstatic __isl_give isl_schedule_node *try_hybrid_tile(struct gpu_gen *gen,\n\t__isl_take isl_schedule_node *node)\n{\n\tint tile_len;\n\tint *tile_size;\n\tisl_bool ok;\n\tisl_schedule_node *orig = node;\n\tppcg_ht_bounds *bounds;\n\n\tok = ppcg_ht_parent_has_input_pattern(node);\n\tif (ok < 0)\n\t\treturn isl_schedule_node_free(node);\n\tif (!ok)\n\t\treturn orig;\n\n\ttile_len = 1 + isl_schedule_node_band_n_member(node);\n\ttile_size = read_tile_sizes(gen, &tile_len);\n\tif (!tile_size)\n\t\treturn isl_schedule_node_free(node);\n\n\tnode = isl_schedule_node_copy(node);\n\tnode = split_band(node, tile_len - 1);\n\tnode = isl_schedule_node_parent(node);\n\tbounds = ppcg_ht_compute_bounds(gen->prog->scop, node);\n\tnode = isl_schedule_node_child(node, 0);\n\n\tok = ppcg_ht_bounds_is_valid(bounds);\n\tif (ok >= 0 && ok)\n\t\tnode = gpu_hybrid_tile(gen, node, bounds, tile_size);\n\telse\n\t\tppcg_ht_bounds_free(bounds);\n\tfree(tile_size);\n\n\tif (ok >= 0 && !ok) {\n\t\tisl_schedule_node_free(node);\n\t\treturn orig;\n\t}\n\tisl_schedule_node_free(orig);\n\tif (ok < 0)\n\t\treturn isl_schedule_node_free(node);\n\treturn node;\n}\n\n/* If \"node\" is the outermost permutable band that can be mapped to block and\n * thread identifiers in its branch (or the root of a subtree with\n * no such outer bands),\n * then mark the band as such, attaching a ppcg_kernel to the mark.\n *\n * If hybrid tiling is allowed, then first try and apply it\n * to \"node\" and its parent.\n *\n * If \"node\" is the root of a subtree without permutable bands,\n * then insert a zero-dimensional permutable band such that\n * we can assume that \"node\" always points to a band node.\n * This includes the case where \"node\" already points to a band node,\n * but one without any coincident dimension.  In this case,\n * the extra node ensures that this original node does not get tiled.\n *\n * Tile \"node\" using user specified tile sizes, after splitting the band\n * if the number of specified tile sizes is smaller than the dimension\n * of the band.  Mark the point band of this tiling as the band that\n * needs to be mapped to threads and instruct the AST generator to unroll\n * the band if the \"unroll_gpu_tile\" option is set.\n * Create a kernel representing the domain instances that reach \"node\" and\n * insert a mark node pointing to the ppcg_kernel before the band node.\n */\nstatic __isl_give isl_schedule_node *mark_outer_permutable(\n\t__isl_take isl_schedule_node *node, void *user)\n{\n\tstruct gpu_gen *gen = user;\n\tint outer;\n\tint scale;\n\tint tile_len;\n\tint *tile_size;\n\tisl_id *id;\n\tisl_multi_val *sizes;\n\n\touter = is_outer_tilable(node);\n\tif (outer < 0)\n\t\treturn isl_schedule_node_free(node);\n\tif (!outer)\n\t\treturn node;\n\n\tif (gen->options->hybrid) {\n\t\tisl_schedule_node *saved = isl_schedule_node_copy(node);\n\t\tnode = try_hybrid_tile(gen, node);\n\t\tisl_schedule_node_free(saved);\n\t\tif (node != saved)\n\t\t\treturn node;\n\t}\n\n\tif (isl_schedule_node_get_type(node) != isl_schedule_node_band ||\n\t    !isl_schedule_node_band_member_get_coincident(node, 0))\n\t\tnode = insert_empty_permutable_band(node);\n\n\ttile_len = isl_schedule_node_band_n_member(node);\n\ttile_size = read_tile_sizes(gen, &tile_len);\n\tif (!tile_size)\n\t\treturn isl_schedule_node_free(node);\n\tif (tile_len < isl_schedule_node_band_n_member(node))\n\t\tnode = isl_schedule_node_band_split(node, tile_len);\n\tsizes = construct_band_tiles_sizes(node, tile_size);\n\tnode = tile_band(node, isl_multi_val_copy(sizes));\n\tnode = isl_schedule_node_child(node, 0);\n\tif (gen->options->unroll_gpu_tile)\n\t\tnode = ppcg_set_schedule_node_type(node, isl_ast_loop_unroll);\n\tid = isl_id_alloc(gen->ctx, \"thread\", NULL);\n\tnode = isl_schedule_node_insert_mark(node, id);\n\tnode = isl_schedule_node_parent(node);\n\n\tscale = gen->options->scale_tile_loops;\n\tnode = gpu_create_kernel(gen, node, scale, sizes);\n\tisl_multi_val_free(sizes);\n\tfree(tile_size);\n\n\treturn node;\n}\n\n/* Given a set or sequence node, return the union the filters of either all\n * (if \"only_initial\" is not set) or the initial (if \"only_initial\" is set)\n * direct subtrees that do not contain any suitably permutable bands\n * (according to subtree_has_permutable_bands).\n */\nstatic __isl_give isl_union_set *get_non_parallel_subtree_filters(\n\t__isl_keep isl_schedule_node *node, int only_initial)\n{\n\tisl_space *space;\n\tisl_union_set *filter;\n\tint i, n;\n\n\tn = isl_schedule_node_n_children(node);\n\tif (n < 0)\n\t\treturn NULL;\n\n\tnode = isl_schedule_node_copy(node);\n\tnode = isl_schedule_node_child(node, 0);\n\tfilter = isl_schedule_node_filter_get_filter(node);\n\tnode = isl_schedule_node_parent(node);\n\tspace = isl_union_set_get_space(filter);\n\tisl_union_set_free(filter);\n\tfilter = isl_union_set_empty(space);\n\n\tfor (i = 0; i < n; ++i) {\n\t\tint parallelism;\n\n\t\tnode = isl_schedule_node_child(node, i);\n\t\tparallelism = subtree_has_permutable_bands(node);\n\t\tif (parallelism < 0) {\n\t\t\tfilter = isl_union_set_free(filter);\n\t\t} else if (!parallelism) {\n\t\t\tisl_union_set *filter_i;\n\t\t\tfilter_i = isl_schedule_node_filter_get_filter(node);\n\t\t\tfilter = isl_union_set_union(filter, filter_i);\n\t\t} else if (only_initial)\n\t\t\tbreak;\n\t\tnode = isl_schedule_node_parent(node);\n\t}\n\n\tisl_schedule_node_free(node);\n\n\treturn filter;\n}\n\n/* Given a set or sequence node, return the union of the filters of\n * the direct subtrees that do not contain any suitably permutable bands\n * (according to subtree_has_permutable_bands).\n */\nstatic __isl_give isl_union_set *get_all_non_parallel_subtree_filters(\n\t__isl_keep isl_schedule_node *node)\n{\n\treturn get_non_parallel_subtree_filters(node, 0);\n}\n\n/* Given a set or sequence node, return the union of the filters of\n * the initial direct subtrees that do not contain any suitably permutable\n * bands (according to subtree_has_permutable_bands).\n */\nstatic __isl_give isl_union_set *get_initial_non_parallel_subtree_filters(\n\t__isl_keep isl_schedule_node *node)\n{\n\treturn get_non_parallel_subtree_filters(node, 1);\n}\n\n/* Mark all variables that are accessed by the statement instances in \"domain\"\n * and that are local to \"prog\" as requiring a declaration in the host code.\n * The statement instances in \"domain\" correspond to (a subset of)\n * the active instances at \"node\".\n * \"node\" is not modified by this function, except that NULL is returned\n * in case of error.\n */\nstatic __isl_give isl_schedule_node *declare_accessed_local_variables(\n\t__isl_take isl_schedule_node *node, struct gpu_prog *prog,\n\t__isl_keep isl_union_set *domain)\n{\n\tisl_union_pw_multi_aff *contraction;\n\tisl_union_set *arrays;\n\tint i;\n\n\tif (!ppcg_scop_any_hidden_declarations(prog->scop))\n\t\treturn node;\n\tcontraction = isl_schedule_node_get_subtree_contraction(node);\n\tdomain = isl_union_set_copy(domain);\n\tdomain = isl_union_set_preimage_union_pw_multi_aff(domain, contraction);\n\tarrays = accessed_by_domain(domain, prog);\n\n\tfor (i = 0; i < prog->n_array; ++i) {\n\t\tisl_space *space;\n\t\tisl_set *set;\n\t\tint empty;\n\n\t\tif (!prog->array[i].local)\n\t\t\tcontinue;\n\t\tspace = isl_set_get_space(prog->array[i].extent);\n\t\tset = isl_union_set_extract_set(arrays, space);\n\t\tempty = isl_set_plain_is_empty(set);\n\t\tisl_set_free(set);\n\t\tif (empty < 0)\n\t\t\tgoto error;\n\t\tif (!empty)\n\t\t\tprog->array[i].declare_local = 1;\n\t}\n\n\tisl_union_set_free(arrays);\n\treturn node;\nerror:\n\tisl_union_set_free(arrays);\n\treturn isl_schedule_node_free(node);\n}\n\n/* If \"node\" points to a set node, then separate its children\n * into subtrees that have suitably permutable bands and\n * those that do not.\n * Adjust the schedule tree in order to execute the second group\n * after the first group and return a pointer to the first group,\n * assuming there are any such subtrees.\n * If \"node\" points to a sequence node, then separate the initial\n * children that do not have suitably permutable bands and\n * return a pointer to the subsequence of children that do have such bands,\n * assuming there are any such subtrees.\n *\n * In both cases, mark all local variables in \"prog\" that are accessed by\n * the group without permutable bands as requiring a declaration on the host.\n */\nstatic __isl_give isl_schedule_node *isolate_permutable_subtrees(\n\t__isl_take isl_schedule_node *node, struct gpu_prog *prog)\n{\n\tisl_union_set *filter;\n\tenum isl_schedule_node_type type;\n\n\tif (!node)\n\t\treturn NULL;\n\ttype = isl_schedule_node_get_type(node);\n\tif (type == isl_schedule_node_set) {\n\t\tfilter = get_all_non_parallel_subtree_filters(node);\n\t\tnode = declare_accessed_local_variables(node, prog, filter);\n\t\tnode = isl_schedule_node_order_after(node, filter);\n\t} else if (type == isl_schedule_node_sequence) {\n\t\tfilter = get_initial_non_parallel_subtree_filters(node);\n\t\tnode = declare_accessed_local_variables(node, prog, filter);\n\t\tnode = isl_schedule_node_order_before(node, filter);\n\t}\n\n\treturn node;\n}\n\n/* Replace any reference to an array element in the range of \"copy\"\n * by a reference to all array elements (defined by the extent of the array).\n */\nstatic __isl_give isl_union_map *approximate_copy_out(\n\t__isl_take isl_union_map *copy, struct gpu_prog *prog)\n{\n\tint i;\n\tisl_union_map *res;\n\n\tres = isl_union_map_empty(isl_union_map_get_space(copy));\n\n\tfor (i = 0; i < prog->n_array; ++i) {\n\t\tisl_space *space;\n\t\tisl_set *set;\n\t\tisl_union_map *copy_i;\n\t\tisl_union_set *extent, *domain;\n\n\t\tspace = isl_space_copy(prog->array[i].space);\n\t\textent = isl_union_set_from_set(isl_set_universe(space));\n\t\tcopy_i = isl_union_map_copy(copy);\n\t\tcopy_i = isl_union_map_intersect_range(copy_i, extent);\n\t\tset = isl_set_copy(prog->array[i].extent);\n\t\textent = isl_union_set_from_set(set);\n\t\tdomain = isl_union_map_domain(copy_i);\n\t\tcopy_i = isl_union_map_from_domain_and_range(domain, extent);\n\t\tres = isl_union_map_union(res, copy_i);\n\t}\n\n\tisl_union_map_free(copy);\n\n\treturn res;\n}\n\n/* Insert \"kernel\" marks that point to a ppcg_kernel structure\n * in front of all outermost tilable band that (by construction)\n * have at least one parallel loop.\n */\nstatic __isl_give isl_schedule_node *mark_kernels(struct gpu_gen *gen,\n\t__isl_take isl_schedule_node *node)\n{\n\treturn isl_schedule_node_map_descendant_bottom_up(node,\n\t\t\t\t\t\t&mark_outer_permutable, gen);\n}\n\n/* Construct schedule constraints from the dependences in prog->scop and\n * the array order dependences in prog->array_order.\n *\n * If live range reordering is allowed, then we need to make sure\n * that live ranges on arrays are not run in parallel since doing\n * so would require array expansion.  We therefore add the array\n * order dependences to the coincidence dependences.  Non-zero array\n * order dependences will then prevent a schedule dimension from being\n * considered parallel.\n * Live ranges derived from scalars are allowed to be run in parallel\n * since we force the scalars to be mapped to private memory in\n * check_scalar_live_ranges.\n * If live range reordering is allowed, then the false dependences\n * are not added to the validity constraints as that would prevent\n * reordering.  Instead, the external false dependences that enforce that reads\n * from potentially live-in data precede any later write and\n * that writes of potentially live-out data follow any other earlier write\n * are added to the validity and the coincidence constraints.\n * The false dependences are still added to the proximity constraints\n * for consistency with the case where live range reordering is not allowed.\n * The coincidence constraints then consist of flow dependences,\n * external false dependences and array order dependences.\n * The independences can be filtered out from the first two sets.\n * They have already been filtered out from the array order dependences\n * on a per array basis in collect_order_dependences.\n * There is no need for a per array handling of the other two sets\n * as there should be no flow or external false dependence on local\n * variables that can be filtered out.\n */\nstatic __isl_give isl_schedule_constraints *construct_schedule_constraints(\n\tstruct gpu_prog *prog)\n{\n\tisl_union_set *domain;\n\tisl_union_map *dep_raw, *dep;\n\tisl_union_map *validity, *proximity, *coincidence;\n\tisl_schedule_constraints *sc;\n\n\tdomain = isl_union_set_copy(prog->scop->domain);\n\tsc = isl_schedule_constraints_on_domain(domain);\n\tsc = isl_schedule_constraints_set_context(sc,\n\t\t\t\tisl_set_copy(prog->scop->context));\n\tif (prog->scop->options->live_range_reordering) {\n\t\tsc = isl_schedule_constraints_set_conditional_validity(sc,\n\t\t\tisl_union_map_copy(prog->scop->tagged_dep_flow),\n\t\t\tisl_union_map_copy(prog->scop->tagged_dep_order));\n\t\tproximity = isl_union_map_copy(prog->scop->dep_flow);\n\t\tvalidity = isl_union_map_copy(proximity);\n\t\tvalidity = isl_union_map_union(validity,\n\t\t\t    isl_union_map_copy(prog->scop->dep_forced));\n\t\tproximity = isl_union_map_union(proximity,\n\t\t\t    isl_union_map_copy(prog->scop->dep_false));\n\t\tcoincidence = isl_union_map_copy(validity);\n\t\tcoincidence = isl_union_map_subtract(coincidence,\n\t\t\tisl_union_map_copy(prog->scop->independence));\n\t\tcoincidence = isl_union_map_union(coincidence,\n\t\t\t\tisl_union_map_copy(prog->array_order));\n\t} else {\n\t\tdep_raw = isl_union_map_copy(prog->scop->dep_flow);\n\t\tdep = isl_union_map_copy(prog->scop->dep_false);\n\t\tdep = isl_union_map_union(dep, dep_raw);\n\t\tdep = isl_union_map_coalesce(dep);\n\t\tproximity = isl_union_map_copy(dep);\n\t\tcoincidence = isl_union_map_copy(dep);\n\t\tvalidity = dep;\n\t}\n\tsc = isl_schedule_constraints_set_validity(sc, validity);\n\tsc = isl_schedule_constraints_set_coincidence(sc, coincidence);\n\tsc = isl_schedule_constraints_set_proximity(sc, proximity);\n\n\tif (prog->scop->options->debug->dump_schedule_constraints)\n\t\tisl_schedule_constraints_dump(sc);\n\treturn sc;\n}\n\n/* Compute an appropriate schedule based on the accesses in\n * gen->read and gen->write.\n *\n * We derive schedule constraints from the dependences in gen->prog->scop\n * and then use isl to compute a schedule that has a parallel loop\n * in each tilable band.\n * During the schedule construction, some statement instances\n * may be grouped first based on the input schedule.\n */\nstatic __isl_give isl_schedule *compute_schedule(struct gpu_gen *gen)\n{\n\tisl_schedule_constraints *sc;\n\tisl_schedule *schedule;\n\n\tsc = construct_schedule_constraints(gen->prog);\n\tschedule = gen->prog->scop->schedule;\n\tschedule = ppcg_compute_schedule(sc, schedule, gen->options);\n\n\treturn schedule;\n}\n\n/* If the band node \"node\" has exactly one member then mark it permutable.\n */\nstatic __isl_give isl_schedule_node *band_set_permutable(\n\t__isl_take isl_schedule_node *node,\n\t__isl_keep isl_schedule_constraints *sc)\n{\n\tif (isl_schedule_node_band_n_member(node) == 1)\n\t\tnode = isl_schedule_node_band_set_permutable(node, 1);\n\n\treturn node;\n}\n\n/* Return the coincidence constraints between pairs of instances\n * that are scheduled together by the ancestors of \"node\".\n * That is, select those coincidence constraints that relate\n * pairs of instances that have the same value for the prefix schedule.\n * If the schedule depth is zero, then the prefix schedule does not\n * contain any information, so we intersect domain and range\n * of the schedule constraints with the reaching domain elements instead.\n */\nstatic __isl_give isl_union_map *get_local_coincidence(\n\t__isl_keep isl_schedule_node *node,\n\t__isl_keep isl_schedule_constraints *sc)\n{\n\tisl_union_map *coincidence;\n\tisl_multi_union_pw_aff *prefix;\n\tisl_union_pw_multi_aff *contraction;\n\n\tcoincidence = isl_schedule_constraints_get_coincidence(sc);\n\tcontraction = isl_schedule_node_get_subtree_contraction(node);\n\tif (isl_schedule_node_get_schedule_depth(node) == 0) {\n\t\tisl_union_set *domain;\n\n\t\tdomain = isl_schedule_node_get_domain(node);\n\t\tdomain = isl_union_set_preimage_union_pw_multi_aff(domain,\n\t\t\t\t\t\t    contraction);\n\t\tcoincidence = isl_union_map_intersect_domain(coincidence,\n\t\t\t\t\t\t    isl_union_set_copy(domain));\n\t\tcoincidence = isl_union_map_intersect_range(coincidence,\n\t\t\t\t\t\t    domain);\n\t\treturn coincidence;\n\t}\n\n\tprefix = isl_schedule_node_get_prefix_schedule_multi_union_pw_aff(node);\n\tprefix = isl_multi_union_pw_aff_pullback_union_pw_multi_aff(prefix,\n\t\t\t\t\t\t\t\tcontraction);\n\treturn isl_union_map_eq_at_multi_union_pw_aff(coincidence, prefix);\n}\n\n/* For each member in the band node \"node\", determine whether\n * it is coincident with respect to the outer nodes and mark\n * it accordingly.\n *\n * That is, for each coincidence constraint between pairs\n * of instances that are scheduled together by the outer nodes,\n * check that domain and range are assigned the same value\n * by the band member.  This test is performed by checking\n * that imposing the same value for the band member does not\n * remove any elements from the set of coincidence constraints.\n */\nstatic __isl_give isl_schedule_node *band_set_coincident(\n\t__isl_take isl_schedule_node *node,\n\t__isl_keep isl_schedule_constraints *sc)\n{\n\tisl_union_map *coincidence;\n\tisl_union_pw_multi_aff *contraction;\n\tisl_multi_union_pw_aff *partial;\n\tint i, n;\n\n\tcoincidence = get_local_coincidence(node, sc);\n\n\tpartial = isl_schedule_node_band_get_partial_schedule(node);\n\tcontraction = isl_schedule_node_get_subtree_contraction(node);\n\tpartial = isl_multi_union_pw_aff_pullback_union_pw_multi_aff(partial,\n\t\t\t\t\t\t\t\tcontraction);\n\tn = isl_schedule_node_band_n_member(node);\n\tfor (i = 0; i < n; ++i) {\n\t\tisl_union_map *coincidence_i;\n\t\tisl_union_pw_aff *upa;\n\t\tisl_multi_union_pw_aff *partial_i;\n\t\tint subset;\n\n\t\tupa = isl_multi_union_pw_aff_get_union_pw_aff(partial, i);\n\t\tpartial_i = isl_multi_union_pw_aff_from_union_pw_aff(upa);\n\t\tcoincidence_i = isl_union_map_copy(coincidence);\n\t\tcoincidence_i = isl_union_map_eq_at_multi_union_pw_aff(\n\t\t\t\t\t\t    coincidence_i, partial_i);\n\t\tsubset = isl_union_map_is_subset(coincidence, coincidence_i);\n\t\tisl_union_map_free(coincidence_i);\n\n\t\tif (subset < 0)\n\t\t\tbreak;\n\t\tnode = isl_schedule_node_band_member_set_coincident(node, i,\n\t\t\t\t\t\t\t\t    subset);\n\t}\n\tif (i < n)\n\t\tnode = isl_schedule_node_free(node);\n\tisl_multi_union_pw_aff_free(partial);\n\tisl_union_map_free(coincidence);\n\n\treturn node;\n}\n\n/* If \"node\" is a band, then set its properties.\n *\n * In particular, if the band has exactly one member, then mark it permutable.\n * Mark the band member coincident based on the coincidence constraints\n * of \"sc\".\n */\nstatic __isl_give isl_schedule_node *set_band_properties(\n\t__isl_take isl_schedule_node *node, void *user)\n{\n\tisl_schedule_constraints *sc = user;\n\n\tif (isl_schedule_node_get_type(node) != isl_schedule_node_band)\n\t\treturn node;\n\tif (isl_schedule_node_band_n_member(node) == 0)\n\t\treturn node;\n\n\tnode = band_set_permutable(node, sc);\n\tnode = band_set_coincident(node, sc);\n\n\treturn node;\n}\n\n/* Return the original schedule with all bands marked permutable and\n * all band members marked coincident based on the coincidence constraints.\n * The bands are explicitly marked permutable so that they will be considered\n * by mark_outer_permutable.\n */\nstatic __isl_give isl_schedule *determine_properties_original_schedule(\n\tstruct gpu_gen *gen)\n{\n\tisl_schedule *schedule;\n\tisl_schedule_constraints *sc;\n\n\tschedule = isl_schedule_copy(gen->prog->scop->schedule);\n\tsc = construct_schedule_constraints(gen->prog);\n\tschedule = isl_schedule_map_schedule_node_bottom_up(schedule,\n\t\t\t\t\t\t    &set_band_properties, sc);\n\tisl_schedule_constraints_free(sc);\n\n\treturn schedule;\n}\n\n/* Compute a schedule or determine the properties of the original schedule\n * depending on the value of the \"reschedule\" option.\n */\nstatic __isl_give isl_schedule *compute_or_set_properties(void *user)\n{\n\tstruct gpu_gen *gen = user;\n\n\tif (gen->options->reschedule)\n\t\treturn compute_schedule(gen);\n\telse\n\t\treturn determine_properties_original_schedule(gen);\n}\n\n/* Obtain a schedule for the scop, by reading it from\n * a file, by computing one or by determining the properties\n * of the original schedule.\n */\n__isl_give isl_schedule *get_schedule(struct gpu_gen *gen)\n{\n\treturn ppcg_get_schedule(gen->ctx, gen->options,\n\t\t\t\t&compute_or_set_properties, gen);\n}\n\n/* Construct the string \"<a>_<b>\".\n */\nstatic char *concat(isl_ctx *ctx, const char *a, const char *b)\n{\n\tisl_printer *p;\n\tchar *s;\n\n\tp = isl_printer_to_str(ctx);\n\tp = isl_printer_print_str(p, a);\n\tp = isl_printer_print_str(p, \"_\");\n\tp = isl_printer_print_str(p, b);\n\ts = isl_printer_get_str(p);\n\tisl_printer_free(p);\n\n\treturn s;\n}\n\n/* For each array in \"prog\" of which an element appears in \"accessed\" and\n * that is not a read only scalar, create a zero-dimensional universe set\n * of which the tuple id has name \"<prefix>_<name of array>\" and a user\n * pointer pointing to the array (gpu_array_info).\n *\n * If the array is local to \"prog\", then make sure it will be declared\n * in the host code.\n *\n * Return the list of these universe sets.\n */\nstatic __isl_give isl_union_set_list *create_copy_filters(struct gpu_prog *prog,\n\tconst char *prefix, __isl_take isl_union_set *accessed)\n{\n\tint i;\n\tisl_ctx *ctx;\n\tisl_union_set_list *filters;\n\n\tctx = prog->ctx;\n\tfilters = isl_union_set_list_alloc(ctx, 0);\n\tfor (i = 0; i < prog->n_array; ++i) {\n\t\tstruct gpu_array_info *array = &prog->array[i];\n\t\tisl_space *space;\n\t\tisl_set *accessed_i;\n\t\tint empty;\n\t\tchar *name;\n\t\tisl_id *id;\n\t\tisl_union_set *uset;\n\n\t\tif (gpu_array_is_read_only_scalar(array))\n\t\t\tcontinue;\n\n\t\tspace = isl_space_copy(array->space);\n\t\taccessed_i = isl_union_set_extract_set(accessed, space);\n\t\tempty = isl_set_plain_is_empty(accessed_i);\n\t\tisl_set_free(accessed_i);\n\t\tif (empty < 0) {\n\t\t\tfilters = isl_union_set_list_free(filters);\n\t\t\tbreak;\n\t\t}\n\t\tif (empty)\n\t\t\tcontinue;\n\n\t\tarray->global = 1;\n\t\tif (array->local)\n\t\t\tarray->declare_local = 1;\n\n\t\tname = concat(ctx, prefix, array->name);\n\t\tid = name ? isl_id_alloc(ctx, name, array) : NULL;\n\t\tfree(name);\n\t\tspace = isl_space_set_alloc(ctx, 0, 0);\n\t\tspace = isl_space_set_tuple_id(space, isl_dim_set, id);\n\t\tuset = isl_union_set_from_set(isl_set_universe(space));\n\n\t\tfilters = isl_union_set_list_add(filters, uset);\n\t}\n\tisl_union_set_free(accessed);\n\n\treturn filters;\n}\n\n/* Make sure that code for the statements in \"filters\" that\n * copy arrays to or from the device is only generated when\n * the size of the corresponding array is positive.\n * That is, add a set node underneath \"graft\" with \"filters\" as children\n * and for each child add a guard that the selects the parameter\n * values for which the corresponding array has a positive size.\n * The array is available in the user pointer of the statement identifier.\n * \"depth\" is the schedule depth of the position where \"graft\"\n * will be added.\n */\nstatic __isl_give isl_schedule_node *insert_positive_size_guards(\n\t__isl_take isl_schedule_node *graft,\n\t__isl_take isl_union_set_list *filters, int depth)\n{\n\tint i, n;\n\n\tgraft = isl_schedule_node_child(graft, 0);\n\tgraft = isl_schedule_node_insert_set(graft, filters);\n\tn = isl_schedule_node_n_children(graft);\n\tfor (i = 0; i < n; ++i) {\n\t\tisl_union_set *filter;\n\t\tisl_set *domain, *guard;\n\t\tisl_id *id;\n\t\tstruct gpu_array_info *array;\n\n\t\tgraft = isl_schedule_node_child(graft, i);\n\t\tfilter = isl_schedule_node_filter_get_filter(graft);\n\t\tdomain = isl_set_from_union_set(filter);\n\t\tid = isl_set_get_tuple_id(domain);\n\t\tarray = isl_id_get_user(id);\n\t\tisl_id_free(id);\n\t\tisl_set_free(domain);\n\t\tguard = gpu_array_positive_size_guard(array);\n\t\tguard = isl_set_from_params(guard);\n\t\tguard = isl_set_add_dims(guard, isl_dim_set, depth);\n\t\tgraft = isl_schedule_node_child(graft, 0);\n\t\tgraft = isl_schedule_node_insert_guard(graft, guard);\n\t\tgraft = isl_schedule_node_parent(graft);\n\t\tgraft = isl_schedule_node_parent(graft);\n\t}\n\tgraft = isl_schedule_node_parent(graft);\n\n\treturn graft;\n}\n\n/* Create a graft for copying arrays to or from the device,\n * whenever the size of the array is strictly positive.\n * Each statement is called \"<prefix>_<name of array>\" and\n * the identifier has a user pointer pointing to the array.\n * The graft will be added at the position specified by \"node\".\n * \"copy\" contains the array elements that need to be copied.\n * Only arrays of which some elements need to be copied\n * will have a corresponding statement in the graph.\n * Note though that each such statement will copy the entire array.\n */\nstatic __isl_give isl_schedule_node *create_copy_device(struct gpu_prog *prog,\n\t__isl_keep isl_schedule_node *node, const char *prefix,\n\t__isl_take isl_union_set *copy)\n{\n\tint depth;\n\tisl_ctx *ctx;\n\tisl_space *space;\n\tisl_union_set *all, *domain;\n\tisl_union_set_list *filters;\n\tisl_union_map *extension;\n\tisl_schedule_node *graft;\n\n\tctx = prog->ctx;\n\tdepth = isl_schedule_node_get_schedule_depth(node);\n\tfilters = create_copy_filters(prog, prefix, copy);\n\tall = isl_union_set_list_union(isl_union_set_list_copy(filters));\n\n\tspace = depth < 0 ? NULL : isl_space_set_alloc(ctx, 0, depth);\n\tdomain = isl_union_set_from_set(isl_set_universe(space));\n\textension = isl_union_map_from_domain_and_range(domain, all);\n\tgraft = isl_schedule_node_from_extension(extension);\n\n\tif (!filters)\n\t\treturn isl_schedule_node_free(graft);\n\tif (isl_union_set_list_n_union_set(filters) == 0) {\n\t\tisl_union_set_list_free(filters);\n\t\treturn graft;\n\t}\n\n\treturn insert_positive_size_guards(graft, filters, depth);\n}\n\n/* Return (the universe spaces of) the arrays that are declared\n * inside the scop corresponding to \"prog\" and for which all\n * potential writes inside the scop form a subset of \"domain\".\n */\nstatic __isl_give isl_union_set *extract_local_accesses(struct gpu_prog *prog,\n\t__isl_keep isl_union_set *domain)\n{\n\tint i;\n\tisl_union_set *local;\n\n\tlocal = isl_union_set_empty(isl_union_set_get_space(domain));\n\n\tfor (i = 0; i < prog->n_array; ++i) {\n\t\tisl_set *set;\n\t\tisl_union_map *to_outer;\n\t\tisl_union_map *may_write;\n\t\tisl_union_set *write_domain;\n\t\tisl_union_set *fields;\n\t\tint subset;\n\n\t\tif (!prog->array[i].local)\n\t\t\tcontinue;\n\n\t\tset = isl_set_universe(isl_space_copy(prog->array[i].space));\n\t\tto_outer = isl_union_map_copy(prog->to_outer);\n\t\tto_outer = isl_union_map_intersect_range(to_outer,\n\t\t\t\t    isl_union_set_from_set(isl_set_copy(set)));\n\t\tfields = isl_union_map_domain(to_outer);\n\t\tmay_write = isl_union_map_copy(prog->may_write);\n\t\tmay_write = isl_union_map_intersect_range(may_write, fields);\n\t\twrite_domain = isl_union_map_domain(may_write);\n\t\tsubset = isl_union_set_is_subset(write_domain, domain);\n\t\tisl_union_set_free(write_domain);\n\n\t\tif (subset < 0) {\n\t\t\tisl_set_free(set);\n\t\t\treturn isl_union_set_free(local);\n\t\t} else if (subset) {\n\t\t\tlocal = isl_union_set_add_set(local, set);\n\t\t} else {\n\t\t\tisl_set_free(set);\n\t\t}\n\t}\n\n\treturn local;\n}\n\n/* Internal data structure for node_may_persist.\n *\n * \"tagger\" maps tagged iteration domains to the corresponding untagged\n *\titeration domain.\n *\n * \"may_persist_flow\" is the set of all tagged dataflow dependences\n * with those dependences removed that either precede or follow\n * the kernel launch in a sequence.\n * \"inner_band_flow\" is the set of all tagged dataflow dependences\n * that are local to a given iteration of the outer band nodes\n * with respect to the current node.\n * \"local_flow\" is equal to \"inner_band_flow\", except that the domain\n * and the range have been intersected with intermediate filters\n * on children of sets or sequences.\n */\nstruct ppcg_may_persist_data {\n\tisl_union_pw_multi_aff *tagger;\n\n\tisl_union_map *local_flow;\n\tisl_union_map *inner_band_flow;\n\tisl_union_map *may_persist_flow;\n};\n\n/* Update the information in \"data\" based on the band ancestor \"node\".\n *\n * In particular, we restrict the dependences in data->local_flow\n * to those dependence where the source and the sink occur in\n * the same iteration of the given band node.\n * We also update data->inner_band_flow to the new value of\n * data->local_flow.\n */\nstatic int update_may_persist_at_band(__isl_keep isl_schedule_node *node,\n\tstruct ppcg_may_persist_data *data)\n{\n\tisl_multi_union_pw_aff *partial;\n\tisl_union_pw_multi_aff *contraction;\n\tisl_union_map *flow;\n\n\tif (isl_schedule_node_band_n_member(node) == 0)\n\t\treturn 0;\n\n\tpartial = isl_schedule_node_band_get_partial_schedule(node);\n\tcontraction = isl_schedule_node_get_subtree_contraction(node);\n\tpartial = isl_multi_union_pw_aff_pullback_union_pw_multi_aff(partial,\n\t\t\t\t\t\t\t\tcontraction);\n\tpartial = isl_multi_union_pw_aff_pullback_union_pw_multi_aff(partial,\n\t\t\t\tisl_union_pw_multi_aff_copy(data->tagger));\n\n\tflow = data->local_flow;\n\tflow = isl_union_map_eq_at_multi_union_pw_aff(flow, partial);\n\tdata->local_flow = flow;\n\n\tisl_union_map_free(data->inner_band_flow);\n\tdata->inner_band_flow = isl_union_map_copy(data->local_flow);\n\n\treturn 0;\n}\n\n/* Given a set of local reaching domain elements \"domain\",\n * expand them to the corresponding leaf domain elements using \"contraction\"\n * and insert the array references tags using data->tagger.\n */\nstatic __isl_give isl_union_set *expand_and_tag(\n\t__isl_take isl_union_set *domain,\n\t__isl_take isl_union_pw_multi_aff *contraction,\n\tstruct ppcg_may_persist_data *data)\n{\n\tdomain = isl_union_set_preimage_union_pw_multi_aff(domain,\n\t\t\t    contraction);\n\tdomain = isl_union_set_preimage_union_pw_multi_aff(domain,\n\t\t\t    isl_union_pw_multi_aff_copy(data->tagger));\n\treturn domain;\n}\n\n/* Given a filter node that is the child of a set or sequence node,\n * restrict data->local_flow to refer only to those elements\n * in the filter of the node.\n * \"contraction\" maps the leaf domain elements of the schedule tree\n * to the corresponding domain elements at (the parent of) \"node\".\n */\nstatic int filter_flow(__isl_keep isl_schedule_node *node,\n\tstruct ppcg_may_persist_data *data,\n\t__isl_take isl_union_pw_multi_aff *contraction)\n{\n\tisl_union_set *filter;\n\tisl_union_map *flow;\n\n\tflow = data->local_flow;\n\tfilter = isl_schedule_node_filter_get_filter(node);\n\tfilter = expand_and_tag(filter, contraction, data);\n\tflow = isl_union_map_intersect_domain(flow, isl_union_set_copy(filter));\n\tflow = isl_union_map_intersect_range(flow, filter);\n\tdata->local_flow = flow;\n\n\treturn 0;\n}\n\n/* Given a filter node \"node\", collect the filters on all preceding siblings\n * (which are also filter nodes), add them to \"filters\" and return the result.\n */\nstatic __isl_give isl_union_set *add_previous_filters(\n\t__isl_take isl_union_set *filters, __isl_keep isl_schedule_node *node)\n{\n\tisl_schedule_node *sibling;\n\n\tsibling = isl_schedule_node_copy(node);\n\twhile (sibling && isl_schedule_node_has_previous_sibling(sibling)) {\n\t\tisl_union_set *filter;\n\n\t\tsibling = isl_schedule_node_previous_sibling(sibling);\n\t\tfilter = isl_schedule_node_filter_get_filter(sibling);\n\t\tfilters = isl_union_set_union(filters, filter);\n\t}\n\tisl_schedule_node_free(sibling);\n\tif (!sibling)\n\t\treturn isl_union_set_free(filters);\n\n\treturn filters;\n}\n\n/* Given a filter node \"node\", collect the filters on all following siblings\n * (which are also filter nodes), add them to \"filters\" and return the result.\n */\nstatic __isl_give isl_union_set *add_next_filters(\n\t__isl_take isl_union_set *filters, __isl_keep isl_schedule_node *node)\n{\n\tisl_schedule_node *sibling;\n\n\tsibling = isl_schedule_node_copy(node);\n\twhile (sibling && isl_schedule_node_has_next_sibling(sibling)) {\n\t\tisl_union_set *filter;\n\n\t\tsibling = isl_schedule_node_next_sibling(sibling);\n\t\tfilter = isl_schedule_node_filter_get_filter(sibling);\n\t\tfilters = isl_union_set_union(filters, filter);\n\t}\n\tisl_schedule_node_free(sibling);\n\tif (!sibling)\n\t\treturn isl_union_set_free(filters);\n\n\treturn filters;\n}\n\n/* Remove those flow dependences from data->may_persist_flow\n * that flow between elements of \"domain\" within the same iteration\n * of all outer band nodes.\n * \"contraction\" maps the leaf domain elements of the schedule tree\n * to the corresponding elements \"domain\".\n */\nstatic void remove_external_flow(struct ppcg_may_persist_data *data,\n\t__isl_take isl_union_set *domain,\n\t__isl_keep isl_union_pw_multi_aff *contraction)\n{\n\tisl_union_map *flow;\n\n\tcontraction = isl_union_pw_multi_aff_copy(contraction);\n\tdomain = expand_and_tag(domain, contraction, data);\n\tflow = isl_union_map_copy(data->local_flow);\n\tflow = isl_union_map_intersect_domain(flow, isl_union_set_copy(domain));\n\tflow = isl_union_map_intersect_range(flow, domain);\n\n\tdata->may_persist_flow = isl_union_map_subtract(data->may_persist_flow,\n\t\t\t\t\t\t\tflow);\n}\n\n/* Update the information in \"data\" based on the filter ancestor \"node\".\n * We only need to modify anything if the filter is the child\n * of a set or sequence node.\n *\n * In the case of a sequence, we remove the dependences between\n * statement instances that are both executed either before or\n * after the subtree that will be mapped to a kernel, within\n * the same iteration of outer bands.\n *\n * In both cases, we restrict data->local_flow to the current child.\n */\nstatic int update_may_persist_at_filter(__isl_keep isl_schedule_node *node,\n\tstruct ppcg_may_persist_data *data)\n{\n\tenum isl_schedule_node_type type;\n\tisl_schedule_node *parent;\n\tisl_space *space;\n\tisl_union_pw_multi_aff *contraction;\n\tisl_union_set *before, *after, *filter;\n\n\ttype = isl_schedule_node_get_parent_type(node);\n\tif (type != isl_schedule_node_sequence && type != isl_schedule_node_set)\n\t\treturn 0;\n\n\tparent = isl_schedule_node_copy(node);\n\tparent = isl_schedule_node_parent(parent);\n\tcontraction = isl_schedule_node_get_subtree_contraction(parent);\n\tisl_schedule_node_free(parent);\n\n\tif (type == isl_schedule_node_set)\n\t\treturn filter_flow(node, data, contraction);\n\n\tfilter = isl_schedule_node_filter_get_filter(node);\n\tspace = isl_union_set_get_space(filter);\n\tisl_union_set_free(filter);\n\tbefore = isl_union_set_empty(space);\n\tafter = isl_union_set_copy(before);\n\tbefore = add_previous_filters(before, node);\n\tafter = add_next_filters(after, node);\n\n\tremove_external_flow(data, before, contraction);\n\tremove_external_flow(data, after, contraction);\n\n\treturn filter_flow(node, data, contraction);\n}\n\n/* Update the information in \"data\" based on the ancestor \"node\".\n */\nstatic isl_stat update_may_persist_at(__isl_keep isl_schedule_node *node,\n\tvoid *user)\n{\n\tstruct ppcg_may_persist_data *data = user;\n\n\tswitch (isl_schedule_node_get_type(node)) {\n\tcase isl_schedule_node_error:\n\t\treturn isl_stat_error;\n\tcase isl_schedule_node_context:\n\tcase isl_schedule_node_domain:\n\tcase isl_schedule_node_expansion:\n\tcase isl_schedule_node_extension:\n\tcase isl_schedule_node_guard:\n\tcase isl_schedule_node_leaf:\n\tcase isl_schedule_node_mark:\n\tcase isl_schedule_node_sequence:\n\tcase isl_schedule_node_set:\n\t\tbreak;\n\tcase isl_schedule_node_band:\n\t\tif (update_may_persist_at_band(node, data) < 0)\n\t\t\treturn isl_stat_error;\n\t\tbreak;\n\tcase isl_schedule_node_filter:\n\t\tif (update_may_persist_at_filter(node, data) < 0)\n\t\t\treturn isl_stat_error;\n\t\tbreak;\n\t}\n\n\treturn isl_stat_ok;\n}\n\n/* Determine the set of array elements that may need to be perserved\n * by a kernel constructed from the subtree at \"node\".\n * This includes the set of array elements that may need to be preserved\n * by the entire scop (prog->may_persist) and the elements for which\n * there is a potential flow dependence that may cross a kernel launch.\n *\n * To determine the second set, we start from all flow dependences.\n * From this set of dependences, we remove those that cannot possibly\n * require data to be preserved by a kernel launch.\n * In particular, we consider the following sets of dependences.\n * - dependences of which the write occurs inside the kernel.\n *   If the data is needed outside the kernel, then it will\n *   be copied out immediately after the kernel launch, so there\n *   is no need for any special care.\n * - dependences of which the read occurs inside the kernel and the\n *   corresponding write occurs inside the same iteration of the\n *   outer band nodes.  This means that the data is needed in\n *   the first kernel launch after the write, which is already\n *   taken care of by the standard copy-in.  That is, the data\n *   do not need to be preserved by any intermediate call to\n *   the same kernel.\n * - dependences of which the write and the read either both occur\n *   before the kernel launch or both occur after the kernel launch,\n *   within the same iteration of the outer band nodes with respect\n *   to the sequence that determines the ordering of the dependence\n *   and the kernel launch.  Such flow dependences cannot cross\n *   any kernel launch.\n *\n * For the remaining (tagged) dependences, we take the domain\n * (i.e., the tagged writes) and apply the tagged access relation\n * to obtain the accessed data elements.\n * These are then combined with the elements that may need to be\n * preserved by the entire scop.\n */\nstatic __isl_give isl_union_set *node_may_persist(\n\t__isl_keep isl_schedule_node *node, struct gpu_prog *prog)\n{\n\tstruct ppcg_may_persist_data data;\n\tisl_union_pw_multi_aff *contraction;\n\tisl_union_set *domain;\n\tisl_union_set *persist;\n\tisl_union_map *flow, *local_flow;\n\n\tdata.tagger = prog->scop->tagger;\n\n\tflow = isl_union_map_copy(prog->scop->tagged_dep_flow);\n\tdata.local_flow = isl_union_map_copy(flow);\n\tdata.inner_band_flow = isl_union_map_copy(flow);\n\tdata.may_persist_flow = flow;\n\tif (isl_schedule_node_foreach_ancestor_top_down(node,\n\t\t\t\t\t&update_may_persist_at, &data) < 0)\n\t\tdata.may_persist_flow =\n\t\t\t\t    isl_union_map_free(data.may_persist_flow);\n\tflow = data.may_persist_flow;\n\tisl_union_map_free(data.local_flow);\n\n\tdomain = isl_schedule_node_get_domain(node);\n\tcontraction = isl_schedule_node_get_subtree_contraction(node);\n\tdomain = isl_union_set_preimage_union_pw_multi_aff(domain,\n\t\t\t\t    contraction);\n\tdomain = isl_union_set_preimage_union_pw_multi_aff(domain,\n\t\t\t\t    isl_union_pw_multi_aff_copy(data.tagger));\n\tflow = isl_union_map_subtract_domain(flow, isl_union_set_copy(domain));\n\tlocal_flow = data.inner_band_flow;\n\tlocal_flow = isl_union_map_intersect_range(local_flow, domain);\n\tflow = isl_union_map_subtract(flow, local_flow);\n\n\tpersist = isl_union_map_domain(flow);\n\tpersist = isl_union_set_apply(persist,\n\t\t\tisl_union_map_copy(prog->scop->tagged_may_writes));\n\tpersist = isl_union_set_union(persist,\n\t\t\tisl_union_set_copy(prog->may_persist));\n\n\treturn persist;\n}\n\n/* Add nodes for copying outer arrays in and out of the device\n * before and after the subtree \"node\", which contains one or more kernels.\n * \"domain\" contains the original statement instances, i.e.,\n * those that correspond to the domains of the access relations in \"prog\".\n * In particular, the domain has not been contracted in any way.\n * \"prefix\" contains the prefix schedule at that point, in terms\n * of the same original statement instances.\n *\n * We first compute the sets of outer array elements that need\n * to be copied in and out and then graft in the nodes for\n * performing this copying.\n *\n * In particular, for each array that is possibly written anywhere in\n * the subtree \"node\" and that may be used after \"node\"\n * or that may be visible outside the corresponding scop,\n * we copy out its entire extent.\n *\n * Any array elements that is read without first being written inside\n * the subtree \"node\" needs to be copied in.\n * Furthermore, if there are any array elements that\n * are copied out, but that may not be written inside \"node, then\n * they also need to be copied in to ensure that the value after execution\n * is the same as the value before execution, at least for those array\n * elements that may have their values preserved by the scop or that\n * may be written before \"node\" and read after \"node\".\n * In case the array elements are structures, we need to take into\n * account that all members of the structures need to be written\n * by \"node\" before we can avoid copying the data structure in.\n *\n * Note that the may_write relation is intersected with the domain,\n * which has been intersected with the context.\n * This helps in those cases where the arrays are declared with a fixed size,\n * while the accesses are parametric and the context assigns a fixed value\n * to the parameters.\n *\n * If an element from a local array is read without first being written,\n * then there is no point in copying it in since it cannot have been\n * written prior to the scop.  Warn about the uninitialized read instead.\n */\nstatic __isl_give isl_schedule_node *add_to_from_device(\n\t__isl_take isl_schedule_node *node, __isl_take isl_union_set *domain,\n\t__isl_take isl_union_map *prefix, struct gpu_prog *prog)\n{\n\tisl_union_set *local;\n\tisl_union_set *may_persist;\n\tisl_union_map *may_write, *must_write, *copy_out, *not_written;\n\tisl_union_map *read, *copy_in;\n\tisl_union_map *tagged;\n\tisl_union_map *local_uninitialized;\n\tisl_schedule_node *graft;\n\n\ttagged = isl_union_map_copy(prog->scop->tagged_reads);\n\ttagged = isl_union_map_union(tagged,\n\t\t\t    isl_union_map_copy(prog->scop->tagged_may_writes));\n\n\tmay_write = isl_union_map_copy(prog->may_write);\n\tmay_write = isl_union_map_intersect_domain(may_write,\n\t\t\t\t\tisl_union_set_copy(domain));\n\tmay_write = remove_local_accesses(prog,\n\t\t\t\t\tisl_union_map_copy(tagged), may_write,\n\t\t\t\t\tisl_union_map_copy(prefix), 0);\n\tmay_write = isl_union_map_apply_range(may_write,\n\t\t\t\t\tisl_union_map_copy(prog->to_outer));\n\tmay_write = isl_union_map_apply_domain(may_write,\n\t\t\t\t\tisl_union_map_copy(prefix));\n\tmay_write = approximate_copy_out(may_write, prog);\n\tcopy_out = isl_union_map_copy(may_write);\n\tmay_write = isl_union_map_apply_range(may_write,\n\t\t\t\t\tisl_union_map_copy(prog->to_inner));\n\tmust_write = isl_union_map_copy(prog->must_write);\n\tmust_write = isl_union_map_apply_domain(must_write,\n\t\t\t\t\tisl_union_map_copy(prefix));\n\tmay_persist = node_may_persist(node, prog);\n\tmay_write = isl_union_map_intersect_range(may_write, may_persist);\n\tnot_written = isl_union_map_subtract(may_write, must_write);\n\n\tlocal = extract_local_accesses(prog, domain);\n\tread = isl_union_map_copy(prog->read);\n\tread = isl_union_map_intersect_domain(read, domain);\n\tread = remove_local_accesses(prog, tagged, read,\n\t\t\t\t\tisl_union_map_copy(prefix), 1);\n\tlocal = isl_union_set_apply(local, isl_union_map_copy(prog->to_inner));\n\tlocal_uninitialized = isl_union_map_copy(prog->scop->live_in);\n\tlocal_uninitialized = isl_union_map_intersect_range(local_uninitialized,\n\t\t\t\t\t\t\t    local);\n\tlocal_uninitialized = isl_union_map_intersect(local_uninitialized,\n\t\t\t\t\t\t    isl_union_map_copy(read));\n\tif (!isl_union_map_is_empty(local_uninitialized)) {\n\t\tfprintf(stderr,\n\t\t\t\"possibly uninitialized reads (not copied in):\\n\");\n\t\tisl_union_map_dump(local_uninitialized);\n\t}\n\tread = isl_union_map_subtract(read, local_uninitialized);\n\tread = isl_union_map_apply_domain(read, prefix);\n\tcopy_in = isl_union_map_union(read, not_written);\n\tcopy_in = isl_union_map_apply_range(copy_in,\n\t\t\t\t    isl_union_map_copy(prog->to_outer));\n\n\tgraft = create_copy_device(prog, node, \"to_device\",\n\t\t\t\t\t\tisl_union_map_range(copy_in));\n\tnode = isl_schedule_node_graft_before(node, graft);\n\tgraft = create_copy_device(prog, node, \"from_device\",\n\t\t\t\t\t\tisl_union_map_range(copy_out));\n\tnode = isl_schedule_node_graft_after(node, graft);\n\n\treturn node;\n}\n\n/* Add nodes for initializing (\"init_device\") and clearing (\"clear_device\")\n * the device before and after \"node\".\n */\nstatic __isl_give isl_schedule_node *add_init_clear_device(\n\t__isl_take isl_schedule_node *node)\n{\n\tisl_ctx *ctx;\n\tisl_space *space;\n\tisl_union_set *domain;\n\tisl_schedule_node *graft;\n\n\tctx = isl_schedule_node_get_ctx(node);\n\n\tspace = isl_space_set_alloc(ctx, 0, 0);\n\tspace = isl_space_set_tuple_name(space, isl_dim_set, \"init_device\");\n\tdomain = isl_union_set_from_set(isl_set_universe(space));\n\tgraft = isl_schedule_node_from_domain(domain);\n\n\tnode = isl_schedule_node_graft_before(node, graft);\n\n\tspace = isl_space_set_alloc(ctx, 0, 0);\n\tspace = isl_space_set_tuple_name(space, isl_dim_set, \"clear_device\");\n\tdomain = isl_union_set_from_set(isl_set_universe(space));\n\tgraft = isl_schedule_node_from_domain(domain);\n\n\tnode = isl_schedule_node_graft_after(node, graft);\n\n\treturn node;\n}\n\n/* Update \"schedule\" for mapping to a GPU device.\n *\n * In particular, insert a context node, create kernels for\n * each outermost tilable band and introduce nodes for copying arrays\n * in and out of the device and for initializing and clearing the device.\n * If the child of the initial root points to a set node,\n * then children of this node that do not contain any tilable bands\n * are separated from the other children and are not mapped to\n * the device.\n *\n * The GPU code is generated in a context where at least one\n * statement instance is executed.  The corresponding guard is inserted\n * around the entire schedule.\n */\n__isl_give isl_schedule *map_to_device(struct gpu_gen *gen,\n\t__isl_take isl_schedule *schedule, int to_from_device)\n{\n\tisl_schedule_node *node;\n\tisl_set *context;\n\tisl_set *guard;\n\tisl_union_set *domain;\n\tisl_union_map *prefix;\n\tisl_union_pw_multi_aff *contraction;\n\tstruct gpu_prog *prog;\n\n\tcontext = isl_set_copy(gen->prog->context);\n\tcontext = isl_set_from_params(context);\n\tschedule = isl_schedule_insert_context(schedule, context);\n\n\tprog = gen->prog;\n\tguard = isl_union_set_params(isl_union_set_copy(prog->scop->domain));\n\tprog->context = isl_set_intersect(prog->context, isl_set_copy(guard));\n\tguard = isl_set_from_params(guard);\n\n\tnode = isl_schedule_get_root(schedule);\n\tisl_schedule_free(schedule);\n\tnode = isl_schedule_node_child(node, 0);\n\tnode = isl_schedule_node_child(node, 0);\n\tnode = isolate_permutable_subtrees(node, gen->prog);\n\tdomain = isl_schedule_node_get_domain(node);\n\tcontraction = isl_schedule_node_get_subtree_contraction(node);\n\tdomain = isl_union_set_preimage_union_pw_multi_aff(domain,\n\t\t\t\t    isl_union_pw_multi_aff_copy(contraction));\n\tprefix = isl_schedule_node_get_prefix_schedule_union_map(node);\n\tprefix = isl_union_map_preimage_domain_union_pw_multi_aff(prefix,\n\t\t\t\t    contraction);\n\tnode = mark_kernels(gen, node);\n\tif (to_from_device) {\n\t\tnode = add_to_from_device(node, domain, prefix, gen->prog);\n\t} else {\n\t\tisl_union_set_free(domain);\n\t\tisl_union_map_free(prefix);\n\t}\n\tnode = isl_schedule_node_root(node);\n\tnode = isl_schedule_node_child(node, 0);\n\tnode = isl_schedule_node_child(node, 0);\n\tnode = isl_schedule_node_insert_guard(node, guard);\n\tnode = isl_schedule_node_child(node, 0);\n\tnode = add_init_clear_device(node);\n\tschedule = isl_schedule_node_get_schedule(node);\n\tisl_schedule_node_free(node);\n\n\treturn schedule;\n}\n\n/* Internal data structure for extract_access.\n * \"next_access\" points to the end of a linked list that is extended\n * by extract_access.\n * \"single_expression\" is set if the access expressions belong to\n * an expression statement (i.e., a statement without internal control).\n * \"any_to_outer\" maps all intermediate arrays to their outer arrays.\n */\nstruct ppcg_extract_access_data {\n\tstruct gpu_stmt_access **next_access;\n\tint single_expression;\n\tisl_union_map *any_to_outer;\n};\n\n/* Given a tagged access relation to a single array \"tagged\", extract it\n * as a map, taking into account that the input may be empty.\n * If the access relation is empty, then it does not contain\n * any space information, so we try to recover it from the index\n * expression.\n * The space of the index expression is of the form I -> A,\n * with I the statement instances and A the array, or [I -> F] -> A,\n * with F the filters corresponding to arguments.\n * We first drop F, if present, obtaining I -> A.\n * Then we construct I -> R, with R the reference tag,\n * combine the two into I -> [R -> A] and uncurry to obtain\n * the final result [I -> R] -> A.\n * Note that the index expression may have a lower dimension\n * than that of the array, but this dimension is not used\n * if the access relation is empty.\n */\nstatic __isl_give isl_map *extract_single_tagged_access(\n\t__isl_take isl_union_map *tagged, __isl_keep pet_expr *expr)\n{\n\tint empty;\n\tisl_id *id;\n\tisl_space *space, *space2;\n\tisl_multi_pw_aff *index;\n\n\tempty = isl_union_map_is_empty(tagged);\n\tif (empty < 0)\n\t\tgoto error;\n\tif (!empty)\n\t\treturn isl_map_from_union_map(tagged);\n\tisl_union_map_free(tagged);\n\n\tindex = pet_expr_access_get_index(expr);\n\tspace = isl_multi_pw_aff_get_space(index);\n\tisl_multi_pw_aff_free(index);\n\tif (isl_space_domain_is_wrapping(space))\n\t\tspace = isl_space_domain_factor_domain(space);\n\tspace2 = isl_space_copy(space);\n\tspace2 = isl_space_from_domain(isl_space_domain(space));\n\tid = pet_expr_access_get_ref_id(expr);\n\tspace2 = isl_space_set_tuple_id(space2, isl_dim_out, id);\n\tspace = isl_space_range_product(space2, space);\n\tspace = isl_space_uncurry(space);\n\n\treturn isl_map_empty(space);\nerror:\n\tisl_union_map_free(tagged);\n\treturn NULL;\n}\n\n/* Does the index expression \"index\" of \"expr\" represent an access\n * to a single element?\n * That is, is \"index\" completely specified?\n *\n * If \"expr\" accesses elements from different spaces (i.e., fields\n * of a structure), then it does not access a single element.\n * Otherwise, if the single space of the access matches the space\n * of \"index\", then the index expression is completely specified\n * (no pointer to a lower-dimensional slice of the accessed array)\n * and a single element is being accessed.\n */\nstatic isl_bool complete_index(__isl_keep pet_expr *expr,\n\t__isl_keep isl_multi_pw_aff *index)\n{\n\tisl_union_map *read, *write, *all;\n\tisl_map *map;\n\tisl_space *space1, *space2;\n\tisl_bool complete;\n\n\tread = pet_expr_access_get_may_read(expr);\n\twrite = pet_expr_access_get_may_write(expr);\n\tall = isl_union_map_union(read, write);\n\tif (!all)\n\t\treturn isl_bool_error;\n\tif (isl_union_map_n_map(all) != 1) {\n\t\tisl_union_map_free(all);\n\t\treturn isl_bool_false;\n\t}\n\tmap = isl_map_from_union_map(all);\n\tspace1 = isl_map_get_space(map);\n\tisl_map_free(map);\n\tspace2 = isl_multi_pw_aff_get_space(index);\n\tcomplete = isl_space_tuple_is_equal(space1, isl_dim_out,\n\t\t\t\t\t    space2, isl_dim_out);\n\tisl_space_free(space1);\n\tisl_space_free(space2);\n\n\treturn complete;\n}\n\n/* Does \"expr\" access a single, fixed element (independently of the statement\n * instance)?\n * That is, does it have a completely specified constant index expression?\n *\n * Note that it is not sufficient for the index expression to be\n * piecewise constant.  isl_multi_pw_aff_is_cst can therefore not be used.\n */\nstatic isl_bool accesses_fixed_element(__isl_keep pet_expr *expr)\n{\n\tint i, n;\n\tisl_multi_pw_aff *index;\n\tisl_bool fixed = isl_bool_true;\n\n\tindex = pet_expr_access_get_index(expr);\n\tif (index < 0)\n\t\treturn isl_bool_error;\n\tn = isl_multi_pw_aff_dim(index, isl_dim_out);\n\tfor (i = 0; i < n; ++i) {\n\t\tisl_pw_aff *pa;\n\n\t\tpa = isl_multi_pw_aff_get_pw_aff(index, 0);\n\t\tfixed = isl_pw_aff_n_piece(pa) == 1;\n\t\tif (fixed)\n\t\t\tfixed = isl_pw_aff_is_cst(pa);\n\t\tisl_pw_aff_free(pa);\n\t\tif (fixed < 0 || !fixed)\n\t\t\tbreak;\n\t}\n\tif (fixed >= 0 && fixed)\n\t\tfixed = complete_index(expr, index);\n\tisl_multi_pw_aff_free(index);\n\n\treturn fixed;\n}\n\n/* Extract a gpu_stmt_access from \"expr\", append it to the list\n * that ends in *data->next_access and update the end of the list.\n * If the access expression performs a write, then it is considered\n * exact only if it appears in a single expression statement and\n * if its may access relation is equal to its must access relation.\n *\n * The combined set of may accesses may be a union if member accesses\n * are involved, but the entire set is derived from a single reference and\n * therefore from a single index expression.  These accesses therefore\n * all map to the same outer array.\n */\nstatic int extract_access(__isl_keep pet_expr *expr, void *user)\n{\n\tstruct ppcg_extract_access_data *data = user;\n\tisl_union_map *tagged;\n\tstruct gpu_stmt_access *access;\n\tisl_ctx *ctx = pet_expr_get_ctx(expr);\n\tisl_multi_pw_aff *index;\n\n\taccess = isl_alloc_type(ctx, struct gpu_stmt_access);\n\tassert(access);\n\taccess->next = NULL;\n\taccess->read = pet_expr_access_is_read(expr);\n\taccess->write = pet_expr_access_is_write(expr);\n\ttagged = pet_expr_access_get_tagged_may_read(expr);\n\ttagged = isl_union_map_union(tagged,\n\t\t\t\tpet_expr_access_get_tagged_may_write(expr));\n\ttagged = isl_union_map_apply_range(tagged,\n\t\t\t\t\tisl_union_map_copy(data->any_to_outer));\n\tif (!access->write) {\n\t\taccess->exact_write = 1;\n\t} else if (!data->single_expression) {\n\t\taccess->exact_write = 0;\n\t} else {\n\t\tisl_union_map *must, *may;\n\t\tmay = isl_union_map_copy(tagged);\n\t\tmay = isl_union_map_domain_factor_domain(may);\n\t\tmust = pet_expr_access_get_must_write(expr);\n\t\taccess->exact_write = isl_union_map_is_equal(must, may);\n\t\tisl_union_map_free(must);\n\t\tisl_union_map_free(may);\n\t}\n\tindex = pet_expr_access_get_index(expr);\n\taccess->n_index = isl_multi_pw_aff_dim(index, isl_dim_out);\n\tisl_multi_pw_aff_free(index);\n\taccess->ref_id = pet_expr_access_get_ref_id(expr);\n\taccess->tagged_access = extract_single_tagged_access(tagged, expr);\n\taccess->access = isl_map_copy(access->tagged_access);\n\taccess->access = isl_map_domain_factor_domain(access->access);\n\taccess->fixed_element = accesses_fixed_element(expr);\n\n\t*data->next_access = access;\n\tdata->next_access = &(*data->next_access)->next;\n\n\tif (!access->access || access->fixed_element < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n/* Construct a linked list of gpu_stmt_access objects,\n * one for each access expression in the statement body.\n * \"any_to_outer\" maps all intermediate arrays to their outer arrays.\n */\nstatic int pet_stmt_extract_accesses(struct gpu_stmt *stmt,\n\t__isl_keep isl_union_map *any_to_outer)\n{\n\tstruct ppcg_extract_access_data data;\n\n\tstmt->accesses = NULL;\n\tdata.next_access = &stmt->accesses;\n\tdata.single_expression =\n\t\tpet_tree_get_type(stmt->stmt->body) == pet_tree_expr;\n\tdata.any_to_outer = any_to_outer;\n\treturn pet_tree_foreach_access_expr(stmt->stmt->body,\n\t\t\t\t\t\t&extract_access, &data);\n}\n\n/* Has statement \"stmt\" been killed from \"scop\"?\n * That is, is the instance set of \"scop\" free from any\n * instances of \"stmt\"?\n */\nstatic isl_bool is_stmt_killed(struct ppcg_scop *scop, struct pet_stmt *stmt)\n{\n\tisl_space *space;\n\tisl_set *left;\n\tisl_bool empty;\n\n\tif (!scop || !stmt)\n\t\treturn isl_bool_error;\n\tspace = isl_set_get_space(stmt->domain);\n\tleft = isl_union_set_extract_set(scop->domain, space);\n\tempty = isl_set_plain_is_empty(left);\n\tisl_set_free(left);\n\n\treturn empty;\n}\n\n/* Return an array of gpu_stmt representing the statements in \"scop\".\n * Do not collect array accesses for statements that have been killed.\n */\nstatic struct gpu_stmt *extract_stmts(isl_ctx *ctx, struct ppcg_scop *scop,\n\t__isl_keep isl_union_map *any_to_outer)\n{\n\tint i;\n\tstruct gpu_stmt *stmts;\n\n\tstmts = isl_calloc_array(ctx, struct gpu_stmt, scop->pet->n_stmt);\n\tif (!stmts)\n\t\treturn NULL;\n\n\tfor (i = 0; i < scop->pet->n_stmt; ++i) {\n\t\tstruct gpu_stmt *s = &stmts[i];\n\t\tisl_bool killed;\n\n\t\ts->id = isl_set_get_tuple_id(scop->pet->stmts[i]->domain);\n\t\ts->stmt = scop->pet->stmts[i];\n\t\tkilled = is_stmt_killed(scop, scop->pet->stmts[i]);\n\t\tif (killed < 0)\n\t\t\treturn free_stmts(stmts, i + 1);\n\t\tif (killed)\n\t\t\tcontinue;\n\t\tif (pet_stmt_extract_accesses(s, any_to_outer) < 0)\n\t\t\treturn free_stmts(stmts, i + 1);\n\t}\n\n\treturn stmts;\n}\n\n/* Generate CUDA code for \"scop\" and print it to \"p\".\n * After generating an AST for the transformed scop as explained below,\n * we call \"gen->print\" to print the AST in the desired output format\n * to \"p\".\n *\n * If it turns out that it does not make sense to generate GPU code,\n * then we generate CPU code instead.\n *\n * The declarations of the arrays that are visible outside of the scop\n * are printed outside of the code generated from the schedule,\n * because the generated code may involve a guard around the entire code.\n *\n * We first compute a schedule that respects the dependences\n * of the original program and select the outermost bands\n * of tilable dimensions that have at least one parallel loop.\n * If the --load-schedule is specified, then the loaded schedule\n * is used instead of a computed schedule.\n *\n * Each of these bands B is then tiled according to \"tile\" sizes, resulting\n * in two nested bands, with a kernel marker on top\n *\n *\t\tK\n *\t\t|\n *\t\tT\n *\t\t|\n *\t\tP\n *\n * We then split off at most 2 parallel dimensions from the T band and\n * at most 3 parallel dimension from the P band\n *\n *\t\tK\n *\t\t|\n *\t\tT\n *\t\tT1\n *\t\t|\n *\t\tT2\n *\t\t|\n *\t\tP1\n *\t\t|\n *\t\tP2\n *\n * A filter is introduced in front of T1 that maps the domain instances\n * to block identifiers.  Similarly, a filter is introduced in front of P1\n * that maps the domain instances to thread identifiers.\n *\n * For each iteration of the T2 band and for each array, we compute\n * the array elements accessed by that iteration, construct a rectangular\n * box around it and shift it to the origin.  The result is used\n * as shared memory for the array.\n *\n * Copying and synchronization statements are added to this schedule tree.\n * In principle, these are added in front of the P1 band, but some of\n * them may get hoisted up to higher levels.\n *\n * The entire AST is then generated from the single resulting schedule tree.\n * During the generation the subtrees at kernel nodes (K) are saved\n * aside and replaced by kernel calls.  The result is printed as host code\n * while the saved subtrees are printed as device code.\n */\nstatic __isl_give isl_printer *generate(__isl_take isl_printer *p,\n\tstruct gpu_gen *gen, struct ppcg_scop *scop,\n\tstruct ppcg_options *options)\n{\n\tstruct gpu_prog *prog;\n\tisl_ctx *ctx;\n\tisl_schedule *schedule;\n\tint any_permutable;\n\n\tif (!scop)\n\t\treturn isl_printer_free(p);\n\n\tctx = isl_printer_get_ctx(p);\n\tprog = gpu_prog_alloc(ctx, scop);\n\tif (!prog)\n\t\treturn isl_printer_free(p);\n\n\tgen->prog = prog;\n\tschedule = get_schedule(gen);\n\n\tany_permutable = has_any_permutable_node(schedule);\n\tif (any_permutable < 0 || !any_permutable) {\n\t\tif (any_permutable < 0)\n\t\t\tp = isl_printer_free(p);\n\t\telse\n\t\t\tp = print_cpu(p, scop, options);\n\t\tisl_schedule_free(schedule);\n\t} else {\n\t\tconst int create_to_from_device = 1;\n\t\tschedule = map_to_device(gen, schedule, create_to_from_device);\n\t\tgen->tree = generate_code(gen, schedule);\n\t\tp = ppcg_set_macro_names(p);\n\t\tp = ppcg_print_exposed_declarations(p, prog->scop);\n\t\tp = gen->print(p, gen->prog, gen->tree, &gen->types,\n\t\t\t\t    gen->print_user);\n\t\tisl_ast_node_free(gen->tree);\n\t}\n\n\tgpu_prog_free(prog);\n\n\treturn p;\n}\n\n/* Wrapper around generate for use as a ppcg_transform callback.\n */\nstatic __isl_give isl_printer *generate_wrap(__isl_take isl_printer *p,\n\tstruct ppcg_scop *scop, void *user)\n{\n\tstruct gpu_gen *gen = user;\n\n\treturn generate(p, gen, scop, gen->options);\n}\n\n/* Transform the code in the file called \"input\" by replacing\n * all scops by corresponding GPU code and write the results to \"out\".\n */\nint generate_gpu(isl_ctx *ctx, const char *input, FILE *out,\n\tstruct ppcg_options *options,\n\t__isl_give isl_printer *(*print)(__isl_take isl_printer *p,\n\t\tstruct gpu_prog *prog, __isl_keep isl_ast_node *tree,\n\t\tstruct gpu_types *types, void *user), void *user)\n{\n\tstruct gpu_gen gen;\n\tint r;\n\tint i;\n\n\tgen.ctx = ctx;\n\tgen.sizes = extract_sizes_from_str(ctx, options->sizes);\n\tgen.options = options;\n\tgen.kernel_id = 0;\n\tgen.print = print;\n\tgen.print_user = user;\n\tgen.types.n = 0;\n\tgen.types.name = NULL;\n\n\tif (options->debug->dump_sizes) {\n\t\tisl_space *space = isl_space_params_alloc(ctx, 0);\n\t\tgen.used_sizes = isl_union_map_empty(space);\n\t}\n\n\tr = ppcg_transform(ctx, input, out, options, &generate_wrap, &gen);\n\n\tif (options->debug->dump_sizes) {\n\t\tisl_union_map_dump(gen.used_sizes);\n\t\tisl_union_map_free(gen.used_sizes);\n\t}\n\n\tisl_union_map_free(gen.sizes);\n\tfor (i = 0; i < gen.types.n; ++i)\n\t\tfree(gen.types.name[i]);\n\tfree(gen.types.name);\n\n\treturn r;\n}\n\n/* Compute the set of inner array elements that may have their values\n * preserved by \"prog\".  In particular, collect the array elements of\n * arrays that are not local to \"prog\" and remove those elements that\n * are definitely killed or definitely written by \"prog\".\n */\n__isl_give isl_union_set *compute_may_persist(struct gpu_prog *prog)\n{\n\tint i;\n\tisl_union_set *may_persist, *killed;\n\tisl_union_map *must_kill;\n\n\tmay_persist = isl_union_set_empty(isl_set_get_space(prog->context));\n\tfor (i = 0; i < prog->n_array; ++i) {\n\t\tisl_set *extent;\n\n\t\tif (prog->array[i].local)\n\t\t\tcontinue;\n\n\t\textent = isl_set_copy(prog->array[i].extent);\n\t\tmay_persist = isl_union_set_add_set(may_persist, extent);\n\t}\n\n\tmay_persist = isl_union_set_intersect_params(may_persist,\n\t\t\t\t\t\tisl_set_copy(prog->context));\n\tmay_persist = isl_union_set_apply(may_persist,\n\t\t\t\t\tisl_union_map_copy(prog->to_inner));\n\tmust_kill = isl_union_map_copy(prog->tagged_must_kill);\n\tkilled = isl_union_map_range(must_kill);\n\tmust_kill = isl_union_map_copy(prog->must_write);\n\tkilled = isl_union_set_union(killed, isl_union_map_range(must_kill));\n\n\tmay_persist = isl_union_set_subtract(may_persist, killed);\n\treturn may_persist;\n}\n\nstruct gpu_prog *gpu_prog_alloc(isl_ctx *ctx, struct ppcg_scop *scop)\n{\n\tstruct gpu_prog *prog;\n\tisl_space *space;\n\tisl_map *id;\n\n\tif (!scop)\n\t\treturn NULL;\n\n\tprog = isl_calloc_type(ctx, struct gpu_prog);\n\tassert(prog);\n\n\tprog->ctx = ctx;\n\tprog->scop = scop;\n\tprog->context = isl_set_copy(scop->context);\n\tprog->n_stmts = scop->pet->n_stmt;\n\tprog->any_to_outer = pet_scop_compute_outer_to_any(scop->pet);\n\tprog->any_to_outer = isl_union_map_reverse(prog->any_to_outer);\n\tspace = isl_union_map_get_space(prog->any_to_outer);\n\tspace = isl_space_set_from_params(space);\n\tspace = isl_space_add_dims(space, isl_dim_set, 1);\n\tspace = isl_space_map_from_set(space);\n\tid = isl_map_identity(space);\n\tprog->any_to_outer = isl_union_map_add_map(prog->any_to_outer, id);\n\tprog->stmts = extract_stmts(ctx, scop, prog->any_to_outer);\n\tprog->read = isl_union_map_copy(scop->reads);\n\tprog->may_write = isl_union_map_copy(scop->may_writes);\n\tprog->must_write = isl_union_map_copy(scop->must_writes);\n\tprog->tagged_must_kill = isl_union_map_copy(scop->tagged_must_kills);\n\tprog->to_inner = pet_scop_compute_outer_to_inner(scop->pet);\n\tprog->to_outer = isl_union_map_copy(prog->to_inner);\n\tprog->to_outer = isl_union_map_reverse(prog->to_outer);\n\n\tif (!prog->stmts)\n\t\treturn gpu_prog_free(prog);\n\n\tif (collect_array_info(prog) < 0)\n\t\treturn gpu_prog_free(prog);\n\tprog->may_persist = compute_may_persist(prog);\n\n\treturn prog;\n}\n\nvoid *gpu_prog_free(struct gpu_prog *prog)\n{\n\tif (!prog)\n\t\treturn NULL;\n\tfree_array_info(prog);\n\tfree_stmts(prog->stmts, prog->n_stmts);\n\tisl_union_map_free(prog->any_to_outer);\n\tisl_union_map_free(prog->to_outer);\n\tisl_union_map_free(prog->to_inner);\n\tisl_union_map_free(prog->read);\n\tisl_union_map_free(prog->may_write);\n\tisl_union_map_free(prog->must_write);\n\tisl_union_map_free(prog->tagged_must_kill);\n\tisl_union_map_free(prog->array_order);\n\tisl_union_set_free(prog->may_persist);\n\tisl_set_free(prog->context);\n\tfree(prog);\n\treturn NULL;\n}\n"}, "7": {"id": 7, "path": "/home/vsts/work/1/llvm-project/polly/lib/External/ppcg/gpu_group.h", "content": "#ifndef GPU_GROUP_H\n#define GPU_GROUP_H\n\n#include <isl/schedule_node.h>\n#include \"gpu.h\"\n\n/* A group of array references in a kernel that should be handled together.\n * If private_tile is not NULL, then it is mapped to registers.\n * Otherwise, if shared_tile is not NULL, it is mapped to shared memory.\n * Otherwise, it is accessed from global memory.\n * Note that if both private_tile and shared_tile are set, then shared_tile\n * is only used inside group_common_shared_memory_tile.\n */\nstruct gpu_array_ref_group {\n\t/* The references in this group access this local array. */\n\tstruct gpu_local_array_info *local_array;\n\t/* This is the corresponding array. */\n\tstruct gpu_array_info *array;\n\t/* Position of this group in the list of reference groups of array. */\n\tint nr;\n\n\t/* The following fields are use during the construction of the groups.\n\t * access is the combined access relation relative to the private\n\t * memory tiling.  In particular, the domain of the map corresponds\n\t * to the first thread_depth dimensions of the kernel schedule.\n\t * write is set if any access in the group is a write.\n\t * exact_write is set if all writes are definite writes.\n\t * slice is set if there is at least one access in the group\n\t * that refers to more than one element\n\t * \"min_depth\" is the minimum of the tile depths and thread_depth.\n\t */\n\tisl_map *access;\n\tint write;\n\tint exact_write;\n\tint slice;\n\tint min_depth;\n\n\t/* The shared memory tile, NULL if none. */\n\tstruct gpu_array_tile *shared_tile;\n\n\t/* The private memory tile, NULL if none. */\n\tstruct gpu_array_tile *private_tile;\n\n\t/* References in this group; point to elements of a linked list. */\n\tint n_ref;\n\tstruct gpu_stmt_access **refs;\n};\n\nint gpu_group_references(struct ppcg_kernel *kernel,\n\t__isl_keep isl_schedule_node *node);\n\n__isl_give isl_printer *gpu_array_ref_group_print_name(\n\tstruct gpu_array_ref_group *group, __isl_take isl_printer *p);\nvoid gpu_array_ref_group_compute_tiling(struct gpu_array_ref_group *group);\n__isl_give isl_union_map *gpu_array_ref_group_access_relation(\n\tstruct gpu_array_ref_group *group, int read, int write);\nint gpu_array_ref_group_requires_unroll(struct gpu_array_ref_group *group);\nenum ppcg_group_access_type gpu_array_ref_group_type(\n\tstruct gpu_array_ref_group *group);\nstruct gpu_array_tile *gpu_array_ref_group_tile(\n\tstruct gpu_array_ref_group *group);\nstruct gpu_array_ref_group *gpu_array_ref_group_free(\n\tstruct gpu_array_ref_group *group);\n\n#endif\n"}, "8": {"id": 8, "path": "/home/vsts/work/1/llvm-project/polly/lib/External/ppcg/gpu_hybrid.h", "content": "#ifndef GPU_HYBRID_H\n#define GPU_HYBRID_H\n\n#include <isl/schedule_node.h>\n\n#include \"gpu.h\"\n#include \"hybrid.h\"\n\n__isl_give isl_schedule_node *gpu_hybrid_tile(struct gpu_gen *gen,\n\t__isl_take isl_schedule_node *node, __isl_take ppcg_ht_bounds *bounds,\n\tint *tile_sizes);\n\n#endif\n"}, "10": {"id": 10, "path": "/home/vsts/work/1/llvm-project/polly/lib/External/ppcg/hybrid.h", "content": "#ifndef HYBRID_H\n#define HYBRID_H\n\n#include <isl/val.h>\n#include <isl/schedule_node.h>\n\n#include \"ppcg.h\"\n\nstruct ppcg_ht_bounds;\ntypedef struct ppcg_ht_bounds ppcg_ht_bounds;\n\nstruct ppcg_ht_phase;\ntypedef struct ppcg_ht_phase ppcg_ht_phase;\n\nisl_bool ppcg_ht_has_input_pattern(__isl_keep isl_schedule_node *node);\nisl_bool ppcg_ht_parent_has_input_pattern(__isl_keep isl_schedule_node *node);\n\n__isl_give ppcg_ht_bounds *ppcg_ht_compute_bounds(struct ppcg_scop *scop,\n\t__isl_keep isl_schedule_node *node);\nvoid ppcg_ht_bounds_dump(__isl_keep ppcg_ht_bounds *bounds);\nisl_bool ppcg_ht_bounds_is_valid(__isl_keep ppcg_ht_bounds *bounds);\nisl_bool ppcg_ht_bounds_supports_sizes(__isl_keep ppcg_ht_bounds *bounds,\n\t__isl_keep isl_multi_val *sizes);\n__isl_give isl_schedule_node *ppcg_ht_bounds_insert_tiling(\n\t__isl_take ppcg_ht_bounds *bounds, __isl_take isl_multi_val *sizes,\n\t__isl_take isl_schedule_node *node, struct ppcg_options *options);\n__isl_null ppcg_ht_bounds *ppcg_ht_bounds_free(\n\t__isl_take ppcg_ht_bounds *bounds);\n\n__isl_keep ppcg_ht_phase *ppcg_ht_phase_extract_from_mark(\n\t__isl_keep isl_schedule_node *node);\n__isl_give isl_schedule_node *ppcg_ht_phase_shift_space_point(\n\t__isl_keep ppcg_ht_phase *phase, __isl_take isl_schedule_node *node);\n__isl_give isl_schedule_node *hybrid_tile_foreach_phase(\n\t__isl_take isl_schedule_node *node,\n\t__isl_give isl_schedule_node *(*fn)(__isl_take isl_schedule_node *node,\n\t\tvoid *user), void *user);\n__isl_give isl_schedule_node *hybrid_tile_drop_phase_marks(\n\t__isl_take isl_schedule_node *node);\n\n#endif\n"}, "13": {"id": 13, "path": "/home/vsts/work/1/llvm-project/polly/lib/External/ppcg/print.h", "content": "#ifndef PRINT_H\n#define PRINT_H\n\n#include <isl/ast.h>\n\n#include \"ppcg.h\"\n\nextern const char *ppcg_min;\nextern const char *ppcg_max;\nextern const char *ppcg_fdiv_q;\n\n__isl_give isl_printer *ppcg_start_block(__isl_take isl_printer *p);\n__isl_give isl_printer *ppcg_end_block(__isl_take isl_printer *p);\n\n__isl_give isl_printer *ppcg_set_macro_names(__isl_take isl_printer *p);\n__isl_give isl_printer *ppcg_set_macros(__isl_take isl_printer *p,\n\tconst char *min, const char *max);\n__isl_give isl_printer *ppcg_print_macro(enum isl_ast_op_type type,\n\t__isl_take isl_printer *p);\n__isl_give isl_printer *ppcg_ast_expr_print_macros(\n\t__isl_keep isl_ast_expr *expr, __isl_take isl_printer *p);\n__isl_give isl_printer *ppcg_print_body_macros(__isl_take isl_printer *p,\n\t__isl_keep isl_id_to_ast_expr *ref2expr);\n__isl_give isl_printer *ppcg_print_macros(__isl_take isl_printer *p,\n\t__isl_keep isl_ast_node *node);\n\n__isl_give isl_ast_expr *ppcg_build_size_expr(__isl_take isl_multi_pw_aff *size,\n\t__isl_keep isl_ast_build *build);\n\n__isl_give isl_printer *ppcg_print_declaration_with_size(\n\t__isl_take isl_printer *p, const char *base_type,\n\t__isl_keep isl_ast_expr *size);\n__isl_give isl_printer *ppcg_print_declaration(__isl_take isl_printer *p,\n\tstruct pet_array *array, __isl_keep isl_ast_build *build);\n__isl_give isl_printer *ppcg_print_exposed_declarations(\n\t__isl_take isl_printer *p, struct ppcg_scop *scop);\n__isl_give isl_printer *ppcg_print_hidden_declarations(\n\t__isl_take isl_printer *p, struct ppcg_scop *scop);\n\n#endif\n"}, "15": {"id": 15, "path": "/home/vsts/work/1/llvm-project/polly/lib/External/ppcg/util.h", "content": "#ifndef UTIL_H\n#define UTIL_H\n\n#include <string.h>\n\n#include <isl/space.h>\n#include <isl/val.h>\n\n/* Compare the prefix of \"s\" to \"prefix\" up to the length of \"prefix\".\n */\nstatic inline int prefixcmp(const char *s, const char *prefix)\n{\n\treturn strncmp(s, prefix, strlen(prefix));\n}\n\n__isl_give isl_multi_val *ppcg_multi_val_from_int(__isl_take isl_space *space,\n\tint val);\n__isl_give isl_multi_val *ppcg_multi_val_from_int_list(\n\t__isl_take isl_space *space, int *list);\n__isl_give isl_multi_pw_aff *ppcg_size_from_extent(__isl_take isl_set *set);\n\n#endif\n"}}, "reports": [{"events": [{"location": {"col": 16, "file": 4, "line": 458}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/ppcg/gpu.c", "reportHash": "309e22acaee30423353f0d1fe5ae3b9e", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 4, "line": 817}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/ppcg/gpu.c", "reportHash": "309e22acaee30423353f0d1fe5ae3b9e", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 4, "line": 1226}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/ppcg/gpu.c", "reportHash": "b100f56a09043248819adbb48a88fd0b", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 4, "line": 1763}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/ppcg/gpu.c", "reportHash": "be6f774828e8d6fcbe138b1519269152", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 25, "file": 4, "line": 1775}, "message": "comparison of integers of different signs: 'unsigned int' and 'int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/ppcg/gpu.c", "reportHash": "6cc7e822e9006c6968ab5232066045a1", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 12, "file": 4, "line": 5449}, "message": "ordered comparison between pointer and zero ('isl_multi_pw_aff *' (aka 'struct isl_multi_pw_aff *') and 'int') is an extension"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/ppcg/gpu.c", "reportHash": "63d5f037fe848b1cf1599b8091689c95", "checkerName": "clang-diagnostic-pedantic", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 9, "file": 7, "line": 1}, "message": "LLVM_POLLY_LIB_EXTERNAL_PPCG_GPU_GROUP_H (fixit)"}, {"location": {"col": 9, "file": 7, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/ppcg/gpu_group.h", "reportHash": "f8a2a133971dfaa4f6c4d34bf982c09b", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 8, "line": 1}, "message": "LLVM_POLLY_LIB_EXTERNAL_PPCG_GPU_HYBRID_H (fixit)"}, {"location": {"col": 9, "file": 8, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/ppcg/gpu_hybrid.h", "reportHash": "20435c5b770c9c94e3f46d855bf9e805", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 10, "line": 1}, "message": "LLVM_POLLY_LIB_EXTERNAL_PPCG_HYBRID_H (fixit)"}, {"location": {"col": 9, "file": 10, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/ppcg/hybrid.h", "reportHash": "3589cadb0749746da6dc28eebcf7e030", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 13, "line": 1}, "message": "LLVM_POLLY_LIB_EXTERNAL_PPCG_PRINT_H (fixit)"}, {"location": {"col": 9, "file": 13, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/ppcg/print.h", "reportHash": "d8e635935f262d58237c7c07b99f944f", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 15, "line": 1}, "message": "LLVM_POLLY_LIB_EXTERNAL_PPCG_UTIL_H (fixit)"}, {"location": {"col": 9, "file": 15, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/ppcg/util.h", "reportHash": "9a2eb14168728b5466fb4942d305c583", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
