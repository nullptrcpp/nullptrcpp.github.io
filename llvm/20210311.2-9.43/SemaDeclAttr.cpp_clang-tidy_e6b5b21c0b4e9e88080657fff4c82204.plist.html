<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"20": {"id": 20, "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp", "content": "//===--- SemaDeclAttr.cpp - Declaration Attribute Handling ----------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file implements decl-related attribute processing.\n//\n//===----------------------------------------------------------------------===//\n\n#include \"clang/AST/ASTConsumer.h\"\n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/ASTMutationListener.h\"\n#include \"clang/AST/CXXInheritance.h\"\n#include \"clang/AST/DeclCXX.h\"\n#include \"clang/AST/DeclObjC.h\"\n#include \"clang/AST/DeclTemplate.h\"\n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/ExprCXX.h\"\n#include \"clang/AST/Mangle.h\"\n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/CharInfo.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Basic/SourceManager.h\"\n#include \"clang/Basic/TargetBuiltins.h\"\n#include \"clang/Basic/TargetInfo.h\"\n#include \"clang/Lex/Preprocessor.h\"\n#include \"clang/Sema/DeclSpec.h\"\n#include \"clang/Sema/DelayedDiagnostic.h\"\n#include \"clang/Sema/Initialization.h\"\n#include \"clang/Sema/Lookup.h\"\n#include \"clang/Sema/ParsedAttr.h\"\n#include \"clang/Sema/Scope.h\"\n#include \"clang/Sema/ScopeInfo.h\"\n#include \"clang/Sema/SemaInternal.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/StringExtras.h\"\n#include \"llvm/IR/Assumptions.h\"\n#include \"llvm/Support/Error.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include \"llvm/Support/raw_ostream.h\"\n\nusing namespace clang;\nusing namespace sema;\n\nnamespace AttributeLangSupport {\n  enum LANG {\n    C,\n    Cpp,\n    ObjC\n  };\n} // end namespace AttributeLangSupport\n\n//===----------------------------------------------------------------------===//\n//  Helper functions\n//===----------------------------------------------------------------------===//\n\n/// isFunctionOrMethod - Return true if the given decl has function\n/// type (function or function-typed variable) or an Objective-C\n/// method.\nstatic bool isFunctionOrMethod(const Decl *D) {\n  return (D->getFunctionType() != nullptr) || isa<ObjCMethodDecl>(D);\n}\n\n/// Return true if the given decl has function type (function or\n/// function-typed variable) or an Objective-C method or a block.\nstatic bool isFunctionOrMethodOrBlock(const Decl *D) {\n  return isFunctionOrMethod(D) || isa<BlockDecl>(D);\n}\n\n/// Return true if the given decl has a declarator that should have\n/// been processed by Sema::GetTypeForDeclarator.\nstatic bool hasDeclarator(const Decl *D) {\n  // In some sense, TypedefDecl really *ought* to be a DeclaratorDecl.\n  return isa<DeclaratorDecl>(D) || isa<BlockDecl>(D) || isa<TypedefNameDecl>(D) ||\n         isa<ObjCPropertyDecl>(D);\n}\n\n/// hasFunctionProto - Return true if the given decl has a argument\n/// information. This decl should have already passed\n/// isFunctionOrMethod or isFunctionOrMethodOrBlock.\nstatic bool hasFunctionProto(const Decl *D) {\n  if (const FunctionType *FnTy = D->getFunctionType())\n    return isa<FunctionProtoType>(FnTy);\n  return isa<ObjCMethodDecl>(D) || isa<BlockDecl>(D);\n}\n\n/// getFunctionOrMethodNumParams - Return number of function or method\n/// parameters. It is an error to call this on a K&R function (use\n/// hasFunctionProto first).\nstatic unsigned getFunctionOrMethodNumParams(const Decl *D) {\n  if (const FunctionType *FnTy = D->getFunctionType())\n    return cast<FunctionProtoType>(FnTy)->getNumParams();\n  if (const auto *BD = dyn_cast<BlockDecl>(D))\n    return BD->getNumParams();\n  return cast<ObjCMethodDecl>(D)->param_size();\n}\n\nstatic const ParmVarDecl *getFunctionOrMethodParam(const Decl *D,\n                                                   unsigned Idx) {\n  if (const auto *FD = dyn_cast<FunctionDecl>(D))\n    return FD->getParamDecl(Idx);\n  if (const auto *MD = dyn_cast<ObjCMethodDecl>(D))\n    return MD->getParamDecl(Idx);\n  if (const auto *BD = dyn_cast<BlockDecl>(D))\n    return BD->getParamDecl(Idx);\n  return nullptr;\n}\n\nstatic QualType getFunctionOrMethodParamType(const Decl *D, unsigned Idx) {\n  if (const FunctionType *FnTy = D->getFunctionType())\n    return cast<FunctionProtoType>(FnTy)->getParamType(Idx);\n  if (const auto *BD = dyn_cast<BlockDecl>(D))\n    return BD->getParamDecl(Idx)->getType();\n\n  return cast<ObjCMethodDecl>(D)->parameters()[Idx]->getType();\n}\n\nstatic SourceRange getFunctionOrMethodParamRange(const Decl *D, unsigned Idx) {\n  if (auto *PVD = getFunctionOrMethodParam(D, Idx))\n    return PVD->getSourceRange();\n  return SourceRange();\n}\n\nstatic QualType getFunctionOrMethodResultType(const Decl *D) {\n  if (const FunctionType *FnTy = D->getFunctionType())\n    return FnTy->getReturnType();\n  return cast<ObjCMethodDecl>(D)->getReturnType();\n}\n\nstatic SourceRange getFunctionOrMethodResultSourceRange(const Decl *D) {\n  if (const auto *FD = dyn_cast<FunctionDecl>(D))\n    return FD->getReturnTypeSourceRange();\n  if (const auto *MD = dyn_cast<ObjCMethodDecl>(D))\n    return MD->getReturnTypeSourceRange();\n  return SourceRange();\n}\n\nstatic bool isFunctionOrMethodVariadic(const Decl *D) {\n  if (const FunctionType *FnTy = D->getFunctionType())\n    return cast<FunctionProtoType>(FnTy)->isVariadic();\n  if (const auto *BD = dyn_cast<BlockDecl>(D))\n    return BD->isVariadic();\n  return cast<ObjCMethodDecl>(D)->isVariadic();\n}\n\nstatic bool isInstanceMethod(const Decl *D) {\n  if (const auto *MethodDecl = dyn_cast<CXXMethodDecl>(D))\n    return MethodDecl->isInstance();\n  return false;\n}\n\nstatic inline bool isNSStringType(QualType T, ASTContext &Ctx,\n                                  bool AllowNSAttributedString = false) {\n  const auto *PT = T->getAs<ObjCObjectPointerType>();\n  if (!PT)\n    return false;\n\n  ObjCInterfaceDecl *Cls = PT->getObjectType()->getInterface();\n  if (!Cls)\n    return false;\n\n  IdentifierInfo* ClsName = Cls->getIdentifier();\n\n  if (AllowNSAttributedString &&\n      ClsName == &Ctx.Idents.get(\"NSAttributedString\"))\n    return true;\n  // FIXME: Should we walk the chain of classes?\n  return ClsName == &Ctx.Idents.get(\"NSString\") ||\n         ClsName == &Ctx.Idents.get(\"NSMutableString\");\n}\n\nstatic inline bool isCFStringType(QualType T, ASTContext &Ctx) {\n  const auto *PT = T->getAs<PointerType>();\n  if (!PT)\n    return false;\n\n  const auto *RT = PT->getPointeeType()->getAs<RecordType>();\n  if (!RT)\n    return false;\n\n  const RecordDecl *RD = RT->getDecl();\n  if (RD->getTagKind() != TTK_Struct)\n    return false;\n\n  return RD->getIdentifier() == &Ctx.Idents.get(\"__CFString\");\n}\n\nstatic unsigned getNumAttributeArgs(const ParsedAttr &AL) {\n  // FIXME: Include the type in the argument list.\n  return AL.getNumArgs() + AL.hasParsedType();\n}\n\n/// A helper function to provide Attribute Location for the Attr types\n/// AND the ParsedAttr.\ntemplate <typename AttrInfo>\nstatic std::enable_if_t<std::is_base_of<Attr, AttrInfo>::value, SourceLocation>\ngetAttrLoc(const AttrInfo &AL) {\n  return AL.getLocation();\n}\nstatic SourceLocation getAttrLoc(const ParsedAttr &AL) { return AL.getLoc(); }\n\n/// If Expr is a valid integer constant, get the value of the integer\n/// expression and return success or failure. May output an error.\n///\n/// Negative argument is implicitly converted to unsigned, unless\n/// \\p StrictlyUnsigned is true.\ntemplate <typename AttrInfo>\nstatic bool checkUInt32Argument(Sema &S, const AttrInfo &AI, const Expr *Expr,\n                                uint32_t &Val, unsigned Idx = UINT_MAX,\n                                bool StrictlyUnsigned = false) {\n  Optional<llvm::APSInt> I = llvm::APSInt(32);\n  if (Expr->isTypeDependent() || Expr->isValueDependent() ||\n      !(I = Expr->getIntegerConstantExpr(S.Context))) {\n    if (Idx != UINT_MAX)\n      S.Diag(getAttrLoc(AI), diag::err_attribute_argument_n_type)\n          << &AI << Idx << AANT_ArgumentIntegerConstant\n          << Expr->getSourceRange();\n    else\n      S.Diag(getAttrLoc(AI), diag::err_attribute_argument_type)\n          << &AI << AANT_ArgumentIntegerConstant << Expr->getSourceRange();\n    return false;\n  }\n\n  if (!I->isIntN(32)) {\n    S.Diag(Expr->getExprLoc(), diag::err_ice_too_large)\n        << I->toString(10, false) << 32 << /* Unsigned */ 1;\n    return false;\n  }\n\n  if (StrictlyUnsigned && I->isSigned() && I->isNegative()) {\n    S.Diag(getAttrLoc(AI), diag::err_attribute_requires_positive_integer)\n        << &AI << /*non-negative*/ 1;\n    return false;\n  }\n\n  Val = (uint32_t)I->getZExtValue();\n  return true;\n}\n\n/// Wrapper around checkUInt32Argument, with an extra check to be sure\n/// that the result will fit into a regular (signed) int. All args have the same\n/// purpose as they do in checkUInt32Argument.\ntemplate <typename AttrInfo>\nstatic bool checkPositiveIntArgument(Sema &S, const AttrInfo &AI, const Expr *Expr,\n                                     int &Val, unsigned Idx = UINT_MAX) {\n  uint32_t UVal;\n  if (!checkUInt32Argument(S, AI, Expr, UVal, Idx))\n    return false;\n\n  if (UVal > (uint32_t)std::numeric_limits<int>::max()) {\n    llvm::APSInt I(32); // for toString\n    I = UVal;\n    S.Diag(Expr->getExprLoc(), diag::err_ice_too_large)\n        << I.toString(10, false) << 32 << /* Unsigned */ 0;\n    return false;\n  }\n\n  Val = UVal;\n  return true;\n}\n\n/// Diagnose mutually exclusive attributes when present on a given\n/// declaration. Returns true if diagnosed.\ntemplate <typename AttrTy>\nstatic bool checkAttrMutualExclusion(Sema &S, Decl *D, const ParsedAttr &AL) {\n  if (const auto *A = D->getAttr<AttrTy>()) {\n    S.Diag(AL.getLoc(), diag::err_attributes_are_not_compatible) << AL << A;\n    S.Diag(A->getLocation(), diag::note_conflicting_attribute);\n    return true;\n  }\n  return false;\n}\n\ntemplate <typename AttrTy>\nstatic bool checkAttrMutualExclusion(Sema &S, Decl *D, const Attr &AL) {\n  if (const auto *A = D->getAttr<AttrTy>()) {\n    S.Diag(AL.getLocation(), diag::err_attributes_are_not_compatible) << &AL\n                                                                      << A;\n    S.Diag(A->getLocation(), diag::note_conflicting_attribute);\n    return true;\n  }\n  return false;\n}\n\n/// Check if IdxExpr is a valid parameter index for a function or\n/// instance method D.  May output an error.\n///\n/// \\returns true if IdxExpr is a valid index.\ntemplate <typename AttrInfo>\nstatic bool checkFunctionOrMethodParameterIndex(\n    Sema &S, const Decl *D, const AttrInfo &AI, unsigned AttrArgNum,\n    const Expr *IdxExpr, ParamIdx &Idx, bool CanIndexImplicitThis = false) {\n  assert(isFunctionOrMethodOrBlock(D));\n\n  // In C++ the implicit 'this' function parameter also counts.\n  // Parameters are counted from one.\n  bool HP = hasFunctionProto(D);\n  bool HasImplicitThisParam = isInstanceMethod(D);\n  bool IV = HP && isFunctionOrMethodVariadic(D);\n  unsigned NumParams =\n      (HP ? getFunctionOrMethodNumParams(D) : 0) + HasImplicitThisParam;\n\n  Optional<llvm::APSInt> IdxInt;\n  if (IdxExpr->isTypeDependent() || IdxExpr->isValueDependent() ||\n      !(IdxInt = IdxExpr->getIntegerConstantExpr(S.Context))) {\n    S.Diag(getAttrLoc(AI), diag::err_attribute_argument_n_type)\n        << &AI << AttrArgNum << AANT_ArgumentIntegerConstant\n        << IdxExpr->getSourceRange();\n    return false;\n  }\n\n  unsigned IdxSource = IdxInt->getLimitedValue(UINT_MAX);\n  if (IdxSource < 1 || (!IV && IdxSource > NumParams)) {\n    S.Diag(getAttrLoc(AI), diag::err_attribute_argument_out_of_bounds)\n        << &AI << AttrArgNum << IdxExpr->getSourceRange();\n    return false;\n  }\n  if (HasImplicitThisParam && !CanIndexImplicitThis) {\n    if (IdxSource == 1) {\n      S.Diag(getAttrLoc(AI), diag::err_attribute_invalid_implicit_this_argument)\n          << &AI << IdxExpr->getSourceRange();\n      return false;\n    }\n  }\n\n  Idx = ParamIdx(IdxSource, D);\n  return true;\n}\n\n/// Check if the argument \\p ArgNum of \\p Attr is a ASCII string literal.\n/// If not emit an error and return false. If the argument is an identifier it\n/// will emit an error with a fixit hint and treat it as if it was a string\n/// literal.\nbool Sema::checkStringLiteralArgumentAttr(const ParsedAttr &AL, unsigned ArgNum,\n                                          StringRef &Str,\n                                          SourceLocation *ArgLocation) {\n  // Look for identifiers. If we have one emit a hint to fix it to a literal.\n  if (AL.isArgIdent(ArgNum)) {\n    IdentifierLoc *Loc = AL.getArgAsIdent(ArgNum);\n    Diag(Loc->Loc, diag::err_attribute_argument_type)\n        << AL << AANT_ArgumentString\n        << FixItHint::CreateInsertion(Loc->Loc, \"\\\"\")\n        << FixItHint::CreateInsertion(getLocForEndOfToken(Loc->Loc), \"\\\"\");\n    Str = Loc->Ident->getName();\n    if (ArgLocation)\n      *ArgLocation = Loc->Loc;\n    return true;\n  }\n\n  // Now check for an actual string literal.\n  Expr *ArgExpr = AL.getArgAsExpr(ArgNum);\n  const auto *Literal = dyn_cast<StringLiteral>(ArgExpr->IgnoreParenCasts());\n  if (ArgLocation)\n    *ArgLocation = ArgExpr->getBeginLoc();\n\n  if (!Literal || !Literal->isAscii()) {\n    Diag(ArgExpr->getBeginLoc(), diag::err_attribute_argument_type)\n        << AL << AANT_ArgumentString;\n    return false;\n  }\n\n  Str = Literal->getString();\n  return true;\n}\n\n/// Applies the given attribute to the Decl without performing any\n/// additional semantic checking.\ntemplate <typename AttrType>\nstatic void handleSimpleAttribute(Sema &S, Decl *D,\n                                  const AttributeCommonInfo &CI) {\n  D->addAttr(::new (S.Context) AttrType(S.Context, CI));\n}\n\ntemplate <typename... DiagnosticArgs>\nstatic const Sema::SemaDiagnosticBuilder&\nappendDiagnostics(const Sema::SemaDiagnosticBuilder &Bldr) {\n  return Bldr;\n}\n\ntemplate <typename T, typename... DiagnosticArgs>\nstatic const Sema::SemaDiagnosticBuilder&\nappendDiagnostics(const Sema::SemaDiagnosticBuilder &Bldr, T &&ExtraArg,\n                  DiagnosticArgs &&... ExtraArgs) {\n  return appendDiagnostics(Bldr << std::forward<T>(ExtraArg),\n                           std::forward<DiagnosticArgs>(ExtraArgs)...);\n}\n\n/// Add an attribute {@code AttrType} to declaration {@code D}, provided that\n/// {@code PassesCheck} is true.\n/// Otherwise, emit diagnostic {@code DiagID}, passing in all parameters\n/// specified in {@code ExtraArgs}.\ntemplate <typename AttrType, typename... DiagnosticArgs>\nstatic void handleSimpleAttributeOrDiagnose(Sema &S, Decl *D,\n                                            const AttributeCommonInfo &CI,\n                                            bool PassesCheck, unsigned DiagID,\n                                            DiagnosticArgs &&... ExtraArgs) {\n  if (!PassesCheck) {\n    Sema::SemaDiagnosticBuilder DB = S.Diag(D->getBeginLoc(), DiagID);\n    appendDiagnostics(DB, std::forward<DiagnosticArgs>(ExtraArgs)...);\n    return;\n  }\n  handleSimpleAttribute<AttrType>(S, D, CI);\n}\n\ntemplate <typename AttrType>\nstatic void handleSimpleAttributeWithExclusions(Sema &S, Decl *D,\n                                                const ParsedAttr &AL) {\n  handleSimpleAttribute<AttrType>(S, D, AL);\n}\n\n/// Applies the given attribute to the Decl so long as the Decl doesn't\n/// already have one of the given incompatible attributes.\ntemplate <typename AttrType, typename IncompatibleAttrType,\n          typename... IncompatibleAttrTypes>\nstatic void handleSimpleAttributeWithExclusions(Sema &S, Decl *D,\n                                                const ParsedAttr &AL) {\n  if (checkAttrMutualExclusion<IncompatibleAttrType>(S, D, AL))\n    return;\n  handleSimpleAttributeWithExclusions<AttrType, IncompatibleAttrTypes...>(S, D,\n                                                                          AL);\n}\n\n/// Check if the passed-in expression is of type int or bool.\nstatic bool isIntOrBool(Expr *Exp) {\n  QualType QT = Exp->getType();\n  return QT->isBooleanType() || QT->isIntegerType();\n}\n\n\n// Check to see if the type is a smart pointer of some kind.  We assume\n// it's a smart pointer if it defines both operator-> and operator*.\nstatic bool threadSafetyCheckIsSmartPointer(Sema &S, const RecordType* RT) {\n  auto IsOverloadedOperatorPresent = [&S](const RecordDecl *Record,\n                                          OverloadedOperatorKind Op) {\n    DeclContextLookupResult Result =\n        Record->lookup(S.Context.DeclarationNames.getCXXOperatorName(Op));\n    return !Result.empty();\n  };\n\n  const RecordDecl *Record = RT->getDecl();\n  bool foundStarOperator = IsOverloadedOperatorPresent(Record, OO_Star);\n  bool foundArrowOperator = IsOverloadedOperatorPresent(Record, OO_Arrow);\n  if (foundStarOperator && foundArrowOperator)\n    return true;\n\n  const CXXRecordDecl *CXXRecord = dyn_cast<CXXRecordDecl>(Record);\n  if (!CXXRecord)\n    return false;\n\n  for (auto BaseSpecifier : CXXRecord->bases()) {\n    if (!foundStarOperator)\n      foundStarOperator = IsOverloadedOperatorPresent(\n          BaseSpecifier.getType()->getAsRecordDecl(), OO_Star);\n    if (!foundArrowOperator)\n      foundArrowOperator = IsOverloadedOperatorPresent(\n          BaseSpecifier.getType()->getAsRecordDecl(), OO_Arrow);\n  }\n\n  if (foundStarOperator && foundArrowOperator)\n    return true;\n\n  return false;\n}\n\n/// Check if passed in Decl is a pointer type.\n/// Note that this function may produce an error message.\n/// \\return true if the Decl is a pointer type; false otherwise\nstatic bool threadSafetyCheckIsPointer(Sema &S, const Decl *D,\n                                       const ParsedAttr &AL) {\n  const auto *VD = cast<ValueDecl>(D);\n  QualType QT = VD->getType();\n  if (QT->isAnyPointerType())\n    return true;\n\n  if (const auto *RT = QT->getAs<RecordType>()) {\n    // If it's an incomplete type, it could be a smart pointer; skip it.\n    // (We don't want to force template instantiation if we can avoid it,\n    // since that would alter the order in which templates are instantiated.)\n    if (RT->isIncompleteType())\n      return true;\n\n    if (threadSafetyCheckIsSmartPointer(S, RT))\n      return true;\n  }\n\n  S.Diag(AL.getLoc(), diag::warn_thread_attribute_decl_not_pointer) << AL << QT;\n  return false;\n}\n\n/// Checks that the passed in QualType either is of RecordType or points\n/// to RecordType. Returns the relevant RecordType, null if it does not exit.\nstatic const RecordType *getRecordType(QualType QT) {\n  if (const auto *RT = QT->getAs<RecordType>())\n    return RT;\n\n  // Now check if we point to record type.\n  if (const auto *PT = QT->getAs<PointerType>())\n    return PT->getPointeeType()->getAs<RecordType>();\n\n  return nullptr;\n}\n\ntemplate <typename AttrType>\nstatic bool checkRecordDeclForAttr(const RecordDecl *RD) {\n  // Check if the record itself has the attribute.\n  if (RD->hasAttr<AttrType>())\n    return true;\n\n  // Else check if any base classes have the attribute.\n  if (const auto *CRD = dyn_cast<CXXRecordDecl>(RD)) {\n    CXXBasePaths BPaths(false, false);\n    if (CRD->lookupInBases(\n            [](const CXXBaseSpecifier *BS, CXXBasePath &) {\n              const auto &Ty = *BS->getType();\n              // If it's type-dependent, we assume it could have the attribute.\n              if (Ty.isDependentType())\n                return true;\n              return Ty.castAs<RecordType>()->getDecl()->hasAttr<AttrType>();\n            },\n            BPaths, true))\n      return true;\n  }\n  return false;\n}\n\nstatic bool checkRecordTypeForCapability(Sema &S, QualType Ty) {\n  const RecordType *RT = getRecordType(Ty);\n\n  if (!RT)\n    return false;\n\n  // Don't check for the capability if the class hasn't been defined yet.\n  if (RT->isIncompleteType())\n    return true;\n\n  // Allow smart pointers to be used as capability objects.\n  // FIXME -- Check the type that the smart pointer points to.\n  if (threadSafetyCheckIsSmartPointer(S, RT))\n    return true;\n\n  return checkRecordDeclForAttr<CapabilityAttr>(RT->getDecl());\n}\n\nstatic bool checkTypedefTypeForCapability(QualType Ty) {\n  const auto *TD = Ty->getAs<TypedefType>();\n  if (!TD)\n    return false;\n\n  TypedefNameDecl *TN = TD->getDecl();\n  if (!TN)\n    return false;\n\n  return TN->hasAttr<CapabilityAttr>();\n}\n\nstatic bool typeHasCapability(Sema &S, QualType Ty) {\n  if (checkTypedefTypeForCapability(Ty))\n    return true;\n\n  if (checkRecordTypeForCapability(S, Ty))\n    return true;\n\n  return false;\n}\n\nstatic bool isCapabilityExpr(Sema &S, const Expr *Ex) {\n  // Capability expressions are simple expressions involving the boolean logic\n  // operators &&, || or !, a simple DeclRefExpr, CastExpr or a ParenExpr. Once\n  // a DeclRefExpr is found, its type should be checked to determine whether it\n  // is a capability or not.\n\n  if (const auto *E = dyn_cast<CastExpr>(Ex))\n    return isCapabilityExpr(S, E->getSubExpr());\n  else if (const auto *E = dyn_cast<ParenExpr>(Ex))\n    return isCapabilityExpr(S, E->getSubExpr());\n  else if (const auto *E = dyn_cast<UnaryOperator>(Ex)) {\n    if (E->getOpcode() == UO_LNot || E->getOpcode() == UO_AddrOf ||\n        E->getOpcode() == UO_Deref)\n      return isCapabilityExpr(S, E->getSubExpr());\n    return false;\n  } else if (const auto *E = dyn_cast<BinaryOperator>(Ex)) {\n    if (E->getOpcode() == BO_LAnd || E->getOpcode() == BO_LOr)\n      return isCapabilityExpr(S, E->getLHS()) &&\n             isCapabilityExpr(S, E->getRHS());\n    return false;\n  }\n\n  return typeHasCapability(S, Ex->getType());\n}\n\n/// Checks that all attribute arguments, starting from Sidx, resolve to\n/// a capability object.\n/// \\param Sidx The attribute argument index to start checking with.\n/// \\param ParamIdxOk Whether an argument can be indexing into a function\n/// parameter list.\nstatic void checkAttrArgsAreCapabilityObjs(Sema &S, Decl *D,\n                                           const ParsedAttr &AL,\n                                           SmallVectorImpl<Expr *> &Args,\n                                           unsigned Sidx = 0,\n                                           bool ParamIdxOk = false) {\n  if (Sidx == AL.getNumArgs()) {\n    // If we don't have any capability arguments, the attribute implicitly\n    // refers to 'this'. So we need to make sure that 'this' exists, i.e. we're\n    // a non-static method, and that the class is a (scoped) capability.\n    const auto *MD = dyn_cast<const CXXMethodDecl>(D);\n    if (MD && !MD->isStatic()) {\n      const CXXRecordDecl *RD = MD->getParent();\n      // FIXME -- need to check this again on template instantiation\n      if (!checkRecordDeclForAttr<CapabilityAttr>(RD) &&\n          !checkRecordDeclForAttr<ScopedLockableAttr>(RD))\n        S.Diag(AL.getLoc(),\n               diag::warn_thread_attribute_not_on_capability_member)\n            << AL << MD->getParent();\n    } else {\n      S.Diag(AL.getLoc(), diag::warn_thread_attribute_not_on_non_static_member)\n          << AL;\n    }\n  }\n\n  for (unsigned Idx = Sidx; Idx < AL.getNumArgs(); ++Idx) {\n    Expr *ArgExp = AL.getArgAsExpr(Idx);\n\n    if (ArgExp->isTypeDependent()) {\n      // FIXME -- need to check this again on template instantiation\n      Args.push_back(ArgExp);\n      continue;\n    }\n\n    if (const auto *StrLit = dyn_cast<StringLiteral>(ArgExp)) {\n      if (StrLit->getLength() == 0 ||\n          (StrLit->isAscii() && StrLit->getString() == StringRef(\"*\"))) {\n        // Pass empty strings to the analyzer without warnings.\n        // Treat \"*\" as the universal lock.\n        Args.push_back(ArgExp);\n        continue;\n      }\n\n      // We allow constant strings to be used as a placeholder for expressions\n      // that are not valid C++ syntax, but warn that they are ignored.\n      S.Diag(AL.getLoc(), diag::warn_thread_attribute_ignored) << AL;\n      Args.push_back(ArgExp);\n      continue;\n    }\n\n    QualType ArgTy = ArgExp->getType();\n\n    // A pointer to member expression of the form  &MyClass::mu is treated\n    // specially -- we need to look at the type of the member.\n    if (const auto *UOp = dyn_cast<UnaryOperator>(ArgExp))\n      if (UOp->getOpcode() == UO_AddrOf)\n        if (const auto *DRE = dyn_cast<DeclRefExpr>(UOp->getSubExpr()))\n          if (DRE->getDecl()->isCXXInstanceMember())\n            ArgTy = DRE->getDecl()->getType();\n\n    // First see if we can just cast to record type, or pointer to record type.\n    const RecordType *RT = getRecordType(ArgTy);\n\n    // Now check if we index into a record type function param.\n    if(!RT && ParamIdxOk) {\n      const auto *FD = dyn_cast<FunctionDecl>(D);\n      const auto *IL = dyn_cast<IntegerLiteral>(ArgExp);\n      if(FD && IL) {\n        unsigned int NumParams = FD->getNumParams();\n        llvm::APInt ArgValue = IL->getValue();\n        uint64_t ParamIdxFromOne = ArgValue.getZExtValue();\n        uint64_t ParamIdxFromZero = ParamIdxFromOne - 1;\n        if (!ArgValue.isStrictlyPositive() || ParamIdxFromOne > NumParams) {\n          S.Diag(AL.getLoc(),\n                 diag::err_attribute_argument_out_of_bounds_extra_info)\n              << AL << Idx + 1 << NumParams;\n          continue;\n        }\n        ArgTy = FD->getParamDecl(ParamIdxFromZero)->getType();\n      }\n    }\n\n    // If the type does not have a capability, see if the components of the\n    // expression have capabilities. This allows for writing C code where the\n    // capability may be on the type, and the expression is a capability\n    // boolean logic expression. Eg) requires_capability(A || B && !C)\n    if (!typeHasCapability(S, ArgTy) && !isCapabilityExpr(S, ArgExp))\n      S.Diag(AL.getLoc(), diag::warn_thread_attribute_argument_not_lockable)\n          << AL << ArgTy;\n\n    Args.push_back(ArgExp);\n  }\n}\n\n//===----------------------------------------------------------------------===//\n// Attribute Implementations\n//===----------------------------------------------------------------------===//\n\nstatic void handlePtGuardedVarAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  if (!threadSafetyCheckIsPointer(S, D, AL))\n    return;\n\n  D->addAttr(::new (S.Context) PtGuardedVarAttr(S.Context, AL));\n}\n\nstatic bool checkGuardedByAttrCommon(Sema &S, Decl *D, const ParsedAttr &AL,\n                                     Expr *&Arg) {\n  SmallVector<Expr *, 1> Args;\n  // check that all arguments are lockable objects\n  checkAttrArgsAreCapabilityObjs(S, D, AL, Args);\n  unsigned Size = Args.size();\n  if (Size != 1)\n    return false;\n\n  Arg = Args[0];\n\n  return true;\n}\n\nstatic void handleGuardedByAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  Expr *Arg = nullptr;\n  if (!checkGuardedByAttrCommon(S, D, AL, Arg))\n    return;\n\n  D->addAttr(::new (S.Context) GuardedByAttr(S.Context, AL, Arg));\n}\n\nstatic void handlePtGuardedByAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  Expr *Arg = nullptr;\n  if (!checkGuardedByAttrCommon(S, D, AL, Arg))\n    return;\n\n  if (!threadSafetyCheckIsPointer(S, D, AL))\n    return;\n\n  D->addAttr(::new (S.Context) PtGuardedByAttr(S.Context, AL, Arg));\n}\n\nstatic bool checkAcquireOrderAttrCommon(Sema &S, Decl *D, const ParsedAttr &AL,\n                                        SmallVectorImpl<Expr *> &Args) {\n  if (!AL.checkAtLeastNumArgs(S, 1))\n    return false;\n\n  // Check that this attribute only applies to lockable types.\n  QualType QT = cast<ValueDecl>(D)->getType();\n  if (!QT->isDependentType() && !typeHasCapability(S, QT)) {\n    S.Diag(AL.getLoc(), diag::warn_thread_attribute_decl_not_lockable) << AL;\n    return false;\n  }\n\n  // Check that all arguments are lockable objects.\n  checkAttrArgsAreCapabilityObjs(S, D, AL, Args);\n  if (Args.empty())\n    return false;\n\n  return true;\n}\n\nstatic void handleAcquiredAfterAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  SmallVector<Expr *, 1> Args;\n  if (!checkAcquireOrderAttrCommon(S, D, AL, Args))\n    return;\n\n  Expr **StartArg = &Args[0];\n  D->addAttr(::new (S.Context)\n                 AcquiredAfterAttr(S.Context, AL, StartArg, Args.size()));\n}\n\nstatic void handleAcquiredBeforeAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  SmallVector<Expr *, 1> Args;\n  if (!checkAcquireOrderAttrCommon(S, D, AL, Args))\n    return;\n\n  Expr **StartArg = &Args[0];\n  D->addAttr(::new (S.Context)\n                 AcquiredBeforeAttr(S.Context, AL, StartArg, Args.size()));\n}\n\nstatic bool checkLockFunAttrCommon(Sema &S, Decl *D, const ParsedAttr &AL,\n                                   SmallVectorImpl<Expr *> &Args) {\n  // zero or more arguments ok\n  // check that all arguments are lockable objects\n  checkAttrArgsAreCapabilityObjs(S, D, AL, Args, 0, /*ParamIdxOk=*/true);\n\n  return true;\n}\n\nstatic void handleAssertSharedLockAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  SmallVector<Expr *, 1> Args;\n  if (!checkLockFunAttrCommon(S, D, AL, Args))\n    return;\n\n  unsigned Size = Args.size();\n  Expr **StartArg = Size == 0 ? nullptr : &Args[0];\n  D->addAttr(::new (S.Context)\n                 AssertSharedLockAttr(S.Context, AL, StartArg, Size));\n}\n\nstatic void handleAssertExclusiveLockAttr(Sema &S, Decl *D,\n                                          const ParsedAttr &AL) {\n  SmallVector<Expr *, 1> Args;\n  if (!checkLockFunAttrCommon(S, D, AL, Args))\n    return;\n\n  unsigned Size = Args.size();\n  Expr **StartArg = Size == 0 ? nullptr : &Args[0];\n  D->addAttr(::new (S.Context)\n                 AssertExclusiveLockAttr(S.Context, AL, StartArg, Size));\n}\n\n/// Checks to be sure that the given parameter number is in bounds, and\n/// is an integral type. Will emit appropriate diagnostics if this returns\n/// false.\n///\n/// AttrArgNo is used to actually retrieve the argument, so it's base-0.\ntemplate <typename AttrInfo>\nstatic bool checkParamIsIntegerType(Sema &S, const FunctionDecl *FD,\n                                    const AttrInfo &AI, unsigned AttrArgNo) {\n  assert(AI.isArgExpr(AttrArgNo) && \"Expected expression argument\");\n  Expr *AttrArg = AI.getArgAsExpr(AttrArgNo);\n  ParamIdx Idx;\n  if (!checkFunctionOrMethodParameterIndex(S, FD, AI, AttrArgNo + 1, AttrArg,\n                                           Idx))\n    return false;\n\n  const ParmVarDecl *Param = FD->getParamDecl(Idx.getASTIndex());\n  if (!Param->getType()->isIntegerType() && !Param->getType()->isCharType()) {\n    SourceLocation SrcLoc = AttrArg->getBeginLoc();\n    S.Diag(SrcLoc, diag::err_attribute_integers_only)\n        << AI << Param->getSourceRange();\n    return false;\n  }\n  return true;\n}\n\nstatic void handleAllocSizeAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  if (!AL.checkAtLeastNumArgs(S, 1) || !AL.checkAtMostNumArgs(S, 2))\n    return;\n\n  const auto *FD = cast<FunctionDecl>(D);\n  if (!FD->getReturnType()->isPointerType()) {\n    S.Diag(AL.getLoc(), diag::warn_attribute_return_pointers_only) << AL;\n    return;\n  }\n\n  const Expr *SizeExpr = AL.getArgAsExpr(0);\n  int SizeArgNoVal;\n  // Parameter indices are 1-indexed, hence Index=1\n  if (!checkPositiveIntArgument(S, AL, SizeExpr, SizeArgNoVal, /*Idx=*/1))\n    return;\n  if (!checkParamIsIntegerType(S, FD, AL, /*AttrArgNo=*/0))\n    return;\n  ParamIdx SizeArgNo(SizeArgNoVal, D);\n\n  ParamIdx NumberArgNo;\n  if (AL.getNumArgs() == 2) {\n    const Expr *NumberExpr = AL.getArgAsExpr(1);\n    int Val;\n    // Parameter indices are 1-based, hence Index=2\n    if (!checkPositiveIntArgument(S, AL, NumberExpr, Val, /*Idx=*/2))\n      return;\n    if (!checkParamIsIntegerType(S, FD, AL, /*AttrArgNo=*/1))\n      return;\n    NumberArgNo = ParamIdx(Val, D);\n  }\n\n  D->addAttr(::new (S.Context)\n                 AllocSizeAttr(S.Context, AL, SizeArgNo, NumberArgNo));\n}\n\nstatic bool checkTryLockFunAttrCommon(Sema &S, Decl *D, const ParsedAttr &AL,\n                                      SmallVectorImpl<Expr *> &Args) {\n  if (!AL.checkAtLeastNumArgs(S, 1))\n    return false;\n\n  if (!isIntOrBool(AL.getArgAsExpr(0))) {\n    S.Diag(AL.getLoc(), diag::err_attribute_argument_n_type)\n        << AL << 1 << AANT_ArgumentIntOrBool;\n    return false;\n  }\n\n  // check that all arguments are lockable objects\n  checkAttrArgsAreCapabilityObjs(S, D, AL, Args, 1);\n\n  return true;\n}\n\nstatic void handleSharedTrylockFunctionAttr(Sema &S, Decl *D,\n                                            const ParsedAttr &AL) {\n  SmallVector<Expr*, 2> Args;\n  if (!checkTryLockFunAttrCommon(S, D, AL, Args))\n    return;\n\n  D->addAttr(::new (S.Context) SharedTrylockFunctionAttr(\n      S.Context, AL, AL.getArgAsExpr(0), Args.data(), Args.size()));\n}\n\nstatic void handleExclusiveTrylockFunctionAttr(Sema &S, Decl *D,\n                                               const ParsedAttr &AL) {\n  SmallVector<Expr*, 2> Args;\n  if (!checkTryLockFunAttrCommon(S, D, AL, Args))\n    return;\n\n  D->addAttr(::new (S.Context) ExclusiveTrylockFunctionAttr(\n      S.Context, AL, AL.getArgAsExpr(0), Args.data(), Args.size()));\n}\n\nstatic void handleLockReturnedAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  // check that the argument is lockable object\n  SmallVector<Expr*, 1> Args;\n  checkAttrArgsAreCapabilityObjs(S, D, AL, Args);\n  unsigned Size = Args.size();\n  if (Size == 0)\n    return;\n\n  D->addAttr(::new (S.Context) LockReturnedAttr(S.Context, AL, Args[0]));\n}\n\nstatic void handleLocksExcludedAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  if (!AL.checkAtLeastNumArgs(S, 1))\n    return;\n\n  // check that all arguments are lockable objects\n  SmallVector<Expr*, 1> Args;\n  checkAttrArgsAreCapabilityObjs(S, D, AL, Args);\n  unsigned Size = Args.size();\n  if (Size == 0)\n    return;\n  Expr **StartArg = &Args[0];\n\n  D->addAttr(::new (S.Context)\n                 LocksExcludedAttr(S.Context, AL, StartArg, Size));\n}\n\nstatic bool checkFunctionConditionAttr(Sema &S, Decl *D, const ParsedAttr &AL,\n                                       Expr *&Cond, StringRef &Msg) {\n  Cond = AL.getArgAsExpr(0);\n  if (!Cond->isTypeDependent()) {\n    ExprResult Converted = S.PerformContextuallyConvertToBool(Cond);\n    if (Converted.isInvalid())\n      return false;\n    Cond = Converted.get();\n  }\n\n  if (!S.checkStringLiteralArgumentAttr(AL, 1, Msg))\n    return false;\n\n  if (Msg.empty())\n    Msg = \"<no message provided>\";\n\n  SmallVector<PartialDiagnosticAt, 8> Diags;\n  if (isa<FunctionDecl>(D) && !Cond->isValueDependent() &&\n      !Expr::isPotentialConstantExprUnevaluated(Cond, cast<FunctionDecl>(D),\n                                                Diags)) {\n    S.Diag(AL.getLoc(), diag::err_attr_cond_never_constant_expr) << AL;\n    for (const PartialDiagnosticAt &PDiag : Diags)\n      S.Diag(PDiag.first, PDiag.second);\n    return false;\n  }\n  return true;\n}\n\nstatic void handleEnableIfAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  S.Diag(AL.getLoc(), diag::ext_clang_enable_if);\n\n  Expr *Cond;\n  StringRef Msg;\n  if (checkFunctionConditionAttr(S, D, AL, Cond, Msg))\n    D->addAttr(::new (S.Context) EnableIfAttr(S.Context, AL, Cond, Msg));\n}\n\nnamespace {\n/// Determines if a given Expr references any of the given function's\n/// ParmVarDecls, or the function's implicit `this` parameter (if applicable).\nclass ArgumentDependenceChecker\n    : public RecursiveASTVisitor<ArgumentDependenceChecker> {\n#ifndef NDEBUG\n  const CXXRecordDecl *ClassType;\n#endif\n  llvm::SmallPtrSet<const ParmVarDecl *, 16> Parms;\n  bool Result;\n\npublic:\n  ArgumentDependenceChecker(const FunctionDecl *FD) {\n#ifndef NDEBUG\n    if (const auto *MD = dyn_cast<CXXMethodDecl>(FD))\n      ClassType = MD->getParent();\n    else\n      ClassType = nullptr;\n#endif\n    Parms.insert(FD->param_begin(), FD->param_end());\n  }\n\n  bool referencesArgs(Expr *E) {\n    Result = false;\n    TraverseStmt(E);\n    return Result;\n  }\n\n  bool VisitCXXThisExpr(CXXThisExpr *E) {\n    assert(E->getType()->getPointeeCXXRecordDecl() == ClassType &&\n           \"`this` doesn't refer to the enclosing class?\");\n    Result = true;\n    return false;\n  }\n\n  bool VisitDeclRefExpr(DeclRefExpr *DRE) {\n    if (const auto *PVD = dyn_cast<ParmVarDecl>(DRE->getDecl()))\n      if (Parms.count(PVD)) {\n        Result = true;\n        return false;\n      }\n    return true;\n  }\n};\n}\n\nstatic void handleDiagnoseIfAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  S.Diag(AL.getLoc(), diag::ext_clang_diagnose_if);\n\n  Expr *Cond;\n  StringRef Msg;\n  if (!checkFunctionConditionAttr(S, D, AL, Cond, Msg))\n    return;\n\n  StringRef DiagTypeStr;\n  if (!S.checkStringLiteralArgumentAttr(AL, 2, DiagTypeStr))\n    return;\n\n  DiagnoseIfAttr::DiagnosticType DiagType;\n  if (!DiagnoseIfAttr::ConvertStrToDiagnosticType(DiagTypeStr, DiagType)) {\n    S.Diag(AL.getArgAsExpr(2)->getBeginLoc(),\n           diag::err_diagnose_if_invalid_diagnostic_type);\n    return;\n  }\n\n  bool ArgDependent = false;\n  if (const auto *FD = dyn_cast<FunctionDecl>(D))\n    ArgDependent = ArgumentDependenceChecker(FD).referencesArgs(Cond);\n  D->addAttr(::new (S.Context) DiagnoseIfAttr(\n      S.Context, AL, Cond, Msg, DiagType, ArgDependent, cast<NamedDecl>(D)));\n}\n\nstatic void handleNoBuiltinAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  static constexpr const StringRef kWildcard = \"*\";\n\n  llvm::SmallVector<StringRef, 16> Names;\n  bool HasWildcard = false;\n\n  const auto AddBuiltinName = [&Names, &HasWildcard](StringRef Name) {\n    if (Name == kWildcard)\n      HasWildcard = true;\n    Names.push_back(Name);\n  };\n\n  // Add previously defined attributes.\n  if (const auto *NBA = D->getAttr<NoBuiltinAttr>())\n    for (StringRef BuiltinName : NBA->builtinNames())\n      AddBuiltinName(BuiltinName);\n\n  // Add current attributes.\n  if (AL.getNumArgs() == 0)\n    AddBuiltinName(kWildcard);\n  else\n    for (unsigned I = 0, E = AL.getNumArgs(); I != E; ++I) {\n      StringRef BuiltinName;\n      SourceLocation LiteralLoc;\n      if (!S.checkStringLiteralArgumentAttr(AL, I, BuiltinName, &LiteralLoc))\n        return;\n\n      if (Builtin::Context::isBuiltinFunc(BuiltinName))\n        AddBuiltinName(BuiltinName);\n      else\n        S.Diag(LiteralLoc, diag::warn_attribute_no_builtin_invalid_builtin_name)\n            << BuiltinName << AL;\n    }\n\n  // Repeating the same attribute is fine.\n  llvm::sort(Names);\n  Names.erase(std::unique(Names.begin(), Names.end()), Names.end());\n\n  // Empty no_builtin must be on its own.\n  if (HasWildcard && Names.size() > 1)\n    S.Diag(D->getLocation(),\n           diag::err_attribute_no_builtin_wildcard_or_builtin_name)\n        << AL;\n\n  if (D->hasAttr<NoBuiltinAttr>())\n    D->dropAttr<NoBuiltinAttr>();\n  D->addAttr(::new (S.Context)\n                 NoBuiltinAttr(S.Context, AL, Names.data(), Names.size()));\n}\n\nstatic void handlePassObjectSizeAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  if (D->hasAttr<PassObjectSizeAttr>()) {\n    S.Diag(D->getBeginLoc(), diag::err_attribute_only_once_per_parameter) << AL;\n    return;\n  }\n\n  Expr *E = AL.getArgAsExpr(0);\n  uint32_t Type;\n  if (!checkUInt32Argument(S, AL, E, Type, /*Idx=*/1))\n    return;\n\n  // pass_object_size's argument is passed in as the second argument of\n  // __builtin_object_size. So, it has the same constraints as that second\n  // argument; namely, it must be in the range [0, 3].\n  if (Type > 3) {\n    S.Diag(E->getBeginLoc(), diag::err_attribute_argument_out_of_range)\n        << AL << 0 << 3 << E->getSourceRange();\n    return;\n  }\n\n  // pass_object_size is only supported on constant pointer parameters; as a\n  // kindness to users, we allow the parameter to be non-const for declarations.\n  // At this point, we have no clue if `D` belongs to a function declaration or\n  // definition, so we defer the constness check until later.\n  if (!cast<ParmVarDecl>(D)->getType()->isPointerType()) {\n    S.Diag(D->getBeginLoc(), diag::err_attribute_pointers_only) << AL << 1;\n    return;\n  }\n\n  D->addAttr(::new (S.Context) PassObjectSizeAttr(S.Context, AL, (int)Type));\n}\n\nstatic void handleConsumableAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  ConsumableAttr::ConsumedState DefaultState;\n\n  if (AL.isArgIdent(0)) {\n    IdentifierLoc *IL = AL.getArgAsIdent(0);\n    if (!ConsumableAttr::ConvertStrToConsumedState(IL->Ident->getName(),\n                                                   DefaultState)) {\n      S.Diag(IL->Loc, diag::warn_attribute_type_not_supported) << AL\n                                                               << IL->Ident;\n      return;\n    }\n  } else {\n    S.Diag(AL.getLoc(), diag::err_attribute_argument_type)\n        << AL << AANT_ArgumentIdentifier;\n    return;\n  }\n\n  D->addAttr(::new (S.Context) ConsumableAttr(S.Context, AL, DefaultState));\n}\n\nstatic bool checkForConsumableClass(Sema &S, const CXXMethodDecl *MD,\n                                    const ParsedAttr &AL) {\n  QualType ThisType = MD->getThisType()->getPointeeType();\n\n  if (const CXXRecordDecl *RD = ThisType->getAsCXXRecordDecl()) {\n    if (!RD->hasAttr<ConsumableAttr>()) {\n      S.Diag(AL.getLoc(), diag::warn_attr_on_unconsumable_class) << RD;\n\n      return false;\n    }\n  }\n\n  return true;\n}\n\nstatic void handleCallableWhenAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  if (!AL.checkAtLeastNumArgs(S, 1))\n    return;\n\n  if (!checkForConsumableClass(S, cast<CXXMethodDecl>(D), AL))\n    return;\n\n  SmallVector<CallableWhenAttr::ConsumedState, 3> States;\n  for (unsigned ArgIndex = 0; ArgIndex < AL.getNumArgs(); ++ArgIndex) {\n    CallableWhenAttr::ConsumedState CallableState;\n\n    StringRef StateString;\n    SourceLocation Loc;\n    if (AL.isArgIdent(ArgIndex)) {\n      IdentifierLoc *Ident = AL.getArgAsIdent(ArgIndex);\n      StateString = Ident->Ident->getName();\n      Loc = Ident->Loc;\n    } else {\n      if (!S.checkStringLiteralArgumentAttr(AL, ArgIndex, StateString, &Loc))\n        return;\n    }\n\n    if (!CallableWhenAttr::ConvertStrToConsumedState(StateString,\n                                                     CallableState)) {\n      S.Diag(Loc, diag::warn_attribute_type_not_supported) << AL << StateString;\n      return;\n    }\n\n    States.push_back(CallableState);\n  }\n\n  D->addAttr(::new (S.Context)\n                 CallableWhenAttr(S.Context, AL, States.data(), States.size()));\n}\n\nstatic void handleParamTypestateAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  ParamTypestateAttr::ConsumedState ParamState;\n\n  if (AL.isArgIdent(0)) {\n    IdentifierLoc *Ident = AL.getArgAsIdent(0);\n    StringRef StateString = Ident->Ident->getName();\n\n    if (!ParamTypestateAttr::ConvertStrToConsumedState(StateString,\n                                                       ParamState)) {\n      S.Diag(Ident->Loc, diag::warn_attribute_type_not_supported)\n          << AL << StateString;\n      return;\n    }\n  } else {\n    S.Diag(AL.getLoc(), diag::err_attribute_argument_type)\n        << AL << AANT_ArgumentIdentifier;\n    return;\n  }\n\n  // FIXME: This check is currently being done in the analysis.  It can be\n  //        enabled here only after the parser propagates attributes at\n  //        template specialization definition, not declaration.\n  //QualType ReturnType = cast<ParmVarDecl>(D)->getType();\n  //const CXXRecordDecl *RD = ReturnType->getAsCXXRecordDecl();\n  //\n  //if (!RD || !RD->hasAttr<ConsumableAttr>()) {\n  //    S.Diag(AL.getLoc(), diag::warn_return_state_for_unconsumable_type) <<\n  //      ReturnType.getAsString();\n  //    return;\n  //}\n\n  D->addAttr(::new (S.Context) ParamTypestateAttr(S.Context, AL, ParamState));\n}\n\nstatic void handleReturnTypestateAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  ReturnTypestateAttr::ConsumedState ReturnState;\n\n  if (AL.isArgIdent(0)) {\n    IdentifierLoc *IL = AL.getArgAsIdent(0);\n    if (!ReturnTypestateAttr::ConvertStrToConsumedState(IL->Ident->getName(),\n                                                        ReturnState)) {\n      S.Diag(IL->Loc, diag::warn_attribute_type_not_supported) << AL\n                                                               << IL->Ident;\n      return;\n    }\n  } else {\n    S.Diag(AL.getLoc(), diag::err_attribute_argument_type)\n        << AL << AANT_ArgumentIdentifier;\n    return;\n  }\n\n  // FIXME: This check is currently being done in the analysis.  It can be\n  //        enabled here only after the parser propagates attributes at\n  //        template specialization definition, not declaration.\n  //QualType ReturnType;\n  //\n  //if (const ParmVarDecl *Param = dyn_cast<ParmVarDecl>(D)) {\n  //  ReturnType = Param->getType();\n  //\n  //} else if (const CXXConstructorDecl *Constructor =\n  //             dyn_cast<CXXConstructorDecl>(D)) {\n  //  ReturnType = Constructor->getThisType()->getPointeeType();\n  //\n  //} else {\n  //\n  //  ReturnType = cast<FunctionDecl>(D)->getCallResultType();\n  //}\n  //\n  //const CXXRecordDecl *RD = ReturnType->getAsCXXRecordDecl();\n  //\n  //if (!RD || !RD->hasAttr<ConsumableAttr>()) {\n  //    S.Diag(Attr.getLoc(), diag::warn_return_state_for_unconsumable_type) <<\n  //      ReturnType.getAsString();\n  //    return;\n  //}\n\n  D->addAttr(::new (S.Context) ReturnTypestateAttr(S.Context, AL, ReturnState));\n}\n\nstatic void handleSetTypestateAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  if (!checkForConsumableClass(S, cast<CXXMethodDecl>(D), AL))\n    return;\n\n  SetTypestateAttr::ConsumedState NewState;\n  if (AL.isArgIdent(0)) {\n    IdentifierLoc *Ident = AL.getArgAsIdent(0);\n    StringRef Param = Ident->Ident->getName();\n    if (!SetTypestateAttr::ConvertStrToConsumedState(Param, NewState)) {\n      S.Diag(Ident->Loc, diag::warn_attribute_type_not_supported) << AL\n                                                                  << Param;\n      return;\n    }\n  } else {\n    S.Diag(AL.getLoc(), diag::err_attribute_argument_type)\n        << AL << AANT_ArgumentIdentifier;\n    return;\n  }\n\n  D->addAttr(::new (S.Context) SetTypestateAttr(S.Context, AL, NewState));\n}\n\nstatic void handleTestTypestateAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  if (!checkForConsumableClass(S, cast<CXXMethodDecl>(D), AL))\n    return;\n\n  TestTypestateAttr::ConsumedState TestState;\n  if (AL.isArgIdent(0)) {\n    IdentifierLoc *Ident = AL.getArgAsIdent(0);\n    StringRef Param = Ident->Ident->getName();\n    if (!TestTypestateAttr::ConvertStrToConsumedState(Param, TestState)) {\n      S.Diag(Ident->Loc, diag::warn_attribute_type_not_supported) << AL\n                                                                  << Param;\n      return;\n    }\n  } else {\n    S.Diag(AL.getLoc(), diag::err_attribute_argument_type)\n        << AL << AANT_ArgumentIdentifier;\n    return;\n  }\n\n  D->addAttr(::new (S.Context) TestTypestateAttr(S.Context, AL, TestState));\n}\n\nstatic void handleExtVectorTypeAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  // Remember this typedef decl, we will need it later for diagnostics.\n  S.ExtVectorDecls.push_back(cast<TypedefNameDecl>(D));\n}\n\nstatic void handlePackedAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  if (auto *TD = dyn_cast<TagDecl>(D))\n    TD->addAttr(::new (S.Context) PackedAttr(S.Context, AL));\n  else if (auto *FD = dyn_cast<FieldDecl>(D)) {\n    bool BitfieldByteAligned = (!FD->getType()->isDependentType() &&\n                                !FD->getType()->isIncompleteType() &&\n                                FD->isBitField() &&\n                                S.Context.getTypeAlign(FD->getType()) <= 8);\n\n    if (S.getASTContext().getTargetInfo().getTriple().isPS4()) {\n      if (BitfieldByteAligned)\n        // The PS4 target needs to maintain ABI backwards compatibility.\n        S.Diag(AL.getLoc(), diag::warn_attribute_ignored_for_field_of_type)\n            << AL << FD->getType();\n      else\n        FD->addAttr(::new (S.Context) PackedAttr(S.Context, AL));\n    } else {\n      // Report warning about changed offset in the newer compiler versions.\n      if (BitfieldByteAligned)\n        S.Diag(AL.getLoc(), diag::warn_attribute_packed_for_bitfield);\n\n      FD->addAttr(::new (S.Context) PackedAttr(S.Context, AL));\n    }\n\n  } else\n    S.Diag(AL.getLoc(), diag::warn_attribute_ignored) << AL;\n}\n\nstatic void handlePreferredName(Sema &S, Decl *D, const ParsedAttr &AL) {\n  auto *RD = cast<CXXRecordDecl>(D);\n  ClassTemplateDecl *CTD = RD->getDescribedClassTemplate();\n  assert(CTD && \"attribute does not appertain to this declaration\");\n\n  ParsedType PT = AL.getTypeArg();\n  TypeSourceInfo *TSI = nullptr;\n  QualType T = S.GetTypeFromParser(PT, &TSI);\n  if (!TSI)\n    TSI = S.Context.getTrivialTypeSourceInfo(T, AL.getLoc());\n\n  if (!T.hasQualifiers() && T->isTypedefNameType()) {\n    // Find the template name, if this type names a template specialization.\n    const TemplateDecl *Template = nullptr;\n    if (const auto *CTSD = dyn_cast_or_null<ClassTemplateSpecializationDecl>(\n            T->getAsCXXRecordDecl())) {\n      Template = CTSD->getSpecializedTemplate();\n    } else if (const auto *TST = T->getAs<TemplateSpecializationType>()) {\n      while (TST && TST->isTypeAlias())\n        TST = TST->getAliasedType()->getAs<TemplateSpecializationType>();\n      if (TST)\n        Template = TST->getTemplateName().getAsTemplateDecl();\n    }\n\n    if (Template && declaresSameEntity(Template, CTD)) {\n      D->addAttr(::new (S.Context) PreferredNameAttr(S.Context, AL, TSI));\n      return;\n    }\n  }\n\n  S.Diag(AL.getLoc(), diag::err_attribute_preferred_name_arg_invalid)\n      << T << CTD;\n  if (const auto *TT = T->getAs<TypedefType>())\n    S.Diag(TT->getDecl()->getLocation(), diag::note_entity_declared_at)\n        << TT->getDecl();\n}\n\nstatic bool checkIBOutletCommon(Sema &S, Decl *D, const ParsedAttr &AL) {\n  // The IBOutlet/IBOutletCollection attributes only apply to instance\n  // variables or properties of Objective-C classes.  The outlet must also\n  // have an object reference type.\n  if (const auto *VD = dyn_cast<ObjCIvarDecl>(D)) {\n    if (!VD->getType()->getAs<ObjCObjectPointerType>()) {\n      S.Diag(AL.getLoc(), diag::warn_iboutlet_object_type)\n          << AL << VD->getType() << 0;\n      return false;\n    }\n  }\n  else if (const auto *PD = dyn_cast<ObjCPropertyDecl>(D)) {\n    if (!PD->getType()->getAs<ObjCObjectPointerType>()) {\n      S.Diag(AL.getLoc(), diag::warn_iboutlet_object_type)\n          << AL << PD->getType() << 1;\n      return false;\n    }\n  }\n  else {\n    S.Diag(AL.getLoc(), diag::warn_attribute_iboutlet) << AL;\n    return false;\n  }\n\n  return true;\n}\n\nstatic void handleIBOutlet(Sema &S, Decl *D, const ParsedAttr &AL) {\n  if (!checkIBOutletCommon(S, D, AL))\n    return;\n\n  D->addAttr(::new (S.Context) IBOutletAttr(S.Context, AL));\n}\n\nstatic void handleIBOutletCollection(Sema &S, Decl *D, const ParsedAttr &AL) {\n\n  // The iboutletcollection attribute can have zero or one arguments.\n  if (AL.getNumArgs() > 1) {\n    S.Diag(AL.getLoc(), diag::err_attribute_wrong_number_arguments) << AL << 1;\n    return;\n  }\n\n  if (!checkIBOutletCommon(S, D, AL))\n    return;\n\n  ParsedType PT;\n\n  if (AL.hasParsedType())\n    PT = AL.getTypeArg();\n  else {\n    PT = S.getTypeName(S.Context.Idents.get(\"NSObject\"), AL.getLoc(),\n                       S.getScopeForContext(D->getDeclContext()->getParent()));\n    if (!PT) {\n      S.Diag(AL.getLoc(), diag::err_iboutletcollection_type) << \"NSObject\";\n      return;\n    }\n  }\n\n  TypeSourceInfo *QTLoc = nullptr;\n  QualType QT = S.GetTypeFromParser(PT, &QTLoc);\n  if (!QTLoc)\n    QTLoc = S.Context.getTrivialTypeSourceInfo(QT, AL.getLoc());\n\n  // Diagnose use of non-object type in iboutletcollection attribute.\n  // FIXME. Gnu attribute extension ignores use of builtin types in\n  // attributes. So, __attribute__((iboutletcollection(char))) will be\n  // treated as __attribute__((iboutletcollection())).\n  if (!QT->isObjCIdType() && !QT->isObjCObjectType()) {\n    S.Diag(AL.getLoc(),\n           QT->isBuiltinType() ? diag::err_iboutletcollection_builtintype\n                               : diag::err_iboutletcollection_type) << QT;\n    return;\n  }\n\n  D->addAttr(::new (S.Context) IBOutletCollectionAttr(S.Context, AL, QTLoc));\n}\n\nbool Sema::isValidPointerAttrType(QualType T, bool RefOkay) {\n  if (RefOkay) {\n    if (T->isReferenceType())\n      return true;\n  } else {\n    T = T.getNonReferenceType();\n  }\n\n  // The nonnull attribute, and other similar attributes, can be applied to a\n  // transparent union that contains a pointer type.\n  if (const RecordType *UT = T->getAsUnionType()) {\n    if (UT && UT->getDecl()->hasAttr<TransparentUnionAttr>()) {\n      RecordDecl *UD = UT->getDecl();\n      for (const auto *I : UD->fields()) {\n        QualType QT = I->getType();\n        if (QT->isAnyPointerType() || QT->isBlockPointerType())\n          return true;\n      }\n    }\n  }\n\n  return T->isAnyPointerType() || T->isBlockPointerType();\n}\n\nstatic bool attrNonNullArgCheck(Sema &S, QualType T, const ParsedAttr &AL,\n                                SourceRange AttrParmRange,\n                                SourceRange TypeRange,\n                                bool isReturnValue = false) {\n  if (!S.isValidPointerAttrType(T)) {\n    if (isReturnValue)\n      S.Diag(AL.getLoc(), diag::warn_attribute_return_pointers_only)\n          << AL << AttrParmRange << TypeRange;\n    else\n      S.Diag(AL.getLoc(), diag::warn_attribute_pointers_only)\n          << AL << AttrParmRange << TypeRange << 0;\n    return false;\n  }\n  return true;\n}\n\nstatic void handleNonNullAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  SmallVector<ParamIdx, 8> NonNullArgs;\n  for (unsigned I = 0; I < AL.getNumArgs(); ++I) {\n    Expr *Ex = AL.getArgAsExpr(I);\n    ParamIdx Idx;\n    if (!checkFunctionOrMethodParameterIndex(S, D, AL, I + 1, Ex, Idx))\n      return;\n\n    // Is the function argument a pointer type?\n    if (Idx.getASTIndex() < getFunctionOrMethodNumParams(D) &&\n        !attrNonNullArgCheck(\n            S, getFunctionOrMethodParamType(D, Idx.getASTIndex()), AL,\n            Ex->getSourceRange(),\n            getFunctionOrMethodParamRange(D, Idx.getASTIndex())))\n      continue;\n\n    NonNullArgs.push_back(Idx);\n  }\n\n  // If no arguments were specified to __attribute__((nonnull)) then all pointer\n  // arguments have a nonnull attribute; warn if there aren't any. Skip this\n  // check if the attribute came from a macro expansion or a template\n  // instantiation.\n  if (NonNullArgs.empty() && AL.getLoc().isFileID() &&\n      !S.inTemplateInstantiation()) {\n    bool AnyPointers = isFunctionOrMethodVariadic(D);\n    for (unsigned I = 0, E = getFunctionOrMethodNumParams(D);\n         I != E && !AnyPointers; ++I) {\n      QualType T = getFunctionOrMethodParamType(D, I);\n      if (T->isDependentType() || S.isValidPointerAttrType(T))\n        AnyPointers = true;\n    }\n\n    if (!AnyPointers)\n      S.Diag(AL.getLoc(), diag::warn_attribute_nonnull_no_pointers);\n  }\n\n  ParamIdx *Start = NonNullArgs.data();\n  unsigned Size = NonNullArgs.size();\n  llvm::array_pod_sort(Start, Start + Size);\n  D->addAttr(::new (S.Context) NonNullAttr(S.Context, AL, Start, Size));\n}\n\nstatic void handleNonNullAttrParameter(Sema &S, ParmVarDecl *D,\n                                       const ParsedAttr &AL) {\n  if (AL.getNumArgs() > 0) {\n    if (D->getFunctionType()) {\n      handleNonNullAttr(S, D, AL);\n    } else {\n      S.Diag(AL.getLoc(), diag::warn_attribute_nonnull_parm_no_args)\n        << D->getSourceRange();\n    }\n    return;\n  }\n\n  // Is the argument a pointer type?\n  if (!attrNonNullArgCheck(S, D->getType(), AL, SourceRange(),\n                           D->getSourceRange()))\n    return;\n\n  D->addAttr(::new (S.Context) NonNullAttr(S.Context, AL, nullptr, 0));\n}\n\nstatic void handleReturnsNonNullAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  QualType ResultType = getFunctionOrMethodResultType(D);\n  SourceRange SR = getFunctionOrMethodResultSourceRange(D);\n  if (!attrNonNullArgCheck(S, ResultType, AL, SourceRange(), SR,\n                           /* isReturnValue */ true))\n    return;\n\n  D->addAttr(::new (S.Context) ReturnsNonNullAttr(S.Context, AL));\n}\n\nstatic void handleNoEscapeAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  if (D->isInvalidDecl())\n    return;\n\n  // noescape only applies to pointer types.\n  QualType T = cast<ParmVarDecl>(D)->getType();\n  if (!S.isValidPointerAttrType(T, /* RefOkay */ true)) {\n    S.Diag(AL.getLoc(), diag::warn_attribute_pointers_only)\n        << AL << AL.getRange() << 0;\n    return;\n  }\n\n  D->addAttr(::new (S.Context) NoEscapeAttr(S.Context, AL));\n}\n\nstatic void handleAssumeAlignedAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  Expr *E = AL.getArgAsExpr(0),\n       *OE = AL.getNumArgs() > 1 ? AL.getArgAsExpr(1) : nullptr;\n  S.AddAssumeAlignedAttr(D, AL, E, OE);\n}\n\nstatic void handleAllocAlignAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  S.AddAllocAlignAttr(D, AL, AL.getArgAsExpr(0));\n}\n\nvoid Sema::AddAssumeAlignedAttr(Decl *D, const AttributeCommonInfo &CI, Expr *E,\n                                Expr *OE) {\n  QualType ResultType = getFunctionOrMethodResultType(D);\n  SourceRange SR = getFunctionOrMethodResultSourceRange(D);\n\n  AssumeAlignedAttr TmpAttr(Context, CI, E, OE);\n  SourceLocation AttrLoc = TmpAttr.getLocation();\n\n  if (!isValidPointerAttrType(ResultType, /* RefOkay */ true)) {\n    Diag(AttrLoc, diag::warn_attribute_return_pointers_refs_only)\n        << &TmpAttr << TmpAttr.getRange() << SR;\n    return;\n  }\n\n  if (!E->isValueDependent()) {\n    Optional<llvm::APSInt> I = llvm::APSInt(64);\n    if (!(I = E->getIntegerConstantExpr(Context))) {\n      if (OE)\n        Diag(AttrLoc, diag::err_attribute_argument_n_type)\n          << &TmpAttr << 1 << AANT_ArgumentIntegerConstant\n          << E->getSourceRange();\n      else\n        Diag(AttrLoc, diag::err_attribute_argument_type)\n          << &TmpAttr << AANT_ArgumentIntegerConstant\n          << E->getSourceRange();\n      return;\n    }\n\n    if (!I->isPowerOf2()) {\n      Diag(AttrLoc, diag::err_alignment_not_power_of_two)\n        << E->getSourceRange();\n      return;\n    }\n\n    if (*I > Sema::MaximumAlignment)\n      Diag(CI.getLoc(), diag::warn_assume_aligned_too_great)\n          << CI.getRange() << Sema::MaximumAlignment;\n  }\n\n  if (OE && !OE->isValueDependent() && !OE->isIntegerConstantExpr(Context)) {\n    Diag(AttrLoc, diag::err_attribute_argument_n_type)\n        << &TmpAttr << 2 << AANT_ArgumentIntegerConstant\n        << OE->getSourceRange();\n    return;\n  }\n\n  D->addAttr(::new (Context) AssumeAlignedAttr(Context, CI, E, OE));\n}\n\nvoid Sema::AddAllocAlignAttr(Decl *D, const AttributeCommonInfo &CI,\n                             Expr *ParamExpr) {\n  QualType ResultType = getFunctionOrMethodResultType(D);\n\n  AllocAlignAttr TmpAttr(Context, CI, ParamIdx());\n  SourceLocation AttrLoc = CI.getLoc();\n\n  if (!ResultType->isDependentType() &&\n      !isValidPointerAttrType(ResultType, /* RefOkay */ true)) {\n    Diag(AttrLoc, diag::warn_attribute_return_pointers_refs_only)\n        << &TmpAttr << CI.getRange() << getFunctionOrMethodResultSourceRange(D);\n    return;\n  }\n\n  ParamIdx Idx;\n  const auto *FuncDecl = cast<FunctionDecl>(D);\n  if (!checkFunctionOrMethodParameterIndex(*this, FuncDecl, TmpAttr,\n                                           /*AttrArgNum=*/1, ParamExpr, Idx))\n    return;\n\n  QualType Ty = getFunctionOrMethodParamType(D, Idx.getASTIndex());\n  if (!Ty->isDependentType() && !Ty->isIntegralType(Context) &&\n      !Ty->isAlignValT()) {\n    Diag(ParamExpr->getBeginLoc(), diag::err_attribute_integers_only)\n        << &TmpAttr\n        << FuncDecl->getParamDecl(Idx.getASTIndex())->getSourceRange();\n    return;\n  }\n\n  D->addAttr(::new (Context) AllocAlignAttr(Context, CI, Idx));\n}\n\n/// Check if \\p AssumptionStr is a known assumption and warn if not.\nstatic void checkAssumptionAttr(Sema &S, SourceLocation Loc,\n                                StringRef AssumptionStr) {\n  if (llvm::KnownAssumptionStrings.count(AssumptionStr))\n    return;\n\n  unsigned BestEditDistance = 3;\n  StringRef Suggestion;\n  for (const auto &KnownAssumptionIt : llvm::KnownAssumptionStrings) {\n    unsigned EditDistance =\n        AssumptionStr.edit_distance(KnownAssumptionIt.getKey());\n    if (EditDistance < BestEditDistance) {\n      Suggestion = KnownAssumptionIt.getKey();\n      BestEditDistance = EditDistance;\n    }\n  }\n\n  if (!Suggestion.empty())\n    S.Diag(Loc, diag::warn_assume_attribute_string_unknown_suggested)\n        << AssumptionStr << Suggestion;\n  else\n    S.Diag(Loc, diag::warn_assume_attribute_string_unknown) << AssumptionStr;\n}\n\nstatic void handleAssumumptionAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  // Handle the case where the attribute has a text message.\n  StringRef Str;\n  SourceLocation AttrStrLoc;\n  if (!S.checkStringLiteralArgumentAttr(AL, 0, Str, &AttrStrLoc))\n    return;\n\n  checkAssumptionAttr(S, AttrStrLoc, Str);\n\n  D->addAttr(::new (S.Context) AssumptionAttr(S.Context, AL, Str));\n}\n\n/// Normalize the attribute, __foo__ becomes foo.\n/// Returns true if normalization was applied.\nstatic bool normalizeName(StringRef &AttrName) {\n  if (AttrName.size() > 4 && AttrName.startswith(\"__\") &&\n      AttrName.endswith(\"__\")) {\n    AttrName = AttrName.drop_front(2).drop_back(2);\n    return true;\n  }\n  return false;\n}\n\nstatic void handleOwnershipAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  // This attribute must be applied to a function declaration. The first\n  // argument to the attribute must be an identifier, the name of the resource,\n  // for example: malloc. The following arguments must be argument indexes, the\n  // arguments must be of integer type for Returns, otherwise of pointer type.\n  // The difference between Holds and Takes is that a pointer may still be used\n  // after being held. free() should be __attribute((ownership_takes)), whereas\n  // a list append function may well be __attribute((ownership_holds)).\n\n  if (!AL.isArgIdent(0)) {\n    S.Diag(AL.getLoc(), diag::err_attribute_argument_n_type)\n        << AL << 1 << AANT_ArgumentIdentifier;\n    return;\n  }\n\n  // Figure out our Kind.\n  OwnershipAttr::OwnershipKind K =\n      OwnershipAttr(S.Context, AL, nullptr, nullptr, 0).getOwnKind();\n\n  // Check arguments.\n  switch (K) {\n  case OwnershipAttr::Takes:\n  case OwnershipAttr::Holds:\n    if (AL.getNumArgs() < 2) {\n      S.Diag(AL.getLoc(), diag::err_attribute_too_few_arguments) << AL << 2;\n      return;\n    }\n    break;\n  case OwnershipAttr::Returns:\n    if (AL.getNumArgs() > 2) {\n      S.Diag(AL.getLoc(), diag::err_attribute_too_many_arguments) << AL << 1;\n      return;\n    }\n    break;\n  }\n\n  IdentifierInfo *Module = AL.getArgAsIdent(0)->Ident;\n\n  StringRef ModuleName = Module->getName();\n  if (normalizeName(ModuleName)) {\n    Module = &S.PP.getIdentifierTable().get(ModuleName);\n  }\n\n  SmallVector<ParamIdx, 8> OwnershipArgs;\n  for (unsigned i = 1; i < AL.getNumArgs(); ++i) {\n    Expr *Ex = AL.getArgAsExpr(i);\n    ParamIdx Idx;\n    if (!checkFunctionOrMethodParameterIndex(S, D, AL, i, Ex, Idx))\n      return;\n\n    // Is the function argument a pointer type?\n    QualType T = getFunctionOrMethodParamType(D, Idx.getASTIndex());\n    int Err = -1;  // No error\n    switch (K) {\n      case OwnershipAttr::Takes:\n      case OwnershipAttr::Holds:\n        if (!T->isAnyPointerType() && !T->isBlockPointerType())\n          Err = 0;\n        break;\n      case OwnershipAttr::Returns:\n        if (!T->isIntegerType())\n          Err = 1;\n        break;\n    }\n    if (-1 != Err) {\n      S.Diag(AL.getLoc(), diag::err_ownership_type) << AL << Err\n                                                    << Ex->getSourceRange();\n      return;\n    }\n\n    // Check we don't have a conflict with another ownership attribute.\n    for (const auto *I : D->specific_attrs<OwnershipAttr>()) {\n      // Cannot have two ownership attributes of different kinds for the same\n      // index.\n      if (I->getOwnKind() != K && I->args_end() !=\n          std::find(I->args_begin(), I->args_end(), Idx)) {\n        S.Diag(AL.getLoc(), diag::err_attributes_are_not_compatible) << AL << I;\n        return;\n      } else if (K == OwnershipAttr::Returns &&\n                 I->getOwnKind() == OwnershipAttr::Returns) {\n        // A returns attribute conflicts with any other returns attribute using\n        // a different index.\n        if (std::find(I->args_begin(), I->args_end(), Idx) == I->args_end()) {\n          S.Diag(I->getLocation(), diag::err_ownership_returns_index_mismatch)\n              << I->args_begin()->getSourceIndex();\n          if (I->args_size())\n            S.Diag(AL.getLoc(), diag::note_ownership_returns_index_mismatch)\n                << Idx.getSourceIndex() << Ex->getSourceRange();\n          return;\n        }\n      }\n    }\n    OwnershipArgs.push_back(Idx);\n  }\n\n  ParamIdx *Start = OwnershipArgs.data();\n  unsigned Size = OwnershipArgs.size();\n  llvm::array_pod_sort(Start, Start + Size);\n  D->addAttr(::new (S.Context)\n                 OwnershipAttr(S.Context, AL, Module, Start, Size));\n}\n\nstatic void handleWeakRefAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  // Check the attribute arguments.\n  if (AL.getNumArgs() > 1) {\n    S.Diag(AL.getLoc(), diag::err_attribute_wrong_number_arguments) << AL << 1;\n    return;\n  }\n\n  // gcc rejects\n  // class c {\n  //   static int a __attribute__((weakref (\"v2\")));\n  //   static int b() __attribute__((weakref (\"f3\")));\n  // };\n  // and ignores the attributes of\n  // void f(void) {\n  //   static int a __attribute__((weakref (\"v2\")));\n  // }\n  // we reject them\n  const DeclContext *Ctx = D->getDeclContext()->getRedeclContext();\n  if (!Ctx->isFileContext()) {\n    S.Diag(AL.getLoc(), diag::err_attribute_weakref_not_global_context)\n        << cast<NamedDecl>(D);\n    return;\n  }\n\n  // The GCC manual says\n  //\n  // At present, a declaration to which `weakref' is attached can only\n  // be `static'.\n  //\n  // It also says\n  //\n  // Without a TARGET,\n  // given as an argument to `weakref' or to `alias', `weakref' is\n  // equivalent to `weak'.\n  //\n  // gcc 4.4.1 will accept\n  // int a7 __attribute__((weakref));\n  // as\n  // int a7 __attribute__((weak));\n  // This looks like a bug in gcc. We reject that for now. We should revisit\n  // it if this behaviour is actually used.\n\n  // GCC rejects\n  // static ((alias (\"y\"), weakref)).\n  // Should we? How to check that weakref is before or after alias?\n\n  // FIXME: it would be good for us to keep the WeakRefAttr as-written instead\n  // of transforming it into an AliasAttr.  The WeakRefAttr never uses the\n  // StringRef parameter it was given anyway.\n  StringRef Str;\n  if (AL.getNumArgs() && S.checkStringLiteralArgumentAttr(AL, 0, Str))\n    // GCC will accept anything as the argument of weakref. Should we\n    // check for an existing decl?\n    D->addAttr(::new (S.Context) AliasAttr(S.Context, AL, Str));\n\n  D->addAttr(::new (S.Context) WeakRefAttr(S.Context, AL));\n}\n\nstatic void handleIFuncAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  StringRef Str;\n  if (!S.checkStringLiteralArgumentAttr(AL, 0, Str))\n    return;\n\n  // Aliases should be on declarations, not definitions.\n  const auto *FD = cast<FunctionDecl>(D);\n  if (FD->isThisDeclarationADefinition()) {\n    S.Diag(AL.getLoc(), diag::err_alias_is_definition) << FD << 1;\n    return;\n  }\n\n  D->addAttr(::new (S.Context) IFuncAttr(S.Context, AL, Str));\n}\n\nstatic void handleAliasAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  StringRef Str;\n  if (!S.checkStringLiteralArgumentAttr(AL, 0, Str))\n    return;\n\n  if (S.Context.getTargetInfo().getTriple().isOSDarwin()) {\n    S.Diag(AL.getLoc(), diag::err_alias_not_supported_on_darwin);\n    return;\n  }\n  if (S.Context.getTargetInfo().getTriple().isNVPTX()) {\n    S.Diag(AL.getLoc(), diag::err_alias_not_supported_on_nvptx);\n  }\n\n  // Aliases should be on declarations, not definitions.\n  if (const auto *FD = dyn_cast<FunctionDecl>(D)) {\n    if (FD->isThisDeclarationADefinition()) {\n      S.Diag(AL.getLoc(), diag::err_alias_is_definition) << FD << 0;\n      return;\n    }\n  } else {\n    const auto *VD = cast<VarDecl>(D);\n    if (VD->isThisDeclarationADefinition() && VD->isExternallyVisible()) {\n      S.Diag(AL.getLoc(), diag::err_alias_is_definition) << VD << 0;\n      return;\n    }\n  }\n\n  // Mark target used to prevent unneeded-internal-declaration warnings.\n  if (!S.LangOpts.CPlusPlus) {\n    // FIXME: demangle Str for C++, as the attribute refers to the mangled\n    // linkage name, not the pre-mangled identifier.\n    const DeclarationNameInfo target(&S.Context.Idents.get(Str), AL.getLoc());\n    LookupResult LR(S, target, Sema::LookupOrdinaryName);\n    if (S.LookupQualifiedName(LR, S.getCurLexicalContext()))\n      for (NamedDecl *ND : LR)\n        ND->markUsed(S.Context);\n  }\n\n  D->addAttr(::new (S.Context) AliasAttr(S.Context, AL, Str));\n}\n\nstatic void handleTLSModelAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  StringRef Model;\n  SourceLocation LiteralLoc;\n  // Check that it is a string.\n  if (!S.checkStringLiteralArgumentAttr(AL, 0, Model, &LiteralLoc))\n    return;\n\n  // Check that the value.\n  if (Model != \"global-dynamic\" && Model != \"local-dynamic\"\n      && Model != \"initial-exec\" && Model != \"local-exec\") {\n    S.Diag(LiteralLoc, diag::err_attr_tlsmodel_arg);\n    return;\n  }\n\n  D->addAttr(::new (S.Context) TLSModelAttr(S.Context, AL, Model));\n}\n\nstatic void handleRestrictAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  QualType ResultType = getFunctionOrMethodResultType(D);\n  if (ResultType->isAnyPointerType() || ResultType->isBlockPointerType()) {\n    D->addAttr(::new (S.Context) RestrictAttr(S.Context, AL));\n    return;\n  }\n\n  S.Diag(AL.getLoc(), diag::warn_attribute_return_pointers_only)\n      << AL << getFunctionOrMethodResultSourceRange(D);\n}\n\nstatic void handleCPUSpecificAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  FunctionDecl *FD = cast<FunctionDecl>(D);\n\n  if (const auto *MD = dyn_cast<CXXMethodDecl>(D)) {\n    if (MD->getParent()->isLambda()) {\n      S.Diag(AL.getLoc(), diag::err_attribute_dll_lambda) << AL;\n      return;\n    }\n  }\n\n  if (!AL.checkAtLeastNumArgs(S, 1))\n    return;\n\n  SmallVector<IdentifierInfo *, 8> CPUs;\n  for (unsigned ArgNo = 0; ArgNo < getNumAttributeArgs(AL); ++ArgNo) {\n    if (!AL.isArgIdent(ArgNo)) {\n      S.Diag(AL.getLoc(), diag::err_attribute_argument_type)\n          << AL << AANT_ArgumentIdentifier;\n      return;\n    }\n\n    IdentifierLoc *CPUArg = AL.getArgAsIdent(ArgNo);\n    StringRef CPUName = CPUArg->Ident->getName().trim();\n\n    if (!S.Context.getTargetInfo().validateCPUSpecificCPUDispatch(CPUName)) {\n      S.Diag(CPUArg->Loc, diag::err_invalid_cpu_specific_dispatch_value)\n          << CPUName << (AL.getKind() == ParsedAttr::AT_CPUDispatch);\n      return;\n    }\n\n    const TargetInfo &Target = S.Context.getTargetInfo();\n    if (llvm::any_of(CPUs, [CPUName, &Target](const IdentifierInfo *Cur) {\n          return Target.CPUSpecificManglingCharacter(CPUName) ==\n                 Target.CPUSpecificManglingCharacter(Cur->getName());\n        })) {\n      S.Diag(AL.getLoc(), diag::warn_multiversion_duplicate_entries);\n      return;\n    }\n    CPUs.push_back(CPUArg->Ident);\n  }\n\n  FD->setIsMultiVersion(true);\n  if (AL.getKind() == ParsedAttr::AT_CPUSpecific)\n    D->addAttr(::new (S.Context)\n                   CPUSpecificAttr(S.Context, AL, CPUs.data(), CPUs.size()));\n  else\n    D->addAttr(::new (S.Context)\n                   CPUDispatchAttr(S.Context, AL, CPUs.data(), CPUs.size()));\n}\n\nstatic void handleCommonAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  if (S.LangOpts.CPlusPlus) {\n    S.Diag(AL.getLoc(), diag::err_attribute_not_supported_in_lang)\n        << AL << AttributeLangSupport::Cpp;\n    return;\n  }\n\n  if (CommonAttr *CA = S.mergeCommonAttr(D, AL))\n    D->addAttr(CA);\n}\n\nstatic void handleCmseNSEntryAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  if (S.LangOpts.CPlusPlus && !D->getDeclContext()->isExternCContext()) {\n    S.Diag(AL.getLoc(), diag::err_attribute_not_clinkage) << AL;\n    return;\n  }\n\n  const auto *FD = cast<FunctionDecl>(D);\n  if (!FD->isExternallyVisible()) {\n    S.Diag(AL.getLoc(), diag::warn_attribute_cmse_entry_static);\n    return;\n  }\n\n  D->addAttr(::new (S.Context) CmseNSEntryAttr(S.Context, AL));\n}\n\nstatic void handleNakedAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  if (checkAttrMutualExclusion<DisableTailCallsAttr>(S, D, AL))\n    return;\n\n  if (AL.isDeclspecAttribute()) {\n    const auto &Triple = S.getASTContext().getTargetInfo().getTriple();\n    const auto &Arch = Triple.getArch();\n    if (Arch != llvm::Triple::x86 &&\n        (Arch != llvm::Triple::arm && Arch != llvm::Triple::thumb)) {\n      S.Diag(AL.getLoc(), diag::err_attribute_not_supported_on_arch)\n          << AL << Triple.getArchName();\n      return;\n    }\n  }\n\n  D->addAttr(::new (S.Context) NakedAttr(S.Context, AL));\n}\n\nstatic void handleNoReturnAttr(Sema &S, Decl *D, const ParsedAttr &Attrs) {\n  if (hasDeclarator(D)) return;\n\n  if (!isa<ObjCMethodDecl>(D)) {\n    S.Diag(Attrs.getLoc(), diag::warn_attribute_wrong_decl_type)\n        << Attrs << ExpectedFunctionOrMethod;\n    return;\n  }\n\n  D->addAttr(::new (S.Context) NoReturnAttr(S.Context, Attrs));\n}\n\nstatic void handleNoCfCheckAttr(Sema &S, Decl *D, const ParsedAttr &Attrs) {\n  if (!S.getLangOpts().CFProtectionBranch)\n    S.Diag(Attrs.getLoc(), diag::warn_nocf_check_attribute_ignored);\n  else\n    handleSimpleAttribute<AnyX86NoCfCheckAttr>(S, D, Attrs);\n}\n\nbool Sema::CheckAttrNoArgs(const ParsedAttr &Attrs) {\n  if (!Attrs.checkExactlyNumArgs(*this, 0)) {\n    Attrs.setInvalid();\n    return true;\n  }\n\n  return false;\n}\n\nbool Sema::CheckAttrTarget(const ParsedAttr &AL) {\n  // Check whether the attribute is valid on the current target.\n  if (!AL.existsInTarget(Context.getTargetInfo())) {\n    Diag(AL.getLoc(), diag::warn_unknown_attribute_ignored)\n        << AL << AL.getRange();\n    AL.setInvalid();\n    return true;\n  }\n\n  return false;\n}\n\nstatic void handleAnalyzerNoReturnAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n\n  // The checking path for 'noreturn' and 'analyzer_noreturn' are different\n  // because 'analyzer_noreturn' does not impact the type.\n  if (!isFunctionOrMethodOrBlock(D)) {\n    ValueDecl *VD = dyn_cast<ValueDecl>(D);\n    if (!VD || (!VD->getType()->isBlockPointerType() &&\n                !VD->getType()->isFunctionPointerType())) {\n      S.Diag(AL.getLoc(), AL.isCXX11Attribute()\n                              ? diag::err_attribute_wrong_decl_type\n                              : diag::warn_attribute_wrong_decl_type)\n          << AL << ExpectedFunctionMethodOrBlock;\n      return;\n    }\n  }\n\n  D->addAttr(::new (S.Context) AnalyzerNoReturnAttr(S.Context, AL));\n}\n\n// PS3 PPU-specific.\nstatic void handleVecReturnAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  /*\n    Returning a Vector Class in Registers\n\n    According to the PPU ABI specifications, a class with a single member of\n    vector type is returned in memory when used as the return value of a\n    function.\n    This results in inefficient code when implementing vector classes. To return\n    the value in a single vector register, add the vecreturn attribute to the\n    class definition. This attribute is also applicable to struct types.\n\n    Example:\n\n    struct Vector\n    {\n      __vector float xyzw;\n    } __attribute__((vecreturn));\n\n    Vector Add(Vector lhs, Vector rhs)\n    {\n      Vector result;\n      result.xyzw = vec_add(lhs.xyzw, rhs.xyzw);\n      return result; // This will be returned in a register\n    }\n  */\n  if (VecReturnAttr *A = D->getAttr<VecReturnAttr>()) {\n    S.Diag(AL.getLoc(), diag::err_repeat_attribute) << A;\n    return;\n  }\n\n  const auto *R = cast<RecordDecl>(D);\n  int count = 0;\n\n  if (!isa<CXXRecordDecl>(R)) {\n    S.Diag(AL.getLoc(), diag::err_attribute_vecreturn_only_vector_member);\n    return;\n  }\n\n  if (!cast<CXXRecordDecl>(R)->isPOD()) {\n    S.Diag(AL.getLoc(), diag::err_attribute_vecreturn_only_pod_record);\n    return;\n  }\n\n  for (const auto *I : R->fields()) {\n    if ((count == 1) || !I->getType()->isVectorType()) {\n      S.Diag(AL.getLoc(), diag::err_attribute_vecreturn_only_vector_member);\n      return;\n    }\n    count++;\n  }\n\n  D->addAttr(::new (S.Context) VecReturnAttr(S.Context, AL));\n}\n\nstatic void handleDependencyAttr(Sema &S, Scope *Scope, Decl *D,\n                                 const ParsedAttr &AL) {\n  if (isa<ParmVarDecl>(D)) {\n    // [[carries_dependency]] can only be applied to a parameter if it is a\n    // parameter of a function declaration or lambda.\n    if (!(Scope->getFlags() & clang::Scope::FunctionDeclarationScope)) {\n      S.Diag(AL.getLoc(),\n             diag::err_carries_dependency_param_not_function_decl);\n      return;\n    }\n  }\n\n  D->addAttr(::new (S.Context) CarriesDependencyAttr(S.Context, AL));\n}\n\nstatic void handleUnusedAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  bool IsCXX17Attr = AL.isCXX11Attribute() && !AL.getScopeName();\n\n  // If this is spelled as the standard C++17 attribute, but not in C++17, warn\n  // about using it as an extension.\n  if (!S.getLangOpts().CPlusPlus17 && IsCXX17Attr)\n    S.Diag(AL.getLoc(), diag::ext_cxx17_attr) << AL;\n\n  D->addAttr(::new (S.Context) UnusedAttr(S.Context, AL));\n}\n\nstatic void handleConstructorAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  uint32_t priority = ConstructorAttr::DefaultPriority;\n  if (AL.getNumArgs() &&\n      !checkUInt32Argument(S, AL, AL.getArgAsExpr(0), priority))\n    return;\n\n  D->addAttr(::new (S.Context) ConstructorAttr(S.Context, AL, priority));\n}\n\nstatic void handleDestructorAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  uint32_t priority = DestructorAttr::DefaultPriority;\n  if (AL.getNumArgs() &&\n      !checkUInt32Argument(S, AL, AL.getArgAsExpr(0), priority))\n    return;\n\n  D->addAttr(::new (S.Context) DestructorAttr(S.Context, AL, priority));\n}\n\ntemplate <typename AttrTy>\nstatic void handleAttrWithMessage(Sema &S, Decl *D, const ParsedAttr &AL) {\n  // Handle the case where the attribute has a text message.\n  StringRef Str;\n  if (AL.getNumArgs() == 1 && !S.checkStringLiteralArgumentAttr(AL, 0, Str))\n    return;\n\n  D->addAttr(::new (S.Context) AttrTy(S.Context, AL, Str));\n}\n\nstatic void handleObjCSuppresProtocolAttr(Sema &S, Decl *D,\n                                          const ParsedAttr &AL) {\n  if (!cast<ObjCProtocolDecl>(D)->isThisDeclarationADefinition()) {\n    S.Diag(AL.getLoc(), diag::err_objc_attr_protocol_requires_definition)\n        << AL << AL.getRange();\n    return;\n  }\n\n  D->addAttr(::new (S.Context) ObjCExplicitProtocolImplAttr(S.Context, AL));\n}\n\nstatic bool checkAvailabilityAttr(Sema &S, SourceRange Range,\n                                  IdentifierInfo *Platform,\n                                  VersionTuple Introduced,\n                                  VersionTuple Deprecated,\n                                  VersionTuple Obsoleted) {\n  StringRef PlatformName\n    = AvailabilityAttr::getPrettyPlatformName(Platform->getName());\n  if (PlatformName.empty())\n    PlatformName = Platform->getName();\n\n  // Ensure that Introduced <= Deprecated <= Obsoleted (although not all\n  // of these steps are needed).\n  if (!Introduced.empty() && !Deprecated.empty() &&\n      !(Introduced <= Deprecated)) {\n    S.Diag(Range.getBegin(), diag::warn_availability_version_ordering)\n      << 1 << PlatformName << Deprecated.getAsString()\n      << 0 << Introduced.getAsString();\n    return true;\n  }\n\n  if (!Introduced.empty() && !Obsoleted.empty() &&\n      !(Introduced <= Obsoleted)) {\n    S.Diag(Range.getBegin(), diag::warn_availability_version_ordering)\n      << 2 << PlatformName << Obsoleted.getAsString()\n      << 0 << Introduced.getAsString();\n    return true;\n  }\n\n  if (!Deprecated.empty() && !Obsoleted.empty() &&\n      !(Deprecated <= Obsoleted)) {\n    S.Diag(Range.getBegin(), diag::warn_availability_version_ordering)\n      << 2 << PlatformName << Obsoleted.getAsString()\n      << 1 << Deprecated.getAsString();\n    return true;\n  }\n\n  return false;\n}\n\n/// Check whether the two versions match.\n///\n/// If either version tuple is empty, then they are assumed to match. If\n/// \\p BeforeIsOkay is true, then \\p X can be less than or equal to \\p Y.\nstatic bool versionsMatch(const VersionTuple &X, const VersionTuple &Y,\n                          bool BeforeIsOkay) {\n  if (X.empty() || Y.empty())\n    return true;\n\n  if (X == Y)\n    return true;\n\n  if (BeforeIsOkay && X < Y)\n    return true;\n\n  return false;\n}\n\nAvailabilityAttr *Sema::mergeAvailabilityAttr(\n    NamedDecl *D, const AttributeCommonInfo &CI, IdentifierInfo *Platform,\n    bool Implicit, VersionTuple Introduced, VersionTuple Deprecated,\n    VersionTuple Obsoleted, bool IsUnavailable, StringRef Message,\n    bool IsStrict, StringRef Replacement, AvailabilityMergeKind AMK,\n    int Priority) {\n  VersionTuple MergedIntroduced = Introduced;\n  VersionTuple MergedDeprecated = Deprecated;\n  VersionTuple MergedObsoleted = Obsoleted;\n  bool FoundAny = false;\n  bool OverrideOrImpl = false;\n  switch (AMK) {\n  case AMK_None:\n  case AMK_Redeclaration:\n    OverrideOrImpl = false;\n    break;\n\n  case AMK_Override:\n  case AMK_ProtocolImplementation:\n    OverrideOrImpl = true;\n    break;\n  }\n\n  if (D->hasAttrs()) {\n    AttrVec &Attrs = D->getAttrs();\n    for (unsigned i = 0, e = Attrs.size(); i != e;) {\n      const auto *OldAA = dyn_cast<AvailabilityAttr>(Attrs[i]);\n      if (!OldAA) {\n        ++i;\n        continue;\n      }\n\n      IdentifierInfo *OldPlatform = OldAA->getPlatform();\n      if (OldPlatform != Platform) {\n        ++i;\n        continue;\n      }\n\n      // If there is an existing availability attribute for this platform that\n      // has a lower priority use the existing one and discard the new\n      // attribute.\n      if (OldAA->getPriority() < Priority)\n        return nullptr;\n\n      // If there is an existing attribute for this platform that has a higher\n      // priority than the new attribute then erase the old one and continue\n      // processing the attributes.\n      if (OldAA->getPriority() > Priority) {\n        Attrs.erase(Attrs.begin() + i);\n        --e;\n        continue;\n      }\n\n      FoundAny = true;\n      VersionTuple OldIntroduced = OldAA->getIntroduced();\n      VersionTuple OldDeprecated = OldAA->getDeprecated();\n      VersionTuple OldObsoleted = OldAA->getObsoleted();\n      bool OldIsUnavailable = OldAA->getUnavailable();\n\n      if (!versionsMatch(OldIntroduced, Introduced, OverrideOrImpl) ||\n          !versionsMatch(Deprecated, OldDeprecated, OverrideOrImpl) ||\n          !versionsMatch(Obsoleted, OldObsoleted, OverrideOrImpl) ||\n          !(OldIsUnavailable == IsUnavailable ||\n            (OverrideOrImpl && !OldIsUnavailable && IsUnavailable))) {\n        if (OverrideOrImpl) {\n          int Which = -1;\n          VersionTuple FirstVersion;\n          VersionTuple SecondVersion;\n          if (!versionsMatch(OldIntroduced, Introduced, OverrideOrImpl)) {\n            Which = 0;\n            FirstVersion = OldIntroduced;\n            SecondVersion = Introduced;\n          } else if (!versionsMatch(Deprecated, OldDeprecated, OverrideOrImpl)) {\n            Which = 1;\n            FirstVersion = Deprecated;\n            SecondVersion = OldDeprecated;\n          } else if (!versionsMatch(Obsoleted, OldObsoleted, OverrideOrImpl)) {\n            Which = 2;\n            FirstVersion = Obsoleted;\n            SecondVersion = OldObsoleted;\n          }\n\n          if (Which == -1) {\n            Diag(OldAA->getLocation(),\n                 diag::warn_mismatched_availability_override_unavail)\n              << AvailabilityAttr::getPrettyPlatformName(Platform->getName())\n              << (AMK == AMK_Override);\n          } else {\n            Diag(OldAA->getLocation(),\n                 diag::warn_mismatched_availability_override)\n              << Which\n              << AvailabilityAttr::getPrettyPlatformName(Platform->getName())\n              << FirstVersion.getAsString() << SecondVersion.getAsString()\n              << (AMK == AMK_Override);\n          }\n          if (AMK == AMK_Override)\n            Diag(CI.getLoc(), diag::note_overridden_method);\n          else\n            Diag(CI.getLoc(), diag::note_protocol_method);\n        } else {\n          Diag(OldAA->getLocation(), diag::warn_mismatched_availability);\n          Diag(CI.getLoc(), diag::note_previous_attribute);\n        }\n\n        Attrs.erase(Attrs.begin() + i);\n        --e;\n        continue;\n      }\n\n      VersionTuple MergedIntroduced2 = MergedIntroduced;\n      VersionTuple MergedDeprecated2 = MergedDeprecated;\n      VersionTuple MergedObsoleted2 = MergedObsoleted;\n\n      if (MergedIntroduced2.empty())\n        MergedIntroduced2 = OldIntroduced;\n      if (MergedDeprecated2.empty())\n        MergedDeprecated2 = OldDeprecated;\n      if (MergedObsoleted2.empty())\n        MergedObsoleted2 = OldObsoleted;\n\n      if (checkAvailabilityAttr(*this, OldAA->getRange(), Platform,\n                                MergedIntroduced2, MergedDeprecated2,\n                                MergedObsoleted2)) {\n        Attrs.erase(Attrs.begin() + i);\n        --e;\n        continue;\n      }\n\n      MergedIntroduced = MergedIntroduced2;\n      MergedDeprecated = MergedDeprecated2;\n      MergedObsoleted = MergedObsoleted2;\n      ++i;\n    }\n  }\n\n  if (FoundAny &&\n      MergedIntroduced == Introduced &&\n      MergedDeprecated == Deprecated &&\n      MergedObsoleted == Obsoleted)\n    return nullptr;\n\n  // Only create a new attribute if !OverrideOrImpl, but we want to do\n  // the checking.\n  if (!checkAvailabilityAttr(*this, CI.getRange(), Platform, MergedIntroduced,\n                             MergedDeprecated, MergedObsoleted) &&\n      !OverrideOrImpl) {\n    auto *Avail = ::new (Context) AvailabilityAttr(\n        Context, CI, Platform, Introduced, Deprecated, Obsoleted, IsUnavailable,\n        Message, IsStrict, Replacement, Priority);\n    Avail->setImplicit(Implicit);\n    return Avail;\n  }\n  return nullptr;\n}\n\nstatic void handleAvailabilityAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  if (!AL.checkExactlyNumArgs(S, 1))\n    return;\n  IdentifierLoc *Platform = AL.getArgAsIdent(0);\n\n  IdentifierInfo *II = Platform->Ident;\n  if (AvailabilityAttr::getPrettyPlatformName(II->getName()).empty())\n    S.Diag(Platform->Loc, diag::warn_availability_unknown_platform)\n      << Platform->Ident;\n\n  auto *ND = dyn_cast<NamedDecl>(D);\n  if (!ND) // We warned about this already, so just return.\n    return;\n\n  AvailabilityChange Introduced = AL.getAvailabilityIntroduced();\n  AvailabilityChange Deprecated = AL.getAvailabilityDeprecated();\n  AvailabilityChange Obsoleted = AL.getAvailabilityObsoleted();\n  bool IsUnavailable = AL.getUnavailableLoc().isValid();\n  bool IsStrict = AL.getStrictLoc().isValid();\n  StringRef Str;\n  if (const auto *SE = dyn_cast_or_null<StringLiteral>(AL.getMessageExpr()))\n    Str = SE->getString();\n  StringRef Replacement;\n  if (const auto *SE = dyn_cast_or_null<StringLiteral>(AL.getReplacementExpr()))\n    Replacement = SE->getString();\n\n  if (II->isStr(\"swift\")) {\n    if (Introduced.isValid() || Obsoleted.isValid() ||\n        (!IsUnavailable && !Deprecated.isValid())) {\n      S.Diag(AL.getLoc(),\n             diag::warn_availability_swift_unavailable_deprecated_only);\n      return;\n    }\n  }\n\n  int PriorityModifier = AL.isPragmaClangAttribute()\n                             ? Sema::AP_PragmaClangAttribute\n                             : Sema::AP_Explicit;\n  AvailabilityAttr *NewAttr = S.mergeAvailabilityAttr(\n      ND, AL, II, false /*Implicit*/, Introduced.Version, Deprecated.Version,\n      Obsoleted.Version, IsUnavailable, Str, IsStrict, Replacement,\n      Sema::AMK_None, PriorityModifier);\n  if (NewAttr)\n    D->addAttr(NewAttr);\n\n  // Transcribe \"ios\" to \"watchos\" (and add a new attribute) if the versioning\n  // matches before the start of the watchOS platform.\n  if (S.Context.getTargetInfo().getTriple().isWatchOS()) {\n    IdentifierInfo *NewII = nullptr;\n    if (II->getName() == \"ios\")\n      NewII = &S.Context.Idents.get(\"watchos\");\n    else if (II->getName() == \"ios_app_extension\")\n      NewII = &S.Context.Idents.get(\"watchos_app_extension\");\n\n    if (NewII) {\n        auto adjustWatchOSVersion = [](VersionTuple Version) -> VersionTuple {\n          if (Version.empty())\n            return Version;\n          auto Major = Version.getMajor();\n          auto NewMajor = Major >= 9 ? Major - 7 : 0;\n          if (NewMajor >= 2) {\n            if (Version.getMinor().hasValue()) {\n              if (Version.getSubminor().hasValue())\n                return VersionTuple(NewMajor, Version.getMinor().getValue(),\n                                    Version.getSubminor().getValue());\n              else\n                return VersionTuple(NewMajor, Version.getMinor().getValue());\n            }\n            return VersionTuple(NewMajor);\n          }\n\n          return VersionTuple(2, 0);\n        };\n\n        auto NewIntroduced = adjustWatchOSVersion(Introduced.Version);\n        auto NewDeprecated = adjustWatchOSVersion(Deprecated.Version);\n        auto NewObsoleted = adjustWatchOSVersion(Obsoleted.Version);\n\n        AvailabilityAttr *NewAttr = S.mergeAvailabilityAttr(\n            ND, AL, NewII, true /*Implicit*/, NewIntroduced, NewDeprecated,\n            NewObsoleted, IsUnavailable, Str, IsStrict, Replacement,\n            Sema::AMK_None,\n            PriorityModifier + Sema::AP_InferredFromOtherPlatform);\n        if (NewAttr)\n          D->addAttr(NewAttr);\n      }\n  } else if (S.Context.getTargetInfo().getTriple().isTvOS()) {\n    // Transcribe \"ios\" to \"tvos\" (and add a new attribute) if the versioning\n    // matches before the start of the tvOS platform.\n    IdentifierInfo *NewII = nullptr;\n    if (II->getName() == \"ios\")\n      NewII = &S.Context.Idents.get(\"tvos\");\n    else if (II->getName() == \"ios_app_extension\")\n      NewII = &S.Context.Idents.get(\"tvos_app_extension\");\n\n    if (NewII) {\n      AvailabilityAttr *NewAttr = S.mergeAvailabilityAttr(\n          ND, AL, NewII, true /*Implicit*/, Introduced.Version,\n          Deprecated.Version, Obsoleted.Version, IsUnavailable, Str, IsStrict,\n          Replacement, Sema::AMK_None,\n          PriorityModifier + Sema::AP_InferredFromOtherPlatform);\n      if (NewAttr)\n        D->addAttr(NewAttr);\n      }\n  }\n}\n\nstatic void handleExternalSourceSymbolAttr(Sema &S, Decl *D,\n                                           const ParsedAttr &AL) {\n  if (!AL.checkAtLeastNumArgs(S, 1) || !AL.checkAtMostNumArgs(S, 3))\n    return;\n\n  StringRef Language;\n  if (const auto *SE = dyn_cast_or_null<StringLiteral>(AL.getArgAsExpr(0)))\n    Language = SE->getString();\n  StringRef DefinedIn;\n  if (const auto *SE = dyn_cast_or_null<StringLiteral>(AL.getArgAsExpr(1)))\n    DefinedIn = SE->getString();\n  bool IsGeneratedDeclaration = AL.getArgAsIdent(2) != nullptr;\n\n  D->addAttr(::new (S.Context) ExternalSourceSymbolAttr(\n      S.Context, AL, Language, DefinedIn, IsGeneratedDeclaration));\n}\n\ntemplate <class T>\nstatic T *mergeVisibilityAttr(Sema &S, Decl *D, const AttributeCommonInfo &CI,\n                              typename T::VisibilityType value) {\n  T *existingAttr = D->getAttr<T>();\n  if (existingAttr) {\n    typename T::VisibilityType existingValue = existingAttr->getVisibility();\n    if (existingValue == value)\n      return nullptr;\n    S.Diag(existingAttr->getLocation(), diag::err_mismatched_visibility);\n    S.Diag(CI.getLoc(), diag::note_previous_attribute);\n    D->dropAttr<T>();\n  }\n  return ::new (S.Context) T(S.Context, CI, value);\n}\n\nVisibilityAttr *Sema::mergeVisibilityAttr(Decl *D,\n                                          const AttributeCommonInfo &CI,\n                                          VisibilityAttr::VisibilityType Vis) {\n  return ::mergeVisibilityAttr<VisibilityAttr>(*this, D, CI, Vis);\n}\n\nTypeVisibilityAttr *\nSema::mergeTypeVisibilityAttr(Decl *D, const AttributeCommonInfo &CI,\n                              TypeVisibilityAttr::VisibilityType Vis) {\n  return ::mergeVisibilityAttr<TypeVisibilityAttr>(*this, D, CI, Vis);\n}\n\nstatic void handleVisibilityAttr(Sema &S, Decl *D, const ParsedAttr &AL,\n                                 bool isTypeVisibility) {\n  // Visibility attributes don't mean anything on a typedef.\n  if (isa<TypedefNameDecl>(D)) {\n    S.Diag(AL.getRange().getBegin(), diag::warn_attribute_ignored) << AL;\n    return;\n  }\n\n  // 'type_visibility' can only go on a type or namespace.\n  if (isTypeVisibility &&\n      !(isa<TagDecl>(D) ||\n        isa<ObjCInterfaceDecl>(D) ||\n        isa<NamespaceDecl>(D))) {\n    S.Diag(AL.getRange().getBegin(), diag::err_attribute_wrong_decl_type)\n        << AL << ExpectedTypeOrNamespace;\n    return;\n  }\n\n  // Check that the argument is a string literal.\n  StringRef TypeStr;\n  SourceLocation LiteralLoc;\n  if (!S.checkStringLiteralArgumentAttr(AL, 0, TypeStr, &LiteralLoc))\n    return;\n\n  VisibilityAttr::VisibilityType type;\n  if (!VisibilityAttr::ConvertStrToVisibilityType(TypeStr, type)) {\n    S.Diag(LiteralLoc, diag::warn_attribute_type_not_supported) << AL\n                                                                << TypeStr;\n    return;\n  }\n\n  // Complain about attempts to use protected visibility on targets\n  // (like Darwin) that don't support it.\n  if (type == VisibilityAttr::Protected &&\n      !S.Context.getTargetInfo().hasProtectedVisibility()) {\n    S.Diag(AL.getLoc(), diag::warn_attribute_protected_visibility);\n    type = VisibilityAttr::Default;\n  }\n\n  Attr *newAttr;\n  if (isTypeVisibility) {\n    newAttr = S.mergeTypeVisibilityAttr(\n        D, AL, (TypeVisibilityAttr::VisibilityType)type);\n  } else {\n    newAttr = S.mergeVisibilityAttr(D, AL, type);\n  }\n  if (newAttr)\n    D->addAttr(newAttr);\n}\n\nstatic void handleObjCNonRuntimeProtocolAttr(Sema &S, Decl *D,\n                                             const ParsedAttr &AL) {\n  handleSimpleAttribute<ObjCNonRuntimeProtocolAttr>(S, D, AL);\n}\n\nstatic void handleObjCDirectAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  // objc_direct cannot be set on methods declared in the context of a protocol\n  if (isa<ObjCProtocolDecl>(D->getDeclContext())) {\n    S.Diag(AL.getLoc(), diag::err_objc_direct_on_protocol) << false;\n    return;\n  }\n\n  if (S.getLangOpts().ObjCRuntime.allowsDirectDispatch()) {\n    handleSimpleAttribute<ObjCDirectAttr>(S, D, AL);\n  } else {\n    S.Diag(AL.getLoc(), diag::warn_objc_direct_ignored) << AL;\n  }\n}\n\nstatic void handleObjCDirectMembersAttr(Sema &S, Decl *D,\n                                        const ParsedAttr &AL) {\n  if (S.getLangOpts().ObjCRuntime.allowsDirectDispatch()) {\n    handleSimpleAttribute<ObjCDirectMembersAttr>(S, D, AL);\n  } else {\n    S.Diag(AL.getLoc(), diag::warn_objc_direct_ignored) << AL;\n  }\n}\n\nstatic void handleObjCMethodFamilyAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  const auto *M = cast<ObjCMethodDecl>(D);\n  if (!AL.isArgIdent(0)) {\n    S.Diag(AL.getLoc(), diag::err_attribute_argument_n_type)\n        << AL << 1 << AANT_ArgumentIdentifier;\n    return;\n  }\n\n  IdentifierLoc *IL = AL.getArgAsIdent(0);\n  ObjCMethodFamilyAttr::FamilyKind F;\n  if (!ObjCMethodFamilyAttr::ConvertStrToFamilyKind(IL->Ident->getName(), F)) {\n    S.Diag(IL->Loc, diag::warn_attribute_type_not_supported) << AL << IL->Ident;\n    return;\n  }\n\n  if (F == ObjCMethodFamilyAttr::OMF_init &&\n      !M->getReturnType()->isObjCObjectPointerType()) {\n    S.Diag(M->getLocation(), diag::err_init_method_bad_return_type)\n        << M->getReturnType();\n    // Ignore the attribute.\n    return;\n  }\n\n  D->addAttr(new (S.Context) ObjCMethodFamilyAttr(S.Context, AL, F));\n}\n\nstatic void handleObjCNSObject(Sema &S, Decl *D, const ParsedAttr &AL) {\n  if (const auto *TD = dyn_cast<TypedefNameDecl>(D)) {\n    QualType T = TD->getUnderlyingType();\n    if (!T->isCARCBridgableType()) {\n      S.Diag(TD->getLocation(), diag::err_nsobject_attribute);\n      return;\n    }\n  }\n  else if (const auto *PD = dyn_cast<ObjCPropertyDecl>(D)) {\n    QualType T = PD->getType();\n    if (!T->isCARCBridgableType()) {\n      S.Diag(PD->getLocation(), diag::err_nsobject_attribute);\n      return;\n    }\n  }\n  else {\n    // It is okay to include this attribute on properties, e.g.:\n    //\n    //  @property (retain, nonatomic) struct Bork *Q __attribute__((NSObject));\n    //\n    // In this case it follows tradition and suppresses an error in the above\n    // case.\n    S.Diag(D->getLocation(), diag::warn_nsobject_attribute);\n  }\n  D->addAttr(::new (S.Context) ObjCNSObjectAttr(S.Context, AL));\n}\n\nstatic void handleObjCIndependentClass(Sema &S, Decl *D, const ParsedAttr &AL) {\n  if (const auto *TD = dyn_cast<TypedefNameDecl>(D)) {\n    QualType T = TD->getUnderlyingType();\n    if (!T->isObjCObjectPointerType()) {\n      S.Diag(TD->getLocation(), diag::warn_ptr_independentclass_attribute);\n      return;\n    }\n  } else {\n    S.Diag(D->getLocation(), diag::warn_independentclass_attribute);\n    return;\n  }\n  D->addAttr(::new (S.Context) ObjCIndependentClassAttr(S.Context, AL));\n}\n\nstatic void handleBlocksAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  if (!AL.isArgIdent(0)) {\n    S.Diag(AL.getLoc(), diag::err_attribute_argument_n_type)\n        << AL << 1 << AANT_ArgumentIdentifier;\n    return;\n  }\n\n  IdentifierInfo *II = AL.getArgAsIdent(0)->Ident;\n  BlocksAttr::BlockType type;\n  if (!BlocksAttr::ConvertStrToBlockType(II->getName(), type)) {\n    S.Diag(AL.getLoc(), diag::warn_attribute_type_not_supported) << AL << II;\n    return;\n  }\n\n  D->addAttr(::new (S.Context) BlocksAttr(S.Context, AL, type));\n}\n\nstatic void handleSentinelAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  unsigned sentinel = (unsigned)SentinelAttr::DefaultSentinel;\n  if (AL.getNumArgs() > 0) {\n    Expr *E = AL.getArgAsExpr(0);\n    Optional<llvm::APSInt> Idx = llvm::APSInt(32);\n    if (E->isTypeDependent() || E->isValueDependent() ||\n        !(Idx = E->getIntegerConstantExpr(S.Context))) {\n      S.Diag(AL.getLoc(), diag::err_attribute_argument_n_type)\n          << AL << 1 << AANT_ArgumentIntegerConstant << E->getSourceRange();\n      return;\n    }\n\n    if (Idx->isSigned() && Idx->isNegative()) {\n      S.Diag(AL.getLoc(), diag::err_attribute_sentinel_less_than_zero)\n        << E->getSourceRange();\n      return;\n    }\n\n    sentinel = Idx->getZExtValue();\n  }\n\n  unsigned nullPos = (unsigned)SentinelAttr::DefaultNullPos;\n  if (AL.getNumArgs() > 1) {\n    Expr *E = AL.getArgAsExpr(1);\n    Optional<llvm::APSInt> Idx = llvm::APSInt(32);\n    if (E->isTypeDependent() || E->isValueDependent() ||\n        !(Idx = E->getIntegerConstantExpr(S.Context))) {\n      S.Diag(AL.getLoc(), diag::err_attribute_argument_n_type)\n          << AL << 2 << AANT_ArgumentIntegerConstant << E->getSourceRange();\n      return;\n    }\n    nullPos = Idx->getZExtValue();\n\n    if ((Idx->isSigned() && Idx->isNegative()) || nullPos > 1) {\n      // FIXME: This error message could be improved, it would be nice\n      // to say what the bounds actually are.\n      S.Diag(AL.getLoc(), diag::err_attribute_sentinel_not_zero_or_one)\n        << E->getSourceRange();\n      return;\n    }\n  }\n\n  if (const auto *FD = dyn_cast<FunctionDecl>(D)) {\n    const FunctionType *FT = FD->getType()->castAs<FunctionType>();\n    if (isa<FunctionNoProtoType>(FT)) {\n      S.Diag(AL.getLoc(), diag::warn_attribute_sentinel_named_arguments);\n      return;\n    }\n\n    if (!cast<FunctionProtoType>(FT)->isVariadic()) {\n      S.Diag(AL.getLoc(), diag::warn_attribute_sentinel_not_variadic) << 0;\n      return;\n    }\n  } else if (const auto *MD = dyn_cast<ObjCMethodDecl>(D)) {\n    if (!MD->isVariadic()) {\n      S.Diag(AL.getLoc(), diag::warn_attribute_sentinel_not_variadic) << 0;\n      return;\n    }\n  } else if (const auto *BD = dyn_cast<BlockDecl>(D)) {\n    if (!BD->isVariadic()) {\n      S.Diag(AL.getLoc(), diag::warn_attribute_sentinel_not_variadic) << 1;\n      return;\n    }\n  } else if (const auto *V = dyn_cast<VarDecl>(D)) {\n    QualType Ty = V->getType();\n    if (Ty->isBlockPointerType() || Ty->isFunctionPointerType()) {\n      const FunctionType *FT = Ty->isFunctionPointerType()\n       ? D->getFunctionType()\n       : Ty->castAs<BlockPointerType>()->getPointeeType()->getAs<FunctionType>();\n      if (!cast<FunctionProtoType>(FT)->isVariadic()) {\n        int m = Ty->isFunctionPointerType() ? 0 : 1;\n        S.Diag(AL.getLoc(), diag::warn_attribute_sentinel_not_variadic) << m;\n        return;\n      }\n    } else {\n      S.Diag(AL.getLoc(), diag::warn_attribute_wrong_decl_type)\n          << AL << ExpectedFunctionMethodOrBlock;\n      return;\n    }\n  } else {\n    S.Diag(AL.getLoc(), diag::warn_attribute_wrong_decl_type)\n        << AL << ExpectedFunctionMethodOrBlock;\n    return;\n  }\n  D->addAttr(::new (S.Context) SentinelAttr(S.Context, AL, sentinel, nullPos));\n}\n\nstatic void handleWarnUnusedResult(Sema &S, Decl *D, const ParsedAttr &AL) {\n  if (D->getFunctionType() &&\n      D->getFunctionType()->getReturnType()->isVoidType() &&\n      !isa<CXXConstructorDecl>(D)) {\n    S.Diag(AL.getLoc(), diag::warn_attribute_void_function_method) << AL << 0;\n    return;\n  }\n  if (const auto *MD = dyn_cast<ObjCMethodDecl>(D))\n    if (MD->getReturnType()->isVoidType()) {\n      S.Diag(AL.getLoc(), diag::warn_attribute_void_function_method) << AL << 1;\n      return;\n    }\n\n  StringRef Str;\n  if ((AL.isCXX11Attribute() || AL.isC2xAttribute()) && !AL.getScopeName()) {\n    // The standard attribute cannot be applied to variable declarations such\n    // as a function pointer.\n    if (isa<VarDecl>(D))\n      S.Diag(AL.getLoc(), diag::warn_attribute_wrong_decl_type_str)\n          << AL << \"functions, classes, or enumerations\";\n\n    // If this is spelled as the standard C++17 attribute, but not in C++17,\n    // warn about using it as an extension. If there are attribute arguments,\n    // then claim it's a C++2a extension instead.\n    // FIXME: If WG14 does not seem likely to adopt the same feature, add an\n    // extension warning for C2x mode.\n    const LangOptions &LO = S.getLangOpts();\n    if (AL.getNumArgs() == 1) {\n      if (LO.CPlusPlus && !LO.CPlusPlus20)\n        S.Diag(AL.getLoc(), diag::ext_cxx20_attr) << AL;\n\n      // Since this this is spelled [[nodiscard]], get the optional string\n      // literal. If in C++ mode, but not in C++2a mode, diagnose as an\n      // extension.\n      // FIXME: C2x should support this feature as well, even as an extension.\n      if (!S.checkStringLiteralArgumentAttr(AL, 0, Str, nullptr))\n        return;\n    } else if (LO.CPlusPlus && !LO.CPlusPlus17)\n      S.Diag(AL.getLoc(), diag::ext_cxx17_attr) << AL;\n  }\n\n  D->addAttr(::new (S.Context) WarnUnusedResultAttr(S.Context, AL, Str));\n}\n\nstatic void handleWeakImportAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  // weak_import only applies to variable & function declarations.\n  bool isDef = false;\n  if (!D->canBeWeakImported(isDef)) {\n    if (isDef)\n      S.Diag(AL.getLoc(), diag::warn_attribute_invalid_on_definition)\n        << \"weak_import\";\n    else if (isa<ObjCPropertyDecl>(D) || isa<ObjCMethodDecl>(D) ||\n             (S.Context.getTargetInfo().getTriple().isOSDarwin() &&\n              (isa<ObjCInterfaceDecl>(D) || isa<EnumDecl>(D)))) {\n      // Nothing to warn about here.\n    } else\n      S.Diag(AL.getLoc(), diag::warn_attribute_wrong_decl_type)\n          << AL << ExpectedVariableOrFunction;\n\n    return;\n  }\n\n  D->addAttr(::new (S.Context) WeakImportAttr(S.Context, AL));\n}\n\n// Handles reqd_work_group_size and work_group_size_hint.\ntemplate <typename WorkGroupAttr>\nstatic void handleWorkGroupSize(Sema &S, Decl *D, const ParsedAttr &AL) {\n  uint32_t WGSize[3];\n  for (unsigned i = 0; i < 3; ++i) {\n    const Expr *E = AL.getArgAsExpr(i);\n    if (!checkUInt32Argument(S, AL, E, WGSize[i], i,\n                             /*StrictlyUnsigned=*/true))\n      return;\n    if (WGSize[i] == 0) {\n      S.Diag(AL.getLoc(), diag::err_attribute_argument_is_zero)\n          << AL << E->getSourceRange();\n      return;\n    }\n  }\n\n  WorkGroupAttr *Existing = D->getAttr<WorkGroupAttr>();\n  if (Existing && !(Existing->getXDim() == WGSize[0] &&\n                    Existing->getYDim() == WGSize[1] &&\n                    Existing->getZDim() == WGSize[2]))\n    S.Diag(AL.getLoc(), diag::warn_duplicate_attribute) << AL;\n\n  D->addAttr(::new (S.Context)\n                 WorkGroupAttr(S.Context, AL, WGSize[0], WGSize[1], WGSize[2]));\n}\n\n// Handles intel_reqd_sub_group_size.\nstatic void handleSubGroupSize(Sema &S, Decl *D, const ParsedAttr &AL) {\n  uint32_t SGSize;\n  const Expr *E = AL.getArgAsExpr(0);\n  if (!checkUInt32Argument(S, AL, E, SGSize))\n    return;\n  if (SGSize == 0) {\n    S.Diag(AL.getLoc(), diag::err_attribute_argument_is_zero)\n        << AL << E->getSourceRange();\n    return;\n  }\n\n  OpenCLIntelReqdSubGroupSizeAttr *Existing =\n      D->getAttr<OpenCLIntelReqdSubGroupSizeAttr>();\n  if (Existing && Existing->getSubGroupSize() != SGSize)\n    S.Diag(AL.getLoc(), diag::warn_duplicate_attribute) << AL;\n\n  D->addAttr(::new (S.Context)\n                 OpenCLIntelReqdSubGroupSizeAttr(S.Context, AL, SGSize));\n}\n\nstatic void handleVecTypeHint(Sema &S, Decl *D, const ParsedAttr &AL) {\n  if (!AL.hasParsedType()) {\n    S.Diag(AL.getLoc(), diag::err_attribute_wrong_number_arguments) << AL << 1;\n    return;\n  }\n\n  TypeSourceInfo *ParmTSI = nullptr;\n  QualType ParmType = S.GetTypeFromParser(AL.getTypeArg(), &ParmTSI);\n  assert(ParmTSI && \"no type source info for attribute argument\");\n\n  if (!ParmType->isExtVectorType() && !ParmType->isFloatingType() &&\n      (ParmType->isBooleanType() ||\n       !ParmType->isIntegralType(S.getASTContext()))) {\n    S.Diag(AL.getLoc(), diag::err_attribute_invalid_argument) << 2 << AL;\n    return;\n  }\n\n  if (VecTypeHintAttr *A = D->getAttr<VecTypeHintAttr>()) {\n    if (!S.Context.hasSameType(A->getTypeHint(), ParmType)) {\n      S.Diag(AL.getLoc(), diag::warn_duplicate_attribute) << AL;\n      return;\n    }\n  }\n\n  D->addAttr(::new (S.Context) VecTypeHintAttr(S.Context, AL, ParmTSI));\n}\n\nSectionAttr *Sema::mergeSectionAttr(Decl *D, const AttributeCommonInfo &CI,\n                                    StringRef Name) {\n  // Explicit or partial specializations do not inherit\n  // the section attribute from the primary template.\n  if (const auto *FD = dyn_cast<FunctionDecl>(D)) {\n    if (CI.getAttributeSpellingListIndex() == SectionAttr::Declspec_allocate &&\n        FD->isFunctionTemplateSpecialization())\n      return nullptr;\n  }\n  if (SectionAttr *ExistingAttr = D->getAttr<SectionAttr>()) {\n    if (ExistingAttr->getName() == Name)\n      return nullptr;\n    Diag(ExistingAttr->getLocation(), diag::warn_mismatched_section)\n         << 1 /*section*/;\n    Diag(CI.getLoc(), diag::note_previous_attribute);\n    return nullptr;\n  }\n  return ::new (Context) SectionAttr(Context, CI, Name);\n}\n\nbool Sema::checkSectionName(SourceLocation LiteralLoc, StringRef SecName) {\n  if (llvm::Error E =\n          Context.getTargetInfo().isValidSectionSpecifier(SecName)) {\n    Diag(LiteralLoc, diag::err_attribute_section_invalid_for_target)\n        << toString(std::move(E)) << 1 /*'section'*/;\n    return false;\n  }\n  return true;\n}\n\nstatic void handleSectionAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  // Make sure that there is a string literal as the sections's single\n  // argument.\n  StringRef Str;\n  SourceLocation LiteralLoc;\n  if (!S.checkStringLiteralArgumentAttr(AL, 0, Str, &LiteralLoc))\n    return;\n\n  if (!S.checkSectionName(LiteralLoc, Str))\n    return;\n\n  // If the target wants to validate the section specifier, make it happen.\n  if (llvm::Error E = S.Context.getTargetInfo().isValidSectionSpecifier(Str)) {\n    S.Diag(LiteralLoc, diag::err_attribute_section_invalid_for_target)\n        << toString(std::move(E));\n    return;\n  }\n\n  SectionAttr *NewAttr = S.mergeSectionAttr(D, AL, Str);\n  if (NewAttr) {\n    D->addAttr(NewAttr);\n    if (isa<FunctionDecl, FunctionTemplateDecl, ObjCMethodDecl,\n            ObjCPropertyDecl>(D))\n      S.UnifySection(NewAttr->getName(),\n                     ASTContext::PSF_Execute | ASTContext::PSF_Read,\n                     cast<NamedDecl>(D));\n  }\n}\n\n// This is used for `__declspec(code_seg(\"segname\"))` on a decl.\n// `#pragma code_seg(\"segname\")` uses checkSectionName() instead.\nstatic bool checkCodeSegName(Sema &S, SourceLocation LiteralLoc,\n                             StringRef CodeSegName) {\n  if (llvm::Error E =\n          S.Context.getTargetInfo().isValidSectionSpecifier(CodeSegName)) {\n    S.Diag(LiteralLoc, diag::err_attribute_section_invalid_for_target)\n        << toString(std::move(E)) << 0 /*'code-seg'*/;\n    return false;\n  }\n\n  return true;\n}\n\nCodeSegAttr *Sema::mergeCodeSegAttr(Decl *D, const AttributeCommonInfo &CI,\n                                    StringRef Name) {\n  // Explicit or partial specializations do not inherit\n  // the code_seg attribute from the primary template.\n  if (const auto *FD = dyn_cast<FunctionDecl>(D)) {\n    if (FD->isFunctionTemplateSpecialization())\n      return nullptr;\n  }\n  if (const auto *ExistingAttr = D->getAttr<CodeSegAttr>()) {\n    if (ExistingAttr->getName() == Name)\n      return nullptr;\n    Diag(ExistingAttr->getLocation(), diag::warn_mismatched_section)\n         << 0 /*codeseg*/;\n    Diag(CI.getLoc(), diag::note_previous_attribute);\n    return nullptr;\n  }\n  return ::new (Context) CodeSegAttr(Context, CI, Name);\n}\n\nstatic void handleCodeSegAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  StringRef Str;\n  SourceLocation LiteralLoc;\n  if (!S.checkStringLiteralArgumentAttr(AL, 0, Str, &LiteralLoc))\n    return;\n  if (!checkCodeSegName(S, LiteralLoc, Str))\n    return;\n  if (const auto *ExistingAttr = D->getAttr<CodeSegAttr>()) {\n    if (!ExistingAttr->isImplicit()) {\n      S.Diag(AL.getLoc(),\n             ExistingAttr->getName() == Str\n             ? diag::warn_duplicate_codeseg_attribute\n             : diag::err_conflicting_codeseg_attribute);\n      return;\n    }\n    D->dropAttr<CodeSegAttr>();\n  }\n  if (CodeSegAttr *CSA = S.mergeCodeSegAttr(D, AL, Str))\n    D->addAttr(CSA);\n}\n\n// Check for things we'd like to warn about. Multiversioning issues are\n// handled later in the process, once we know how many exist.\nbool Sema::checkTargetAttr(SourceLocation LiteralLoc, StringRef AttrStr) {\n  enum FirstParam { Unsupported, Duplicate, Unknown };\n  enum SecondParam { None, Architecture, Tune };\n  if (AttrStr.find(\"fpmath=\") != StringRef::npos)\n    return Diag(LiteralLoc, diag::warn_unsupported_target_attribute)\n           << Unsupported << None << \"fpmath=\";\n\n  // Diagnose use of tune if target doesn't support it.\n  if (!Context.getTargetInfo().supportsTargetAttributeTune() &&\n      AttrStr.find(\"tune=\") != StringRef::npos)\n    return Diag(LiteralLoc, diag::warn_unsupported_target_attribute)\n           << Unsupported << None << \"tune=\";\n\n  ParsedTargetAttr ParsedAttrs = TargetAttr::parse(AttrStr);\n\n  if (!ParsedAttrs.Architecture.empty() &&\n      !Context.getTargetInfo().isValidCPUName(ParsedAttrs.Architecture))\n    return Diag(LiteralLoc, diag::warn_unsupported_target_attribute)\n           << Unknown << Architecture << ParsedAttrs.Architecture;\n\n  if (!ParsedAttrs.Tune.empty() &&\n      !Context.getTargetInfo().isValidCPUName(ParsedAttrs.Tune))\n    return Diag(LiteralLoc, diag::warn_unsupported_target_attribute)\n           << Unknown << Tune << ParsedAttrs.Tune;\n\n  if (ParsedAttrs.DuplicateArchitecture)\n    return Diag(LiteralLoc, diag::warn_unsupported_target_attribute)\n           << Duplicate << None << \"arch=\";\n  if (ParsedAttrs.DuplicateTune)\n    return Diag(LiteralLoc, diag::warn_unsupported_target_attribute)\n           << Duplicate << None << \"tune=\";\n\n  for (const auto &Feature : ParsedAttrs.Features) {\n    auto CurFeature = StringRef(Feature).drop_front(); // remove + or -.\n    if (!Context.getTargetInfo().isValidFeatureName(CurFeature))\n      return Diag(LiteralLoc, diag::warn_unsupported_target_attribute)\n             << Unsupported << None << CurFeature;\n  }\n\n  TargetInfo::BranchProtectionInfo BPI;\n  StringRef Error;\n  if (!ParsedAttrs.BranchProtection.empty() &&\n      !Context.getTargetInfo().validateBranchProtection(\n          ParsedAttrs.BranchProtection, BPI, Error)) {\n    if (Error.empty())\n      return Diag(LiteralLoc, diag::warn_unsupported_target_attribute)\n             << Unsupported << None << \"branch-protection\";\n    else\n      return Diag(LiteralLoc, diag::err_invalid_branch_protection_spec)\n             << Error;\n  }\n\n  return false;\n}\n\nstatic void handleTargetAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  StringRef Str;\n  SourceLocation LiteralLoc;\n  if (!S.checkStringLiteralArgumentAttr(AL, 0, Str, &LiteralLoc) ||\n      S.checkTargetAttr(LiteralLoc, Str))\n    return;\n\n  TargetAttr *NewAttr = ::new (S.Context) TargetAttr(S.Context, AL, Str);\n  D->addAttr(NewAttr);\n}\n\nstatic void handleMinVectorWidthAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  Expr *E = AL.getArgAsExpr(0);\n  uint32_t VecWidth;\n  if (!checkUInt32Argument(S, AL, E, VecWidth)) {\n    AL.setInvalid();\n    return;\n  }\n\n  MinVectorWidthAttr *Existing = D->getAttr<MinVectorWidthAttr>();\n  if (Existing && Existing->getVectorWidth() != VecWidth) {\n    S.Diag(AL.getLoc(), diag::warn_duplicate_attribute) << AL;\n    return;\n  }\n\n  D->addAttr(::new (S.Context) MinVectorWidthAttr(S.Context, AL, VecWidth));\n}\n\nstatic void handleCleanupAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  Expr *E = AL.getArgAsExpr(0);\n  SourceLocation Loc = E->getExprLoc();\n  FunctionDecl *FD = nullptr;\n  DeclarationNameInfo NI;\n\n  // gcc only allows for simple identifiers. Since we support more than gcc, we\n  // will warn the user.\n  if (auto *DRE = dyn_cast<DeclRefExpr>(E)) {\n    if (DRE->hasQualifier())\n      S.Diag(Loc, diag::warn_cleanup_ext);\n    FD = dyn_cast<FunctionDecl>(DRE->getDecl());\n    NI = DRE->getNameInfo();\n    if (!FD) {\n      S.Diag(Loc, diag::err_attribute_cleanup_arg_not_function) << 1\n        << NI.getName();\n      return;\n    }\n  } else if (auto *ULE = dyn_cast<UnresolvedLookupExpr>(E)) {\n    if (ULE->hasExplicitTemplateArgs())\n      S.Diag(Loc, diag::warn_cleanup_ext);\n    FD = S.ResolveSingleFunctionTemplateSpecialization(ULE, true);\n    NI = ULE->getNameInfo();\n    if (!FD) {\n      S.Diag(Loc, diag::err_attribute_cleanup_arg_not_function) << 2\n        << NI.getName();\n      if (ULE->getType() == S.Context.OverloadTy)\n        S.NoteAllOverloadCandidates(ULE);\n      return;\n    }\n  } else {\n    S.Diag(Loc, diag::err_attribute_cleanup_arg_not_function) << 0;\n    return;\n  }\n\n  if (FD->getNumParams() != 1) {\n    S.Diag(Loc, diag::err_attribute_cleanup_func_must_take_one_arg)\n      << NI.getName();\n    return;\n  }\n\n  // We're currently more strict than GCC about what function types we accept.\n  // If this ever proves to be a problem it should be easy to fix.\n  QualType Ty = S.Context.getPointerType(cast<VarDecl>(D)->getType());\n  QualType ParamTy = FD->getParamDecl(0)->getType();\n  if (S.CheckAssignmentConstraints(FD->getParamDecl(0)->getLocation(),\n                                   ParamTy, Ty) != Sema::Compatible) {\n    S.Diag(Loc, diag::err_attribute_cleanup_func_arg_incompatible_type)\n      << NI.getName() << ParamTy << Ty;\n    return;\n  }\n\n  D->addAttr(::new (S.Context) CleanupAttr(S.Context, AL, FD));\n}\n\nstatic void handleEnumExtensibilityAttr(Sema &S, Decl *D,\n                                        const ParsedAttr &AL) {\n  if (!AL.isArgIdent(0)) {\n    S.Diag(AL.getLoc(), diag::err_attribute_argument_n_type)\n        << AL << 0 << AANT_ArgumentIdentifier;\n    return;\n  }\n\n  EnumExtensibilityAttr::Kind ExtensibilityKind;\n  IdentifierInfo *II = AL.getArgAsIdent(0)->Ident;\n  if (!EnumExtensibilityAttr::ConvertStrToKind(II->getName(),\n                                               ExtensibilityKind)) {\n    S.Diag(AL.getLoc(), diag::warn_attribute_type_not_supported) << AL << II;\n    return;\n  }\n\n  D->addAttr(::new (S.Context)\n                 EnumExtensibilityAttr(S.Context, AL, ExtensibilityKind));\n}\n\n/// Handle __attribute__((format_arg((idx)))) attribute based on\n/// http://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html\nstatic void handleFormatArgAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  Expr *IdxExpr = AL.getArgAsExpr(0);\n  ParamIdx Idx;\n  if (!checkFunctionOrMethodParameterIndex(S, D, AL, 1, IdxExpr, Idx))\n    return;\n\n  // Make sure the format string is really a string.\n  QualType Ty = getFunctionOrMethodParamType(D, Idx.getASTIndex());\n\n  bool NotNSStringTy = !isNSStringType(Ty, S.Context);\n  if (NotNSStringTy &&\n      !isCFStringType(Ty, S.Context) &&\n      (!Ty->isPointerType() ||\n       !Ty->castAs<PointerType>()->getPointeeType()->isCharType())) {\n    S.Diag(AL.getLoc(), diag::err_format_attribute_not)\n        << \"a string type\" << IdxExpr->getSourceRange()\n        << getFunctionOrMethodParamRange(D, 0);\n    return;\n  }\n  Ty = getFunctionOrMethodResultType(D);\n  if (!isNSStringType(Ty, S.Context, /*AllowNSAttributedString=*/true) &&\n      !isCFStringType(Ty, S.Context) &&\n      (!Ty->isPointerType() ||\n       !Ty->castAs<PointerType>()->getPointeeType()->isCharType())) {\n    S.Diag(AL.getLoc(), diag::err_format_attribute_result_not)\n        << (NotNSStringTy ? \"string type\" : \"NSString\")\n        << IdxExpr->getSourceRange() << getFunctionOrMethodParamRange(D, 0);\n    return;\n  }\n\n  D->addAttr(::new (S.Context) FormatArgAttr(S.Context, AL, Idx));\n}\n\nenum FormatAttrKind {\n  CFStringFormat,\n  NSStringFormat,\n  StrftimeFormat,\n  SupportedFormat,\n  IgnoredFormat,\n  InvalidFormat\n};\n\n/// getFormatAttrKind - Map from format attribute names to supported format\n/// types.\nstatic FormatAttrKind getFormatAttrKind(StringRef Format) {\n  return llvm::StringSwitch<FormatAttrKind>(Format)\n      // Check for formats that get handled specially.\n      .Case(\"NSString\", NSStringFormat)\n      .Case(\"CFString\", CFStringFormat)\n      .Case(\"strftime\", StrftimeFormat)\n\n      // Otherwise, check for supported formats.\n      .Cases(\"scanf\", \"printf\", \"printf0\", \"strfmon\", SupportedFormat)\n      .Cases(\"cmn_err\", \"vcmn_err\", \"zcmn_err\", SupportedFormat)\n      .Case(\"kprintf\", SupportedFormat)         // OpenBSD.\n      .Case(\"freebsd_kprintf\", SupportedFormat) // FreeBSD.\n      .Case(\"os_trace\", SupportedFormat)\n      .Case(\"os_log\", SupportedFormat)\n\n      .Cases(\"gcc_diag\", \"gcc_cdiag\", \"gcc_cxxdiag\", \"gcc_tdiag\", IgnoredFormat)\n      .Default(InvalidFormat);\n}\n\n/// Handle __attribute__((init_priority(priority))) attributes based on\n/// http://gcc.gnu.org/onlinedocs/gcc/C_002b_002b-Attributes.html\nstatic void handleInitPriorityAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  if (!S.getLangOpts().CPlusPlus) {\n    S.Diag(AL.getLoc(), diag::warn_attribute_ignored) << AL;\n    return;\n  }\n\n  if (S.getCurFunctionOrMethodDecl()) {\n    S.Diag(AL.getLoc(), diag::err_init_priority_object_attr);\n    AL.setInvalid();\n    return;\n  }\n  QualType T = cast<VarDecl>(D)->getType();\n  if (S.Context.getAsArrayType(T))\n    T = S.Context.getBaseElementType(T);\n  if (!T->getAs<RecordType>()) {\n    S.Diag(AL.getLoc(), diag::err_init_priority_object_attr);\n    AL.setInvalid();\n    return;\n  }\n\n  Expr *E = AL.getArgAsExpr(0);\n  uint32_t prioritynum;\n  if (!checkUInt32Argument(S, AL, E, prioritynum)) {\n    AL.setInvalid();\n    return;\n  }\n\n  // Only perform the priority check if the attribute is outside of a system\n  // header. Values <= 100 are reserved for the implementation, and libc++\n  // benefits from being able to specify values in that range.\n  if ((prioritynum < 101 || prioritynum > 65535) &&\n      !S.getSourceManager().isInSystemHeader(AL.getLoc())) {\n    S.Diag(AL.getLoc(), diag::err_attribute_argument_out_of_range)\n        << E->getSourceRange() << AL << 101 << 65535;\n    AL.setInvalid();\n    return;\n  }\n  D->addAttr(::new (S.Context) InitPriorityAttr(S.Context, AL, prioritynum));\n}\n\nFormatAttr *Sema::mergeFormatAttr(Decl *D, const AttributeCommonInfo &CI,\n                                  IdentifierInfo *Format, int FormatIdx,\n                                  int FirstArg) {\n  // Check whether we already have an equivalent format attribute.\n  for (auto *F : D->specific_attrs<FormatAttr>()) {\n    if (F->getType() == Format &&\n        F->getFormatIdx() == FormatIdx &&\n        F->getFirstArg() == FirstArg) {\n      // If we don't have a valid location for this attribute, adopt the\n      // location.\n      if (F->getLocation().isInvalid())\n        F->setRange(CI.getRange());\n      return nullptr;\n    }\n  }\n\n  return ::new (Context) FormatAttr(Context, CI, Format, FormatIdx, FirstArg);\n}\n\n/// Handle __attribute__((format(type,idx,firstarg))) attributes based on\n/// http://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html\nstatic void handleFormatAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  if (!AL.isArgIdent(0)) {\n    S.Diag(AL.getLoc(), diag::err_attribute_argument_n_type)\n        << AL << 1 << AANT_ArgumentIdentifier;\n    return;\n  }\n\n  // In C++ the implicit 'this' function parameter also counts, and they are\n  // counted from one.\n  bool HasImplicitThisParam = isInstanceMethod(D);\n  unsigned NumArgs = getFunctionOrMethodNumParams(D) + HasImplicitThisParam;\n\n  IdentifierInfo *II = AL.getArgAsIdent(0)->Ident;\n  StringRef Format = II->getName();\n\n  if (normalizeName(Format)) {\n    // If we've modified the string name, we need a new identifier for it.\n    II = &S.Context.Idents.get(Format);\n  }\n\n  // Check for supported formats.\n  FormatAttrKind Kind = getFormatAttrKind(Format);\n\n  if (Kind == IgnoredFormat)\n    return;\n\n  if (Kind == InvalidFormat) {\n    S.Diag(AL.getLoc(), diag::warn_attribute_type_not_supported)\n        << AL << II->getName();\n    return;\n  }\n\n  // checks for the 2nd argument\n  Expr *IdxExpr = AL.getArgAsExpr(1);\n  uint32_t Idx;\n  if (!checkUInt32Argument(S, AL, IdxExpr, Idx, 2))\n    return;\n\n  if (Idx < 1 || Idx > NumArgs) {\n    S.Diag(AL.getLoc(), diag::err_attribute_argument_out_of_bounds)\n        << AL << 2 << IdxExpr->getSourceRange();\n    return;\n  }\n\n  // FIXME: Do we need to bounds check?\n  unsigned ArgIdx = Idx - 1;\n\n  if (HasImplicitThisParam) {\n    if (ArgIdx == 0) {\n      S.Diag(AL.getLoc(),\n             diag::err_format_attribute_implicit_this_format_string)\n        << IdxExpr->getSourceRange();\n      return;\n    }\n    ArgIdx--;\n  }\n\n  // make sure the format string is really a string\n  QualType Ty = getFunctionOrMethodParamType(D, ArgIdx);\n\n  if (Kind == CFStringFormat) {\n    if (!isCFStringType(Ty, S.Context)) {\n      S.Diag(AL.getLoc(), diag::err_format_attribute_not)\n        << \"a CFString\" << IdxExpr->getSourceRange()\n        << getFunctionOrMethodParamRange(D, ArgIdx);\n      return;\n    }\n  } else if (Kind == NSStringFormat) {\n    // FIXME: do we need to check if the type is NSString*?  What are the\n    // semantics?\n    if (!isNSStringType(Ty, S.Context)) {\n      S.Diag(AL.getLoc(), diag::err_format_attribute_not)\n        << \"an NSString\" << IdxExpr->getSourceRange()\n        << getFunctionOrMethodParamRange(D, ArgIdx);\n      return;\n    }\n  } else if (!Ty->isPointerType() ||\n             !Ty->castAs<PointerType>()->getPointeeType()->isCharType()) {\n    S.Diag(AL.getLoc(), diag::err_format_attribute_not)\n      << \"a string type\" << IdxExpr->getSourceRange()\n      << getFunctionOrMethodParamRange(D, ArgIdx);\n    return;\n  }\n\n  // check the 3rd argument\n  Expr *FirstArgExpr = AL.getArgAsExpr(2);\n  uint32_t FirstArg;\n  if (!checkUInt32Argument(S, AL, FirstArgExpr, FirstArg, 3))\n    return;\n\n  // check if the function is variadic if the 3rd argument non-zero\n  if (FirstArg != 0) {\n    if (isFunctionOrMethodVariadic(D)) {\n      ++NumArgs; // +1 for ...\n    } else {\n      S.Diag(D->getLocation(), diag::err_format_attribute_requires_variadic);\n      return;\n    }\n  }\n\n  // strftime requires FirstArg to be 0 because it doesn't read from any\n  // variable the input is just the current time + the format string.\n  if (Kind == StrftimeFormat) {\n    if (FirstArg != 0) {\n      S.Diag(AL.getLoc(), diag::err_format_strftime_third_parameter)\n        << FirstArgExpr->getSourceRange();\n      return;\n    }\n  // if 0 it disables parameter checking (to use with e.g. va_list)\n  } else if (FirstArg != 0 && FirstArg != NumArgs) {\n    S.Diag(AL.getLoc(), diag::err_attribute_argument_out_of_bounds)\n        << AL << 3 << FirstArgExpr->getSourceRange();\n    return;\n  }\n\n  FormatAttr *NewAttr = S.mergeFormatAttr(D, AL, II, Idx, FirstArg);\n  if (NewAttr)\n    D->addAttr(NewAttr);\n}\n\n/// Handle __attribute__((callback(CalleeIdx, PayloadIdx0, ...))) attributes.\nstatic void handleCallbackAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  // The index that identifies the callback callee is mandatory.\n  if (AL.getNumArgs() == 0) {\n    S.Diag(AL.getLoc(), diag::err_callback_attribute_no_callee)\n        << AL.getRange();\n    return;\n  }\n\n  bool HasImplicitThisParam = isInstanceMethod(D);\n  int32_t NumArgs = getFunctionOrMethodNumParams(D);\n\n  FunctionDecl *FD = D->getAsFunction();\n  assert(FD && \"Expected a function declaration!\");\n\n  llvm::StringMap<int> NameIdxMapping;\n  NameIdxMapping[\"__\"] = -1;\n\n  NameIdxMapping[\"this\"] = 0;\n\n  int Idx = 1;\n  for (const ParmVarDecl *PVD : FD->parameters())\n    NameIdxMapping[PVD->getName()] = Idx++;\n\n  auto UnknownName = NameIdxMapping.end();\n\n  SmallVector<int, 8> EncodingIndices;\n  for (unsigned I = 0, E = AL.getNumArgs(); I < E; ++I) {\n    SourceRange SR;\n    int32_t ArgIdx;\n\n    if (AL.isArgIdent(I)) {\n      IdentifierLoc *IdLoc = AL.getArgAsIdent(I);\n      auto It = NameIdxMapping.find(IdLoc->Ident->getName());\n      if (It == UnknownName) {\n        S.Diag(AL.getLoc(), diag::err_callback_attribute_argument_unknown)\n            << IdLoc->Ident << IdLoc->Loc;\n        return;\n      }\n\n      SR = SourceRange(IdLoc->Loc);\n      ArgIdx = It->second;\n    } else if (AL.isArgExpr(I)) {\n      Expr *IdxExpr = AL.getArgAsExpr(I);\n\n      // If the expression is not parseable as an int32_t we have a problem.\n      if (!checkUInt32Argument(S, AL, IdxExpr, (uint32_t &)ArgIdx, I + 1,\n                               false)) {\n        S.Diag(AL.getLoc(), diag::err_attribute_argument_out_of_bounds)\n            << AL << (I + 1) << IdxExpr->getSourceRange();\n        return;\n      }\n\n      // Check oob, excluding the special values, 0 and -1.\n      if (ArgIdx < -1 || ArgIdx > NumArgs) {\n        S.Diag(AL.getLoc(), diag::err_attribute_argument_out_of_bounds)\n            << AL << (I + 1) << IdxExpr->getSourceRange();\n        return;\n      }\n\n      SR = IdxExpr->getSourceRange();\n    } else {\n      llvm_unreachable(\"Unexpected ParsedAttr argument type!\");\n    }\n\n    if (ArgIdx == 0 && !HasImplicitThisParam) {\n      S.Diag(AL.getLoc(), diag::err_callback_implicit_this_not_available)\n          << (I + 1) << SR;\n      return;\n    }\n\n    // Adjust for the case we do not have an implicit \"this\" parameter. In this\n    // case we decrease all positive values by 1 to get LLVM argument indices.\n    if (!HasImplicitThisParam && ArgIdx > 0)\n      ArgIdx -= 1;\n\n    EncodingIndices.push_back(ArgIdx);\n  }\n\n  int CalleeIdx = EncodingIndices.front();\n  // Check if the callee index is proper, thus not \"this\" and not \"unknown\".\n  // This means the \"CalleeIdx\" has to be non-negative if \"HasImplicitThisParam\"\n  // is false and positive if \"HasImplicitThisParam\" is true.\n  if (CalleeIdx < (int)HasImplicitThisParam) {\n    S.Diag(AL.getLoc(), diag::err_callback_attribute_invalid_callee)\n        << AL.getRange();\n    return;\n  }\n\n  // Get the callee type, note the index adjustment as the AST doesn't contain\n  // the this type (which the callee cannot reference anyway!).\n  const Type *CalleeType =\n      getFunctionOrMethodParamType(D, CalleeIdx - HasImplicitThisParam)\n          .getTypePtr();\n  if (!CalleeType || !CalleeType->isFunctionPointerType()) {\n    S.Diag(AL.getLoc(), diag::err_callback_callee_no_function_type)\n        << AL.getRange();\n    return;\n  }\n\n  const Type *CalleeFnType =\n      CalleeType->getPointeeType()->getUnqualifiedDesugaredType();\n\n  // TODO: Check the type of the callee arguments.\n\n  const auto *CalleeFnProtoType = dyn_cast<FunctionProtoType>(CalleeFnType);\n  if (!CalleeFnProtoType) {\n    S.Diag(AL.getLoc(), diag::err_callback_callee_no_function_type)\n        << AL.getRange();\n    return;\n  }\n\n  if (CalleeFnProtoType->getNumParams() > EncodingIndices.size() - 1) {\n    S.Diag(AL.getLoc(), diag::err_attribute_wrong_number_arguments)\n        << AL << (unsigned)(EncodingIndices.size() - 1);\n    return;\n  }\n\n  if (CalleeFnProtoType->getNumParams() < EncodingIndices.size() - 1) {\n    S.Diag(AL.getLoc(), diag::err_attribute_wrong_number_arguments)\n        << AL << (unsigned)(EncodingIndices.size() - 1);\n    return;\n  }\n\n  if (CalleeFnProtoType->isVariadic()) {\n    S.Diag(AL.getLoc(), diag::err_callback_callee_is_variadic) << AL.getRange();\n    return;\n  }\n\n  // Do not allow multiple callback attributes.\n  if (D->hasAttr<CallbackAttr>()) {\n    S.Diag(AL.getLoc(), diag::err_callback_attribute_multiple) << AL.getRange();\n    return;\n  }\n\n  D->addAttr(::new (S.Context) CallbackAttr(\n      S.Context, AL, EncodingIndices.data(), EncodingIndices.size()));\n}\n\nstatic bool isFunctionLike(const Type &T) {\n  // Check for explicit function types.\n  // 'called_once' is only supported in Objective-C and it has\n  // function pointers and block pointers.\n  return T.isFunctionPointerType() || T.isBlockPointerType();\n}\n\n/// Handle 'called_once' attribute.\nstatic void handleCalledOnceAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  // 'called_once' only applies to parameters representing functions.\n  QualType T = cast<ParmVarDecl>(D)->getType();\n\n  if (!isFunctionLike(*T)) {\n    S.Diag(AL.getLoc(), diag::err_called_once_attribute_wrong_type);\n    return;\n  }\n\n  D->addAttr(::new (S.Context) CalledOnceAttr(S.Context, AL));\n}\n\nstatic void handleTransparentUnionAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  // Try to find the underlying union declaration.\n  RecordDecl *RD = nullptr;\n  const auto *TD = dyn_cast<TypedefNameDecl>(D);\n  if (TD && TD->getUnderlyingType()->isUnionType())\n    RD = TD->getUnderlyingType()->getAsUnionType()->getDecl();\n  else\n    RD = dyn_cast<RecordDecl>(D);\n\n  if (!RD || !RD->isUnion()) {\n    S.Diag(AL.getLoc(), diag::warn_attribute_wrong_decl_type) << AL\n                                                              << ExpectedUnion;\n    return;\n  }\n\n  if (!RD->isCompleteDefinition()) {\n    if (!RD->isBeingDefined())\n      S.Diag(AL.getLoc(),\n             diag::warn_transparent_union_attribute_not_definition);\n    return;\n  }\n\n  RecordDecl::field_iterator Field = RD->field_begin(),\n                          FieldEnd = RD->field_end();\n  if (Field == FieldEnd) {\n    S.Diag(AL.getLoc(), diag::warn_transparent_union_attribute_zero_fields);\n    return;\n  }\n\n  FieldDecl *FirstField = *Field;\n  QualType FirstType = FirstField->getType();\n  if (FirstType->hasFloatingRepresentation() || FirstType->isVectorType()) {\n    S.Diag(FirstField->getLocation(),\n           diag::warn_transparent_union_attribute_floating)\n      << FirstType->isVectorType() << FirstType;\n    return;\n  }\n\n  if (FirstType->isIncompleteType())\n    return;\n  uint64_t FirstSize = S.Context.getTypeSize(FirstType);\n  uint64_t FirstAlign = S.Context.getTypeAlign(FirstType);\n  for (; Field != FieldEnd; ++Field) {\n    QualType FieldType = Field->getType();\n    if (FieldType->isIncompleteType())\n      return;\n    // FIXME: this isn't fully correct; we also need to test whether the\n    // members of the union would all have the same calling convention as the\n    // first member of the union. Checking just the size and alignment isn't\n    // sufficient (consider structs passed on the stack instead of in registers\n    // as an example).\n    if (S.Context.getTypeSize(FieldType) != FirstSize ||\n        S.Context.getTypeAlign(FieldType) > FirstAlign) {\n      // Warn if we drop the attribute.\n      bool isSize = S.Context.getTypeSize(FieldType) != FirstSize;\n      unsigned FieldBits = isSize ? S.Context.getTypeSize(FieldType)\n                                  : S.Context.getTypeAlign(FieldType);\n      S.Diag(Field->getLocation(),\n             diag::warn_transparent_union_attribute_field_size_align)\n          << isSize << *Field << FieldBits;\n      unsigned FirstBits = isSize ? FirstSize : FirstAlign;\n      S.Diag(FirstField->getLocation(),\n             diag::note_transparent_union_first_field_size_align)\n          << isSize << FirstBits;\n      return;\n    }\n  }\n\n  RD->addAttr(::new (S.Context) TransparentUnionAttr(S.Context, AL));\n}\n\nvoid Sema::AddAnnotationAttr(Decl *D, const AttributeCommonInfo &CI,\n                             StringRef Str, MutableArrayRef<Expr *> Args) {\n  auto *Attr = AnnotateAttr::Create(Context, Str, Args.data(), Args.size(), CI);\n  llvm::SmallVector<PartialDiagnosticAt, 8> Notes;\n  for (unsigned Idx = 0; Idx < Attr->args_size(); Idx++) {\n    Expr *&E = Attr->args_begin()[Idx];\n    assert(E && \"error are handled before\");\n    if (E->isValueDependent() || E->isTypeDependent())\n      continue;\n\n    if (E->getType()->isArrayType())\n      E = ImpCastExprToType(E, Context.getPointerType(E->getType()),\n                            clang::CK_ArrayToPointerDecay)\n              .get();\n    if (E->getType()->isFunctionType())\n      E = ImplicitCastExpr::Create(Context,\n                                   Context.getPointerType(E->getType()),\n                                   clang::CK_FunctionToPointerDecay, E, nullptr,\n                                   VK_RValue, FPOptionsOverride());\n    if (E->isLValue())\n      E = ImplicitCastExpr::Create(Context, E->getType().getNonReferenceType(),\n                                   clang::CK_LValueToRValue, E, nullptr,\n                                   VK_RValue, FPOptionsOverride());\n\n    Expr::EvalResult Eval;\n    Notes.clear();\n    Eval.Diag = &Notes;\n\n    bool Result =\n        E->EvaluateAsConstantExpr(Eval, Context);\n\n    /// Result means the expression can be folded to a constant.\n    /// Note.empty() means the expression is a valid constant expression in the\n    /// current language mode.\n    if (!Result || !Notes.empty()) {\n      Diag(E->getBeginLoc(), diag::err_attribute_argument_n_type)\n          << CI << (Idx + 1) << AANT_ArgumentConstantExpr;\n      for (auto &Note : Notes)\n        Diag(Note.first, Note.second);\n      return;\n    }\n    assert(Eval.Val.hasValue());\n    E = ConstantExpr::Create(Context, E, Eval.Val);\n  }\n  D->addAttr(Attr);\n}\n\nstatic void handleAnnotateAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  // Make sure that there is a string literal as the annotation's first\n  // argument.\n  StringRef Str;\n  if (!S.checkStringLiteralArgumentAttr(AL, 0, Str))\n    return;\n\n  llvm::SmallVector<Expr *, 4> Args;\n  Args.reserve(AL.getNumArgs() - 1);\n  for (unsigned Idx = 1; Idx < AL.getNumArgs(); Idx++) {\n    assert(!AL.isArgIdent(Idx));\n    Args.push_back(AL.getArgAsExpr(Idx));\n  }\n\n  S.AddAnnotationAttr(D, AL, Str, Args);\n}\n\nstatic void handleAlignValueAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  S.AddAlignValueAttr(D, AL, AL.getArgAsExpr(0));\n}\n\nvoid Sema::AddAlignValueAttr(Decl *D, const AttributeCommonInfo &CI, Expr *E) {\n  AlignValueAttr TmpAttr(Context, CI, E);\n  SourceLocation AttrLoc = CI.getLoc();\n\n  QualType T;\n  if (const auto *TD = dyn_cast<TypedefNameDecl>(D))\n    T = TD->getUnderlyingType();\n  else if (const auto *VD = dyn_cast<ValueDecl>(D))\n    T = VD->getType();\n  else\n    llvm_unreachable(\"Unknown decl type for align_value\");\n\n  if (!T->isDependentType() && !T->isAnyPointerType() &&\n      !T->isReferenceType() && !T->isMemberPointerType()) {\n    Diag(AttrLoc, diag::warn_attribute_pointer_or_reference_only)\n      << &TmpAttr << T << D->getSourceRange();\n    return;\n  }\n\n  if (!E->isValueDependent()) {\n    llvm::APSInt Alignment;\n    ExprResult ICE = VerifyIntegerConstantExpression(\n        E, &Alignment, diag::err_align_value_attribute_argument_not_int);\n    if (ICE.isInvalid())\n      return;\n\n    if (!Alignment.isPowerOf2()) {\n      Diag(AttrLoc, diag::err_alignment_not_power_of_two)\n        << E->getSourceRange();\n      return;\n    }\n\n    D->addAttr(::new (Context) AlignValueAttr(Context, CI, ICE.get()));\n    return;\n  }\n\n  // Save dependent expressions in the AST to be instantiated.\n  D->addAttr(::new (Context) AlignValueAttr(Context, CI, E));\n}\n\nstatic void handleAlignedAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  // check the attribute arguments.\n  if (AL.getNumArgs() > 1) {\n    S.Diag(AL.getLoc(), diag::err_attribute_wrong_number_arguments) << AL << 1;\n    return;\n  }\n\n  if (AL.getNumArgs() == 0) {\n    D->addAttr(::new (S.Context) AlignedAttr(S.Context, AL, true, nullptr));\n    return;\n  }\n\n  Expr *E = AL.getArgAsExpr(0);\n  if (AL.isPackExpansion() && !E->containsUnexpandedParameterPack()) {\n    S.Diag(AL.getEllipsisLoc(),\n           diag::err_pack_expansion_without_parameter_packs);\n    return;\n  }\n\n  if (!AL.isPackExpansion() && S.DiagnoseUnexpandedParameterPack(E))\n    return;\n\n  S.AddAlignedAttr(D, AL, E, AL.isPackExpansion());\n}\n\nvoid Sema::AddAlignedAttr(Decl *D, const AttributeCommonInfo &CI, Expr *E,\n                          bool IsPackExpansion) {\n  AlignedAttr TmpAttr(Context, CI, true, E);\n  SourceLocation AttrLoc = CI.getLoc();\n\n  // C++11 alignas(...) and C11 _Alignas(...) have additional requirements.\n  if (TmpAttr.isAlignas()) {\n    // C++11 [dcl.align]p1:\n    //   An alignment-specifier may be applied to a variable or to a class\n    //   data member, but it shall not be applied to a bit-field, a function\n    //   parameter, the formal parameter of a catch clause, or a variable\n    //   declared with the register storage class specifier. An\n    //   alignment-specifier may also be applied to the declaration of a class\n    //   or enumeration type.\n    // C11 6.7.5/2:\n    //   An alignment attribute shall not be specified in a declaration of\n    //   a typedef, or a bit-field, or a function, or a parameter, or an\n    //   object declared with the register storage-class specifier.\n    int DiagKind = -1;\n    if (isa<ParmVarDecl>(D)) {\n      DiagKind = 0;\n    } else if (const auto *VD = dyn_cast<VarDecl>(D)) {\n      if (VD->getStorageClass() == SC_Register)\n        DiagKind = 1;\n      if (VD->isExceptionVariable())\n        DiagKind = 2;\n    } else if (const auto *FD = dyn_cast<FieldDecl>(D)) {\n      if (FD->isBitField())\n        DiagKind = 3;\n    } else if (!isa<TagDecl>(D)) {\n      Diag(AttrLoc, diag::err_attribute_wrong_decl_type) << &TmpAttr\n        << (TmpAttr.isC11() ? ExpectedVariableOrField\n                            : ExpectedVariableFieldOrTag);\n      return;\n    }\n    if (DiagKind != -1) {\n      Diag(AttrLoc, diag::err_alignas_attribute_wrong_decl_type)\n        << &TmpAttr << DiagKind;\n      return;\n    }\n  }\n\n  if (E->isValueDependent()) {\n    // We can't support a dependent alignment on a non-dependent type,\n    // because we have no way to model that a type is \"alignment-dependent\"\n    // but not dependent in any other way.\n    if (const auto *TND = dyn_cast<TypedefNameDecl>(D)) {\n      if (!TND->getUnderlyingType()->isDependentType()) {\n        Diag(AttrLoc, diag::err_alignment_dependent_typedef_name)\n            << E->getSourceRange();\n        return;\n      }\n    }\n\n    // Save dependent expressions in the AST to be instantiated.\n    AlignedAttr *AA = ::new (Context) AlignedAttr(Context, CI, true, E);\n    AA->setPackExpansion(IsPackExpansion);\n    D->addAttr(AA);\n    return;\n  }\n\n  // FIXME: Cache the number on the AL object?\n  llvm::APSInt Alignment;\n  ExprResult ICE = VerifyIntegerConstantExpression(\n      E, &Alignment, diag::err_aligned_attribute_argument_not_int);\n  if (ICE.isInvalid())\n    return;\n\n  uint64_t AlignVal = Alignment.getZExtValue();\n\n  // C++11 [dcl.align]p2:\n  //   -- if the constant expression evaluates to zero, the alignment\n  //      specifier shall have no effect\n  // C11 6.7.5p6:\n  //   An alignment specification of zero has no effect.\n  if (!(TmpAttr.isAlignas() && !Alignment)) {\n    if (!llvm::isPowerOf2_64(AlignVal)) {\n      Diag(AttrLoc, diag::err_alignment_not_power_of_two)\n        << E->getSourceRange();\n      return;\n    }\n  }\n\n  unsigned MaximumAlignment = Sema::MaximumAlignment;\n  if (Context.getTargetInfo().getTriple().isOSBinFormatCOFF())\n    MaximumAlignment = std::min(MaximumAlignment, 8192u);\n  if (AlignVal > MaximumAlignment) {\n    Diag(AttrLoc, diag::err_attribute_aligned_too_great)\n        << MaximumAlignment << E->getSourceRange();\n    return;\n  }\n\n  if (Context.getTargetInfo().isTLSSupported()) {\n    unsigned MaxTLSAlign =\n        Context.toCharUnitsFromBits(Context.getTargetInfo().getMaxTLSAlign())\n            .getQuantity();\n    const auto *VD = dyn_cast<VarDecl>(D);\n    if (MaxTLSAlign && AlignVal > MaxTLSAlign && VD &&\n        VD->getTLSKind() != VarDecl::TLS_None) {\n      Diag(VD->getLocation(), diag::err_tls_var_aligned_over_maximum)\n          << (unsigned)AlignVal << VD << MaxTLSAlign;\n      return;\n    }\n  }\n\n  AlignedAttr *AA = ::new (Context) AlignedAttr(Context, CI, true, ICE.get());\n  AA->setPackExpansion(IsPackExpansion);\n  D->addAttr(AA);\n}\n\nvoid Sema::AddAlignedAttr(Decl *D, const AttributeCommonInfo &CI,\n                          TypeSourceInfo *TS, bool IsPackExpansion) {\n  // FIXME: Cache the number on the AL object if non-dependent?\n  // FIXME: Perform checking of type validity\n  AlignedAttr *AA = ::new (Context) AlignedAttr(Context, CI, false, TS);\n  AA->setPackExpansion(IsPackExpansion);\n  D->addAttr(AA);\n}\n\nvoid Sema::CheckAlignasUnderalignment(Decl *D) {\n  assert(D->hasAttrs() && \"no attributes on decl\");\n\n  QualType UnderlyingTy, DiagTy;\n  if (const auto *VD = dyn_cast<ValueDecl>(D)) {\n    UnderlyingTy = DiagTy = VD->getType();\n  } else {\n    UnderlyingTy = DiagTy = Context.getTagDeclType(cast<TagDecl>(D));\n    if (const auto *ED = dyn_cast<EnumDecl>(D))\n      UnderlyingTy = ED->getIntegerType();\n  }\n  if (DiagTy->isDependentType() || DiagTy->isIncompleteType())\n    return;\n\n  // C++11 [dcl.align]p5, C11 6.7.5/4:\n  //   The combined effect of all alignment attributes in a declaration shall\n  //   not specify an alignment that is less strict than the alignment that\n  //   would otherwise be required for the entity being declared.\n  AlignedAttr *AlignasAttr = nullptr;\n  AlignedAttr *LastAlignedAttr = nullptr;\n  unsigned Align = 0;\n  for (auto *I : D->specific_attrs<AlignedAttr>()) {\n    if (I->isAlignmentDependent())\n      return;\n    if (I->isAlignas())\n      AlignasAttr = I;\n    Align = std::max(Align, I->getAlignment(Context));\n    LastAlignedAttr = I;\n  }\n\n  if (Align && DiagTy->isSizelessType()) {\n    Diag(LastAlignedAttr->getLocation(), diag::err_attribute_sizeless_type)\n        << LastAlignedAttr << DiagTy;\n  } else if (AlignasAttr && Align) {\n    CharUnits RequestedAlign = Context.toCharUnitsFromBits(Align);\n    CharUnits NaturalAlign = Context.getTypeAlignInChars(UnderlyingTy);\n    if (NaturalAlign > RequestedAlign)\n      Diag(AlignasAttr->getLocation(), diag::err_alignas_underaligned)\n        << DiagTy << (unsigned)NaturalAlign.getQuantity();\n  }\n}\n\nbool Sema::checkMSInheritanceAttrOnDefinition(\n    CXXRecordDecl *RD, SourceRange Range, bool BestCase,\n    MSInheritanceModel ExplicitModel) {\n  assert(RD->hasDefinition() && \"RD has no definition!\");\n\n  // We may not have seen base specifiers or any virtual methods yet.  We will\n  // have to wait until the record is defined to catch any mismatches.\n  if (!RD->getDefinition()->isCompleteDefinition())\n    return false;\n\n  // The unspecified model never matches what a definition could need.\n  if (ExplicitModel == MSInheritanceModel::Unspecified)\n    return false;\n\n  if (BestCase) {\n    if (RD->calculateInheritanceModel() == ExplicitModel)\n      return false;\n  } else {\n    if (RD->calculateInheritanceModel() <= ExplicitModel)\n      return false;\n  }\n\n  Diag(Range.getBegin(), diag::err_mismatched_ms_inheritance)\n      << 0 /*definition*/;\n  Diag(RD->getDefinition()->getLocation(), diag::note_defined_here) << RD;\n  return true;\n}\n\n/// parseModeAttrArg - Parses attribute mode string and returns parsed type\n/// attribute.\nstatic void parseModeAttrArg(Sema &S, StringRef Str, unsigned &DestWidth,\n                             bool &IntegerMode, bool &ComplexMode,\n                             bool &ExplicitIEEE) {\n  IntegerMode = true;\n  ComplexMode = false;\n  switch (Str.size()) {\n  case 2:\n    switch (Str[0]) {\n    case 'Q':\n      DestWidth = 8;\n      break;\n    case 'H':\n      DestWidth = 16;\n      break;\n    case 'S':\n      DestWidth = 32;\n      break;\n    case 'D':\n      DestWidth = 64;\n      break;\n    case 'X':\n      DestWidth = 96;\n      break;\n    case 'K': // KFmode - IEEE quad precision (__float128)\n      ExplicitIEEE = true;\n      DestWidth = Str[1] == 'I' ? 0 : 128;\n      break;\n    case 'T':\n      ExplicitIEEE = false;\n      DestWidth = 128;\n      break;\n    }\n    if (Str[1] == 'F') {\n      IntegerMode = false;\n    } else if (Str[1] == 'C') {\n      IntegerMode = false;\n      ComplexMode = true;\n    } else if (Str[1] != 'I') {\n      DestWidth = 0;\n    }\n    break;\n  case 4:\n    // FIXME: glibc uses 'word' to define register_t; this is narrower than a\n    // pointer on PIC16 and other embedded platforms.\n    if (Str == \"word\")\n      DestWidth = S.Context.getTargetInfo().getRegisterWidth();\n    else if (Str == \"byte\")\n      DestWidth = S.Context.getTargetInfo().getCharWidth();\n    break;\n  case 7:\n    if (Str == \"pointer\")\n      DestWidth = S.Context.getTargetInfo().getPointerWidth(0);\n    break;\n  case 11:\n    if (Str == \"unwind_word\")\n      DestWidth = S.Context.getTargetInfo().getUnwindWordWidth();\n    break;\n  }\n}\n\n/// handleModeAttr - This attribute modifies the width of a decl with primitive\n/// type.\n///\n/// Despite what would be logical, the mode attribute is a decl attribute, not a\n/// type attribute: 'int ** __attribute((mode(HI))) *G;' tries to make 'G' be\n/// HImode, not an intermediate pointer.\nstatic void handleModeAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  // This attribute isn't documented, but glibc uses it.  It changes\n  // the width of an int or unsigned int to the specified size.\n  if (!AL.isArgIdent(0)) {\n    S.Diag(AL.getLoc(), diag::err_attribute_argument_type)\n        << AL << AANT_ArgumentIdentifier;\n    return;\n  }\n\n  IdentifierInfo *Name = AL.getArgAsIdent(0)->Ident;\n\n  S.AddModeAttr(D, AL, Name);\n}\n\nvoid Sema::AddModeAttr(Decl *D, const AttributeCommonInfo &CI,\n                       IdentifierInfo *Name, bool InInstantiation) {\n  StringRef Str = Name->getName();\n  normalizeName(Str);\n  SourceLocation AttrLoc = CI.getLoc();\n\n  unsigned DestWidth = 0;\n  bool IntegerMode = true;\n  bool ComplexMode = false;\n  bool ExplicitIEEE = false;\n  llvm::APInt VectorSize(64, 0);\n  if (Str.size() >= 4 && Str[0] == 'V') {\n    // Minimal length of vector mode is 4: 'V' + NUMBER(>=1) + TYPE(>=2).\n    size_t StrSize = Str.size();\n    size_t VectorStringLength = 0;\n    while ((VectorStringLength + 1) < StrSize &&\n           isdigit(Str[VectorStringLength + 1]))\n      ++VectorStringLength;\n    if (VectorStringLength &&\n        !Str.substr(1, VectorStringLength).getAsInteger(10, VectorSize) &&\n        VectorSize.isPowerOf2()) {\n      parseModeAttrArg(*this, Str.substr(VectorStringLength + 1), DestWidth,\n                       IntegerMode, ComplexMode, ExplicitIEEE);\n      // Avoid duplicate warning from template instantiation.\n      if (!InInstantiation)\n        Diag(AttrLoc, diag::warn_vector_mode_deprecated);\n    } else {\n      VectorSize = 0;\n    }\n  }\n\n  if (!VectorSize)\n    parseModeAttrArg(*this, Str, DestWidth, IntegerMode, ComplexMode,\n                     ExplicitIEEE);\n\n  // FIXME: Sync this with InitializePredefinedMacros; we need to match int8_t\n  // and friends, at least with glibc.\n  // FIXME: Make sure floating-point mappings are accurate\n  // FIXME: Support XF and TF types\n  if (!DestWidth) {\n    Diag(AttrLoc, diag::err_machine_mode) << 0 /*Unknown*/ << Name;\n    return;\n  }\n\n  QualType OldTy;\n  if (const auto *TD = dyn_cast<TypedefNameDecl>(D))\n    OldTy = TD->getUnderlyingType();\n  else if (const auto *ED = dyn_cast<EnumDecl>(D)) {\n    // Something like 'typedef enum { X } __attribute__((mode(XX))) T;'.\n    // Try to get type from enum declaration, default to int.\n    OldTy = ED->getIntegerType();\n    if (OldTy.isNull())\n      OldTy = Context.IntTy;\n  } else\n    OldTy = cast<ValueDecl>(D)->getType();\n\n  if (OldTy->isDependentType()) {\n    D->addAttr(::new (Context) ModeAttr(Context, CI, Name));\n    return;\n  }\n\n  // Base type can also be a vector type (see PR17453).\n  // Distinguish between base type and base element type.\n  QualType OldElemTy = OldTy;\n  if (const auto *VT = OldTy->getAs<VectorType>())\n    OldElemTy = VT->getElementType();\n\n  // GCC allows 'mode' attribute on enumeration types (even incomplete), except\n  // for vector modes. So, 'enum X __attribute__((mode(QI)));' forms a complete\n  // type, 'enum { A } __attribute__((mode(V4SI)))' is rejected.\n  if ((isa<EnumDecl>(D) || OldElemTy->getAs<EnumType>()) &&\n      VectorSize.getBoolValue()) {\n    Diag(AttrLoc, diag::err_enum_mode_vector_type) << Name << CI.getRange();\n    return;\n  }\n  bool IntegralOrAnyEnumType = (OldElemTy->isIntegralOrEnumerationType() &&\n                                !OldElemTy->isExtIntType()) ||\n                               OldElemTy->getAs<EnumType>();\n\n  if (!OldElemTy->getAs<BuiltinType>() && !OldElemTy->isComplexType() &&\n      !IntegralOrAnyEnumType)\n    Diag(AttrLoc, diag::err_mode_not_primitive);\n  else if (IntegerMode) {\n    if (!IntegralOrAnyEnumType)\n      Diag(AttrLoc, diag::err_mode_wrong_type);\n  } else if (ComplexMode) {\n    if (!OldElemTy->isComplexType())\n      Diag(AttrLoc, diag::err_mode_wrong_type);\n  } else {\n    if (!OldElemTy->isFloatingType())\n      Diag(AttrLoc, diag::err_mode_wrong_type);\n  }\n\n  QualType NewElemTy;\n\n  if (IntegerMode)\n    NewElemTy = Context.getIntTypeForBitwidth(DestWidth,\n                                              OldElemTy->isSignedIntegerType());\n  else\n    NewElemTy = Context.getRealTypeForBitwidth(DestWidth, ExplicitIEEE);\n\n  if (NewElemTy.isNull()) {\n    Diag(AttrLoc, diag::err_machine_mode) << 1 /*Unsupported*/ << Name;\n    return;\n  }\n\n  if (ComplexMode) {\n    NewElemTy = Context.getComplexType(NewElemTy);\n  }\n\n  QualType NewTy = NewElemTy;\n  if (VectorSize.getBoolValue()) {\n    NewTy = Context.getVectorType(NewTy, VectorSize.getZExtValue(),\n                                  VectorType::GenericVector);\n  } else if (const auto *OldVT = OldTy->getAs<VectorType>()) {\n    // Complex machine mode does not support base vector types.\n    if (ComplexMode) {\n      Diag(AttrLoc, diag::err_complex_mode_vector_type);\n      return;\n    }\n    unsigned NumElements = Context.getTypeSize(OldElemTy) *\n                           OldVT->getNumElements() /\n                           Context.getTypeSize(NewElemTy);\n    NewTy =\n        Context.getVectorType(NewElemTy, NumElements, OldVT->getVectorKind());\n  }\n\n  if (NewTy.isNull()) {\n    Diag(AttrLoc, diag::err_mode_wrong_type);\n    return;\n  }\n\n  // Install the new type.\n  if (auto *TD = dyn_cast<TypedefNameDecl>(D))\n    TD->setModedTypeSourceInfo(TD->getTypeSourceInfo(), NewTy);\n  else if (auto *ED = dyn_cast<EnumDecl>(D))\n    ED->setIntegerType(NewTy);\n  else\n    cast<ValueDecl>(D)->setType(NewTy);\n\n  D->addAttr(::new (Context) ModeAttr(Context, CI, Name));\n}\n\nstatic void handleNoDebugAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  D->addAttr(::new (S.Context) NoDebugAttr(S.Context, AL));\n}\n\nAlwaysInlineAttr *Sema::mergeAlwaysInlineAttr(Decl *D,\n                                              const AttributeCommonInfo &CI,\n                                              const IdentifierInfo *Ident) {\n  if (OptimizeNoneAttr *Optnone = D->getAttr<OptimizeNoneAttr>()) {\n    Diag(CI.getLoc(), diag::warn_attribute_ignored) << Ident;\n    Diag(Optnone->getLocation(), diag::note_conflicting_attribute);\n    return nullptr;\n  }\n\n  if (D->hasAttr<AlwaysInlineAttr>())\n    return nullptr;\n\n  return ::new (Context) AlwaysInlineAttr(Context, CI);\n}\n\nCommonAttr *Sema::mergeCommonAttr(Decl *D, const ParsedAttr &AL) {\n  if (checkAttrMutualExclusion<InternalLinkageAttr>(*this, D, AL))\n    return nullptr;\n\n  return ::new (Context) CommonAttr(Context, AL);\n}\n\nCommonAttr *Sema::mergeCommonAttr(Decl *D, const CommonAttr &AL) {\n  if (checkAttrMutualExclusion<InternalLinkageAttr>(*this, D, AL))\n    return nullptr;\n\n  return ::new (Context) CommonAttr(Context, AL);\n}\n\nInternalLinkageAttr *Sema::mergeInternalLinkageAttr(Decl *D,\n                                                    const ParsedAttr &AL) {\n  if (const auto *VD = dyn_cast<VarDecl>(D)) {\n    // Attribute applies to Var but not any subclass of it (like ParmVar,\n    // ImplicitParm or VarTemplateSpecialization).\n    if (VD->getKind() != Decl::Var) {\n      Diag(AL.getLoc(), diag::warn_attribute_wrong_decl_type)\n          << AL << (getLangOpts().CPlusPlus ? ExpectedFunctionVariableOrClass\n                                            : ExpectedVariableOrFunction);\n      return nullptr;\n    }\n    // Attribute does not apply to non-static local variables.\n    if (VD->hasLocalStorage()) {\n      Diag(VD->getLocation(), diag::warn_internal_linkage_local_storage);\n      return nullptr;\n    }\n  }\n\n  if (checkAttrMutualExclusion<CommonAttr>(*this, D, AL))\n    return nullptr;\n\n  return ::new (Context) InternalLinkageAttr(Context, AL);\n}\nInternalLinkageAttr *\nSema::mergeInternalLinkageAttr(Decl *D, const InternalLinkageAttr &AL) {\n  if (const auto *VD = dyn_cast<VarDecl>(D)) {\n    // Attribute applies to Var but not any subclass of it (like ParmVar,\n    // ImplicitParm or VarTemplateSpecialization).\n    if (VD->getKind() != Decl::Var) {\n      Diag(AL.getLocation(), diag::warn_attribute_wrong_decl_type)\n          << &AL << (getLangOpts().CPlusPlus ? ExpectedFunctionVariableOrClass\n                                             : ExpectedVariableOrFunction);\n      return nullptr;\n    }\n    // Attribute does not apply to non-static local variables.\n    if (VD->hasLocalStorage()) {\n      Diag(VD->getLocation(), diag::warn_internal_linkage_local_storage);\n      return nullptr;\n    }\n  }\n\n  if (checkAttrMutualExclusion<CommonAttr>(*this, D, AL))\n    return nullptr;\n\n  return ::new (Context) InternalLinkageAttr(Context, AL);\n}\n\nMinSizeAttr *Sema::mergeMinSizeAttr(Decl *D, const AttributeCommonInfo &CI) {\n  if (OptimizeNoneAttr *Optnone = D->getAttr<OptimizeNoneAttr>()) {\n    Diag(CI.getLoc(), diag::warn_attribute_ignored) << \"'minsize'\";\n    Diag(Optnone->getLocation(), diag::note_conflicting_attribute);\n    return nullptr;\n  }\n\n  if (D->hasAttr<MinSizeAttr>())\n    return nullptr;\n\n  return ::new (Context) MinSizeAttr(Context, CI);\n}\n\nNoSpeculativeLoadHardeningAttr *Sema::mergeNoSpeculativeLoadHardeningAttr(\n    Decl *D, const NoSpeculativeLoadHardeningAttr &AL) {\n  if (checkAttrMutualExclusion<SpeculativeLoadHardeningAttr>(*this, D, AL))\n    return nullptr;\n\n  return ::new (Context) NoSpeculativeLoadHardeningAttr(Context, AL);\n}\n\nSwiftNameAttr *Sema::mergeSwiftNameAttr(Decl *D, const SwiftNameAttr &SNA,\n                                        StringRef Name) {\n  if (const auto *PrevSNA = D->getAttr<SwiftNameAttr>()) {\n    if (PrevSNA->getName() != Name && !PrevSNA->isImplicit()) {\n      Diag(PrevSNA->getLocation(), diag::err_attributes_are_not_compatible)\n          << PrevSNA << &SNA;\n      Diag(SNA.getLoc(), diag::note_conflicting_attribute);\n    }\n\n    D->dropAttr<SwiftNameAttr>();\n  }\n  return ::new (Context) SwiftNameAttr(Context, SNA, Name);\n}\n\nOptimizeNoneAttr *Sema::mergeOptimizeNoneAttr(Decl *D,\n                                              const AttributeCommonInfo &CI) {\n  if (AlwaysInlineAttr *Inline = D->getAttr<AlwaysInlineAttr>()) {\n    Diag(Inline->getLocation(), diag::warn_attribute_ignored) << Inline;\n    Diag(CI.getLoc(), diag::note_conflicting_attribute);\n    D->dropAttr<AlwaysInlineAttr>();\n  }\n  if (MinSizeAttr *MinSize = D->getAttr<MinSizeAttr>()) {\n    Diag(MinSize->getLocation(), diag::warn_attribute_ignored) << MinSize;\n    Diag(CI.getLoc(), diag::note_conflicting_attribute);\n    D->dropAttr<MinSizeAttr>();\n  }\n\n  if (D->hasAttr<OptimizeNoneAttr>())\n    return nullptr;\n\n  return ::new (Context) OptimizeNoneAttr(Context, CI);\n}\n\nSpeculativeLoadHardeningAttr *Sema::mergeSpeculativeLoadHardeningAttr(\n    Decl *D, const SpeculativeLoadHardeningAttr &AL) {\n  if (checkAttrMutualExclusion<NoSpeculativeLoadHardeningAttr>(*this, D, AL))\n    return nullptr;\n\n  return ::new (Context) SpeculativeLoadHardeningAttr(Context, AL);\n}\n\nstatic void handleAlwaysInlineAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  if (checkAttrMutualExclusion<NotTailCalledAttr>(S, D, AL))\n    return;\n\n  if (AlwaysInlineAttr *Inline =\n          S.mergeAlwaysInlineAttr(D, AL, AL.getAttrName()))\n    D->addAttr(Inline);\n}\n\nstatic void handleMinSizeAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  if (MinSizeAttr *MinSize = S.mergeMinSizeAttr(D, AL))\n    D->addAttr(MinSize);\n}\n\nstatic void handleOptimizeNoneAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  if (OptimizeNoneAttr *Optnone = S.mergeOptimizeNoneAttr(D, AL))\n    D->addAttr(Optnone);\n}\n\nstatic void handleConstantAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  if (checkAttrMutualExclusion<CUDASharedAttr>(S, D, AL) ||\n      checkAttrMutualExclusion<HIPManagedAttr>(S, D, AL))\n    return;\n  const auto *VD = cast<VarDecl>(D);\n  if (VD->hasLocalStorage()) {\n    S.Diag(AL.getLoc(), diag::err_cuda_nonstatic_constdev);\n    return;\n  }\n  D->addAttr(::new (S.Context) CUDAConstantAttr(S.Context, AL));\n}\n\nstatic void handleSharedAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  if (checkAttrMutualExclusion<CUDAConstantAttr>(S, D, AL) ||\n      checkAttrMutualExclusion<HIPManagedAttr>(S, D, AL))\n    return;\n  const auto *VD = cast<VarDecl>(D);\n  // extern __shared__ is only allowed on arrays with no length (e.g.\n  // \"int x[]\").\n  if (!S.getLangOpts().GPURelocatableDeviceCode && VD->hasExternalStorage() &&\n      !isa<IncompleteArrayType>(VD->getType())) {\n    S.Diag(AL.getLoc(), diag::err_cuda_extern_shared) << VD;\n    return;\n  }\n  if (S.getLangOpts().CUDA && VD->hasLocalStorage() &&\n      S.CUDADiagIfHostCode(AL.getLoc(), diag::err_cuda_host_shared)\n          << S.CurrentCUDATarget())\n    return;\n  D->addAttr(::new (S.Context) CUDASharedAttr(S.Context, AL));\n}\n\nstatic void handleGlobalAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  if (checkAttrMutualExclusion<CUDADeviceAttr>(S, D, AL) ||\n      checkAttrMutualExclusion<CUDAHostAttr>(S, D, AL)) {\n    return;\n  }\n  const auto *FD = cast<FunctionDecl>(D);\n  if (!FD->getReturnType()->isVoidType() &&\n      !FD->getReturnType()->getAs<AutoType>() &&\n      !FD->getReturnType()->isInstantiationDependentType()) {\n    SourceRange RTRange = FD->getReturnTypeSourceRange();\n    S.Diag(FD->getTypeSpecStartLoc(), diag::err_kern_type_not_void_return)\n        << FD->getType()\n        << (RTRange.isValid() ? FixItHint::CreateReplacement(RTRange, \"void\")\n                              : FixItHint());\n    return;\n  }\n  if (const auto *Method = dyn_cast<CXXMethodDecl>(FD)) {\n    if (Method->isInstance()) {\n      S.Diag(Method->getBeginLoc(), diag::err_kern_is_nonstatic_method)\n          << Method;\n      return;\n    }\n    S.Diag(Method->getBeginLoc(), diag::warn_kern_is_method) << Method;\n  }\n  // Only warn for \"inline\" when compiling for host, to cut down on noise.\n  if (FD->isInlineSpecified() && !S.getLangOpts().CUDAIsDevice)\n    S.Diag(FD->getBeginLoc(), diag::warn_kern_is_inline) << FD;\n\n  D->addAttr(::new (S.Context) CUDAGlobalAttr(S.Context, AL));\n  // In host compilation the kernel is emitted as a stub function, which is\n  // a helper function for launching the kernel. The instructions in the helper\n  // function has nothing to do with the source code of the kernel. Do not emit\n  // debug info for the stub function to avoid confusing the debugger.\n  if (S.LangOpts.HIP && !S.LangOpts.CUDAIsDevice)\n    D->addAttr(NoDebugAttr::CreateImplicit(S.Context));\n}\n\nstatic void handleDeviceAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  if (checkAttrMutualExclusion<CUDAGlobalAttr>(S, D, AL)) {\n    return;\n  }\n\n  if (const auto *VD = dyn_cast<VarDecl>(D)) {\n    if (VD->hasLocalStorage()) {\n      S.Diag(AL.getLoc(), diag::err_cuda_nonstatic_constdev);\n      return;\n    }\n  }\n\n  if (auto *A = D->getAttr<CUDADeviceAttr>()) {\n    if (!A->isImplicit())\n      return;\n    D->dropAttr<CUDADeviceAttr>();\n  }\n  D->addAttr(::new (S.Context) CUDADeviceAttr(S.Context, AL));\n}\n\nstatic void handleManagedAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  if (checkAttrMutualExclusion<CUDAConstantAttr>(S, D, AL) ||\n      checkAttrMutualExclusion<CUDASharedAttr>(S, D, AL)) {\n    return;\n  }\n\n  if (const auto *VD = dyn_cast<VarDecl>(D)) {\n    if (VD->hasLocalStorage()) {\n      S.Diag(AL.getLoc(), diag::err_cuda_nonstatic_constdev);\n      return;\n    }\n  }\n  if (!D->hasAttr<HIPManagedAttr>())\n    D->addAttr(::new (S.Context) HIPManagedAttr(S.Context, AL));\n  if (!D->hasAttr<CUDADeviceAttr>())\n    D->addAttr(CUDADeviceAttr::CreateImplicit(S.Context));\n}\n\nstatic void handleGNUInlineAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  const auto *Fn = cast<FunctionDecl>(D);\n  if (!Fn->isInlineSpecified()) {\n    S.Diag(AL.getLoc(), diag::warn_gnu_inline_attribute_requires_inline);\n    return;\n  }\n\n  if (S.LangOpts.CPlusPlus && Fn->getStorageClass() != SC_Extern)\n    S.Diag(AL.getLoc(), diag::warn_gnu_inline_cplusplus_without_extern);\n\n  D->addAttr(::new (S.Context) GNUInlineAttr(S.Context, AL));\n}\n\nstatic void handleCallConvAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  if (hasDeclarator(D)) return;\n\n  // Diagnostic is emitted elsewhere: here we store the (valid) AL\n  // in the Decl node for syntactic reasoning, e.g., pretty-printing.\n  CallingConv CC;\n  if (S.CheckCallingConvAttr(AL, CC, /*FD*/nullptr))\n    return;\n\n  if (!isa<ObjCMethodDecl>(D)) {\n    S.Diag(AL.getLoc(), diag::warn_attribute_wrong_decl_type)\n        << AL << ExpectedFunctionOrMethod;\n    return;\n  }\n\n  switch (AL.getKind()) {\n  case ParsedAttr::AT_FastCall:\n    D->addAttr(::new (S.Context) FastCallAttr(S.Context, AL));\n    return;\n  case ParsedAttr::AT_StdCall:\n    D->addAttr(::new (S.Context) StdCallAttr(S.Context, AL));\n    return;\n  case ParsedAttr::AT_ThisCall:\n    D->addAttr(::new (S.Context) ThisCallAttr(S.Context, AL));\n    return;\n  case ParsedAttr::AT_CDecl:\n    D->addAttr(::new (S.Context) CDeclAttr(S.Context, AL));\n    return;\n  case ParsedAttr::AT_Pascal:\n    D->addAttr(::new (S.Context) PascalAttr(S.Context, AL));\n    return;\n  case ParsedAttr::AT_SwiftCall:\n    D->addAttr(::new (S.Context) SwiftCallAttr(S.Context, AL));\n    return;\n  case ParsedAttr::AT_VectorCall:\n    D->addAttr(::new (S.Context) VectorCallAttr(S.Context, AL));\n    return;\n  case ParsedAttr::AT_MSABI:\n    D->addAttr(::new (S.Context) MSABIAttr(S.Context, AL));\n    return;\n  case ParsedAttr::AT_SysVABI:\n    D->addAttr(::new (S.Context) SysVABIAttr(S.Context, AL));\n    return;\n  case ParsedAttr::AT_RegCall:\n    D->addAttr(::new (S.Context) RegCallAttr(S.Context, AL));\n    return;\n  case ParsedAttr::AT_Pcs: {\n    PcsAttr::PCSType PCS;\n    switch (CC) {\n    case CC_AAPCS:\n      PCS = PcsAttr::AAPCS;\n      break;\n    case CC_AAPCS_VFP:\n      PCS = PcsAttr::AAPCS_VFP;\n      break;\n    default:\n      llvm_unreachable(\"unexpected calling convention in pcs attribute\");\n    }\n\n    D->addAttr(::new (S.Context) PcsAttr(S.Context, AL, PCS));\n    return;\n  }\n  case ParsedAttr::AT_AArch64VectorPcs:\n    D->addAttr(::new (S.Context) AArch64VectorPcsAttr(S.Context, AL));\n    return;\n  case ParsedAttr::AT_IntelOclBicc:\n    D->addAttr(::new (S.Context) IntelOclBiccAttr(S.Context, AL));\n    return;\n  case ParsedAttr::AT_PreserveMost:\n    D->addAttr(::new (S.Context) PreserveMostAttr(S.Context, AL));\n    return;\n  case ParsedAttr::AT_PreserveAll:\n    D->addAttr(::new (S.Context) PreserveAllAttr(S.Context, AL));\n    return;\n  default:\n    llvm_unreachable(\"unexpected attribute kind\");\n  }\n}\n\nstatic void handleSuppressAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  if (!AL.checkAtLeastNumArgs(S, 1))\n    return;\n\n  std::vector<StringRef> DiagnosticIdentifiers;\n  for (unsigned I = 0, E = AL.getNumArgs(); I != E; ++I) {\n    StringRef RuleName;\n\n    if (!S.checkStringLiteralArgumentAttr(AL, I, RuleName, nullptr))\n      return;\n\n    // FIXME: Warn if the rule name is unknown. This is tricky because only\n    // clang-tidy knows about available rules.\n    DiagnosticIdentifiers.push_back(RuleName);\n  }\n  D->addAttr(::new (S.Context)\n                 SuppressAttr(S.Context, AL, DiagnosticIdentifiers.data(),\n                              DiagnosticIdentifiers.size()));\n}\n\nstatic void handleLifetimeCategoryAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  TypeSourceInfo *DerefTypeLoc = nullptr;\n  QualType ParmType;\n  if (AL.hasParsedType()) {\n    ParmType = S.GetTypeFromParser(AL.getTypeArg(), &DerefTypeLoc);\n\n    unsigned SelectIdx = ~0U;\n    if (ParmType->isReferenceType())\n      SelectIdx = 0;\n    else if (ParmType->isArrayType())\n      SelectIdx = 1;\n\n    if (SelectIdx != ~0U) {\n      S.Diag(AL.getLoc(), diag::err_attribute_invalid_argument)\n          << SelectIdx << AL;\n      return;\n    }\n  }\n\n  // To check if earlier decl attributes do not conflict the newly parsed ones\n  // we always add (and check) the attribute to the cannonical decl.\n  D = D->getCanonicalDecl();\n  if (AL.getKind() == ParsedAttr::AT_Owner) {\n    if (checkAttrMutualExclusion<PointerAttr>(S, D, AL))\n      return;\n    if (const auto *OAttr = D->getAttr<OwnerAttr>()) {\n      const Type *ExistingDerefType = OAttr->getDerefTypeLoc()\n                                          ? OAttr->getDerefType().getTypePtr()\n                                          : nullptr;\n      if (ExistingDerefType != ParmType.getTypePtrOrNull()) {\n        S.Diag(AL.getLoc(), diag::err_attributes_are_not_compatible)\n            << AL << OAttr;\n        S.Diag(OAttr->getLocation(), diag::note_conflicting_attribute);\n      }\n      return;\n    }\n    for (Decl *Redecl : D->redecls()) {\n      Redecl->addAttr(::new (S.Context) OwnerAttr(S.Context, AL, DerefTypeLoc));\n    }\n  } else {\n    if (checkAttrMutualExclusion<OwnerAttr>(S, D, AL))\n      return;\n    if (const auto *PAttr = D->getAttr<PointerAttr>()) {\n      const Type *ExistingDerefType = PAttr->getDerefTypeLoc()\n                                          ? PAttr->getDerefType().getTypePtr()\n                                          : nullptr;\n      if (ExistingDerefType != ParmType.getTypePtrOrNull()) {\n        S.Diag(AL.getLoc(), diag::err_attributes_are_not_compatible)\n            << AL << PAttr;\n        S.Diag(PAttr->getLocation(), diag::note_conflicting_attribute);\n      }\n      return;\n    }\n    for (Decl *Redecl : D->redecls()) {\n      Redecl->addAttr(::new (S.Context)\n                          PointerAttr(S.Context, AL, DerefTypeLoc));\n    }\n  }\n}\n\nbool Sema::CheckCallingConvAttr(const ParsedAttr &Attrs, CallingConv &CC,\n                                const FunctionDecl *FD) {\n  if (Attrs.isInvalid())\n    return true;\n\n  if (Attrs.hasProcessingCache()) {\n    CC = (CallingConv) Attrs.getProcessingCache();\n    return false;\n  }\n\n  unsigned ReqArgs = Attrs.getKind() == ParsedAttr::AT_Pcs ? 1 : 0;\n  if (!Attrs.checkExactlyNumArgs(*this, ReqArgs)) {\n    Attrs.setInvalid();\n    return true;\n  }\n\n  // TODO: diagnose uses of these conventions on the wrong target.\n  switch (Attrs.getKind()) {\n  case ParsedAttr::AT_CDecl:\n    CC = CC_C;\n    break;\n  case ParsedAttr::AT_FastCall:\n    CC = CC_X86FastCall;\n    break;\n  case ParsedAttr::AT_StdCall:\n    CC = CC_X86StdCall;\n    break;\n  case ParsedAttr::AT_ThisCall:\n    CC = CC_X86ThisCall;\n    break;\n  case ParsedAttr::AT_Pascal:\n    CC = CC_X86Pascal;\n    break;\n  case ParsedAttr::AT_SwiftCall:\n    CC = CC_Swift;\n    break;\n  case ParsedAttr::AT_VectorCall:\n    CC = CC_X86VectorCall;\n    break;\n  case ParsedAttr::AT_AArch64VectorPcs:\n    CC = CC_AArch64VectorCall;\n    break;\n  case ParsedAttr::AT_RegCall:\n    CC = CC_X86RegCall;\n    break;\n  case ParsedAttr::AT_MSABI:\n    CC = Context.getTargetInfo().getTriple().isOSWindows() ? CC_C :\n                                                             CC_Win64;\n    break;\n  case ParsedAttr::AT_SysVABI:\n    CC = Context.getTargetInfo().getTriple().isOSWindows() ? CC_X86_64SysV :\n                                                             CC_C;\n    break;\n  case ParsedAttr::AT_Pcs: {\n    StringRef StrRef;\n    if (!checkStringLiteralArgumentAttr(Attrs, 0, StrRef)) {\n      Attrs.setInvalid();\n      return true;\n    }\n    if (StrRef == \"aapcs\") {\n      CC = CC_AAPCS;\n      break;\n    } else if (StrRef == \"aapcs-vfp\") {\n      CC = CC_AAPCS_VFP;\n      break;\n    }\n\n    Attrs.setInvalid();\n    Diag(Attrs.getLoc(), diag::err_invalid_pcs);\n    return true;\n  }\n  case ParsedAttr::AT_IntelOclBicc:\n    CC = CC_IntelOclBicc;\n    break;\n  case ParsedAttr::AT_PreserveMost:\n    CC = CC_PreserveMost;\n    break;\n  case ParsedAttr::AT_PreserveAll:\n    CC = CC_PreserveAll;\n    break;\n  default: llvm_unreachable(\"unexpected attribute kind\");\n  }\n\n  TargetInfo::CallingConvCheckResult A = TargetInfo::CCCR_OK;\n  const TargetInfo &TI = Context.getTargetInfo();\n  // CUDA functions may have host and/or device attributes which indicate\n  // their targeted execution environment, therefore the calling convention\n  // of functions in CUDA should be checked against the target deduced based\n  // on their host/device attributes.\n  if (LangOpts.CUDA) {\n    auto *Aux = Context.getAuxTargetInfo();\n    auto CudaTarget = IdentifyCUDATarget(FD);\n    bool CheckHost = false, CheckDevice = false;\n    switch (CudaTarget) {\n    case CFT_HostDevice:\n      CheckHost = true;\n      CheckDevice = true;\n      break;\n    case CFT_Host:\n      CheckHost = true;\n      break;\n    case CFT_Device:\n    case CFT_Global:\n      CheckDevice = true;\n      break;\n    case CFT_InvalidTarget:\n      llvm_unreachable(\"unexpected cuda target\");\n    }\n    auto *HostTI = LangOpts.CUDAIsDevice ? Aux : &TI;\n    auto *DeviceTI = LangOpts.CUDAIsDevice ? &TI : Aux;\n    if (CheckHost && HostTI)\n      A = HostTI->checkCallingConvention(CC);\n    if (A == TargetInfo::CCCR_OK && CheckDevice && DeviceTI)\n      A = DeviceTI->checkCallingConvention(CC);\n  } else {\n    A = TI.checkCallingConvention(CC);\n  }\n\n  switch (A) {\n  case TargetInfo::CCCR_OK:\n    break;\n\n  case TargetInfo::CCCR_Ignore:\n    // Treat an ignored convention as if it was an explicit C calling convention\n    // attribute. For example, __stdcall on Win x64 functions as __cdecl, so\n    // that command line flags that change the default convention to\n    // __vectorcall don't affect declarations marked __stdcall.\n    CC = CC_C;\n    break;\n\n  case TargetInfo::CCCR_Error:\n    Diag(Attrs.getLoc(), diag::error_cconv_unsupported)\n        << Attrs << (int)CallingConventionIgnoredReason::ForThisTarget;\n    break;\n\n  case TargetInfo::CCCR_Warning: {\n    Diag(Attrs.getLoc(), diag::warn_cconv_unsupported)\n        << Attrs << (int)CallingConventionIgnoredReason::ForThisTarget;\n\n    // This convention is not valid for the target. Use the default function or\n    // method calling convention.\n    bool IsCXXMethod = false, IsVariadic = false;\n    if (FD) {\n      IsCXXMethod = FD->isCXXInstanceMember();\n      IsVariadic = FD->isVariadic();\n    }\n    CC = Context.getDefaultCallingConvention(IsVariadic, IsCXXMethod);\n    break;\n  }\n  }\n\n  Attrs.setProcessingCache((unsigned) CC);\n  return false;\n}\n\n/// Pointer-like types in the default address space.\nstatic bool isValidSwiftContextType(QualType Ty) {\n  if (!Ty->hasPointerRepresentation())\n    return Ty->isDependentType();\n  return Ty->getPointeeType().getAddressSpace() == LangAS::Default;\n}\n\n/// Pointers and references in the default address space.\nstatic bool isValidSwiftIndirectResultType(QualType Ty) {\n  if (const auto *PtrType = Ty->getAs<PointerType>()) {\n    Ty = PtrType->getPointeeType();\n  } else if (const auto *RefType = Ty->getAs<ReferenceType>()) {\n    Ty = RefType->getPointeeType();\n  } else {\n    return Ty->isDependentType();\n  }\n  return Ty.getAddressSpace() == LangAS::Default;\n}\n\n/// Pointers and references to pointers in the default address space.\nstatic bool isValidSwiftErrorResultType(QualType Ty) {\n  if (const auto *PtrType = Ty->getAs<PointerType>()) {\n    Ty = PtrType->getPointeeType();\n  } else if (const auto *RefType = Ty->getAs<ReferenceType>()) {\n    Ty = RefType->getPointeeType();\n  } else {\n    return Ty->isDependentType();\n  }\n  if (!Ty.getQualifiers().empty())\n    return false;\n  return isValidSwiftContextType(Ty);\n}\n\nvoid Sema::AddParameterABIAttr(Decl *D, const AttributeCommonInfo &CI,\n                               ParameterABI abi) {\n\n  QualType type = cast<ParmVarDecl>(D)->getType();\n\n  if (auto existingAttr = D->getAttr<ParameterABIAttr>()) {\n    if (existingAttr->getABI() != abi) {\n      Diag(CI.getLoc(), diag::err_attributes_are_not_compatible)\n          << getParameterABISpelling(abi) << existingAttr;\n      Diag(existingAttr->getLocation(), diag::note_conflicting_attribute);\n      return;\n    }\n  }\n\n  switch (abi) {\n  case ParameterABI::Ordinary:\n    llvm_unreachable(\"explicit attribute for ordinary parameter ABI?\");\n\n  case ParameterABI::SwiftContext:\n    if (!isValidSwiftContextType(type)) {\n      Diag(CI.getLoc(), diag::err_swift_abi_parameter_wrong_type)\n          << getParameterABISpelling(abi) << /*pointer to pointer */ 0 << type;\n    }\n    D->addAttr(::new (Context) SwiftContextAttr(Context, CI));\n    return;\n\n  case ParameterABI::SwiftErrorResult:\n    if (!isValidSwiftErrorResultType(type)) {\n      Diag(CI.getLoc(), diag::err_swift_abi_parameter_wrong_type)\n          << getParameterABISpelling(abi) << /*pointer to pointer */ 1 << type;\n    }\n    D->addAttr(::new (Context) SwiftErrorResultAttr(Context, CI));\n    return;\n\n  case ParameterABI::SwiftIndirectResult:\n    if (!isValidSwiftIndirectResultType(type)) {\n      Diag(CI.getLoc(), diag::err_swift_abi_parameter_wrong_type)\n          << getParameterABISpelling(abi) << /*pointer*/ 0 << type;\n    }\n    D->addAttr(::new (Context) SwiftIndirectResultAttr(Context, CI));\n    return;\n  }\n  llvm_unreachable(\"bad parameter ABI attribute\");\n}\n\n/// Checks a regparm attribute, returning true if it is ill-formed and\n/// otherwise setting numParams to the appropriate value.\nbool Sema::CheckRegparmAttr(const ParsedAttr &AL, unsigned &numParams) {\n  if (AL.isInvalid())\n    return true;\n\n  if (!AL.checkExactlyNumArgs(*this, 1)) {\n    AL.setInvalid();\n    return true;\n  }\n\n  uint32_t NP;\n  Expr *NumParamsExpr = AL.getArgAsExpr(0);\n  if (!checkUInt32Argument(*this, AL, NumParamsExpr, NP)) {\n    AL.setInvalid();\n    return true;\n  }\n\n  if (Context.getTargetInfo().getRegParmMax() == 0) {\n    Diag(AL.getLoc(), diag::err_attribute_regparm_wrong_platform)\n      << NumParamsExpr->getSourceRange();\n    AL.setInvalid();\n    return true;\n  }\n\n  numParams = NP;\n  if (numParams > Context.getTargetInfo().getRegParmMax()) {\n    Diag(AL.getLoc(), diag::err_attribute_regparm_invalid_number)\n      << Context.getTargetInfo().getRegParmMax() << NumParamsExpr->getSourceRange();\n    AL.setInvalid();\n    return true;\n  }\n\n  return false;\n}\n\n// Checks whether an argument of launch_bounds attribute is\n// acceptable, performs implicit conversion to Rvalue, and returns\n// non-nullptr Expr result on success. Otherwise, it returns nullptr\n// and may output an error.\nstatic Expr *makeLaunchBoundsArgExpr(Sema &S, Expr *E,\n                                     const CUDALaunchBoundsAttr &AL,\n                                     const unsigned Idx) {\n  if (S.DiagnoseUnexpandedParameterPack(E))\n    return nullptr;\n\n  // Accept template arguments for now as they depend on something else.\n  // We'll get to check them when they eventually get instantiated.\n  if (E->isValueDependent())\n    return E;\n\n  Optional<llvm::APSInt> I = llvm::APSInt(64);\n  if (!(I = E->getIntegerConstantExpr(S.Context))) {\n    S.Diag(E->getExprLoc(), diag::err_attribute_argument_n_type)\n        << &AL << Idx << AANT_ArgumentIntegerConstant << E->getSourceRange();\n    return nullptr;\n  }\n  // Make sure we can fit it in 32 bits.\n  if (!I->isIntN(32)) {\n    S.Diag(E->getExprLoc(), diag::err_ice_too_large)\n        << I->toString(10, false) << 32 << /* Unsigned */ 1;\n    return nullptr;\n  }\n  if (*I < 0)\n    S.Diag(E->getExprLoc(), diag::warn_attribute_argument_n_negative)\n        << &AL << Idx << E->getSourceRange();\n\n  // We may need to perform implicit conversion of the argument.\n  InitializedEntity Entity = InitializedEntity::InitializeParameter(\n      S.Context, S.Context.getConstType(S.Context.IntTy), /*consume*/ false);\n  ExprResult ValArg = S.PerformCopyInitialization(Entity, SourceLocation(), E);\n  assert(!ValArg.isInvalid() &&\n         \"Unexpected PerformCopyInitialization() failure.\");\n\n  return ValArg.getAs<Expr>();\n}\n\nvoid Sema::AddLaunchBoundsAttr(Decl *D, const AttributeCommonInfo &CI,\n                               Expr *MaxThreads, Expr *MinBlocks) {\n  CUDALaunchBoundsAttr TmpAttr(Context, CI, MaxThreads, MinBlocks);\n  MaxThreads = makeLaunchBoundsArgExpr(*this, MaxThreads, TmpAttr, 0);\n  if (MaxThreads == nullptr)\n    return;\n\n  if (MinBlocks) {\n    MinBlocks = makeLaunchBoundsArgExpr(*this, MinBlocks, TmpAttr, 1);\n    if (MinBlocks == nullptr)\n      return;\n  }\n\n  D->addAttr(::new (Context)\n                 CUDALaunchBoundsAttr(Context, CI, MaxThreads, MinBlocks));\n}\n\nstatic void handleLaunchBoundsAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  if (!AL.checkAtLeastNumArgs(S, 1) || !AL.checkAtMostNumArgs(S, 2))\n    return;\n\n  S.AddLaunchBoundsAttr(D, AL, AL.getArgAsExpr(0),\n                        AL.getNumArgs() > 1 ? AL.getArgAsExpr(1) : nullptr);\n}\n\nstatic void handleArgumentWithTypeTagAttr(Sema &S, Decl *D,\n                                          const ParsedAttr &AL) {\n  if (!AL.isArgIdent(0)) {\n    S.Diag(AL.getLoc(), diag::err_attribute_argument_n_type)\n        << AL << /* arg num = */ 1 << AANT_ArgumentIdentifier;\n    return;\n  }\n\n  ParamIdx ArgumentIdx;\n  if (!checkFunctionOrMethodParameterIndex(S, D, AL, 2, AL.getArgAsExpr(1),\n                                           ArgumentIdx))\n    return;\n\n  ParamIdx TypeTagIdx;\n  if (!checkFunctionOrMethodParameterIndex(S, D, AL, 3, AL.getArgAsExpr(2),\n                                           TypeTagIdx))\n    return;\n\n  bool IsPointer = AL.getAttrName()->getName() == \"pointer_with_type_tag\";\n  if (IsPointer) {\n    // Ensure that buffer has a pointer type.\n    unsigned ArgumentIdxAST = ArgumentIdx.getASTIndex();\n    if (ArgumentIdxAST >= getFunctionOrMethodNumParams(D) ||\n        !getFunctionOrMethodParamType(D, ArgumentIdxAST)->isPointerType())\n      S.Diag(AL.getLoc(), diag::err_attribute_pointers_only) << AL << 0;\n  }\n\n  D->addAttr(::new (S.Context) ArgumentWithTypeTagAttr(\n      S.Context, AL, AL.getArgAsIdent(0)->Ident, ArgumentIdx, TypeTagIdx,\n      IsPointer));\n}\n\nstatic void handleTypeTagForDatatypeAttr(Sema &S, Decl *D,\n                                         const ParsedAttr &AL) {\n  if (!AL.isArgIdent(0)) {\n    S.Diag(AL.getLoc(), diag::err_attribute_argument_n_type)\n        << AL << 1 << AANT_ArgumentIdentifier;\n    return;\n  }\n\n  if (!AL.checkExactlyNumArgs(S, 1))\n    return;\n\n  if (!isa<VarDecl>(D)) {\n    S.Diag(AL.getLoc(), diag::err_attribute_wrong_decl_type)\n        << AL << ExpectedVariable;\n    return;\n  }\n\n  IdentifierInfo *PointerKind = AL.getArgAsIdent(0)->Ident;\n  TypeSourceInfo *MatchingCTypeLoc = nullptr;\n  S.GetTypeFromParser(AL.getMatchingCType(), &MatchingCTypeLoc);\n  assert(MatchingCTypeLoc && \"no type source info for attribute argument\");\n\n  D->addAttr(::new (S.Context) TypeTagForDatatypeAttr(\n      S.Context, AL, PointerKind, MatchingCTypeLoc, AL.getLayoutCompatible(),\n      AL.getMustBeNull()));\n}\n\nstatic void handleXRayLogArgsAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  ParamIdx ArgCount;\n\n  if (!checkFunctionOrMethodParameterIndex(S, D, AL, 1, AL.getArgAsExpr(0),\n                                           ArgCount,\n                                           true /* CanIndexImplicitThis */))\n    return;\n\n  // ArgCount isn't a parameter index [0;n), it's a count [1;n]\n  D->addAttr(::new (S.Context)\n                 XRayLogArgsAttr(S.Context, AL, ArgCount.getSourceIndex()));\n}\n\nstatic void handlePatchableFunctionEntryAttr(Sema &S, Decl *D,\n                                             const ParsedAttr &AL) {\n  uint32_t Count = 0, Offset = 0;\n  if (!checkUInt32Argument(S, AL, AL.getArgAsExpr(0), Count, 0, true))\n    return;\n  if (AL.getNumArgs() == 2) {\n    Expr *Arg = AL.getArgAsExpr(1);\n    if (!checkUInt32Argument(S, AL, Arg, Offset, 1, true))\n      return;\n    if (Count < Offset) {\n      S.Diag(getAttrLoc(AL), diag::err_attribute_argument_out_of_range)\n          << &AL << 0 << Count << Arg->getBeginLoc();\n      return;\n    }\n  }\n  D->addAttr(::new (S.Context)\n                 PatchableFunctionEntryAttr(S.Context, AL, Count, Offset));\n}\n\nnamespace {\nstruct IntrinToName {\n  uint32_t Id;\n  int32_t FullName;\n  int32_t ShortName;\n};\n} // unnamed namespace\n\nstatic bool ArmBuiltinAliasValid(unsigned BuiltinID, StringRef AliasName,\n                                 ArrayRef<IntrinToName> Map,\n                                 const char *IntrinNames) {\n  if (AliasName.startswith(\"__arm_\"))\n    AliasName = AliasName.substr(6);\n  const IntrinToName *It = std::lower_bound(\n      Map.begin(), Map.end(), BuiltinID,\n      [](const IntrinToName &L, unsigned Id) { return L.Id < Id; });\n  if (It == Map.end() || It->Id != BuiltinID)\n    return false;\n  StringRef FullName(&IntrinNames[It->FullName]);\n  if (AliasName == FullName)\n    return true;\n  if (It->ShortName == -1)\n    return false;\n  StringRef ShortName(&IntrinNames[It->ShortName]);\n  return AliasName == ShortName;\n}\n\nstatic bool ArmMveAliasValid(unsigned BuiltinID, StringRef AliasName) {\n#include \"clang/Basic/arm_mve_builtin_aliases.inc\"\n  // The included file defines:\n  // - ArrayRef<IntrinToName> Map\n  // - const char IntrinNames[]\n  return ArmBuiltinAliasValid(BuiltinID, AliasName, Map, IntrinNames);\n}\n\nstatic bool ArmCdeAliasValid(unsigned BuiltinID, StringRef AliasName) {\n#include \"clang/Basic/arm_cde_builtin_aliases.inc\"\n  return ArmBuiltinAliasValid(BuiltinID, AliasName, Map, IntrinNames);\n}\n\nstatic bool ArmSveAliasValid(unsigned BuiltinID, StringRef AliasName) {\n  switch (BuiltinID) {\n  default:\n    return false;\n#define GET_SVE_BUILTINS\n#define BUILTIN(name, types, attr) case SVE::BI##name:\n#include \"clang/Basic/arm_sve_builtins.inc\"\n    return true;\n  }\n}\n\nstatic void handleArmBuiltinAliasAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  if (!AL.isArgIdent(0)) {\n    S.Diag(AL.getLoc(), diag::err_attribute_argument_n_type)\n        << AL << 1 << AANT_ArgumentIdentifier;\n    return;\n  }\n\n  IdentifierInfo *Ident = AL.getArgAsIdent(0)->Ident;\n  unsigned BuiltinID = Ident->getBuiltinID();\n  StringRef AliasName = cast<FunctionDecl>(D)->getIdentifier()->getName();\n\n  bool IsAArch64 = S.Context.getTargetInfo().getTriple().isAArch64();\n  if ((IsAArch64 && !ArmSveAliasValid(BuiltinID, AliasName)) ||\n      (!IsAArch64 && !ArmMveAliasValid(BuiltinID, AliasName) &&\n       !ArmCdeAliasValid(BuiltinID, AliasName))) {\n    S.Diag(AL.getLoc(), diag::err_attribute_arm_builtin_alias);\n    return;\n  }\n\n  D->addAttr(::new (S.Context) ArmBuiltinAliasAttr(S.Context, AL, Ident));\n}\n\n//===----------------------------------------------------------------------===//\n// Checker-specific attribute handlers.\n//===----------------------------------------------------------------------===//\nstatic bool isValidSubjectOfNSReturnsRetainedAttribute(QualType QT) {\n  return QT->isDependentType() || QT->isObjCRetainableType();\n}\n\nstatic bool isValidSubjectOfNSAttribute(QualType QT) {\n  return QT->isDependentType() || QT->isObjCObjectPointerType() ||\n         QT->isObjCNSObjectType();\n}\n\nstatic bool isValidSubjectOfCFAttribute(QualType QT) {\n  return QT->isDependentType() || QT->isPointerType() ||\n         isValidSubjectOfNSAttribute(QT);\n}\n\nstatic bool isValidSubjectOfOSAttribute(QualType QT) {\n  if (QT->isDependentType())\n    return true;\n  QualType PT = QT->getPointeeType();\n  return !PT.isNull() && PT->getAsCXXRecordDecl() != nullptr;\n}\n\nvoid Sema::AddXConsumedAttr(Decl *D, const AttributeCommonInfo &CI,\n                            RetainOwnershipKind K,\n                            bool IsTemplateInstantiation) {\n  ValueDecl *VD = cast<ValueDecl>(D);\n  switch (K) {\n  case RetainOwnershipKind::OS:\n    handleSimpleAttributeOrDiagnose<OSConsumedAttr>(\n        *this, VD, CI, isValidSubjectOfOSAttribute(VD->getType()),\n        diag::warn_ns_attribute_wrong_parameter_type,\n        /*ExtraArgs=*/CI.getRange(), \"os_consumed\", /*pointers*/ 1);\n    return;\n  case RetainOwnershipKind::NS:\n    handleSimpleAttributeOrDiagnose<NSConsumedAttr>(\n        *this, VD, CI, isValidSubjectOfNSAttribute(VD->getType()),\n\n        // These attributes are normally just advisory, but in ARC, ns_consumed\n        // is significant.  Allow non-dependent code to contain inappropriate\n        // attributes even in ARC, but require template instantiations to be\n        // set up correctly.\n        ((IsTemplateInstantiation && getLangOpts().ObjCAutoRefCount)\n             ? diag::err_ns_attribute_wrong_parameter_type\n             : diag::warn_ns_attribute_wrong_parameter_type),\n        /*ExtraArgs=*/CI.getRange(), \"ns_consumed\", /*objc pointers*/ 0);\n    return;\n  case RetainOwnershipKind::CF:\n    handleSimpleAttributeOrDiagnose<CFConsumedAttr>(\n        *this, VD, CI, isValidSubjectOfCFAttribute(VD->getType()),\n        diag::warn_ns_attribute_wrong_parameter_type,\n        /*ExtraArgs=*/CI.getRange(), \"cf_consumed\", /*pointers*/ 1);\n    return;\n  }\n}\n\nstatic Sema::RetainOwnershipKind\nparsedAttrToRetainOwnershipKind(const ParsedAttr &AL) {\n  switch (AL.getKind()) {\n  case ParsedAttr::AT_CFConsumed:\n  case ParsedAttr::AT_CFReturnsRetained:\n  case ParsedAttr::AT_CFReturnsNotRetained:\n    return Sema::RetainOwnershipKind::CF;\n  case ParsedAttr::AT_OSConsumesThis:\n  case ParsedAttr::AT_OSConsumed:\n  case ParsedAttr::AT_OSReturnsRetained:\n  case ParsedAttr::AT_OSReturnsNotRetained:\n  case ParsedAttr::AT_OSReturnsRetainedOnZero:\n  case ParsedAttr::AT_OSReturnsRetainedOnNonZero:\n    return Sema::RetainOwnershipKind::OS;\n  case ParsedAttr::AT_NSConsumesSelf:\n  case ParsedAttr::AT_NSConsumed:\n  case ParsedAttr::AT_NSReturnsRetained:\n  case ParsedAttr::AT_NSReturnsNotRetained:\n  case ParsedAttr::AT_NSReturnsAutoreleased:\n    return Sema::RetainOwnershipKind::NS;\n  default:\n    llvm_unreachable(\"Wrong argument supplied\");\n  }\n}\n\nbool Sema::checkNSReturnsRetainedReturnType(SourceLocation Loc, QualType QT) {\n  if (isValidSubjectOfNSReturnsRetainedAttribute(QT))\n    return false;\n\n  Diag(Loc, diag::warn_ns_attribute_wrong_return_type)\n      << \"'ns_returns_retained'\" << 0 << 0;\n  return true;\n}\n\n/// \\return whether the parameter is a pointer to OSObject pointer.\nstatic bool isValidOSObjectOutParameter(const Decl *D) {\n  const auto *PVD = dyn_cast<ParmVarDecl>(D);\n  if (!PVD)\n    return false;\n  QualType QT = PVD->getType();\n  QualType PT = QT->getPointeeType();\n  return !PT.isNull() && isValidSubjectOfOSAttribute(PT);\n}\n\nstatic void handleXReturnsXRetainedAttr(Sema &S, Decl *D,\n                                        const ParsedAttr &AL) {\n  QualType ReturnType;\n  Sema::RetainOwnershipKind K = parsedAttrToRetainOwnershipKind(AL);\n\n  if (const auto *MD = dyn_cast<ObjCMethodDecl>(D)) {\n    ReturnType = MD->getReturnType();\n  } else if (S.getLangOpts().ObjCAutoRefCount && hasDeclarator(D) &&\n             (AL.getKind() == ParsedAttr::AT_NSReturnsRetained)) {\n    return; // ignore: was handled as a type attribute\n  } else if (const auto *PD = dyn_cast<ObjCPropertyDecl>(D)) {\n    ReturnType = PD->getType();\n  } else if (const auto *FD = dyn_cast<FunctionDecl>(D)) {\n    ReturnType = FD->getReturnType();\n  } else if (const auto *Param = dyn_cast<ParmVarDecl>(D)) {\n    // Attributes on parameters are used for out-parameters,\n    // passed as pointers-to-pointers.\n    unsigned DiagID = K == Sema::RetainOwnershipKind::CF\n            ? /*pointer-to-CF-pointer*/2\n            : /*pointer-to-OSObject-pointer*/3;\n    ReturnType = Param->getType()->getPointeeType();\n    if (ReturnType.isNull()) {\n      S.Diag(D->getBeginLoc(), diag::warn_ns_attribute_wrong_parameter_type)\n          << AL << DiagID << AL.getRange();\n      return;\n    }\n  } else if (AL.isUsedAsTypeAttr()) {\n    return;\n  } else {\n    AttributeDeclKind ExpectedDeclKind;\n    switch (AL.getKind()) {\n    default: llvm_unreachable(\"invalid ownership attribute\");\n    case ParsedAttr::AT_NSReturnsRetained:\n    case ParsedAttr::AT_NSReturnsAutoreleased:\n    case ParsedAttr::AT_NSReturnsNotRetained:\n      ExpectedDeclKind = ExpectedFunctionOrMethod;\n      break;\n\n    case ParsedAttr::AT_OSReturnsRetained:\n    case ParsedAttr::AT_OSReturnsNotRetained:\n    case ParsedAttr::AT_CFReturnsRetained:\n    case ParsedAttr::AT_CFReturnsNotRetained:\n      ExpectedDeclKind = ExpectedFunctionMethodOrParameter;\n      break;\n    }\n    S.Diag(D->getBeginLoc(), diag::warn_attribute_wrong_decl_type)\n        << AL.getRange() << AL << ExpectedDeclKind;\n    return;\n  }\n\n  bool TypeOK;\n  bool Cf;\n  unsigned ParmDiagID = 2; // Pointer-to-CF-pointer\n  switch (AL.getKind()) {\n  default: llvm_unreachable(\"invalid ownership attribute\");\n  case ParsedAttr::AT_NSReturnsRetained:\n    TypeOK = isValidSubjectOfNSReturnsRetainedAttribute(ReturnType);\n    Cf = false;\n    break;\n\n  case ParsedAttr::AT_NSReturnsAutoreleased:\n  case ParsedAttr::AT_NSReturnsNotRetained:\n    TypeOK = isValidSubjectOfNSAttribute(ReturnType);\n    Cf = false;\n    break;\n\n  case ParsedAttr::AT_CFReturnsRetained:\n  case ParsedAttr::AT_CFReturnsNotRetained:\n    TypeOK = isValidSubjectOfCFAttribute(ReturnType);\n    Cf = true;\n    break;\n\n  case ParsedAttr::AT_OSReturnsRetained:\n  case ParsedAttr::AT_OSReturnsNotRetained:\n    TypeOK = isValidSubjectOfOSAttribute(ReturnType);\n    Cf = true;\n    ParmDiagID = 3; // Pointer-to-OSObject-pointer\n    break;\n  }\n\n  if (!TypeOK) {\n    if (AL.isUsedAsTypeAttr())\n      return;\n\n    if (isa<ParmVarDecl>(D)) {\n      S.Diag(D->getBeginLoc(), diag::warn_ns_attribute_wrong_parameter_type)\n          << AL << ParmDiagID << AL.getRange();\n    } else {\n      // Needs to be kept in sync with warn_ns_attribute_wrong_return_type.\n      enum : unsigned {\n        Function,\n        Method,\n        Property\n      } SubjectKind = Function;\n      if (isa<ObjCMethodDecl>(D))\n        SubjectKind = Method;\n      else if (isa<ObjCPropertyDecl>(D))\n        SubjectKind = Property;\n      S.Diag(D->getBeginLoc(), diag::warn_ns_attribute_wrong_return_type)\n          << AL << SubjectKind << Cf << AL.getRange();\n    }\n    return;\n  }\n\n  switch (AL.getKind()) {\n    default:\n      llvm_unreachable(\"invalid ownership attribute\");\n    case ParsedAttr::AT_NSReturnsAutoreleased:\n      handleSimpleAttribute<NSReturnsAutoreleasedAttr>(S, D, AL);\n      return;\n    case ParsedAttr::AT_CFReturnsNotRetained:\n      handleSimpleAttribute<CFReturnsNotRetainedAttr>(S, D, AL);\n      return;\n    case ParsedAttr::AT_NSReturnsNotRetained:\n      handleSimpleAttribute<NSReturnsNotRetainedAttr>(S, D, AL);\n      return;\n    case ParsedAttr::AT_CFReturnsRetained:\n      handleSimpleAttribute<CFReturnsRetainedAttr>(S, D, AL);\n      return;\n    case ParsedAttr::AT_NSReturnsRetained:\n      handleSimpleAttribute<NSReturnsRetainedAttr>(S, D, AL);\n      return;\n    case ParsedAttr::AT_OSReturnsRetained:\n      handleSimpleAttribute<OSReturnsRetainedAttr>(S, D, AL);\n      return;\n    case ParsedAttr::AT_OSReturnsNotRetained:\n      handleSimpleAttribute<OSReturnsNotRetainedAttr>(S, D, AL);\n      return;\n  };\n}\n\nstatic void handleObjCReturnsInnerPointerAttr(Sema &S, Decl *D,\n                                              const ParsedAttr &Attrs) {\n  const int EP_ObjCMethod = 1;\n  const int EP_ObjCProperty = 2;\n\n  SourceLocation loc = Attrs.getLoc();\n  QualType resultType;\n  if (isa<ObjCMethodDecl>(D))\n    resultType = cast<ObjCMethodDecl>(D)->getReturnType();\n  else\n    resultType = cast<ObjCPropertyDecl>(D)->getType();\n\n  if (!resultType->isReferenceType() &&\n      (!resultType->isPointerType() || resultType->isObjCRetainableType())) {\n    S.Diag(D->getBeginLoc(), diag::warn_ns_attribute_wrong_return_type)\n        << SourceRange(loc) << Attrs\n        << (isa<ObjCMethodDecl>(D) ? EP_ObjCMethod : EP_ObjCProperty)\n        << /*non-retainable pointer*/ 2;\n\n    // Drop the attribute.\n    return;\n  }\n\n  D->addAttr(::new (S.Context) ObjCReturnsInnerPointerAttr(S.Context, Attrs));\n}\n\nstatic void handleObjCRequiresSuperAttr(Sema &S, Decl *D,\n                                        const ParsedAttr &Attrs) {\n  const auto *Method = cast<ObjCMethodDecl>(D);\n\n  const DeclContext *DC = Method->getDeclContext();\n  if (const auto *PDecl = dyn_cast_or_null<ObjCProtocolDecl>(DC)) {\n    S.Diag(D->getBeginLoc(), diag::warn_objc_requires_super_protocol) << Attrs\n                                                                      << 0;\n    S.Diag(PDecl->getLocation(), diag::note_protocol_decl);\n    return;\n  }\n  if (Method->getMethodFamily() == OMF_dealloc) {\n    S.Diag(D->getBeginLoc(), diag::warn_objc_requires_super_protocol) << Attrs\n                                                                      << 1;\n    return;\n  }\n\n  D->addAttr(::new (S.Context) ObjCRequiresSuperAttr(S.Context, Attrs));\n}\n\nstatic void handleNSErrorDomain(Sema &S, Decl *D, const ParsedAttr &AL) {\n  auto *E = AL.getArgAsExpr(0);\n  auto Loc = E ? E->getBeginLoc() : AL.getLoc();\n\n  auto *DRE = dyn_cast<DeclRefExpr>(AL.getArgAsExpr(0));\n  if (!DRE) {\n    S.Diag(Loc, diag::err_nserrordomain_invalid_decl) << 0;\n    return;\n  }\n\n  auto *VD = dyn_cast<VarDecl>(DRE->getDecl());\n  if (!VD) {\n    S.Diag(Loc, diag::err_nserrordomain_invalid_decl) << 1 << DRE->getDecl();\n    return;\n  }\n\n  if (!isNSStringType(VD->getType(), S.Context) &&\n      !isCFStringType(VD->getType(), S.Context)) {\n    S.Diag(Loc, diag::err_nserrordomain_wrong_type) << VD;\n    return;\n  }\n\n  D->addAttr(::new (S.Context) NSErrorDomainAttr(S.Context, AL, VD));\n}\n\nstatic void handleObjCBridgeAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  IdentifierLoc *Parm = AL.isArgIdent(0) ? AL.getArgAsIdent(0) : nullptr;\n\n  if (!Parm) {\n    S.Diag(D->getBeginLoc(), diag::err_objc_attr_not_id) << AL << 0;\n    return;\n  }\n\n  // Typedefs only allow objc_bridge(id) and have some additional checking.\n  if (const auto *TD = dyn_cast<TypedefNameDecl>(D)) {\n    if (!Parm->Ident->isStr(\"id\")) {\n      S.Diag(AL.getLoc(), diag::err_objc_attr_typedef_not_id) << AL;\n      return;\n    }\n\n    // Only allow 'cv void *'.\n    QualType T = TD->getUnderlyingType();\n    if (!T->isVoidPointerType()) {\n      S.Diag(AL.getLoc(), diag::err_objc_attr_typedef_not_void_pointer);\n      return;\n    }\n  }\n\n  D->addAttr(::new (S.Context) ObjCBridgeAttr(S.Context, AL, Parm->Ident));\n}\n\nstatic void handleObjCBridgeMutableAttr(Sema &S, Decl *D,\n                                        const ParsedAttr &AL) {\n  IdentifierLoc *Parm = AL.isArgIdent(0) ? AL.getArgAsIdent(0) : nullptr;\n\n  if (!Parm) {\n    S.Diag(D->getBeginLoc(), diag::err_objc_attr_not_id) << AL << 0;\n    return;\n  }\n\n  D->addAttr(::new (S.Context)\n                 ObjCBridgeMutableAttr(S.Context, AL, Parm->Ident));\n}\n\nstatic void handleObjCBridgeRelatedAttr(Sema &S, Decl *D,\n                                        const ParsedAttr &AL) {\n  IdentifierInfo *RelatedClass =\n      AL.isArgIdent(0) ? AL.getArgAsIdent(0)->Ident : nullptr;\n  if (!RelatedClass) {\n    S.Diag(D->getBeginLoc(), diag::err_objc_attr_not_id) << AL << 0;\n    return;\n  }\n  IdentifierInfo *ClassMethod =\n    AL.getArgAsIdent(1) ? AL.getArgAsIdent(1)->Ident : nullptr;\n  IdentifierInfo *InstanceMethod =\n    AL.getArgAsIdent(2) ? AL.getArgAsIdent(2)->Ident : nullptr;\n  D->addAttr(::new (S.Context) ObjCBridgeRelatedAttr(\n      S.Context, AL, RelatedClass, ClassMethod, InstanceMethod));\n}\n\nstatic void handleObjCDesignatedInitializer(Sema &S, Decl *D,\n                                            const ParsedAttr &AL) {\n  DeclContext *Ctx = D->getDeclContext();\n\n  // This attribute can only be applied to methods in interfaces or class\n  // extensions.\n  if (!isa<ObjCInterfaceDecl>(Ctx) &&\n      !(isa<ObjCCategoryDecl>(Ctx) &&\n        cast<ObjCCategoryDecl>(Ctx)->IsClassExtension())) {\n    S.Diag(D->getLocation(), diag::err_designated_init_attr_non_init);\n    return;\n  }\n\n  ObjCInterfaceDecl *IFace;\n  if (auto *CatDecl = dyn_cast<ObjCCategoryDecl>(Ctx))\n    IFace = CatDecl->getClassInterface();\n  else\n    IFace = cast<ObjCInterfaceDecl>(Ctx);\n\n  if (!IFace)\n    return;\n\n  IFace->setHasDesignatedInitializers();\n  D->addAttr(::new (S.Context) ObjCDesignatedInitializerAttr(S.Context, AL));\n}\n\nstatic void handleObjCRuntimeName(Sema &S, Decl *D, const ParsedAttr &AL) {\n  StringRef MetaDataName;\n  if (!S.checkStringLiteralArgumentAttr(AL, 0, MetaDataName))\n    return;\n  D->addAttr(::new (S.Context)\n                 ObjCRuntimeNameAttr(S.Context, AL, MetaDataName));\n}\n\n// When a user wants to use objc_boxable with a union or struct\n// but they don't have access to the declaration (legacy/third-party code)\n// then they can 'enable' this feature with a typedef:\n// typedef struct __attribute((objc_boxable)) legacy_struct legacy_struct;\nstatic void handleObjCBoxable(Sema &S, Decl *D, const ParsedAttr &AL) {\n  bool notify = false;\n\n  auto *RD = dyn_cast<RecordDecl>(D);\n  if (RD && RD->getDefinition()) {\n    RD = RD->getDefinition();\n    notify = true;\n  }\n\n  if (RD) {\n    ObjCBoxableAttr *BoxableAttr =\n        ::new (S.Context) ObjCBoxableAttr(S.Context, AL);\n    RD->addAttr(BoxableAttr);\n    if (notify) {\n      // we need to notify ASTReader/ASTWriter about\n      // modification of existing declaration\n      if (ASTMutationListener *L = S.getASTMutationListener())\n        L->AddedAttributeToRecord(BoxableAttr, RD);\n    }\n  }\n}\n\nstatic void handleObjCOwnershipAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  if (hasDeclarator(D)) return;\n\n  S.Diag(D->getBeginLoc(), diag::err_attribute_wrong_decl_type)\n      << AL.getRange() << AL << ExpectedVariable;\n}\n\nstatic void handleObjCPreciseLifetimeAttr(Sema &S, Decl *D,\n                                          const ParsedAttr &AL) {\n  const auto *VD = cast<ValueDecl>(D);\n  QualType QT = VD->getType();\n\n  if (!QT->isDependentType() &&\n      !QT->isObjCLifetimeType()) {\n    S.Diag(AL.getLoc(), diag::err_objc_precise_lifetime_bad_type)\n      << QT;\n    return;\n  }\n\n  Qualifiers::ObjCLifetime Lifetime = QT.getObjCLifetime();\n\n  // If we have no lifetime yet, check the lifetime we're presumably\n  // going to infer.\n  if (Lifetime == Qualifiers::OCL_None && !QT->isDependentType())\n    Lifetime = QT->getObjCARCImplicitLifetime();\n\n  switch (Lifetime) {\n  case Qualifiers::OCL_None:\n    assert(QT->isDependentType() &&\n           \"didn't infer lifetime for non-dependent type?\");\n    break;\n\n  case Qualifiers::OCL_Weak:   // meaningful\n  case Qualifiers::OCL_Strong: // meaningful\n    break;\n\n  case Qualifiers::OCL_ExplicitNone:\n  case Qualifiers::OCL_Autoreleasing:\n    S.Diag(AL.getLoc(), diag::warn_objc_precise_lifetime_meaningless)\n        << (Lifetime == Qualifiers::OCL_Autoreleasing);\n    break;\n  }\n\n  D->addAttr(::new (S.Context) ObjCPreciseLifetimeAttr(S.Context, AL));\n}\n\nstatic void handleSwiftAttrAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  // Make sure that there is a string literal as the annotation's single\n  // argument.\n  StringRef Str;\n  if (!S.checkStringLiteralArgumentAttr(AL, 0, Str))\n    return;\n\n  D->addAttr(::new (S.Context) SwiftAttrAttr(S.Context, AL, Str));\n}\n\nstatic void handleSwiftBridge(Sema &S, Decl *D, const ParsedAttr &AL) {\n  // Make sure that there is a string literal as the annotation's single\n  // argument.\n  StringRef BT;\n  if (!S.checkStringLiteralArgumentAttr(AL, 0, BT))\n    return;\n\n  // Warn about duplicate attributes if they have different arguments, but drop\n  // any duplicate attributes regardless.\n  if (const auto *Other = D->getAttr<SwiftBridgeAttr>()) {\n    if (Other->getSwiftType() != BT)\n      S.Diag(AL.getLoc(), diag::warn_duplicate_attribute) << AL;\n    return;\n  }\n\n  D->addAttr(::new (S.Context) SwiftBridgeAttr(S.Context, AL, BT));\n}\n\nstatic bool isErrorParameter(Sema &S, QualType QT) {\n  const auto *PT = QT->getAs<PointerType>();\n  if (!PT)\n    return false;\n\n  QualType Pointee = PT->getPointeeType();\n\n  // Check for NSError**.\n  if (const auto *OPT = Pointee->getAs<ObjCObjectPointerType>())\n    if (const auto *ID = OPT->getInterfaceDecl())\n      if (ID->getIdentifier() == S.getNSErrorIdent())\n        return true;\n\n  // Check for CFError**.\n  if (const auto *PT = Pointee->getAs<PointerType>())\n    if (const auto *RT = PT->getPointeeType()->getAs<RecordType>())\n      if (S.isCFError(RT->getDecl()))\n        return true;\n\n  return false;\n}\n\nstatic void handleSwiftError(Sema &S, Decl *D, const ParsedAttr &AL) {\n  auto hasErrorParameter = [](Sema &S, Decl *D, const ParsedAttr &AL) -> bool {\n    for (unsigned I = 0, E = getFunctionOrMethodNumParams(D); I != E; ++I) {\n      if (isErrorParameter(S, getFunctionOrMethodParamType(D, I)))\n        return true;\n    }\n\n    S.Diag(AL.getLoc(), diag::err_attr_swift_error_no_error_parameter)\n        << AL << isa<ObjCMethodDecl>(D);\n    return false;\n  };\n\n  auto hasPointerResult = [](Sema &S, Decl *D, const ParsedAttr &AL) -> bool {\n    // - C, ObjC, and block pointers are definitely okay.\n    // - References are definitely not okay.\n    // - nullptr_t is weird, but acceptable.\n    QualType RT = getFunctionOrMethodResultType(D);\n    if (RT->hasPointerRepresentation() && !RT->isReferenceType())\n      return true;\n\n    S.Diag(AL.getLoc(), diag::err_attr_swift_error_return_type)\n        << AL << AL.getArgAsIdent(0)->Ident->getName() << isa<ObjCMethodDecl>(D)\n        << /*pointer*/ 1;\n    return false;\n  };\n\n  auto hasIntegerResult = [](Sema &S, Decl *D, const ParsedAttr &AL) -> bool {\n    QualType RT = getFunctionOrMethodResultType(D);\n    if (RT->isIntegralType(S.Context))\n      return true;\n\n    S.Diag(AL.getLoc(), diag::err_attr_swift_error_return_type)\n        << AL << AL.getArgAsIdent(0)->Ident->getName() << isa<ObjCMethodDecl>(D)\n        << /*integral*/ 0;\n    return false;\n  };\n\n  if (D->isInvalidDecl())\n    return;\n\n  IdentifierLoc *Loc = AL.getArgAsIdent(0);\n  SwiftErrorAttr::ConventionKind Convention;\n  if (!SwiftErrorAttr::ConvertStrToConventionKind(Loc->Ident->getName(),\n                                                  Convention)) {\n    S.Diag(AL.getLoc(), diag::warn_attribute_type_not_supported)\n        << AL << Loc->Ident;\n    return;\n  }\n\n  switch (Convention) {\n  case SwiftErrorAttr::None:\n    // No additional validation required.\n    break;\n\n  case SwiftErrorAttr::NonNullError:\n    if (!hasErrorParameter(S, D, AL))\n      return;\n    break;\n\n  case SwiftErrorAttr::NullResult:\n    if (!hasErrorParameter(S, D, AL) || !hasPointerResult(S, D, AL))\n      return;\n    break;\n\n  case SwiftErrorAttr::NonZeroResult:\n  case SwiftErrorAttr::ZeroResult:\n    if (!hasErrorParameter(S, D, AL) || !hasIntegerResult(S, D, AL))\n      return;\n    break;\n  }\n\n  D->addAttr(::new (S.Context) SwiftErrorAttr(S.Context, AL, Convention));\n}\n\nstatic void checkSwiftAsyncErrorBlock(Sema &S, Decl *D,\n                                      const SwiftAsyncErrorAttr *ErrorAttr,\n                                      const SwiftAsyncAttr *AsyncAttr) {\n  if (AsyncAttr->getKind() == SwiftAsyncAttr::None) {\n    if (ErrorAttr->getConvention() != SwiftAsyncErrorAttr::None) {\n      S.Diag(AsyncAttr->getLocation(),\n             diag::err_swift_async_error_without_swift_async)\n          << AsyncAttr << isa<ObjCMethodDecl>(D);\n    }\n    return;\n  }\n\n  const ParmVarDecl *HandlerParam = getFunctionOrMethodParam(\n      D, AsyncAttr->getCompletionHandlerIndex().getASTIndex());\n  // handleSwiftAsyncAttr already verified the type is correct, so no need to\n  // double-check it here.\n  const auto *FuncTy = HandlerParam->getType()\n                           ->getAs<BlockPointerType>()\n                           ->getPointeeType()\n                           ->getAs<FunctionProtoType>();\n  ArrayRef<QualType> BlockParams;\n  if (FuncTy)\n    BlockParams = FuncTy->getParamTypes();\n\n  switch (ErrorAttr->getConvention()) {\n  case SwiftAsyncErrorAttr::ZeroArgument:\n  case SwiftAsyncErrorAttr::NonZeroArgument: {\n    uint32_t ParamIdx = ErrorAttr->getHandlerParamIdx();\n    if (ParamIdx == 0 || ParamIdx > BlockParams.size()) {\n      S.Diag(ErrorAttr->getLocation(),\n             diag::err_attribute_argument_out_of_bounds) << ErrorAttr << 2;\n      return;\n    }\n    QualType ErrorParam = BlockParams[ParamIdx - 1];\n    if (!ErrorParam->isIntegralType(S.Context)) {\n      StringRef ConvStr =\n          ErrorAttr->getConvention() == SwiftAsyncErrorAttr::ZeroArgument\n              ? \"zero_argument\"\n              : \"nonzero_argument\";\n      S.Diag(ErrorAttr->getLocation(), diag::err_swift_async_error_non_integral)\n          << ErrorAttr << ConvStr << ParamIdx << ErrorParam;\n      return;\n    }\n    break;\n  }\n  case SwiftAsyncErrorAttr::NonNullError: {\n    bool AnyErrorParams = false;\n    for (QualType Param : BlockParams) {\n      // Check for NSError *.\n      if (const auto *ObjCPtrTy = Param->getAs<ObjCObjectPointerType>()) {\n        if (const auto *ID = ObjCPtrTy->getInterfaceDecl()) {\n          if (ID->getIdentifier() == S.getNSErrorIdent()) {\n            AnyErrorParams = true;\n            break;\n          }\n        }\n      }\n      // Check for CFError *.\n      if (const auto *PtrTy = Param->getAs<PointerType>()) {\n        if (const auto *RT = PtrTy->getPointeeType()->getAs<RecordType>()) {\n          if (S.isCFError(RT->getDecl())) {\n            AnyErrorParams = true;\n            break;\n          }\n        }\n      }\n    }\n\n    if (!AnyErrorParams) {\n      S.Diag(ErrorAttr->getLocation(),\n             diag::err_swift_async_error_no_error_parameter)\n          << ErrorAttr << isa<ObjCMethodDecl>(D);\n      return;\n    }\n    break;\n  }\n  case SwiftAsyncErrorAttr::None:\n    break;\n  }\n}\n\nstatic void handleSwiftAsyncError(Sema &S, Decl *D, const ParsedAttr &AL) {\n  IdentifierLoc *IDLoc = AL.getArgAsIdent(0);\n  SwiftAsyncErrorAttr::ConventionKind ConvKind;\n  if (!SwiftAsyncErrorAttr::ConvertStrToConventionKind(IDLoc->Ident->getName(),\n                                                       ConvKind)) {\n    S.Diag(AL.getLoc(), diag::warn_attribute_type_not_supported)\n        << AL << IDLoc->Ident;\n    return;\n  }\n\n  uint32_t ParamIdx = 0;\n  switch (ConvKind) {\n  case SwiftAsyncErrorAttr::ZeroArgument:\n  case SwiftAsyncErrorAttr::NonZeroArgument: {\n    if (!AL.checkExactlyNumArgs(S, 2))\n      return;\n\n    Expr *IdxExpr = AL.getArgAsExpr(1);\n    if (!checkUInt32Argument(S, AL, IdxExpr, ParamIdx))\n      return;\n    break;\n  }\n  case SwiftAsyncErrorAttr::NonNullError:\n  case SwiftAsyncErrorAttr::None: {\n    if (!AL.checkExactlyNumArgs(S, 1))\n      return;\n    break;\n  }\n  }\n\n  auto *ErrorAttr =\n      ::new (S.Context) SwiftAsyncErrorAttr(S.Context, AL, ConvKind, ParamIdx);\n  D->addAttr(ErrorAttr);\n\n  if (auto *AsyncAttr = D->getAttr<SwiftAsyncAttr>())\n    checkSwiftAsyncErrorBlock(S, D, ErrorAttr, AsyncAttr);\n}\n\n// For a function, this will validate a compound Swift name, e.g.\n// <code>init(foo:bar:baz:)</code> or <code>controllerForName(_:)</code>, and\n// the function will output the number of parameter names, and whether this is a\n// single-arg initializer.\n//\n// For a type, enum constant, property, or variable declaration, this will\n// validate either a simple identifier, or a qualified\n// <code>context.identifier</code> name.\nstatic bool\nvalidateSwiftFunctionName(Sema &S, const ParsedAttr &AL, SourceLocation Loc,\n                          StringRef Name, unsigned &SwiftParamCount,\n                          bool &IsSingleParamInit) {\n  SwiftParamCount = 0;\n  IsSingleParamInit = false;\n\n  // Check whether this will be mapped to a getter or setter of a property.\n  bool IsGetter = false, IsSetter = false;\n  if (Name.startswith(\"getter:\")) {\n    IsGetter = true;\n    Name = Name.substr(7);\n  } else if (Name.startswith(\"setter:\")) {\n    IsSetter = true;\n    Name = Name.substr(7);\n  }\n\n  if (Name.back() != ')') {\n    S.Diag(Loc, diag::warn_attr_swift_name_function) << AL;\n    return false;\n  }\n\n  bool IsMember = false;\n  StringRef ContextName, BaseName, Parameters;\n\n  std::tie(BaseName, Parameters) = Name.split('(');\n\n  // Split at the first '.', if it exists, which separates the context name\n  // from the base name.\n  std::tie(ContextName, BaseName) = BaseName.split('.');\n  if (BaseName.empty()) {\n    BaseName = ContextName;\n    ContextName = StringRef();\n  } else if (ContextName.empty() || !isValidIdentifier(ContextName)) {\n    S.Diag(Loc, diag::warn_attr_swift_name_invalid_identifier)\n        << AL << /*context*/ 1;\n    return false;\n  } else {\n    IsMember = true;\n  }\n\n  if (!isValidIdentifier(BaseName) || BaseName == \"_\") {\n    S.Diag(Loc, diag::warn_attr_swift_name_invalid_identifier)\n        << AL << /*basename*/ 0;\n    return false;\n  }\n\n  bool IsSubscript = BaseName == \"subscript\";\n  // A subscript accessor must be a getter or setter.\n  if (IsSubscript && !IsGetter && !IsSetter) {\n    S.Diag(Loc, diag::warn_attr_swift_name_subscript_invalid_parameter)\n        << AL << /* getter or setter */ 0;\n    return false;\n  }\n\n  if (Parameters.empty()) {\n    S.Diag(Loc, diag::warn_attr_swift_name_missing_parameters) << AL;\n    return false;\n  }\n\n  assert(Parameters.back() == ')' && \"expected ')'\");\n  Parameters = Parameters.drop_back(); // ')'\n\n  if (Parameters.empty()) {\n    // Setters and subscripts must have at least one parameter.\n    if (IsSubscript) {\n      S.Diag(Loc, diag::warn_attr_swift_name_subscript_invalid_parameter)\n          << AL << /* have at least one parameter */1;\n      return false;\n    }\n\n    if (IsSetter) {\n      S.Diag(Loc, diag::warn_attr_swift_name_setter_parameters) << AL;\n      return false;\n    }\n\n    return true;\n  }\n\n  if (Parameters.back() != ':') {\n    S.Diag(Loc, diag::warn_attr_swift_name_function) << AL;\n    return false;\n  }\n\n  StringRef CurrentParam;\n  llvm::Optional<unsigned> SelfLocation;\n  unsigned NewValueCount = 0;\n  llvm::Optional<unsigned> NewValueLocation;\n  do {\n    std::tie(CurrentParam, Parameters) = Parameters.split(':');\n\n    if (!isValidIdentifier(CurrentParam)) {\n      S.Diag(Loc, diag::warn_attr_swift_name_invalid_identifier)\n          << AL << /*parameter*/2;\n      return false;\n    }\n\n    if (IsMember && CurrentParam == \"self\") {\n      // \"self\" indicates the \"self\" argument for a member.\n\n      // More than one \"self\"?\n      if (SelfLocation) {\n        S.Diag(Loc, diag::warn_attr_swift_name_multiple_selfs) << AL;\n        return false;\n      }\n\n      // The \"self\" location is the current parameter.\n      SelfLocation = SwiftParamCount;\n    } else if (CurrentParam == \"newValue\") {\n      // \"newValue\" indicates the \"newValue\" argument for a setter.\n\n      // There should only be one 'newValue', but it's only significant for\n      // subscript accessors, so don't error right away.\n      ++NewValueCount;\n\n      NewValueLocation = SwiftParamCount;\n    }\n\n    ++SwiftParamCount;\n  } while (!Parameters.empty());\n\n  // Only instance subscripts are currently supported.\n  if (IsSubscript && !SelfLocation) {\n    S.Diag(Loc, diag::warn_attr_swift_name_subscript_invalid_parameter)\n        << AL << /*have a 'self:' parameter*/2;\n    return false;\n  }\n\n  IsSingleParamInit =\n        SwiftParamCount == 1 && BaseName == \"init\" && CurrentParam != \"_\";\n\n  // Check the number of parameters for a getter/setter.\n  if (IsGetter || IsSetter) {\n    // Setters have one parameter for the new value.\n    unsigned NumExpectedParams = IsGetter ? 0 : 1;\n    unsigned ParamDiag =\n        IsGetter ? diag::warn_attr_swift_name_getter_parameters\n                 : diag::warn_attr_swift_name_setter_parameters;\n\n    // Instance methods have one parameter for \"self\".\n    if (SelfLocation)\n      ++NumExpectedParams;\n\n    // Subscripts may have additional parameters beyond the expected params for\n    // the index.\n    if (IsSubscript) {\n      if (SwiftParamCount < NumExpectedParams) {\n        S.Diag(Loc, ParamDiag) << AL;\n        return false;\n      }\n\n      // A subscript setter must explicitly label its newValue parameter to\n      // distinguish it from index parameters.\n      if (IsSetter) {\n        if (!NewValueLocation) {\n          S.Diag(Loc, diag::warn_attr_swift_name_subscript_setter_no_newValue)\n              << AL;\n          return false;\n        }\n        if (NewValueCount > 1) {\n          S.Diag(Loc, diag::warn_attr_swift_name_subscript_setter_multiple_newValues)\n              << AL;\n          return false;\n        }\n      } else {\n        // Subscript getters should have no 'newValue:' parameter.\n        if (NewValueLocation) {\n          S.Diag(Loc, diag::warn_attr_swift_name_subscript_getter_newValue)\n              << AL;\n          return false;\n        }\n      }\n    } else {\n      // Property accessors must have exactly the number of expected params.\n      if (SwiftParamCount != NumExpectedParams) {\n        S.Diag(Loc, ParamDiag) << AL;\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\nbool Sema::DiagnoseSwiftName(Decl *D, StringRef Name, SourceLocation Loc,\n                             const ParsedAttr &AL, bool IsAsync) {\n  if (isa<ObjCMethodDecl>(D) || isa<FunctionDecl>(D)) {\n    ArrayRef<ParmVarDecl*> Params;\n    unsigned ParamCount;\n\n    if (const auto *Method = dyn_cast<ObjCMethodDecl>(D)) {\n      ParamCount = Method->getSelector().getNumArgs();\n      Params = Method->parameters().slice(0, ParamCount);\n    } else {\n      const auto *F = cast<FunctionDecl>(D);\n\n      ParamCount = F->getNumParams();\n      Params = F->parameters();\n\n      if (!F->hasWrittenPrototype()) {\n        Diag(Loc, diag::warn_attribute_wrong_decl_type) << AL\n            << ExpectedFunctionWithProtoType;\n        return false;\n      }\n    }\n\n    // The async name drops the last callback parameter.\n    if (IsAsync) {\n      if (ParamCount == 0) {\n        Diag(Loc, diag::warn_attr_swift_name_decl_missing_params)\n            << AL << isa<ObjCMethodDecl>(D);\n        return false;\n      }\n      ParamCount -= 1;\n    }\n\n    unsigned SwiftParamCount;\n    bool IsSingleParamInit;\n    if (!validateSwiftFunctionName(*this, AL, Loc, Name,\n                                   SwiftParamCount, IsSingleParamInit))\n      return false;\n\n    bool ParamCountValid;\n    if (SwiftParamCount == ParamCount) {\n      ParamCountValid = true;\n    } else if (SwiftParamCount > ParamCount) {\n      ParamCountValid = IsSingleParamInit && ParamCount == 0;\n    } else {\n      // We have fewer Swift parameters than Objective-C parameters, but that\n      // might be because we've transformed some of them. Check for potential\n      // \"out\" parameters and err on the side of not warning.\n      unsigned MaybeOutParamCount =\n          std::count_if(Params.begin(), Params.end(),\n                        [](const ParmVarDecl *Param) -> bool {\n        QualType ParamTy = Param->getType();\n        if (ParamTy->isReferenceType() || ParamTy->isPointerType())\n          return !ParamTy->getPointeeType().isConstQualified();\n        return false;\n      });\n\n      ParamCountValid = SwiftParamCount + MaybeOutParamCount >= ParamCount;\n    }\n\n    if (!ParamCountValid) {\n      Diag(Loc, diag::warn_attr_swift_name_num_params)\n          << (SwiftParamCount > ParamCount) << AL << ParamCount\n          << SwiftParamCount;\n      return false;\n    }\n  } else if ((isa<EnumConstantDecl>(D) || isa<ObjCProtocolDecl>(D) ||\n              isa<ObjCInterfaceDecl>(D) || isa<ObjCPropertyDecl>(D) ||\n              isa<VarDecl>(D) || isa<TypedefNameDecl>(D) || isa<TagDecl>(D) ||\n              isa<IndirectFieldDecl>(D) || isa<FieldDecl>(D)) &&\n             !IsAsync) {\n    StringRef ContextName, BaseName;\n\n    std::tie(ContextName, BaseName) = Name.split('.');\n    if (BaseName.empty()) {\n      BaseName = ContextName;\n      ContextName = StringRef();\n    } else if (!isValidIdentifier(ContextName)) {\n      Diag(Loc, diag::warn_attr_swift_name_invalid_identifier) << AL\n          << /*context*/1;\n      return false;\n    }\n\n    if (!isValidIdentifier(BaseName)) {\n      Diag(Loc, diag::warn_attr_swift_name_invalid_identifier) << AL\n          << /*basename*/0;\n      return false;\n    }\n  } else {\n    Diag(Loc, diag::warn_attr_swift_name_decl_kind) << AL;\n    return false;\n  }\n  return true;\n}\n\nstatic void handleSwiftName(Sema &S, Decl *D, const ParsedAttr &AL) {\n  StringRef Name;\n  SourceLocation Loc;\n  if (!S.checkStringLiteralArgumentAttr(AL, 0, Name, &Loc))\n    return;\n\n  if (!S.DiagnoseSwiftName(D, Name, Loc, AL, /*IsAsync=*/false))\n    return;\n\n  D->addAttr(::new (S.Context) SwiftNameAttr(S.Context, AL, Name));\n}\n\nstatic void handleSwiftAsyncName(Sema &S, Decl *D, const ParsedAttr &AL) {\n  StringRef Name;\n  SourceLocation Loc;\n  if (!S.checkStringLiteralArgumentAttr(AL, 0, Name, &Loc))\n    return;\n\n  if (!S.DiagnoseSwiftName(D, Name, Loc, AL, /*IsAsync=*/true))\n    return;\n\n  D->addAttr(::new (S.Context) SwiftAsyncNameAttr(S.Context, AL, Name));\n}\n\nstatic void handleSwiftNewType(Sema &S, Decl *D, const ParsedAttr &AL) {\n  // Make sure that there is an identifier as the annotation's single argument.\n  if (!AL.checkExactlyNumArgs(S, 1))\n    return;\n\n  if (!AL.isArgIdent(0)) {\n    S.Diag(AL.getLoc(), diag::err_attribute_argument_type)\n        << AL << AANT_ArgumentIdentifier;\n    return;\n  }\n\n  SwiftNewTypeAttr::NewtypeKind Kind;\n  IdentifierInfo *II = AL.getArgAsIdent(0)->Ident;\n  if (!SwiftNewTypeAttr::ConvertStrToNewtypeKind(II->getName(), Kind)) {\n    S.Diag(AL.getLoc(), diag::warn_attribute_type_not_supported) << AL << II;\n    return;\n  }\n\n  if (!isa<TypedefNameDecl>(D)) {\n    S.Diag(AL.getLoc(), diag::warn_attribute_wrong_decl_type_str)\n        << AL << \"typedefs\";\n    return;\n  }\n\n  D->addAttr(::new (S.Context) SwiftNewTypeAttr(S.Context, AL, Kind));\n}\n\nstatic void handleSwiftAsyncAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  if (!AL.isArgIdent(0)) {\n    S.Diag(AL.getLoc(), diag::err_attribute_argument_n_type)\n        << AL << 1 << AANT_ArgumentIdentifier;\n    return;\n  }\n\n  SwiftAsyncAttr::Kind Kind;\n  IdentifierInfo *II = AL.getArgAsIdent(0)->Ident;\n  if (!SwiftAsyncAttr::ConvertStrToKind(II->getName(), Kind)) {\n    S.Diag(AL.getLoc(), diag::err_swift_async_no_access) << AL << II;\n    return;\n  }\n\n  ParamIdx Idx;\n  if (Kind == SwiftAsyncAttr::None) {\n    // If this is 'none', then there shouldn't be any additional arguments.\n    if (!AL.checkExactlyNumArgs(S, 1))\n      return;\n  } else {\n    // Non-none swift_async requires a completion handler index argument.\n    if (!AL.checkExactlyNumArgs(S, 2))\n      return;\n\n    Expr *HandlerIdx = AL.getArgAsExpr(1);\n    if (!checkFunctionOrMethodParameterIndex(S, D, AL, 2, HandlerIdx, Idx))\n      return;\n\n    const ParmVarDecl *CompletionBlock =\n        getFunctionOrMethodParam(D, Idx.getASTIndex());\n    QualType CompletionBlockType = CompletionBlock->getType();\n    if (!CompletionBlockType->isBlockPointerType()) {\n      S.Diag(CompletionBlock->getLocation(),\n             diag::err_swift_async_bad_block_type)\n          << CompletionBlock->getType();\n      return;\n    }\n    QualType BlockTy =\n        CompletionBlockType->getAs<BlockPointerType>()->getPointeeType();\n    if (!BlockTy->getAs<FunctionType>()->getReturnType()->isVoidType()) {\n      S.Diag(CompletionBlock->getLocation(),\n             diag::err_swift_async_bad_block_type)\n          << CompletionBlock->getType();\n      return;\n    }\n  }\n\n  auto *AsyncAttr =\n      ::new (S.Context) SwiftAsyncAttr(S.Context, AL, Kind, Idx);\n  D->addAttr(AsyncAttr);\n\n  if (auto *ErrorAttr = D->getAttr<SwiftAsyncErrorAttr>())\n    checkSwiftAsyncErrorBlock(S, D, ErrorAttr, AsyncAttr);\n}\n\n//===----------------------------------------------------------------------===//\n// Microsoft specific attribute handlers.\n//===----------------------------------------------------------------------===//\n\nUuidAttr *Sema::mergeUuidAttr(Decl *D, const AttributeCommonInfo &CI,\n                              StringRef UuidAsWritten, MSGuidDecl *GuidDecl) {\n  if (const auto *UA = D->getAttr<UuidAttr>()) {\n    if (declaresSameEntity(UA->getGuidDecl(), GuidDecl))\n      return nullptr;\n    if (!UA->getGuid().empty()) {\n      Diag(UA->getLocation(), diag::err_mismatched_uuid);\n      Diag(CI.getLoc(), diag::note_previous_uuid);\n      D->dropAttr<UuidAttr>();\n    }\n  }\n\n  return ::new (Context) UuidAttr(Context, CI, UuidAsWritten, GuidDecl);\n}\n\nstatic void handleUuidAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  if (!S.LangOpts.CPlusPlus) {\n    S.Diag(AL.getLoc(), diag::err_attribute_not_supported_in_lang)\n        << AL << AttributeLangSupport::C;\n    return;\n  }\n\n  StringRef OrigStrRef;\n  SourceLocation LiteralLoc;\n  if (!S.checkStringLiteralArgumentAttr(AL, 0, OrigStrRef, &LiteralLoc))\n    return;\n\n  // GUID format is \"XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\" or\n  // \"{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}\", normalize to the former.\n  StringRef StrRef = OrigStrRef;\n  if (StrRef.size() == 38 && StrRef.front() == '{' && StrRef.back() == '}')\n    StrRef = StrRef.drop_front().drop_back();\n\n  // Validate GUID length.\n  if (StrRef.size() != 36) {\n    S.Diag(LiteralLoc, diag::err_attribute_uuid_malformed_guid);\n    return;\n  }\n\n  for (unsigned i = 0; i < 36; ++i) {\n    if (i == 8 || i == 13 || i == 18 || i == 23) {\n      if (StrRef[i] != '-') {\n        S.Diag(LiteralLoc, diag::err_attribute_uuid_malformed_guid);\n        return;\n      }\n    } else if (!isHexDigit(StrRef[i])) {\n      S.Diag(LiteralLoc, diag::err_attribute_uuid_malformed_guid);\n      return;\n    }\n  }\n\n  // Convert to our parsed format and canonicalize.\n  MSGuidDecl::Parts Parsed;\n  StrRef.substr(0, 8).getAsInteger(16, Parsed.Part1);\n  StrRef.substr(9, 4).getAsInteger(16, Parsed.Part2);\n  StrRef.substr(14, 4).getAsInteger(16, Parsed.Part3);\n  for (unsigned i = 0; i != 8; ++i)\n    StrRef.substr(19 + 2 * i + (i >= 2 ? 1 : 0), 2)\n        .getAsInteger(16, Parsed.Part4And5[i]);\n  MSGuidDecl *Guid = S.Context.getMSGuidDecl(Parsed);\n\n  // FIXME: It'd be nice to also emit a fixit removing uuid(...) (and, if it's\n  // the only thing in the [] list, the [] too), and add an insertion of\n  // __declspec(uuid(...)).  But sadly, neither the SourceLocs of the commas\n  // separating attributes nor of the [ and the ] are in the AST.\n  // Cf \"SourceLocations of attribute list delimiters - [[ ... , ... ]] etc\"\n  // on cfe-dev.\n  if (AL.isMicrosoftAttribute()) // Check for [uuid(...)] spelling.\n    S.Diag(AL.getLoc(), diag::warn_atl_uuid_deprecated);\n\n  UuidAttr *UA = S.mergeUuidAttr(D, AL, OrigStrRef, Guid);\n  if (UA)\n    D->addAttr(UA);\n}\n\nstatic void handleMSInheritanceAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  if (!S.LangOpts.CPlusPlus) {\n    S.Diag(AL.getLoc(), diag::err_attribute_not_supported_in_lang)\n        << AL << AttributeLangSupport::C;\n    return;\n  }\n  MSInheritanceAttr *IA = S.mergeMSInheritanceAttr(\n      D, AL, /*BestCase=*/true, (MSInheritanceModel)AL.getSemanticSpelling());\n  if (IA) {\n    D->addAttr(IA);\n    S.Consumer.AssignInheritanceModel(cast<CXXRecordDecl>(D));\n  }\n}\n\nstatic void handleDeclspecThreadAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  const auto *VD = cast<VarDecl>(D);\n  if (!S.Context.getTargetInfo().isTLSSupported()) {\n    S.Diag(AL.getLoc(), diag::err_thread_unsupported);\n    return;\n  }\n  if (VD->getTSCSpec() != TSCS_unspecified) {\n    S.Diag(AL.getLoc(), diag::err_declspec_thread_on_thread_variable);\n    return;\n  }\n  if (VD->hasLocalStorage()) {\n    S.Diag(AL.getLoc(), diag::err_thread_non_global) << \"__declspec(thread)\";\n    return;\n  }\n  D->addAttr(::new (S.Context) ThreadAttr(S.Context, AL));\n}\n\nstatic void handleAbiTagAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  SmallVector<StringRef, 4> Tags;\n  for (unsigned I = 0, E = AL.getNumArgs(); I != E; ++I) {\n    StringRef Tag;\n    if (!S.checkStringLiteralArgumentAttr(AL, I, Tag))\n      return;\n    Tags.push_back(Tag);\n  }\n\n  if (const auto *NS = dyn_cast<NamespaceDecl>(D)) {\n    if (!NS->isInline()) {\n      S.Diag(AL.getLoc(), diag::warn_attr_abi_tag_namespace) << 0;\n      return;\n    }\n    if (NS->isAnonymousNamespace()) {\n      S.Diag(AL.getLoc(), diag::warn_attr_abi_tag_namespace) << 1;\n      return;\n    }\n    if (AL.getNumArgs() == 0)\n      Tags.push_back(NS->getName());\n  } else if (!AL.checkAtLeastNumArgs(S, 1))\n    return;\n\n  // Store tags sorted and without duplicates.\n  llvm::sort(Tags);\n  Tags.erase(std::unique(Tags.begin(), Tags.end()), Tags.end());\n\n  D->addAttr(::new (S.Context)\n                 AbiTagAttr(S.Context, AL, Tags.data(), Tags.size()));\n}\n\nstatic void handleARMInterruptAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  // Check the attribute arguments.\n  if (AL.getNumArgs() > 1) {\n    S.Diag(AL.getLoc(), diag::err_attribute_too_many_arguments) << AL << 1;\n    return;\n  }\n\n  StringRef Str;\n  SourceLocation ArgLoc;\n\n  if (AL.getNumArgs() == 0)\n    Str = \"\";\n  else if (!S.checkStringLiteralArgumentAttr(AL, 0, Str, &ArgLoc))\n    return;\n\n  ARMInterruptAttr::InterruptType Kind;\n  if (!ARMInterruptAttr::ConvertStrToInterruptType(Str, Kind)) {\n    S.Diag(AL.getLoc(), diag::warn_attribute_type_not_supported) << AL << Str\n                                                                 << ArgLoc;\n    return;\n  }\n\n  D->addAttr(::new (S.Context) ARMInterruptAttr(S.Context, AL, Kind));\n}\n\nstatic void handleMSP430InterruptAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  // MSP430 'interrupt' attribute is applied to\n  // a function with no parameters and void return type.\n  if (!isFunctionOrMethod(D)) {\n    S.Diag(D->getLocation(), diag::warn_attribute_wrong_decl_type)\n        << \"'interrupt'\" << ExpectedFunctionOrMethod;\n    return;\n  }\n\n  if (hasFunctionProto(D) && getFunctionOrMethodNumParams(D) != 0) {\n    S.Diag(D->getLocation(), diag::warn_interrupt_attribute_invalid)\n        << /*MSP430*/ 1 << 0;\n    return;\n  }\n\n  if (!getFunctionOrMethodResultType(D)->isVoidType()) {\n    S.Diag(D->getLocation(), diag::warn_interrupt_attribute_invalid)\n        << /*MSP430*/ 1 << 1;\n    return;\n  }\n\n  // The attribute takes one integer argument.\n  if (!AL.checkExactlyNumArgs(S, 1))\n    return;\n\n  if (!AL.isArgExpr(0)) {\n    S.Diag(AL.getLoc(), diag::err_attribute_argument_type)\n        << AL << AANT_ArgumentIntegerConstant;\n    return;\n  }\n\n  Expr *NumParamsExpr = static_cast<Expr *>(AL.getArgAsExpr(0));\n  Optional<llvm::APSInt> NumParams = llvm::APSInt(32);\n  if (!(NumParams = NumParamsExpr->getIntegerConstantExpr(S.Context))) {\n    S.Diag(AL.getLoc(), diag::err_attribute_argument_type)\n        << AL << AANT_ArgumentIntegerConstant\n        << NumParamsExpr->getSourceRange();\n    return;\n  }\n  // The argument should be in range 0..63.\n  unsigned Num = NumParams->getLimitedValue(255);\n  if (Num > 63) {\n    S.Diag(AL.getLoc(), diag::err_attribute_argument_out_of_bounds)\n        << AL << (int)NumParams->getSExtValue()\n        << NumParamsExpr->getSourceRange();\n    return;\n  }\n\n  D->addAttr(::new (S.Context) MSP430InterruptAttr(S.Context, AL, Num));\n  D->addAttr(UsedAttr::CreateImplicit(S.Context));\n}\n\nstatic void handleMipsInterruptAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  // Only one optional argument permitted.\n  if (AL.getNumArgs() > 1) {\n    S.Diag(AL.getLoc(), diag::err_attribute_too_many_arguments) << AL << 1;\n    return;\n  }\n\n  StringRef Str;\n  SourceLocation ArgLoc;\n\n  if (AL.getNumArgs() == 0)\n    Str = \"\";\n  else if (!S.checkStringLiteralArgumentAttr(AL, 0, Str, &ArgLoc))\n    return;\n\n  // Semantic checks for a function with the 'interrupt' attribute for MIPS:\n  // a) Must be a function.\n  // b) Must have no parameters.\n  // c) Must have the 'void' return type.\n  // d) Cannot have the 'mips16' attribute, as that instruction set\n  //    lacks the 'eret' instruction.\n  // e) The attribute itself must either have no argument or one of the\n  //    valid interrupt types, see [MipsInterruptDocs].\n\n  if (!isFunctionOrMethod(D)) {\n    S.Diag(D->getLocation(), diag::warn_attribute_wrong_decl_type)\n        << \"'interrupt'\" << ExpectedFunctionOrMethod;\n    return;\n  }\n\n  if (hasFunctionProto(D) && getFunctionOrMethodNumParams(D) != 0) {\n    S.Diag(D->getLocation(), diag::warn_interrupt_attribute_invalid)\n        << /*MIPS*/ 0 << 0;\n    return;\n  }\n\n  if (!getFunctionOrMethodResultType(D)->isVoidType()) {\n    S.Diag(D->getLocation(), diag::warn_interrupt_attribute_invalid)\n        << /*MIPS*/ 0 << 1;\n    return;\n  }\n\n  if (checkAttrMutualExclusion<Mips16Attr>(S, D, AL))\n    return;\n\n  MipsInterruptAttr::InterruptType Kind;\n  if (!MipsInterruptAttr::ConvertStrToInterruptType(Str, Kind)) {\n    S.Diag(AL.getLoc(), diag::warn_attribute_type_not_supported)\n        << AL << \"'\" + std::string(Str) + \"'\";\n    return;\n  }\n\n  D->addAttr(::new (S.Context) MipsInterruptAttr(S.Context, AL, Kind));\n}\n\nstatic void handleM68kInterruptAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  if (!AL.checkExactlyNumArgs(S, 1))\n    return;\n\n  if (!AL.isArgExpr(0)) {\n    S.Diag(AL.getLoc(), diag::err_attribute_argument_type)\n        << AL << AANT_ArgumentIntegerConstant;\n    return;\n  }\n\n  // FIXME: Check for decl - it should be void ()(void).\n\n  Expr *NumParamsExpr = static_cast<Expr *>(AL.getArgAsExpr(0));\n  auto MaybeNumParams = NumParamsExpr->getIntegerConstantExpr(S.Context);\n  if (!MaybeNumParams) {\n    S.Diag(AL.getLoc(), diag::err_attribute_argument_type)\n        << AL << AANT_ArgumentIntegerConstant\n        << NumParamsExpr->getSourceRange();\n    return;\n  }\n\n  unsigned Num = MaybeNumParams->getLimitedValue(255);\n  if ((Num & 1) || Num > 30) {\n    S.Diag(AL.getLoc(), diag::err_attribute_argument_out_of_bounds)\n        << AL << (int)MaybeNumParams->getSExtValue()\n        << NumParamsExpr->getSourceRange();\n    return;\n  }\n\n  D->addAttr(::new (S.Context) M68kInterruptAttr(S.Context, AL, Num));\n  D->addAttr(UsedAttr::CreateImplicit(S.Context));\n}\n\nstatic void handleAnyX86InterruptAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  // Semantic checks for a function with the 'interrupt' attribute.\n  // a) Must be a function.\n  // b) Must have the 'void' return type.\n  // c) Must take 1 or 2 arguments.\n  // d) The 1st argument must be a pointer.\n  // e) The 2nd argument (if any) must be an unsigned integer.\n  if (!isFunctionOrMethod(D) || !hasFunctionProto(D) || isInstanceMethod(D) ||\n      CXXMethodDecl::isStaticOverloadedOperator(\n          cast<NamedDecl>(D)->getDeclName().getCXXOverloadedOperator())) {\n    S.Diag(AL.getLoc(), diag::warn_attribute_wrong_decl_type)\n        << AL << ExpectedFunctionWithProtoType;\n    return;\n  }\n  // Interrupt handler must have void return type.\n  if (!getFunctionOrMethodResultType(D)->isVoidType()) {\n    S.Diag(getFunctionOrMethodResultSourceRange(D).getBegin(),\n           diag::err_anyx86_interrupt_attribute)\n        << (S.Context.getTargetInfo().getTriple().getArch() == llvm::Triple::x86\n                ? 0\n                : 1)\n        << 0;\n    return;\n  }\n  // Interrupt handler must have 1 or 2 parameters.\n  unsigned NumParams = getFunctionOrMethodNumParams(D);\n  if (NumParams < 1 || NumParams > 2) {\n    S.Diag(D->getBeginLoc(), diag::err_anyx86_interrupt_attribute)\n        << (S.Context.getTargetInfo().getTriple().getArch() == llvm::Triple::x86\n                ? 0\n                : 1)\n        << 1;\n    return;\n  }\n  // The first argument must be a pointer.\n  if (!getFunctionOrMethodParamType(D, 0)->isPointerType()) {\n    S.Diag(getFunctionOrMethodParamRange(D, 0).getBegin(),\n           diag::err_anyx86_interrupt_attribute)\n        << (S.Context.getTargetInfo().getTriple().getArch() == llvm::Triple::x86\n                ? 0\n                : 1)\n        << 2;\n    return;\n  }\n  // The second argument, if present, must be an unsigned integer.\n  unsigned TypeSize =\n      S.Context.getTargetInfo().getTriple().getArch() == llvm::Triple::x86_64\n          ? 64\n          : 32;\n  if (NumParams == 2 &&\n      (!getFunctionOrMethodParamType(D, 1)->isUnsignedIntegerType() ||\n       S.Context.getTypeSize(getFunctionOrMethodParamType(D, 1)) != TypeSize)) {\n    S.Diag(getFunctionOrMethodParamRange(D, 1).getBegin(),\n           diag::err_anyx86_interrupt_attribute)\n        << (S.Context.getTargetInfo().getTriple().getArch() == llvm::Triple::x86\n                ? 0\n                : 1)\n        << 3 << S.Context.getIntTypeForBitwidth(TypeSize, /*Signed=*/false);\n    return;\n  }\n  D->addAttr(::new (S.Context) AnyX86InterruptAttr(S.Context, AL));\n  D->addAttr(UsedAttr::CreateImplicit(S.Context));\n}\n\nstatic void handleAVRInterruptAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  if (!isFunctionOrMethod(D)) {\n    S.Diag(D->getLocation(), diag::warn_attribute_wrong_decl_type)\n        << \"'interrupt'\" << ExpectedFunction;\n    return;\n  }\n\n  if (!AL.checkExactlyNumArgs(S, 0))\n    return;\n\n  handleSimpleAttribute<AVRInterruptAttr>(S, D, AL);\n}\n\nstatic void handleAVRSignalAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  if (!isFunctionOrMethod(D)) {\n    S.Diag(D->getLocation(), diag::warn_attribute_wrong_decl_type)\n        << \"'signal'\" << ExpectedFunction;\n    return;\n  }\n\n  if (!AL.checkExactlyNumArgs(S, 0))\n    return;\n\n  handleSimpleAttribute<AVRSignalAttr>(S, D, AL);\n}\n\nstatic void handleBPFPreserveAIRecord(Sema &S, RecordDecl *RD) {\n  // Add preserve_access_index attribute to all fields and inner records.\n  for (auto D : RD->decls()) {\n    if (D->hasAttr<BPFPreserveAccessIndexAttr>())\n      continue;\n\n    D->addAttr(BPFPreserveAccessIndexAttr::CreateImplicit(S.Context));\n    if (auto *Rec = dyn_cast<RecordDecl>(D))\n      handleBPFPreserveAIRecord(S, Rec);\n  }\n}\n\nstatic void handleBPFPreserveAccessIndexAttr(Sema &S, Decl *D,\n    const ParsedAttr &AL) {\n  auto *Rec = cast<RecordDecl>(D);\n  handleBPFPreserveAIRecord(S, Rec);\n  Rec->addAttr(::new (S.Context) BPFPreserveAccessIndexAttr(S.Context, AL));\n}\n\nstatic void handleWebAssemblyExportNameAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  if (!isFunctionOrMethod(D)) {\n    S.Diag(D->getLocation(), diag::warn_attribute_wrong_decl_type)\n        << \"'export_name'\" << ExpectedFunction;\n    return;\n  }\n\n  auto *FD = cast<FunctionDecl>(D);\n  if (FD->isThisDeclarationADefinition()) {\n    S.Diag(D->getLocation(), diag::err_alias_is_definition) << FD << 0;\n    return;\n  }\n\n  StringRef Str;\n  SourceLocation ArgLoc;\n  if (!S.checkStringLiteralArgumentAttr(AL, 0, Str, &ArgLoc))\n    return;\n\n  D->addAttr(::new (S.Context) WebAssemblyExportNameAttr(S.Context, AL, Str));\n  D->addAttr(UsedAttr::CreateImplicit(S.Context));\n}\n\nWebAssemblyImportModuleAttr *\nSema::mergeImportModuleAttr(Decl *D, const WebAssemblyImportModuleAttr &AL) {\n  auto *FD = cast<FunctionDecl>(D);\n\n  if (const auto *ExistingAttr = FD->getAttr<WebAssemblyImportModuleAttr>()) {\n    if (ExistingAttr->getImportModule() == AL.getImportModule())\n      return nullptr;\n    Diag(ExistingAttr->getLocation(), diag::warn_mismatched_import) << 0\n      << ExistingAttr->getImportModule() << AL.getImportModule();\n    Diag(AL.getLoc(), diag::note_previous_attribute);\n    return nullptr;\n  }\n  if (FD->hasBody()) {\n    Diag(AL.getLoc(), diag::warn_import_on_definition) << 0;\n    return nullptr;\n  }\n  return ::new (Context) WebAssemblyImportModuleAttr(Context, AL,\n                                                     AL.getImportModule());\n}\n\nWebAssemblyImportNameAttr *\nSema::mergeImportNameAttr(Decl *D, const WebAssemblyImportNameAttr &AL) {\n  auto *FD = cast<FunctionDecl>(D);\n\n  if (const auto *ExistingAttr = FD->getAttr<WebAssemblyImportNameAttr>()) {\n    if (ExistingAttr->getImportName() == AL.getImportName())\n      return nullptr;\n    Diag(ExistingAttr->getLocation(), diag::warn_mismatched_import) << 1\n      << ExistingAttr->getImportName() << AL.getImportName();\n    Diag(AL.getLoc(), diag::note_previous_attribute);\n    return nullptr;\n  }\n  if (FD->hasBody()) {\n    Diag(AL.getLoc(), diag::warn_import_on_definition) << 1;\n    return nullptr;\n  }\n  return ::new (Context) WebAssemblyImportNameAttr(Context, AL,\n                                                   AL.getImportName());\n}\n\nstatic void\nhandleWebAssemblyImportModuleAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  auto *FD = cast<FunctionDecl>(D);\n\n  StringRef Str;\n  SourceLocation ArgLoc;\n  if (!S.checkStringLiteralArgumentAttr(AL, 0, Str, &ArgLoc))\n    return;\n  if (FD->hasBody()) {\n    S.Diag(AL.getLoc(), diag::warn_import_on_definition) << 0;\n    return;\n  }\n\n  FD->addAttr(::new (S.Context)\n                  WebAssemblyImportModuleAttr(S.Context, AL, Str));\n}\n\nstatic void\nhandleWebAssemblyImportNameAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  auto *FD = cast<FunctionDecl>(D);\n\n  StringRef Str;\n  SourceLocation ArgLoc;\n  if (!S.checkStringLiteralArgumentAttr(AL, 0, Str, &ArgLoc))\n    return;\n  if (FD->hasBody()) {\n    S.Diag(AL.getLoc(), diag::warn_import_on_definition) << 1;\n    return;\n  }\n\n  FD->addAttr(::new (S.Context) WebAssemblyImportNameAttr(S.Context, AL, Str));\n}\n\nstatic void handleRISCVInterruptAttr(Sema &S, Decl *D,\n                                     const ParsedAttr &AL) {\n  // Warn about repeated attributes.\n  if (const auto *A = D->getAttr<RISCVInterruptAttr>()) {\n    S.Diag(AL.getRange().getBegin(),\n      diag::warn_riscv_repeated_interrupt_attribute);\n    S.Diag(A->getLocation(), diag::note_riscv_repeated_interrupt_attribute);\n    return;\n  }\n\n  // Check the attribute argument. Argument is optional.\n  if (!AL.checkAtMostNumArgs(S, 1))\n    return;\n\n  StringRef Str;\n  SourceLocation ArgLoc;\n\n  // 'machine'is the default interrupt mode.\n  if (AL.getNumArgs() == 0)\n    Str = \"machine\";\n  else if (!S.checkStringLiteralArgumentAttr(AL, 0, Str, &ArgLoc))\n    return;\n\n  // Semantic checks for a function with the 'interrupt' attribute:\n  // - Must be a function.\n  // - Must have no parameters.\n  // - Must have the 'void' return type.\n  // - The attribute itself must either have no argument or one of the\n  //   valid interrupt types, see [RISCVInterruptDocs].\n\n  if (D->getFunctionType() == nullptr) {\n    S.Diag(D->getLocation(), diag::warn_attribute_wrong_decl_type)\n      << \"'interrupt'\" << ExpectedFunction;\n    return;\n  }\n\n  if (hasFunctionProto(D) && getFunctionOrMethodNumParams(D) != 0) {\n    S.Diag(D->getLocation(), diag::warn_interrupt_attribute_invalid)\n      << /*RISC-V*/ 2 << 0;\n    return;\n  }\n\n  if (!getFunctionOrMethodResultType(D)->isVoidType()) {\n    S.Diag(D->getLocation(), diag::warn_interrupt_attribute_invalid)\n      << /*RISC-V*/ 2 << 1;\n    return;\n  }\n\n  RISCVInterruptAttr::InterruptType Kind;\n  if (!RISCVInterruptAttr::ConvertStrToInterruptType(Str, Kind)) {\n    S.Diag(AL.getLoc(), diag::warn_attribute_type_not_supported) << AL << Str\n                                                                 << ArgLoc;\n    return;\n  }\n\n  D->addAttr(::new (S.Context) RISCVInterruptAttr(S.Context, AL, Kind));\n}\n\nstatic void handleInterruptAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  // Dispatch the interrupt attribute based on the current target.\n  switch (S.Context.getTargetInfo().getTriple().getArch()) {\n  case llvm::Triple::msp430:\n    handleMSP430InterruptAttr(S, D, AL);\n    break;\n  case llvm::Triple::mipsel:\n  case llvm::Triple::mips:\n    handleMipsInterruptAttr(S, D, AL);\n    break;\n  case llvm::Triple::m68k:\n    handleM68kInterruptAttr(S, D, AL);\n    break;\n  case llvm::Triple::x86:\n  case llvm::Triple::x86_64:\n    handleAnyX86InterruptAttr(S, D, AL);\n    break;\n  case llvm::Triple::avr:\n    handleAVRInterruptAttr(S, D, AL);\n    break;\n  case llvm::Triple::riscv32:\n  case llvm::Triple::riscv64:\n    handleRISCVInterruptAttr(S, D, AL);\n    break;\n  default:\n    handleARMInterruptAttr(S, D, AL);\n    break;\n  }\n}\n\nstatic bool\ncheckAMDGPUFlatWorkGroupSizeArguments(Sema &S, Expr *MinExpr, Expr *MaxExpr,\n                                      const AMDGPUFlatWorkGroupSizeAttr &Attr) {\n  // Accept template arguments for now as they depend on something else.\n  // We'll get to check them when they eventually get instantiated.\n  if (MinExpr->isValueDependent() || MaxExpr->isValueDependent())\n    return false;\n\n  uint32_t Min = 0;\n  if (!checkUInt32Argument(S, Attr, MinExpr, Min, 0))\n    return true;\n\n  uint32_t Max = 0;\n  if (!checkUInt32Argument(S, Attr, MaxExpr, Max, 1))\n    return true;\n\n  if (Min == 0 && Max != 0) {\n    S.Diag(Attr.getLocation(), diag::err_attribute_argument_invalid)\n        << &Attr << 0;\n    return true;\n  }\n  if (Min > Max) {\n    S.Diag(Attr.getLocation(), diag::err_attribute_argument_invalid)\n        << &Attr << 1;\n    return true;\n  }\n\n  return false;\n}\n\nvoid Sema::addAMDGPUFlatWorkGroupSizeAttr(Decl *D,\n                                          const AttributeCommonInfo &CI,\n                                          Expr *MinExpr, Expr *MaxExpr) {\n  AMDGPUFlatWorkGroupSizeAttr TmpAttr(Context, CI, MinExpr, MaxExpr);\n\n  if (checkAMDGPUFlatWorkGroupSizeArguments(*this, MinExpr, MaxExpr, TmpAttr))\n    return;\n\n  D->addAttr(::new (Context)\n                 AMDGPUFlatWorkGroupSizeAttr(Context, CI, MinExpr, MaxExpr));\n}\n\nstatic void handleAMDGPUFlatWorkGroupSizeAttr(Sema &S, Decl *D,\n                                              const ParsedAttr &AL) {\n  Expr *MinExpr = AL.getArgAsExpr(0);\n  Expr *MaxExpr = AL.getArgAsExpr(1);\n\n  S.addAMDGPUFlatWorkGroupSizeAttr(D, AL, MinExpr, MaxExpr);\n}\n\nstatic bool checkAMDGPUWavesPerEUArguments(Sema &S, Expr *MinExpr,\n                                           Expr *MaxExpr,\n                                           const AMDGPUWavesPerEUAttr &Attr) {\n  if (S.DiagnoseUnexpandedParameterPack(MinExpr) ||\n      (MaxExpr && S.DiagnoseUnexpandedParameterPack(MaxExpr)))\n    return true;\n\n  // Accept template arguments for now as they depend on something else.\n  // We'll get to check them when they eventually get instantiated.\n  if (MinExpr->isValueDependent() || (MaxExpr && MaxExpr->isValueDependent()))\n    return false;\n\n  uint32_t Min = 0;\n  if (!checkUInt32Argument(S, Attr, MinExpr, Min, 0))\n    return true;\n\n  uint32_t Max = 0;\n  if (MaxExpr && !checkUInt32Argument(S, Attr, MaxExpr, Max, 1))\n    return true;\n\n  if (Min == 0 && Max != 0) {\n    S.Diag(Attr.getLocation(), diag::err_attribute_argument_invalid)\n        << &Attr << 0;\n    return true;\n  }\n  if (Max != 0 && Min > Max) {\n    S.Diag(Attr.getLocation(), diag::err_attribute_argument_invalid)\n        << &Attr << 1;\n    return true;\n  }\n\n  return false;\n}\n\nvoid Sema::addAMDGPUWavesPerEUAttr(Decl *D, const AttributeCommonInfo &CI,\n                                   Expr *MinExpr, Expr *MaxExpr) {\n  AMDGPUWavesPerEUAttr TmpAttr(Context, CI, MinExpr, MaxExpr);\n\n  if (checkAMDGPUWavesPerEUArguments(*this, MinExpr, MaxExpr, TmpAttr))\n    return;\n\n  D->addAttr(::new (Context)\n                 AMDGPUWavesPerEUAttr(Context, CI, MinExpr, MaxExpr));\n}\n\nstatic void handleAMDGPUWavesPerEUAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  if (!AL.checkAtLeastNumArgs(S, 1) || !AL.checkAtMostNumArgs(S, 2))\n    return;\n\n  Expr *MinExpr = AL.getArgAsExpr(0);\n  Expr *MaxExpr = (AL.getNumArgs() > 1) ? AL.getArgAsExpr(1) : nullptr;\n\n  S.addAMDGPUWavesPerEUAttr(D, AL, MinExpr, MaxExpr);\n}\n\nstatic void handleAMDGPUNumSGPRAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  uint32_t NumSGPR = 0;\n  Expr *NumSGPRExpr = AL.getArgAsExpr(0);\n  if (!checkUInt32Argument(S, AL, NumSGPRExpr, NumSGPR))\n    return;\n\n  D->addAttr(::new (S.Context) AMDGPUNumSGPRAttr(S.Context, AL, NumSGPR));\n}\n\nstatic void handleAMDGPUNumVGPRAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  uint32_t NumVGPR = 0;\n  Expr *NumVGPRExpr = AL.getArgAsExpr(0);\n  if (!checkUInt32Argument(S, AL, NumVGPRExpr, NumVGPR))\n    return;\n\n  D->addAttr(::new (S.Context) AMDGPUNumVGPRAttr(S.Context, AL, NumVGPR));\n}\n\nstatic void handleX86ForceAlignArgPointerAttr(Sema &S, Decl *D,\n                                              const ParsedAttr &AL) {\n  // If we try to apply it to a function pointer, don't warn, but don't\n  // do anything, either. It doesn't matter anyway, because there's nothing\n  // special about calling a force_align_arg_pointer function.\n  const auto *VD = dyn_cast<ValueDecl>(D);\n  if (VD && VD->getType()->isFunctionPointerType())\n    return;\n  // Also don't warn on function pointer typedefs.\n  const auto *TD = dyn_cast<TypedefNameDecl>(D);\n  if (TD && (TD->getUnderlyingType()->isFunctionPointerType() ||\n    TD->getUnderlyingType()->isFunctionType()))\n    return;\n  // Attribute can only be applied to function types.\n  if (!isa<FunctionDecl>(D)) {\n    S.Diag(AL.getLoc(), diag::warn_attribute_wrong_decl_type)\n        << AL << ExpectedFunction;\n    return;\n  }\n\n  D->addAttr(::new (S.Context) X86ForceAlignArgPointerAttr(S.Context, AL));\n}\n\nstatic void handleLayoutVersion(Sema &S, Decl *D, const ParsedAttr &AL) {\n  uint32_t Version;\n  Expr *VersionExpr = static_cast<Expr *>(AL.getArgAsExpr(0));\n  if (!checkUInt32Argument(S, AL, AL.getArgAsExpr(0), Version))\n    return;\n\n  // TODO: Investigate what happens with the next major version of MSVC.\n  if (Version != LangOptions::MSVC2015 / 100) {\n    S.Diag(AL.getLoc(), diag::err_attribute_argument_out_of_bounds)\n        << AL << Version << VersionExpr->getSourceRange();\n    return;\n  }\n\n  // The attribute expects a \"major\" version number like 19, but new versions of\n  // MSVC have moved to updating the \"minor\", or less significant numbers, so we\n  // have to multiply by 100 now.\n  Version *= 100;\n\n  D->addAttr(::new (S.Context) LayoutVersionAttr(S.Context, AL, Version));\n}\n\nDLLImportAttr *Sema::mergeDLLImportAttr(Decl *D,\n                                        const AttributeCommonInfo &CI) {\n  if (D->hasAttr<DLLExportAttr>()) {\n    Diag(CI.getLoc(), diag::warn_attribute_ignored) << \"'dllimport'\";\n    return nullptr;\n  }\n\n  if (D->hasAttr<DLLImportAttr>())\n    return nullptr;\n\n  return ::new (Context) DLLImportAttr(Context, CI);\n}\n\nDLLExportAttr *Sema::mergeDLLExportAttr(Decl *D,\n                                        const AttributeCommonInfo &CI) {\n  if (DLLImportAttr *Import = D->getAttr<DLLImportAttr>()) {\n    Diag(Import->getLocation(), diag::warn_attribute_ignored) << Import;\n    D->dropAttr<DLLImportAttr>();\n  }\n\n  if (D->hasAttr<DLLExportAttr>())\n    return nullptr;\n\n  return ::new (Context) DLLExportAttr(Context, CI);\n}\n\nstatic void handleDLLAttr(Sema &S, Decl *D, const ParsedAttr &A) {\n  if (isa<ClassTemplatePartialSpecializationDecl>(D) &&\n      (S.Context.getTargetInfo().shouldDLLImportComdatSymbols())) {\n    S.Diag(A.getRange().getBegin(), diag::warn_attribute_ignored) << A;\n    return;\n  }\n\n  if (const auto *FD = dyn_cast<FunctionDecl>(D)) {\n    if (FD->isInlined() && A.getKind() == ParsedAttr::AT_DLLImport &&\n        !(S.Context.getTargetInfo().shouldDLLImportComdatSymbols())) {\n      // MinGW doesn't allow dllimport on inline functions.\n      S.Diag(A.getRange().getBegin(), diag::warn_attribute_ignored_on_inline)\n          << A;\n      return;\n    }\n  }\n\n  if (const auto *MD = dyn_cast<CXXMethodDecl>(D)) {\n    if ((S.Context.getTargetInfo().shouldDLLImportComdatSymbols()) &&\n        MD->getParent()->isLambda()) {\n      S.Diag(A.getRange().getBegin(), diag::err_attribute_dll_lambda) << A;\n      return;\n    }\n  }\n\n  Attr *NewAttr = A.getKind() == ParsedAttr::AT_DLLExport\n                      ? (Attr *)S.mergeDLLExportAttr(D, A)\n                      : (Attr *)S.mergeDLLImportAttr(D, A);\n  if (NewAttr)\n    D->addAttr(NewAttr);\n}\n\nMSInheritanceAttr *\nSema::mergeMSInheritanceAttr(Decl *D, const AttributeCommonInfo &CI,\n                             bool BestCase,\n                             MSInheritanceModel Model) {\n  if (MSInheritanceAttr *IA = D->getAttr<MSInheritanceAttr>()) {\n    if (IA->getInheritanceModel() == Model)\n      return nullptr;\n    Diag(IA->getLocation(), diag::err_mismatched_ms_inheritance)\n        << 1 /*previous declaration*/;\n    Diag(CI.getLoc(), diag::note_previous_ms_inheritance);\n    D->dropAttr<MSInheritanceAttr>();\n  }\n\n  auto *RD = cast<CXXRecordDecl>(D);\n  if (RD->hasDefinition()) {\n    if (checkMSInheritanceAttrOnDefinition(RD, CI.getRange(), BestCase,\n                                           Model)) {\n      return nullptr;\n    }\n  } else {\n    if (isa<ClassTemplatePartialSpecializationDecl>(RD)) {\n      Diag(CI.getLoc(), diag::warn_ignored_ms_inheritance)\n          << 1 /*partial specialization*/;\n      return nullptr;\n    }\n    if (RD->getDescribedClassTemplate()) {\n      Diag(CI.getLoc(), diag::warn_ignored_ms_inheritance)\n          << 0 /*primary template*/;\n      return nullptr;\n    }\n  }\n\n  return ::new (Context) MSInheritanceAttr(Context, CI, BestCase);\n}\n\nstatic void handleCapabilityAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  // The capability attributes take a single string parameter for the name of\n  // the capability they represent. The lockable attribute does not take any\n  // parameters. However, semantically, both attributes represent the same\n  // concept, and so they use the same semantic attribute. Eventually, the\n  // lockable attribute will be removed.\n  //\n  // For backward compatibility, any capability which has no specified string\n  // literal will be considered a \"mutex.\"\n  StringRef N(\"mutex\");\n  SourceLocation LiteralLoc;\n  if (AL.getKind() == ParsedAttr::AT_Capability &&\n      !S.checkStringLiteralArgumentAttr(AL, 0, N, &LiteralLoc))\n    return;\n\n  D->addAttr(::new (S.Context) CapabilityAttr(S.Context, AL, N));\n}\n\nstatic void handleAssertCapabilityAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  SmallVector<Expr*, 1> Args;\n  if (!checkLockFunAttrCommon(S, D, AL, Args))\n    return;\n\n  D->addAttr(::new (S.Context)\n                 AssertCapabilityAttr(S.Context, AL, Args.data(), Args.size()));\n}\n\nstatic void handleAcquireCapabilityAttr(Sema &S, Decl *D,\n                                        const ParsedAttr &AL) {\n  SmallVector<Expr*, 1> Args;\n  if (!checkLockFunAttrCommon(S, D, AL, Args))\n    return;\n\n  D->addAttr(::new (S.Context) AcquireCapabilityAttr(S.Context, AL, Args.data(),\n                                                     Args.size()));\n}\n\nstatic void handleTryAcquireCapabilityAttr(Sema &S, Decl *D,\n                                           const ParsedAttr &AL) {\n  SmallVector<Expr*, 2> Args;\n  if (!checkTryLockFunAttrCommon(S, D, AL, Args))\n    return;\n\n  D->addAttr(::new (S.Context) TryAcquireCapabilityAttr(\n      S.Context, AL, AL.getArgAsExpr(0), Args.data(), Args.size()));\n}\n\nstatic void handleReleaseCapabilityAttr(Sema &S, Decl *D,\n                                        const ParsedAttr &AL) {\n  // Check that all arguments are lockable objects.\n  SmallVector<Expr *, 1> Args;\n  checkAttrArgsAreCapabilityObjs(S, D, AL, Args, 0, true);\n\n  D->addAttr(::new (S.Context) ReleaseCapabilityAttr(S.Context, AL, Args.data(),\n                                                     Args.size()));\n}\n\nstatic void handleRequiresCapabilityAttr(Sema &S, Decl *D,\n                                         const ParsedAttr &AL) {\n  if (!AL.checkAtLeastNumArgs(S, 1))\n    return;\n\n  // check that all arguments are lockable objects\n  SmallVector<Expr*, 1> Args;\n  checkAttrArgsAreCapabilityObjs(S, D, AL, Args);\n  if (Args.empty())\n    return;\n\n  RequiresCapabilityAttr *RCA = ::new (S.Context)\n      RequiresCapabilityAttr(S.Context, AL, Args.data(), Args.size());\n\n  D->addAttr(RCA);\n}\n\nstatic void handleDeprecatedAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  if (const auto *NSD = dyn_cast<NamespaceDecl>(D)) {\n    if (NSD->isAnonymousNamespace()) {\n      S.Diag(AL.getLoc(), diag::warn_deprecated_anonymous_namespace);\n      // Do not want to attach the attribute to the namespace because that will\n      // cause confusing diagnostic reports for uses of declarations within the\n      // namespace.\n      return;\n    }\n  }\n\n  // Handle the cases where the attribute has a text message.\n  StringRef Str, Replacement;\n  if (AL.isArgExpr(0) && AL.getArgAsExpr(0) &&\n      !S.checkStringLiteralArgumentAttr(AL, 0, Str))\n    return;\n\n  // Only support a single optional message for Declspec and CXX11.\n  if (AL.isDeclspecAttribute() || AL.isCXX11Attribute())\n    AL.checkAtMostNumArgs(S, 1);\n  else if (AL.isArgExpr(1) && AL.getArgAsExpr(1) &&\n           !S.checkStringLiteralArgumentAttr(AL, 1, Replacement))\n    return;\n\n  if (!S.getLangOpts().CPlusPlus14 && AL.isCXX11Attribute() && !AL.isGNUScope())\n    S.Diag(AL.getLoc(), diag::ext_cxx14_attr) << AL;\n\n  D->addAttr(::new (S.Context) DeprecatedAttr(S.Context, AL, Str, Replacement));\n}\n\nstatic bool isGlobalVar(const Decl *D) {\n  if (const auto *S = dyn_cast<VarDecl>(D))\n    return S->hasGlobalStorage();\n  return false;\n}\n\nstatic void handleNoSanitizeAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  if (!AL.checkAtLeastNumArgs(S, 1))\n    return;\n\n  std::vector<StringRef> Sanitizers;\n\n  for (unsigned I = 0, E = AL.getNumArgs(); I != E; ++I) {\n    StringRef SanitizerName;\n    SourceLocation LiteralLoc;\n\n    if (!S.checkStringLiteralArgumentAttr(AL, I, SanitizerName, &LiteralLoc))\n      return;\n\n    if (parseSanitizerValue(SanitizerName, /*AllowGroups=*/true) ==\n        SanitizerMask())\n      S.Diag(LiteralLoc, diag::warn_unknown_sanitizer_ignored) << SanitizerName;\n    else if (isGlobalVar(D) && SanitizerName != \"address\")\n      S.Diag(D->getLocation(), diag::err_attribute_wrong_decl_type)\n          << AL << ExpectedFunctionOrMethod;\n    Sanitizers.push_back(SanitizerName);\n  }\n\n  D->addAttr(::new (S.Context) NoSanitizeAttr(S.Context, AL, Sanitizers.data(),\n                                              Sanitizers.size()));\n}\n\nstatic void handleNoSanitizeSpecificAttr(Sema &S, Decl *D,\n                                         const ParsedAttr &AL) {\n  StringRef AttrName = AL.getAttrName()->getName();\n  normalizeName(AttrName);\n  StringRef SanitizerName = llvm::StringSwitch<StringRef>(AttrName)\n                                .Case(\"no_address_safety_analysis\", \"address\")\n                                .Case(\"no_sanitize_address\", \"address\")\n                                .Case(\"no_sanitize_thread\", \"thread\")\n                                .Case(\"no_sanitize_memory\", \"memory\");\n  if (isGlobalVar(D) && SanitizerName != \"address\")\n    S.Diag(D->getLocation(), diag::err_attribute_wrong_decl_type)\n        << AL << ExpectedFunction;\n\n  // FIXME: Rather than create a NoSanitizeSpecificAttr, this creates a\n  // NoSanitizeAttr object; but we need to calculate the correct spelling list\n  // index rather than incorrectly assume the index for NoSanitizeSpecificAttr\n  // has the same spellings as the index for NoSanitizeAttr. We don't have a\n  // general way to \"translate\" between the two, so this hack attempts to work\n  // around the issue with hard-coded indicies. This is critical for calling\n  // getSpelling() or prettyPrint() on the resulting semantic attribute object\n  // without failing assertions.\n  unsigned TranslatedSpellingIndex = 0;\n  if (AL.isC2xAttribute() || AL.isCXX11Attribute())\n    TranslatedSpellingIndex = 1;\n\n  AttributeCommonInfo Info = AL;\n  Info.setAttributeSpellingListIndex(TranslatedSpellingIndex);\n  D->addAttr(::new (S.Context)\n                 NoSanitizeAttr(S.Context, Info, &SanitizerName, 1));\n}\n\nstatic void handleInternalLinkageAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  if (InternalLinkageAttr *Internal = S.mergeInternalLinkageAttr(D, AL))\n    D->addAttr(Internal);\n}\n\nstatic void handleOpenCLNoSVMAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  if (S.LangOpts.OpenCLVersion != 200)\n    S.Diag(AL.getLoc(), diag::err_attribute_requires_opencl_version)\n        << AL << \"2.0\" << 0;\n  else\n    S.Diag(AL.getLoc(), diag::warn_opencl_attr_deprecated_ignored) << AL\n                                                                   << \"2.0\";\n}\n\n/// Handles semantic checking for features that are common to all attributes,\n/// such as checking whether a parameter was properly specified, or the correct\n/// number of arguments were passed, etc.\nstatic bool handleCommonAttributeFeatures(Sema &S, Decl *D,\n                                          const ParsedAttr &AL) {\n  // Several attributes carry different semantics than the parsing requires, so\n  // those are opted out of the common argument checks.\n  //\n  // We also bail on unknown and ignored attributes because those are handled\n  // as part of the target-specific handling logic.\n  if (AL.getKind() == ParsedAttr::UnknownAttribute)\n    return false;\n  // Check whether the attribute requires specific language extensions to be\n  // enabled.\n  if (!AL.diagnoseLangOpts(S))\n    return true;\n  // Check whether the attribute appertains to the given subject.\n  if (!AL.diagnoseAppertainsTo(S, D))\n    return true;\n  if (AL.hasCustomParsing())\n    return false;\n\n  if (AL.getMinArgs() == AL.getMaxArgs()) {\n    // If there are no optional arguments, then checking for the argument count\n    // is trivial.\n    if (!AL.checkExactlyNumArgs(S, AL.getMinArgs()))\n      return true;\n  } else {\n    // There are optional arguments, so checking is slightly more involved.\n    if (AL.getMinArgs() && !AL.checkAtLeastNumArgs(S, AL.getMinArgs()))\n      return true;\n    else if (!AL.hasVariadicArg() && AL.getMaxArgs() &&\n             !AL.checkAtMostNumArgs(S, AL.getMaxArgs()))\n      return true;\n  }\n\n  if (S.CheckAttrTarget(AL))\n    return true;\n\n  return false;\n}\n\nstatic void handleOpenCLAccessAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  if (D->isInvalidDecl())\n    return;\n\n  // Check if there is only one access qualifier.\n  if (D->hasAttr<OpenCLAccessAttr>()) {\n    if (D->getAttr<OpenCLAccessAttr>()->getSemanticSpelling() ==\n        AL.getSemanticSpelling()) {\n      S.Diag(AL.getLoc(), diag::warn_duplicate_declspec)\n          << AL.getAttrName()->getName() << AL.getRange();\n    } else {\n      S.Diag(AL.getLoc(), diag::err_opencl_multiple_access_qualifiers)\n          << D->getSourceRange();\n      D->setInvalidDecl(true);\n      return;\n    }\n  }\n\n  // OpenCL v2.0 s6.6 - read_write can be used for image types to specify that an\n  // image object can be read and written.\n  // OpenCL v2.0 s6.13.6 - A kernel cannot read from and write to the same pipe\n  // object. Using the read_write (or __read_write) qualifier with the pipe\n  // qualifier is a compilation error.\n  if (const auto *PDecl = dyn_cast<ParmVarDecl>(D)) {\n    const Type *DeclTy = PDecl->getType().getCanonicalType().getTypePtr();\n    if (AL.getAttrName()->getName().find(\"read_write\") != StringRef::npos) {\n      if ((!S.getLangOpts().OpenCLCPlusPlus &&\n           S.getLangOpts().OpenCLVersion < 200) ||\n          DeclTy->isPipeType()) {\n        S.Diag(AL.getLoc(), diag::err_opencl_invalid_read_write)\n            << AL << PDecl->getType() << DeclTy->isImageType();\n        D->setInvalidDecl(true);\n        return;\n      }\n    }\n  }\n\n  D->addAttr(::new (S.Context) OpenCLAccessAttr(S.Context, AL));\n}\n\nstatic void handleSYCLKernelAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  // The 'sycl_kernel' attribute applies only to function templates.\n  const auto *FD = cast<FunctionDecl>(D);\n  const FunctionTemplateDecl *FT = FD->getDescribedFunctionTemplate();\n  assert(FT && \"Function template is expected\");\n\n  // Function template must have at least two template parameters.\n  const TemplateParameterList *TL = FT->getTemplateParameters();\n  if (TL->size() < 2) {\n    S.Diag(FT->getLocation(), diag::warn_sycl_kernel_num_of_template_params);\n    return;\n  }\n\n  // Template parameters must be typenames.\n  for (unsigned I = 0; I < 2; ++I) {\n    const NamedDecl *TParam = TL->getParam(I);\n    if (isa<NonTypeTemplateParmDecl>(TParam)) {\n      S.Diag(FT->getLocation(),\n             diag::warn_sycl_kernel_invalid_template_param_type);\n      return;\n    }\n  }\n\n  // Function must have at least one argument.\n  if (getFunctionOrMethodNumParams(D) != 1) {\n    S.Diag(FT->getLocation(), diag::warn_sycl_kernel_num_of_function_params);\n    return;\n  }\n\n  // Function must return void.\n  QualType RetTy = getFunctionOrMethodResultType(D);\n  if (!RetTy->isVoidType()) {\n    S.Diag(FT->getLocation(), diag::warn_sycl_kernel_return_type);\n    return;\n  }\n\n  handleSimpleAttribute<SYCLKernelAttr>(S, D, AL);\n}\n\nstatic void handleDestroyAttr(Sema &S, Decl *D, const ParsedAttr &A) {\n  if (!cast<VarDecl>(D)->hasGlobalStorage()) {\n    S.Diag(D->getLocation(), diag::err_destroy_attr_on_non_static_var)\n        << (A.getKind() == ParsedAttr::AT_AlwaysDestroy);\n    return;\n  }\n\n  if (A.getKind() == ParsedAttr::AT_AlwaysDestroy)\n    handleSimpleAttributeWithExclusions<AlwaysDestroyAttr, NoDestroyAttr>(S, D, A);\n  else\n    handleSimpleAttributeWithExclusions<NoDestroyAttr, AlwaysDestroyAttr>(S, D, A);\n}\n\nstatic void handleUninitializedAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  assert(cast<VarDecl>(D)->getStorageDuration() == SD_Automatic &&\n         \"uninitialized is only valid on automatic duration variables\");\n  D->addAttr(::new (S.Context) UninitializedAttr(S.Context, AL));\n}\n\nstatic bool tryMakeVariablePseudoStrong(Sema &S, VarDecl *VD,\n                                        bool DiagnoseFailure) {\n  QualType Ty = VD->getType();\n  if (!Ty->isObjCRetainableType()) {\n    if (DiagnoseFailure) {\n      S.Diag(VD->getBeginLoc(), diag::warn_ignored_objc_externally_retained)\n          << 0;\n    }\n    return false;\n  }\n\n  Qualifiers::ObjCLifetime LifetimeQual = Ty.getQualifiers().getObjCLifetime();\n\n  // Sema::inferObjCARCLifetime must run after processing decl attributes\n  // (because __block lowers to an attribute), so if the lifetime hasn't been\n  // explicitly specified, infer it locally now.\n  if (LifetimeQual == Qualifiers::OCL_None)\n    LifetimeQual = Ty->getObjCARCImplicitLifetime();\n\n  // The attributes only really makes sense for __strong variables; ignore any\n  // attempts to annotate a parameter with any other lifetime qualifier.\n  if (LifetimeQual != Qualifiers::OCL_Strong) {\n    if (DiagnoseFailure) {\n      S.Diag(VD->getBeginLoc(), diag::warn_ignored_objc_externally_retained)\n          << 1;\n    }\n    return false;\n  }\n\n  // Tampering with the type of a VarDecl here is a bit of a hack, but we need\n  // to ensure that the variable is 'const' so that we can error on\n  // modification, which can otherwise over-release.\n  VD->setType(Ty.withConst());\n  VD->setARCPseudoStrong(true);\n  return true;\n}\n\nstatic void handleObjCExternallyRetainedAttr(Sema &S, Decl *D,\n                                             const ParsedAttr &AL) {\n  if (auto *VD = dyn_cast<VarDecl>(D)) {\n    assert(!isa<ParmVarDecl>(VD) && \"should be diagnosed automatically\");\n    if (!VD->hasLocalStorage()) {\n      S.Diag(D->getBeginLoc(), diag::warn_ignored_objc_externally_retained)\n          << 0;\n      return;\n    }\n\n    if (!tryMakeVariablePseudoStrong(S, VD, /*DiagnoseFailure=*/true))\n      return;\n\n    handleSimpleAttribute<ObjCExternallyRetainedAttr>(S, D, AL);\n    return;\n  }\n\n  // If D is a function-like declaration (method, block, or function), then we\n  // make every parameter psuedo-strong.\n  unsigned NumParams =\n      hasFunctionProto(D) ? getFunctionOrMethodNumParams(D) : 0;\n  for (unsigned I = 0; I != NumParams; ++I) {\n    auto *PVD = const_cast<ParmVarDecl *>(getFunctionOrMethodParam(D, I));\n    QualType Ty = PVD->getType();\n\n    // If a user wrote a parameter with __strong explicitly, then assume they\n    // want \"real\" strong semantics for that parameter. This works because if\n    // the parameter was written with __strong, then the strong qualifier will\n    // be non-local.\n    if (Ty.getLocalUnqualifiedType().getQualifiers().getObjCLifetime() ==\n        Qualifiers::OCL_Strong)\n      continue;\n\n    tryMakeVariablePseudoStrong(S, PVD, /*DiagnoseFailure=*/false);\n  }\n  handleSimpleAttribute<ObjCExternallyRetainedAttr>(S, D, AL);\n}\n\nstatic void handleMIGServerRoutineAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  // Check that the return type is a `typedef int kern_return_t` or a typedef\n  // around it, because otherwise MIG convention checks make no sense.\n  // BlockDecl doesn't store a return type, so it's annoying to check,\n  // so let's skip it for now.\n  if (!isa<BlockDecl>(D)) {\n    QualType T = getFunctionOrMethodResultType(D);\n    bool IsKernReturnT = false;\n    while (const auto *TT = T->getAs<TypedefType>()) {\n      IsKernReturnT = (TT->getDecl()->getName() == \"kern_return_t\");\n      T = TT->desugar();\n    }\n    if (!IsKernReturnT || T.getCanonicalType() != S.getASTContext().IntTy) {\n      S.Diag(D->getBeginLoc(),\n             diag::warn_mig_server_routine_does_not_return_kern_return_t);\n      return;\n    }\n  }\n\n  handleSimpleAttribute<MIGServerRoutineAttr>(S, D, AL);\n}\n\nstatic void handleMSAllocatorAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  // Warn if the return type is not a pointer or reference type.\n  if (auto *FD = dyn_cast<FunctionDecl>(D)) {\n    QualType RetTy = FD->getReturnType();\n    if (!RetTy->isPointerType() && !RetTy->isReferenceType()) {\n      S.Diag(AL.getLoc(), diag::warn_declspec_allocator_nonpointer)\n          << AL.getRange() << RetTy;\n      return;\n    }\n  }\n\n  handleSimpleAttribute<MSAllocatorAttr>(S, D, AL);\n}\n\nstatic void handleAcquireHandleAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  if (AL.isUsedAsTypeAttr())\n    return;\n  // Warn if the parameter is definitely not an output parameter.\n  if (const auto *PVD = dyn_cast<ParmVarDecl>(D)) {\n    if (PVD->getType()->isIntegerType()) {\n      S.Diag(AL.getLoc(), diag::err_attribute_output_parameter)\n          << AL.getRange();\n      return;\n    }\n  }\n  StringRef Argument;\n  if (!S.checkStringLiteralArgumentAttr(AL, 0, Argument))\n    return;\n  D->addAttr(AcquireHandleAttr::Create(S.Context, Argument, AL));\n}\n\ntemplate<typename Attr>\nstatic void handleHandleAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  StringRef Argument;\n  if (!S.checkStringLiteralArgumentAttr(AL, 0, Argument))\n    return;\n  D->addAttr(Attr::Create(S.Context, Argument, AL));\n}\n\nstatic void handleCFGuardAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  // The guard attribute takes a single identifier argument.\n\n  if (!AL.isArgIdent(0)) {\n    S.Diag(AL.getLoc(), diag::err_attribute_argument_type)\n        << AL << AANT_ArgumentIdentifier;\n    return;\n  }\n\n  CFGuardAttr::GuardArg Arg;\n  IdentifierInfo *II = AL.getArgAsIdent(0)->Ident;\n  if (!CFGuardAttr::ConvertStrToGuardArg(II->getName(), Arg)) {\n    S.Diag(AL.getLoc(), diag::warn_attribute_type_not_supported) << AL << II;\n    return;\n  }\n\n  D->addAttr(::new (S.Context) CFGuardAttr(S.Context, AL, Arg));\n}\n\n\ntemplate <typename AttrTy>\nstatic const AttrTy *findEnforceTCBAttrByName(Decl *D, StringRef Name) {\n  auto Attrs = D->specific_attrs<AttrTy>();\n  auto I = llvm::find_if(Attrs,\n                         [Name](const AttrTy *A) {\n                           return A->getTCBName() == Name;\n                         });\n  return I == Attrs.end() ? nullptr : *I;\n}\n\ntemplate <typename AttrTy, typename ConflictingAttrTy>\nstatic void handleEnforceTCBAttr(Sema &S, Decl *D, const ParsedAttr &AL) {\n  StringRef Argument;\n  if (!S.checkStringLiteralArgumentAttr(AL, 0, Argument))\n    return;\n\n  // A function cannot be have both regular and leaf membership in the same TCB.\n  if (const ConflictingAttrTy *ConflictingAttr =\n      findEnforceTCBAttrByName<ConflictingAttrTy>(D, Argument)) {\n    // We could attach a note to the other attribute but in this case\n    // there's no need given how the two are very close to each other.\n    S.Diag(AL.getLoc(), diag::err_tcb_conflicting_attributes)\n      << AL.getAttrName()->getName() << ConflictingAttr->getAttrName()->getName()\n      << Argument;\n\n    // Error recovery: drop the non-leaf attribute so that to suppress\n    // all future warnings caused by erroneous attributes. The leaf attribute\n    // needs to be kept because it can only suppresses warnings, not cause them.\n    D->dropAttr<EnforceTCBAttr>();\n    return;\n  }\n\n  D->addAttr(AttrTy::Create(S.Context, Argument, AL));\n}\n\ntemplate <typename AttrTy, typename ConflictingAttrTy>\nstatic AttrTy *mergeEnforceTCBAttrImpl(Sema &S, Decl *D, const AttrTy &AL) {\n  // Check if the new redeclaration has different leaf-ness in the same TCB.\n  StringRef TCBName = AL.getTCBName();\n  if (const ConflictingAttrTy *ConflictingAttr =\n      findEnforceTCBAttrByName<ConflictingAttrTy>(D, TCBName)) {\n    S.Diag(ConflictingAttr->getLoc(), diag::err_tcb_conflicting_attributes)\n      << ConflictingAttr->getAttrName()->getName()\n      << AL.getAttrName()->getName() << TCBName;\n\n    // Add a note so that the user could easily find the conflicting attribute.\n    S.Diag(AL.getLoc(), diag::note_conflicting_attribute);\n\n    // More error recovery.\n    D->dropAttr<EnforceTCBAttr>();\n    return nullptr;\n  }\n\n  ASTContext &Context = S.getASTContext();\n  return ::new(Context) AttrTy(Context, AL, AL.getTCBName());\n}\n\nEnforceTCBAttr *Sema::mergeEnforceTCBAttr(Decl *D, const EnforceTCBAttr &AL) {\n  return mergeEnforceTCBAttrImpl<EnforceTCBAttr, EnforceTCBLeafAttr>(\n      *this, D, AL);\n}\n\nEnforceTCBLeafAttr *Sema::mergeEnforceTCBLeafAttr(\n    Decl *D, const EnforceTCBLeafAttr &AL) {\n  return mergeEnforceTCBAttrImpl<EnforceTCBLeafAttr, EnforceTCBAttr>(\n      *this, D, AL);\n}\n\n//===----------------------------------------------------------------------===//\n// Top Level Sema Entry Points\n//===----------------------------------------------------------------------===//\n\n/// ProcessDeclAttribute - Apply the specific attribute to the specified decl if\n/// the attribute applies to decls.  If the attribute is a type attribute, just\n/// silently ignore it if a GNU attribute.\nstatic void ProcessDeclAttribute(Sema &S, Scope *scope, Decl *D,\n                                 const ParsedAttr &AL,\n                                 bool IncludeCXX11Attributes) {\n  if (AL.isInvalid() || AL.getKind() == ParsedAttr::IgnoredAttribute)\n    return;\n\n  // Ignore C++11 attributes on declarator chunks: they appertain to the type\n  // instead.\n  if (AL.isCXX11Attribute() && !IncludeCXX11Attributes)\n    return;\n\n  // Unknown attributes are automatically warned on. Target-specific attributes\n  // which do not apply to the current target architecture are treated as\n  // though they were unknown attributes.\n  if (AL.getKind() == ParsedAttr::UnknownAttribute ||\n      !AL.existsInTarget(S.Context.getTargetInfo())) {\n    S.Diag(AL.getLoc(),\n           AL.isDeclspecAttribute()\n               ? (unsigned)diag::warn_unhandled_ms_attribute_ignored\n               : (unsigned)diag::warn_unknown_attribute_ignored)\n        << AL << AL.getRange();\n    return;\n  }\n\n  if (handleCommonAttributeFeatures(S, D, AL))\n    return;\n\n  switch (AL.getKind()) {\n  default:\n    if (AL.getInfo().handleDeclAttribute(S, D, AL) != ParsedAttrInfo::NotHandled)\n      break;\n    if (!AL.isStmtAttr()) {\n      // Type attributes are handled elsewhere; silently move on.\n      assert(AL.isTypeAttr() && \"Non-type attribute not handled\");\n      break;\n    }\n    S.Diag(AL.getLoc(), diag::err_stmt_attribute_invalid_on_decl)\n        << AL << D->getLocation();\n    break;\n  case ParsedAttr::AT_Interrupt:\n    handleInterruptAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_X86ForceAlignArgPointer:\n    handleX86ForceAlignArgPointerAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_DLLExport:\n  case ParsedAttr::AT_DLLImport:\n    handleDLLAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_Mips16:\n    handleSimpleAttributeWithExclusions<Mips16Attr, MicroMipsAttr,\n                                        MipsInterruptAttr>(S, D, AL);\n    break;\n  case ParsedAttr::AT_MicroMips:\n    handleSimpleAttributeWithExclusions<MicroMipsAttr, Mips16Attr>(S, D, AL);\n    break;\n  case ParsedAttr::AT_MipsLongCall:\n    handleSimpleAttributeWithExclusions<MipsLongCallAttr, MipsShortCallAttr>(\n        S, D, AL);\n    break;\n  case ParsedAttr::AT_MipsShortCall:\n    handleSimpleAttributeWithExclusions<MipsShortCallAttr, MipsLongCallAttr>(\n        S, D, AL);\n    break;\n  case ParsedAttr::AT_AMDGPUFlatWorkGroupSize:\n    handleAMDGPUFlatWorkGroupSizeAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_AMDGPUWavesPerEU:\n    handleAMDGPUWavesPerEUAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_AMDGPUNumSGPR:\n    handleAMDGPUNumSGPRAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_AMDGPUNumVGPR:\n    handleAMDGPUNumVGPRAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_AVRSignal:\n    handleAVRSignalAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_BPFPreserveAccessIndex:\n    handleBPFPreserveAccessIndexAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_WebAssemblyExportName:\n    handleWebAssemblyExportNameAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_WebAssemblyImportModule:\n    handleWebAssemblyImportModuleAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_WebAssemblyImportName:\n    handleWebAssemblyImportNameAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_IBOutlet:\n    handleIBOutlet(S, D, AL);\n    break;\n  case ParsedAttr::AT_IBOutletCollection:\n    handleIBOutletCollection(S, D, AL);\n    break;\n  case ParsedAttr::AT_IFunc:\n    handleIFuncAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_Alias:\n    handleAliasAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_Aligned:\n    handleAlignedAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_AlignValue:\n    handleAlignValueAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_AllocSize:\n    handleAllocSizeAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_AlwaysInline:\n    handleAlwaysInlineAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_AnalyzerNoReturn:\n    handleAnalyzerNoReturnAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_TLSModel:\n    handleTLSModelAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_Annotate:\n    handleAnnotateAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_Availability:\n    handleAvailabilityAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_CarriesDependency:\n    handleDependencyAttr(S, scope, D, AL);\n    break;\n  case ParsedAttr::AT_CPUDispatch:\n  case ParsedAttr::AT_CPUSpecific:\n    handleCPUSpecificAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_Common:\n    handleCommonAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_CUDAConstant:\n    handleConstantAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_PassObjectSize:\n    handlePassObjectSizeAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_Constructor:\n      handleConstructorAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_Deprecated:\n    handleDeprecatedAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_Destructor:\n      handleDestructorAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_EnableIf:\n    handleEnableIfAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_DiagnoseIf:\n    handleDiagnoseIfAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_NoBuiltin:\n    handleNoBuiltinAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_ExtVectorType:\n    handleExtVectorTypeAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_ExternalSourceSymbol:\n    handleExternalSourceSymbolAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_MinSize:\n    handleMinSizeAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_OptimizeNone:\n    handleOptimizeNoneAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_EnumExtensibility:\n    handleEnumExtensibilityAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_SYCLKernel:\n    handleSYCLKernelAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_Format:\n    handleFormatAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_FormatArg:\n    handleFormatArgAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_Callback:\n    handleCallbackAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_CalledOnce:\n    handleCalledOnceAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_CUDAGlobal:\n    handleGlobalAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_CUDADevice:\n    handleDeviceAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_CUDAHost:\n    handleSimpleAttributeWithExclusions<CUDAHostAttr, CUDAGlobalAttr>(S, D, AL);\n    break;\n  case ParsedAttr::AT_HIPManaged:\n    handleManagedAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_CUDADeviceBuiltinSurfaceType:\n    handleSimpleAttributeWithExclusions<CUDADeviceBuiltinSurfaceTypeAttr,\n                                        CUDADeviceBuiltinTextureTypeAttr>(S, D,\n                                                                          AL);\n    break;\n  case ParsedAttr::AT_CUDADeviceBuiltinTextureType:\n    handleSimpleAttributeWithExclusions<CUDADeviceBuiltinTextureTypeAttr,\n                                        CUDADeviceBuiltinSurfaceTypeAttr>(S, D,\n                                                                          AL);\n    break;\n  case ParsedAttr::AT_GNUInline:\n    handleGNUInlineAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_CUDALaunchBounds:\n    handleLaunchBoundsAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_Restrict:\n    handleRestrictAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_Mode:\n    handleModeAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_NonNull:\n    if (auto *PVD = dyn_cast<ParmVarDecl>(D))\n      handleNonNullAttrParameter(S, PVD, AL);\n    else\n      handleNonNullAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_ReturnsNonNull:\n    handleReturnsNonNullAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_NoEscape:\n    handleNoEscapeAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_AssumeAligned:\n    handleAssumeAlignedAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_AllocAlign:\n    handleAllocAlignAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_Ownership:\n    handleOwnershipAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_Cold:\n    handleSimpleAttributeWithExclusions<ColdAttr, HotAttr>(S, D, AL);\n    break;\n  case ParsedAttr::AT_Hot:\n    handleSimpleAttributeWithExclusions<HotAttr, ColdAttr>(S, D, AL);\n    break;\n  case ParsedAttr::AT_Naked:\n    handleNakedAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_NoReturn:\n    handleNoReturnAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_AnyX86NoCfCheck:\n    handleNoCfCheckAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_Leaf:\n    handleSimpleAttribute<LeafAttr>(S, D, AL);\n    break;\n  case ParsedAttr::AT_NoThrow:\n    if (!AL.isUsedAsTypeAttr())\n      handleSimpleAttribute<NoThrowAttr>(S, D, AL);\n    break;\n  case ParsedAttr::AT_CUDAShared:\n    handleSharedAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_VecReturn:\n    handleVecReturnAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_ObjCOwnership:\n    handleObjCOwnershipAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_ObjCPreciseLifetime:\n    handleObjCPreciseLifetimeAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_ObjCReturnsInnerPointer:\n    handleObjCReturnsInnerPointerAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_ObjCRequiresSuper:\n    handleObjCRequiresSuperAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_ObjCBridge:\n    handleObjCBridgeAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_ObjCBridgeMutable:\n    handleObjCBridgeMutableAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_ObjCBridgeRelated:\n    handleObjCBridgeRelatedAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_ObjCDesignatedInitializer:\n    handleObjCDesignatedInitializer(S, D, AL);\n    break;\n  case ParsedAttr::AT_ObjCRuntimeName:\n    handleObjCRuntimeName(S, D, AL);\n    break;\n  case ParsedAttr::AT_ObjCBoxable:\n    handleObjCBoxable(S, D, AL);\n    break;\n  case ParsedAttr::AT_NSErrorDomain:\n    handleNSErrorDomain(S, D, AL);\n    break;\n  case ParsedAttr::AT_CFAuditedTransfer:\n    handleSimpleAttributeWithExclusions<CFAuditedTransferAttr,\n                                        CFUnknownTransferAttr>(S, D, AL);\n    break;\n  case ParsedAttr::AT_CFUnknownTransfer:\n    handleSimpleAttributeWithExclusions<CFUnknownTransferAttr,\n                                        CFAuditedTransferAttr>(S, D, AL);\n    break;\n  case ParsedAttr::AT_CFConsumed:\n  case ParsedAttr::AT_NSConsumed:\n  case ParsedAttr::AT_OSConsumed:\n    S.AddXConsumedAttr(D, AL, parsedAttrToRetainOwnershipKind(AL),\n                       /*IsTemplateInstantiation=*/false);\n    break;\n  case ParsedAttr::AT_OSReturnsRetainedOnZero:\n    handleSimpleAttributeOrDiagnose<OSReturnsRetainedOnZeroAttr>(\n        S, D, AL, isValidOSObjectOutParameter(D),\n        diag::warn_ns_attribute_wrong_parameter_type,\n        /*Extra Args=*/AL, /*pointer-to-OSObject-pointer*/ 3, AL.getRange());\n    break;\n  case ParsedAttr::AT_OSReturnsRetainedOnNonZero:\n    handleSimpleAttributeOrDiagnose<OSReturnsRetainedOnNonZeroAttr>(\n        S, D, AL, isValidOSObjectOutParameter(D),\n        diag::warn_ns_attribute_wrong_parameter_type,\n        /*Extra Args=*/AL, /*pointer-to-OSObject-poointer*/ 3, AL.getRange());\n    break;\n  case ParsedAttr::AT_NSReturnsAutoreleased:\n  case ParsedAttr::AT_NSReturnsNotRetained:\n  case ParsedAttr::AT_NSReturnsRetained:\n  case ParsedAttr::AT_CFReturnsNotRetained:\n  case ParsedAttr::AT_CFReturnsRetained:\n  case ParsedAttr::AT_OSReturnsNotRetained:\n  case ParsedAttr::AT_OSReturnsRetained:\n    handleXReturnsXRetainedAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_WorkGroupSizeHint:\n    handleWorkGroupSize<WorkGroupSizeHintAttr>(S, D, AL);\n    break;\n  case ParsedAttr::AT_ReqdWorkGroupSize:\n    handleWorkGroupSize<ReqdWorkGroupSizeAttr>(S, D, AL);\n    break;\n  case ParsedAttr::AT_OpenCLIntelReqdSubGroupSize:\n    handleSubGroupSize(S, D, AL);\n    break;\n  case ParsedAttr::AT_VecTypeHint:\n    handleVecTypeHint(S, D, AL);\n    break;\n  case ParsedAttr::AT_InitPriority:\n    if (S.Context.getTargetInfo().getTriple().isOSAIX())\n      llvm::report_fatal_error(\n          \"'init_priority' attribute is not yet supported on AIX\");\n    else\n      handleInitPriorityAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_Packed:\n    handlePackedAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_PreferredName:\n    handlePreferredName(S, D, AL);\n    break;\n  case ParsedAttr::AT_Section:\n    handleSectionAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_SpeculativeLoadHardening:\n    handleSimpleAttributeWithExclusions<SpeculativeLoadHardeningAttr,\n                                        NoSpeculativeLoadHardeningAttr>(S, D,\n                                                                        AL);\n    break;\n  case ParsedAttr::AT_NoSpeculativeLoadHardening:\n    handleSimpleAttributeWithExclusions<NoSpeculativeLoadHardeningAttr,\n                                        SpeculativeLoadHardeningAttr>(S, D, AL);\n    break;\n  case ParsedAttr::AT_CodeSeg:\n    handleCodeSegAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_Target:\n    handleTargetAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_MinVectorWidth:\n    handleMinVectorWidthAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_Unavailable:\n    handleAttrWithMessage<UnavailableAttr>(S, D, AL);\n    break;\n  case ParsedAttr::AT_Assumption:\n    handleAssumumptionAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_ObjCDirect:\n    handleObjCDirectAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_ObjCNonRuntimeProtocol:\n    handleObjCNonRuntimeProtocolAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_ObjCDirectMembers:\n    handleObjCDirectMembersAttr(S, D, AL);\n    handleSimpleAttribute<ObjCDirectMembersAttr>(S, D, AL);\n    break;\n  case ParsedAttr::AT_ObjCExplicitProtocolImpl:\n    handleObjCSuppresProtocolAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_Unused:\n    handleUnusedAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_NotTailCalled:\n    handleSimpleAttributeWithExclusions<NotTailCalledAttr, AlwaysInlineAttr>(\n        S, D, AL);\n    break;\n  case ParsedAttr::AT_DisableTailCalls:\n    handleSimpleAttributeWithExclusions<DisableTailCallsAttr, NakedAttr>(S, D,\n                                                                         AL);\n    break;\n  case ParsedAttr::AT_NoMerge:\n    handleSimpleAttribute<NoMergeAttr>(S, D, AL);\n    break;\n  case ParsedAttr::AT_Visibility:\n    handleVisibilityAttr(S, D, AL, false);\n    break;\n  case ParsedAttr::AT_TypeVisibility:\n    handleVisibilityAttr(S, D, AL, true);\n    break;\n  case ParsedAttr::AT_WarnUnusedResult:\n    handleWarnUnusedResult(S, D, AL);\n    break;\n  case ParsedAttr::AT_WeakRef:\n    handleWeakRefAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_WeakImport:\n    handleWeakImportAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_TransparentUnion:\n    handleTransparentUnionAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_ObjCMethodFamily:\n    handleObjCMethodFamilyAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_ObjCNSObject:\n    handleObjCNSObject(S, D, AL);\n    break;\n  case ParsedAttr::AT_ObjCIndependentClass:\n    handleObjCIndependentClass(S, D, AL);\n    break;\n  case ParsedAttr::AT_Blocks:\n    handleBlocksAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_Sentinel:\n    handleSentinelAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_Cleanup:\n    handleCleanupAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_NoDebug:\n    handleNoDebugAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_CmseNSEntry:\n    handleCmseNSEntryAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_StdCall:\n  case ParsedAttr::AT_CDecl:\n  case ParsedAttr::AT_FastCall:\n  case ParsedAttr::AT_ThisCall:\n  case ParsedAttr::AT_Pascal:\n  case ParsedAttr::AT_RegCall:\n  case ParsedAttr::AT_SwiftCall:\n  case ParsedAttr::AT_VectorCall:\n  case ParsedAttr::AT_MSABI:\n  case ParsedAttr::AT_SysVABI:\n  case ParsedAttr::AT_Pcs:\n  case ParsedAttr::AT_IntelOclBicc:\n  case ParsedAttr::AT_PreserveMost:\n  case ParsedAttr::AT_PreserveAll:\n  case ParsedAttr::AT_AArch64VectorPcs:\n    handleCallConvAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_Suppress:\n    handleSuppressAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_Owner:\n  case ParsedAttr::AT_Pointer:\n    handleLifetimeCategoryAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_OpenCLAccess:\n    handleOpenCLAccessAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_OpenCLNoSVM:\n    handleOpenCLNoSVMAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_SwiftContext:\n    S.AddParameterABIAttr(D, AL, ParameterABI::SwiftContext);\n    break;\n  case ParsedAttr::AT_SwiftErrorResult:\n    S.AddParameterABIAttr(D, AL, ParameterABI::SwiftErrorResult);\n    break;\n  case ParsedAttr::AT_SwiftIndirectResult:\n    S.AddParameterABIAttr(D, AL, ParameterABI::SwiftIndirectResult);\n    break;\n  case ParsedAttr::AT_InternalLinkage:\n    handleInternalLinkageAttr(S, D, AL);\n    break;\n\n  // Microsoft attributes:\n  case ParsedAttr::AT_LayoutVersion:\n    handleLayoutVersion(S, D, AL);\n    break;\n  case ParsedAttr::AT_Uuid:\n    handleUuidAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_MSInheritance:\n    handleMSInheritanceAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_Thread:\n    handleDeclspecThreadAttr(S, D, AL);\n    break;\n\n  case ParsedAttr::AT_AbiTag:\n    handleAbiTagAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_CFGuard:\n    handleCFGuardAttr(S, D, AL);\n    break;\n\n  // Thread safety attributes:\n  case ParsedAttr::AT_AssertExclusiveLock:\n    handleAssertExclusiveLockAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_AssertSharedLock:\n    handleAssertSharedLockAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_PtGuardedVar:\n    handlePtGuardedVarAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_NoSanitize:\n    handleNoSanitizeAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_NoSanitizeSpecific:\n    handleNoSanitizeSpecificAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_GuardedBy:\n    handleGuardedByAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_PtGuardedBy:\n    handlePtGuardedByAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_ExclusiveTrylockFunction:\n    handleExclusiveTrylockFunctionAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_LockReturned:\n    handleLockReturnedAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_LocksExcluded:\n    handleLocksExcludedAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_SharedTrylockFunction:\n    handleSharedTrylockFunctionAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_AcquiredBefore:\n    handleAcquiredBeforeAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_AcquiredAfter:\n    handleAcquiredAfterAttr(S, D, AL);\n    break;\n\n  // Capability analysis attributes.\n  case ParsedAttr::AT_Capability:\n  case ParsedAttr::AT_Lockable:\n    handleCapabilityAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_RequiresCapability:\n    handleRequiresCapabilityAttr(S, D, AL);\n    break;\n\n  case ParsedAttr::AT_AssertCapability:\n    handleAssertCapabilityAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_AcquireCapability:\n    handleAcquireCapabilityAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_ReleaseCapability:\n    handleReleaseCapabilityAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_TryAcquireCapability:\n    handleTryAcquireCapabilityAttr(S, D, AL);\n    break;\n\n  // Consumed analysis attributes.\n  case ParsedAttr::AT_Consumable:\n    handleConsumableAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_CallableWhen:\n    handleCallableWhenAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_ParamTypestate:\n    handleParamTypestateAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_ReturnTypestate:\n    handleReturnTypestateAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_SetTypestate:\n    handleSetTypestateAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_TestTypestate:\n    handleTestTypestateAttr(S, D, AL);\n    break;\n\n  // Type safety attributes.\n  case ParsedAttr::AT_ArgumentWithTypeTag:\n    handleArgumentWithTypeTagAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_TypeTagForDatatype:\n    handleTypeTagForDatatypeAttr(S, D, AL);\n    break;\n\n  // Swift attributes.\n  case ParsedAttr::AT_SwiftAsyncName:\n    handleSwiftAsyncName(S, D, AL);\n    break;\n  case ParsedAttr::AT_SwiftAttr:\n    handleSwiftAttrAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_SwiftBridge:\n    handleSwiftBridge(S, D, AL);\n    break;\n  case ParsedAttr::AT_SwiftBridgedTypedef:\n    handleSimpleAttribute<SwiftBridgedTypedefAttr>(S, D, AL);\n    break;\n  case ParsedAttr::AT_SwiftError:\n    handleSwiftError(S, D, AL);\n    break;\n  case ParsedAttr::AT_SwiftName:\n    handleSwiftName(S, D, AL);\n    break;\n  case ParsedAttr::AT_SwiftNewType:\n    handleSwiftNewType(S, D, AL);\n    break;\n  case ParsedAttr::AT_SwiftObjCMembers:\n    handleSimpleAttribute<SwiftObjCMembersAttr>(S, D, AL);\n    break;\n  case ParsedAttr::AT_SwiftPrivate:\n    handleSimpleAttribute<SwiftPrivateAttr>(S, D, AL);\n    break;\n  case ParsedAttr::AT_SwiftAsync:\n    handleSwiftAsyncAttr(S, D, AL);\n    break;\n  case ParsedAttr::AT_SwiftAsyncError:\n    handleSwiftAsyncError(S, D, AL);\n    break;\n\n  // XRay attributes.\n  case ParsedAttr::AT_XRayLogArgs:\n    handleXRayLogArgsAttr(S, D, AL);\n    break;\n\n  case ParsedAttr::AT_PatchableFunctionEntry:\n    handlePatchableFunctionEntryAttr(S, D, AL);\n    break;\n\n  case ParsedAttr::AT_AlwaysDestroy:\n  case ParsedAttr::AT_NoDestroy:\n    handleDestroyAttr(S, D, AL);\n    break;\n\n  case ParsedAttr::AT_Uninitialized:\n    handleUninitializedAttr(S, D, AL);\n    break;\n\n  case ParsedAttr::AT_LoaderUninitialized:\n    handleSimpleAttribute<LoaderUninitializedAttr>(S, D, AL);\n    break;\n\n  case ParsedAttr::AT_ObjCExternallyRetained:\n    handleObjCExternallyRetainedAttr(S, D, AL);\n    break;\n\n  case ParsedAttr::AT_MIGServerRoutine:\n    handleMIGServerRoutineAttr(S, D, AL);\n    break;\n\n  case ParsedAttr::AT_MSAllocator:\n    handleMSAllocatorAttr(S, D, AL);\n    break;\n\n  case ParsedAttr::AT_ArmBuiltinAlias:\n    handleArmBuiltinAliasAttr(S, D, AL);\n    break;\n\n  case ParsedAttr::AT_AcquireHandle:\n    handleAcquireHandleAttr(S, D, AL);\n    break;\n\n  case ParsedAttr::AT_ReleaseHandle:\n    handleHandleAttr<ReleaseHandleAttr>(S, D, AL);\n    break;\n\n  case ParsedAttr::AT_UseHandle:\n    handleHandleAttr<UseHandleAttr>(S, D, AL);\n    break;\n\n  case ParsedAttr::AT_EnforceTCB:\n    handleEnforceTCBAttr<EnforceTCBAttr, EnforceTCBLeafAttr>(S, D, AL);\n    break;\n\n  case ParsedAttr::AT_EnforceTCBLeaf:\n    handleEnforceTCBAttr<EnforceTCBLeafAttr, EnforceTCBAttr>(S, D, AL);\n    break;\n  }\n}\n\n/// ProcessDeclAttributeList - Apply all the decl attributes in the specified\n/// attribute list to the specified decl, ignoring any type attributes.\nvoid Sema::ProcessDeclAttributeList(Scope *S, Decl *D,\n                                    const ParsedAttributesView &AttrList,\n                                    bool IncludeCXX11Attributes) {\n  if (AttrList.empty())\n    return;\n\n  for (const ParsedAttr &AL : AttrList)\n    ProcessDeclAttribute(*this, S, D, AL, IncludeCXX11Attributes);\n\n  // FIXME: We should be able to handle these cases in TableGen.\n  // GCC accepts\n  // static int a9 __attribute__((weakref));\n  // but that looks really pointless. We reject it.\n  if (D->hasAttr<WeakRefAttr>() && !D->hasAttr<AliasAttr>()) {\n    Diag(AttrList.begin()->getLoc(), diag::err_attribute_weakref_without_alias)\n        << cast<NamedDecl>(D);\n    D->dropAttr<WeakRefAttr>();\n    return;\n  }\n\n  // FIXME: We should be able to handle this in TableGen as well. It would be\n  // good to have a way to specify \"these attributes must appear as a group\",\n  // for these. Additionally, it would be good to have a way to specify \"these\n  // attribute must never appear as a group\" for attributes like cold and hot.\n  if (!D->hasAttr<OpenCLKernelAttr>()) {\n    // These attributes cannot be applied to a non-kernel function.\n    if (const auto *A = D->getAttr<ReqdWorkGroupSizeAttr>()) {\n      // FIXME: This emits a different error message than\n      // diag::err_attribute_wrong_decl_type + ExpectedKernelFunction.\n      Diag(D->getLocation(), diag::err_opencl_kernel_attr) << A;\n      D->setInvalidDecl();\n    } else if (const auto *A = D->getAttr<WorkGroupSizeHintAttr>()) {\n      Diag(D->getLocation(), diag::err_opencl_kernel_attr) << A;\n      D->setInvalidDecl();\n    } else if (const auto *A = D->getAttr<VecTypeHintAttr>()) {\n      Diag(D->getLocation(), diag::err_opencl_kernel_attr) << A;\n      D->setInvalidDecl();\n    } else if (const auto *A = D->getAttr<OpenCLIntelReqdSubGroupSizeAttr>()) {\n      Diag(D->getLocation(), diag::err_opencl_kernel_attr) << A;\n      D->setInvalidDecl();\n    } else if (!D->hasAttr<CUDAGlobalAttr>()) {\n      if (const auto *A = D->getAttr<AMDGPUFlatWorkGroupSizeAttr>()) {\n        Diag(D->getLocation(), diag::err_attribute_wrong_decl_type)\n            << A << ExpectedKernelFunction;\n        D->setInvalidDecl();\n      } else if (const auto *A = D->getAttr<AMDGPUWavesPerEUAttr>()) {\n        Diag(D->getLocation(), diag::err_attribute_wrong_decl_type)\n            << A << ExpectedKernelFunction;\n        D->setInvalidDecl();\n      } else if (const auto *A = D->getAttr<AMDGPUNumSGPRAttr>()) {\n        Diag(D->getLocation(), diag::err_attribute_wrong_decl_type)\n            << A << ExpectedKernelFunction;\n        D->setInvalidDecl();\n      } else if (const auto *A = D->getAttr<AMDGPUNumVGPRAttr>()) {\n        Diag(D->getLocation(), diag::err_attribute_wrong_decl_type)\n            << A << ExpectedKernelFunction;\n        D->setInvalidDecl();\n      }\n    }\n  }\n\n  // Do this check after processing D's attributes because the attribute\n  // objc_method_family can change whether the given method is in the init\n  // family, and it can be applied after objc_designated_initializer. This is a\n  // bit of a hack, but we need it to be compatible with versions of clang that\n  // processed the attribute list in the wrong order.\n  if (D->hasAttr<ObjCDesignatedInitializerAttr>() &&\n      cast<ObjCMethodDecl>(D)->getMethodFamily() != OMF_init) {\n    Diag(D->getLocation(), diag::err_designated_init_attr_non_init);\n    D->dropAttr<ObjCDesignatedInitializerAttr>();\n  }\n}\n\n// Helper for delayed processing TransparentUnion or BPFPreserveAccessIndexAttr\n// attribute.\nvoid Sema::ProcessDeclAttributeDelayed(Decl *D,\n                                       const ParsedAttributesView &AttrList) {\n  for (const ParsedAttr &AL : AttrList)\n    if (AL.getKind() == ParsedAttr::AT_TransparentUnion) {\n      handleTransparentUnionAttr(*this, D, AL);\n      break;\n    }\n\n  // For BPFPreserveAccessIndexAttr, we want to populate the attributes\n  // to fields and inner records as well.\n  if (D && D->hasAttr<BPFPreserveAccessIndexAttr>())\n    handleBPFPreserveAIRecord(*this, cast<RecordDecl>(D));\n}\n\n// Annotation attributes are the only attributes allowed after an access\n// specifier.\nbool Sema::ProcessAccessDeclAttributeList(\n    AccessSpecDecl *ASDecl, const ParsedAttributesView &AttrList) {\n  for (const ParsedAttr &AL : AttrList) {\n    if (AL.getKind() == ParsedAttr::AT_Annotate) {\n      ProcessDeclAttribute(*this, nullptr, ASDecl, AL, AL.isCXX11Attribute());\n    } else {\n      Diag(AL.getLoc(), diag::err_only_annotate_after_access_spec);\n      return true;\n    }\n  }\n  return false;\n}\n\n/// checkUnusedDeclAttributes - Check a list of attributes to see if it\n/// contains any decl attributes that we should warn about.\nstatic void checkUnusedDeclAttributes(Sema &S, const ParsedAttributesView &A) {\n  for (const ParsedAttr &AL : A) {\n    // Only warn if the attribute is an unignored, non-type attribute.\n    if (AL.isUsedAsTypeAttr() || AL.isInvalid())\n      continue;\n    if (AL.getKind() == ParsedAttr::IgnoredAttribute)\n      continue;\n\n    if (AL.getKind() == ParsedAttr::UnknownAttribute) {\n      S.Diag(AL.getLoc(), diag::warn_unknown_attribute_ignored)\n          << AL << AL.getRange();\n    } else {\n      S.Diag(AL.getLoc(), diag::warn_attribute_not_on_decl) << AL\n                                                            << AL.getRange();\n    }\n  }\n}\n\n/// checkUnusedDeclAttributes - Given a declarator which is not being\n/// used to build a declaration, complain about any decl attributes\n/// which might be lying around on it.\nvoid Sema::checkUnusedDeclAttributes(Declarator &D) {\n  ::checkUnusedDeclAttributes(*this, D.getDeclSpec().getAttributes());\n  ::checkUnusedDeclAttributes(*this, D.getAttributes());\n  for (unsigned i = 0, e = D.getNumTypeObjects(); i != e; ++i)\n    ::checkUnusedDeclAttributes(*this, D.getTypeObject(i).getAttrs());\n}\n\n/// DeclClonePragmaWeak - clone existing decl (maybe definition),\n/// \\#pragma weak needs a non-definition decl and source may not have one.\nNamedDecl * Sema::DeclClonePragmaWeak(NamedDecl *ND, IdentifierInfo *II,\n                                      SourceLocation Loc) {\n  assert(isa<FunctionDecl>(ND) || isa<VarDecl>(ND));\n  NamedDecl *NewD = nullptr;\n  if (auto *FD = dyn_cast<FunctionDecl>(ND)) {\n    FunctionDecl *NewFD;\n    // FIXME: Missing call to CheckFunctionDeclaration().\n    // FIXME: Mangling?\n    // FIXME: Is the qualifier info correct?\n    // FIXME: Is the DeclContext correct?\n    NewFD = FunctionDecl::Create(\n        FD->getASTContext(), FD->getDeclContext(), Loc, Loc,\n        DeclarationName(II), FD->getType(), FD->getTypeSourceInfo(), SC_None,\n        false /*isInlineSpecified*/, FD->hasPrototype(),\n        ConstexprSpecKind::Unspecified, FD->getTrailingRequiresClause());\n    NewD = NewFD;\n\n    if (FD->getQualifier())\n      NewFD->setQualifierInfo(FD->getQualifierLoc());\n\n    // Fake up parameter variables; they are declared as if this were\n    // a typedef.\n    QualType FDTy = FD->getType();\n    if (const auto *FT = FDTy->getAs<FunctionProtoType>()) {\n      SmallVector<ParmVarDecl*, 16> Params;\n      for (const auto &AI : FT->param_types()) {\n        ParmVarDecl *Param = BuildParmVarDeclForTypedef(NewFD, Loc, AI);\n        Param->setScopeInfo(0, Params.size());\n        Params.push_back(Param);\n      }\n      NewFD->setParams(Params);\n    }\n  } else if (auto *VD = dyn_cast<VarDecl>(ND)) {\n    NewD = VarDecl::Create(VD->getASTContext(), VD->getDeclContext(),\n                           VD->getInnerLocStart(), VD->getLocation(), II,\n                           VD->getType(), VD->getTypeSourceInfo(),\n                           VD->getStorageClass());\n    if (VD->getQualifier())\n      cast<VarDecl>(NewD)->setQualifierInfo(VD->getQualifierLoc());\n  }\n  return NewD;\n}\n\n/// DeclApplyPragmaWeak - A declaration (maybe definition) needs \\#pragma weak\n/// applied to it, possibly with an alias.\nvoid Sema::DeclApplyPragmaWeak(Scope *S, NamedDecl *ND, WeakInfo &W) {\n  if (W.getUsed()) return; // only do this once\n  W.setUsed(true);\n  if (W.getAlias()) { // clone decl, impersonate __attribute(weak,alias(...))\n    IdentifierInfo *NDId = ND->getIdentifier();\n    NamedDecl *NewD = DeclClonePragmaWeak(ND, W.getAlias(), W.getLocation());\n    NewD->addAttr(\n        AliasAttr::CreateImplicit(Context, NDId->getName(), W.getLocation()));\n    NewD->addAttr(WeakAttr::CreateImplicit(Context, W.getLocation(),\n                                           AttributeCommonInfo::AS_Pragma));\n    WeakTopLevelDecl.push_back(NewD);\n    // FIXME: \"hideous\" code from Sema::LazilyCreateBuiltin\n    // to insert Decl at TU scope, sorry.\n    DeclContext *SavedContext = CurContext;\n    CurContext = Context.getTranslationUnitDecl();\n    NewD->setDeclContext(CurContext);\n    NewD->setLexicalDeclContext(CurContext);\n    PushOnScopeChains(NewD, S);\n    CurContext = SavedContext;\n  } else { // just add weak to existing\n    ND->addAttr(WeakAttr::CreateImplicit(Context, W.getLocation(),\n                                         AttributeCommonInfo::AS_Pragma));\n  }\n}\n\nvoid Sema::ProcessPragmaWeak(Scope *S, Decl *D) {\n  // It's valid to \"forward-declare\" #pragma weak, in which case we\n  // have to do this.\n  LoadExternalWeakUndeclaredIdentifiers();\n  if (!WeakUndeclaredIdentifiers.empty()) {\n    NamedDecl *ND = nullptr;\n    if (auto *VD = dyn_cast<VarDecl>(D))\n      if (VD->isExternC())\n        ND = VD;\n    if (auto *FD = dyn_cast<FunctionDecl>(D))\n      if (FD->isExternC())\n        ND = FD;\n    if (ND) {\n      if (IdentifierInfo *Id = ND->getIdentifier()) {\n        auto I = WeakUndeclaredIdentifiers.find(Id);\n        if (I != WeakUndeclaredIdentifiers.end()) {\n          WeakInfo W = I->second;\n          DeclApplyPragmaWeak(S, ND, W);\n          WeakUndeclaredIdentifiers[Id] = W;\n        }\n      }\n    }\n  }\n}\n\n/// ProcessDeclAttributes - Given a declarator (PD) with attributes indicated in\n/// it, apply them to D.  This is a bit tricky because PD can have attributes\n/// specified in many different places, and we need to find and apply them all.\nvoid Sema::ProcessDeclAttributes(Scope *S, Decl *D, const Declarator &PD) {\n  // Apply decl attributes from the DeclSpec if present.\n  if (!PD.getDeclSpec().getAttributes().empty())\n    ProcessDeclAttributeList(S, D, PD.getDeclSpec().getAttributes());\n\n  // Walk the declarator structure, applying decl attributes that were in a type\n  // position to the decl itself.  This handles cases like:\n  //   int *__attr__(x)** D;\n  // when X is a decl attribute.\n  for (unsigned i = 0, e = PD.getNumTypeObjects(); i != e; ++i)\n    ProcessDeclAttributeList(S, D, PD.getTypeObject(i).getAttrs(),\n                             /*IncludeCXX11Attributes=*/false);\n\n  // Finally, apply any attributes on the decl itself.\n  ProcessDeclAttributeList(S, D, PD.getAttributes());\n\n  // Apply additional attributes specified by '#pragma clang attribute'.\n  AddPragmaAttributes(S, D);\n}\n\n/// Is the given declaration allowed to use a forbidden type?\n/// If so, it'll still be annotated with an attribute that makes it\n/// illegal to actually use.\nstatic bool isForbiddenTypeAllowed(Sema &S, Decl *D,\n                                   const DelayedDiagnostic &diag,\n                                   UnavailableAttr::ImplicitReason &reason) {\n  // Private ivars are always okay.  Unfortunately, people don't\n  // always properly make their ivars private, even in system headers.\n  // Plus we need to make fields okay, too.\n  if (!isa<FieldDecl>(D) && !isa<ObjCPropertyDecl>(D) &&\n      !isa<FunctionDecl>(D))\n    return false;\n\n  // Silently accept unsupported uses of __weak in both user and system\n  // declarations when it's been disabled, for ease of integration with\n  // -fno-objc-arc files.  We do have to take some care against attempts\n  // to define such things;  for now, we've only done that for ivars\n  // and properties.\n  if ((isa<ObjCIvarDecl>(D) || isa<ObjCPropertyDecl>(D))) {\n    if (diag.getForbiddenTypeDiagnostic() == diag::err_arc_weak_disabled ||\n        diag.getForbiddenTypeDiagnostic() == diag::err_arc_weak_no_runtime) {\n      reason = UnavailableAttr::IR_ForbiddenWeak;\n      return true;\n    }\n  }\n\n  // Allow all sorts of things in system headers.\n  if (S.Context.getSourceManager().isInSystemHeader(D->getLocation())) {\n    // Currently, all the failures dealt with this way are due to ARC\n    // restrictions.\n    reason = UnavailableAttr::IR_ARCForbiddenType;\n    return true;\n  }\n\n  return false;\n}\n\n/// Handle a delayed forbidden-type diagnostic.\nstatic void handleDelayedForbiddenType(Sema &S, DelayedDiagnostic &DD,\n                                       Decl *D) {\n  auto Reason = UnavailableAttr::IR_None;\n  if (D && isForbiddenTypeAllowed(S, D, DD, Reason)) {\n    assert(Reason && \"didn't set reason?\");\n    D->addAttr(UnavailableAttr::CreateImplicit(S.Context, \"\", Reason, DD.Loc));\n    return;\n  }\n  if (S.getLangOpts().ObjCAutoRefCount)\n    if (const auto *FD = dyn_cast<FunctionDecl>(D)) {\n      // FIXME: we may want to suppress diagnostics for all\n      // kind of forbidden type messages on unavailable functions.\n      if (FD->hasAttr<UnavailableAttr>() &&\n          DD.getForbiddenTypeDiagnostic() ==\n              diag::err_arc_array_param_no_ownership) {\n        DD.Triggered = true;\n        return;\n      }\n    }\n\n  S.Diag(DD.Loc, DD.getForbiddenTypeDiagnostic())\n      << DD.getForbiddenTypeOperand() << DD.getForbiddenTypeArgument();\n  DD.Triggered = true;\n}\n\n\nvoid Sema::PopParsingDeclaration(ParsingDeclState state, Decl *decl) {\n  assert(DelayedDiagnostics.getCurrentPool());\n  DelayedDiagnosticPool &poppedPool = *DelayedDiagnostics.getCurrentPool();\n  DelayedDiagnostics.popWithoutEmitting(state);\n\n  // When delaying diagnostics to run in the context of a parsed\n  // declaration, we only want to actually emit anything if parsing\n  // succeeds.\n  if (!decl) return;\n\n  // We emit all the active diagnostics in this pool or any of its\n  // parents.  In general, we'll get one pool for the decl spec\n  // and a child pool for each declarator; in a decl group like:\n  //   deprecated_typedef foo, *bar, baz();\n  // only the declarator pops will be passed decls.  This is correct;\n  // we really do need to consider delayed diagnostics from the decl spec\n  // for each of the different declarations.\n  const DelayedDiagnosticPool *pool = &poppedPool;\n  do {\n    bool AnyAccessFailures = false;\n    for (DelayedDiagnosticPool::pool_iterator\n           i = pool->pool_begin(), e = pool->pool_end(); i != e; ++i) {\n      // This const_cast is a bit lame.  Really, Triggered should be mutable.\n      DelayedDiagnostic &diag = const_cast<DelayedDiagnostic&>(*i);\n      if (diag.Triggered)\n        continue;\n\n      switch (diag.Kind) {\n      case DelayedDiagnostic::Availability:\n        // Don't bother giving deprecation/unavailable diagnostics if\n        // the decl is invalid.\n        if (!decl->isInvalidDecl())\n          handleDelayedAvailabilityCheck(diag, decl);\n        break;\n\n      case DelayedDiagnostic::Access:\n        // Only produce one access control diagnostic for a structured binding\n        // declaration: we don't need to tell the user that all the fields are\n        // inaccessible one at a time.\n        if (AnyAccessFailures && isa<DecompositionDecl>(decl))\n          continue;\n        HandleDelayedAccessCheck(diag, decl);\n        if (diag.Triggered)\n          AnyAccessFailures = true;\n        break;\n\n      case DelayedDiagnostic::ForbiddenType:\n        handleDelayedForbiddenType(*this, diag, decl);\n        break;\n      }\n    }\n  } while ((pool = pool->getParent()));\n}\n\n/// Given a set of delayed diagnostics, re-emit them as if they had\n/// been delayed in the current context instead of in the given pool.\n/// Essentially, this just moves them to the current pool.\nvoid Sema::redelayDiagnostics(DelayedDiagnosticPool &pool) {\n  DelayedDiagnosticPool *curPool = DelayedDiagnostics.getCurrentPool();\n  assert(curPool && \"re-emitting in undelayed context not supported\");\n  curPool->steal(pool);\n}\n"}}, "reports": [{"events": [{"location": {"col": 38, "file": 20, "line": 438}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp", "reportHash": "48f433a45e49dcc4b2176792d64ed7b9", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 38, "file": 20, "line": 438}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp", "reportHash": "88910298f2a1dd96fbab8c6fcc21ae27", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 31, "file": 20, "line": 1049}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp", "reportHash": "b1405736fa986e64f4d39606ca915ee2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 31, "file": 20, "line": 1049}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp", "reportHash": "2010bbd55a102edaf14d6aabd35c7e41", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 28, "file": 20, "line": 5749}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp", "reportHash": "67bdd620d22f6d1350eb3b3a17d30713", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 28, "file": 20, "line": 5749}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp", "reportHash": "2ae4f3e1aff3caeae8d7abdee24dfa0d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 27, "file": 20, "line": 5760}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp", "reportHash": "f672129f125110573af8334c61f18b9b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 27, "file": 20, "line": 5760}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp", "reportHash": "bd87ac33b36a6201ce8435ca9ced7873", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 27, "file": 20, "line": 5774}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp", "reportHash": "00f4e51501b7c87bf217c9aa970c75de", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 27, "file": 20, "line": 5774}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp", "reportHash": "0e8c77e6bb931f3bedcc895307df1f62", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
