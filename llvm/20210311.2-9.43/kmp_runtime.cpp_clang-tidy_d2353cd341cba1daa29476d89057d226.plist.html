<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/home/vsts/work/1/build/projects/openmp/runtime/src/omp-tools.h", "content": "/*\n * include/omp-tools.h.var\n */\n\n//===----------------------------------------------------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef __OMPT__\n#define __OMPT__\n\n/*****************************************************************************\n * system include files\n *****************************************************************************/\n\n#include <stdint.h>\n#include <stddef.h>\n\n#ifdef DEPRECATION_WARNINGS \n# ifdef __cplusplus\n# define DEPRECATED_51 [[deprecated(\"as of 5.1\")]]\n# else\n# define DEPRECATED_51 __attribute__((deprecated(\"as of 5.1\")))\n#endif\n#else\n#define DEPRECATED_51\n#endif\n\n/*****************************************************************************\n * iteration macros\n *****************************************************************************/\n\n#define FOREACH_OMPT_INQUIRY_FN(macro)      \\\n    macro (ompt_enumerate_states)           \\\n    macro (ompt_enumerate_mutex_impls)      \\\n                                            \\\n    macro (ompt_set_callback)               \\\n    macro (ompt_get_callback)               \\\n                                            \\\n    macro (ompt_get_state)                  \\\n                                            \\\n    macro (ompt_get_parallel_info)          \\\n    macro (ompt_get_task_info)              \\\n    macro (ompt_get_task_memory)            \\\n    macro (ompt_get_thread_data)            \\\n    macro (ompt_get_unique_id)              \\\n    macro (ompt_finalize_tool)              \\\n                                            \\\n    macro(ompt_get_num_procs)               \\\n    macro(ompt_get_num_places)              \\\n    macro(ompt_get_place_proc_ids)          \\\n    macro(ompt_get_place_num)               \\\n    macro(ompt_get_partition_place_nums)    \\\n    macro(ompt_get_proc_id)                 \\\n                                            \\\n    macro(ompt_get_target_info)             \\\n    macro(ompt_get_num_devices)\n\n#define FOREACH_OMPT_STATE(macro)                                                                \\\n                                                                                                \\\n    /* first available state */                                                                 \\\n    macro (ompt_state_undefined, 0x102)      /* undefined thread state */                        \\\n                                                                                                \\\n    /* work states (0..15) */                                                                   \\\n    macro (ompt_state_work_serial, 0x000)    /* working outside parallel */                      \\\n    macro (ompt_state_work_parallel, 0x001)  /* working within parallel */                       \\\n    macro (ompt_state_work_reduction, 0x002) /* performing a reduction */                        \\\n                                                                                                \\\n    /* barrier wait states (16..31) */                                                          \\\n    macro (ompt_state_wait_barrier, 0x010)   /* waiting at a barrier */                          \\\n    macro (ompt_state_wait_barrier_implicit_parallel, 0x011)                                     \\\n                                            /* implicit barrier at the end of parallel region */\\\n    macro (ompt_state_wait_barrier_implicit_workshare, 0x012)                                    \\\n                                            /* implicit barrier at the end of worksharing */    \\\n    macro (ompt_state_wait_barrier_implicit, 0x013)  /* implicit barrier */                      \\\n    macro (ompt_state_wait_barrier_explicit, 0x014)  /* explicit barrier */                      \\\n                                                                                                \\\n    /* task wait states (32..63) */                                                             \\\n    macro (ompt_state_wait_taskwait, 0x020)  /* waiting at a taskwait */                         \\\n    macro (ompt_state_wait_taskgroup, 0x021) /* waiting at a taskgroup */                        \\\n                                                                                                \\\n    /* mutex wait states (64..127) */                                                           \\\n    macro (ompt_state_wait_mutex, 0x040)                                                         \\\n    macro (ompt_state_wait_lock, 0x041)      /* waiting for lock */                              \\\n    macro (ompt_state_wait_critical, 0x042)  /* waiting for critical */                          \\\n    macro (ompt_state_wait_atomic, 0x043)    /* waiting for atomic */                            \\\n    macro (ompt_state_wait_ordered, 0x044)   /* waiting for ordered */                           \\\n                                                                                                \\\n    /* target wait states (128..255) */                                                         \\\n    macro (ompt_state_wait_target, 0x080)        /* waiting for target region */                 \\\n    macro (ompt_state_wait_target_map, 0x081)    /* waiting for target data mapping operation */ \\\n    macro (ompt_state_wait_target_update, 0x082) /* waiting for target update operation */       \\\n                                                                                                \\\n    /* misc (256..511) */                                                                       \\\n    macro (ompt_state_idle, 0x100)           /* waiting for work */                              \\\n    macro (ompt_state_overhead, 0x101)       /* overhead excluding wait states */                \\\n                                                                                                \\\n    /* implementation-specific states (512..) */\n\n\n#define FOREACH_KMP_MUTEX_IMPL(macro)                                                \\\n    macro (kmp_mutex_impl_none, 0)         /* unknown implementation */              \\\n    macro (kmp_mutex_impl_spin, 1)         /* based on spin */                       \\\n    macro (kmp_mutex_impl_queuing, 2)      /* based on some fair policy */           \\\n    macro (kmp_mutex_impl_speculative, 3)  /* based on HW-supported speculation */\n\n#define FOREACH_OMPT_EVENT(macro)                                                                                        \\\n                                                                                                                         \\\n    /*--- Mandatory Events ---*/                                                                                         \\\n    macro (ompt_callback_thread_begin,      ompt_callback_thread_begin_t,       1) /* thread begin                    */ \\\n    macro (ompt_callback_thread_end,        ompt_callback_thread_end_t,         2) /* thread end                      */ \\\n                                                                                                                         \\\n    macro (ompt_callback_parallel_begin,    ompt_callback_parallel_begin_t,     3) /* parallel begin                  */ \\\n    macro (ompt_callback_parallel_end,      ompt_callback_parallel_end_t,       4) /* parallel end                    */ \\\n                                                                                                                         \\\n    macro (ompt_callback_task_create,       ompt_callback_task_create_t,        5) /* task begin                      */ \\\n    macro (ompt_callback_task_schedule,     ompt_callback_task_schedule_t,      6) /* task schedule                   */ \\\n    macro (ompt_callback_implicit_task,     ompt_callback_implicit_task_t,      7) /* implicit task                   */ \\\n                                                                                                                         \\\n    macro (ompt_callback_target,            ompt_callback_target_t,             8) /* target                          */ \\\n    macro (ompt_callback_target_data_op,    ompt_callback_target_data_op_t,     9) /* target data op                  */ \\\n    macro (ompt_callback_target_submit,     ompt_callback_target_submit_t,     10) /* target  submit                  */ \\\n                                                                                                                         \\\n    macro (ompt_callback_control_tool,      ompt_callback_control_tool_t,      11) /* control tool                    */ \\\n                                                                                                                         \\\n    macro (ompt_callback_device_initialize, ompt_callback_device_initialize_t, 12) /* device initialize               */ \\\n    macro (ompt_callback_device_finalize,   ompt_callback_device_finalize_t,   13) /* device finalize                 */ \\\n                                                                                                                         \\\n    macro (ompt_callback_device_load,       ompt_callback_device_load_t,       14) /* device load                     */ \\\n    macro (ompt_callback_device_unload,     ompt_callback_device_unload_t,     15) /* device unload                   */ \\\n                                                                                                                         \\\n    /* Optional Events */                                                                                                \\\n    macro (ompt_callback_sync_region_wait,  ompt_callback_sync_region_t,       16) /* sync region wait begin or end   */ \\\n                                                                                                                         \\\n    macro (ompt_callback_mutex_released,    ompt_callback_mutex_t,             17) /* mutex released                  */ \\\n                                                                                                                         \\\n    macro (ompt_callback_dependences,       ompt_callback_dependences_t,       18) /* report task dependences         */ \\\n    macro (ompt_callback_task_dependence,   ompt_callback_task_dependence_t,   19) /* report task dependence          */ \\\n                                                                                                                         \\\n    macro (ompt_callback_work,              ompt_callback_work_t,              20) /* task at work begin or end       */ \\\n                                                                                                                         \\\n    macro (ompt_callback_masked,            ompt_callback_masked_t,            21) /* task at masked begin or end     */ \\\n                                                                                                                         \\\n    macro (ompt_callback_target_map,        ompt_callback_target_map_t,        22) /* target map                      */ \\\n                                                                                                                         \\\n    macro (ompt_callback_sync_region,       ompt_callback_sync_region_t,       23) /* sync region begin or end        */ \\\n                                                                                                                         \\\n    macro (ompt_callback_lock_init,         ompt_callback_mutex_acquire_t,     24) /* lock init                       */ \\\n    macro (ompt_callback_lock_destroy,      ompt_callback_mutex_t,             25) /* lock destroy                    */ \\\n                                                                                                                         \\\n    macro (ompt_callback_mutex_acquire,     ompt_callback_mutex_acquire_t,     26) /* mutex acquire                   */ \\\n    macro (ompt_callback_mutex_acquired,    ompt_callback_mutex_t,             27) /* mutex acquired                  */ \\\n                                                                                                                         \\\n    macro (ompt_callback_nest_lock,         ompt_callback_nest_lock_t,         28) /* nest lock                       */ \\\n                                                                                                                         \\\n    macro (ompt_callback_flush,             ompt_callback_flush_t,             29) /* after executing flush           */ \\\n                                                                                                                         \\\n    macro (ompt_callback_cancel,            ompt_callback_cancel_t,            30) /* cancel innermost binding region */ \\\n                                                                                                                         \\\n    macro (ompt_callback_reduction,         ompt_callback_sync_region_t,       31) /* reduction                       */ \\\n                                                                                                                         \\\n    macro (ompt_callback_dispatch,          ompt_callback_dispatch_t,          32) /* dispatch of work                */ \\\n    macro (ompt_callback_target_emi,        ompt_callback_target_emi_t,        33) /* target                          */ \\\n    macro (ompt_callback_target_data_op_emi,ompt_callback_target_data_op_emi_t,34) /* target data op                  */ \\\n    macro (ompt_callback_target_submit_emi, ompt_callback_target_submit_emi_t, 35) /* target submit                   */ \\\n    macro (ompt_callback_target_map_emi,    ompt_callback_target_map_emi_t,    36) /* target map                      */ \\\n    macro (ompt_callback_error,             ompt_callback_error_t,             37) /* error                           */\n\n/*****************************************************************************\n * implementation specific types\n *****************************************************************************/\n\ntypedef enum kmp_mutex_impl_t {\n#define kmp_mutex_impl_macro(impl, code) impl = code,\n    FOREACH_KMP_MUTEX_IMPL(kmp_mutex_impl_macro)\n#undef kmp_mutex_impl_macro\n} kmp_mutex_impl_t;\n\n/*****************************************************************************\n * definitions generated from spec\n *****************************************************************************/\n\ntypedef enum ompt_callbacks_t {\n  ompt_callback_thread_begin             = 1,\n  ompt_callback_thread_end               = 2,\n  ompt_callback_parallel_begin           = 3,\n  ompt_callback_parallel_end             = 4,\n  ompt_callback_task_create              = 5,\n  ompt_callback_task_schedule            = 6,\n  ompt_callback_implicit_task            = 7,\n  ompt_callback_target                   = 8,\n  ompt_callback_target_data_op           = 9,\n  ompt_callback_target_submit            = 10,\n  ompt_callback_control_tool             = 11,\n  ompt_callback_device_initialize        = 12,\n  ompt_callback_device_finalize          = 13,\n  ompt_callback_device_load              = 14,\n  ompt_callback_device_unload            = 15,\n  ompt_callback_sync_region_wait         = 16,\n  ompt_callback_mutex_released           = 17,\n  ompt_callback_dependences              = 18,\n  ompt_callback_task_dependence          = 19,\n  ompt_callback_work                     = 20,\n  ompt_callback_master     DEPRECATED_51 = 21,\n  ompt_callback_masked                   = 21,\n  ompt_callback_target_map               = 22,\n  ompt_callback_sync_region              = 23,\n  ompt_callback_lock_init                = 24,\n  ompt_callback_lock_destroy             = 25,\n  ompt_callback_mutex_acquire            = 26,\n  ompt_callback_mutex_acquired           = 27,\n  ompt_callback_nest_lock                = 28,\n  ompt_callback_flush                    = 29,\n  ompt_callback_cancel                   = 30,\n  ompt_callback_reduction                = 31,\n  ompt_callback_dispatch                 = 32,\n  ompt_callback_target_emi               = 33,\n  ompt_callback_target_data_op_emi       = 34,\n  ompt_callback_target_submit_emi        = 35,\n  ompt_callback_target_map_emi           = 36,\n  ompt_callback_error                    = 37\n} ompt_callbacks_t;\n\ntypedef enum ompt_record_t {\n  ompt_record_ompt               = 1,\n  ompt_record_native             = 2,\n  ompt_record_invalid            = 3\n} ompt_record_t;\n\ntypedef enum ompt_record_native_t {\n  ompt_record_native_info  = 1,\n  ompt_record_native_event = 2\n} ompt_record_native_t;\n\ntypedef enum ompt_set_result_t {\n  ompt_set_error            = 0,\n  ompt_set_never            = 1,\n  ompt_set_impossible       = 2,\n  ompt_set_sometimes        = 3,\n  ompt_set_sometimes_paired = 4,\n  ompt_set_always           = 5\n} ompt_set_result_t;\n\ntypedef uint64_t ompt_id_t;\n\ntypedef uint64_t ompt_device_time_t;\n\ntypedef uint64_t ompt_buffer_cursor_t;\n\ntypedef enum ompt_thread_t {\n  ompt_thread_initial                 = 1,\n  ompt_thread_worker                  = 2,\n  ompt_thread_other                   = 3,\n  ompt_thread_unknown                 = 4\n} ompt_thread_t;\n\ntypedef enum ompt_scope_endpoint_t {\n  ompt_scope_begin                    = 1,\n  ompt_scope_end                      = 2,\n  ompt_scope_beginend                 = 3\n} ompt_scope_endpoint_t;\n\ntypedef enum ompt_dispatch_t {\n  ompt_dispatch_iteration             = 1,\n  ompt_dispatch_section               = 2\n} ompt_dispatch_t;\n\ntypedef enum ompt_sync_region_t {\n  ompt_sync_region_barrier                DEPRECATED_51 = 1,\n  ompt_sync_region_barrier_implicit       DEPRECATED_51 = 2,\n  ompt_sync_region_barrier_explicit       = 3,\n  ompt_sync_region_barrier_implementation = 4,\n  ompt_sync_region_taskwait               = 5,\n  ompt_sync_region_taskgroup              = 6,\n  ompt_sync_region_reduction              = 7,\n  ompt_sync_region_barrier_implicit_workshare = 8,\n  ompt_sync_region_barrier_implicit_parallel = 9,\n  ompt_sync_region_barrier_teams = 10\n} ompt_sync_region_t;\n\ntypedef enum ompt_target_data_op_t {\n  ompt_target_data_alloc                      = 1,\n  ompt_target_data_transfer_to_device         = 2,\n  ompt_target_data_transfer_from_device       = 3,\n  ompt_target_data_delete                     = 4,\n  ompt_target_data_associate                  = 5,\n  ompt_target_data_disassociate               = 6,\n  ompt_target_data_alloc_async                = 17,\n  ompt_target_data_transfer_to_device_async   = 18,\n  ompt_target_data_transfer_from_device_async = 19,\n  ompt_target_data_delete_async               = 20\n} ompt_target_data_op_t;\n\ntypedef enum ompt_work_t {\n  ompt_work_loop               = 1,\n  ompt_work_sections           = 2,\n  ompt_work_single_executor    = 3,\n  ompt_work_single_other       = 4,\n  ompt_work_workshare          = 5,\n  ompt_work_distribute         = 6,\n  ompt_work_taskloop           = 7,\n  ompt_work_scope              = 8\n} ompt_work_t;\n\ntypedef enum ompt_mutex_t {\n  ompt_mutex_lock                     = 1,\n  ompt_mutex_test_lock                = 2,\n  ompt_mutex_nest_lock                = 3,\n  ompt_mutex_test_nest_lock           = 4,\n  ompt_mutex_critical                 = 5,\n  ompt_mutex_atomic                   = 6,\n  ompt_mutex_ordered                  = 7\n} ompt_mutex_t;\n\ntypedef enum ompt_native_mon_flag_t {\n  ompt_native_data_motion_explicit    = 0x01,\n  ompt_native_data_motion_implicit    = 0x02,\n  ompt_native_kernel_invocation       = 0x04,\n  ompt_native_kernel_execution        = 0x08,\n  ompt_native_driver                  = 0x10,\n  ompt_native_runtime                 = 0x20,\n  ompt_native_overhead                = 0x40,\n  ompt_native_idleness                = 0x80\n} ompt_native_mon_flag_t;\n\ntypedef enum ompt_task_flag_t {\n  ompt_task_initial                   = 0x00000001,\n  ompt_task_implicit                  = 0x00000002,\n  ompt_task_explicit                  = 0x00000004,\n  ompt_task_target                    = 0x00000008,\n  ompt_task_taskwait                  = 0x00000010,\n  ompt_task_undeferred                = 0x08000000,\n  ompt_task_untied                    = 0x10000000,\n  ompt_task_final                     = 0x20000000,\n  ompt_task_mergeable                 = 0x40000000,\n  ompt_task_merged                    = 0x80000000\n} ompt_task_flag_t;\n\ntypedef enum ompt_task_status_t {\n  ompt_task_complete      = 1,\n  ompt_task_yield         = 2,\n  ompt_task_cancel        = 3,\n  ompt_task_detach        = 4,\n  ompt_task_early_fulfill = 5,\n  ompt_task_late_fulfill  = 6,\n  ompt_task_switch        = 7,\n  ompt_taskwait_complete  = 8\n} ompt_task_status_t;\n\ntypedef enum ompt_target_t {\n  ompt_target                         = 1,\n  ompt_target_enter_data              = 2,\n  ompt_target_exit_data               = 3,\n  ompt_target_update                  = 4,\n  ompt_target_nowait                  = 9,\n  ompt_target_enter_data_nowait       = 10,\n  ompt_target_exit_data_nowait        = 11,\n  ompt_target_update_nowait           = 12\n} ompt_target_t;\n\ntypedef enum ompt_parallel_flag_t {\n  ompt_parallel_invoker_program = 0x00000001,\n  ompt_parallel_invoker_runtime = 0x00000002,\n  ompt_parallel_league          = 0x40000000,\n  ompt_parallel_team            = 0x80000000\n} ompt_parallel_flag_t;\n\ntypedef enum ompt_target_map_flag_t {\n  ompt_target_map_flag_to             = 0x01,\n  ompt_target_map_flag_from           = 0x02,\n  ompt_target_map_flag_alloc          = 0x04,\n  ompt_target_map_flag_release        = 0x08,\n  ompt_target_map_flag_delete         = 0x10,\n  ompt_target_map_flag_implicit       = 0x20\n} ompt_target_map_flag_t;\n\ntypedef enum ompt_dependence_type_t {\n  ompt_dependence_type_in              = 1,\n  ompt_dependence_type_out             = 2,\n  ompt_dependence_type_inout           = 3,\n  ompt_dependence_type_mutexinoutset   = 4,\n  ompt_dependence_type_source          = 5,\n  ompt_dependence_type_sink            = 6,\n  ompt_dependence_type_inoutset        = 7\n} ompt_dependence_type_t;\n\ntypedef enum ompt_severity_t {\n  ompt_warning                         = 1,\n  ompt_fatal                           = 2\n} ompt_severity_t;\n\ntypedef enum ompt_cancel_flag_t {\n  ompt_cancel_parallel       = 0x01,\n  ompt_cancel_sections       = 0x02,\n  ompt_cancel_loop           = 0x04,\n  ompt_cancel_taskgroup      = 0x08,\n  ompt_cancel_activated      = 0x10,\n  ompt_cancel_detected       = 0x20,\n  ompt_cancel_discarded_task = 0x40\n} ompt_cancel_flag_t;\n\ntypedef uint64_t ompt_hwid_t;\n\ntypedef uint64_t ompt_wait_id_t;\n\ntypedef enum ompt_frame_flag_t {\n  ompt_frame_runtime        = 0x00,\n  ompt_frame_application    = 0x01,\n  ompt_frame_cfa            = 0x10,\n  ompt_frame_framepointer   = 0x20,\n  ompt_frame_stackaddress   = 0x30\n} ompt_frame_flag_t;\n\ntypedef enum ompt_state_t {\n  ompt_state_work_serial                      = 0x000,\n  ompt_state_work_parallel                    = 0x001,\n  ompt_state_work_reduction                   = 0x002,\n\n  ompt_state_wait_barrier                     DEPRECATED_51 = 0x010,\n  ompt_state_wait_barrier_implicit_parallel   = 0x011,\n  ompt_state_wait_barrier_implicit_workshare  = 0x012,\n  ompt_state_wait_barrier_implicit            DEPRECATED_51 = 0x013,\n  ompt_state_wait_barrier_explicit            = 0x014,\n  ompt_state_wait_barrier_implementation      = 0x015,\n  ompt_state_wait_barrier_teams               = 0x016,\n\n  ompt_state_wait_taskwait                    = 0x020,\n  ompt_state_wait_taskgroup                   = 0x021,\n\n  ompt_state_wait_mutex                       = 0x040,\n  ompt_state_wait_lock                        = 0x041,\n  ompt_state_wait_critical                    = 0x042,\n  ompt_state_wait_atomic                      = 0x043,\n  ompt_state_wait_ordered                     = 0x044,\n\n  ompt_state_wait_target                      = 0x080,\n  ompt_state_wait_target_map                  = 0x081,\n  ompt_state_wait_target_update               = 0x082,\n\n  ompt_state_idle                             = 0x100,\n  ompt_state_overhead                         = 0x101,\n  ompt_state_undefined                        = 0x102\n} ompt_state_t;\n\ntypedef uint64_t (*ompt_get_unique_id_t) (void);\n\ntypedef uint64_t ompd_size_t;\n\ntypedef uint64_t ompd_wait_id_t;\n\ntypedef uint64_t ompd_addr_t;\ntypedef int64_t  ompd_word_t;\ntypedef uint64_t ompd_seg_t;\n\ntypedef uint64_t ompd_device_t;\n\ntypedef uint64_t ompd_thread_id_t;\n\ntypedef enum ompd_scope_t {\n  ompd_scope_global = 1,\n  ompd_scope_address_space = 2,\n  ompd_scope_thread = 3,\n  ompd_scope_parallel = 4,\n  ompd_scope_implicit_task = 5,\n  ompd_scope_task = 6\n} ompd_scope_t;\n\ntypedef uint64_t ompd_icv_id_t;\n\ntypedef enum ompd_rc_t {\n  ompd_rc_ok = 0,\n  ompd_rc_unavailable = 1,\n  ompd_rc_stale_handle = 2,\n  ompd_rc_bad_input = 3,\n  ompd_rc_error = 4,\n  ompd_rc_unsupported = 5,\n  ompd_rc_needs_state_tracking = 6,\n  ompd_rc_incompatible = 7,\n  ompd_rc_device_read_error = 8,\n  ompd_rc_device_write_error = 9,\n  ompd_rc_nomem = 10,\n} ompd_rc_t;\n\ntypedef void (*ompt_interface_fn_t) (void);\n\ntypedef ompt_interface_fn_t (*ompt_function_lookup_t) (\n  const char *interface_function_name\n);\n\ntypedef union ompt_data_t {\n  uint64_t value;\n  void *ptr;\n} ompt_data_t;\n\ntypedef struct ompt_frame_t {\n  ompt_data_t exit_frame;\n  ompt_data_t enter_frame;\n  int exit_frame_flags;\n  int enter_frame_flags;\n} ompt_frame_t;\n\ntypedef void (*ompt_callback_t) (void);\n\ntypedef void ompt_device_t;\n\ntypedef void ompt_buffer_t;\n\ntypedef void (*ompt_callback_buffer_request_t) (\n  int device_num,\n  ompt_buffer_t **buffer,\n  size_t *bytes\n);\n\ntypedef void (*ompt_callback_buffer_complete_t) (\n  int device_num,\n  ompt_buffer_t *buffer,\n  size_t bytes,\n  ompt_buffer_cursor_t begin,\n  int buffer_owned\n);\n\ntypedef void (*ompt_finalize_t) (\n  ompt_data_t *tool_data\n);\n\ntypedef int (*ompt_initialize_t) (\n  ompt_function_lookup_t lookup,\n  int initial_device_num,\n  ompt_data_t *tool_data\n);\n\ntypedef struct ompt_start_tool_result_t {\n  ompt_initialize_t initialize;\n  ompt_finalize_t finalize;\n  ompt_data_t tool_data;\n} ompt_start_tool_result_t;\n\ntypedef struct ompt_record_abstract_t {\n  ompt_record_native_t rclass;\n  const char *type;\n  ompt_device_time_t start_time;\n  ompt_device_time_t end_time;\n  ompt_hwid_t hwid;\n} ompt_record_abstract_t;\n\ntypedef struct ompt_dependence_t {\n  ompt_data_t variable;\n  ompt_dependence_type_t dependence_type;\n} ompt_dependence_t;\n\ntypedef int (*ompt_enumerate_states_t) (\n  int current_state,\n  int *next_state,\n  const char **next_state_name\n);\n\ntypedef int (*ompt_enumerate_mutex_impls_t) (\n  int current_impl,\n  int *next_impl,\n  const char **next_impl_name\n);\n\ntypedef ompt_set_result_t (*ompt_set_callback_t) (\n  ompt_callbacks_t event,\n  ompt_callback_t callback\n);\n\ntypedef int (*ompt_get_callback_t) (\n  ompt_callbacks_t event,\n  ompt_callback_t *callback\n);\n\ntypedef ompt_data_t *(*ompt_get_thread_data_t) (void);\n\ntypedef int (*ompt_get_num_procs_t) (void);\n\ntypedef int (*ompt_get_num_places_t) (void);\n\ntypedef int (*ompt_get_place_proc_ids_t) (\n  int place_num,\n  int ids_size,\n  int *ids\n);\n\ntypedef int (*ompt_get_place_num_t) (void);\n\ntypedef int (*ompt_get_partition_place_nums_t) (\n  int place_nums_size,\n  int *place_nums\n);\n\ntypedef int (*ompt_get_proc_id_t) (void);\n\ntypedef int (*ompt_get_state_t) (\n  ompt_wait_id_t *wait_id\n);\n\ntypedef int (*ompt_get_parallel_info_t) (\n  int ancestor_level,\n  ompt_data_t **parallel_data,\n  int *team_size\n);\n\ntypedef int (*ompt_get_task_info_t) (\n  int ancestor_level,\n  int *flags,\n  ompt_data_t **task_data,\n  ompt_frame_t **task_frame,\n  ompt_data_t **parallel_data,\n  int *thread_num\n);\n\ntypedef int (*ompt_get_task_memory_t)(\n  void **addr,\n  size_t *size,\n  int block\n);\n\ntypedef int (*ompt_get_target_info_t) (\n  uint64_t *device_num,\n  ompt_id_t *target_id,\n  ompt_id_t *host_op_id\n);\n\ntypedef int (*ompt_get_num_devices_t) (void);\n\ntypedef void (*ompt_finalize_tool_t) (void);\n\ntypedef int (*ompt_get_device_num_procs_t) (\n  ompt_device_t *device\n);\n\ntypedef ompt_device_time_t (*ompt_get_device_time_t) (\n  ompt_device_t *device\n);\n\ntypedef double (*ompt_translate_time_t) (\n  ompt_device_t *device,\n  ompt_device_time_t time\n);\n\ntypedef ompt_set_result_t (*ompt_set_trace_ompt_t) (\n  ompt_device_t *device,\n  unsigned int enable,\n  unsigned int etype\n);\n\ntypedef ompt_set_result_t (*ompt_set_trace_native_t) (\n  ompt_device_t *device,\n  int enable,\n  int flags\n);\n\ntypedef int (*ompt_start_trace_t) (\n  ompt_device_t *device,\n  ompt_callback_buffer_request_t request,\n  ompt_callback_buffer_complete_t complete\n);\n\ntypedef int (*ompt_pause_trace_t) (\n  ompt_device_t *device,\n  int begin_pause\n);\n\ntypedef int (*ompt_flush_trace_t) (\n  ompt_device_t *device\n);\n\ntypedef int (*ompt_stop_trace_t) (\n  ompt_device_t *device\n);\n\ntypedef int (*ompt_advance_buffer_cursor_t) (\n  ompt_device_t *device,\n  ompt_buffer_t *buffer,\n  size_t size,\n  ompt_buffer_cursor_t current,\n  ompt_buffer_cursor_t *next\n);\n\ntypedef ompt_record_t (*ompt_get_record_type_t) (\n  ompt_buffer_t *buffer,\n  ompt_buffer_cursor_t current\n);\n\ntypedef void *(*ompt_get_record_native_t) (\n  ompt_buffer_t *buffer,\n  ompt_buffer_cursor_t current,\n  ompt_id_t *host_op_id\n);\n\ntypedef ompt_record_abstract_t *\n(*ompt_get_record_abstract_t) (\n  void *native_record\n);\n\ntypedef void (*ompt_callback_thread_begin_t) (\n  ompt_thread_t thread_type,\n  ompt_data_t *thread_data\n);\n\ntypedef struct ompt_record_thread_begin_t {\n  ompt_thread_t thread_type;\n} ompt_record_thread_begin_t;\n\ntypedef void (*ompt_callback_thread_end_t) (\n  ompt_data_t *thread_data\n);\n\ntypedef void (*ompt_callback_parallel_begin_t) (\n  ompt_data_t *encountering_task_data,\n  const ompt_frame_t *encountering_task_frame,\n  ompt_data_t *parallel_data,\n  unsigned int requested_parallelism,\n  int flags,\n  const void *codeptr_ra\n);\n\ntypedef struct ompt_record_parallel_begin_t {\n  ompt_id_t encountering_task_id;\n  ompt_id_t parallel_id;\n  unsigned int requested_parallelism;\n  int flags;\n  const void *codeptr_ra;\n} ompt_record_parallel_begin_t;\n\ntypedef void (*ompt_callback_parallel_end_t) (\n  ompt_data_t *parallel_data,\n  ompt_data_t *encountering_task_data,\n  int flags,\n  const void *codeptr_ra\n);\n\ntypedef struct ompt_record_parallel_end_t {\n  ompt_id_t parallel_id;\n  ompt_id_t encountering_task_id;\n  int flags;\n  const void *codeptr_ra;\n} ompt_record_parallel_end_t;\n\ntypedef void (*ompt_callback_work_t) (\n  ompt_work_t wstype,\n  ompt_scope_endpoint_t endpoint,\n  ompt_data_t *parallel_data,\n  ompt_data_t *task_data,\n  uint64_t count,\n  const void *codeptr_ra\n);\n\ntypedef struct ompt_record_work_t {\n  ompt_work_t wstype;\n  ompt_scope_endpoint_t endpoint;\n  ompt_id_t parallel_id;\n  ompt_id_t task_id;\n  uint64_t count;\n  const void *codeptr_ra;\n} ompt_record_work_t;\n\ntypedef void (*ompt_callback_dispatch_t) (\n  ompt_data_t *parallel_data,\n  ompt_data_t *task_data,\n  ompt_dispatch_t kind,\n  ompt_data_t instance\n);\n\ntypedef struct ompt_record_dispatch_t {\n  ompt_id_t parallel_id;\n  ompt_id_t task_id;\n  ompt_dispatch_t kind;\n  ompt_data_t instance;\n} ompt_record_dispatch_t;\n\ntypedef void (*ompt_callback_task_create_t) (\n  ompt_data_t *encountering_task_data,\n  const ompt_frame_t *encountering_task_frame,\n  ompt_data_t *new_task_data,\n  int flags,\n  int has_dependences,\n  const void *codeptr_ra\n);\n\ntypedef struct ompt_record_task_create_t {\n  ompt_id_t encountering_task_id;\n  ompt_id_t new_task_id;\n  int flags;\n  int has_dependences;\n  const void *codeptr_ra;\n} ompt_record_task_create_t;\n\ntypedef void (*ompt_callback_dependences_t) (\n  ompt_data_t *task_data,\n  const ompt_dependence_t *deps,\n  int ndeps\n);\n\ntypedef struct ompt_record_dependences_t {\n  ompt_id_t task_id;\n  ompt_dependence_t dep;\n  int ndeps;\n} ompt_record_dependences_t;\n\ntypedef void (*ompt_callback_task_dependence_t) (\n  ompt_data_t *src_task_data,\n  ompt_data_t *sink_task_data\n);\n\ntypedef struct ompt_record_task_dependence_t {\n  ompt_id_t src_task_id;\n  ompt_id_t sink_task_id;\n} ompt_record_task_dependence_t;\n\ntypedef void (*ompt_callback_task_schedule_t) (\n  ompt_data_t *prior_task_data,\n  ompt_task_status_t prior_task_status,\n  ompt_data_t *next_task_data\n);\n\ntypedef struct ompt_record_task_schedule_t {\n  ompt_id_t prior_task_id;\n  ompt_task_status_t prior_task_status;\n  ompt_id_t next_task_id;\n} ompt_record_task_schedule_t;\n\ntypedef void (*ompt_callback_implicit_task_t) (\n  ompt_scope_endpoint_t endpoint,\n  ompt_data_t *parallel_data,\n  ompt_data_t *task_data,\n  unsigned int actual_parallelism,\n  unsigned int index,\n  int flags\n);\n\ntypedef struct ompt_record_implicit_task_t {\n  ompt_scope_endpoint_t endpoint;\n  ompt_id_t parallel_id;\n  ompt_id_t task_id;\n  unsigned int actual_parallelism;\n  unsigned int index;\n  int flags;\n} ompt_record_implicit_task_t;\n\ntypedef void (*ompt_callback_masked_t) (\n  ompt_scope_endpoint_t endpoint,\n  ompt_data_t *parallel_data,\n  ompt_data_t *task_data,\n  const void *codeptr_ra\n);\n\ntypedef ompt_callback_masked_t ompt_callback_master_t DEPRECATED_51;\n\ntypedef struct ompt_record_masked_t {\n  ompt_scope_endpoint_t endpoint;\n  ompt_id_t parallel_id;\n  ompt_id_t task_id;\n  const void *codeptr_ra;\n} ompt_record_masked_t;\n\ntypedef void (*ompt_callback_sync_region_t) (\n  ompt_sync_region_t kind,\n  ompt_scope_endpoint_t endpoint,\n  ompt_data_t *parallel_data,\n  ompt_data_t *task_data,\n  const void *codeptr_ra\n);\n\ntypedef struct ompt_record_sync_region_t {\n  ompt_sync_region_t kind;\n  ompt_scope_endpoint_t endpoint;\n  ompt_id_t parallel_id;\n  ompt_id_t task_id;\n  const void *codeptr_ra;\n} ompt_record_sync_region_t;\n\ntypedef void (*ompt_callback_mutex_acquire_t) (\n  ompt_mutex_t kind,\n  unsigned int hint,\n  unsigned int impl,\n  ompt_wait_id_t wait_id,\n  const void *codeptr_ra\n);\n\ntypedef struct ompt_record_mutex_acquire_t {\n  ompt_mutex_t kind;\n  unsigned int hint;\n  unsigned int impl;\n  ompt_wait_id_t wait_id;\n  const void *codeptr_ra;\n} ompt_record_mutex_acquire_t;\n\ntypedef void (*ompt_callback_mutex_t) (\n  ompt_mutex_t kind,\n  ompt_wait_id_t wait_id,\n  const void *codeptr_ra\n);\n\ntypedef struct ompt_record_mutex_t {\n  ompt_mutex_t kind;\n  ompt_wait_id_t wait_id;\n  const void *codeptr_ra;\n} ompt_record_mutex_t;\n\ntypedef void (*ompt_callback_nest_lock_t) (\n  ompt_scope_endpoint_t endpoint,\n  ompt_wait_id_t wait_id,\n  const void *codeptr_ra\n);\n\ntypedef struct ompt_record_nest_lock_t {\n  ompt_scope_endpoint_t endpoint;\n  ompt_wait_id_t wait_id;\n  const void *codeptr_ra;\n} ompt_record_nest_lock_t;\n\ntypedef void (*ompt_callback_flush_t) (\n  ompt_data_t *thread_data,\n  const void *codeptr_ra\n);\n\ntypedef struct ompt_record_flush_t {\n  const void *codeptr_ra;\n} ompt_record_flush_t;\n\ntypedef void (*ompt_callback_cancel_t) (\n  ompt_data_t *task_data,\n  int flags,\n  const void *codeptr_ra\n);\n\ntypedef struct ompt_record_cancel_t {\n  ompt_id_t task_id;\n  int flags;\n  const void *codeptr_ra;\n} ompt_record_cancel_t;\n\ntypedef void (*ompt_callback_device_initialize_t) (\n  int device_num,\n  const char *type,\n  ompt_device_t *device,\n  ompt_function_lookup_t lookup,\n  const char *documentation\n);\n\ntypedef void (*ompt_callback_device_finalize_t) (\n  int device_num\n);\n\ntypedef void (*ompt_callback_device_load_t) (\n  int device_num,\n  const char *filename,\n  int64_t offset_in_file,\n  void *vma_in_file,\n  size_t bytes,\n  void *host_addr,\n  void *device_addr,\n  uint64_t module_id\n);\n\ntypedef void (*ompt_callback_device_unload_t) (\n  int device_num,\n  uint64_t module_id\n);\n\ntypedef void (*ompt_callback_target_data_op_emi_t) (\n  ompt_scope_endpoint_t endpoint,\n  ompt_data_t *target_task_data,\n  ompt_data_t *target_data,\n  ompt_id_t *host_op_id,\n  ompt_target_data_op_t optype,\n  void *src_addr,\n  int src_device_num,\n  void *dest_addr,\n  int dest_device_num,\n  size_t bytes,\n  const void *codeptr_ra\n);\n\ntypedef void (*ompt_callback_target_data_op_t) (\n  ompt_id_t target_id,\n  ompt_id_t host_op_id,\n  ompt_target_data_op_t optype,\n  void *src_addr,\n  int src_device_num,\n  void *dest_addr,\n  int dest_device_num,\n  size_t bytes,\n  const void *codeptr_ra\n);\n\ntypedef struct ompt_record_target_data_op_t {\n  ompt_id_t host_op_id;\n  ompt_target_data_op_t optype;\n  void *src_addr;\n  int src_device_num;\n  void *dest_addr;\n  int dest_device_num;\n  size_t bytes;\n  ompt_device_time_t end_time;\n  const void *codeptr_ra;\n} ompt_record_target_data_op_t;\n\ntypedef void (*ompt_callback_target_emi_t) (\n  ompt_target_t kind,\n  ompt_scope_endpoint_t endpoint,\n  int device_num,\n  ompt_data_t *task_data,\n  ompt_data_t *target_task_data,\n  ompt_data_t *target_data,\n  const void *codeptr_ra\n);\n\ntypedef void (*ompt_callback_target_t) (\n  ompt_target_t kind,\n  ompt_scope_endpoint_t endpoint,\n  int device_num,\n  ompt_data_t *task_data,\n  ompt_id_t target_id,\n  const void *codeptr_ra\n);\n\ntypedef struct ompt_record_target_t {\n  ompt_target_t kind;\n  ompt_scope_endpoint_t endpoint;\n  int device_num;\n  ompt_id_t task_id;\n  ompt_id_t target_id;\n  const void *codeptr_ra;\n} ompt_record_target_t;\n\ntypedef void (*ompt_callback_target_map_emi_t) (\n  ompt_data_t *target_data,\n  unsigned int nitems,\n  void **host_addr,\n  void **device_addr,\n  size_t *bytes,\n  unsigned int *mapping_flags,\n  const void *codeptr_ra\n);\n\ntypedef void (*ompt_callback_target_map_t) (\n  ompt_id_t target_id,\n  unsigned int nitems,\n  void **host_addr,\n  void **device_addr,\n  size_t *bytes,\n  unsigned int *mapping_flags,\n  const void *codeptr_ra\n);\n\ntypedef struct ompt_record_target_map_t {\n  ompt_id_t target_id;\n  unsigned int nitems;\n  void **host_addr;\n  void **device_addr;\n  size_t *bytes;\n  unsigned int *mapping_flags;\n  const void *codeptr_ra;\n} ompt_record_target_map_t;\n\ntypedef void (*ompt_callback_target_submit_emi_t) (\n  ompt_scope_endpoint_t endpoint,\n  ompt_data_t *target_data,\n  ompt_id_t *host_op_id,\n  unsigned int requested_num_teams\n);\n\ntypedef void (*ompt_callback_target_submit_t) (\n  ompt_id_t target_id,\n  ompt_id_t host_op_id,\n  unsigned int requested_num_teams\n);\n\ntypedef struct ompt_record_target_kernel_t {\n  ompt_id_t host_op_id;\n  unsigned int requested_num_teams;\n  unsigned int granted_num_teams;\n  ompt_device_time_t end_time;\n} ompt_record_target_kernel_t;\n\ntypedef int (*ompt_callback_control_tool_t) (\n  uint64_t command,\n  uint64_t modifier,\n  void *arg,\n  const void *codeptr_ra\n);\n\ntypedef struct ompt_record_control_tool_t {\n  uint64_t command;\n  uint64_t modifier;\n  const void *codeptr_ra;\n} ompt_record_control_tool_t;\n\ntypedef void (*ompt_callback_error_t) (\n  ompt_severity_t severity,\n  const char *message, size_t length,\n  const void *codeptr_ra\n);\n\ntypedef struct ompd_address_t {\n  ompd_seg_t segment;\n  ompd_addr_t address;\n} ompd_address_t;\n\ntypedef struct ompd_frame_info_t {\n  ompd_address_t frame_address;\n  ompd_word_t frame_flag;\n} ompd_frame_info_t;\n\ntypedef struct _ompd_aspace_handle ompd_address_space_handle_t;\ntypedef struct _ompd_thread_handle ompd_thread_handle_t;\ntypedef struct _ompd_parallel_handle ompd_parallel_handle_t;\ntypedef struct _ompd_task_handle ompd_task_handle_t;\n\ntypedef struct _ompd_aspace_cont ompd_address_space_context_t;\ntypedef struct _ompd_thread_cont ompd_thread_context_t;\n\ntypedef struct ompd_device_type_sizes_t {\n  uint8_t sizeof_char;\n  uint8_t sizeof_short;\n  uint8_t sizeof_int;\n  uint8_t sizeof_long;\n  uint8_t sizeof_long_long;\n  uint8_t sizeof_pointer;\n} ompd_device_type_sizes_t;\n\ntypedef struct ompt_record_ompt_t {\n  ompt_callbacks_t type;\n  ompt_device_time_t time;\n  ompt_id_t thread_id;\n  ompt_id_t target_id;\n  union {\n    ompt_record_thread_begin_t thread_begin;\n    ompt_record_parallel_begin_t parallel_begin;\n    ompt_record_parallel_end_t parallel_end;\n    ompt_record_work_t work;\n    ompt_record_dispatch_t dispatch;\n    ompt_record_task_create_t task_create;\n    ompt_record_dependences_t dependences;\n    ompt_record_task_dependence_t task_dependence;\n    ompt_record_task_schedule_t task_schedule;\n    ompt_record_implicit_task_t implicit_task;\n    ompt_record_masked_t masked;\n    ompt_record_sync_region_t sync_region;\n    ompt_record_mutex_acquire_t mutex_acquire;\n    ompt_record_mutex_t mutex;\n    ompt_record_nest_lock_t nest_lock;\n    ompt_record_flush_t flush;\n    ompt_record_cancel_t cancel;\n    ompt_record_target_t target;\n    ompt_record_target_data_op_t target_data_op;\n    ompt_record_target_map_t target_map;\n    ompt_record_target_kernel_t target_kernel;\n    ompt_record_control_tool_t control_tool;\n  } record;\n} ompt_record_ompt_t;\n\ntypedef ompt_record_ompt_t *(*ompt_get_record_ompt_t) (\n  ompt_buffer_t *buffer,\n  ompt_buffer_cursor_t current\n);\n\n#define ompt_id_none 0\n#define ompt_data_none {0}\n#define ompt_time_none 0\n#define ompt_hwid_none 0\n#define ompt_addr_none ~0\n#define ompt_mutex_impl_none 0\n#define ompt_wait_id_none 0\n\n#define ompd_segment_none 0\n\n#endif /* __OMPT__ */\n"}, "1": {"id": 1, "path": "/home/vsts/work/1/llvm-project/openmp/runtime/src/kmp.h", "content": "/*! \\file */\n/*\n * kmp.h -- KPTS runtime header file.\n */\n\n//===----------------------------------------------------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef KMP_H\n#define KMP_H\n\n#include \"kmp_config.h\"\n\n/* #define BUILD_PARALLEL_ORDERED 1 */\n\n/* This fix replaces gettimeofday with clock_gettime for better scalability on\n   the Altix.  Requires user code to be linked with -lrt. */\n//#define FIX_SGI_CLOCK\n\n/* Defines for OpenMP 3.0 tasking and auto scheduling */\n\n#ifndef KMP_STATIC_STEAL_ENABLED\n#define KMP_STATIC_STEAL_ENABLED 1\n#endif\n\n#define TASK_CURRENT_NOT_QUEUED 0\n#define TASK_CURRENT_QUEUED 1\n\n#ifdef BUILD_TIED_TASK_STACK\n#define TASK_STACK_EMPTY 0 // entries when the stack is empty\n#define TASK_STACK_BLOCK_BITS 5 // Used in TASK_STACK_SIZE and TASK_STACK_MASK\n// Number of entries in each task stack array\n#define TASK_STACK_BLOCK_SIZE (1 << TASK_STACK_BLOCK_BITS)\n// Mask for determining index into stack block\n#define TASK_STACK_INDEX_MASK (TASK_STACK_BLOCK_SIZE - 1)\n#endif // BUILD_TIED_TASK_STACK\n\n#define TASK_NOT_PUSHED 1\n#define TASK_SUCCESSFULLY_PUSHED 0\n#define TASK_TIED 1\n#define TASK_UNTIED 0\n#define TASK_EXPLICIT 1\n#define TASK_IMPLICIT 0\n#define TASK_PROXY 1\n#define TASK_FULL 0\n#define TASK_DETACHABLE 1\n#define TASK_UNDETACHABLE 0\n\n#define KMP_CANCEL_THREADS\n#define KMP_THREAD_ATTR\n\n// Android does not have pthread_cancel.  Undefine KMP_CANCEL_THREADS if being\n// built on Android\n#if defined(__ANDROID__)\n#undef KMP_CANCEL_THREADS\n#endif\n\n#include <signal.h>\n#include <stdarg.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits>\n#include <type_traits>\n/* include <ctype.h> don't use; problems with /MD on Windows* OS NT due to bad\n   Microsoft library. Some macros provided below to replace these functions  */\n#ifndef __ABSOFT_WIN\n#include <sys/types.h>\n#endif\n#include <limits.h>\n#include <time.h>\n\n#include <errno.h>\n\n#include \"kmp_os.h\"\n\n#include \"kmp_safe_c_api.h\"\n\n#if KMP_STATS_ENABLED\nclass kmp_stats_list;\n#endif\n\n#if KMP_USE_HIER_SCHED\n// Only include hierarchical scheduling if affinity is supported\n#undef KMP_USE_HIER_SCHED\n#define KMP_USE_HIER_SCHED KMP_AFFINITY_SUPPORTED\n#endif\n\n#if KMP_USE_HWLOC && KMP_AFFINITY_SUPPORTED\n#include \"hwloc.h\"\n#ifndef HWLOC_OBJ_NUMANODE\n#define HWLOC_OBJ_NUMANODE HWLOC_OBJ_NODE\n#endif\n#ifndef HWLOC_OBJ_PACKAGE\n#define HWLOC_OBJ_PACKAGE HWLOC_OBJ_SOCKET\n#endif\n#if HWLOC_API_VERSION >= 0x00020000\n// hwloc 2.0 changed type of depth of object from unsigned to int\ntypedef int kmp_hwloc_depth_t;\n#else\ntypedef unsigned int kmp_hwloc_depth_t;\n#endif\n#endif\n\n#if KMP_ARCH_X86 || KMP_ARCH_X86_64\n#include <xmmintrin.h>\n#endif\n\n#include \"kmp_debug.h\"\n#include \"kmp_lock.h\"\n#include \"kmp_version.h\"\n#if USE_DEBUGGER\n#include \"kmp_debugger.h\"\n#endif\n#include \"kmp_i18n.h\"\n\n#define KMP_HANDLE_SIGNALS (KMP_OS_UNIX || KMP_OS_WINDOWS)\n\n#include \"kmp_wrapper_malloc.h\"\n#if KMP_OS_UNIX\n#include <unistd.h>\n#if !defined NSIG && defined _NSIG\n#define NSIG _NSIG\n#endif\n#endif\n\n#if KMP_OS_LINUX\n#pragma weak clock_gettime\n#endif\n\n#if OMPT_SUPPORT\n#include \"ompt-internal.h\"\n#endif\n\n#ifndef UNLIKELY\n#define UNLIKELY(x) (x)\n#endif\n\n// Affinity format function\n#include \"kmp_str.h\"\n\n// 0 - no fast memory allocation, alignment: 8-byte on x86, 16-byte on x64.\n// 3 - fast allocation using sync, non-sync free lists of any size, non-self\n// free lists of limited size.\n#ifndef USE_FAST_MEMORY\n#define USE_FAST_MEMORY 3\n#endif\n\n#ifndef KMP_NESTED_HOT_TEAMS\n#define KMP_NESTED_HOT_TEAMS 0\n#define USE_NESTED_HOT_ARG(x)\n#else\n#if KMP_NESTED_HOT_TEAMS\n#define USE_NESTED_HOT_ARG(x) , x\n#else\n#define USE_NESTED_HOT_ARG(x)\n#endif\n#endif\n\n// Assume using BGET compare_exchange instruction instead of lock by default.\n#ifndef USE_CMP_XCHG_FOR_BGET\n#define USE_CMP_XCHG_FOR_BGET 1\n#endif\n\n// Test to see if queuing lock is better than bootstrap lock for bget\n// #ifndef USE_QUEUING_LOCK_FOR_BGET\n// #define USE_QUEUING_LOCK_FOR_BGET\n// #endif\n\n#define KMP_NSEC_PER_SEC 1000000000L\n#define KMP_USEC_PER_SEC 1000000L\n\n/*!\n@ingroup BASIC_TYPES\n@{\n*/\n\n/*!\nValues for bit flags used in the ident_t to describe the fields.\n*/\nenum {\n  /*! Use trampoline for internal microtasks */\n  KMP_IDENT_IMB = 0x01,\n  /*! Use c-style ident structure */\n  KMP_IDENT_KMPC = 0x02,\n  /* 0x04 is no longer used */\n  /*! Entry point generated by auto-parallelization */\n  KMP_IDENT_AUTOPAR = 0x08,\n  /*! Compiler generates atomic reduction option for kmpc_reduce* */\n  KMP_IDENT_ATOMIC_REDUCE = 0x10,\n  /*! To mark a 'barrier' directive in user code */\n  KMP_IDENT_BARRIER_EXPL = 0x20,\n  /*! To Mark implicit barriers. */\n  KMP_IDENT_BARRIER_IMPL = 0x0040,\n  KMP_IDENT_BARRIER_IMPL_MASK = 0x01C0,\n  KMP_IDENT_BARRIER_IMPL_FOR = 0x0040,\n  KMP_IDENT_BARRIER_IMPL_SECTIONS = 0x00C0,\n\n  KMP_IDENT_BARRIER_IMPL_SINGLE = 0x0140,\n  KMP_IDENT_BARRIER_IMPL_WORKSHARE = 0x01C0,\n\n  /*! To mark a static loop in OMPT callbacks */\n  KMP_IDENT_WORK_LOOP = 0x200,\n  /*! To mark a sections directive in OMPT callbacks */\n  KMP_IDENT_WORK_SECTIONS = 0x400,\n  /*! To mark a distribute construct in OMPT callbacks */\n  KMP_IDENT_WORK_DISTRIBUTE = 0x800,\n  /*! Atomic hint; bottom four bits as omp_sync_hint_t. Top four reserved and\n      not currently used. If one day we need more bits, then we can use\n      an invalid combination of hints to mean that another, larger field\n      should be used in a different flag. */\n  KMP_IDENT_ATOMIC_HINT_MASK = 0xFF0000,\n  KMP_IDENT_ATOMIC_HINT_UNCONTENDED = 0x010000,\n  KMP_IDENT_ATOMIC_HINT_CONTENDED = 0x020000,\n  KMP_IDENT_ATOMIC_HINT_NONSPECULATIVE = 0x040000,\n  KMP_IDENT_ATOMIC_HINT_SPECULATIVE = 0x080000,\n  KMP_IDENT_OPENMP_SPEC_VERSION_MASK = 0xFF000000\n};\n\n/*!\n * The ident structure that describes a source location.\n */\ntypedef struct ident {\n  kmp_int32 reserved_1; /**<  might be used in Fortran; see above  */\n  kmp_int32 flags; /**<  also f.flags; KMP_IDENT_xxx flags; KMP_IDENT_KMPC\n                      identifies this union member  */\n  kmp_int32 reserved_2; /**<  not really used in Fortran any more; see above */\n#if USE_ITT_BUILD\n/*  but currently used for storing region-specific ITT */\n/*  contextual information. */\n#endif /* USE_ITT_BUILD */\n  kmp_int32 reserved_3; /**< source[4] in Fortran, do not use for C++  */\n  char const *psource; /**< String describing the source location.\n                       The string is composed of semi-colon separated fields\n                       which describe the source file, the function and a pair\n                       of line numbers that delimit the construct. */\n  // Returns the OpenMP version in form major*10+minor (e.g., 50 for 5.0)\n  kmp_int32 get_openmp_version() {\n    return (((flags & KMP_IDENT_OPENMP_SPEC_VERSION_MASK) >> 24) & 0xFF);\n  }\n} ident_t;\n/*!\n@}\n*/\n\n// Some forward declarations.\ntypedef union kmp_team kmp_team_t;\ntypedef struct kmp_taskdata kmp_taskdata_t;\ntypedef union kmp_task_team kmp_task_team_t;\ntypedef union kmp_team kmp_team_p;\ntypedef union kmp_info kmp_info_p;\ntypedef union kmp_root kmp_root_p;\n\ntemplate <bool C = false, bool S = true> class kmp_flag_32;\ntemplate <bool C = false, bool S = true> class kmp_flag_64;\nclass kmp_flag_oncore;\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* ------------------------------------------------------------------------ */\n\n/* Pack two 32-bit signed integers into a 64-bit signed integer */\n/* ToDo: Fix word ordering for big-endian machines. */\n#define KMP_PACK_64(HIGH_32, LOW_32)                                           \\\n  ((kmp_int64)((((kmp_uint64)(HIGH_32)) << 32) | (kmp_uint64)(LOW_32)))\n\n// Generic string manipulation macros. Assume that _x is of type char *\n#define SKIP_WS(_x)                                                            \\\n  {                                                                            \\\n    while (*(_x) == ' ' || *(_x) == '\\t')                                      \\\n      (_x)++;                                                                  \\\n  }\n#define SKIP_DIGITS(_x)                                                        \\\n  {                                                                            \\\n    while (*(_x) >= '0' && *(_x) <= '9')                                       \\\n      (_x)++;                                                                  \\\n  }\n#define SKIP_TOKEN(_x)                                                         \\\n  {                                                                            \\\n    while ((*(_x) >= '0' && *(_x) <= '9') || (*(_x) >= 'a' && *(_x) <= 'z') || \\\n           (*(_x) >= 'A' && *(_x) <= 'Z') || *(_x) == '_')                     \\\n      (_x)++;                                                                  \\\n  }\n#define SKIP_TO(_x, _c)                                                        \\\n  {                                                                            \\\n    while (*(_x) != '\\0' && *(_x) != (_c))                                     \\\n      (_x)++;                                                                  \\\n  }\n\n/* ------------------------------------------------------------------------ */\n\n#define KMP_MAX(x, y) ((x) > (y) ? (x) : (y))\n#define KMP_MIN(x, y) ((x) < (y) ? (x) : (y))\n\n/* ------------------------------------------------------------------------ */\n/* Enumeration types */\n\nenum kmp_state_timer {\n  ts_stop,\n  ts_start,\n  ts_pause,\n\n  ts_last_state\n};\n\nenum dynamic_mode {\n  dynamic_default,\n#ifdef USE_LOAD_BALANCE\n  dynamic_load_balance,\n#endif /* USE_LOAD_BALANCE */\n  dynamic_random,\n  dynamic_thread_limit,\n  dynamic_max\n};\n\n/* external schedule constants, duplicate enum omp_sched in omp.h in order to\n * not include it here */\n#ifndef KMP_SCHED_TYPE_DEFINED\n#define KMP_SCHED_TYPE_DEFINED\ntypedef enum kmp_sched {\n  kmp_sched_lower = 0, // lower and upper bounds are for routine parameter check\n  // Note: need to adjust __kmp_sch_map global array in case enum is changed\n  kmp_sched_static = 1, // mapped to kmp_sch_static_chunked           (33)\n  kmp_sched_dynamic = 2, // mapped to kmp_sch_dynamic_chunked          (35)\n  kmp_sched_guided = 3, // mapped to kmp_sch_guided_chunked           (36)\n  kmp_sched_auto = 4, // mapped to kmp_sch_auto                     (38)\n  kmp_sched_upper_std = 5, // upper bound for standard schedules\n  kmp_sched_lower_ext = 100, // lower bound of Intel extension schedules\n  kmp_sched_trapezoidal = 101, // mapped to kmp_sch_trapezoidal (39)\n#if KMP_STATIC_STEAL_ENABLED\n  kmp_sched_static_steal = 102, // mapped to kmp_sch_static_steal (44)\n#endif\n  kmp_sched_upper,\n  kmp_sched_default = kmp_sched_static, // default scheduling\n  kmp_sched_monotonic = 0x80000000\n} kmp_sched_t;\n#endif\n\n/*!\n @ingroup WORK_SHARING\n * Describes the loop schedule to be used for a parallel for loop.\n */\nenum sched_type : kmp_int32 {\n  kmp_sch_lower = 32, /**< lower bound for unordered values */\n  kmp_sch_static_chunked = 33,\n  kmp_sch_static = 34, /**< static unspecialized */\n  kmp_sch_dynamic_chunked = 35,\n  kmp_sch_guided_chunked = 36, /**< guided unspecialized */\n  kmp_sch_runtime = 37,\n  kmp_sch_auto = 38, /**< auto */\n  kmp_sch_trapezoidal = 39,\n\n  /* accessible only through KMP_SCHEDULE environment variable */\n  kmp_sch_static_greedy = 40,\n  kmp_sch_static_balanced = 41,\n  /* accessible only through KMP_SCHEDULE environment variable */\n  kmp_sch_guided_iterative_chunked = 42,\n  kmp_sch_guided_analytical_chunked = 43,\n  /* accessible only through KMP_SCHEDULE environment variable */\n  kmp_sch_static_steal = 44,\n\n  /* static with chunk adjustment (e.g., simd) */\n  kmp_sch_static_balanced_chunked = 45,\n  kmp_sch_guided_simd = 46, /**< guided with chunk adjustment */\n  kmp_sch_runtime_simd = 47, /**< runtime with chunk adjustment */\n\n  /* accessible only through KMP_SCHEDULE environment variable */\n  kmp_sch_upper, /**< upper bound for unordered values */\n\n  kmp_ord_lower = 64, /**< lower bound for ordered values, must be power of 2 */\n  kmp_ord_static_chunked = 65,\n  kmp_ord_static = 66, /**< ordered static unspecialized */\n  kmp_ord_dynamic_chunked = 67,\n  kmp_ord_guided_chunked = 68,\n  kmp_ord_runtime = 69,\n  kmp_ord_auto = 70, /**< ordered auto */\n  kmp_ord_trapezoidal = 71,\n  kmp_ord_upper, /**< upper bound for ordered values */\n\n  /* Schedules for Distribute construct */\n  kmp_distribute_static_chunked = 91, /**< distribute static chunked */\n  kmp_distribute_static = 92, /**< distribute static unspecialized */\n\n  /* For the \"nomerge\" versions, kmp_dispatch_next*() will always return a\n     single iteration/chunk, even if the loop is serialized. For the schedule\n     types listed above, the entire iteration vector is returned if the loop is\n     serialized. This doesn't work for gcc/gcomp sections. */\n  kmp_nm_lower = 160, /**< lower bound for nomerge values */\n\n  kmp_nm_static_chunked =\n      (kmp_sch_static_chunked - kmp_sch_lower + kmp_nm_lower),\n  kmp_nm_static = 162, /**< static unspecialized */\n  kmp_nm_dynamic_chunked = 163,\n  kmp_nm_guided_chunked = 164, /**< guided unspecialized */\n  kmp_nm_runtime = 165,\n  kmp_nm_auto = 166, /**< auto */\n  kmp_nm_trapezoidal = 167,\n\n  /* accessible only through KMP_SCHEDULE environment variable */\n  kmp_nm_static_greedy = 168,\n  kmp_nm_static_balanced = 169,\n  /* accessible only through KMP_SCHEDULE environment variable */\n  kmp_nm_guided_iterative_chunked = 170,\n  kmp_nm_guided_analytical_chunked = 171,\n  kmp_nm_static_steal =\n      172, /* accessible only through OMP_SCHEDULE environment variable */\n\n  kmp_nm_ord_static_chunked = 193,\n  kmp_nm_ord_static = 194, /**< ordered static unspecialized */\n  kmp_nm_ord_dynamic_chunked = 195,\n  kmp_nm_ord_guided_chunked = 196,\n  kmp_nm_ord_runtime = 197,\n  kmp_nm_ord_auto = 198, /**< auto */\n  kmp_nm_ord_trapezoidal = 199,\n  kmp_nm_upper, /**< upper bound for nomerge values */\n\n  /* Support for OpenMP 4.5 monotonic and nonmonotonic schedule modifiers. Since\n     we need to distinguish the three possible cases (no modifier, monotonic\n     modifier, nonmonotonic modifier), we need separate bits for each modifier.\n     The absence of monotonic does not imply nonmonotonic, especially since 4.5\n     says that the behaviour of the \"no modifier\" case is implementation defined\n     in 4.5, but will become \"nonmonotonic\" in 5.0.\n\n     Since we're passing a full 32 bit value, we can use a couple of high bits\n     for these flags; out of paranoia we avoid the sign bit.\n\n     These modifiers can be or-ed into non-static schedules by the compiler to\n     pass the additional information. They will be stripped early in the\n     processing in __kmp_dispatch_init when setting up schedules, so most of the\n     code won't ever see schedules with these bits set.  */\n  kmp_sch_modifier_monotonic =\n      (1 << 29), /**< Set if the monotonic schedule modifier was present */\n  kmp_sch_modifier_nonmonotonic =\n      (1 << 30), /**< Set if the nonmonotonic schedule modifier was present */\n\n#define SCHEDULE_WITHOUT_MODIFIERS(s)                                          \\\n  (enum sched_type)(                                                           \\\n      (s) & ~(kmp_sch_modifier_nonmonotonic | kmp_sch_modifier_monotonic))\n#define SCHEDULE_HAS_MONOTONIC(s) (((s)&kmp_sch_modifier_monotonic) != 0)\n#define SCHEDULE_HAS_NONMONOTONIC(s) (((s)&kmp_sch_modifier_nonmonotonic) != 0)\n#define SCHEDULE_HAS_NO_MODIFIERS(s)                                           \\\n  (((s) & (kmp_sch_modifier_nonmonotonic | kmp_sch_modifier_monotonic)) == 0)\n#define SCHEDULE_GET_MODIFIERS(s)                                              \\\n  ((enum sched_type)(                                                          \\\n      (s) & (kmp_sch_modifier_nonmonotonic | kmp_sch_modifier_monotonic)))\n#define SCHEDULE_SET_MODIFIERS(s, m)                                           \\\n  (s = (enum sched_type)((kmp_int32)s | (kmp_int32)m))\n#define SCHEDULE_NONMONOTONIC 0\n#define SCHEDULE_MONOTONIC 1\n\n  kmp_sch_default = kmp_sch_static /**< default scheduling algorithm */\n};\n\n// Apply modifiers on internal kind to standard kind\nstatic inline void\n__kmp_sched_apply_mods_stdkind(kmp_sched_t *kind,\n                               enum sched_type internal_kind) {\n  if (SCHEDULE_HAS_MONOTONIC(internal_kind)) {\n    *kind = (kmp_sched_t)((int)*kind | (int)kmp_sched_monotonic);\n  }\n}\n\n// Apply modifiers on standard kind to internal kind\nstatic inline void\n__kmp_sched_apply_mods_intkind(kmp_sched_t kind,\n                               enum sched_type *internal_kind) {\n  if ((int)kind & (int)kmp_sched_monotonic) {\n    *internal_kind = (enum sched_type)((int)*internal_kind |\n                                       (int)kmp_sch_modifier_monotonic);\n  }\n}\n\n// Get standard schedule without modifiers\nstatic inline kmp_sched_t __kmp_sched_without_mods(kmp_sched_t kind) {\n  return (kmp_sched_t)((int)kind & ~((int)kmp_sched_monotonic));\n}\n\n/* Type to keep runtime schedule set via OMP_SCHEDULE or omp_set_schedule() */\ntypedef union kmp_r_sched {\n  struct {\n    enum sched_type r_sched_type;\n    int chunk;\n  };\n  kmp_int64 sched;\n} kmp_r_sched_t;\n\nextern enum sched_type __kmp_sch_map[]; // map OMP 3.0 schedule types with our\n// internal schedule types\n\nenum library_type {\n  library_none,\n  library_serial,\n  library_turnaround,\n  library_throughput\n};\n\n#if KMP_OS_LINUX\nenum clock_function_type {\n  clock_function_gettimeofday,\n  clock_function_clock_gettime\n};\n#endif /* KMP_OS_LINUX */\n\n#if KMP_MIC_SUPPORTED\nenum mic_type { non_mic, mic1, mic2, mic3, dummy };\n#endif\n\n/* -- fast reduction stuff ------------------------------------------------ */\n\n#undef KMP_FAST_REDUCTION_BARRIER\n#define KMP_FAST_REDUCTION_BARRIER 1\n\n#undef KMP_FAST_REDUCTION_CORE_DUO\n#if KMP_ARCH_X86 || KMP_ARCH_X86_64\n#define KMP_FAST_REDUCTION_CORE_DUO 1\n#endif\n\nenum _reduction_method {\n  reduction_method_not_defined = 0,\n  critical_reduce_block = (1 << 8),\n  atomic_reduce_block = (2 << 8),\n  tree_reduce_block = (3 << 8),\n  empty_reduce_block = (4 << 8)\n};\n\n// Description of the packed_reduction_method variable:\n// The packed_reduction_method variable consists of two enum types variables\n// that are packed together into 0-th byte and 1-st byte:\n// 0: (packed_reduction_method & 0x000000FF) is a 'enum barrier_type' value of\n// barrier that will be used in fast reduction: bs_plain_barrier or\n// bs_reduction_barrier\n// 1: (packed_reduction_method & 0x0000FF00) is a reduction method that will\n// be used in fast reduction;\n// Reduction method is of 'enum _reduction_method' type and it's defined the way\n// so that the bits of 0-th byte are empty, so no need to execute a shift\n// instruction while packing/unpacking\n\n#if KMP_FAST_REDUCTION_BARRIER\n#define PACK_REDUCTION_METHOD_AND_BARRIER(reduction_method, barrier_type)      \\\n  ((reduction_method) | (barrier_type))\n\n#define UNPACK_REDUCTION_METHOD(packed_reduction_method)                       \\\n  ((enum _reduction_method)((packed_reduction_method) & (0x0000FF00)))\n\n#define UNPACK_REDUCTION_BARRIER(packed_reduction_method)                      \\\n  ((enum barrier_type)((packed_reduction_method) & (0x000000FF)))\n#else\n#define PACK_REDUCTION_METHOD_AND_BARRIER(reduction_method, barrier_type)      \\\n  (reduction_method)\n\n#define UNPACK_REDUCTION_METHOD(packed_reduction_method)                       \\\n  (packed_reduction_method)\n\n#define UNPACK_REDUCTION_BARRIER(packed_reduction_method) (bs_plain_barrier)\n#endif\n\n#define TEST_REDUCTION_METHOD(packed_reduction_method, which_reduction_block)  \\\n  ((UNPACK_REDUCTION_METHOD(packed_reduction_method)) ==                       \\\n   (which_reduction_block))\n\n#if KMP_FAST_REDUCTION_BARRIER\n#define TREE_REDUCE_BLOCK_WITH_REDUCTION_BARRIER                               \\\n  (PACK_REDUCTION_METHOD_AND_BARRIER(tree_reduce_block, bs_reduction_barrier))\n\n#define TREE_REDUCE_BLOCK_WITH_PLAIN_BARRIER                                   \\\n  (PACK_REDUCTION_METHOD_AND_BARRIER(tree_reduce_block, bs_plain_barrier))\n#endif\n\ntypedef int PACKED_REDUCTION_METHOD_T;\n\n/* -- end of fast reduction stuff ----------------------------------------- */\n\n#if KMP_OS_WINDOWS\n#define USE_CBLKDATA\n#if KMP_MSVC_COMPAT\n#pragma warning(push)\n#pragma warning(disable : 271 310)\n#endif\n#include <windows.h>\n#if KMP_MSVC_COMPAT\n#pragma warning(pop)\n#endif\n#endif\n\n#if KMP_OS_UNIX\n#include <dlfcn.h>\n#include <pthread.h>\n#endif\n\nenum kmp_hw_t : int {\n  KMP_HW_UNKNOWN = -1,\n  KMP_HW_MACHINE = 0,\n  KMP_HW_SOCKET,\n  KMP_HW_PROC_GROUP,\n  KMP_HW_NUMA,\n  KMP_HW_DIE,\n  KMP_HW_L3,\n  KMP_HW_TILE,\n  KMP_HW_MODULE,\n  KMP_HW_L2,\n  KMP_HW_L1,\n  KMP_HW_CORE,\n  KMP_HW_THREAD,\n  KMP_HW_LAST\n};\n\n#define KMP_ASSERT_VALID_HW_TYPE(type)                                         \\\n  KMP_DEBUG_ASSERT(type >= (kmp_hw_t)0 && type < KMP_HW_LAST)\n\n#define KMP_FOREACH_HW_TYPE(type)                                              \\\n  for (kmp_hw_t type = (kmp_hw_t)0; type < KMP_HW_LAST;                        \\\n       type = (kmp_hw_t)((int)type + 1))\n\nconst char *__kmp_hw_get_catalog_string(kmp_hw_t type, bool plural = false);\n\n/* Only Linux* OS and Windows* OS support thread affinity. */\n#if KMP_AFFINITY_SUPPORTED\n\n// GROUP_AFFINITY is already defined for _MSC_VER>=1600 (VS2010 and later).\n#if KMP_OS_WINDOWS\n#if _MSC_VER < 1600 && KMP_MSVC_COMPAT\ntypedef struct GROUP_AFFINITY {\n  KAFFINITY Mask;\n  WORD Group;\n  WORD Reserved[3];\n} GROUP_AFFINITY;\n#endif /* _MSC_VER < 1600 */\n#if KMP_GROUP_AFFINITY\nextern int __kmp_num_proc_groups;\n#else\nstatic const int __kmp_num_proc_groups = 1;\n#endif /* KMP_GROUP_AFFINITY */\ntypedef DWORD (*kmp_GetActiveProcessorCount_t)(WORD);\nextern kmp_GetActiveProcessorCount_t __kmp_GetActiveProcessorCount;\n\ntypedef WORD (*kmp_GetActiveProcessorGroupCount_t)(void);\nextern kmp_GetActiveProcessorGroupCount_t __kmp_GetActiveProcessorGroupCount;\n\ntypedef BOOL (*kmp_GetThreadGroupAffinity_t)(HANDLE, GROUP_AFFINITY *);\nextern kmp_GetThreadGroupAffinity_t __kmp_GetThreadGroupAffinity;\n\ntypedef BOOL (*kmp_SetThreadGroupAffinity_t)(HANDLE, const GROUP_AFFINITY *,\n                                             GROUP_AFFINITY *);\nextern kmp_SetThreadGroupAffinity_t __kmp_SetThreadGroupAffinity;\n#endif /* KMP_OS_WINDOWS */\n\n#if KMP_USE_HWLOC\nextern hwloc_topology_t __kmp_hwloc_topology;\nextern int __kmp_hwloc_error;\nextern int __kmp_numa_detected;\nextern int __kmp_tile_depth;\n#endif\n\nextern size_t __kmp_affin_mask_size;\n#define KMP_AFFINITY_CAPABLE() (__kmp_affin_mask_size > 0)\n#define KMP_AFFINITY_DISABLE() (__kmp_affin_mask_size = 0)\n#define KMP_AFFINITY_ENABLE(mask_size) (__kmp_affin_mask_size = mask_size)\n#define KMP_CPU_SET_ITERATE(i, mask)                                           \\\n  for (i = (mask)->begin(); (int)i != (mask)->end(); i = (mask)->next(i))\n#define KMP_CPU_SET(i, mask) (mask)->set(i)\n#define KMP_CPU_ISSET(i, mask) (mask)->is_set(i)\n#define KMP_CPU_CLR(i, mask) (mask)->clear(i)\n#define KMP_CPU_ZERO(mask) (mask)->zero()\n#define KMP_CPU_COPY(dest, src) (dest)->copy(src)\n#define KMP_CPU_AND(dest, src) (dest)->bitwise_and(src)\n#define KMP_CPU_COMPLEMENT(max_bit_number, mask) (mask)->bitwise_not()\n#define KMP_CPU_UNION(dest, src) (dest)->bitwise_or(src)\n#define KMP_CPU_ALLOC(ptr) (ptr = __kmp_affinity_dispatch->allocate_mask())\n#define KMP_CPU_FREE(ptr) __kmp_affinity_dispatch->deallocate_mask(ptr)\n#define KMP_CPU_ALLOC_ON_STACK(ptr) KMP_CPU_ALLOC(ptr)\n#define KMP_CPU_FREE_FROM_STACK(ptr) KMP_CPU_FREE(ptr)\n#define KMP_CPU_INTERNAL_ALLOC(ptr) KMP_CPU_ALLOC(ptr)\n#define KMP_CPU_INTERNAL_FREE(ptr) KMP_CPU_FREE(ptr)\n#define KMP_CPU_INDEX(arr, i) __kmp_affinity_dispatch->index_mask_array(arr, i)\n#define KMP_CPU_ALLOC_ARRAY(arr, n)                                            \\\n  (arr = __kmp_affinity_dispatch->allocate_mask_array(n))\n#define KMP_CPU_FREE_ARRAY(arr, n)                                             \\\n  __kmp_affinity_dispatch->deallocate_mask_array(arr)\n#define KMP_CPU_INTERNAL_ALLOC_ARRAY(arr, n) KMP_CPU_ALLOC_ARRAY(arr, n)\n#define KMP_CPU_INTERNAL_FREE_ARRAY(arr, n) KMP_CPU_FREE_ARRAY(arr, n)\n#define __kmp_get_system_affinity(mask, abort_bool)                            \\\n  (mask)->get_system_affinity(abort_bool)\n#define __kmp_set_system_affinity(mask, abort_bool)                            \\\n  (mask)->set_system_affinity(abort_bool)\n#define __kmp_get_proc_group(mask) (mask)->get_proc_group()\n\nclass KMPAffinity {\npublic:\n  class Mask {\n  public:\n    void *operator new(size_t n);\n    void operator delete(void *p);\n    void *operator new[](size_t n);\n    void operator delete[](void *p);\n    virtual ~Mask() {}\n    // Set bit i to 1\n    virtual void set(int i) {}\n    // Return bit i\n    virtual bool is_set(int i) const { return false; }\n    // Set bit i to 0\n    virtual void clear(int i) {}\n    // Zero out entire mask\n    virtual void zero() {}\n    // Copy src into this mask\n    virtual void copy(const Mask *src) {}\n    // this &= rhs\n    virtual void bitwise_and(const Mask *rhs) {}\n    // this |= rhs\n    virtual void bitwise_or(const Mask *rhs) {}\n    // this = ~this\n    virtual void bitwise_not() {}\n    // API for iterating over an affinity mask\n    // for (int i = mask->begin(); i != mask->end(); i = mask->next(i))\n    virtual int begin() const { return 0; }\n    virtual int end() const { return 0; }\n    virtual int next(int previous) const { return 0; }\n#if KMP_OS_WINDOWS\n    virtual int set_process_affinity(bool abort_on_error) const { return -1; }\n#endif\n    // Set the system's affinity to this affinity mask's value\n    virtual int set_system_affinity(bool abort_on_error) const { return -1; }\n    // Set this affinity mask to the current system affinity\n    virtual int get_system_affinity(bool abort_on_error) { return -1; }\n    // Only 1 DWORD in the mask should have any procs set.\n    // Return the appropriate index, or -1 for an invalid mask.\n    virtual int get_proc_group() const { return -1; }\n  };\n  void *operator new(size_t n);\n  void operator delete(void *p);\n  // Need virtual destructor\n  virtual ~KMPAffinity() = default;\n  // Determine if affinity is capable\n  virtual void determine_capable(const char *env_var) {}\n  // Bind the current thread to os proc\n  virtual void bind_thread(int proc) {}\n  // Factory functions to allocate/deallocate a mask\n  virtual Mask *allocate_mask() { return nullptr; }\n  virtual void deallocate_mask(Mask *m) {}\n  virtual Mask *allocate_mask_array(int num) { return nullptr; }\n  virtual void deallocate_mask_array(Mask *m) {}\n  virtual Mask *index_mask_array(Mask *m, int index) { return nullptr; }\n  static void pick_api();\n  static void destroy_api();\n  enum api_type {\n    NATIVE_OS\n#if KMP_USE_HWLOC\n    ,\n    HWLOC\n#endif\n  };\n  virtual api_type get_api_type() const {\n    KMP_ASSERT(0);\n    return NATIVE_OS;\n  }\n\nprivate:\n  static bool picked_api;\n};\n\ntypedef KMPAffinity::Mask kmp_affin_mask_t;\nextern KMPAffinity *__kmp_affinity_dispatch;\n\n// Declare local char buffers with this size for printing debug and info\n// messages, using __kmp_affinity_print_mask().\n#define KMP_AFFIN_MASK_PRINT_LEN 1024\n\nenum affinity_type {\n  affinity_none = 0,\n  affinity_physical,\n  affinity_logical,\n  affinity_compact,\n  affinity_scatter,\n  affinity_explicit,\n  affinity_balanced,\n  affinity_disabled, // not used outsize the env var parser\n  affinity_default\n};\n\nenum affinity_gran {\n  affinity_gran_fine = 0,\n  affinity_gran_thread,\n  affinity_gran_core,\n  affinity_gran_tile,\n  affinity_gran_die,\n  affinity_gran_numa,\n  affinity_gran_package,\n  affinity_gran_node,\n#if KMP_GROUP_AFFINITY\n  // The \"group\" granularity isn't necesssarily coarser than all of the\n  // other levels, but we put it last in the enum.\n  affinity_gran_group,\n#endif /* KMP_GROUP_AFFINITY */\n  affinity_gran_default\n};\n\nenum affinity_top_method {\n  affinity_top_method_all = 0, // try all (supported) methods, in order\n#if KMP_ARCH_X86 || KMP_ARCH_X86_64\n  affinity_top_method_apicid,\n  affinity_top_method_x2apicid,\n  affinity_top_method_x2apicid_1f,\n#endif /* KMP_ARCH_X86 || KMP_ARCH_X86_64 */\n  affinity_top_method_cpuinfo, // KMP_CPUINFO_FILE is usable on Windows* OS, too\n#if KMP_GROUP_AFFINITY\n  affinity_top_method_group,\n#endif /* KMP_GROUP_AFFINITY */\n  affinity_top_method_flat,\n#if KMP_USE_HWLOC\n  affinity_top_method_hwloc,\n#endif\n  affinity_top_method_default\n};\n\n#define affinity_respect_mask_default (-1)\n\nextern enum affinity_type __kmp_affinity_type; /* Affinity type */\nextern enum affinity_gran __kmp_affinity_gran; /* Affinity granularity */\nextern int __kmp_affinity_gran_levels; /* corresponding int value */\nextern int __kmp_affinity_dups; /* Affinity duplicate masks */\nextern enum affinity_top_method __kmp_affinity_top_method;\nextern int __kmp_affinity_compact; /* Affinity 'compact' value */\nextern int __kmp_affinity_offset; /* Affinity offset value  */\nextern int __kmp_affinity_verbose; /* Was verbose specified for KMP_AFFINITY? */\nextern int __kmp_affinity_warnings; /* KMP_AFFINITY warnings enabled ? */\nextern int __kmp_affinity_respect_mask; // Respect process' init affinity mask?\nextern char *__kmp_affinity_proclist; /* proc ID list */\nextern kmp_affin_mask_t *__kmp_affinity_masks;\nextern unsigned __kmp_affinity_num_masks;\nextern void __kmp_affinity_bind_thread(int which);\n\nextern kmp_affin_mask_t *__kmp_affin_fullMask;\nextern char *__kmp_cpuinfo_file;\n\n#endif /* KMP_AFFINITY_SUPPORTED */\n\n// This needs to be kept in sync with the values in omp.h !!!\ntypedef enum kmp_proc_bind_t {\n  proc_bind_false = 0,\n  proc_bind_true,\n  proc_bind_primary,\n  proc_bind_close,\n  proc_bind_spread,\n  proc_bind_intel, // use KMP_AFFINITY interface\n  proc_bind_default\n} kmp_proc_bind_t;\n\ntypedef struct kmp_nested_proc_bind_t {\n  kmp_proc_bind_t *bind_types;\n  int size;\n  int used;\n} kmp_nested_proc_bind_t;\n\nextern kmp_nested_proc_bind_t __kmp_nested_proc_bind;\n\nextern int __kmp_display_affinity;\nextern char *__kmp_affinity_format;\nstatic const size_t KMP_AFFINITY_FORMAT_SIZE = 512;\n\n#if KMP_AFFINITY_SUPPORTED\n#define KMP_PLACE_ALL (-1)\n#define KMP_PLACE_UNDEFINED (-2)\n// Is KMP_AFFINITY is being used instead of OMP_PROC_BIND/OMP_PLACES?\n#define KMP_AFFINITY_NON_PROC_BIND                                             \\\n  ((__kmp_nested_proc_bind.bind_types[0] == proc_bind_false ||                 \\\n    __kmp_nested_proc_bind.bind_types[0] == proc_bind_intel) &&                \\\n   (__kmp_affinity_num_masks > 0 || __kmp_affinity_type == affinity_balanced))\n#endif /* KMP_AFFINITY_SUPPORTED */\n\nextern int __kmp_affinity_num_places;\n\ntypedef enum kmp_cancel_kind_t {\n  cancel_noreq = 0,\n  cancel_parallel = 1,\n  cancel_loop = 2,\n  cancel_sections = 3,\n  cancel_taskgroup = 4\n} kmp_cancel_kind_t;\n\n// KMP_HW_SUBSET support:\ntypedef struct kmp_hws_item {\n  int num;\n  int offset;\n} kmp_hws_item_t;\n\nextern kmp_hws_item_t __kmp_hws_socket;\nextern kmp_hws_item_t __kmp_hws_die;\nextern kmp_hws_item_t __kmp_hws_node;\nextern kmp_hws_item_t __kmp_hws_tile;\nextern kmp_hws_item_t __kmp_hws_core;\nextern kmp_hws_item_t __kmp_hws_proc;\nextern int __kmp_hws_requested;\nextern int __kmp_hws_abs_flag; // absolute or per-item number requested\n\n/* ------------------------------------------------------------------------ */\n\n#define KMP_PAD(type, sz)                                                      \\\n  (sizeof(type) + (sz - ((sizeof(type) - 1) % (sz)) - 1))\n\n// We need to avoid using -1 as a GTID as +1 is added to the gtid\n// when storing it in a lock, and the value 0 is reserved.\n#define KMP_GTID_DNE (-2) /* Does not exist */\n#define KMP_GTID_SHUTDOWN (-3) /* Library is shutting down */\n#define KMP_GTID_MONITOR (-4) /* Monitor thread ID */\n#define KMP_GTID_UNKNOWN (-5) /* Is not known */\n#define KMP_GTID_MIN (-6) /* Minimal gtid for low bound check in DEBUG */\n\n/* OpenMP 5.0 Memory Management support */\n\n#ifndef __OMP_H\n// Duplicate type definitions from omp.h\ntypedef uintptr_t omp_uintptr_t;\n\ntypedef enum {\n  omp_atk_sync_hint = 1,\n  omp_atk_alignment = 2,\n  omp_atk_access = 3,\n  omp_atk_pool_size = 4,\n  omp_atk_fallback = 5,\n  omp_atk_fb_data = 6,\n  omp_atk_pinned = 7,\n  omp_atk_partition = 8\n} omp_alloctrait_key_t;\n\ntypedef enum {\n  omp_atv_false = 0,\n  omp_atv_true = 1,\n  omp_atv_contended = 3,\n  omp_atv_uncontended = 4,\n  omp_atv_serialized = 5,\n  omp_atv_sequential = omp_atv_serialized, // (deprecated)\n  omp_atv_private = 6,\n  omp_atv_all = 7,\n  omp_atv_thread = 8,\n  omp_atv_pteam = 9,\n  omp_atv_cgroup = 10,\n  omp_atv_default_mem_fb = 11,\n  omp_atv_null_fb = 12,\n  omp_atv_abort_fb = 13,\n  omp_atv_allocator_fb = 14,\n  omp_atv_environment = 15,\n  omp_atv_nearest = 16,\n  omp_atv_blocked = 17,\n  omp_atv_interleaved = 18\n} omp_alloctrait_value_t;\n#define omp_atv_default ((omp_uintptr_t)-1)\n\ntypedef void *omp_memspace_handle_t;\nextern omp_memspace_handle_t const omp_default_mem_space;\nextern omp_memspace_handle_t const omp_large_cap_mem_space;\nextern omp_memspace_handle_t const omp_const_mem_space;\nextern omp_memspace_handle_t const omp_high_bw_mem_space;\nextern omp_memspace_handle_t const omp_low_lat_mem_space;\n// Preview of target memory support\nextern omp_memspace_handle_t const llvm_omp_target_host_mem_space;\nextern omp_memspace_handle_t const llvm_omp_target_shared_mem_space;\nextern omp_memspace_handle_t const llvm_omp_target_device_mem_space;\n\ntypedef struct {\n  omp_alloctrait_key_t key;\n  omp_uintptr_t value;\n} omp_alloctrait_t;\n\ntypedef void *omp_allocator_handle_t;\nextern omp_allocator_handle_t const omp_null_allocator;\nextern omp_allocator_handle_t const omp_default_mem_alloc;\nextern omp_allocator_handle_t const omp_large_cap_mem_alloc;\nextern omp_allocator_handle_t const omp_const_mem_alloc;\nextern omp_allocator_handle_t const omp_high_bw_mem_alloc;\nextern omp_allocator_handle_t const omp_low_lat_mem_alloc;\nextern omp_allocator_handle_t const omp_cgroup_mem_alloc;\nextern omp_allocator_handle_t const omp_pteam_mem_alloc;\nextern omp_allocator_handle_t const omp_thread_mem_alloc;\n// Preview of target memory support\nextern omp_allocator_handle_t const llvm_omp_target_host_mem_alloc;\nextern omp_allocator_handle_t const llvm_omp_target_shared_mem_alloc;\nextern omp_allocator_handle_t const llvm_omp_target_device_mem_alloc;\nextern omp_allocator_handle_t const kmp_max_mem_alloc;\nextern omp_allocator_handle_t __kmp_def_allocator;\n\n// end of duplicate type definitions from omp.h\n#endif\n\nextern int __kmp_memkind_available;\n\ntypedef omp_memspace_handle_t kmp_memspace_t; // placeholder\n\ntypedef struct kmp_allocator_t {\n  omp_memspace_handle_t memspace;\n  void **memkind; // pointer to memkind\n  int alignment;\n  omp_alloctrait_value_t fb;\n  kmp_allocator_t *fb_data;\n  kmp_uint64 pool_size;\n  kmp_uint64 pool_used;\n} kmp_allocator_t;\n\nextern omp_allocator_handle_t __kmpc_init_allocator(int gtid,\n                                                    omp_memspace_handle_t,\n                                                    int ntraits,\n                                                    omp_alloctrait_t traits[]);\nextern void __kmpc_destroy_allocator(int gtid, omp_allocator_handle_t al);\nextern void __kmpc_set_default_allocator(int gtid, omp_allocator_handle_t al);\nextern omp_allocator_handle_t __kmpc_get_default_allocator(int gtid);\nextern void *__kmpc_alloc(int gtid, size_t sz, omp_allocator_handle_t al);\nextern void *__kmpc_calloc(int gtid, size_t nmemb, size_t sz,\n                           omp_allocator_handle_t al);\nextern void *__kmpc_realloc(int gtid, void *ptr, size_t sz,\n                            omp_allocator_handle_t al,\n                            omp_allocator_handle_t free_al);\nextern void __kmpc_free(int gtid, void *ptr, omp_allocator_handle_t al);\n\nextern void __kmp_init_memkind();\nextern void __kmp_fini_memkind();\nextern void __kmp_init_target_mem();\n\n/* ------------------------------------------------------------------------ */\n\n#define KMP_UINT64_MAX                                                         \\\n  (~((kmp_uint64)1 << ((sizeof(kmp_uint64) * (1 << 3)) - 1)))\n\n#define KMP_MIN_NTH 1\n\n#ifndef KMP_MAX_NTH\n#if defined(PTHREAD_THREADS_MAX) && PTHREAD_THREADS_MAX < INT_MAX\n#define KMP_MAX_NTH PTHREAD_THREADS_MAX\n#else\n#define KMP_MAX_NTH INT_MAX\n#endif\n#endif /* KMP_MAX_NTH */\n\n#ifdef PTHREAD_STACK_MIN\n#define KMP_MIN_STKSIZE PTHREAD_STACK_MIN\n#else\n#define KMP_MIN_STKSIZE ((size_t)(32 * 1024))\n#endif\n\n#define KMP_MAX_STKSIZE (~((size_t)1 << ((sizeof(size_t) * (1 << 3)) - 1)))\n\n#if KMP_ARCH_X86\n#define KMP_DEFAULT_STKSIZE ((size_t)(2 * 1024 * 1024))\n#elif KMP_ARCH_X86_64\n#define KMP_DEFAULT_STKSIZE ((size_t)(4 * 1024 * 1024))\n#define KMP_BACKUP_STKSIZE ((size_t)(2 * 1024 * 1024))\n#else\n#define KMP_DEFAULT_STKSIZE ((size_t)(1024 * 1024))\n#endif\n\n#define KMP_DEFAULT_MALLOC_POOL_INCR ((size_t)(1024 * 1024))\n#define KMP_MIN_MALLOC_POOL_INCR ((size_t)(4 * 1024))\n#define KMP_MAX_MALLOC_POOL_INCR                                               \\\n  (~((size_t)1 << ((sizeof(size_t) * (1 << 3)) - 1)))\n\n#define KMP_MIN_STKOFFSET (0)\n#define KMP_MAX_STKOFFSET KMP_MAX_STKSIZE\n#if KMP_OS_DARWIN\n#define KMP_DEFAULT_STKOFFSET KMP_MIN_STKOFFSET\n#else\n#define KMP_DEFAULT_STKOFFSET CACHE_LINE\n#endif\n\n#define KMP_MIN_STKPADDING (0)\n#define KMP_MAX_STKPADDING (2 * 1024 * 1024)\n\n#define KMP_BLOCKTIME_MULTIPLIER                                               \\\n  (1000) /* number of blocktime units per second */\n#define KMP_MIN_BLOCKTIME (0)\n#define KMP_MAX_BLOCKTIME                                                      \\\n  (INT_MAX) /* Must be this for \"infinite\" setting the work */\n#define KMP_DEFAULT_BLOCKTIME (200) /*  __kmp_blocktime is in milliseconds  */\n\n#if KMP_USE_MONITOR\n#define KMP_DEFAULT_MONITOR_STKSIZE ((size_t)(64 * 1024))\n#define KMP_MIN_MONITOR_WAKEUPS (1) // min times monitor wakes up per second\n#define KMP_MAX_MONITOR_WAKEUPS (1000) // max times monitor can wake up per sec\n\n/* Calculate new number of monitor wakeups for a specific block time based on\n   previous monitor_wakeups. Only allow increasing number of wakeups */\n#define KMP_WAKEUPS_FROM_BLOCKTIME(blocktime, monitor_wakeups)                 \\\n  (((blocktime) == KMP_MAX_BLOCKTIME)   ? (monitor_wakeups)                    \\\n   : ((blocktime) == KMP_MIN_BLOCKTIME) ? KMP_MAX_MONITOR_WAKEUPS              \\\n   : ((monitor_wakeups) > (KMP_BLOCKTIME_MULTIPLIER / (blocktime)))            \\\n       ? (monitor_wakeups)                                                     \\\n       : (KMP_BLOCKTIME_MULTIPLIER) / (blocktime))\n\n/* Calculate number of intervals for a specific block time based on\n   monitor_wakeups */\n#define KMP_INTERVALS_FROM_BLOCKTIME(blocktime, monitor_wakeups)               \\\n  (((blocktime) + (KMP_BLOCKTIME_MULTIPLIER / (monitor_wakeups)) - 1) /        \\\n   (KMP_BLOCKTIME_MULTIPLIER / (monitor_wakeups)))\n#else\n#define KMP_BLOCKTIME(team, tid)                                               \\\n  (get__bt_set(team, tid) ? get__blocktime(team, tid) : __kmp_dflt_blocktime)\n#if KMP_OS_UNIX && (KMP_ARCH_X86 || KMP_ARCH_X86_64)\n// HW TSC is used to reduce overhead (clock tick instead of nanosecond).\nextern kmp_uint64 __kmp_ticks_per_msec;\n#if KMP_COMPILER_ICC\n#define KMP_NOW() ((kmp_uint64)_rdtsc())\n#else\n#define KMP_NOW() __kmp_hardware_timestamp()\n#endif\n#define KMP_NOW_MSEC() (KMP_NOW() / __kmp_ticks_per_msec)\n#define KMP_BLOCKTIME_INTERVAL(team, tid)                                      \\\n  (KMP_BLOCKTIME(team, tid) * __kmp_ticks_per_msec)\n#define KMP_BLOCKING(goal, count) ((goal) > KMP_NOW())\n#else\n// System time is retrieved sporadically while blocking.\nextern kmp_uint64 __kmp_now_nsec();\n#define KMP_NOW() __kmp_now_nsec()\n#define KMP_NOW_MSEC() (KMP_NOW() / KMP_USEC_PER_SEC)\n#define KMP_BLOCKTIME_INTERVAL(team, tid)                                      \\\n  (KMP_BLOCKTIME(team, tid) * KMP_USEC_PER_SEC)\n#define KMP_BLOCKING(goal, count) ((count) % 1000 != 0 || (goal) > KMP_NOW())\n#endif\n#endif // KMP_USE_MONITOR\n\n#define KMP_MIN_STATSCOLS 40\n#define KMP_MAX_STATSCOLS 4096\n#define KMP_DEFAULT_STATSCOLS 80\n\n#define KMP_MIN_INTERVAL 0\n#define KMP_MAX_INTERVAL (INT_MAX - 1)\n#define KMP_DEFAULT_INTERVAL 0\n\n#define KMP_MIN_CHUNK 1\n#define KMP_MAX_CHUNK (INT_MAX - 1)\n#define KMP_DEFAULT_CHUNK 1\n\n#define KMP_MIN_DISP_NUM_BUFF 1\n#define KMP_DFLT_DISP_NUM_BUFF 7\n#define KMP_MAX_DISP_NUM_BUFF 4096\n\n#define KMP_MAX_ORDERED 8\n\n#define KMP_MAX_FIELDS 32\n\n#define KMP_MAX_BRANCH_BITS 31\n\n#define KMP_MAX_ACTIVE_LEVELS_LIMIT INT_MAX\n\n#define KMP_MAX_DEFAULT_DEVICE_LIMIT INT_MAX\n\n#define KMP_MAX_TASK_PRIORITY_LIMIT INT_MAX\n\n/* Minimum number of threads before switch to TLS gtid (experimentally\n   determined) */\n/* josh TODO: what about OS X* tuning? */\n#if KMP_ARCH_X86 || KMP_ARCH_X86_64\n#define KMP_TLS_GTID_MIN 5\n#else\n#define KMP_TLS_GTID_MIN INT_MAX\n#endif\n\n#define KMP_MASTER_TID(tid) (0 == (tid))\n#define KMP_WORKER_TID(tid) (0 != (tid))\n\n#define KMP_MASTER_GTID(gtid) (0 == __kmp_tid_from_gtid((gtid)))\n#define KMP_WORKER_GTID(gtid) (0 != __kmp_tid_from_gtid((gtid)))\n#define KMP_INITIAL_GTID(gtid) (0 == (gtid))\n\n#ifndef TRUE\n#define FALSE 0\n#define TRUE (!FALSE)\n#endif\n\n/* NOTE: all of the following constants must be even */\n\n#if KMP_OS_WINDOWS\n#define KMP_INIT_WAIT 64U /* initial number of spin-tests   */\n#define KMP_NEXT_WAIT 32U /* susequent number of spin-tests */\n#elif KMP_OS_LINUX\n#define KMP_INIT_WAIT 1024U /* initial number of spin-tests   */\n#define KMP_NEXT_WAIT 512U /* susequent number of spin-tests */\n#elif KMP_OS_DARWIN\n/* TODO: tune for KMP_OS_DARWIN */\n#define KMP_INIT_WAIT 1024U /* initial number of spin-tests   */\n#define KMP_NEXT_WAIT 512U /* susequent number of spin-tests */\n#elif KMP_OS_DRAGONFLY\n/* TODO: tune for KMP_OS_DRAGONFLY */\n#define KMP_INIT_WAIT 1024U /* initial number of spin-tests   */\n#define KMP_NEXT_WAIT 512U /* susequent number of spin-tests */\n#elif KMP_OS_FREEBSD\n/* TODO: tune for KMP_OS_FREEBSD */\n#define KMP_INIT_WAIT 1024U /* initial number of spin-tests   */\n#define KMP_NEXT_WAIT 512U /* susequent number of spin-tests */\n#elif KMP_OS_NETBSD\n/* TODO: tune for KMP_OS_NETBSD */\n#define KMP_INIT_WAIT 1024U /* initial number of spin-tests   */\n#define KMP_NEXT_WAIT 512U /* susequent number of spin-tests */\n#elif KMP_OS_HURD\n/* TODO: tune for KMP_OS_HURD */\n#define KMP_INIT_WAIT 1024U /* initial number of spin-tests   */\n#define KMP_NEXT_WAIT 512U /* susequent number of spin-tests */\n#elif KMP_OS_OPENBSD\n/* TODO: tune for KMP_OS_OPENBSD */\n#define KMP_INIT_WAIT 1024U /* initial number of spin-tests   */\n#define KMP_NEXT_WAIT 512U /* susequent number of spin-tests */\n#endif\n\n#if KMP_ARCH_X86 || KMP_ARCH_X86_64\ntypedef struct kmp_cpuid {\n  kmp_uint32 eax;\n  kmp_uint32 ebx;\n  kmp_uint32 ecx;\n  kmp_uint32 edx;\n} kmp_cpuid_t;\n\ntypedef struct kmp_cpuinfo {\n  int initialized; // If 0, other fields are not initialized.\n  int signature; // CPUID(1).EAX\n  int family; // CPUID(1).EAX[27:20]+CPUID(1).EAX[11:8] (Extended Family+Family)\n  int model; // ( CPUID(1).EAX[19:16] << 4 ) + CPUID(1).EAX[7:4] ( ( Extended\n  // Model << 4 ) + Model)\n  int stepping; // CPUID(1).EAX[3:0] ( Stepping )\n  int sse2; // 0 if SSE2 instructions are not supported, 1 otherwise.\n  int rtm; // 0 if RTM instructions are not supported, 1 otherwise.\n  int cpu_stackoffset;\n  int apic_id;\n  int physical_id;\n  int logical_id;\n  kmp_uint64 frequency; // Nominal CPU frequency in Hz.\n  char name[3 * sizeof(kmp_cpuid_t)]; // CPUID(0x80000002,0x80000003,0x80000004)\n} kmp_cpuinfo_t;\n\nextern void __kmp_query_cpuid(kmp_cpuinfo_t *p);\n\n#if KMP_OS_UNIX\n// subleaf is only needed for cache and topology discovery and can be set to\n// zero in most cases\nstatic inline void __kmp_x86_cpuid(int leaf, int subleaf, struct kmp_cpuid *p) {\n  __asm__ __volatile__(\"cpuid\"\n                       : \"=a\"(p->eax), \"=b\"(p->ebx), \"=c\"(p->ecx), \"=d\"(p->edx)\n                       : \"a\"(leaf), \"c\"(subleaf));\n}\n// Load p into FPU control word\nstatic inline void __kmp_load_x87_fpu_control_word(const kmp_int16 *p) {\n  __asm__ __volatile__(\"fldcw %0\" : : \"m\"(*p));\n}\n// Store FPU control word into p\nstatic inline void __kmp_store_x87_fpu_control_word(kmp_int16 *p) {\n  __asm__ __volatile__(\"fstcw %0\" : \"=m\"(*p));\n}\nstatic inline void __kmp_clear_x87_fpu_status_word() {\n#if KMP_MIC\n  // 32-bit protected mode x87 FPU state\n  struct x87_fpu_state {\n    unsigned cw;\n    unsigned sw;\n    unsigned tw;\n    unsigned fip;\n    unsigned fips;\n    unsigned fdp;\n    unsigned fds;\n  };\n  struct x87_fpu_state fpu_state = {0, 0, 0, 0, 0, 0, 0};\n  __asm__ __volatile__(\"fstenv %0\\n\\t\" // store FP env\n                       \"andw $0x7f00, %1\\n\\t\" // clear 0-7,15 bits of FP SW\n                       \"fldenv %0\\n\\t\" // load FP env back\n                       : \"+m\"(fpu_state), \"+m\"(fpu_state.sw));\n#else\n  __asm__ __volatile__(\"fnclex\");\n#endif // KMP_MIC\n}\n#if __SSE__\nstatic inline void __kmp_load_mxcsr(const kmp_uint32 *p) { _mm_setcsr(*p); }\nstatic inline void __kmp_store_mxcsr(kmp_uint32 *p) { *p = _mm_getcsr(); }\n#else\nstatic inline void __kmp_load_mxcsr(const kmp_uint32 *p) {}\nstatic inline void __kmp_store_mxcsr(kmp_uint32 *p) { *p = 0; }\n#endif\n#else\n// Windows still has these as external functions in assembly file\nextern void __kmp_x86_cpuid(int mode, int mode2, struct kmp_cpuid *p);\nextern void __kmp_load_x87_fpu_control_word(const kmp_int16 *p);\nextern void __kmp_store_x87_fpu_control_word(kmp_int16 *p);\nextern void __kmp_clear_x87_fpu_status_word();\nstatic inline void __kmp_load_mxcsr(const kmp_uint32 *p) { _mm_setcsr(*p); }\nstatic inline void __kmp_store_mxcsr(kmp_uint32 *p) { *p = _mm_getcsr(); }\n#endif // KMP_OS_UNIX\n\n#define KMP_X86_MXCSR_MASK 0xffffffc0 /* ignore status flags (6 lsb) */\n\n#if KMP_ARCH_X86\nextern void __kmp_x86_pause(void);\n#elif KMP_MIC\n// Performance testing on KNC (C0QS-7120 P/A/X/D, 61-core, 16 GB Memory) showed\n// regression after removal of extra PAUSE from spin loops. Changing\n// the delay from 100 to 300 showed even better performance than double PAUSE\n// on Spec OMP2001 and LCPC tasking tests, no regressions on EPCC.\nstatic inline void __kmp_x86_pause(void) { _mm_delay_32(300); }\n#else\nstatic inline void __kmp_x86_pause(void) { _mm_pause(); }\n#endif\n#define KMP_CPU_PAUSE() __kmp_x86_pause()\n#elif KMP_ARCH_PPC64\n#define KMP_PPC64_PRI_LOW() __asm__ volatile(\"or 1, 1, 1\")\n#define KMP_PPC64_PRI_MED() __asm__ volatile(\"or 2, 2, 2\")\n#define KMP_PPC64_PRI_LOC_MB() __asm__ volatile(\"\" : : : \"memory\")\n#define KMP_CPU_PAUSE()                                                        \\\n  do {                                                                         \\\n    KMP_PPC64_PRI_LOW();                                                       \\\n    KMP_PPC64_PRI_MED();                                                       \\\n    KMP_PPC64_PRI_LOC_MB();                                                    \\\n  } while (0)\n#else\n#define KMP_CPU_PAUSE() /* nothing to do */\n#endif\n\n#define KMP_INIT_YIELD(count)                                                  \\\n  { (count) = __kmp_yield_init; }\n\n#define KMP_OVERSUBSCRIBED                                                     \\\n  (TCR_4(__kmp_nth) > (__kmp_avail_proc ? __kmp_avail_proc : __kmp_xproc))\n\n#define KMP_TRY_YIELD                                                          \\\n  ((__kmp_use_yield == 1) || (__kmp_use_yield == 2 && (KMP_OVERSUBSCRIBED)))\n\n#define KMP_TRY_YIELD_OVERSUB                                                  \\\n  ((__kmp_use_yield == 1 || __kmp_use_yield == 2) && (KMP_OVERSUBSCRIBED))\n\n#define KMP_YIELD(cond)                                                        \\\n  {                                                                            \\\n    KMP_CPU_PAUSE();                                                           \\\n    if ((cond) && (KMP_TRY_YIELD))                                             \\\n      __kmp_yield();                                                           \\\n  }\n\n#define KMP_YIELD_OVERSUB()                                                    \\\n  {                                                                            \\\n    KMP_CPU_PAUSE();                                                           \\\n    if ((KMP_TRY_YIELD_OVERSUB))                                               \\\n      __kmp_yield();                                                           \\\n  }\n\n// Note the decrement of 2 in the following Macros. With KMP_LIBRARY=turnaround,\n// there should be no yielding since initial value from KMP_INIT_YIELD() is odd.\n#define KMP_YIELD_SPIN(count)                                                  \\\n  {                                                                            \\\n    KMP_CPU_PAUSE();                                                           \\\n    if (KMP_TRY_YIELD) {                                                       \\\n      (count) -= 2;                                                            \\\n      if (!(count)) {                                                          \\\n        __kmp_yield();                                                         \\\n        (count) = __kmp_yield_next;                                            \\\n      }                                                                        \\\n    }                                                                          \\\n  }\n\n#define KMP_YIELD_OVERSUB_ELSE_SPIN(count)                                     \\\n  {                                                                            \\\n    KMP_CPU_PAUSE();                                                           \\\n    if ((KMP_TRY_YIELD_OVERSUB))                                               \\\n      __kmp_yield();                                                           \\\n    else if (__kmp_use_yield == 1) {                                           \\\n      (count) -= 2;                                                            \\\n      if (!(count)) {                                                          \\\n        __kmp_yield();                                                         \\\n        (count) = __kmp_yield_next;                                            \\\n      }                                                                        \\\n    }                                                                          \\\n  }\n\n// User-level Monitor/Mwait\n#if KMP_HAVE_UMWAIT\n// We always try for UMWAIT first\n#if KMP_HAVE_WAITPKG_INTRINSICS\n#if KMP_HAVE_IMMINTRIN_H\n#include <immintrin.h>\n#elif KMP_HAVE_INTRIN_H\n#include <intrin.h>\n#endif\n#endif // KMP_HAVE_WAITPKG_INTRINSICS\nKMP_ATTRIBUTE_TARGET_WAITPKG\nstatic inline int __kmp_tpause(uint32_t hint, uint64_t counter) {\n#if !KMP_HAVE_WAITPKG_INTRINSICS\n  uint32_t timeHi = uint32_t(counter >> 32);\n  uint32_t timeLo = uint32_t(counter & 0xffffffff);\n  char flag;\n  __asm__ volatile(\"#tpause\\n.byte 0x66, 0x0F, 0xAE, 0xF1\\n\"\n                   \"setb   %0\"\n                   : \"=r\"(flag)\n                   : \"a\"(timeLo), \"d\"(timeHi), \"c\"(hint)\n                   :);\n  return flag;\n#else\n  return _tpause(hint, counter);\n#endif\n}\nKMP_ATTRIBUTE_TARGET_WAITPKG\nstatic inline void __kmp_umonitor(void *cacheline) {\n#if !KMP_HAVE_WAITPKG_INTRINSICS\n  __asm__ volatile(\"# umonitor\\n.byte 0xF3, 0x0F, 0xAE, 0x01 \"\n                   :\n                   : \"a\"(cacheline)\n                   :);\n#else\n  _umonitor(cacheline);\n#endif\n}\nKMP_ATTRIBUTE_TARGET_WAITPKG\nstatic inline int __kmp_umwait(uint32_t hint, uint64_t counter) {\n#if !KMP_HAVE_WAITPKG_INTRINSICS\n  uint32_t timeHi = uint32_t(counter >> 32);\n  uint32_t timeLo = uint32_t(counter & 0xffffffff);\n  char flag;\n  __asm__ volatile(\"#umwait\\n.byte 0xF2, 0x0F, 0xAE, 0xF1\\n\"\n                   \"setb   %0\"\n                   : \"=r\"(flag)\n                   : \"a\"(timeLo), \"d\"(timeHi), \"c\"(hint)\n                   :);\n  return flag;\n#else\n  return _umwait(hint, counter);\n#endif\n}\n#elif KMP_HAVE_MWAIT\n#if KMP_OS_UNIX\n#include <pmmintrin.h>\n#else\n#include <intrin.h>\n#endif\n#if KMP_OS_UNIX\n__attribute__((target(\"sse3\")))\n#endif\nstatic inline void\n__kmp_mm_monitor(void *cacheline, unsigned extensions, unsigned hints) {\n  _mm_monitor(cacheline, extensions, hints);\n}\n#if KMP_OS_UNIX\n__attribute__((target(\"sse3\")))\n#endif\nstatic inline void\n__kmp_mm_mwait(unsigned extensions, unsigned hints) {\n  _mm_mwait(extensions, hints);\n}\n#endif // KMP_HAVE_UMWAIT\n\n/* ------------------------------------------------------------------------ */\n/* Support datatypes for the orphaned construct nesting checks.             */\n/* ------------------------------------------------------------------------ */\n\nenum cons_type {\n  ct_none,\n  ct_parallel,\n  ct_pdo,\n  ct_pdo_ordered,\n  ct_psections,\n  ct_psingle,\n  ct_critical,\n  ct_ordered_in_parallel,\n  ct_ordered_in_pdo,\n  ct_master,\n  ct_reduce,\n  ct_barrier,\n  ct_masked\n};\n\n#define IS_CONS_TYPE_ORDERED(ct) ((ct) == ct_pdo_ordered)\n\nstruct cons_data {\n  ident_t const *ident;\n  enum cons_type type;\n  int prev;\n  kmp_user_lock_p\n      name; /* address exclusively for critical section name comparison */\n};\n\nstruct cons_header {\n  int p_top, w_top, s_top;\n  int stack_size, stack_top;\n  struct cons_data *stack_data;\n};\n\nstruct kmp_region_info {\n  char *text;\n  int offset[KMP_MAX_FIELDS];\n  int length[KMP_MAX_FIELDS];\n};\n\n/* ---------------------------------------------------------------------- */\n/* ---------------------------------------------------------------------- */\n\n#if KMP_OS_WINDOWS\ntypedef HANDLE kmp_thread_t;\ntypedef DWORD kmp_key_t;\n#endif /* KMP_OS_WINDOWS */\n\n#if KMP_OS_UNIX\ntypedef pthread_t kmp_thread_t;\ntypedef pthread_key_t kmp_key_t;\n#endif\n\nextern kmp_key_t __kmp_gtid_threadprivate_key;\n\ntypedef struct kmp_sys_info {\n  long maxrss; /* the maximum resident set size utilized (in kilobytes)     */\n  long minflt; /* the number of page faults serviced without any I/O        */\n  long majflt; /* the number of page faults serviced that required I/O      */\n  long nswap; /* the number of times a process was \"swapped\" out of memory */\n  long inblock; /* the number of times the file system had to perform input  */\n  long oublock; /* the number of times the file system had to perform output */\n  long nvcsw; /* the number of times a context switch was voluntarily      */\n  long nivcsw; /* the number of times a context switch was forced           */\n} kmp_sys_info_t;\n\n#if USE_ITT_BUILD\n// We cannot include \"kmp_itt.h\" due to circular dependency. Declare the only\n// required type here. Later we will check the type meets requirements.\ntypedef int kmp_itt_mark_t;\n#define KMP_ITT_DEBUG 0\n#endif /* USE_ITT_BUILD */\n\ntypedef kmp_int32 kmp_critical_name[8];\n\n/*!\n@ingroup PARALLEL\nThe type for a microtask which gets passed to @ref __kmpc_fork_call().\nThe arguments to the outlined function are\n@param global_tid the global thread identity of the thread executing the\nfunction.\n@param bound_tid  the local identity of the thread executing the function\n@param ... pointers to shared variables accessed by the function.\n*/\ntypedef void (*kmpc_micro)(kmp_int32 *global_tid, kmp_int32 *bound_tid, ...);\ntypedef void (*kmpc_micro_bound)(kmp_int32 *bound_tid, kmp_int32 *bound_nth,\n                                 ...);\n\n/*!\n@ingroup THREADPRIVATE\n@{\n*/\n/* ---------------------------------------------------------------------------\n */\n/* Threadprivate initialization/finalization function declarations */\n\n/*  for non-array objects:  __kmpc_threadprivate_register()  */\n\n/*!\n Pointer to the constructor function.\n The first argument is the <tt>this</tt> pointer\n*/\ntypedef void *(*kmpc_ctor)(void *);\n\n/*!\n Pointer to the destructor function.\n The first argument is the <tt>this</tt> pointer\n*/\ntypedef void (*kmpc_dtor)(\n    void * /*, size_t */); /* 2nd arg: magic number for KCC unused by Intel\n                              compiler */\n/*!\n Pointer to an alternate constructor.\n The first argument is the <tt>this</tt> pointer.\n*/\ntypedef void *(*kmpc_cctor)(void *, void *);\n\n/* for array objects: __kmpc_threadprivate_register_vec() */\n/* First arg: \"this\" pointer */\n/* Last arg: number of array elements */\n/*!\n Array constructor.\n First argument is the <tt>this</tt> pointer\n Second argument the number of array elements.\n*/\ntypedef void *(*kmpc_ctor_vec)(void *, size_t);\n/*!\n Pointer to the array destructor function.\n The first argument is the <tt>this</tt> pointer\n Second argument the number of array elements.\n*/\ntypedef void (*kmpc_dtor_vec)(void *, size_t);\n/*!\n Array constructor.\n First argument is the <tt>this</tt> pointer\n Third argument the number of array elements.\n*/\ntypedef void *(*kmpc_cctor_vec)(void *, void *,\n                                size_t); /* function unused by compiler */\n\n/*!\n@}\n*/\n\n/* keeps tracked of threadprivate cache allocations for cleanup later */\ntypedef struct kmp_cached_addr {\n  void **addr; /* address of allocated cache */\n  void ***compiler_cache; /* pointer to compiler's cache */\n  void *data; /* pointer to global data */\n  struct kmp_cached_addr *next; /* pointer to next cached address */\n} kmp_cached_addr_t;\n\nstruct private_data {\n  struct private_data *next; /* The next descriptor in the list      */\n  void *data; /* The data buffer for this descriptor  */\n  int more; /* The repeat count for this descriptor */\n  size_t size; /* The data size for this descriptor    */\n};\n\nstruct private_common {\n  struct private_common *next;\n  struct private_common *link;\n  void *gbl_addr;\n  void *par_addr; /* par_addr == gbl_addr for PRIMARY thread */\n  size_t cmn_size;\n};\n\nstruct shared_common {\n  struct shared_common *next;\n  struct private_data *pod_init;\n  void *obj_init;\n  void *gbl_addr;\n  union {\n    kmpc_ctor ctor;\n    kmpc_ctor_vec ctorv;\n  } ct;\n  union {\n    kmpc_cctor cctor;\n    kmpc_cctor_vec cctorv;\n  } cct;\n  union {\n    kmpc_dtor dtor;\n    kmpc_dtor_vec dtorv;\n  } dt;\n  size_t vec_len;\n  int is_vec;\n  size_t cmn_size;\n};\n\n#define KMP_HASH_TABLE_LOG2 9 /* log2 of the hash table size */\n#define KMP_HASH_TABLE_SIZE                                                    \\\n  (1 << KMP_HASH_TABLE_LOG2) /* size of the hash table */\n#define KMP_HASH_SHIFT 3 /* throw away this many low bits from the address */\n#define KMP_HASH(x)                                                            \\\n  ((((kmp_uintptr_t)x) >> KMP_HASH_SHIFT) & (KMP_HASH_TABLE_SIZE - 1))\n\nstruct common_table {\n  struct private_common *data[KMP_HASH_TABLE_SIZE];\n};\n\nstruct shared_table {\n  struct shared_common *data[KMP_HASH_TABLE_SIZE];\n};\n\n/* ------------------------------------------------------------------------ */\n\n#if KMP_USE_HIER_SCHED\n// Shared barrier data that exists inside a single unit of the scheduling\n// hierarchy\ntypedef struct kmp_hier_private_bdata_t {\n  kmp_int32 num_active;\n  kmp_uint64 index;\n  kmp_uint64 wait_val[2];\n} kmp_hier_private_bdata_t;\n#endif\n\ntypedef struct kmp_sched_flags {\n  unsigned ordered : 1;\n  unsigned nomerge : 1;\n  unsigned contains_last : 1;\n#if KMP_USE_HIER_SCHED\n  unsigned use_hier : 1;\n  unsigned unused : 28;\n#else\n  unsigned unused : 29;\n#endif\n} kmp_sched_flags_t;\n\nKMP_BUILD_ASSERT(sizeof(kmp_sched_flags_t) == 4);\n\n#if KMP_STATIC_STEAL_ENABLED\ntypedef struct KMP_ALIGN_CACHE dispatch_private_info32 {\n  kmp_int32 count;\n  kmp_int32 ub;\n  /* Adding KMP_ALIGN_CACHE here doesn't help / can hurt performance */\n  kmp_int32 lb;\n  kmp_int32 st;\n  kmp_int32 tc;\n  kmp_int32 static_steal_counter; /* for static_steal only; maybe better to put\n                                     after ub */\n  kmp_lock_t *th_steal_lock; // lock used for chunk stealing\n  // KMP_ALIGN( 16 ) ensures ( if the KMP_ALIGN macro is turned on )\n  //    a) parm3 is properly aligned and\n  //    b) all parm1-4 are in the same cache line.\n  // Because of parm1-4 are used together, performance seems to be better\n  // if they are in the same line (not measured though).\n\n  struct KMP_ALIGN(32) { // AC: changed 16 to 32 in order to simplify template\n    kmp_int32 parm1; //     structures in kmp_dispatch.cpp. This should\n    kmp_int32 parm2; //     make no real change at least while padding is off.\n    kmp_int32 parm3;\n    kmp_int32 parm4;\n  };\n\n  kmp_uint32 ordered_lower;\n  kmp_uint32 ordered_upper;\n#if KMP_OS_WINDOWS\n  // This var can be placed in the hole between 'tc' and 'parm1', instead of\n  // 'static_steal_counter'. It would be nice to measure execution times.\n  // Conditional if/endif can be removed at all.\n  kmp_int32 last_upper;\n#endif /* KMP_OS_WINDOWS */\n} dispatch_private_info32_t;\n\ntypedef struct KMP_ALIGN_CACHE dispatch_private_info64 {\n  kmp_int64 count; // current chunk number for static & static-steal scheduling\n  kmp_int64 ub; /* upper-bound */\n  /* Adding KMP_ALIGN_CACHE here doesn't help / can hurt performance */\n  kmp_int64 lb; /* lower-bound */\n  kmp_int64 st; /* stride */\n  kmp_int64 tc; /* trip count (number of iterations) */\n  kmp_int64 static_steal_counter; /* for static_steal only; maybe better to put\n                                     after ub */\n  kmp_lock_t *th_steal_lock; // lock used for chunk stealing\n  /* parm[1-4] are used in different ways by different scheduling algorithms */\n\n  // KMP_ALIGN( 32 ) ensures ( if the KMP_ALIGN macro is turned on )\n  //    a) parm3 is properly aligned and\n  //    b) all parm1-4 are in the same cache line.\n  // Because of parm1-4 are used together, performance seems to be better\n  // if they are in the same line (not measured though).\n\n  struct KMP_ALIGN(32) {\n    kmp_int64 parm1;\n    kmp_int64 parm2;\n    kmp_int64 parm3;\n    kmp_int64 parm4;\n  };\n\n  kmp_uint64 ordered_lower;\n  kmp_uint64 ordered_upper;\n#if KMP_OS_WINDOWS\n  // This var can be placed in the hole between 'tc' and 'parm1', instead of\n  // 'static_steal_counter'. It would be nice to measure execution times.\n  // Conditional if/endif can be removed at all.\n  kmp_int64 last_upper;\n#endif /* KMP_OS_WINDOWS */\n} dispatch_private_info64_t;\n#else /* KMP_STATIC_STEAL_ENABLED */\ntypedef struct KMP_ALIGN_CACHE dispatch_private_info32 {\n  kmp_int32 lb;\n  kmp_int32 ub;\n  kmp_int32 st;\n  kmp_int32 tc;\n\n  kmp_int32 parm1;\n  kmp_int32 parm2;\n  kmp_int32 parm3;\n  kmp_int32 parm4;\n\n  kmp_int32 count;\n\n  kmp_uint32 ordered_lower;\n  kmp_uint32 ordered_upper;\n#if KMP_OS_WINDOWS\n  kmp_int32 last_upper;\n#endif /* KMP_OS_WINDOWS */\n} dispatch_private_info32_t;\n\ntypedef struct KMP_ALIGN_CACHE dispatch_private_info64 {\n  kmp_int64 lb; /* lower-bound */\n  kmp_int64 ub; /* upper-bound */\n  kmp_int64 st; /* stride */\n  kmp_int64 tc; /* trip count (number of iterations) */\n\n  /* parm[1-4] are used in different ways by different scheduling algorithms */\n  kmp_int64 parm1;\n  kmp_int64 parm2;\n  kmp_int64 parm3;\n  kmp_int64 parm4;\n\n  kmp_int64 count; /* current chunk number for static scheduling */\n\n  kmp_uint64 ordered_lower;\n  kmp_uint64 ordered_upper;\n#if KMP_OS_WINDOWS\n  kmp_int64 last_upper;\n#endif /* KMP_OS_WINDOWS */\n} dispatch_private_info64_t;\n#endif /* KMP_STATIC_STEAL_ENABLED */\n\ntypedef struct KMP_ALIGN_CACHE dispatch_private_info {\n  union private_info {\n    dispatch_private_info32_t p32;\n    dispatch_private_info64_t p64;\n  } u;\n  enum sched_type schedule; /* scheduling algorithm */\n  kmp_sched_flags_t flags; /* flags (e.g., ordered, nomerge, etc.) */\n  kmp_int32 ordered_bumped;\n  // To retain the structure size after making ordered_iteration scalar\n  kmp_int32 ordered_dummy[KMP_MAX_ORDERED - 3];\n  // Stack of buffers for nest of serial regions\n  struct dispatch_private_info *next;\n  kmp_int32 type_size; /* the size of types in private_info */\n#if KMP_USE_HIER_SCHED\n  kmp_int32 hier_id;\n  void *parent; /* hierarchical scheduling parent pointer */\n#endif\n  enum cons_type pushed_ws;\n} dispatch_private_info_t;\n\ntypedef struct dispatch_shared_info32 {\n  /* chunk index under dynamic, number of idle threads under static-steal;\n     iteration index otherwise */\n  volatile kmp_uint32 iteration;\n  volatile kmp_uint32 num_done;\n  volatile kmp_uint32 ordered_iteration;\n  // Dummy to retain the structure size after making ordered_iteration scalar\n  kmp_int32 ordered_dummy[KMP_MAX_ORDERED - 1];\n} dispatch_shared_info32_t;\n\ntypedef struct dispatch_shared_info64 {\n  /* chunk index under dynamic, number of idle threads under static-steal;\n     iteration index otherwise */\n  volatile kmp_uint64 iteration;\n  volatile kmp_uint64 num_done;\n  volatile kmp_uint64 ordered_iteration;\n  // Dummy to retain the structure size after making ordered_iteration scalar\n  kmp_int64 ordered_dummy[KMP_MAX_ORDERED - 3];\n} dispatch_shared_info64_t;\n\ntypedef struct dispatch_shared_info {\n  union shared_info {\n    dispatch_shared_info32_t s32;\n    dispatch_shared_info64_t s64;\n  } u;\n  volatile kmp_uint32 buffer_index;\n  volatile kmp_int32 doacross_buf_idx; // teamwise index\n  volatile kmp_uint32 *doacross_flags; // shared array of iteration flags (0/1)\n  kmp_int32 doacross_num_done; // count finished threads\n#if KMP_USE_HIER_SCHED\n  void *hier;\n#endif\n#if KMP_USE_HWLOC\n  // When linking with libhwloc, the ORDERED EPCC test slows down on big\n  // machines (> 48 cores). Performance analysis showed that a cache thrash\n  // was occurring and this padding helps alleviate the problem.\n  char padding[64];\n#endif\n} dispatch_shared_info_t;\n\ntypedef struct kmp_disp {\n  /* Vector for ORDERED SECTION */\n  void (*th_deo_fcn)(int *gtid, int *cid, ident_t *);\n  /* Vector for END ORDERED SECTION */\n  void (*th_dxo_fcn)(int *gtid, int *cid, ident_t *);\n\n  dispatch_shared_info_t *th_dispatch_sh_current;\n  dispatch_private_info_t *th_dispatch_pr_current;\n\n  dispatch_private_info_t *th_disp_buffer;\n  kmp_int32 th_disp_index;\n  kmp_int32 th_doacross_buf_idx; // thread's doacross buffer index\n  volatile kmp_uint32 *th_doacross_flags; // pointer to shared array of flags\n  kmp_int64 *th_doacross_info; // info on loop bounds\n#if KMP_USE_INTERNODE_ALIGNMENT\n  char more_padding[INTERNODE_CACHE_LINE];\n#endif\n} kmp_disp_t;\n\n/* ------------------------------------------------------------------------ */\n/* Barrier stuff */\n\n/* constants for barrier state update */\n#define KMP_INIT_BARRIER_STATE 0 /* should probably start from zero */\n#define KMP_BARRIER_SLEEP_BIT 0 /* bit used for suspend/sleep part of state */\n#define KMP_BARRIER_UNUSED_BIT 1 // bit that must never be set for valid state\n#define KMP_BARRIER_BUMP_BIT 2 /* lsb used for bump of go/arrived state */\n\n#define KMP_BARRIER_SLEEP_STATE (1 << KMP_BARRIER_SLEEP_BIT)\n#define KMP_BARRIER_UNUSED_STATE (1 << KMP_BARRIER_UNUSED_BIT)\n#define KMP_BARRIER_STATE_BUMP (1 << KMP_BARRIER_BUMP_BIT)\n\n#if (KMP_BARRIER_SLEEP_BIT >= KMP_BARRIER_BUMP_BIT)\n#error \"Barrier sleep bit must be smaller than barrier bump bit\"\n#endif\n#if (KMP_BARRIER_UNUSED_BIT >= KMP_BARRIER_BUMP_BIT)\n#error \"Barrier unused bit must be smaller than barrier bump bit\"\n#endif\n\n// Constants for release barrier wait state: currently, hierarchical only\n#define KMP_BARRIER_NOT_WAITING 0 // Normal state; worker not in wait_sleep\n#define KMP_BARRIER_OWN_FLAG                                                   \\\n  1 // Normal state; worker waiting on own b_go flag in release\n#define KMP_BARRIER_PARENT_FLAG                                                \\\n  2 // Special state; worker waiting on parent's b_go flag in release\n#define KMP_BARRIER_SWITCH_TO_OWN_FLAG                                         \\\n  3 // Special state; tells worker to shift from parent to own b_go\n#define KMP_BARRIER_SWITCHING                                                  \\\n  4 // Special state; worker resets appropriate flag on wake-up\n\n#define KMP_NOT_SAFE_TO_REAP                                                   \\\n  0 // Thread th_reap_state: not safe to reap (tasking)\n#define KMP_SAFE_TO_REAP 1 // Thread th_reap_state: safe to reap (not tasking)\n\nenum barrier_type {\n  bs_plain_barrier = 0, /* 0, All non-fork/join barriers (except reduction\n                           barriers if enabled) */\n  bs_forkjoin_barrier, /* 1, All fork/join (parallel region) barriers */\n#if KMP_FAST_REDUCTION_BARRIER\n  bs_reduction_barrier, /* 2, All barriers that are used in reduction */\n#endif // KMP_FAST_REDUCTION_BARRIER\n  bs_last_barrier /* Just a placeholder to mark the end */\n};\n\n// to work with reduction barriers just like with plain barriers\n#if !KMP_FAST_REDUCTION_BARRIER\n#define bs_reduction_barrier bs_plain_barrier\n#endif // KMP_FAST_REDUCTION_BARRIER\n\ntypedef enum kmp_bar_pat { /* Barrier communication patterns */\n                           bp_linear_bar =\n                               0, /* Single level (degenerate) tree */\n                           bp_tree_bar =\n                               1, /* Balanced tree with branching factor 2^n */\n                           bp_hyper_bar = 2, /* Hypercube-embedded tree with min\n                                                branching factor 2^n */\n                           bp_hierarchical_bar = 3, /* Machine hierarchy tree */\n                           bp_last_bar /* Placeholder to mark the end */\n} kmp_bar_pat_e;\n\n#define KMP_BARRIER_ICV_PUSH 1\n\n/* Record for holding the values of the internal controls stack records */\ntypedef struct kmp_internal_control {\n  int serial_nesting_level; /* corresponds to the value of the\n                               th_team_serialized field */\n  kmp_int8 dynamic; /* internal control for dynamic adjustment of threads (per\n                       thread) */\n  kmp_int8\n      bt_set; /* internal control for whether blocktime is explicitly set */\n  int blocktime; /* internal control for blocktime */\n#if KMP_USE_MONITOR\n  int bt_intervals; /* internal control for blocktime intervals */\n#endif\n  int nproc; /* internal control for #threads for next parallel region (per\n                thread) */\n  int thread_limit; /* internal control for thread-limit-var */\n  int max_active_levels; /* internal control for max_active_levels */\n  kmp_r_sched_t\n      sched; /* internal control for runtime schedule {sched,chunk} pair */\n  kmp_proc_bind_t proc_bind; /* internal control for affinity  */\n  kmp_int32 default_device; /* internal control for default device */\n  struct kmp_internal_control *next;\n} kmp_internal_control_t;\n\nstatic inline void copy_icvs(kmp_internal_control_t *dst,\n                             kmp_internal_control_t *src) {\n  *dst = *src;\n}\n\n/* Thread barrier needs volatile barrier fields */\ntypedef struct KMP_ALIGN_CACHE kmp_bstate {\n  // th_fixed_icvs is aligned by virtue of kmp_bstate being aligned (and all\n  // uses of it). It is not explicitly aligned below, because we *don't* want\n  // it to be padded -- instead, we fit b_go into the same cache line with\n  // th_fixed_icvs, enabling NGO cache lines stores in the hierarchical barrier.\n  kmp_internal_control_t th_fixed_icvs; // Initial ICVs for the thread\n  // Tuck b_go into end of th_fixed_icvs cache line, so it can be stored with\n  // same NGO store\n  volatile kmp_uint64 b_go; // STATE => task should proceed (hierarchical)\n  KMP_ALIGN_CACHE volatile kmp_uint64\n      b_arrived; // STATE => task reached synch point.\n  kmp_uint32 *skip_per_level;\n  kmp_uint32 my_level;\n  kmp_int32 parent_tid;\n  kmp_int32 old_tid;\n  kmp_uint32 depth;\n  struct kmp_bstate *parent_bar;\n  kmp_team_t *team;\n  kmp_uint64 leaf_state;\n  kmp_uint32 nproc;\n  kmp_uint8 base_leaf_kids;\n  kmp_uint8 leaf_kids;\n  kmp_uint8 offset;\n  kmp_uint8 wait_flag;\n  kmp_uint8 use_oncore_barrier;\n#if USE_DEBUGGER\n  // The following field is intended for the debugger solely. Only the worker\n  // thread itself accesses this field: the worker increases it by 1 when it\n  // arrives to a barrier.\n  KMP_ALIGN_CACHE kmp_uint b_worker_arrived;\n#endif /* USE_DEBUGGER */\n} kmp_bstate_t;\n\nunion KMP_ALIGN_CACHE kmp_barrier_union {\n  double b_align; /* use worst case alignment */\n  char b_pad[KMP_PAD(kmp_bstate_t, CACHE_LINE)];\n  kmp_bstate_t bb;\n};\n\ntypedef union kmp_barrier_union kmp_balign_t;\n\n/* Team barrier needs only non-volatile arrived counter */\nunion KMP_ALIGN_CACHE kmp_barrier_team_union {\n  double b_align; /* use worst case alignment */\n  char b_pad[CACHE_LINE];\n  struct {\n    kmp_uint64 b_arrived; /* STATE => task reached synch point. */\n#if USE_DEBUGGER\n    // The following two fields are indended for the debugger solely. Only\n    // primary thread of the team accesses these fields: the first one is\n    // increased by 1 when the primary thread arrives to a barrier, the second\n    // one is increased by one when all the threads arrived.\n    kmp_uint b_master_arrived;\n    kmp_uint b_team_arrived;\n#endif\n  };\n};\n\ntypedef union kmp_barrier_team_union kmp_balign_team_t;\n\n/* Padding for Linux* OS pthreads condition variables and mutexes used to signal\n   threads when a condition changes.  This is to workaround an NPTL bug where\n   padding was added to pthread_cond_t which caused the initialization routine\n   to write outside of the structure if compiled on pre-NPTL threads.  */\n#if KMP_OS_WINDOWS\ntypedef struct kmp_win32_mutex {\n  /* The Lock */\n  CRITICAL_SECTION cs;\n} kmp_win32_mutex_t;\n\ntypedef struct kmp_win32_cond {\n  /* Count of the number of waiters. */\n  int waiters_count_;\n\n  /* Serialize access to <waiters_count_> */\n  kmp_win32_mutex_t waiters_count_lock_;\n\n  /* Number of threads to release via a <cond_broadcast> or a <cond_signal> */\n  int release_count_;\n\n  /* Keeps track of the current \"generation\" so that we don't allow */\n  /* one thread to steal all the \"releases\" from the broadcast. */\n  int wait_generation_count_;\n\n  /* A manual-reset event that's used to block and release waiting threads. */\n  HANDLE event_;\n} kmp_win32_cond_t;\n#endif\n\n#if KMP_OS_UNIX\n\nunion KMP_ALIGN_CACHE kmp_cond_union {\n  double c_align;\n  char c_pad[CACHE_LINE];\n  pthread_cond_t c_cond;\n};\n\ntypedef union kmp_cond_union kmp_cond_align_t;\n\nunion KMP_ALIGN_CACHE kmp_mutex_union {\n  double m_align;\n  char m_pad[CACHE_LINE];\n  pthread_mutex_t m_mutex;\n};\n\ntypedef union kmp_mutex_union kmp_mutex_align_t;\n\n#endif /* KMP_OS_UNIX */\n\ntypedef struct kmp_desc_base {\n  void *ds_stackbase;\n  size_t ds_stacksize;\n  int ds_stackgrow;\n  kmp_thread_t ds_thread;\n  volatile int ds_tid;\n  int ds_gtid;\n#if KMP_OS_WINDOWS\n  volatile int ds_alive;\n  DWORD ds_thread_id;\n/* ds_thread keeps thread handle on Windows* OS. It is enough for RTL purposes.\n   However, debugger support (libomp_db) cannot work with handles, because they\n   uncomparable. For example, debugger requests info about thread with handle h.\n   h is valid within debugger process, and meaningless within debugee process.\n   Even if h is duped by call to DuplicateHandle(), so the result h' is valid\n   within debugee process, but it is a *new* handle which does *not* equal to\n   any other handle in debugee... The only way to compare handles is convert\n   them to system-wide ids. GetThreadId() function is available only in\n   Longhorn and Server 2003. :-( In contrast, GetCurrentThreadId() is available\n   on all Windows* OS flavours (including Windows* 95). Thus, we have to get\n   thread id by call to GetCurrentThreadId() from within the thread and save it\n   to let libomp_db identify threads.  */\n#endif /* KMP_OS_WINDOWS */\n} kmp_desc_base_t;\n\ntypedef union KMP_ALIGN_CACHE kmp_desc {\n  double ds_align; /* use worst case alignment */\n  char ds_pad[KMP_PAD(kmp_desc_base_t, CACHE_LINE)];\n  kmp_desc_base_t ds;\n} kmp_desc_t;\n\ntypedef struct kmp_local {\n  volatile int this_construct; /* count of single's encountered by thread */\n  void *reduce_data;\n#if KMP_USE_BGET\n  void *bget_data;\n  void *bget_list;\n#if !USE_CMP_XCHG_FOR_BGET\n#ifdef USE_QUEUING_LOCK_FOR_BGET\n  kmp_lock_t bget_lock; /* Lock for accessing bget free list */\n#else\n  kmp_bootstrap_lock_t bget_lock; // Lock for accessing bget free list. Must be\n// bootstrap lock so we can use it at library\n// shutdown.\n#endif /* USE_LOCK_FOR_BGET */\n#endif /* ! USE_CMP_XCHG_FOR_BGET */\n#endif /* KMP_USE_BGET */\n\n  PACKED_REDUCTION_METHOD_T\n  packed_reduction_method; /* stored by __kmpc_reduce*(), used by\n                              __kmpc_end_reduce*() */\n\n} kmp_local_t;\n\n#define KMP_CHECK_UPDATE(a, b)                                                 \\\n  if ((a) != (b))                                                              \\\n  (a) = (b)\n#define KMP_CHECK_UPDATE_SYNC(a, b)                                            \\\n  if ((a) != (b))                                                              \\\n  TCW_SYNC_PTR((a), (b))\n\n#define get__blocktime(xteam, xtid)                                            \\\n  ((xteam)->t.t_threads[(xtid)]->th.th_current_task->td_icvs.blocktime)\n#define get__bt_set(xteam, xtid)                                               \\\n  ((xteam)->t.t_threads[(xtid)]->th.th_current_task->td_icvs.bt_set)\n#if KMP_USE_MONITOR\n#define get__bt_intervals(xteam, xtid)                                         \\\n  ((xteam)->t.t_threads[(xtid)]->th.th_current_task->td_icvs.bt_intervals)\n#endif\n\n#define get__dynamic_2(xteam, xtid)                                            \\\n  ((xteam)->t.t_threads[(xtid)]->th.th_current_task->td_icvs.dynamic)\n#define get__nproc_2(xteam, xtid)                                              \\\n  ((xteam)->t.t_threads[(xtid)]->th.th_current_task->td_icvs.nproc)\n#define get__sched_2(xteam, xtid)                                              \\\n  ((xteam)->t.t_threads[(xtid)]->th.th_current_task->td_icvs.sched)\n\n#define set__blocktime_team(xteam, xtid, xval)                                 \\\n  (((xteam)->t.t_threads[(xtid)]->th.th_current_task->td_icvs.blocktime) =     \\\n       (xval))\n\n#if KMP_USE_MONITOR\n#define set__bt_intervals_team(xteam, xtid, xval)                              \\\n  (((xteam)->t.t_threads[(xtid)]->th.th_current_task->td_icvs.bt_intervals) =  \\\n       (xval))\n#endif\n\n#define set__bt_set_team(xteam, xtid, xval)                                    \\\n  (((xteam)->t.t_threads[(xtid)]->th.th_current_task->td_icvs.bt_set) = (xval))\n\n#define set__dynamic(xthread, xval)                                            \\\n  (((xthread)->th.th_current_task->td_icvs.dynamic) = (xval))\n#define get__dynamic(xthread)                                                  \\\n  (((xthread)->th.th_current_task->td_icvs.dynamic) ? (FTN_TRUE) : (FTN_FALSE))\n\n#define set__nproc(xthread, xval)                                              \\\n  (((xthread)->th.th_current_task->td_icvs.nproc) = (xval))\n\n#define set__thread_limit(xthread, xval)                                       \\\n  (((xthread)->th.th_current_task->td_icvs.thread_limit) = (xval))\n\n#define set__max_active_levels(xthread, xval)                                  \\\n  (((xthread)->th.th_current_task->td_icvs.max_active_levels) = (xval))\n\n#define get__max_active_levels(xthread)                                        \\\n  ((xthread)->th.th_current_task->td_icvs.max_active_levels)\n\n#define set__sched(xthread, xval)                                              \\\n  (((xthread)->th.th_current_task->td_icvs.sched) = (xval))\n\n#define set__proc_bind(xthread, xval)                                          \\\n  (((xthread)->th.th_current_task->td_icvs.proc_bind) = (xval))\n#define get__proc_bind(xthread)                                                \\\n  ((xthread)->th.th_current_task->td_icvs.proc_bind)\n\n// OpenMP tasking data structures\n\ntypedef enum kmp_tasking_mode {\n  tskm_immediate_exec = 0,\n  tskm_extra_barrier = 1,\n  tskm_task_teams = 2,\n  tskm_max = 2\n} kmp_tasking_mode_t;\n\nextern kmp_tasking_mode_t\n    __kmp_tasking_mode; /* determines how/when to execute tasks */\nextern int __kmp_task_stealing_constraint;\nextern int __kmp_enable_task_throttling;\nextern kmp_int32 __kmp_default_device; // Set via OMP_DEFAULT_DEVICE if\n// specified, defaults to 0 otherwise\n// Set via OMP_MAX_TASK_PRIORITY if specified, defaults to 0 otherwise\nextern kmp_int32 __kmp_max_task_priority;\n// Set via KMP_TASKLOOP_MIN_TASKS if specified, defaults to 0 otherwise\nextern kmp_uint64 __kmp_taskloop_min_tasks;\n\n/* NOTE: kmp_taskdata_t and kmp_task_t structures allocated in single block with\n   taskdata first */\n#define KMP_TASK_TO_TASKDATA(task) (((kmp_taskdata_t *)task) - 1)\n#define KMP_TASKDATA_TO_TASK(taskdata) (kmp_task_t *)(taskdata + 1)\n\n// The tt_found_tasks flag is a signal to all threads in the team that tasks\n// were spawned and queued since the previous barrier release.\n#define KMP_TASKING_ENABLED(task_team)                                         \\\n  (TRUE == TCR_SYNC_4((task_team)->tt.tt_found_tasks))\n/*!\n@ingroup BASIC_TYPES\n@{\n*/\n\n/*!\n */\ntypedef kmp_int32 (*kmp_routine_entry_t)(kmp_int32, void *);\n\ntypedef union kmp_cmplrdata {\n  kmp_int32 priority; /**< priority specified by user for the task */\n  kmp_routine_entry_t\n      destructors; /* pointer to function to invoke deconstructors of\n                      firstprivate C++ objects */\n  /* future data */\n} kmp_cmplrdata_t;\n\n/*  sizeof_kmp_task_t passed as arg to kmpc_omp_task call  */\n/*!\n */\ntypedef struct kmp_task { /* GEH: Shouldn't this be aligned somehow? */\n  void *shareds; /**< pointer to block of pointers to shared vars   */\n  kmp_routine_entry_t\n      routine; /**< pointer to routine to call for executing task */\n  kmp_int32 part_id; /**< part id for the task                          */\n  kmp_cmplrdata_t\n      data1; /* Two known optional additions: destructors and priority */\n  kmp_cmplrdata_t data2; /* Process destructors first, priority second */\n  /* future data */\n  /*  private vars  */\n} kmp_task_t;\n\n/*!\n@}\n*/\n\ntypedef struct kmp_taskgroup {\n  std::atomic<kmp_int32> count; // number of allocated and incomplete tasks\n  std::atomic<kmp_int32>\n      cancel_request; // request for cancellation of this taskgroup\n  struct kmp_taskgroup *parent; // parent taskgroup\n  // Block of data to perform task reduction\n  void *reduce_data; // reduction related info\n  kmp_int32 reduce_num_data; // number of data items to reduce\n} kmp_taskgroup_t;\n\n// forward declarations\ntypedef union kmp_depnode kmp_depnode_t;\ntypedef struct kmp_depnode_list kmp_depnode_list_t;\ntypedef struct kmp_dephash_entry kmp_dephash_entry_t;\n\n// Compiler sends us this info:\ntypedef struct kmp_depend_info {\n  kmp_intptr_t base_addr;\n  size_t len;\n  struct {\n    bool in : 1;\n    bool out : 1;\n    bool mtx : 1;\n  } flags;\n} kmp_depend_info_t;\n\n// Internal structures to work with task dependencies:\nstruct kmp_depnode_list {\n  kmp_depnode_t *node;\n  kmp_depnode_list_t *next;\n};\n\n// Max number of mutexinoutset dependencies per node\n#define MAX_MTX_DEPS 4\n\ntypedef struct kmp_base_depnode {\n  kmp_depnode_list_t *successors; /* used under lock */\n  kmp_task_t *task; /* non-NULL if depnode is active, used under lock */\n  kmp_lock_t *mtx_locks[MAX_MTX_DEPS]; /* lock mutexinoutset dependent tasks */\n  kmp_int32 mtx_num_locks; /* number of locks in mtx_locks array */\n  kmp_lock_t lock; /* guards shared fields: task, successors */\n#if KMP_SUPPORT_GRAPH_OUTPUT\n  kmp_uint32 id;\n#endif\n  std::atomic<kmp_int32> npredecessors;\n  std::atomic<kmp_int32> nrefs;\n} kmp_base_depnode_t;\n\nunion KMP_ALIGN_CACHE kmp_depnode {\n  double dn_align; /* use worst case alignment */\n  char dn_pad[KMP_PAD(kmp_base_depnode_t, CACHE_LINE)];\n  kmp_base_depnode_t dn;\n};\n\nstruct kmp_dephash_entry {\n  kmp_intptr_t addr;\n  kmp_depnode_t *last_out;\n  kmp_depnode_list_t *last_ins;\n  kmp_depnode_list_t *last_mtxs;\n  kmp_int32 last_flag;\n  kmp_lock_t *mtx_lock; /* is referenced by depnodes w/mutexinoutset dep */\n  kmp_dephash_entry_t *next_in_bucket;\n};\n\ntypedef struct kmp_dephash {\n  kmp_dephash_entry_t **buckets;\n  size_t size;\n  size_t generation;\n  kmp_uint32 nelements;\n  kmp_uint32 nconflicts;\n} kmp_dephash_t;\n\ntypedef struct kmp_task_affinity_info {\n  kmp_intptr_t base_addr;\n  size_t len;\n  struct {\n    bool flag1 : 1;\n    bool flag2 : 1;\n    kmp_int32 reserved : 30;\n  } flags;\n} kmp_task_affinity_info_t;\n\ntypedef enum kmp_event_type_t {\n  KMP_EVENT_UNINITIALIZED = 0,\n  KMP_EVENT_ALLOW_COMPLETION = 1\n} kmp_event_type_t;\n\ntypedef struct {\n  kmp_event_type_t type;\n  kmp_tas_lock_t lock;\n  union {\n    kmp_task_t *task;\n  } ed;\n} kmp_event_t;\n\n#ifdef BUILD_TIED_TASK_STACK\n\n/* Tied Task stack definitions */\ntypedef struct kmp_stack_block {\n  kmp_taskdata_t *sb_block[TASK_STACK_BLOCK_SIZE];\n  struct kmp_stack_block *sb_next;\n  struct kmp_stack_block *sb_prev;\n} kmp_stack_block_t;\n\ntypedef struct kmp_task_stack {\n  kmp_stack_block_t ts_first_block; // first block of stack entries\n  kmp_taskdata_t **ts_top; // pointer to the top of stack\n  kmp_int32 ts_entries; // number of entries on the stack\n} kmp_task_stack_t;\n\n#endif // BUILD_TIED_TASK_STACK\n\ntypedef struct kmp_tasking_flags { /* Total struct must be exactly 32 bits */\n  /* Compiler flags */ /* Total compiler flags must be 16 bits */\n  unsigned tiedness : 1; /* task is either tied (1) or untied (0) */\n  unsigned final : 1; /* task is final(1) so execute immediately */\n  unsigned merged_if0 : 1; /* no __kmpc_task_{begin/complete}_if0 calls in if0\n                              code path */\n  unsigned destructors_thunk : 1; /* set if the compiler creates a thunk to\n                                     invoke destructors from the runtime */\n  unsigned proxy : 1; /* task is a proxy task (it will be executed outside the\n                         context of the RTL) */\n  unsigned priority_specified : 1; /* set if the compiler provides priority\n                                      setting for the task */\n  unsigned detachable : 1; /* 1 == can detach */\n  unsigned hidden_helper : 1; /* 1 == hidden helper task */\n  unsigned reserved : 8; /* reserved for compiler use */\n\n  /* Library flags */ /* Total library flags must be 16 bits */\n  unsigned tasktype : 1; /* task is either explicit(1) or implicit (0) */\n  unsigned task_serial : 1; // task is executed immediately (1) or deferred (0)\n  unsigned tasking_ser : 1; // all tasks in team are either executed immediately\n  // (1) or may be deferred (0)\n  unsigned team_serial : 1; // entire team is serial (1) [1 thread] or parallel\n  // (0) [>= 2 threads]\n  /* If either team_serial or tasking_ser is set, task team may be NULL */\n  /* Task State Flags: */\n  unsigned started : 1; /* 1==started, 0==not started     */\n  unsigned executing : 1; /* 1==executing, 0==not executing */\n  unsigned complete : 1; /* 1==complete, 0==not complete   */\n  unsigned freed : 1; /* 1==freed, 0==allocated        */\n  unsigned native : 1; /* 1==gcc-compiled task, 0==intel */\n  unsigned reserved31 : 7; /* reserved for library use */\n\n} kmp_tasking_flags_t;\n\nstruct kmp_taskdata { /* aligned during dynamic allocation       */\n  kmp_int32 td_task_id; /* id, assigned by debugger                */\n  kmp_tasking_flags_t td_flags; /* task flags                              */\n  kmp_team_t *td_team; /* team for this task                      */\n  kmp_info_p *td_alloc_thread; /* thread that allocated data structures   */\n  /* Currently not used except for perhaps IDB */\n  kmp_taskdata_t *td_parent; /* parent task                             */\n  kmp_int32 td_level; /* task nesting level                      */\n  std::atomic<kmp_int32> td_untied_count; // untied task active parts counter\n  ident_t *td_ident; /* task identifier                         */\n  // Taskwait data.\n  ident_t *td_taskwait_ident;\n  kmp_uint32 td_taskwait_counter;\n  kmp_int32 td_taskwait_thread; /* gtid + 1 of thread encountered taskwait */\n  KMP_ALIGN_CACHE kmp_internal_control_t\n      td_icvs; /* Internal control variables for the task */\n  KMP_ALIGN_CACHE std::atomic<kmp_int32>\n      td_allocated_child_tasks; /* Child tasks (+ current task) not yet\n                                   deallocated */\n  std::atomic<kmp_int32>\n      td_incomplete_child_tasks; /* Child tasks not yet complete */\n  kmp_taskgroup_t\n      *td_taskgroup; // Each task keeps pointer to its current taskgroup\n  kmp_dephash_t\n      *td_dephash; // Dependencies for children tasks are tracked from here\n  kmp_depnode_t\n      *td_depnode; // Pointer to graph node if this task has dependencies\n  kmp_task_team_t *td_task_team;\n  // The global thread id of the encountering thread. We need it because when a\n  // regular task depends on a hidden helper task, and the hidden helper task\n  // is finished on a hidden helper thread, it will call __kmp_release_deps to\n  // release all dependences. If now the task is a regular task, we need to pass\n  // the encountering gtid such that the task will be picked up and executed by\n  // its encountering team instead of hidden helper team.\n  kmp_int32 encountering_gtid;\n  size_t td_size_alloc; // Size of task structure, including shareds etc.\n#if defined(KMP_GOMP_COMPAT)\n  // 4 or 8 byte integers for the loop bounds in GOMP_taskloop\n  kmp_int32 td_size_loop_bounds;\n#endif\n  kmp_taskdata_t *td_last_tied; // keep tied task for task scheduling constraint\n#if defined(KMP_GOMP_COMPAT)\n  // GOMP sends in a copy function for copy constructors\n  void (*td_copy_func)(void *, void *);\n#endif\n  kmp_event_t td_allow_completion_event;\n#if OMPT_SUPPORT\n  ompt_task_info_t ompt_task_info;\n#endif\n}; // struct kmp_taskdata\n\n// Make sure padding above worked\nKMP_BUILD_ASSERT(sizeof(kmp_taskdata_t) % sizeof(void *) == 0);\n\n// Data for task team but per thread\ntypedef struct kmp_base_thread_data {\n  kmp_info_p *td_thr; // Pointer back to thread info\n  // Used only in __kmp_execute_tasks_template, maybe not avail until task is\n  // queued?\n  kmp_bootstrap_lock_t td_deque_lock; // Lock for accessing deque\n  kmp_taskdata_t *\n      *td_deque; // Deque of tasks encountered by td_thr, dynamically allocated\n  kmp_int32 td_deque_size; // Size of deck\n  kmp_uint32 td_deque_head; // Head of deque (will wrap)\n  kmp_uint32 td_deque_tail; // Tail of deque (will wrap)\n  kmp_int32 td_deque_ntasks; // Number of tasks in deque\n  // GEH: shouldn't this be volatile since used in while-spin?\n  kmp_int32 td_deque_last_stolen; // Thread number of last successful steal\n#ifdef BUILD_TIED_TASK_STACK\n  kmp_task_stack_t td_susp_tied_tasks; // Stack of suspended tied tasks for task\n// scheduling constraint\n#endif // BUILD_TIED_TASK_STACK\n} kmp_base_thread_data_t;\n\n#define TASK_DEQUE_BITS 8 // Used solely to define INITIAL_TASK_DEQUE_SIZE\n#define INITIAL_TASK_DEQUE_SIZE (1 << TASK_DEQUE_BITS)\n\n#define TASK_DEQUE_SIZE(td) ((td).td_deque_size)\n#define TASK_DEQUE_MASK(td) ((td).td_deque_size - 1)\n\ntypedef union KMP_ALIGN_CACHE kmp_thread_data {\n  kmp_base_thread_data_t td;\n  double td_align; /* use worst case alignment */\n  char td_pad[KMP_PAD(kmp_base_thread_data_t, CACHE_LINE)];\n} kmp_thread_data_t;\n\n// Data for task teams which are used when tasking is enabled for the team\ntypedef struct kmp_base_task_team {\n  kmp_bootstrap_lock_t\n      tt_threads_lock; /* Lock used to allocate per-thread part of task team */\n  /* must be bootstrap lock since used at library shutdown*/\n  kmp_task_team_t *tt_next; /* For linking the task team free list */\n  kmp_thread_data_t\n      *tt_threads_data; /* Array of per-thread structures for task team */\n  /* Data survives task team deallocation */\n  kmp_int32 tt_found_tasks; /* Have we found tasks and queued them while\n                               executing this team? */\n  /* TRUE means tt_threads_data is set up and initialized */\n  kmp_int32 tt_nproc; /* #threads in team           */\n  kmp_int32 tt_max_threads; // # entries allocated for threads_data array\n  kmp_int32 tt_found_proxy_tasks; // found proxy tasks since last barrier\n  kmp_int32 tt_untied_task_encountered;\n  // There is hidden helper thread encountered in this task team so that we must\n  // wait when waiting on task team\n  kmp_int32 tt_hidden_helper_task_encountered;\n\n  KMP_ALIGN_CACHE\n  std::atomic<kmp_int32> tt_unfinished_threads; /* #threads still active */\n\n  KMP_ALIGN_CACHE\n  volatile kmp_uint32\n      tt_active; /* is the team still actively executing tasks */\n} kmp_base_task_team_t;\n\nunion KMP_ALIGN_CACHE kmp_task_team {\n  kmp_base_task_team_t tt;\n  double tt_align; /* use worst case alignment */\n  char tt_pad[KMP_PAD(kmp_base_task_team_t, CACHE_LINE)];\n};\n\n#if (USE_FAST_MEMORY == 3) || (USE_FAST_MEMORY == 5)\n// Free lists keep same-size free memory slots for fast memory allocation\n// routines\ntypedef struct kmp_free_list {\n  void *th_free_list_self; // Self-allocated tasks free list\n  void *th_free_list_sync; // Self-allocated tasks stolen/returned by other\n  // threads\n  void *th_free_list_other; // Non-self free list (to be returned to owner's\n  // sync list)\n} kmp_free_list_t;\n#endif\n#if KMP_NESTED_HOT_TEAMS\n// Hot teams array keeps hot teams and their sizes for given thread. Hot teams\n// are not put in teams pool, and they don't put threads in threads pool.\ntypedef struct kmp_hot_team_ptr {\n  kmp_team_p *hot_team; // pointer to hot_team of given nesting level\n  kmp_int32 hot_team_nth; // number of threads allocated for the hot_team\n} kmp_hot_team_ptr_t;\n#endif\ntypedef struct kmp_teams_size {\n  kmp_int32 nteams; // number of teams in a league\n  kmp_int32 nth; // number of threads in each team of the league\n} kmp_teams_size_t;\n\n// This struct stores a thread that acts as a \"root\" for a contention\n// group. Contention groups are rooted at kmp_root threads, but also at\n// each primary thread of each team created in the teams construct.\n// This struct therefore also stores a thread_limit associated with\n// that contention group, and a counter to track the number of threads\n// active in that contention group. Each thread has a list of these: CG\n// root threads have an entry in their list in which cg_root refers to\n// the thread itself, whereas other workers in the CG will have a\n// single entry where cg_root is same as the entry containing their CG\n// root. When a thread encounters a teams construct, it will add a new\n// entry to the front of its list, because it now roots a new CG.\ntypedef struct kmp_cg_root {\n  kmp_info_p *cg_root; // \"root\" thread for a contention group\n  // The CG root's limit comes from OMP_THREAD_LIMIT for root threads, or\n  // thread_limit clause for teams primary threads\n  kmp_int32 cg_thread_limit;\n  kmp_int32 cg_nthreads; // Count of active threads in CG rooted at cg_root\n  struct kmp_cg_root *up; // pointer to higher level CG root in list\n} kmp_cg_root_t;\n\n// OpenMP thread data structures\n\ntypedef struct KMP_ALIGN_CACHE kmp_base_info {\n  /* Start with the readonly data which is cache aligned and padded. This is\n     written before the thread starts working by the primary thread. Uber\n     masters may update themselves later. Usage does not consider serialized\n     regions.  */\n  kmp_desc_t th_info;\n  kmp_team_p *th_team; /* team we belong to */\n  kmp_root_p *th_root; /* pointer to root of task hierarchy */\n  kmp_info_p *th_next_pool; /* next available thread in the pool */\n  kmp_disp_t *th_dispatch; /* thread's dispatch data */\n  int th_in_pool; /* in thread pool (32 bits for TCR/TCW) */\n\n  /* The following are cached from the team info structure */\n  /* TODO use these in more places as determined to be needed via profiling */\n  int th_team_nproc; /* number of threads in a team */\n  kmp_info_p *th_team_master; /* the team's primary thread */\n  int th_team_serialized; /* team is serialized */\n  microtask_t th_teams_microtask; /* save entry address for teams construct */\n  int th_teams_level; /* save initial level of teams construct */\n/* it is 0 on device but may be any on host */\n\n/* The blocktime info is copied from the team struct to the thread struct */\n/* at the start of a barrier, and the values stored in the team are used  */\n/* at points in the code where the team struct is no longer guaranteed    */\n/* to exist (from the POV of worker threads).                             */\n#if KMP_USE_MONITOR\n  int th_team_bt_intervals;\n  int th_team_bt_set;\n#else\n  kmp_uint64 th_team_bt_intervals;\n#endif\n\n#if KMP_AFFINITY_SUPPORTED\n  kmp_affin_mask_t *th_affin_mask; /* thread's current affinity mask */\n#endif\n  omp_allocator_handle_t th_def_allocator; /* default allocator */\n  /* The data set by the primary thread at reinit, then R/W by the worker */\n  KMP_ALIGN_CACHE int\n      th_set_nproc; /* if > 0, then only use this request for the next fork */\n#if KMP_NESTED_HOT_TEAMS\n  kmp_hot_team_ptr_t *th_hot_teams; /* array of hot teams */\n#endif\n  kmp_proc_bind_t\n      th_set_proc_bind; /* if != proc_bind_default, use request for next fork */\n  kmp_teams_size_t\n      th_teams_size; /* number of teams/threads in teams construct */\n#if KMP_AFFINITY_SUPPORTED\n  int th_current_place; /* place currently bound to */\n  int th_new_place; /* place to bind to in par reg */\n  int th_first_place; /* first place in partition */\n  int th_last_place; /* last place in partition */\n#endif\n  int th_prev_level; /* previous level for affinity format */\n  int th_prev_num_threads; /* previous num_threads for affinity format */\n#if USE_ITT_BUILD\n  kmp_uint64 th_bar_arrive_time; /* arrival to barrier timestamp */\n  kmp_uint64 th_bar_min_time; /* minimum arrival time at the barrier */\n  kmp_uint64 th_frame_time; /* frame timestamp */\n#endif /* USE_ITT_BUILD */\n  kmp_local_t th_local;\n  struct private_common *th_pri_head;\n\n  /* Now the data only used by the worker (after initial allocation) */\n  /* TODO the first serial team should actually be stored in the info_t\n     structure.  this will help reduce initial allocation overhead */\n  KMP_ALIGN_CACHE kmp_team_p\n      *th_serial_team; /*serialized team held in reserve*/\n\n#if OMPT_SUPPORT\n  ompt_thread_info_t ompt_thread_info;\n#endif\n\n  /* The following are also read by the primary thread during reinit */\n  struct common_table *th_pri_common;\n\n  volatile kmp_uint32 th_spin_here; /* thread-local location for spinning */\n  /* while awaiting queuing lock acquire */\n\n  volatile void *th_sleep_loc; // this points at a kmp_flag<T>\n\n  ident_t *th_ident;\n  unsigned th_x; // Random number generator data\n  unsigned th_a; // Random number generator data\n\n  /* Tasking-related data for the thread */\n  kmp_task_team_t *th_task_team; // Task team struct\n  kmp_taskdata_t *th_current_task; // Innermost Task being executed\n  kmp_uint8 th_task_state; // alternating 0/1 for task team identification\n  kmp_uint8 *th_task_state_memo_stack; // Stack holding memos of th_task_state\n  // at nested levels\n  kmp_uint32 th_task_state_top; // Top element of th_task_state_memo_stack\n  kmp_uint32 th_task_state_stack_sz; // Size of th_task_state_memo_stack\n  kmp_uint32 th_reap_state; // Non-zero indicates thread is not\n  // tasking, thus safe to reap\n\n  /* More stuff for keeping track of active/sleeping threads (this part is\n     written by the worker thread) */\n  kmp_uint8 th_active_in_pool; // included in count of #active threads in pool\n  int th_active; // ! sleeping; 32 bits for TCR/TCW\n  struct cons_header *th_cons; // used for consistency check\n#if KMP_USE_HIER_SCHED\n  // used for hierarchical scheduling\n  kmp_hier_private_bdata_t *th_hier_bar_data;\n#endif\n\n  /* Add the syncronizing data which is cache aligned and padded. */\n  KMP_ALIGN_CACHE kmp_balign_t th_bar[bs_last_barrier];\n\n  KMP_ALIGN_CACHE volatile kmp_int32\n      th_next_waiting; /* gtid+1 of next thread on lock wait queue, 0 if none */\n\n#if (USE_FAST_MEMORY == 3) || (USE_FAST_MEMORY == 5)\n#define NUM_LISTS 4\n  kmp_free_list_t th_free_lists[NUM_LISTS]; // Free lists for fast memory\n// allocation routines\n#endif\n\n#if KMP_OS_WINDOWS\n  kmp_win32_cond_t th_suspend_cv;\n  kmp_win32_mutex_t th_suspend_mx;\n  std::atomic<int> th_suspend_init;\n#endif\n#if KMP_OS_UNIX\n  kmp_cond_align_t th_suspend_cv;\n  kmp_mutex_align_t th_suspend_mx;\n  std::atomic<int> th_suspend_init_count;\n#endif\n\n#if USE_ITT_BUILD\n  kmp_itt_mark_t th_itt_mark_single;\n// alignment ???\n#endif /* USE_ITT_BUILD */\n#if KMP_STATS_ENABLED\n  kmp_stats_list *th_stats;\n#endif\n#if KMP_OS_UNIX\n  std::atomic<bool> th_blocking;\n#endif\n  kmp_cg_root_t *th_cg_roots; // list of cg_roots associated with this thread\n} kmp_base_info_t;\n\ntypedef union KMP_ALIGN_CACHE kmp_info {\n  double th_align; /* use worst case alignment */\n  char th_pad[KMP_PAD(kmp_base_info_t, CACHE_LINE)];\n  kmp_base_info_t th;\n} kmp_info_t;\n\n// OpenMP thread team data structures\n\ntypedef struct kmp_base_data {\n  volatile kmp_uint32 t_value;\n} kmp_base_data_t;\n\ntypedef union KMP_ALIGN_CACHE kmp_sleep_team {\n  double dt_align; /* use worst case alignment */\n  char dt_pad[KMP_PAD(kmp_base_data_t, CACHE_LINE)];\n  kmp_base_data_t dt;\n} kmp_sleep_team_t;\n\ntypedef union KMP_ALIGN_CACHE kmp_ordered_team {\n  double dt_align; /* use worst case alignment */\n  char dt_pad[KMP_PAD(kmp_base_data_t, CACHE_LINE)];\n  kmp_base_data_t dt;\n} kmp_ordered_team_t;\n\ntypedef int (*launch_t)(int gtid);\n\n/* Minimum number of ARGV entries to malloc if necessary */\n#define KMP_MIN_MALLOC_ARGV_ENTRIES 100\n\n// Set up how many argv pointers will fit in cache lines containing\n// t_inline_argv. Historically, we have supported at least 96 bytes. Using a\n// larger value for more space between the primary write/worker read section and\n// read/write by all section seems to buy more performance on EPCC PARALLEL.\n#if KMP_ARCH_X86 || KMP_ARCH_X86_64\n#define KMP_INLINE_ARGV_BYTES                                                  \\\n  (4 * CACHE_LINE -                                                            \\\n   ((3 * KMP_PTR_SKIP + 2 * sizeof(int) + 2 * sizeof(kmp_int8) +               \\\n     sizeof(kmp_int16) + sizeof(kmp_uint32)) %                                 \\\n    CACHE_LINE))\n#else\n#define KMP_INLINE_ARGV_BYTES                                                  \\\n  (2 * CACHE_LINE - ((3 * KMP_PTR_SKIP + 2 * sizeof(int)) % CACHE_LINE))\n#endif\n#define KMP_INLINE_ARGV_ENTRIES (int)(KMP_INLINE_ARGV_BYTES / KMP_PTR_SKIP)\n\ntypedef struct KMP_ALIGN_CACHE kmp_base_team {\n  // Synchronization Data\n  // ---------------------------------------------------------------------------\n  KMP_ALIGN_CACHE kmp_ordered_team_t t_ordered;\n  kmp_balign_team_t t_bar[bs_last_barrier];\n  std::atomic<int> t_construct; // count of single directive encountered by team\n  char pad[sizeof(kmp_lock_t)]; // padding to maintain performance on big iron\n\n  // [0] - parallel / [1] - worksharing task reduction data shared by taskgroups\n  std::atomic<void *> t_tg_reduce_data[2]; // to support task modifier\n  std::atomic<int> t_tg_fini_counter[2]; // sync end of task reductions\n\n  // Primary thread only\n  // ---------------------------------------------------------------------------\n  KMP_ALIGN_CACHE int t_master_tid; // tid of primary thread in parent team\n  int t_master_this_cons; // \"this_construct\" single counter of primary thread\n  // in parent team\n  ident_t *t_ident; // if volatile, have to change too much other crud to\n  // volatile too\n  kmp_team_p *t_parent; // parent team\n  kmp_team_p *t_next_pool; // next free team in the team pool\n  kmp_disp_t *t_dispatch; // thread's dispatch data\n  kmp_task_team_t *t_task_team[2]; // Task team struct; switch between 2\n  kmp_proc_bind_t t_proc_bind; // bind type for par region\n#if USE_ITT_BUILD\n  kmp_uint64 t_region_time; // region begin timestamp\n#endif /* USE_ITT_BUILD */\n\n  // Primary thread write, workers read\n  // --------------------------------------------------------------------------\n  KMP_ALIGN_CACHE void **t_argv;\n  int t_argc;\n  int t_nproc; // number of threads in team\n  microtask_t t_pkfn;\n  launch_t t_invoke; // procedure to launch the microtask\n\n#if OMPT_SUPPORT\n  ompt_team_info_t ompt_team_info;\n  ompt_lw_taskteam_t *ompt_serialized_team_info;\n#endif\n\n#if KMP_ARCH_X86 || KMP_ARCH_X86_64\n  kmp_int8 t_fp_control_saved;\n  kmp_int8 t_pad2b;\n  kmp_int16 t_x87_fpu_control_word; // FP control regs\n  kmp_uint32 t_mxcsr;\n#endif /* KMP_ARCH_X86 || KMP_ARCH_X86_64 */\n\n  void *t_inline_argv[KMP_INLINE_ARGV_ENTRIES];\n\n  KMP_ALIGN_CACHE kmp_info_t **t_threads;\n  kmp_taskdata_t\n      *t_implicit_task_taskdata; // Taskdata for the thread's implicit task\n  int t_level; // nested parallel level\n\n  KMP_ALIGN_CACHE int t_max_argc;\n  int t_max_nproc; // max threads this team can handle (dynamically expandable)\n  int t_serialized; // levels deep of serialized teams\n  dispatch_shared_info_t *t_disp_buffer; // buffers for dispatch system\n  int t_id; // team's id, assigned by debugger.\n  int t_active_level; // nested active parallel level\n  kmp_r_sched_t t_sched; // run-time schedule for the team\n#if KMP_AFFINITY_SUPPORTED\n  int t_first_place; // first & last place in parent thread's partition.\n  int t_last_place; // Restore these values to primary thread after par region.\n#endif // KMP_AFFINITY_SUPPORTED\n  int t_display_affinity;\n  int t_size_changed; // team size was changed?: 0: no, 1: yes, -1: changed via\n  // omp_set_num_threads() call\n  omp_allocator_handle_t t_def_allocator; /* default allocator */\n\n// Read/write by workers as well\n#if (KMP_ARCH_X86 || KMP_ARCH_X86_64)\n  // Using CACHE_LINE=64 reduces memory footprint, but causes a big perf\n  // regression of epcc 'parallel' and 'barrier' on fxe256lin01. This extra\n  // padding serves to fix the performance of epcc 'parallel' and 'barrier' when\n  // CACHE_LINE=64. TODO: investigate more and get rid if this padding.\n  char dummy_padding[1024];\n#endif\n  // Internal control stack for additional nested teams.\n  KMP_ALIGN_CACHE kmp_internal_control_t *t_control_stack_top;\n  // for SERIALIZED teams nested 2 or more levels deep\n  // typed flag to store request state of cancellation\n  std::atomic<kmp_int32> t_cancel_request;\n  int t_master_active; // save on fork, restore on join\n  void *t_copypriv_data; // team specific pointer to copyprivate data array\n#if KMP_OS_WINDOWS\n  std::atomic<kmp_uint32> t_copyin_counter;\n#endif\n#if USE_ITT_BUILD\n  void *t_stack_id; // team specific stack stitching id (for ittnotify)\n#endif /* USE_ITT_BUILD */\n} kmp_base_team_t;\n\nunion KMP_ALIGN_CACHE kmp_team {\n  kmp_base_team_t t;\n  double t_align; /* use worst case alignment */\n  char t_pad[KMP_PAD(kmp_base_team_t, CACHE_LINE)];\n};\n\ntypedef union KMP_ALIGN_CACHE kmp_time_global {\n  double dt_align; /* use worst case alignment */\n  char dt_pad[KMP_PAD(kmp_base_data_t, CACHE_LINE)];\n  kmp_base_data_t dt;\n} kmp_time_global_t;\n\ntypedef struct kmp_base_global {\n  /* cache-aligned */\n  kmp_time_global_t g_time;\n\n  /* non cache-aligned */\n  volatile int g_abort;\n  volatile int g_done;\n\n  int g_dynamic;\n  enum dynamic_mode g_dynamic_mode;\n} kmp_base_global_t;\n\ntypedef union KMP_ALIGN_CACHE kmp_global {\n  kmp_base_global_t g;\n  double g_align; /* use worst case alignment */\n  char g_pad[KMP_PAD(kmp_base_global_t, CACHE_LINE)];\n} kmp_global_t;\n\ntypedef struct kmp_base_root {\n  // TODO: GEH - combine r_active with r_in_parallel then r_active ==\n  // (r_in_parallel>= 0)\n  // TODO: GEH - then replace r_active with t_active_levels if we can to reduce\n  // the synch overhead or keeping r_active\n  volatile int r_active; /* TRUE if some region in a nest has > 1 thread */\n  // keeps a count of active parallel regions per root\n  std::atomic<int> r_in_parallel;\n  // GEH: This is misnamed, should be r_active_levels\n  kmp_team_t *r_root_team;\n  kmp_team_t *r_hot_team;\n  kmp_info_t *r_uber_thread;\n  kmp_lock_t r_begin_lock;\n  volatile int r_begin;\n  int r_blocktime; /* blocktime for this root and descendants */\n} kmp_base_root_t;\n\ntypedef union KMP_ALIGN_CACHE kmp_root {\n  kmp_base_root_t r;\n  double r_align; /* use worst case alignment */\n  char r_pad[KMP_PAD(kmp_base_root_t, CACHE_LINE)];\n} kmp_root_t;\n\nstruct fortran_inx_info {\n  kmp_int32 data;\n};\n\n/* ------------------------------------------------------------------------ */\n\nextern int __kmp_settings;\nextern int __kmp_duplicate_library_ok;\n#if USE_ITT_BUILD\nextern int __kmp_forkjoin_frames;\nextern int __kmp_forkjoin_frames_mode;\n#endif\nextern PACKED_REDUCTION_METHOD_T __kmp_force_reduction_method;\nextern int __kmp_determ_red;\n\n#ifdef KMP_DEBUG\nextern int kmp_a_debug;\nextern int kmp_b_debug;\nextern int kmp_c_debug;\nextern int kmp_d_debug;\nextern int kmp_e_debug;\nextern int kmp_f_debug;\n#endif /* KMP_DEBUG */\n\n/* For debug information logging using rotating buffer */\n#define KMP_DEBUG_BUF_LINES_INIT 512\n#define KMP_DEBUG_BUF_LINES_MIN 1\n\n#define KMP_DEBUG_BUF_CHARS_INIT 128\n#define KMP_DEBUG_BUF_CHARS_MIN 2\n\nextern int\n    __kmp_debug_buf; /* TRUE means use buffer, FALSE means print to stderr */\nextern int __kmp_debug_buf_lines; /* How many lines of debug stored in buffer */\nextern int\n    __kmp_debug_buf_chars; /* How many characters allowed per line in buffer */\nextern int __kmp_debug_buf_atomic; /* TRUE means use atomic update of buffer\n                                      entry pointer */\n\nextern char *__kmp_debug_buffer; /* Debug buffer itself */\nextern std::atomic<int> __kmp_debug_count; /* Counter for number of lines\n                                              printed in buffer so far */\nextern int __kmp_debug_buf_warn_chars; /* Keep track of char increase\n                                          recommended in warnings */\n/* end rotating debug buffer */\n\n#ifdef KMP_DEBUG\nextern int __kmp_par_range; /* +1 => only go par for constructs in range */\n\n#define KMP_PAR_RANGE_ROUTINE_LEN 1024\nextern char __kmp_par_range_routine[KMP_PAR_RANGE_ROUTINE_LEN];\n#define KMP_PAR_RANGE_FILENAME_LEN 1024\nextern char __kmp_par_range_filename[KMP_PAR_RANGE_FILENAME_LEN];\nextern int __kmp_par_range_lb;\nextern int __kmp_par_range_ub;\n#endif\n\n/* For printing out dynamic storage map for threads and teams */\nextern int\n    __kmp_storage_map; /* True means print storage map for threads and teams */\nextern int __kmp_storage_map_verbose; /* True means storage map includes\n                                         placement info */\nextern int __kmp_storage_map_verbose_specified;\n\n#if KMP_ARCH_X86 || KMP_ARCH_X86_64\nextern kmp_cpuinfo_t __kmp_cpuinfo;\n#endif\n\nextern volatile int __kmp_init_serial;\nextern volatile int __kmp_init_gtid;\nextern volatile int __kmp_init_common;\nextern volatile int __kmp_init_middle;\nextern volatile int __kmp_init_parallel;\n#if KMP_USE_MONITOR\nextern volatile int __kmp_init_monitor;\n#endif\nextern volatile int __kmp_init_user_locks;\nextern volatile int __kmp_init_hidden_helper_threads;\nextern int __kmp_init_counter;\nextern int __kmp_root_counter;\nextern int __kmp_version;\n\n/* list of address of allocated caches for commons */\nextern kmp_cached_addr_t *__kmp_threadpriv_cache_list;\n\n/* Barrier algorithm types and options */\nextern kmp_uint32 __kmp_barrier_gather_bb_dflt;\nextern kmp_uint32 __kmp_barrier_release_bb_dflt;\nextern kmp_bar_pat_e __kmp_barrier_gather_pat_dflt;\nextern kmp_bar_pat_e __kmp_barrier_release_pat_dflt;\nextern kmp_uint32 __kmp_barrier_gather_branch_bits[bs_last_barrier];\nextern kmp_uint32 __kmp_barrier_release_branch_bits[bs_last_barrier];\nextern kmp_bar_pat_e __kmp_barrier_gather_pattern[bs_last_barrier];\nextern kmp_bar_pat_e __kmp_barrier_release_pattern[bs_last_barrier];\nextern char const *__kmp_barrier_branch_bit_env_name[bs_last_barrier];\nextern char const *__kmp_barrier_pattern_env_name[bs_last_barrier];\nextern char const *__kmp_barrier_type_name[bs_last_barrier];\nextern char const *__kmp_barrier_pattern_name[bp_last_bar];\n\n/* Global Locks */\nextern kmp_bootstrap_lock_t __kmp_initz_lock; /* control initialization */\nextern kmp_bootstrap_lock_t __kmp_forkjoin_lock; /* control fork/join access */\nextern kmp_bootstrap_lock_t __kmp_task_team_lock;\nextern kmp_bootstrap_lock_t\n    __kmp_exit_lock; /* exit() is not always thread-safe */\n#if KMP_USE_MONITOR\nextern kmp_bootstrap_lock_t\n    __kmp_monitor_lock; /* control monitor thread creation */\n#endif\nextern kmp_bootstrap_lock_t\n    __kmp_tp_cached_lock; /* used for the hack to allow threadprivate cache and\n                             __kmp_threads expansion to co-exist */\n\nextern kmp_lock_t __kmp_global_lock; /* control OS/global access  */\nextern kmp_queuing_lock_t __kmp_dispatch_lock; /* control dispatch access  */\nextern kmp_lock_t __kmp_debug_lock; /* control I/O access for KMP_DEBUG */\n\nextern enum library_type __kmp_library;\n\nextern enum sched_type __kmp_sched; /* default runtime scheduling */\nextern enum sched_type __kmp_static; /* default static scheduling method */\nextern enum sched_type __kmp_guided; /* default guided scheduling method */\nextern enum sched_type __kmp_auto; /* default auto scheduling method */\nextern int __kmp_chunk; /* default runtime chunk size */\nextern int __kmp_force_monotonic; /* whether monotonic scheduling forced */\n\nextern size_t __kmp_stksize; /* stack size per thread         */\n#if KMP_USE_MONITOR\nextern size_t __kmp_monitor_stksize; /* stack size for monitor thread */\n#endif\nextern size_t __kmp_stkoffset; /* stack offset per thread       */\nextern int __kmp_stkpadding; /* Should we pad root thread(s) stack */\n\nextern size_t\n    __kmp_malloc_pool_incr; /* incremental size of pool for kmp_malloc() */\nextern int __kmp_env_stksize; /* was KMP_STACKSIZE specified? */\nextern int __kmp_env_blocktime; /* was KMP_BLOCKTIME specified? */\nextern int __kmp_env_checks; /* was KMP_CHECKS specified?    */\nextern int __kmp_env_consistency_check; // was KMP_CONSISTENCY_CHECK specified?\nextern int __kmp_generate_warnings; /* should we issue warnings? */\nextern int __kmp_reserve_warn; /* have we issued reserve_threads warning? */\n\n#ifdef DEBUG_SUSPEND\nextern int __kmp_suspend_count; /* count inside __kmp_suspend_template() */\n#endif\n\nextern kmp_int32 __kmp_use_yield;\nextern kmp_int32 __kmp_use_yield_exp_set;\nextern kmp_uint32 __kmp_yield_init;\nextern kmp_uint32 __kmp_yield_next;\n\n/* ------------------------------------------------------------------------- */\nextern int __kmp_allThreadsSpecified;\n\nextern size_t __kmp_align_alloc;\n/* following data protected by initialization routines */\nextern int __kmp_xproc; /* number of processors in the system */\nextern int __kmp_avail_proc; /* number of processors available to the process */\nextern size_t __kmp_sys_min_stksize; /* system-defined minimum stack size */\nextern int __kmp_sys_max_nth; /* system-imposed maximum number of threads */\n// maximum total number of concurrently-existing threads on device\nextern int __kmp_max_nth;\n// maximum total number of concurrently-existing threads in a contention group\nextern int __kmp_cg_max_nth;\nextern int __kmp_teams_max_nth; // max threads used in a teams construct\nextern int __kmp_threads_capacity; /* capacity of the arrays __kmp_threads and\n                                      __kmp_root */\nextern int __kmp_dflt_team_nth; /* default number of threads in a parallel\n                                   region a la OMP_NUM_THREADS */\nextern int __kmp_dflt_team_nth_ub; /* upper bound on \"\" determined at serial\n                                      initialization */\nextern int __kmp_tp_capacity; /* capacity of __kmp_threads if threadprivate is\n                                 used (fixed) */\nextern int __kmp_tp_cached; /* whether threadprivate cache has been created\n                               (__kmpc_threadprivate_cached()) */\nextern int __kmp_dflt_blocktime; /* number of milliseconds to wait before\n                                    blocking (env setting) */\n#if KMP_USE_MONITOR\nextern int\n    __kmp_monitor_wakeups; /* number of times monitor wakes up per second */\nextern int __kmp_bt_intervals; /* number of monitor timestamp intervals before\n                                  blocking */\n#endif\n#ifdef KMP_ADJUST_BLOCKTIME\nextern int __kmp_zero_bt; /* whether blocktime has been forced to zero */\n#endif /* KMP_ADJUST_BLOCKTIME */\n#ifdef KMP_DFLT_NTH_CORES\nextern int __kmp_ncores; /* Total number of cores for threads placement */\n#endif\n/* Number of millisecs to delay on abort for Intel(R) VTune(TM) tools */\nextern int __kmp_abort_delay;\n\nextern int __kmp_need_register_atfork_specified;\nextern int __kmp_need_register_atfork; /* At initialization, call pthread_atfork\n                                          to install fork handler */\nextern int __kmp_gtid_mode; /* Method of getting gtid, values:\n                               0 - not set, will be set at runtime\n                               1 - using stack search\n                               2 - dynamic TLS (pthread_getspecific(Linux* OS/OS\n                                   X*) or TlsGetValue(Windows* OS))\n                               3 - static TLS (__declspec(thread) __kmp_gtid),\n                                   Linux* OS .so only.  */\nextern int\n    __kmp_adjust_gtid_mode; /* If true, adjust method based on #threads */\n#ifdef KMP_TDATA_GTID\nextern KMP_THREAD_LOCAL int __kmp_gtid;\n#endif\nextern int __kmp_tls_gtid_min; /* #threads below which use sp search for gtid */\nextern int __kmp_foreign_tp; // If true, separate TP var for each foreign thread\n#if KMP_ARCH_X86 || KMP_ARCH_X86_64\nextern int __kmp_inherit_fp_control; // copy fp creg(s) parent->workers at fork\nextern kmp_int16 __kmp_init_x87_fpu_control_word; // init thread's FP ctrl reg\nextern kmp_uint32 __kmp_init_mxcsr; /* init thread's mxscr */\n#endif /* KMP_ARCH_X86 || KMP_ARCH_X86_64 */\n\n// max_active_levels for nested parallelism enabled by default via\n// OMP_MAX_ACTIVE_LEVELS, OMP_NESTED, OMP_NUM_THREADS, and OMP_PROC_BIND\nextern int __kmp_dflt_max_active_levels;\n// Indicates whether value of __kmp_dflt_max_active_levels was already\n// explicitly set by OMP_MAX_ACTIVE_LEVELS or OMP_NESTED=false\nextern bool __kmp_dflt_max_active_levels_set;\nextern int __kmp_dispatch_num_buffers; /* max possible dynamic loops in\n                                          concurrent execution per team */\n#if KMP_NESTED_HOT_TEAMS\nextern int __kmp_hot_teams_mode;\nextern int __kmp_hot_teams_max_level;\n#endif\n\n#if KMP_OS_LINUX\nextern enum clock_function_type __kmp_clock_function;\nextern int __kmp_clock_function_param;\n#endif /* KMP_OS_LINUX */\n\n#if KMP_MIC_SUPPORTED\nextern enum mic_type __kmp_mic_type;\n#endif\n\n#ifdef USE_LOAD_BALANCE\nextern double __kmp_load_balance_interval; // load balance algorithm interval\n#endif /* USE_LOAD_BALANCE */\n\n// OpenMP 3.1 - Nested num threads array\ntypedef struct kmp_nested_nthreads_t {\n  int *nth;\n  int size;\n  int used;\n} kmp_nested_nthreads_t;\n\nextern kmp_nested_nthreads_t __kmp_nested_nth;\n\n#if KMP_USE_ADAPTIVE_LOCKS\n\n// Parameters for the speculative lock backoff system.\nstruct kmp_adaptive_backoff_params_t {\n  // Number of soft retries before it counts as a hard retry.\n  kmp_uint32 max_soft_retries;\n  // Badness is a bit mask : 0,1,3,7,15,... on each hard failure we move one to\n  // the right\n  kmp_uint32 max_badness;\n};\n\nextern kmp_adaptive_backoff_params_t __kmp_adaptive_backoff_params;\n\n#if KMP_DEBUG_ADAPTIVE_LOCKS\nextern const char *__kmp_speculative_statsfile;\n#endif\n\n#endif // KMP_USE_ADAPTIVE_LOCKS\n\nextern int __kmp_display_env; /* TRUE or FALSE */\nextern int __kmp_display_env_verbose; /* TRUE if OMP_DISPLAY_ENV=VERBOSE */\nextern int __kmp_omp_cancellation; /* TRUE or FALSE */\nextern int __kmp_nteams;\nextern int __kmp_teams_thread_limit;\n\n/* ------------------------------------------------------------------------- */\n\n/* the following are protected by the fork/join lock */\n/* write: lock  read: anytime */\nextern kmp_info_t **__kmp_threads; /* Descriptors for the threads */\n/* read/write: lock */\nextern volatile kmp_team_t *__kmp_team_pool;\nextern volatile kmp_info_t *__kmp_thread_pool;\nextern kmp_info_t *__kmp_thread_pool_insert_pt;\n\n// total num threads reachable from some root thread including all root threads\nextern volatile int __kmp_nth;\n/* total number of threads reachable from some root thread including all root\n   threads, and those in the thread pool */\nextern volatile int __kmp_all_nth;\nextern std::atomic<int> __kmp_thread_pool_active_nth;\n\nextern kmp_root_t **__kmp_root; /* root of thread hierarchy */\n/* end data protected by fork/join lock */\n/* ------------------------------------------------------------------------- */\n\n#define __kmp_get_gtid() __kmp_get_global_thread_id()\n#define __kmp_entry_gtid() __kmp_get_global_thread_id_reg()\n#define __kmp_get_tid() (__kmp_tid_from_gtid(__kmp_get_gtid()))\n#define __kmp_get_team() (__kmp_threads[(__kmp_get_gtid())]->th.th_team)\n#define __kmp_get_thread() (__kmp_thread_from_gtid(__kmp_get_gtid()))\n\n// AT: Which way is correct?\n// AT: 1. nproc = __kmp_threads[ ( gtid ) ] -> th.th_team -> t.t_nproc;\n// AT: 2. nproc = __kmp_threads[ ( gtid ) ] -> th.th_team_nproc;\n#define __kmp_get_team_num_threads(gtid)                                       \\\n  (__kmp_threads[(gtid)]->th.th_team->t.t_nproc)\n\nstatic inline bool KMP_UBER_GTID(int gtid) {\n  KMP_DEBUG_ASSERT(gtid >= KMP_GTID_MIN);\n  KMP_DEBUG_ASSERT(gtid < __kmp_threads_capacity);\n  return (gtid >= 0 && __kmp_root[gtid] && __kmp_threads[gtid] &&\n          __kmp_threads[gtid] == __kmp_root[gtid]->r.r_uber_thread);\n}\n\nstatic inline int __kmp_tid_from_gtid(int gtid) {\n  KMP_DEBUG_ASSERT(gtid >= 0);\n  return __kmp_threads[gtid]->th.th_info.ds.ds_tid;\n}\n\nstatic inline int __kmp_gtid_from_tid(int tid, const kmp_team_t *team) {\n  KMP_DEBUG_ASSERT(tid >= 0 && team);\n  return team->t.t_threads[tid]->th.th_info.ds.ds_gtid;\n}\n\nstatic inline int __kmp_gtid_from_thread(const kmp_info_t *thr) {\n  KMP_DEBUG_ASSERT(thr);\n  return thr->th.th_info.ds.ds_gtid;\n}\n\nstatic inline kmp_info_t *__kmp_thread_from_gtid(int gtid) {\n  KMP_DEBUG_ASSERT(gtid >= 0);\n  return __kmp_threads[gtid];\n}\n\nstatic inline kmp_team_t *__kmp_team_from_gtid(int gtid) {\n  KMP_DEBUG_ASSERT(gtid >= 0);\n  return __kmp_threads[gtid]->th.th_team;\n}\n\nstatic inline void __kmp_assert_valid_gtid(kmp_int32 gtid) {\n  if (UNLIKELY(gtid < 0 || gtid >= __kmp_threads_capacity))\n    KMP_FATAL(ThreadIdentInvalid);\n}\n\n#if KMP_HAVE_MWAIT || KMP_HAVE_UMWAIT\nextern int __kmp_user_level_mwait; // TRUE or FALSE; from KMP_USER_LEVEL_MWAIT\nextern int __kmp_umwait_enabled; // Runtime check if user-level mwait enabled\nextern int __kmp_mwait_enabled; // Runtime check if ring3 mwait is enabled\nextern int __kmp_mwait_hints; // Hints to pass in to mwait\n#endif\n\n/* ------------------------------------------------------------------------- */\n\nextern kmp_global_t __kmp_global; /* global status */\n\nextern kmp_info_t __kmp_monitor;\n// For Debugging Support Library\nextern std::atomic<kmp_int32> __kmp_team_counter;\n// For Debugging Support Library\nextern std::atomic<kmp_int32> __kmp_task_counter;\n\n#if USE_DEBUGGER\n#define _KMP_GEN_ID(counter)                                                   \\\n  (__kmp_debugging ? KMP_ATOMIC_INC(&counter) + 1 : ~0)\n#else\n#define _KMP_GEN_ID(counter) (~0)\n#endif /* USE_DEBUGGER */\n\n#define KMP_GEN_TASK_ID() _KMP_GEN_ID(__kmp_task_counter)\n#define KMP_GEN_TEAM_ID() _KMP_GEN_ID(__kmp_team_counter)\n\n/* ------------------------------------------------------------------------ */\n\nextern void __kmp_print_storage_map_gtid(int gtid, void *p1, void *p2,\n                                         size_t size, char const *format, ...);\n\nextern void __kmp_serial_initialize(void);\nextern void __kmp_middle_initialize(void);\nextern void __kmp_parallel_initialize(void);\n\nextern void __kmp_internal_begin(void);\nextern void __kmp_internal_end_library(int gtid);\nextern void __kmp_internal_end_thread(int gtid);\nextern void __kmp_internal_end_atexit(void);\nextern void __kmp_internal_end_dtor(void);\nextern void __kmp_internal_end_dest(void *);\n\nextern int __kmp_register_root(int initial_thread);\nextern void __kmp_unregister_root(int gtid);\nextern void __kmp_unregister_library(void); // called by __kmp_internal_end()\n\nextern int __kmp_ignore_mppbeg(void);\nextern int __kmp_ignore_mppend(void);\n\nextern int __kmp_enter_single(int gtid, ident_t *id_ref, int push_ws);\nextern void __kmp_exit_single(int gtid);\n\nextern void __kmp_parallel_deo(int *gtid_ref, int *cid_ref, ident_t *loc_ref);\nextern void __kmp_parallel_dxo(int *gtid_ref, int *cid_ref, ident_t *loc_ref);\n\n#ifdef USE_LOAD_BALANCE\nextern int __kmp_get_load_balance(int);\n#endif\n\nextern int __kmp_get_global_thread_id(void);\nextern int __kmp_get_global_thread_id_reg(void);\nextern void __kmp_exit_thread(int exit_status);\nextern void __kmp_abort(char const *format, ...);\nextern void __kmp_abort_thread(void);\nKMP_NORETURN extern void __kmp_abort_process(void);\nextern void __kmp_warn(char const *format, ...);\n\nextern void __kmp_set_num_threads(int new_nth, int gtid);\n\n// Returns current thread (pointer to kmp_info_t). Current thread *must* be\n// registered.\nstatic inline kmp_info_t *__kmp_entry_thread() {\n  int gtid = __kmp_entry_gtid();\n\n  return __kmp_threads[gtid];\n}\n\nextern void __kmp_set_max_active_levels(int gtid, int new_max_active_levels);\nextern int __kmp_get_max_active_levels(int gtid);\nextern int __kmp_get_ancestor_thread_num(int gtid, int level);\nextern int __kmp_get_team_size(int gtid, int level);\nextern void __kmp_set_schedule(int gtid, kmp_sched_t new_sched, int chunk);\nextern void __kmp_get_schedule(int gtid, kmp_sched_t *sched, int *chunk);\n\nextern unsigned short __kmp_get_random(kmp_info_t *thread);\nextern void __kmp_init_random(kmp_info_t *thread);\n\nextern kmp_r_sched_t __kmp_get_schedule_global(void);\nextern void __kmp_adjust_num_threads(int new_nproc);\nextern void __kmp_check_stksize(size_t *val);\n\nextern void *___kmp_allocate(size_t size KMP_SRC_LOC_DECL);\nextern void *___kmp_page_allocate(size_t size KMP_SRC_LOC_DECL);\nextern void ___kmp_free(void *ptr KMP_SRC_LOC_DECL);\n#define __kmp_allocate(size) ___kmp_allocate((size)KMP_SRC_LOC_CURR)\n#define __kmp_page_allocate(size) ___kmp_page_allocate((size)KMP_SRC_LOC_CURR)\n#define __kmp_free(ptr) ___kmp_free((ptr)KMP_SRC_LOC_CURR)\n\n#if USE_FAST_MEMORY\nextern void *___kmp_fast_allocate(kmp_info_t *this_thr,\n                                  size_t size KMP_SRC_LOC_DECL);\nextern void ___kmp_fast_free(kmp_info_t *this_thr, void *ptr KMP_SRC_LOC_DECL);\nextern void __kmp_free_fast_memory(kmp_info_t *this_thr);\nextern void __kmp_initialize_fast_memory(kmp_info_t *this_thr);\n#define __kmp_fast_allocate(this_thr, size)                                    \\\n  ___kmp_fast_allocate((this_thr), (size)KMP_SRC_LOC_CURR)\n#define __kmp_fast_free(this_thr, ptr)                                         \\\n  ___kmp_fast_free((this_thr), (ptr)KMP_SRC_LOC_CURR)\n#endif\n\nextern void *___kmp_thread_malloc(kmp_info_t *th, size_t size KMP_SRC_LOC_DECL);\nextern void *___kmp_thread_calloc(kmp_info_t *th, size_t nelem,\n                                  size_t elsize KMP_SRC_LOC_DECL);\nextern void *___kmp_thread_realloc(kmp_info_t *th, void *ptr,\n                                   size_t size KMP_SRC_LOC_DECL);\nextern void ___kmp_thread_free(kmp_info_t *th, void *ptr KMP_SRC_LOC_DECL);\n#define __kmp_thread_malloc(th, size)                                          \\\n  ___kmp_thread_malloc((th), (size)KMP_SRC_LOC_CURR)\n#define __kmp_thread_calloc(th, nelem, elsize)                                 \\\n  ___kmp_thread_calloc((th), (nelem), (elsize)KMP_SRC_LOC_CURR)\n#define __kmp_thread_realloc(th, ptr, size)                                    \\\n  ___kmp_thread_realloc((th), (ptr), (size)KMP_SRC_LOC_CURR)\n#define __kmp_thread_free(th, ptr)                                             \\\n  ___kmp_thread_free((th), (ptr)KMP_SRC_LOC_CURR)\n\n#define KMP_INTERNAL_MALLOC(sz) malloc(sz)\n#define KMP_INTERNAL_FREE(p) free(p)\n#define KMP_INTERNAL_REALLOC(p, sz) realloc((p), (sz))\n#define KMP_INTERNAL_CALLOC(n, sz) calloc((n), (sz))\n\nextern void __kmp_push_num_threads(ident_t *loc, int gtid, int num_threads);\n\nextern void __kmp_push_proc_bind(ident_t *loc, int gtid,\n                                 kmp_proc_bind_t proc_bind);\nextern void __kmp_push_num_teams(ident_t *loc, int gtid, int num_teams,\n                                 int num_threads);\nextern void __kmp_push_num_teams_51(ident_t *loc, int gtid, int num_teams_lb,\n                                    int num_teams_ub, int num_threads);\n\nextern void __kmp_yield();\n\nextern void __kmpc_dispatch_init_4(ident_t *loc, kmp_int32 gtid,\n                                   enum sched_type schedule, kmp_int32 lb,\n                                   kmp_int32 ub, kmp_int32 st, kmp_int32 chunk);\nextern void __kmpc_dispatch_init_4u(ident_t *loc, kmp_int32 gtid,\n                                    enum sched_type schedule, kmp_uint32 lb,\n                                    kmp_uint32 ub, kmp_int32 st,\n                                    kmp_int32 chunk);\nextern void __kmpc_dispatch_init_8(ident_t *loc, kmp_int32 gtid,\n                                   enum sched_type schedule, kmp_int64 lb,\n                                   kmp_int64 ub, kmp_int64 st, kmp_int64 chunk);\nextern void __kmpc_dispatch_init_8u(ident_t *loc, kmp_int32 gtid,\n                                    enum sched_type schedule, kmp_uint64 lb,\n                                    kmp_uint64 ub, kmp_int64 st,\n                                    kmp_int64 chunk);\n\nextern int __kmpc_dispatch_next_4(ident_t *loc, kmp_int32 gtid,\n                                  kmp_int32 *p_last, kmp_int32 *p_lb,\n                                  kmp_int32 *p_ub, kmp_int32 *p_st);\nextern int __kmpc_dispatch_next_4u(ident_t *loc, kmp_int32 gtid,\n                                   kmp_int32 *p_last, kmp_uint32 *p_lb,\n                                   kmp_uint32 *p_ub, kmp_int32 *p_st);\nextern int __kmpc_dispatch_next_8(ident_t *loc, kmp_int32 gtid,\n                                  kmp_int32 *p_last, kmp_int64 *p_lb,\n                                  kmp_int64 *p_ub, kmp_int64 *p_st);\nextern int __kmpc_dispatch_next_8u(ident_t *loc, kmp_int32 gtid,\n                                   kmp_int32 *p_last, kmp_uint64 *p_lb,\n                                   kmp_uint64 *p_ub, kmp_int64 *p_st);\n\nextern void __kmpc_dispatch_fini_4(ident_t *loc, kmp_int32 gtid);\nextern void __kmpc_dispatch_fini_8(ident_t *loc, kmp_int32 gtid);\nextern void __kmpc_dispatch_fini_4u(ident_t *loc, kmp_int32 gtid);\nextern void __kmpc_dispatch_fini_8u(ident_t *loc, kmp_int32 gtid);\n\n#ifdef KMP_GOMP_COMPAT\n\nextern void __kmp_aux_dispatch_init_4(ident_t *loc, kmp_int32 gtid,\n                                      enum sched_type schedule, kmp_int32 lb,\n                                      kmp_int32 ub, kmp_int32 st,\n                                      kmp_int32 chunk, int push_ws);\nextern void __kmp_aux_dispatch_init_4u(ident_t *loc, kmp_int32 gtid,\n                                       enum sched_type schedule, kmp_uint32 lb,\n                                       kmp_uint32 ub, kmp_int32 st,\n                                       kmp_int32 chunk, int push_ws);\nextern void __kmp_aux_dispatch_init_8(ident_t *loc, kmp_int32 gtid,\n                                      enum sched_type schedule, kmp_int64 lb,\n                                      kmp_int64 ub, kmp_int64 st,\n                                      kmp_int64 chunk, int push_ws);\nextern void __kmp_aux_dispatch_init_8u(ident_t *loc, kmp_int32 gtid,\n                                       enum sched_type schedule, kmp_uint64 lb,\n                                       kmp_uint64 ub, kmp_int64 st,\n                                       kmp_int64 chunk, int push_ws);\nextern void __kmp_aux_dispatch_fini_chunk_4(ident_t *loc, kmp_int32 gtid);\nextern void __kmp_aux_dispatch_fini_chunk_8(ident_t *loc, kmp_int32 gtid);\nextern void __kmp_aux_dispatch_fini_chunk_4u(ident_t *loc, kmp_int32 gtid);\nextern void __kmp_aux_dispatch_fini_chunk_8u(ident_t *loc, kmp_int32 gtid);\n\n#endif /* KMP_GOMP_COMPAT */\n\nextern kmp_uint32 __kmp_eq_4(kmp_uint32 value, kmp_uint32 checker);\nextern kmp_uint32 __kmp_neq_4(kmp_uint32 value, kmp_uint32 checker);\nextern kmp_uint32 __kmp_lt_4(kmp_uint32 value, kmp_uint32 checker);\nextern kmp_uint32 __kmp_ge_4(kmp_uint32 value, kmp_uint32 checker);\nextern kmp_uint32 __kmp_le_4(kmp_uint32 value, kmp_uint32 checker);\nextern kmp_uint32 __kmp_wait_4(kmp_uint32 volatile *spinner, kmp_uint32 checker,\n                               kmp_uint32 (*pred)(kmp_uint32, kmp_uint32),\n                               void *obj);\nextern void __kmp_wait_4_ptr(void *spinner, kmp_uint32 checker,\n                             kmp_uint32 (*pred)(void *, kmp_uint32), void *obj);\n\nextern void __kmp_wait_64(kmp_info_t *this_thr, kmp_flag_64<> *flag,\n                          int final_spin\n#if USE_ITT_BUILD\n                          ,\n                          void *itt_sync_obj\n#endif\n);\nextern void __kmp_release_64(kmp_flag_64<> *flag);\n\nextern void __kmp_infinite_loop(void);\n\nextern void __kmp_cleanup(void);\n\n#if KMP_HANDLE_SIGNALS\nextern int __kmp_handle_signals;\nextern void __kmp_install_signals(int parallel_init);\nextern void __kmp_remove_signals(void);\n#endif\n\nextern void __kmp_clear_system_time(void);\nextern void __kmp_read_system_time(double *delta);\n\nextern void __kmp_check_stack_overlap(kmp_info_t *thr);\n\nextern void __kmp_expand_host_name(char *buffer, size_t size);\nextern void __kmp_expand_file_name(char *result, size_t rlen, char *pattern);\n\n#if KMP_ARCH_X86 || KMP_ARCH_X86_64\nextern void\n__kmp_initialize_system_tick(void); /* Initialize timer tick value */\n#endif\n\nextern void\n__kmp_runtime_initialize(void); /* machine specific initialization */\nextern void __kmp_runtime_destroy(void);\n\n#if KMP_AFFINITY_SUPPORTED\nextern char *__kmp_affinity_print_mask(char *buf, int buf_len,\n                                       kmp_affin_mask_t *mask);\nextern kmp_str_buf_t *__kmp_affinity_str_buf_mask(kmp_str_buf_t *buf,\n                                                  kmp_affin_mask_t *mask);\nextern void __kmp_affinity_initialize(void);\nextern void __kmp_affinity_uninitialize(void);\nextern void __kmp_affinity_set_init_mask(\n    int gtid, int isa_root); /* set affinity according to KMP_AFFINITY */\nextern void __kmp_affinity_set_place(int gtid);\nextern void __kmp_affinity_determine_capable(const char *env_var);\nextern int __kmp_aux_set_affinity(void **mask);\nextern int __kmp_aux_get_affinity(void **mask);\nextern int __kmp_aux_get_affinity_max_proc();\nextern int __kmp_aux_set_affinity_mask_proc(int proc, void **mask);\nextern int __kmp_aux_unset_affinity_mask_proc(int proc, void **mask);\nextern int __kmp_aux_get_affinity_mask_proc(int proc, void **mask);\nextern void __kmp_balanced_affinity(kmp_info_t *th, int team_size);\n#if KMP_OS_LINUX || KMP_OS_FREEBSD\nextern int kmp_set_thread_affinity_mask_initial(void);\n#endif\n#endif /* KMP_AFFINITY_SUPPORTED */\n// No need for KMP_AFFINITY_SUPPORTED guard as only one field in the\n// format string is for affinity, so platforms that do not support\n// affinity can still use the other fields, e.g., %n for num_threads\nextern size_t __kmp_aux_capture_affinity(int gtid, const char *format,\n                                         kmp_str_buf_t *buffer);\nextern void __kmp_aux_display_affinity(int gtid, const char *format);\n\nextern void __kmp_cleanup_hierarchy();\nextern void __kmp_get_hierarchy(kmp_uint32 nproc, kmp_bstate_t *thr_bar);\n\n#if KMP_USE_FUTEX\n\nextern int __kmp_futex_determine_capable(void);\n\n#endif // KMP_USE_FUTEX\n\nextern void __kmp_gtid_set_specific(int gtid);\nextern int __kmp_gtid_get_specific(void);\n\nextern double __kmp_read_cpu_time(void);\n\nextern int __kmp_read_system_info(struct kmp_sys_info *info);\n\n#if KMP_USE_MONITOR\nextern void __kmp_create_monitor(kmp_info_t *th);\n#endif\n\nextern void *__kmp_launch_thread(kmp_info_t *thr);\n\nextern void __kmp_create_worker(int gtid, kmp_info_t *th, size_t stack_size);\n\n#if KMP_OS_WINDOWS\nextern int __kmp_still_running(kmp_info_t *th);\nextern int __kmp_is_thread_alive(kmp_info_t *th, DWORD *exit_val);\nextern void __kmp_free_handle(kmp_thread_t tHandle);\n#endif\n\n#if KMP_USE_MONITOR\nextern void __kmp_reap_monitor(kmp_info_t *th);\n#endif\nextern void __kmp_reap_worker(kmp_info_t *th);\nextern void __kmp_terminate_thread(int gtid);\n\nextern int __kmp_try_suspend_mx(kmp_info_t *th);\nextern void __kmp_lock_suspend_mx(kmp_info_t *th);\nextern void __kmp_unlock_suspend_mx(kmp_info_t *th);\n\nextern void __kmp_elapsed(double *);\nextern void __kmp_elapsed_tick(double *);\n\nextern void __kmp_enable(int old_state);\nextern void __kmp_disable(int *old_state);\n\nextern void __kmp_thread_sleep(int millis);\n\nextern void __kmp_common_initialize(void);\nextern void __kmp_common_destroy(void);\nextern void __kmp_common_destroy_gtid(int gtid);\n\n#if KMP_OS_UNIX\nextern void __kmp_register_atfork(void);\n#endif\nextern void __kmp_suspend_initialize(void);\nextern void __kmp_suspend_initialize_thread(kmp_info_t *th);\nextern void __kmp_suspend_uninitialize_thread(kmp_info_t *th);\n\nextern kmp_info_t *__kmp_allocate_thread(kmp_root_t *root, kmp_team_t *team,\n                                         int tid);\nextern kmp_team_t *\n__kmp_allocate_team(kmp_root_t *root, int new_nproc, int max_nproc,\n#if OMPT_SUPPORT\n                    ompt_data_t ompt_parallel_data,\n#endif\n                    kmp_proc_bind_t proc_bind, kmp_internal_control_t *new_icvs,\n                    int argc USE_NESTED_HOT_ARG(kmp_info_t *thr));\nextern void __kmp_free_thread(kmp_info_t *);\nextern void __kmp_free_team(kmp_root_t *,\n                            kmp_team_t *USE_NESTED_HOT_ARG(kmp_info_t *));\nextern kmp_team_t *__kmp_reap_team(kmp_team_t *);\n\n/* ------------------------------------------------------------------------ */\n\nextern void __kmp_initialize_bget(kmp_info_t *th);\nextern void __kmp_finalize_bget(kmp_info_t *th);\n\nKMP_EXPORT void *kmpc_malloc(size_t size);\nKMP_EXPORT void *kmpc_aligned_malloc(size_t size, size_t alignment);\nKMP_EXPORT void *kmpc_calloc(size_t nelem, size_t elsize);\nKMP_EXPORT void *kmpc_realloc(void *ptr, size_t size);\nKMP_EXPORT void kmpc_free(void *ptr);\n\n/* declarations for internal use */\n\nextern int __kmp_barrier(enum barrier_type bt, int gtid, int is_split,\n                         size_t reduce_size, void *reduce_data,\n                         void (*reduce)(void *, void *));\nextern void __kmp_end_split_barrier(enum barrier_type bt, int gtid);\nextern int __kmp_barrier_gomp_cancel(int gtid);\n\n/*!\n * Tell the fork call which compiler generated the fork call, and therefore how\n * to deal with the call.\n */\nenum fork_context_e {\n  fork_context_gnu, /**< Called from GNU generated code, so must not invoke the\n                       microtask internally. */\n  fork_context_intel, /**< Called from Intel generated code.  */\n  fork_context_last\n};\nextern int __kmp_fork_call(ident_t *loc, int gtid,\n                           enum fork_context_e fork_context, kmp_int32 argc,\n                           microtask_t microtask, launch_t invoker,\n                           kmp_va_list ap);\n\nextern void __kmp_join_call(ident_t *loc, int gtid\n#if OMPT_SUPPORT\n                            ,\n                            enum fork_context_e fork_context\n#endif\n                            ,\n                            int exit_teams = 0);\n\nextern void __kmp_serialized_parallel(ident_t *id, kmp_int32 gtid);\nextern void __kmp_internal_fork(ident_t *id, int gtid, kmp_team_t *team);\nextern void __kmp_internal_join(ident_t *id, int gtid, kmp_team_t *team);\nextern int __kmp_invoke_task_func(int gtid);\nextern void __kmp_run_before_invoked_task(int gtid, int tid,\n                                          kmp_info_t *this_thr,\n                                          kmp_team_t *team);\nextern void __kmp_run_after_invoked_task(int gtid, int tid,\n                                         kmp_info_t *this_thr,\n                                         kmp_team_t *team);\n\n// should never have been exported\nKMP_EXPORT int __kmpc_invoke_task_func(int gtid);\nextern int __kmp_invoke_teams_master(int gtid);\nextern void __kmp_teams_master(int gtid);\nextern int __kmp_aux_get_team_num();\nextern int __kmp_aux_get_num_teams();\nextern void __kmp_save_internal_controls(kmp_info_t *thread);\nextern void __kmp_user_set_library(enum library_type arg);\nextern void __kmp_aux_set_library(enum library_type arg);\nextern void __kmp_aux_set_stacksize(size_t arg);\nextern void __kmp_aux_set_blocktime(int arg, kmp_info_t *thread, int tid);\nextern void __kmp_aux_set_defaults(char const *str, size_t len);\n\n/* Functions called from __kmp_aux_env_initialize() in kmp_settings.cpp */\nvoid kmpc_set_blocktime(int arg);\nvoid ompc_set_nested(int flag);\nvoid ompc_set_dynamic(int flag);\nvoid ompc_set_num_threads(int arg);\n\nextern void __kmp_push_current_task_to_thread(kmp_info_t *this_thr,\n                                              kmp_team_t *team, int tid);\nextern void __kmp_pop_current_task_from_thread(kmp_info_t *this_thr);\nextern kmp_task_t *__kmp_task_alloc(ident_t *loc_ref, kmp_int32 gtid,\n                                    kmp_tasking_flags_t *flags,\n                                    size_t sizeof_kmp_task_t,\n                                    size_t sizeof_shareds,\n                                    kmp_routine_entry_t task_entry);\nextern void __kmp_init_implicit_task(ident_t *loc_ref, kmp_info_t *this_thr,\n                                     kmp_team_t *team, int tid,\n                                     int set_curr_task);\nextern void __kmp_finish_implicit_task(kmp_info_t *this_thr);\nextern void __kmp_free_implicit_task(kmp_info_t *this_thr);\n\nextern kmp_event_t *__kmpc_task_allow_completion_event(ident_t *loc_ref,\n                                                       int gtid,\n                                                       kmp_task_t *task);\nextern void __kmp_fulfill_event(kmp_event_t *event);\n\nextern void __kmp_free_task_team(kmp_info_t *thread,\n                                 kmp_task_team_t *task_team);\nextern void __kmp_reap_task_teams(void);\nextern void __kmp_wait_to_unref_task_teams(void);\nextern void __kmp_task_team_setup(kmp_info_t *this_thr, kmp_team_t *team,\n                                  int always);\nextern void __kmp_task_team_sync(kmp_info_t *this_thr, kmp_team_t *team);\nextern void __kmp_task_team_wait(kmp_info_t *this_thr, kmp_team_t *team\n#if USE_ITT_BUILD\n                                 ,\n                                 void *itt_sync_obj\n#endif /* USE_ITT_BUILD */\n                                 ,\n                                 int wait = 1);\nextern void __kmp_tasking_barrier(kmp_team_t *team, kmp_info_t *thread,\n                                  int gtid);\n\nextern int __kmp_is_address_mapped(void *addr);\nextern kmp_uint64 __kmp_hardware_timestamp(void);\n\n#if KMP_OS_UNIX\nextern int __kmp_read_from_file(char const *path, char const *format, ...);\n#endif\n\n/* ------------------------------------------------------------------------ */\n//\n// Assembly routines that have no compiler intrinsic replacement\n//\n\nextern int __kmp_invoke_microtask(microtask_t pkfn, int gtid, int npr, int argc,\n                                  void *argv[]\n#if OMPT_SUPPORT\n                                  ,\n                                  void **exit_frame_ptr\n#endif\n);\n\n/* ------------------------------------------------------------------------ */\n\nKMP_EXPORT void __kmpc_begin(ident_t *, kmp_int32 flags);\nKMP_EXPORT void __kmpc_end(ident_t *);\n\nKMP_EXPORT void __kmpc_threadprivate_register_vec(ident_t *, void *data,\n                                                  kmpc_ctor_vec ctor,\n                                                  kmpc_cctor_vec cctor,\n                                                  kmpc_dtor_vec dtor,\n                                                  size_t vector_length);\nKMP_EXPORT void __kmpc_threadprivate_register(ident_t *, void *data,\n                                              kmpc_ctor ctor, kmpc_cctor cctor,\n                                              kmpc_dtor dtor);\nKMP_EXPORT void *__kmpc_threadprivate(ident_t *, kmp_int32 global_tid,\n                                      void *data, size_t size);\n\nKMP_EXPORT kmp_int32 __kmpc_global_thread_num(ident_t *);\nKMP_EXPORT kmp_int32 __kmpc_global_num_threads(ident_t *);\nKMP_EXPORT kmp_int32 __kmpc_bound_thread_num(ident_t *);\nKMP_EXPORT kmp_int32 __kmpc_bound_num_threads(ident_t *);\n\nKMP_EXPORT kmp_int32 __kmpc_ok_to_fork(ident_t *);\nKMP_EXPORT void __kmpc_fork_call(ident_t *, kmp_int32 nargs,\n                                 kmpc_micro microtask, ...);\n\nKMP_EXPORT void __kmpc_serialized_parallel(ident_t *, kmp_int32 global_tid);\nKMP_EXPORT void __kmpc_end_serialized_parallel(ident_t *, kmp_int32 global_tid);\n\nKMP_EXPORT void __kmpc_flush(ident_t *);\nKMP_EXPORT void __kmpc_barrier(ident_t *, kmp_int32 global_tid);\nKMP_EXPORT kmp_int32 __kmpc_master(ident_t *, kmp_int32 global_tid);\nKMP_EXPORT void __kmpc_end_master(ident_t *, kmp_int32 global_tid);\nKMP_EXPORT kmp_int32 __kmpc_masked(ident_t *, kmp_int32 global_tid,\n                                   kmp_int32 filter);\nKMP_EXPORT void __kmpc_end_masked(ident_t *, kmp_int32 global_tid);\nKMP_EXPORT void __kmpc_ordered(ident_t *, kmp_int32 global_tid);\nKMP_EXPORT void __kmpc_end_ordered(ident_t *, kmp_int32 global_tid);\nKMP_EXPORT void __kmpc_critical(ident_t *, kmp_int32 global_tid,\n                                kmp_critical_name *);\nKMP_EXPORT void __kmpc_end_critical(ident_t *, kmp_int32 global_tid,\n                                    kmp_critical_name *);\nKMP_EXPORT void __kmpc_critical_with_hint(ident_t *, kmp_int32 global_tid,\n                                          kmp_critical_name *, uint32_t hint);\n\nKMP_EXPORT kmp_int32 __kmpc_barrier_master(ident_t *, kmp_int32 global_tid);\nKMP_EXPORT void __kmpc_end_barrier_master(ident_t *, kmp_int32 global_tid);\n\nKMP_EXPORT kmp_int32 __kmpc_barrier_master_nowait(ident_t *,\n                                                  kmp_int32 global_tid);\n\nKMP_EXPORT kmp_int32 __kmpc_single(ident_t *, kmp_int32 global_tid);\nKMP_EXPORT void __kmpc_end_single(ident_t *, kmp_int32 global_tid);\n\nKMP_EXPORT void KMPC_FOR_STATIC_INIT(ident_t *loc, kmp_int32 global_tid,\n                                     kmp_int32 schedtype, kmp_int32 *plastiter,\n                                     kmp_int *plower, kmp_int *pupper,\n                                     kmp_int *pstride, kmp_int incr,\n                                     kmp_int chunk);\n\nKMP_EXPORT void __kmpc_for_static_fini(ident_t *loc, kmp_int32 global_tid);\n\nKMP_EXPORT void __kmpc_copyprivate(ident_t *loc, kmp_int32 global_tid,\n                                   size_t cpy_size, void *cpy_data,\n                                   void (*cpy_func)(void *, void *),\n                                   kmp_int32 didit);\n\nextern void KMPC_SET_NUM_THREADS(int arg);\nextern void KMPC_SET_DYNAMIC(int flag);\nextern void KMPC_SET_NESTED(int flag);\n\n/* OMP 3.0 tasking interface routines */\nKMP_EXPORT kmp_int32 __kmpc_omp_task(ident_t *loc_ref, kmp_int32 gtid,\n                                     kmp_task_t *new_task);\nKMP_EXPORT kmp_task_t *__kmpc_omp_task_alloc(ident_t *loc_ref, kmp_int32 gtid,\n                                             kmp_int32 flags,\n                                             size_t sizeof_kmp_task_t,\n                                             size_t sizeof_shareds,\n                                             kmp_routine_entry_t task_entry);\nKMP_EXPORT kmp_task_t *__kmpc_omp_target_task_alloc(\n    ident_t *loc_ref, kmp_int32 gtid, kmp_int32 flags, size_t sizeof_kmp_task_t,\n    size_t sizeof_shareds, kmp_routine_entry_t task_entry, kmp_int64 device_id);\nKMP_EXPORT void __kmpc_omp_task_begin_if0(ident_t *loc_ref, kmp_int32 gtid,\n                                          kmp_task_t *task);\nKMP_EXPORT void __kmpc_omp_task_complete_if0(ident_t *loc_ref, kmp_int32 gtid,\n                                             kmp_task_t *task);\nKMP_EXPORT kmp_int32 __kmpc_omp_task_parts(ident_t *loc_ref, kmp_int32 gtid,\n                                           kmp_task_t *new_task);\nKMP_EXPORT kmp_int32 __kmpc_omp_taskwait(ident_t *loc_ref, kmp_int32 gtid);\n\nKMP_EXPORT kmp_int32 __kmpc_omp_taskyield(ident_t *loc_ref, kmp_int32 gtid,\n                                          int end_part);\n\n#if TASK_UNUSED\nvoid __kmpc_omp_task_begin(ident_t *loc_ref, kmp_int32 gtid, kmp_task_t *task);\nvoid __kmpc_omp_task_complete(ident_t *loc_ref, kmp_int32 gtid,\n                              kmp_task_t *task);\n#endif // TASK_UNUSED\n\n/* ------------------------------------------------------------------------ */\n\nKMP_EXPORT void __kmpc_taskgroup(ident_t *loc, int gtid);\nKMP_EXPORT void __kmpc_end_taskgroup(ident_t *loc, int gtid);\n\nKMP_EXPORT kmp_int32 __kmpc_omp_task_with_deps(\n    ident_t *loc_ref, kmp_int32 gtid, kmp_task_t *new_task, kmp_int32 ndeps,\n    kmp_depend_info_t *dep_list, kmp_int32 ndeps_noalias,\n    kmp_depend_info_t *noalias_dep_list);\nKMP_EXPORT void __kmpc_omp_wait_deps(ident_t *loc_ref, kmp_int32 gtid,\n                                     kmp_int32 ndeps,\n                                     kmp_depend_info_t *dep_list,\n                                     kmp_int32 ndeps_noalias,\n                                     kmp_depend_info_t *noalias_dep_list);\nextern kmp_int32 __kmp_omp_task(kmp_int32 gtid, kmp_task_t *new_task,\n                                bool serialize_immediate);\n\nKMP_EXPORT kmp_int32 __kmpc_cancel(ident_t *loc_ref, kmp_int32 gtid,\n                                   kmp_int32 cncl_kind);\nKMP_EXPORT kmp_int32 __kmpc_cancellationpoint(ident_t *loc_ref, kmp_int32 gtid,\n                                              kmp_int32 cncl_kind);\nKMP_EXPORT kmp_int32 __kmpc_cancel_barrier(ident_t *loc_ref, kmp_int32 gtid);\nKMP_EXPORT int __kmp_get_cancellation_status(int cancel_kind);\n\nKMP_EXPORT void __kmpc_proxy_task_completed(kmp_int32 gtid, kmp_task_t *ptask);\nKMP_EXPORT void __kmpc_proxy_task_completed_ooo(kmp_task_t *ptask);\nKMP_EXPORT void __kmpc_taskloop(ident_t *loc, kmp_int32 gtid, kmp_task_t *task,\n                                kmp_int32 if_val, kmp_uint64 *lb,\n                                kmp_uint64 *ub, kmp_int64 st, kmp_int32 nogroup,\n                                kmp_int32 sched, kmp_uint64 grainsize,\n                                void *task_dup);\nKMP_EXPORT void __kmpc_taskloop_5(ident_t *loc, kmp_int32 gtid,\n                                  kmp_task_t *task, kmp_int32 if_val,\n                                  kmp_uint64 *lb, kmp_uint64 *ub, kmp_int64 st,\n                                  kmp_int32 nogroup, kmp_int32 sched,\n                                  kmp_uint64 grainsize, kmp_int32 modifier,\n                                  void *task_dup);\nKMP_EXPORT void *__kmpc_task_reduction_init(int gtid, int num_data, void *data);\nKMP_EXPORT void *__kmpc_taskred_init(int gtid, int num_data, void *data);\nKMP_EXPORT void *__kmpc_task_reduction_get_th_data(int gtid, void *tg, void *d);\nKMP_EXPORT void *__kmpc_task_reduction_modifier_init(ident_t *loc, int gtid,\n                                                     int is_ws, int num,\n                                                     void *data);\nKMP_EXPORT void *__kmpc_taskred_modifier_init(ident_t *loc, int gtid, int is_ws,\n                                              int num, void *data);\nKMP_EXPORT void __kmpc_task_reduction_modifier_fini(ident_t *loc, int gtid,\n                                                    int is_ws);\nKMP_EXPORT kmp_int32 __kmpc_omp_reg_task_with_affinity(\n    ident_t *loc_ref, kmp_int32 gtid, kmp_task_t *new_task, kmp_int32 naffins,\n    kmp_task_affinity_info_t *affin_list);\nKMP_EXPORT void __kmp_set_num_teams(int num_teams);\nKMP_EXPORT int __kmp_get_max_teams(void);\nKMP_EXPORT void __kmp_set_teams_thread_limit(int limit);\nKMP_EXPORT int __kmp_get_teams_thread_limit(void);\n\n/* Lock interface routines (fast versions with gtid passed in) */\nKMP_EXPORT void __kmpc_init_lock(ident_t *loc, kmp_int32 gtid,\n                                 void **user_lock);\nKMP_EXPORT void __kmpc_init_nest_lock(ident_t *loc, kmp_int32 gtid,\n                                      void **user_lock);\nKMP_EXPORT void __kmpc_destroy_lock(ident_t *loc, kmp_int32 gtid,\n                                    void **user_lock);\nKMP_EXPORT void __kmpc_destroy_nest_lock(ident_t *loc, kmp_int32 gtid,\n                                         void **user_lock);\nKMP_EXPORT void __kmpc_set_lock(ident_t *loc, kmp_int32 gtid, void **user_lock);\nKMP_EXPORT void __kmpc_set_nest_lock(ident_t *loc, kmp_int32 gtid,\n                                     void **user_lock);\nKMP_EXPORT void __kmpc_unset_lock(ident_t *loc, kmp_int32 gtid,\n                                  void **user_lock);\nKMP_EXPORT void __kmpc_unset_nest_lock(ident_t *loc, kmp_int32 gtid,\n                                       void **user_lock);\nKMP_EXPORT int __kmpc_test_lock(ident_t *loc, kmp_int32 gtid, void **user_lock);\nKMP_EXPORT int __kmpc_test_nest_lock(ident_t *loc, kmp_int32 gtid,\n                                     void **user_lock);\n\nKMP_EXPORT void __kmpc_init_lock_with_hint(ident_t *loc, kmp_int32 gtid,\n                                           void **user_lock, uintptr_t hint);\nKMP_EXPORT void __kmpc_init_nest_lock_with_hint(ident_t *loc, kmp_int32 gtid,\n                                                void **user_lock,\n                                                uintptr_t hint);\n\n/* Interface to fast scalable reduce methods routines */\n\nKMP_EXPORT kmp_int32 __kmpc_reduce_nowait(\n    ident_t *loc, kmp_int32 global_tid, kmp_int32 num_vars, size_t reduce_size,\n    void *reduce_data, void (*reduce_func)(void *lhs_data, void *rhs_data),\n    kmp_critical_name *lck);\nKMP_EXPORT void __kmpc_end_reduce_nowait(ident_t *loc, kmp_int32 global_tid,\n                                         kmp_critical_name *lck);\nKMP_EXPORT kmp_int32 __kmpc_reduce(\n    ident_t *loc, kmp_int32 global_tid, kmp_int32 num_vars, size_t reduce_size,\n    void *reduce_data, void (*reduce_func)(void *lhs_data, void *rhs_data),\n    kmp_critical_name *lck);\nKMP_EXPORT void __kmpc_end_reduce(ident_t *loc, kmp_int32 global_tid,\n                                  kmp_critical_name *lck);\n\n/* Internal fast reduction routines */\n\nextern PACKED_REDUCTION_METHOD_T __kmp_determine_reduction_method(\n    ident_t *loc, kmp_int32 global_tid, kmp_int32 num_vars, size_t reduce_size,\n    void *reduce_data, void (*reduce_func)(void *lhs_data, void *rhs_data),\n    kmp_critical_name *lck);\n\n// this function is for testing set/get/determine reduce method\nKMP_EXPORT kmp_int32 __kmp_get_reduce_method(void);\n\nKMP_EXPORT kmp_uint64 __kmpc_get_taskid();\nKMP_EXPORT kmp_uint64 __kmpc_get_parent_taskid();\n\n// C++ port\n// missing 'extern \"C\"' declarations\n\nKMP_EXPORT kmp_int32 __kmpc_in_parallel(ident_t *loc);\nKMP_EXPORT void __kmpc_pop_num_threads(ident_t *loc, kmp_int32 global_tid);\nKMP_EXPORT void __kmpc_push_num_threads(ident_t *loc, kmp_int32 global_tid,\n                                        kmp_int32 num_threads);\n\nKMP_EXPORT void __kmpc_push_proc_bind(ident_t *loc, kmp_int32 global_tid,\n                                      int proc_bind);\nKMP_EXPORT void __kmpc_push_num_teams(ident_t *loc, kmp_int32 global_tid,\n                                      kmp_int32 num_teams,\n                                      kmp_int32 num_threads);\n/* Function for OpenMP 5.1 num_teams clause */\nKMP_EXPORT void __kmpc_push_num_teams_51(ident_t *loc, kmp_int32 global_tid,\n                                         kmp_int32 num_teams_lb,\n                                         kmp_int32 num_teams_ub,\n                                         kmp_int32 num_threads);\nKMP_EXPORT void __kmpc_fork_teams(ident_t *loc, kmp_int32 argc,\n                                  kmpc_micro microtask, ...);\nstruct kmp_dim { // loop bounds info casted to kmp_int64\n  kmp_int64 lo; // lower\n  kmp_int64 up; // upper\n  kmp_int64 st; // stride\n};\nKMP_EXPORT void __kmpc_doacross_init(ident_t *loc, kmp_int32 gtid,\n                                     kmp_int32 num_dims,\n                                     const struct kmp_dim *dims);\nKMP_EXPORT void __kmpc_doacross_wait(ident_t *loc, kmp_int32 gtid,\n                                     const kmp_int64 *vec);\nKMP_EXPORT void __kmpc_doacross_post(ident_t *loc, kmp_int32 gtid,\n                                     const kmp_int64 *vec);\nKMP_EXPORT void __kmpc_doacross_fini(ident_t *loc, kmp_int32 gtid);\n\nKMP_EXPORT void *__kmpc_threadprivate_cached(ident_t *loc, kmp_int32 global_tid,\n                                             void *data, size_t size,\n                                             void ***cache);\n\n// Symbols for MS mutual detection.\nextern int _You_must_link_with_exactly_one_OpenMP_library;\nextern int _You_must_link_with_Intel_OpenMP_library;\n#if KMP_OS_WINDOWS && (KMP_VERSION_MAJOR > 4)\nextern int _You_must_link_with_Microsoft_OpenMP_library;\n#endif\n\n// The routines below are not exported.\n// Consider making them 'static' in corresponding source files.\nvoid kmp_threadprivate_insert_private_data(int gtid, void *pc_addr,\n                                           void *data_addr, size_t pc_size);\nstruct private_common *kmp_threadprivate_insert(int gtid, void *pc_addr,\n                                                void *data_addr,\n                                                size_t pc_size);\nvoid __kmp_threadprivate_resize_cache(int newCapacity);\nvoid __kmp_cleanup_threadprivate_caches();\n\n// ompc_, kmpc_ entries moved from omp.h.\n#if KMP_OS_WINDOWS\n#define KMPC_CONVENTION __cdecl\n#else\n#define KMPC_CONVENTION\n#endif\n\n#ifndef __OMP_H\ntypedef enum omp_sched_t {\n  omp_sched_static = 1,\n  omp_sched_dynamic = 2,\n  omp_sched_guided = 3,\n  omp_sched_auto = 4\n} omp_sched_t;\ntypedef void *kmp_affinity_mask_t;\n#endif\n\nKMP_EXPORT void KMPC_CONVENTION ompc_set_max_active_levels(int);\nKMP_EXPORT void KMPC_CONVENTION ompc_set_schedule(omp_sched_t, int);\nKMP_EXPORT int KMPC_CONVENTION ompc_get_ancestor_thread_num(int);\nKMP_EXPORT int KMPC_CONVENTION ompc_get_team_size(int);\nKMP_EXPORT int KMPC_CONVENTION\nkmpc_set_affinity_mask_proc(int, kmp_affinity_mask_t *);\nKMP_EXPORT int KMPC_CONVENTION\nkmpc_unset_affinity_mask_proc(int, kmp_affinity_mask_t *);\nKMP_EXPORT int KMPC_CONVENTION\nkmpc_get_affinity_mask_proc(int, kmp_affinity_mask_t *);\n\nKMP_EXPORT void KMPC_CONVENTION kmpc_set_stacksize(int);\nKMP_EXPORT void KMPC_CONVENTION kmpc_set_stacksize_s(size_t);\nKMP_EXPORT void KMPC_CONVENTION kmpc_set_library(int);\nKMP_EXPORT void KMPC_CONVENTION kmpc_set_defaults(char const *);\nKMP_EXPORT void KMPC_CONVENTION kmpc_set_disp_num_buffers(int);\n\nenum kmp_target_offload_kind {\n  tgt_disabled = 0,\n  tgt_default = 1,\n  tgt_mandatory = 2\n};\ntypedef enum kmp_target_offload_kind kmp_target_offload_kind_t;\n// Set via OMP_TARGET_OFFLOAD if specified, defaults to tgt_default otherwise\nextern kmp_target_offload_kind_t __kmp_target_offload;\nextern int __kmpc_get_target_offload();\n\n// Constants used in libomptarget\n#define KMP_DEVICE_DEFAULT -1 // This is libomptarget's default device.\n#define KMP_DEVICE_ALL -11 // This is libomptarget's \"all devices\".\n\n// OMP Pause Resource\n\n// The following enum is used both to set the status in __kmp_pause_status, and\n// as the internal equivalent of the externally-visible omp_pause_resource_t.\ntypedef enum kmp_pause_status_t {\n  kmp_not_paused = 0, // status is not paused, or, requesting resume\n  kmp_soft_paused = 1, // status is soft-paused, or, requesting soft pause\n  kmp_hard_paused = 2 // status is hard-paused, or, requesting hard pause\n} kmp_pause_status_t;\n\n// This stores the pause state of the runtime\nextern kmp_pause_status_t __kmp_pause_status;\nextern int __kmpc_pause_resource(kmp_pause_status_t level);\nextern int __kmp_pause_resource(kmp_pause_status_t level);\n// Soft resume sets __kmp_pause_status, and wakes up all threads.\nextern void __kmp_resume_if_soft_paused();\n// Hard resume simply resets the status to not paused. Library will appear to\n// be uninitialized after hard pause. Let OMP constructs trigger required\n// initializations.\nstatic inline void __kmp_resume_if_hard_paused() {\n  if (__kmp_pause_status == kmp_hard_paused) {\n    __kmp_pause_status = kmp_not_paused;\n  }\n}\n\nextern void __kmp_omp_display_env(int verbose);\n\n// 1: it is initializing hidden helper team\nextern volatile int __kmp_init_hidden_helper;\n// 1: the hidden helper team is done\nextern volatile int __kmp_hidden_helper_team_done;\n// 1: enable hidden helper task\nextern kmp_int32 __kmp_enable_hidden_helper;\n// Main thread of hidden helper team\nextern kmp_info_t *__kmp_hidden_helper_main_thread;\n// Descriptors for the hidden helper threads\nextern kmp_info_t **__kmp_hidden_helper_threads;\n// Number of hidden helper threads\nextern kmp_int32 __kmp_hidden_helper_threads_num;\n// Number of hidden helper tasks that have not been executed yet\nextern std::atomic<kmp_int32> __kmp_unexecuted_hidden_helper_tasks;\n\nextern void __kmp_hidden_helper_initialize();\nextern void __kmp_hidden_helper_threads_initz_routine();\nextern void __kmp_do_initialize_hidden_helper_threads();\nextern void __kmp_hidden_helper_threads_initz_wait();\nextern void __kmp_hidden_helper_initz_release();\nextern void __kmp_hidden_helper_threads_deinitz_wait();\nextern void __kmp_hidden_helper_threads_deinitz_release();\nextern void __kmp_hidden_helper_main_thread_wait();\nextern void __kmp_hidden_helper_worker_thread_wait();\nextern void __kmp_hidden_helper_worker_thread_signal();\nextern void __kmp_hidden_helper_main_thread_release();\n\n// Check whether a given thread is a hidden helper thread\n#define KMP_HIDDEN_HELPER_THREAD(gtid)                                         \\\n  ((gtid) >= 1 && (gtid) <= __kmp_hidden_helper_threads_num)\n\n#define KMP_HIDDEN_HELPER_WORKER_THREAD(gtid)                                  \\\n  ((gtid) > 1 && (gtid) <= __kmp_hidden_helper_threads_num)\n\n// Map a gtid to a hidden helper thread. The first hidden helper thread, a.k.a\n// main thread, is skipped.\n#define KMP_GTID_TO_SHADOW_GTID(gtid)                                          \\\n  ((gtid) % (__kmp_hidden_helper_threads_num - 1) + 2)\n\n#ifdef __cplusplus\n}\n#endif\n\ntemplate <bool C, bool S>\nextern void __kmp_suspend_32(int th_gtid, kmp_flag_32<C, S> *flag);\ntemplate <bool C, bool S>\nextern void __kmp_suspend_64(int th_gtid, kmp_flag_64<C, S> *flag);\nextern void __kmp_suspend_oncore(int th_gtid, kmp_flag_oncore *flag);\n#if KMP_HAVE_MWAIT || KMP_HAVE_UMWAIT\ntemplate <bool C, bool S>\nextern void __kmp_mwait_32(int th_gtid, kmp_flag_32<C, S> *flag);\ntemplate <bool C, bool S>\nextern void __kmp_mwait_64(int th_gtid, kmp_flag_64<C, S> *flag);\nextern void __kmp_mwait_oncore(int th_gtid, kmp_flag_oncore *flag);\n#endif\ntemplate <bool C, bool S>\nextern void __kmp_resume_32(int target_gtid, kmp_flag_32<C, S> *flag);\ntemplate <bool C, bool S>\nextern void __kmp_resume_64(int target_gtid, kmp_flag_64<C, S> *flag);\nextern void __kmp_resume_oncore(int target_gtid, kmp_flag_oncore *flag);\n\ntemplate <bool C, bool S>\nint __kmp_execute_tasks_32(kmp_info_t *thread, kmp_int32 gtid,\n                           kmp_flag_32<C, S> *flag, int final_spin,\n                           int *thread_finished,\n#if USE_ITT_BUILD\n                           void *itt_sync_obj,\n#endif /* USE_ITT_BUILD */\n                           kmp_int32 is_constrained);\ntemplate <bool C, bool S>\nint __kmp_execute_tasks_64(kmp_info_t *thread, kmp_int32 gtid,\n                           kmp_flag_64<C, S> *flag, int final_spin,\n                           int *thread_finished,\n#if USE_ITT_BUILD\n                           void *itt_sync_obj,\n#endif /* USE_ITT_BUILD */\n                           kmp_int32 is_constrained);\nint __kmp_execute_tasks_oncore(kmp_info_t *thread, kmp_int32 gtid,\n                               kmp_flag_oncore *flag, int final_spin,\n                               int *thread_finished,\n#if USE_ITT_BUILD\n                               void *itt_sync_obj,\n#endif /* USE_ITT_BUILD */\n                               kmp_int32 is_constrained);\n\n/// This class safely opens and closes a C-style FILE* object using RAII\n/// semantics. There are also methods which allow using stdout or stderr as\n/// the underlying FILE* object. With the implicit conversion operator to\n/// FILE*, an object with this type can be used in any function which takes\n/// a FILE* object e.g., fprintf().\n/// No close method is needed at use sites.\nclass kmp_safe_raii_file_t {\n  FILE *f;\n\n  void close() {\n    if (f && f != stdout && f != stderr) {\n      fclose(f);\n      f = nullptr;\n    }\n  }\n\npublic:\n  kmp_safe_raii_file_t() : f(nullptr) {}\n  kmp_safe_raii_file_t(const char *filename, const char *mode,\n                       const char *env_var = nullptr)\n      : f(nullptr) {\n    open(filename, mode, env_var);\n  }\n  ~kmp_safe_raii_file_t() { close(); }\n\n  /// Open filename using mode. This is automatically closed in the destructor.\n  /// The env_var parameter indicates the environment variable the filename\n  /// came from if != nullptr.\n  void open(const char *filename, const char *mode,\n            const char *env_var = nullptr) {\n    KMP_ASSERT(!f);\n    f = fopen(filename, mode);\n    if (!f) {\n      int code = errno;\n      if (env_var) {\n        __kmp_fatal(KMP_MSG(CantOpenFileForReading, filename), KMP_ERR(code),\n                    KMP_HNT(CheckEnvVar, env_var, filename), __kmp_msg_null);\n      } else {\n        __kmp_fatal(KMP_MSG(CantOpenFileForReading, filename), KMP_ERR(code),\n                    __kmp_msg_null);\n      }\n    }\n  }\n  /// Set the FILE* object to stdout and output there\n  /// No open call should happen before this call.\n  void set_stdout() {\n    KMP_ASSERT(!f);\n    f = stdout;\n  }\n  /// Set the FILE* object to stderr and output there\n  /// No open call should happen before this call.\n  void set_stderr() {\n    KMP_ASSERT(!f);\n    f = stderr;\n  }\n  operator bool() { return bool(f); }\n  operator FILE *() { return f; }\n};\n\ntemplate <typename SourceType, typename TargetType,\n          bool isSourceSmaller = (sizeof(SourceType) < sizeof(TargetType)),\n          bool isSourceEqual = (sizeof(SourceType) == sizeof(TargetType)),\n          bool isSourceSigned = std::is_signed<SourceType>::value,\n          bool isTargetSigned = std::is_signed<TargetType>::value>\nstruct kmp_convert {};\n\n// Both types are signed; Source smaller\ntemplate <typename SourceType, typename TargetType>\nstruct kmp_convert<SourceType, TargetType, true, false, true, true> {\n  static TargetType to(SourceType src) { return (TargetType)src; }\n};\n// Source equal\ntemplate <typename SourceType, typename TargetType>\nstruct kmp_convert<SourceType, TargetType, false, true, true, true> {\n  static TargetType to(SourceType src) { return src; }\n};\n// Source bigger\ntemplate <typename SourceType, typename TargetType>\nstruct kmp_convert<SourceType, TargetType, false, false, true, true> {\n  static TargetType to(SourceType src) {\n    KMP_ASSERT(src <= static_cast<SourceType>(\n                          (std::numeric_limits<TargetType>::max)()));\n    KMP_ASSERT(src >= static_cast<SourceType>(\n                          (std::numeric_limits<TargetType>::min)()));\n    return (TargetType)src;\n  }\n};\n\n// Source signed, Target unsigned\n// Source smaller\ntemplate <typename SourceType, typename TargetType>\nstruct kmp_convert<SourceType, TargetType, true, false, true, false> {\n  static TargetType to(SourceType src) {\n    KMP_ASSERT(src >= 0);\n    return (TargetType)src;\n  }\n};\n// Source equal\ntemplate <typename SourceType, typename TargetType>\nstruct kmp_convert<SourceType, TargetType, false, true, true, false> {\n  static TargetType to(SourceType src) {\n    KMP_ASSERT(src >= 0);\n    return (TargetType)src;\n  }\n};\n// Source bigger\ntemplate <typename SourceType, typename TargetType>\nstruct kmp_convert<SourceType, TargetType, false, false, true, false> {\n  static TargetType to(SourceType src) {\n    KMP_ASSERT(src >= 0);\n    KMP_ASSERT(src <= static_cast<SourceType>(\n                          (std::numeric_limits<TargetType>::max)()));\n    return (TargetType)src;\n  }\n};\n\n// Source unsigned, Target signed\n// Source smaller\ntemplate <typename SourceType, typename TargetType>\nstruct kmp_convert<SourceType, TargetType, true, false, false, true> {\n  static TargetType to(SourceType src) { return (TargetType)src; }\n};\n// Source equal\ntemplate <typename SourceType, typename TargetType>\nstruct kmp_convert<SourceType, TargetType, false, true, false, true> {\n  static TargetType to(SourceType src) {\n    KMP_ASSERT(src <= static_cast<SourceType>(\n                          (std::numeric_limits<TargetType>::max)()));\n    return (TargetType)src;\n  }\n};\n// Source bigger\ntemplate <typename SourceType, typename TargetType>\nstruct kmp_convert<SourceType, TargetType, false, false, false, true> {\n  static TargetType to(SourceType src) {\n    KMP_ASSERT(src <= static_cast<SourceType>(\n                          (std::numeric_limits<TargetType>::max)()));\n    return (TargetType)src;\n  }\n};\n\n// Source unsigned, Target unsigned\n// Source smaller\ntemplate <typename SourceType, typename TargetType>\nstruct kmp_convert<SourceType, TargetType, true, false, false, false> {\n  static TargetType to(SourceType src) { return (TargetType)src; }\n};\n// Source equal\ntemplate <typename SourceType, typename TargetType>\nstruct kmp_convert<SourceType, TargetType, false, true, false, false> {\n  static TargetType to(SourceType src) { return src; }\n};\n// Source bigger\ntemplate <typename SourceType, typename TargetType>\nstruct kmp_convert<SourceType, TargetType, false, false, false, false> {\n  static TargetType to(SourceType src) {\n    KMP_ASSERT(src <= static_cast<SourceType>(\n                          (std::numeric_limits<TargetType>::max)()));\n    return (TargetType)src;\n  }\n};\n\ntemplate <typename T1, typename T2>\nstatic inline void __kmp_type_convert(T1 src, T2 *dest) {\n  *dest = kmp_convert<T1, T2>::to(src);\n}\n\n#endif /* KMP_H */\n"}, "4": {"id": 4, "path": "/home/vsts/work/1/llvm-project/openmp/runtime/src/kmp_runtime.cpp", "content": "/*\n * kmp_runtime.cpp -- KPTS runtime support library\n */\n\n//===----------------------------------------------------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#include \"kmp.h\"\n#include \"kmp_affinity.h\"\n#include \"kmp_atomic.h\"\n#include \"kmp_environment.h\"\n#include \"kmp_error.h\"\n#include \"kmp_i18n.h\"\n#include \"kmp_io.h\"\n#include \"kmp_itt.h\"\n#include \"kmp_settings.h\"\n#include \"kmp_stats.h\"\n#include \"kmp_str.h\"\n#include \"kmp_wait_release.h\"\n#include \"kmp_wrapper_getpid.h\"\n#include \"kmp_dispatch.h\"\n#if KMP_USE_HIER_SCHED\n#include \"kmp_dispatch_hier.h\"\n#endif\n\n#if OMPT_SUPPORT\n#include \"ompt-specific.h\"\n#endif\n\n#if OMP_PROFILING_SUPPORT\n#include \"llvm/Support/TimeProfiler.h\"\nstatic char *ProfileTraceFile = nullptr;\n#endif\n\n/* these are temporary issues to be dealt with */\n#define KMP_USE_PRCTL 0\n\n#if KMP_OS_WINDOWS\n#include <process.h>\n#endif\n\n#include \"tsan_annotations.h\"\n\n#if KMP_OS_WINDOWS\n// windows does not need include files as it doesn't use shared memory\n#else\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#define SHM_SIZE 1024\n#endif\n\n#if defined(KMP_GOMP_COMPAT)\nchar const __kmp_version_alt_comp[] =\n    KMP_VERSION_PREFIX \"alternative compiler support: yes\";\n#endif /* defined(KMP_GOMP_COMPAT) */\n\nchar const __kmp_version_omp_api[] =\n    KMP_VERSION_PREFIX \"API version: 5.0 (201611)\";\n\n#ifdef KMP_DEBUG\nchar const __kmp_version_lock[] =\n    KMP_VERSION_PREFIX \"lock type: run time selectable\";\n#endif /* KMP_DEBUG */\n\n#define KMP_MIN(x, y) ((x) < (y) ? (x) : (y))\n\n/* ------------------------------------------------------------------------ */\n\n#if KMP_USE_MONITOR\nkmp_info_t __kmp_monitor;\n#endif\n\n/* Forward declarations */\n\nvoid __kmp_cleanup(void);\n\nstatic void __kmp_initialize_info(kmp_info_t *, kmp_team_t *, int tid,\n                                  int gtid);\nstatic void __kmp_initialize_team(kmp_team_t *team, int new_nproc,\n                                  kmp_internal_control_t *new_icvs,\n                                  ident_t *loc);\n#if KMP_AFFINITY_SUPPORTED\nstatic void __kmp_partition_places(kmp_team_t *team,\n                                   int update_master_only = 0);\n#endif\nstatic void __kmp_do_serial_initialize(void);\nvoid __kmp_fork_barrier(int gtid, int tid);\nvoid __kmp_join_barrier(int gtid);\nvoid __kmp_setup_icv_copy(kmp_team_t *team, int new_nproc,\n                          kmp_internal_control_t *new_icvs, ident_t *loc);\n\n#ifdef USE_LOAD_BALANCE\nstatic int __kmp_load_balance_nproc(kmp_root_t *root, int set_nproc);\n#endif\n\nstatic int __kmp_expand_threads(int nNeed);\n#if KMP_OS_WINDOWS\nstatic int __kmp_unregister_root_other_thread(int gtid);\n#endif\nstatic void __kmp_reap_thread(kmp_info_t *thread, int is_root);\nkmp_info_t *__kmp_thread_pool_insert_pt = NULL;\n\n/* Calculate the identifier of the current thread */\n/* fast (and somewhat portable) way to get unique identifier of executing\n   thread. Returns KMP_GTID_DNE if we haven't been assigned a gtid. */\nint __kmp_get_global_thread_id() {\n  int i;\n  kmp_info_t **other_threads;\n  size_t stack_data;\n  char *stack_addr;\n  size_t stack_size;\n  char *stack_base;\n\n  KA_TRACE(\n      1000,\n      (\"*** __kmp_get_global_thread_id: entering, nproc=%d  all_nproc=%d\\n\",\n       __kmp_nth, __kmp_all_nth));\n\n  /* JPH - to handle the case where __kmpc_end(0) is called immediately prior to\n     a parallel region, made it return KMP_GTID_DNE to force serial_initialize\n     by caller. Had to handle KMP_GTID_DNE at all call-sites, or else guarantee\n     __kmp_init_gtid for this to work. */\n\n  if (!TCR_4(__kmp_init_gtid))\n    return KMP_GTID_DNE;\n\n#ifdef KMP_TDATA_GTID\n  if (TCR_4(__kmp_gtid_mode) >= 3) {\n    KA_TRACE(1000, (\"*** __kmp_get_global_thread_id: using TDATA\\n\"));\n    return __kmp_gtid;\n  }\n#endif\n  if (TCR_4(__kmp_gtid_mode) >= 2) {\n    KA_TRACE(1000, (\"*** __kmp_get_global_thread_id: using keyed TLS\\n\"));\n    return __kmp_gtid_get_specific();\n  }\n  KA_TRACE(1000, (\"*** __kmp_get_global_thread_id: using internal alg.\\n\"));\n\n  stack_addr = (char *)&stack_data;\n  other_threads = __kmp_threads;\n\n  /* ATT: The code below is a source of potential bugs due to unsynchronized\n     access to __kmp_threads array. For example:\n     1. Current thread loads other_threads[i] to thr and checks it, it is\n        non-NULL.\n     2. Current thread is suspended by OS.\n     3. Another thread unregisters and finishes (debug versions of free()\n        may fill memory with something like 0xEF).\n     4. Current thread is resumed.\n     5. Current thread reads junk from *thr.\n     TODO: Fix it.  --ln  */\n\n  for (i = 0; i < __kmp_threads_capacity; i++) {\n\n    kmp_info_t *thr = (kmp_info_t *)TCR_SYNC_PTR(other_threads[i]);\n    if (!thr)\n      continue;\n\n    stack_size = (size_t)TCR_PTR(thr->th.th_info.ds.ds_stacksize);\n    stack_base = (char *)TCR_PTR(thr->th.th_info.ds.ds_stackbase);\n\n    /* stack grows down -- search through all of the active threads */\n\n    if (stack_addr <= stack_base) {\n      size_t stack_diff = stack_base - stack_addr;\n\n      if (stack_diff <= stack_size) {\n        /* The only way we can be closer than the allocated */\n        /* stack size is if we are running on this thread. */\n        KMP_DEBUG_ASSERT(__kmp_gtid_get_specific() == i);\n        return i;\n      }\n    }\n  }\n\n  /* get specific to try and determine our gtid */\n  KA_TRACE(1000,\n           (\"*** __kmp_get_global_thread_id: internal alg. failed to find \"\n            \"thread, using TLS\\n\"));\n  i = __kmp_gtid_get_specific();\n\n  /*fprintf( stderr, \"=== %d\\n\", i );  */ /* GROO */\n\n  /* if we havn't been assigned a gtid, then return code */\n  if (i < 0)\n    return i;\n\n  /* dynamically updated stack window for uber threads to avoid get_specific\n     call */\n  if (!TCR_4(other_threads[i]->th.th_info.ds.ds_stackgrow)) {\n    KMP_FATAL(StackOverflow, i);\n  }\n\n  stack_base = (char *)other_threads[i]->th.th_info.ds.ds_stackbase;\n  if (stack_addr > stack_base) {\n    TCW_PTR(other_threads[i]->th.th_info.ds.ds_stackbase, stack_addr);\n    TCW_PTR(other_threads[i]->th.th_info.ds.ds_stacksize,\n            other_threads[i]->th.th_info.ds.ds_stacksize + stack_addr -\n                stack_base);\n  } else {\n    TCW_PTR(other_threads[i]->th.th_info.ds.ds_stacksize,\n            stack_base - stack_addr);\n  }\n\n  /* Reprint stack bounds for ubermaster since they have been refined */\n  if (__kmp_storage_map) {\n    char *stack_end = (char *)other_threads[i]->th.th_info.ds.ds_stackbase;\n    char *stack_beg = stack_end - other_threads[i]->th.th_info.ds.ds_stacksize;\n    __kmp_print_storage_map_gtid(i, stack_beg, stack_end,\n                                 other_threads[i]->th.th_info.ds.ds_stacksize,\n                                 \"th_%d stack (refinement)\", i);\n  }\n  return i;\n}\n\nint __kmp_get_global_thread_id_reg() {\n  int gtid;\n\n  if (!__kmp_init_serial) {\n    gtid = KMP_GTID_DNE;\n  } else\n#ifdef KMP_TDATA_GTID\n      if (TCR_4(__kmp_gtid_mode) >= 3) {\n    KA_TRACE(1000, (\"*** __kmp_get_global_thread_id_reg: using TDATA\\n\"));\n    gtid = __kmp_gtid;\n  } else\n#endif\n      if (TCR_4(__kmp_gtid_mode) >= 2) {\n    KA_TRACE(1000, (\"*** __kmp_get_global_thread_id_reg: using keyed TLS\\n\"));\n    gtid = __kmp_gtid_get_specific();\n  } else {\n    KA_TRACE(1000,\n             (\"*** __kmp_get_global_thread_id_reg: using internal alg.\\n\"));\n    gtid = __kmp_get_global_thread_id();\n  }\n\n  /* we must be a new uber master sibling thread */\n  if (gtid == KMP_GTID_DNE) {\n    KA_TRACE(10,\n             (\"__kmp_get_global_thread_id_reg: Encountered new root thread. \"\n              \"Registering a new gtid.\\n\"));\n    __kmp_acquire_bootstrap_lock(&__kmp_initz_lock);\n    if (!__kmp_init_serial) {\n      __kmp_do_serial_initialize();\n      gtid = __kmp_gtid_get_specific();\n    } else {\n      gtid = __kmp_register_root(FALSE);\n    }\n    __kmp_release_bootstrap_lock(&__kmp_initz_lock);\n    /*__kmp_printf( \"+++ %d\\n\", gtid ); */ /* GROO */\n  }\n\n  KMP_DEBUG_ASSERT(gtid >= 0);\n\n  return gtid;\n}\n\n/* caller must hold forkjoin_lock */\nvoid __kmp_check_stack_overlap(kmp_info_t *th) {\n  int f;\n  char *stack_beg = NULL;\n  char *stack_end = NULL;\n  int gtid;\n\n  KA_TRACE(10, (\"__kmp_check_stack_overlap: called\\n\"));\n  if (__kmp_storage_map) {\n    stack_end = (char *)th->th.th_info.ds.ds_stackbase;\n    stack_beg = stack_end - th->th.th_info.ds.ds_stacksize;\n\n    gtid = __kmp_gtid_from_thread(th);\n\n    if (gtid == KMP_GTID_MONITOR) {\n      __kmp_print_storage_map_gtid(\n          gtid, stack_beg, stack_end, th->th.th_info.ds.ds_stacksize,\n          \"th_%s stack (%s)\", \"mon\",\n          (th->th.th_info.ds.ds_stackgrow) ? \"initial\" : \"actual\");\n    } else {\n      __kmp_print_storage_map_gtid(\n          gtid, stack_beg, stack_end, th->th.th_info.ds.ds_stacksize,\n          \"th_%d stack (%s)\", gtid,\n          (th->th.th_info.ds.ds_stackgrow) ? \"initial\" : \"actual\");\n    }\n  }\n\n  /* No point in checking ubermaster threads since they use refinement and\n   * cannot overlap */\n  gtid = __kmp_gtid_from_thread(th);\n  if (__kmp_env_checks == TRUE && !KMP_UBER_GTID(gtid)) {\n    KA_TRACE(10,\n             (\"__kmp_check_stack_overlap: performing extensive checking\\n\"));\n    if (stack_beg == NULL) {\n      stack_end = (char *)th->th.th_info.ds.ds_stackbase;\n      stack_beg = stack_end - th->th.th_info.ds.ds_stacksize;\n    }\n\n    for (f = 0; f < __kmp_threads_capacity; f++) {\n      kmp_info_t *f_th = (kmp_info_t *)TCR_SYNC_PTR(__kmp_threads[f]);\n\n      if (f_th && f_th != th) {\n        char *other_stack_end =\n            (char *)TCR_PTR(f_th->th.th_info.ds.ds_stackbase);\n        char *other_stack_beg =\n            other_stack_end - (size_t)TCR_PTR(f_th->th.th_info.ds.ds_stacksize);\n        if ((stack_beg > other_stack_beg && stack_beg < other_stack_end) ||\n            (stack_end > other_stack_beg && stack_end < other_stack_end)) {\n\n          /* Print the other stack values before the abort */\n          if (__kmp_storage_map)\n            __kmp_print_storage_map_gtid(\n                -1, other_stack_beg, other_stack_end,\n                (size_t)TCR_PTR(f_th->th.th_info.ds.ds_stacksize),\n                \"th_%d stack (overlapped)\", __kmp_gtid_from_thread(f_th));\n\n          __kmp_fatal(KMP_MSG(StackOverlap), KMP_HNT(ChangeStackLimit),\n                      __kmp_msg_null);\n        }\n      }\n    }\n  }\n  KA_TRACE(10, (\"__kmp_check_stack_overlap: returning\\n\"));\n}\n\n/* ------------------------------------------------------------------------ */\n\nvoid __kmp_infinite_loop(void) {\n  static int done = FALSE;\n\n  while (!done) {\n    KMP_YIELD(TRUE);\n  }\n}\n\n#define MAX_MESSAGE 512\n\nvoid __kmp_print_storage_map_gtid(int gtid, void *p1, void *p2, size_t size,\n                                  char const *format, ...) {\n  char buffer[MAX_MESSAGE];\n  va_list ap;\n\n  va_start(ap, format);\n  KMP_SNPRINTF(buffer, sizeof(buffer), \"OMP storage map: %p %p%8lu %s\\n\", p1,\n               p2, (unsigned long)size, format);\n  __kmp_acquire_bootstrap_lock(&__kmp_stdio_lock);\n  __kmp_vprintf(kmp_err, buffer, ap);\n#if KMP_PRINT_DATA_PLACEMENT\n  int node;\n  if (gtid >= 0) {\n    if (p1 <= p2 && (char *)p2 - (char *)p1 == size) {\n      if (__kmp_storage_map_verbose) {\n        node = __kmp_get_host_node(p1);\n        if (node < 0) /* doesn't work, so don't try this next time */\n          __kmp_storage_map_verbose = FALSE;\n        else {\n          char *last;\n          int lastNode;\n          int localProc = __kmp_get_cpu_from_gtid(gtid);\n\n          const int page_size = KMP_GET_PAGE_SIZE();\n\n          p1 = (void *)((size_t)p1 & ~((size_t)page_size - 1));\n          p2 = (void *)(((size_t)p2 - 1) & ~((size_t)page_size - 1));\n          if (localProc >= 0)\n            __kmp_printf_no_lock(\"  GTID %d localNode %d\\n\", gtid,\n                                 localProc >> 1);\n          else\n            __kmp_printf_no_lock(\"  GTID %d\\n\", gtid);\n#if KMP_USE_PRCTL\n          /* The more elaborate format is disabled for now because of the prctl\n           * hanging bug. */\n          do {\n            last = p1;\n            lastNode = node;\n            /* This loop collates adjacent pages with the same host node. */\n            do {\n              (char *)p1 += page_size;\n            } while (p1 <= p2 && (node = __kmp_get_host_node(p1)) == lastNode);\n            __kmp_printf_no_lock(\"    %p-%p memNode %d\\n\", last, (char *)p1 - 1,\n                                 lastNode);\n          } while (p1 <= p2);\n#else\n          __kmp_printf_no_lock(\"    %p-%p memNode %d\\n\", p1,\n                               (char *)p1 + (page_size - 1),\n                               __kmp_get_host_node(p1));\n          if (p1 < p2) {\n            __kmp_printf_no_lock(\"    %p-%p memNode %d\\n\", p2,\n                                 (char *)p2 + (page_size - 1),\n                                 __kmp_get_host_node(p2));\n          }\n#endif\n        }\n      }\n    } else\n      __kmp_printf_no_lock(\"  %s\\n\", KMP_I18N_STR(StorageMapWarning));\n  }\n#endif /* KMP_PRINT_DATA_PLACEMENT */\n  __kmp_release_bootstrap_lock(&__kmp_stdio_lock);\n}\n\nvoid __kmp_warn(char const *format, ...) {\n  char buffer[MAX_MESSAGE];\n  va_list ap;\n\n  if (__kmp_generate_warnings == kmp_warnings_off) {\n    return;\n  }\n\n  va_start(ap, format);\n\n  KMP_SNPRINTF(buffer, sizeof(buffer), \"OMP warning: %s\\n\", format);\n  __kmp_acquire_bootstrap_lock(&__kmp_stdio_lock);\n  __kmp_vprintf(kmp_err, buffer, ap);\n  __kmp_release_bootstrap_lock(&__kmp_stdio_lock);\n\n  va_end(ap);\n}\n\nvoid __kmp_abort_process() {\n  // Later threads may stall here, but that's ok because abort() will kill them.\n  __kmp_acquire_bootstrap_lock(&__kmp_exit_lock);\n\n  if (__kmp_debug_buf) {\n    __kmp_dump_debug_buffer();\n  }\n\n  if (KMP_OS_WINDOWS) {\n    // Let other threads know of abnormal termination and prevent deadlock\n    // if abort happened during library initialization or shutdown\n    __kmp_global.g.g_abort = SIGABRT;\n\n    /* On Windows* OS by default abort() causes pop-up error box, which stalls\n       nightly testing. Unfortunately, we cannot reliably suppress pop-up error\n       boxes. _set_abort_behavior() works well, but this function is not\n       available in VS7 (this is not problem for DLL, but it is a problem for\n       static OpenMP RTL). SetErrorMode (and so, timelimit utility) does not\n       help, at least in some versions of MS C RTL.\n\n       It seems following sequence is the only way to simulate abort() and\n       avoid pop-up error box. */\n    raise(SIGABRT);\n    _exit(3); // Just in case, if signal ignored, exit anyway.\n  } else {\n    __kmp_unregister_library();\n    abort();\n  }\n\n  __kmp_infinite_loop();\n  __kmp_release_bootstrap_lock(&__kmp_exit_lock);\n\n} // __kmp_abort_process\n\nvoid __kmp_abort_thread(void) {\n  // TODO: Eliminate g_abort global variable and this function.\n  // In case of abort just call abort(), it will kill all the threads.\n  __kmp_infinite_loop();\n} // __kmp_abort_thread\n\n/* Print out the storage map for the major kmp_info_t thread data structures\n   that are allocated together. */\n\nstatic void __kmp_print_thread_storage_map(kmp_info_t *thr, int gtid) {\n  __kmp_print_storage_map_gtid(gtid, thr, thr + 1, sizeof(kmp_info_t), \"th_%d\",\n                               gtid);\n\n  __kmp_print_storage_map_gtid(gtid, &thr->th.th_info, &thr->th.th_team,\n                               sizeof(kmp_desc_t), \"th_%d.th_info\", gtid);\n\n  __kmp_print_storage_map_gtid(gtid, &thr->th.th_local, &thr->th.th_pri_head,\n                               sizeof(kmp_local_t), \"th_%d.th_local\", gtid);\n\n  __kmp_print_storage_map_gtid(\n      gtid, &thr->th.th_bar[0], &thr->th.th_bar[bs_last_barrier],\n      sizeof(kmp_balign_t) * bs_last_barrier, \"th_%d.th_bar\", gtid);\n\n  __kmp_print_storage_map_gtid(gtid, &thr->th.th_bar[bs_plain_barrier],\n                               &thr->th.th_bar[bs_plain_barrier + 1],\n                               sizeof(kmp_balign_t), \"th_%d.th_bar[plain]\",\n                               gtid);\n\n  __kmp_print_storage_map_gtid(gtid, &thr->th.th_bar[bs_forkjoin_barrier],\n                               &thr->th.th_bar[bs_forkjoin_barrier + 1],\n                               sizeof(kmp_balign_t), \"th_%d.th_bar[forkjoin]\",\n                               gtid);\n\n#if KMP_FAST_REDUCTION_BARRIER\n  __kmp_print_storage_map_gtid(gtid, &thr->th.th_bar[bs_reduction_barrier],\n                               &thr->th.th_bar[bs_reduction_barrier + 1],\n                               sizeof(kmp_balign_t), \"th_%d.th_bar[reduction]\",\n                               gtid);\n#endif // KMP_FAST_REDUCTION_BARRIER\n}\n\n/* Print out the storage map for the major kmp_team_t team data structures\n   that are allocated together. */\n\nstatic void __kmp_print_team_storage_map(const char *header, kmp_team_t *team,\n                                         int team_id, int num_thr) {\n  int num_disp_buff = team->t.t_max_nproc > 1 ? __kmp_dispatch_num_buffers : 2;\n  __kmp_print_storage_map_gtid(-1, team, team + 1, sizeof(kmp_team_t), \"%s_%d\",\n                               header, team_id);\n\n  __kmp_print_storage_map_gtid(-1, &team->t.t_bar[0],\n                               &team->t.t_bar[bs_last_barrier],\n                               sizeof(kmp_balign_team_t) * bs_last_barrier,\n                               \"%s_%d.t_bar\", header, team_id);\n\n  __kmp_print_storage_map_gtid(-1, &team->t.t_bar[bs_plain_barrier],\n                               &team->t.t_bar[bs_plain_barrier + 1],\n                               sizeof(kmp_balign_team_t), \"%s_%d.t_bar[plain]\",\n                               header, team_id);\n\n  __kmp_print_storage_map_gtid(-1, &team->t.t_bar[bs_forkjoin_barrier],\n                               &team->t.t_bar[bs_forkjoin_barrier + 1],\n                               sizeof(kmp_balign_team_t),\n                               \"%s_%d.t_bar[forkjoin]\", header, team_id);\n\n#if KMP_FAST_REDUCTION_BARRIER\n  __kmp_print_storage_map_gtid(-1, &team->t.t_bar[bs_reduction_barrier],\n                               &team->t.t_bar[bs_reduction_barrier + 1],\n                               sizeof(kmp_balign_team_t),\n                               \"%s_%d.t_bar[reduction]\", header, team_id);\n#endif // KMP_FAST_REDUCTION_BARRIER\n\n  __kmp_print_storage_map_gtid(\n      -1, &team->t.t_dispatch[0], &team->t.t_dispatch[num_thr],\n      sizeof(kmp_disp_t) * num_thr, \"%s_%d.t_dispatch\", header, team_id);\n\n  __kmp_print_storage_map_gtid(\n      -1, &team->t.t_threads[0], &team->t.t_threads[num_thr],\n      sizeof(kmp_info_t *) * num_thr, \"%s_%d.t_threads\", header, team_id);\n\n  __kmp_print_storage_map_gtid(-1, &team->t.t_disp_buffer[0],\n                               &team->t.t_disp_buffer[num_disp_buff],\n                               sizeof(dispatch_shared_info_t) * num_disp_buff,\n                               \"%s_%d.t_disp_buffer\", header, team_id);\n}\n\nstatic void __kmp_init_allocator() {\n  __kmp_init_memkind();\n  __kmp_init_target_mem();\n}\nstatic void __kmp_fini_allocator() { __kmp_fini_memkind(); }\n\n/* ------------------------------------------------------------------------ */\n\n#if KMP_DYNAMIC_LIB\n#if KMP_OS_WINDOWS\n\nBOOL WINAPI DllMain(HINSTANCE hInstDLL, DWORD fdwReason, LPVOID lpReserved) {\n  //__kmp_acquire_bootstrap_lock( &__kmp_initz_lock );\n\n  switch (fdwReason) {\n\n  case DLL_PROCESS_ATTACH:\n    KA_TRACE(10, (\"DllMain: PROCESS_ATTACH\\n\"));\n\n    return TRUE;\n\n  case DLL_PROCESS_DETACH:\n    KA_TRACE(10, (\"DllMain: PROCESS_DETACH T#%d\\n\", __kmp_gtid_get_specific()));\n\n    // According to Windows* documentation for DllMain entry point:\n    // for DLL_PROCESS_DETACH, lpReserved is used for telling the difference:\n    //   lpReserved == NULL when FreeLibrary() is called,\n    //   lpReserved != NULL when the process is terminated.\n    // When FreeLibrary() is called, worker threads remain alive. So the\n    // runtime's state is consistent and executing proper shutdown is OK.\n    // When the process is terminated, worker threads have exited or been\n    // forcefully terminated by the OS and only the shutdown thread remains.\n    // This can leave the runtime in an inconsistent state.\n    // Hence, only attempt proper cleanup when FreeLibrary() is called.\n    // Otherwise, rely on OS to reclaim resources.\n    if (lpReserved == NULL)\n      __kmp_internal_end_library(__kmp_gtid_get_specific());\n\n    return TRUE;\n\n  case DLL_THREAD_ATTACH:\n    KA_TRACE(10, (\"DllMain: THREAD_ATTACH\\n\"));\n\n    /* if we want to register new siblings all the time here call\n     * __kmp_get_gtid(); */\n    return TRUE;\n\n  case DLL_THREAD_DETACH:\n    KA_TRACE(10, (\"DllMain: THREAD_DETACH T#%d\\n\", __kmp_gtid_get_specific()));\n\n    __kmp_internal_end_thread(__kmp_gtid_get_specific());\n    return TRUE;\n  }\n\n  return TRUE;\n}\n\n#endif /* KMP_OS_WINDOWS */\n#endif /* KMP_DYNAMIC_LIB */\n\n/* __kmp_parallel_deo -- Wait until it's our turn. */\nvoid __kmp_parallel_deo(int *gtid_ref, int *cid_ref, ident_t *loc_ref) {\n  int gtid = *gtid_ref;\n#ifdef BUILD_PARALLEL_ORDERED\n  kmp_team_t *team = __kmp_team_from_gtid(gtid);\n#endif /* BUILD_PARALLEL_ORDERED */\n\n  if (__kmp_env_consistency_check) {\n    if (__kmp_threads[gtid]->th.th_root->r.r_active)\n#if KMP_USE_DYNAMIC_LOCK\n      __kmp_push_sync(gtid, ct_ordered_in_parallel, loc_ref, NULL, 0);\n#else\n      __kmp_push_sync(gtid, ct_ordered_in_parallel, loc_ref, NULL);\n#endif\n  }\n#ifdef BUILD_PARALLEL_ORDERED\n  if (!team->t.t_serialized) {\n    KMP_MB();\n    KMP_WAIT(&team->t.t_ordered.dt.t_value, __kmp_tid_from_gtid(gtid), KMP_EQ,\n             NULL);\n    KMP_MB();\n  }\n#endif /* BUILD_PARALLEL_ORDERED */\n}\n\n/* __kmp_parallel_dxo -- Signal the next task. */\nvoid __kmp_parallel_dxo(int *gtid_ref, int *cid_ref, ident_t *loc_ref) {\n  int gtid = *gtid_ref;\n#ifdef BUILD_PARALLEL_ORDERED\n  int tid = __kmp_tid_from_gtid(gtid);\n  kmp_team_t *team = __kmp_team_from_gtid(gtid);\n#endif /* BUILD_PARALLEL_ORDERED */\n\n  if (__kmp_env_consistency_check) {\n    if (__kmp_threads[gtid]->th.th_root->r.r_active)\n      __kmp_pop_sync(gtid, ct_ordered_in_parallel, loc_ref);\n  }\n#ifdef BUILD_PARALLEL_ORDERED\n  if (!team->t.t_serialized) {\n    KMP_MB(); /* Flush all pending memory write invalidates.  */\n\n    /* use the tid of the next thread in this team */\n    /* TODO replace with general release procedure */\n    team->t.t_ordered.dt.t_value = ((tid + 1) % team->t.t_nproc);\n\n    KMP_MB(); /* Flush all pending memory write invalidates.  */\n  }\n#endif /* BUILD_PARALLEL_ORDERED */\n}\n\n/* ------------------------------------------------------------------------ */\n/* The BARRIER for a SINGLE process section is always explicit   */\n\nint __kmp_enter_single(int gtid, ident_t *id_ref, int push_ws) {\n  int status;\n  kmp_info_t *th;\n  kmp_team_t *team;\n\n  if (!TCR_4(__kmp_init_parallel))\n    __kmp_parallel_initialize();\n  __kmp_resume_if_soft_paused();\n\n  th = __kmp_threads[gtid];\n  team = th->th.th_team;\n  status = 0;\n\n  th->th.th_ident = id_ref;\n\n  if (team->t.t_serialized) {\n    status = 1;\n  } else {\n    kmp_int32 old_this = th->th.th_local.this_construct;\n\n    ++th->th.th_local.this_construct;\n    /* try to set team count to thread count--success means thread got the\n       single block */\n    /* TODO: Should this be acquire or release? */\n    if (team->t.t_construct == old_this) {\n      status = __kmp_atomic_compare_store_acq(&team->t.t_construct, old_this,\n                                              th->th.th_local.this_construct);\n    }\n#if USE_ITT_BUILD\n    if (__itt_metadata_add_ptr && __kmp_forkjoin_frames_mode == 3 &&\n        KMP_MASTER_GTID(gtid) && th->th.th_teams_microtask == NULL &&\n        team->t.t_active_level == 1) {\n      // Only report metadata by primary thread of active team at level 1\n      __kmp_itt_metadata_single(id_ref);\n    }\n#endif /* USE_ITT_BUILD */\n  }\n\n  if (__kmp_env_consistency_check) {\n    if (status && push_ws) {\n      __kmp_push_workshare(gtid, ct_psingle, id_ref);\n    } else {\n      __kmp_check_workshare(gtid, ct_psingle, id_ref);\n    }\n  }\n#if USE_ITT_BUILD\n  if (status) {\n    __kmp_itt_single_start(gtid);\n  }\n#endif /* USE_ITT_BUILD */\n  return status;\n}\n\nvoid __kmp_exit_single(int gtid) {\n#if USE_ITT_BUILD\n  __kmp_itt_single_end(gtid);\n#endif /* USE_ITT_BUILD */\n  if (__kmp_env_consistency_check)\n    __kmp_pop_workshare(gtid, ct_psingle, NULL);\n}\n\n/* determine if we can go parallel or must use a serialized parallel region and\n * how many threads we can use\n * set_nproc is the number of threads requested for the team\n * returns 0 if we should serialize or only use one thread,\n * otherwise the number of threads to use\n * The forkjoin lock is held by the caller. */\nstatic int __kmp_reserve_threads(kmp_root_t *root, kmp_team_t *parent_team,\n                                 int master_tid, int set_nthreads,\n                                 int enter_teams) {\n  int capacity;\n  int new_nthreads;\n  KMP_DEBUG_ASSERT(__kmp_init_serial);\n  KMP_DEBUG_ASSERT(root && parent_team);\n  kmp_info_t *this_thr = parent_team->t.t_threads[master_tid];\n\n  // If dyn-var is set, dynamically adjust the number of desired threads,\n  // according to the method specified by dynamic_mode.\n  new_nthreads = set_nthreads;\n  if (!get__dynamic_2(parent_team, master_tid)) {\n    ;\n  }\n#ifdef USE_LOAD_BALANCE\n  else if (__kmp_global.g.g_dynamic_mode == dynamic_load_balance) {\n    new_nthreads = __kmp_load_balance_nproc(root, set_nthreads);\n    if (new_nthreads == 1) {\n      KC_TRACE(10, (\"__kmp_reserve_threads: T#%d load balance reduced \"\n                    \"reservation to 1 thread\\n\",\n                    master_tid));\n      return 1;\n    }\n    if (new_nthreads < set_nthreads) {\n      KC_TRACE(10, (\"__kmp_reserve_threads: T#%d load balance reduced \"\n                    \"reservation to %d threads\\n\",\n                    master_tid, new_nthreads));\n    }\n  }\n#endif /* USE_LOAD_BALANCE */\n  else if (__kmp_global.g.g_dynamic_mode == dynamic_thread_limit) {\n    new_nthreads = __kmp_avail_proc - __kmp_nth +\n                   (root->r.r_active ? 1 : root->r.r_hot_team->t.t_nproc);\n    if (new_nthreads <= 1) {\n      KC_TRACE(10, (\"__kmp_reserve_threads: T#%d thread limit reduced \"\n                    \"reservation to 1 thread\\n\",\n                    master_tid));\n      return 1;\n    }\n    if (new_nthreads < set_nthreads) {\n      KC_TRACE(10, (\"__kmp_reserve_threads: T#%d thread limit reduced \"\n                    \"reservation to %d threads\\n\",\n                    master_tid, new_nthreads));\n    } else {\n      new_nthreads = set_nthreads;\n    }\n  } else if (__kmp_global.g.g_dynamic_mode == dynamic_random) {\n    if (set_nthreads > 2) {\n      new_nthreads = __kmp_get_random(parent_team->t.t_threads[master_tid]);\n      new_nthreads = (new_nthreads % set_nthreads) + 1;\n      if (new_nthreads == 1) {\n        KC_TRACE(10, (\"__kmp_reserve_threads: T#%d dynamic random reduced \"\n                      \"reservation to 1 thread\\n\",\n                      master_tid));\n        return 1;\n      }\n      if (new_nthreads < set_nthreads) {\n        KC_TRACE(10, (\"__kmp_reserve_threads: T#%d dynamic random reduced \"\n                      \"reservation to %d threads\\n\",\n                      master_tid, new_nthreads));\n      }\n    }\n  } else {\n    KMP_ASSERT(0);\n  }\n\n  // Respect KMP_ALL_THREADS/KMP_DEVICE_THREAD_LIMIT.\n  if (__kmp_nth + new_nthreads -\n          (root->r.r_active ? 1 : root->r.r_hot_team->t.t_nproc) >\n      __kmp_max_nth) {\n    int tl_nthreads = __kmp_max_nth - __kmp_nth +\n                      (root->r.r_active ? 1 : root->r.r_hot_team->t.t_nproc);\n    if (tl_nthreads <= 0) {\n      tl_nthreads = 1;\n    }\n\n    // If dyn-var is false, emit a 1-time warning.\n    if (!get__dynamic_2(parent_team, master_tid) && (!__kmp_reserve_warn)) {\n      __kmp_reserve_warn = 1;\n      __kmp_msg(kmp_ms_warning,\n                KMP_MSG(CantFormThrTeam, set_nthreads, tl_nthreads),\n                KMP_HNT(Unset_ALL_THREADS), __kmp_msg_null);\n    }\n    if (tl_nthreads == 1) {\n      KC_TRACE(10, (\"__kmp_reserve_threads: T#%d KMP_DEVICE_THREAD_LIMIT \"\n                    \"reduced reservation to 1 thread\\n\",\n                    master_tid));\n      return 1;\n    }\n    KC_TRACE(10, (\"__kmp_reserve_threads: T#%d KMP_DEVICE_THREAD_LIMIT reduced \"\n                  \"reservation to %d threads\\n\",\n                  master_tid, tl_nthreads));\n    new_nthreads = tl_nthreads;\n  }\n\n  // Respect OMP_THREAD_LIMIT\n  int cg_nthreads = this_thr->th.th_cg_roots->cg_nthreads;\n  int max_cg_threads = this_thr->th.th_cg_roots->cg_thread_limit;\n  if (cg_nthreads + new_nthreads -\n          (root->r.r_active ? 1 : root->r.r_hot_team->t.t_nproc) >\n      max_cg_threads) {\n    int tl_nthreads = max_cg_threads - cg_nthreads +\n                      (root->r.r_active ? 1 : root->r.r_hot_team->t.t_nproc);\n    if (tl_nthreads <= 0) {\n      tl_nthreads = 1;\n    }\n\n    // If dyn-var is false, emit a 1-time warning.\n    if (!get__dynamic_2(parent_team, master_tid) && (!__kmp_reserve_warn)) {\n      __kmp_reserve_warn = 1;\n      __kmp_msg(kmp_ms_warning,\n                KMP_MSG(CantFormThrTeam, set_nthreads, tl_nthreads),\n                KMP_HNT(Unset_ALL_THREADS), __kmp_msg_null);\n    }\n    if (tl_nthreads == 1) {\n      KC_TRACE(10, (\"__kmp_reserve_threads: T#%d OMP_THREAD_LIMIT \"\n                    \"reduced reservation to 1 thread\\n\",\n                    master_tid));\n      return 1;\n    }\n    KC_TRACE(10, (\"__kmp_reserve_threads: T#%d OMP_THREAD_LIMIT reduced \"\n                  \"reservation to %d threads\\n\",\n                  master_tid, tl_nthreads));\n    new_nthreads = tl_nthreads;\n  }\n\n  // Check if the threads array is large enough, or needs expanding.\n  // See comment in __kmp_register_root() about the adjustment if\n  // __kmp_threads[0] == NULL.\n  capacity = __kmp_threads_capacity;\n  if (TCR_PTR(__kmp_threads[0]) == NULL) {\n    --capacity;\n  }\n  if (__kmp_nth + new_nthreads -\n          (root->r.r_active ? 1 : root->r.r_hot_team->t.t_nproc) >\n      capacity) {\n    // Expand the threads array.\n    int slotsRequired = __kmp_nth + new_nthreads -\n                        (root->r.r_active ? 1 : root->r.r_hot_team->t.t_nproc) -\n                        capacity;\n    int slotsAdded = __kmp_expand_threads(slotsRequired);\n    if (slotsAdded < slotsRequired) {\n      // The threads array was not expanded enough.\n      new_nthreads -= (slotsRequired - slotsAdded);\n      KMP_ASSERT(new_nthreads >= 1);\n\n      // If dyn-var is false, emit a 1-time warning.\n      if (!get__dynamic_2(parent_team, master_tid) && (!__kmp_reserve_warn)) {\n        __kmp_reserve_warn = 1;\n        if (__kmp_tp_cached) {\n          __kmp_msg(kmp_ms_warning,\n                    KMP_MSG(CantFormThrTeam, set_nthreads, new_nthreads),\n                    KMP_HNT(Set_ALL_THREADPRIVATE, __kmp_tp_capacity),\n                    KMP_HNT(PossibleSystemLimitOnThreads), __kmp_msg_null);\n        } else {\n          __kmp_msg(kmp_ms_warning,\n                    KMP_MSG(CantFormThrTeam, set_nthreads, new_nthreads),\n                    KMP_HNT(SystemLimitOnThreads), __kmp_msg_null);\n        }\n      }\n    }\n  }\n\n#ifdef KMP_DEBUG\n  if (new_nthreads == 1) {\n    KC_TRACE(10,\n             (\"__kmp_reserve_threads: T#%d serializing team after reclaiming \"\n              \"dead roots and rechecking; requested %d threads\\n\",\n              __kmp_get_gtid(), set_nthreads));\n  } else {\n    KC_TRACE(10, (\"__kmp_reserve_threads: T#%d allocating %d threads; requested\"\n                  \" %d threads\\n\",\n                  __kmp_get_gtid(), new_nthreads, set_nthreads));\n  }\n#endif // KMP_DEBUG\n  return new_nthreads;\n}\n\n/* Allocate threads from the thread pool and assign them to the new team. We are\n   assured that there are enough threads available, because we checked on that\n   earlier within critical section forkjoin */\nstatic void __kmp_fork_team_threads(kmp_root_t *root, kmp_team_t *team,\n                                    kmp_info_t *master_th, int master_gtid) {\n  int i;\n  int use_hot_team;\n\n  KA_TRACE(10, (\"__kmp_fork_team_threads: new_nprocs = %d\\n\", team->t.t_nproc));\n  KMP_DEBUG_ASSERT(master_gtid == __kmp_get_gtid());\n  KMP_MB();\n\n  /* first, let's setup the primary thread */\n  master_th->th.th_info.ds.ds_tid = 0;\n  master_th->th.th_team = team;\n  master_th->th.th_team_nproc = team->t.t_nproc;\n  master_th->th.th_team_master = master_th;\n  master_th->th.th_team_serialized = FALSE;\n  master_th->th.th_dispatch = &team->t.t_dispatch[0];\n\n/* make sure we are not the optimized hot team */\n#if KMP_NESTED_HOT_TEAMS\n  use_hot_team = 0;\n  kmp_hot_team_ptr_t *hot_teams = master_th->th.th_hot_teams;\n  if (hot_teams) { // hot teams array is not allocated if\n    // KMP_HOT_TEAMS_MAX_LEVEL=0\n    int level = team->t.t_active_level - 1; // index in array of hot teams\n    if (master_th->th.th_teams_microtask) { // are we inside the teams?\n      if (master_th->th.th_teams_size.nteams > 1) {\n        ++level; // level was not increased in teams construct for\n        // team_of_masters\n      }\n      if (team->t.t_pkfn != (microtask_t)__kmp_teams_master &&\n          master_th->th.th_teams_level == team->t.t_level) {\n        ++level; // level was not increased in teams construct for\n        // team_of_workers before the parallel\n      } // team->t.t_level will be increased inside parallel\n    }\n    if (level < __kmp_hot_teams_max_level) {\n      if (hot_teams[level].hot_team) {\n        // hot team has already been allocated for given level\n        KMP_DEBUG_ASSERT(hot_teams[level].hot_team == team);\n        use_hot_team = 1; // the team is ready to use\n      } else {\n        use_hot_team = 0; // AC: threads are not allocated yet\n        hot_teams[level].hot_team = team; // remember new hot team\n        hot_teams[level].hot_team_nth = team->t.t_nproc;\n      }\n    } else {\n      use_hot_team = 0;\n    }\n  }\n#else\n  use_hot_team = team == root->r.r_hot_team;\n#endif\n  if (!use_hot_team) {\n\n    /* install the primary thread */\n    team->t.t_threads[0] = master_th;\n    __kmp_initialize_info(master_th, team, 0, master_gtid);\n\n    /* now, install the worker threads */\n    for (i = 1; i < team->t.t_nproc; i++) {\n\n      /* fork or reallocate a new thread and install it in team */\n      kmp_info_t *thr = __kmp_allocate_thread(root, team, i);\n      team->t.t_threads[i] = thr;\n      KMP_DEBUG_ASSERT(thr);\n      KMP_DEBUG_ASSERT(thr->th.th_team == team);\n      /* align team and thread arrived states */\n      KA_TRACE(20, (\"__kmp_fork_team_threads: T#%d(%d:%d) init arrived \"\n                    \"T#%d(%d:%d) join =%llu, plain=%llu\\n\",\n                    __kmp_gtid_from_tid(0, team), team->t.t_id, 0,\n                    __kmp_gtid_from_tid(i, team), team->t.t_id, i,\n                    team->t.t_bar[bs_forkjoin_barrier].b_arrived,\n                    team->t.t_bar[bs_plain_barrier].b_arrived));\n      thr->th.th_teams_microtask = master_th->th.th_teams_microtask;\n      thr->th.th_teams_level = master_th->th.th_teams_level;\n      thr->th.th_teams_size = master_th->th.th_teams_size;\n      { // Initialize threads' barrier data.\n        int b;\n        kmp_balign_t *balign = team->t.t_threads[i]->th.th_bar;\n        for (b = 0; b < bs_last_barrier; ++b) {\n          balign[b].bb.b_arrived = team->t.t_bar[b].b_arrived;\n          KMP_DEBUG_ASSERT(balign[b].bb.wait_flag != KMP_BARRIER_PARENT_FLAG);\n#if USE_DEBUGGER\n          balign[b].bb.b_worker_arrived = team->t.t_bar[b].b_team_arrived;\n#endif\n        }\n      }\n    }\n\n#if KMP_AFFINITY_SUPPORTED\n    __kmp_partition_places(team);\n#endif\n  }\n\n  if (__kmp_display_affinity && team->t.t_display_affinity != 1) {\n    for (i = 0; i < team->t.t_nproc; i++) {\n      kmp_info_t *thr = team->t.t_threads[i];\n      if (thr->th.th_prev_num_threads != team->t.t_nproc ||\n          thr->th.th_prev_level != team->t.t_level) {\n        team->t.t_display_affinity = 1;\n        break;\n      }\n    }\n  }\n\n  KMP_MB();\n}\n\n#if KMP_ARCH_X86 || KMP_ARCH_X86_64\n// Propagate any changes to the floating point control registers out to the team\n// We try to avoid unnecessary writes to the relevant cache line in the team\n// structure, so we don't make changes unless they are needed.\ninline static void propagateFPControl(kmp_team_t *team) {\n  if (__kmp_inherit_fp_control) {\n    kmp_int16 x87_fpu_control_word;\n    kmp_uint32 mxcsr;\n\n    // Get primary thread's values of FPU control flags (both X87 and vector)\n    __kmp_store_x87_fpu_control_word(&x87_fpu_control_word);\n    __kmp_store_mxcsr(&mxcsr);\n    mxcsr &= KMP_X86_MXCSR_MASK;\n\n    // There is no point looking at t_fp_control_saved here.\n    // If it is TRUE, we still have to update the values if they are different\n    // from those we now have. If it is FALSE we didn't save anything yet, but\n    // our objective is the same. We have to ensure that the values in the team\n    // are the same as those we have.\n    // So, this code achieves what we need whether or not t_fp_control_saved is\n    // true. By checking whether the value needs updating we avoid unnecessary\n    // writes that would put the cache-line into a written state, causing all\n    // threads in the team to have to read it again.\n    KMP_CHECK_UPDATE(team->t.t_x87_fpu_control_word, x87_fpu_control_word);\n    KMP_CHECK_UPDATE(team->t.t_mxcsr, mxcsr);\n    // Although we don't use this value, other code in the runtime wants to know\n    // whether it should restore them. So we must ensure it is correct.\n    KMP_CHECK_UPDATE(team->t.t_fp_control_saved, TRUE);\n  } else {\n    // Similarly here. Don't write to this cache-line in the team structure\n    // unless we have to.\n    KMP_CHECK_UPDATE(team->t.t_fp_control_saved, FALSE);\n  }\n}\n\n// Do the opposite, setting the hardware registers to the updated values from\n// the team.\ninline static void updateHWFPControl(kmp_team_t *team) {\n  if (__kmp_inherit_fp_control && team->t.t_fp_control_saved) {\n    // Only reset the fp control regs if they have been changed in the team.\n    // the parallel region that we are exiting.\n    kmp_int16 x87_fpu_control_word;\n    kmp_uint32 mxcsr;\n    __kmp_store_x87_fpu_control_word(&x87_fpu_control_word);\n    __kmp_store_mxcsr(&mxcsr);\n    mxcsr &= KMP_X86_MXCSR_MASK;\n\n    if (team->t.t_x87_fpu_control_word != x87_fpu_control_word) {\n      __kmp_clear_x87_fpu_status_word();\n      __kmp_load_x87_fpu_control_word(&team->t.t_x87_fpu_control_word);\n    }\n\n    if (team->t.t_mxcsr != mxcsr) {\n      __kmp_load_mxcsr(&team->t.t_mxcsr);\n    }\n  }\n}\n#else\n#define propagateFPControl(x) ((void)0)\n#define updateHWFPControl(x) ((void)0)\n#endif /* KMP_ARCH_X86 || KMP_ARCH_X86_64 */\n\nstatic void __kmp_alloc_argv_entries(int argc, kmp_team_t *team,\n                                     int realloc); // forward declaration\n\n/* Run a parallel region that has been serialized, so runs only in a team of the\n   single primary thread. */\nvoid __kmp_serialized_parallel(ident_t *loc, kmp_int32 global_tid) {\n  kmp_info_t *this_thr;\n  kmp_team_t *serial_team;\n\n  KC_TRACE(10, (\"__kmpc_serialized_parallel: called by T#%d\\n\", global_tid));\n\n  /* Skip all this code for autopar serialized loops since it results in\n     unacceptable overhead */\n  if (loc != NULL && (loc->flags & KMP_IDENT_AUTOPAR))\n    return;\n\n  if (!TCR_4(__kmp_init_parallel))\n    __kmp_parallel_initialize();\n  __kmp_resume_if_soft_paused();\n\n  this_thr = __kmp_threads[global_tid];\n  serial_team = this_thr->th.th_serial_team;\n\n  /* utilize the serialized team held by this thread */\n  KMP_DEBUG_ASSERT(serial_team);\n  KMP_MB();\n\n  if (__kmp_tasking_mode != tskm_immediate_exec) {\n    KMP_DEBUG_ASSERT(\n        this_thr->th.th_task_team ==\n        this_thr->th.th_team->t.t_task_team[this_thr->th.th_task_state]);\n    KMP_DEBUG_ASSERT(serial_team->t.t_task_team[this_thr->th.th_task_state] ==\n                     NULL);\n    KA_TRACE(20, (\"__kmpc_serialized_parallel: T#%d pushing task_team %p / \"\n                  \"team %p, new task_team = NULL\\n\",\n                  global_tid, this_thr->th.th_task_team, this_thr->th.th_team));\n    this_thr->th.th_task_team = NULL;\n  }\n\n  kmp_proc_bind_t proc_bind = this_thr->th.th_set_proc_bind;\n  if (this_thr->th.th_current_task->td_icvs.proc_bind == proc_bind_false) {\n    proc_bind = proc_bind_false;\n  } else if (proc_bind == proc_bind_default) {\n    // No proc_bind clause was specified, so use the current value\n    // of proc-bind-var for this parallel region.\n    proc_bind = this_thr->th.th_current_task->td_icvs.proc_bind;\n  }\n  // Reset for next parallel region\n  this_thr->th.th_set_proc_bind = proc_bind_default;\n\n#if OMPT_SUPPORT\n  ompt_data_t ompt_parallel_data = ompt_data_none;\n  ompt_data_t *implicit_task_data;\n  void *codeptr = OMPT_LOAD_RETURN_ADDRESS(global_tid);\n  if (ompt_enabled.enabled &&\n      this_thr->th.ompt_thread_info.state != ompt_state_overhead) {\n\n    ompt_task_info_t *parent_task_info;\n    parent_task_info = OMPT_CUR_TASK_INFO(this_thr);\n\n    parent_task_info->frame.enter_frame.ptr = OMPT_GET_FRAME_ADDRESS(0);\n    if (ompt_enabled.ompt_callback_parallel_begin) {\n      int team_size = 1;\n\n      ompt_callbacks.ompt_callback(ompt_callback_parallel_begin)(\n          &(parent_task_info->task_data), &(parent_task_info->frame),\n          &ompt_parallel_data, team_size,\n          ompt_parallel_invoker_program | ompt_parallel_team, codeptr);\n    }\n  }\n#endif // OMPT_SUPPORT\n\n  if (this_thr->th.th_team != serial_team) {\n    // Nested level will be an index in the nested nthreads array\n    int level = this_thr->th.th_team->t.t_level;\n\n    if (serial_team->t.t_serialized) {\n      /* this serial team was already used\n         TODO increase performance by making this locks more specific */\n      kmp_team_t *new_team;\n\n      __kmp_acquire_bootstrap_lock(&__kmp_forkjoin_lock);\n\n      new_team =\n          __kmp_allocate_team(this_thr->th.th_root, 1, 1,\n#if OMPT_SUPPORT\n                              ompt_parallel_data,\n#endif\n                              proc_bind, &this_thr->th.th_current_task->td_icvs,\n                              0 USE_NESTED_HOT_ARG(NULL));\n      __kmp_release_bootstrap_lock(&__kmp_forkjoin_lock);\n      KMP_ASSERT(new_team);\n\n      /* setup new serialized team and install it */\n      new_team->t.t_threads[0] = this_thr;\n      new_team->t.t_parent = this_thr->th.th_team;\n      serial_team = new_team;\n      this_thr->th.th_serial_team = serial_team;\n\n      KF_TRACE(\n          10,\n          (\"__kmpc_serialized_parallel: T#%d allocated new serial team %p\\n\",\n           global_tid, serial_team));\n\n      /* TODO the above breaks the requirement that if we run out of resources,\n         then we can still guarantee that serialized teams are ok, since we may\n         need to allocate a new one */\n    } else {\n      KF_TRACE(\n          10,\n          (\"__kmpc_serialized_parallel: T#%d reusing cached serial team %p\\n\",\n           global_tid, serial_team));\n    }\n\n    /* we have to initialize this serial team */\n    KMP_DEBUG_ASSERT(serial_team->t.t_threads);\n    KMP_DEBUG_ASSERT(serial_team->t.t_threads[0] == this_thr);\n    KMP_DEBUG_ASSERT(this_thr->th.th_team != serial_team);\n    serial_team->t.t_ident = loc;\n    serial_team->t.t_serialized = 1;\n    serial_team->t.t_nproc = 1;\n    serial_team->t.t_parent = this_thr->th.th_team;\n    serial_team->t.t_sched.sched = this_thr->th.th_team->t.t_sched.sched;\n    this_thr->th.th_team = serial_team;\n    serial_team->t.t_master_tid = this_thr->th.th_info.ds.ds_tid;\n\n    KF_TRACE(10, (\"__kmpc_serialized_parallel: T#d curtask=%p\\n\", global_tid,\n                  this_thr->th.th_current_task));\n    KMP_ASSERT(this_thr->th.th_current_task->td_flags.executing == 1);\n    this_thr->th.th_current_task->td_flags.executing = 0;\n\n    __kmp_push_current_task_to_thread(this_thr, serial_team, 0);\n\n    /* TODO: GEH: do ICVs work for nested serialized teams? Don't we need an\n       implicit task for each serialized task represented by\n       team->t.t_serialized? */\n    copy_icvs(&this_thr->th.th_current_task->td_icvs,\n              &this_thr->th.th_current_task->td_parent->td_icvs);\n\n    // Thread value exists in the nested nthreads array for the next nested\n    // level\n    if (__kmp_nested_nth.used && (level + 1 < __kmp_nested_nth.used)) {\n      this_thr->th.th_current_task->td_icvs.nproc =\n          __kmp_nested_nth.nth[level + 1];\n    }\n\n    if (__kmp_nested_proc_bind.used &&\n        (level + 1 < __kmp_nested_proc_bind.used)) {\n      this_thr->th.th_current_task->td_icvs.proc_bind =\n          __kmp_nested_proc_bind.bind_types[level + 1];\n    }\n\n#if USE_DEBUGGER\n    serial_team->t.t_pkfn = (microtask_t)(~0); // For the debugger.\n#endif\n    this_thr->th.th_info.ds.ds_tid = 0;\n\n    /* set thread cache values */\n    this_thr->th.th_team_nproc = 1;\n    this_thr->th.th_team_master = this_thr;\n    this_thr->th.th_team_serialized = 1;\n\n    serial_team->t.t_level = serial_team->t.t_parent->t.t_level + 1;\n    serial_team->t.t_active_level = serial_team->t.t_parent->t.t_active_level;\n    serial_team->t.t_def_allocator = this_thr->th.th_def_allocator; // save\n\n    propagateFPControl(serial_team);\n\n    /* check if we need to allocate dispatch buffers stack */\n    KMP_DEBUG_ASSERT(serial_team->t.t_dispatch);\n    if (!serial_team->t.t_dispatch->th_disp_buffer) {\n      serial_team->t.t_dispatch->th_disp_buffer =\n          (dispatch_private_info_t *)__kmp_allocate(\n              sizeof(dispatch_private_info_t));\n    }\n    this_thr->th.th_dispatch = serial_team->t.t_dispatch;\n\n    KMP_MB();\n\n  } else {\n    /* this serialized team is already being used,\n     * that's fine, just add another nested level */\n    KMP_DEBUG_ASSERT(this_thr->th.th_team == serial_team);\n    KMP_DEBUG_ASSERT(serial_team->t.t_threads);\n    KMP_DEBUG_ASSERT(serial_team->t.t_threads[0] == this_thr);\n    ++serial_team->t.t_serialized;\n    this_thr->th.th_team_serialized = serial_team->t.t_serialized;\n\n    // Nested level will be an index in the nested nthreads array\n    int level = this_thr->th.th_team->t.t_level;\n    // Thread value exists in the nested nthreads array for the next nested\n    // level\n    if (__kmp_nested_nth.used && (level + 1 < __kmp_nested_nth.used)) {\n      this_thr->th.th_current_task->td_icvs.nproc =\n          __kmp_nested_nth.nth[level + 1];\n    }\n    serial_team->t.t_level++;\n    KF_TRACE(10, (\"__kmpc_serialized_parallel: T#%d increasing nesting level \"\n                  \"of serial team %p to %d\\n\",\n                  global_tid, serial_team, serial_team->t.t_level));\n\n    /* allocate/push dispatch buffers stack */\n    KMP_DEBUG_ASSERT(serial_team->t.t_dispatch);\n    {\n      dispatch_private_info_t *disp_buffer =\n          (dispatch_private_info_t *)__kmp_allocate(\n              sizeof(dispatch_private_info_t));\n      disp_buffer->next = serial_team->t.t_dispatch->th_disp_buffer;\n      serial_team->t.t_dispatch->th_disp_buffer = disp_buffer;\n    }\n    this_thr->th.th_dispatch = serial_team->t.t_dispatch;\n\n    KMP_MB();\n  }\n  KMP_CHECK_UPDATE(serial_team->t.t_cancel_request, cancel_noreq);\n\n  // Perform the display affinity functionality for\n  // serialized parallel regions\n  if (__kmp_display_affinity) {\n    if (this_thr->th.th_prev_level != serial_team->t.t_level ||\n        this_thr->th.th_prev_num_threads != 1) {\n      // NULL means use the affinity-format-var ICV\n      __kmp_aux_display_affinity(global_tid, NULL);\n      this_thr->th.th_prev_level = serial_team->t.t_level;\n      this_thr->th.th_prev_num_threads = 1;\n    }\n  }\n\n  if (__kmp_env_consistency_check)\n    __kmp_push_parallel(global_tid, NULL);\n#if OMPT_SUPPORT\n  serial_team->t.ompt_team_info.master_return_address = codeptr;\n  if (ompt_enabled.enabled &&\n      this_thr->th.ompt_thread_info.state != ompt_state_overhead) {\n    OMPT_CUR_TASK_INFO(this_thr)->frame.exit_frame.ptr =\n        OMPT_GET_FRAME_ADDRESS(0);\n\n    ompt_lw_taskteam_t lw_taskteam;\n    __ompt_lw_taskteam_init(&lw_taskteam, this_thr, global_tid,\n                            &ompt_parallel_data, codeptr);\n\n    __ompt_lw_taskteam_link(&lw_taskteam, this_thr, 1);\n    // don't use lw_taskteam after linking. content was swaped\n\n    /* OMPT implicit task begin */\n    implicit_task_data = OMPT_CUR_TASK_DATA(this_thr);\n    if (ompt_enabled.ompt_callback_implicit_task) {\n      ompt_callbacks.ompt_callback(ompt_callback_implicit_task)(\n          ompt_scope_begin, OMPT_CUR_TEAM_DATA(this_thr),\n          OMPT_CUR_TASK_DATA(this_thr), 1, __kmp_tid_from_gtid(global_tid),\n          ompt_task_implicit); // TODO: Can this be ompt_task_initial?\n      OMPT_CUR_TASK_INFO(this_thr)->thread_num =\n          __kmp_tid_from_gtid(global_tid);\n    }\n\n    /* OMPT state */\n    this_thr->th.ompt_thread_info.state = ompt_state_work_parallel;\n    OMPT_CUR_TASK_INFO(this_thr)->frame.exit_frame.ptr =\n        OMPT_GET_FRAME_ADDRESS(0);\n  }\n#endif\n}\n\n/* most of the work for a fork */\n/* return true if we really went parallel, false if serialized */\nint __kmp_fork_call(ident_t *loc, int gtid,\n                    enum fork_context_e call_context, // Intel, GNU, ...\n                    kmp_int32 argc, microtask_t microtask, launch_t invoker,\n                    kmp_va_list ap) {\n  void **argv;\n  int i;\n  int master_tid;\n  int master_this_cons;\n  kmp_team_t *team;\n  kmp_team_t *parent_team;\n  kmp_info_t *master_th;\n  kmp_root_t *root;\n  int nthreads;\n  int master_active;\n  int master_set_numthreads;\n  int level;\n  int active_level;\n  int teams_level;\n#if KMP_NESTED_HOT_TEAMS\n  kmp_hot_team_ptr_t **p_hot_teams;\n#endif\n  { // KMP_TIME_BLOCK\n    KMP_TIME_DEVELOPER_PARTITIONED_BLOCK(KMP_fork_call);\n    KMP_COUNT_VALUE(OMP_PARALLEL_args, argc);\n\n    KA_TRACE(20, (\"__kmp_fork_call: enter T#%d\\n\", gtid));\n    if (__kmp_stkpadding > 0 && __kmp_root[gtid] != NULL) {\n      /* Some systems prefer the stack for the root thread(s) to start with */\n      /* some gap from the parent stack to prevent false sharing. */\n      void *dummy = KMP_ALLOCA(__kmp_stkpadding);\n      /* These 2 lines below are so this does not get optimized out */\n      if (__kmp_stkpadding > KMP_MAX_STKPADDING)\n        __kmp_stkpadding += (short)((kmp_int64)dummy);\n    }\n\n    /* initialize if needed */\n    KMP_DEBUG_ASSERT(\n        __kmp_init_serial); // AC: potentially unsafe, not in sync with shutdown\n    if (!TCR_4(__kmp_init_parallel))\n      __kmp_parallel_initialize();\n    __kmp_resume_if_soft_paused();\n\n    /* setup current data */\n    master_th = __kmp_threads[gtid]; // AC: potentially unsafe, not in sync with\n    // shutdown\n    parent_team = master_th->th.th_team;\n    master_tid = master_th->th.th_info.ds.ds_tid;\n    master_this_cons = master_th->th.th_local.this_construct;\n    root = master_th->th.th_root;\n    master_active = root->r.r_active;\n    master_set_numthreads = master_th->th.th_set_nproc;\n\n#if OMPT_SUPPORT\n    ompt_data_t ompt_parallel_data = ompt_data_none;\n    ompt_data_t *parent_task_data;\n    ompt_frame_t *ompt_frame;\n    ompt_data_t *implicit_task_data;\n    void *return_address = NULL;\n\n    if (ompt_enabled.enabled) {\n      __ompt_get_task_info_internal(0, NULL, &parent_task_data, &ompt_frame,\n                                    NULL, NULL);\n      return_address = OMPT_LOAD_RETURN_ADDRESS(gtid);\n    }\n#endif\n\n    // Nested level will be an index in the nested nthreads array\n    level = parent_team->t.t_level;\n    // used to launch non-serial teams even if nested is not allowed\n    active_level = parent_team->t.t_active_level;\n    // needed to check nesting inside the teams\n    teams_level = master_th->th.th_teams_level;\n#if KMP_NESTED_HOT_TEAMS\n    p_hot_teams = &master_th->th.th_hot_teams;\n    if (*p_hot_teams == NULL && __kmp_hot_teams_max_level > 0) {\n      *p_hot_teams = (kmp_hot_team_ptr_t *)__kmp_allocate(\n          sizeof(kmp_hot_team_ptr_t) * __kmp_hot_teams_max_level);\n      (*p_hot_teams)[0].hot_team = root->r.r_hot_team;\n      // it is either actual or not needed (when active_level > 0)\n      (*p_hot_teams)[0].hot_team_nth = 1;\n    }\n#endif\n\n#if OMPT_SUPPORT\n    if (ompt_enabled.enabled) {\n      if (ompt_enabled.ompt_callback_parallel_begin) {\n        int team_size = master_set_numthreads\n                            ? master_set_numthreads\n                            : get__nproc_2(parent_team, master_tid);\n        int flags = OMPT_INVOKER(call_context) |\n                    ((microtask == (microtask_t)__kmp_teams_master)\n                         ? ompt_parallel_league\n                         : ompt_parallel_team);\n        ompt_callbacks.ompt_callback(ompt_callback_parallel_begin)(\n            parent_task_data, ompt_frame, &ompt_parallel_data, team_size, flags,\n            return_address);\n      }\n      master_th->th.ompt_thread_info.state = ompt_state_overhead;\n    }\n#endif\n\n    master_th->th.th_ident = loc;\n\n    if (master_th->th.th_teams_microtask && ap &&\n        microtask != (microtask_t)__kmp_teams_master && level == teams_level) {\n      // AC: This is start of parallel that is nested inside teams construct.\n      // The team is actual (hot), all workers are ready at the fork barrier.\n      // No lock needed to initialize the team a bit, then free workers.\n      parent_team->t.t_ident = loc;\n      __kmp_alloc_argv_entries(argc, parent_team, TRUE);\n      parent_team->t.t_argc = argc;\n      argv = (void **)parent_team->t.t_argv;\n      for (i = argc - 1; i >= 0; --i)\n        *argv++ = va_arg(kmp_va_deref(ap), void *);\n      // Increment our nested depth levels, but not increase the serialization\n      if (parent_team == master_th->th.th_serial_team) {\n        // AC: we are in serialized parallel\n        __kmpc_serialized_parallel(loc, gtid);\n        KMP_DEBUG_ASSERT(parent_team->t.t_serialized > 1);\n\n        if (call_context == fork_context_gnu) {\n          // AC: need to decrement t_serialized for enquiry functions to work\n          // correctly, will restore at join time\n          parent_team->t.t_serialized--;\n          return TRUE;\n        }\n\n#if OMPT_SUPPORT\n        void *dummy;\n        void **exit_frame_p;\n\n        ompt_lw_taskteam_t lw_taskteam;\n\n        if (ompt_enabled.enabled) {\n          __ompt_lw_taskteam_init(&lw_taskteam, master_th, gtid,\n                                  &ompt_parallel_data, return_address);\n          exit_frame_p = &(lw_taskteam.ompt_task_info.frame.exit_frame.ptr);\n\n          __ompt_lw_taskteam_link(&lw_taskteam, master_th, 0);\n          // don't use lw_taskteam after linking. content was swaped\n\n          /* OMPT implicit task begin */\n          implicit_task_data = OMPT_CUR_TASK_DATA(master_th);\n          if (ompt_enabled.ompt_callback_implicit_task) {\n            OMPT_CUR_TASK_INFO(master_th)->thread_num =\n                __kmp_tid_from_gtid(gtid);\n            ompt_callbacks.ompt_callback(ompt_callback_implicit_task)(\n                ompt_scope_begin, OMPT_CUR_TEAM_DATA(master_th),\n                implicit_task_data, 1,\n                OMPT_CUR_TASK_INFO(master_th)->thread_num, ompt_task_implicit);\n          }\n\n          /* OMPT state */\n          master_th->th.ompt_thread_info.state = ompt_state_work_parallel;\n        } else {\n          exit_frame_p = &dummy;\n        }\n#endif\n        // AC: need to decrement t_serialized for enquiry functions to work\n        // correctly, will restore at join time\n        parent_team->t.t_serialized--;\n\n        {\n          KMP_TIME_PARTITIONED_BLOCK(OMP_parallel);\n          KMP_SET_THREAD_STATE_BLOCK(IMPLICIT_TASK);\n          __kmp_invoke_microtask(microtask, gtid, 0, argc, parent_team->t.t_argv\n#if OMPT_SUPPORT\n                                 ,\n                                 exit_frame_p\n#endif\n          );\n        }\n\n#if OMPT_SUPPORT\n        if (ompt_enabled.enabled) {\n          *exit_frame_p = NULL;\n          OMPT_CUR_TASK_INFO(master_th)->frame.exit_frame = ompt_data_none;\n          if (ompt_enabled.ompt_callback_implicit_task) {\n            ompt_callbacks.ompt_callback(ompt_callback_implicit_task)(\n                ompt_scope_end, NULL, implicit_task_data, 1,\n                OMPT_CUR_TASK_INFO(master_th)->thread_num, ompt_task_implicit);\n          }\n          ompt_parallel_data = *OMPT_CUR_TEAM_DATA(master_th);\n          __ompt_lw_taskteam_unlink(master_th);\n          if (ompt_enabled.ompt_callback_parallel_end) {\n            ompt_callbacks.ompt_callback(ompt_callback_parallel_end)(\n                &ompt_parallel_data, OMPT_CUR_TASK_DATA(master_th),\n                OMPT_INVOKER(call_context) | ompt_parallel_team,\n                return_address);\n          }\n          master_th->th.ompt_thread_info.state = ompt_state_overhead;\n        }\n#endif\n        return TRUE;\n      }\n\n      parent_team->t.t_pkfn = microtask;\n      parent_team->t.t_invoke = invoker;\n      KMP_ATOMIC_INC(&root->r.r_in_parallel);\n      parent_team->t.t_active_level++;\n      parent_team->t.t_level++;\n      parent_team->t.t_def_allocator = master_th->th.th_def_allocator; // save\n\n#if OMPT_SUPPORT\n      if (ompt_enabled.enabled) {\n        ompt_lw_taskteam_t lw_taskteam;\n        __ompt_lw_taskteam_init(&lw_taskteam, master_th, gtid,\n                                &ompt_parallel_data, return_address);\n        __ompt_lw_taskteam_link(&lw_taskteam, master_th, 1, true);\n      }\n#endif\n\n      /* Change number of threads in the team if requested */\n      if (master_set_numthreads) { // The parallel has num_threads clause\n        if (master_set_numthreads < master_th->th.th_teams_size.nth) {\n          // AC: only can reduce number of threads dynamically, can't increase\n          kmp_info_t **other_threads = parent_team->t.t_threads;\n          parent_team->t.t_nproc = master_set_numthreads;\n          for (i = 0; i < master_set_numthreads; ++i) {\n            other_threads[i]->th.th_team_nproc = master_set_numthreads;\n          }\n          // Keep extra threads hot in the team for possible next parallels\n        }\n        master_th->th.th_set_nproc = 0;\n      }\n\n#if USE_DEBUGGER\n      if (__kmp_debugging) { // Let debugger override number of threads.\n        int nth = __kmp_omp_num_threads(loc);\n        if (nth > 0) { // 0 means debugger doesn't want to change num threads\n          master_set_numthreads = nth;\n        }\n      }\n#endif\n\n#if USE_ITT_BUILD && USE_ITT_NOTIFY\n      if (((__itt_frame_submit_v3_ptr && __itt_get_timestamp_ptr) ||\n           KMP_ITT_DEBUG) &&\n          __kmp_forkjoin_frames_mode == 3 &&\n          parent_team->t.t_active_level == 1 // only report frames at level 1\n          && master_th->th.th_teams_size.nteams == 1) {\n        kmp_uint64 tmp_time = __itt_get_timestamp();\n        master_th->th.th_frame_time = tmp_time;\n        parent_team->t.t_region_time = tmp_time;\n      }\n      if (__itt_stack_caller_create_ptr) {\n        KMP_DEBUG_ASSERT(parent_team->t.t_stack_id == NULL);\n        // create new stack stitching id before entering fork barrier\n        parent_team->t.t_stack_id = __kmp_itt_stack_caller_create();\n      }\n#endif /* USE_ITT_BUILD && USE_ITT_NOTIFY */\n\n      KF_TRACE(10, (\"__kmp_fork_call: before internal fork: root=%p, team=%p, \"\n                    \"master_th=%p, gtid=%d\\n\",\n                    root, parent_team, master_th, gtid));\n      __kmp_internal_fork(loc, gtid, parent_team);\n      KF_TRACE(10, (\"__kmp_fork_call: after internal fork: root=%p, team=%p, \"\n                    \"master_th=%p, gtid=%d\\n\",\n                    root, parent_team, master_th, gtid));\n\n      if (call_context == fork_context_gnu)\n        return TRUE;\n\n      /* Invoke microtask for PRIMARY thread */\n      KA_TRACE(20, (\"__kmp_fork_call: T#%d(%d:0) invoke microtask = %p\\n\", gtid,\n                    parent_team->t.t_id, parent_team->t.t_pkfn));\n\n      if (!parent_team->t.t_invoke(gtid)) {\n        KMP_ASSERT2(0, \"cannot invoke microtask for PRIMARY thread\");\n      }\n      KA_TRACE(20, (\"__kmp_fork_call: T#%d(%d:0) done microtask = %p\\n\", gtid,\n                    parent_team->t.t_id, parent_team->t.t_pkfn));\n      KMP_MB(); /* Flush all pending memory write invalidates.  */\n\n      KA_TRACE(20, (\"__kmp_fork_call: parallel exit T#%d\\n\", gtid));\n\n      return TRUE;\n    } // Parallel closely nested in teams construct\n\n#if KMP_DEBUG\n    if (__kmp_tasking_mode != tskm_immediate_exec) {\n      KMP_DEBUG_ASSERT(master_th->th.th_task_team ==\n                       parent_team->t.t_task_team[master_th->th.th_task_state]);\n    }\n#endif\n\n    int enter_teams = 0;\n    if (parent_team->t.t_active_level >=\n        master_th->th.th_current_task->td_icvs.max_active_levels) {\n      nthreads = 1;\n    } else {\n      enter_teams = ((ap == NULL && active_level == 0) ||\n                     (ap && teams_level > 0 && teams_level == level));\n      nthreads =\n          master_set_numthreads\n              ? master_set_numthreads\n              : get__nproc_2(\n                    parent_team,\n                    master_tid); // TODO: get nproc directly from current task\n\n      // Check if we need to take forkjoin lock? (no need for serialized\n      // parallel out of teams construct). This code moved here from\n      // __kmp_reserve_threads() to speedup nested serialized parallels.\n      if (nthreads > 1) {\n        if ((get__max_active_levels(master_th) == 1 &&\n             (root->r.r_in_parallel && !enter_teams)) ||\n            (__kmp_library == library_serial)) {\n          KC_TRACE(10, (\"__kmp_fork_call: T#%d serializing team; requested %d\"\n                        \" threads\\n\",\n                        gtid, nthreads));\n          nthreads = 1;\n        }\n      }\n      if (nthreads > 1) {\n        /* determine how many new threads we can use */\n        __kmp_acquire_bootstrap_lock(&__kmp_forkjoin_lock);\n        /* AC: If we execute teams from parallel region (on host), then teams\n           should be created but each can only have 1 thread if nesting is\n           disabled. If teams called from serial region, then teams and their\n           threads should be created regardless of the nesting setting. */\n        nthreads = __kmp_reserve_threads(root, parent_team, master_tid,\n                                         nthreads, enter_teams);\n        if (nthreads == 1) {\n          // Free lock for single thread execution here; for multi-thread\n          // execution it will be freed later after team of threads created\n          // and initialized\n          __kmp_release_bootstrap_lock(&__kmp_forkjoin_lock);\n        }\n      }\n    }\n    KMP_DEBUG_ASSERT(nthreads > 0);\n\n    // If we temporarily changed the set number of threads then restore it now\n    master_th->th.th_set_nproc = 0;\n\n    /* create a serialized parallel region? */\n    if (nthreads == 1) {\n/* josh todo: hypothetical question: what do we do for OS X*? */\n#if KMP_OS_LINUX &&                                                            \\\n    (KMP_ARCH_X86 || KMP_ARCH_X86_64 || KMP_ARCH_ARM || KMP_ARCH_AARCH64)\n      void *args[argc];\n#else\n      void **args = (void **)KMP_ALLOCA(argc * sizeof(void *));\n#endif /* KMP_OS_LINUX && ( KMP_ARCH_X86 || KMP_ARCH_X86_64 || KMP_ARCH_ARM || \\\n          KMP_ARCH_AARCH64) */\n\n      KA_TRACE(20,\n               (\"__kmp_fork_call: T#%d serializing parallel region\\n\", gtid));\n\n      __kmpc_serialized_parallel(loc, gtid);\n\n      if (call_context == fork_context_intel) {\n        /* TODO this sucks, use the compiler itself to pass args! :) */\n        master_th->th.th_serial_team->t.t_ident = loc;\n        if (!ap) {\n          // revert change made in __kmpc_serialized_parallel()\n          master_th->th.th_serial_team->t.t_level--;\n          // Get args from parent team for teams construct\n\n#if OMPT_SUPPORT\n          void *dummy;\n          void **exit_frame_p;\n          ompt_task_info_t *task_info;\n\n          ompt_lw_taskteam_t lw_taskteam;\n\n          if (ompt_enabled.enabled) {\n            __ompt_lw_taskteam_init(&lw_taskteam, master_th, gtid,\n                                    &ompt_parallel_data, return_address);\n\n            __ompt_lw_taskteam_link(&lw_taskteam, master_th, 0);\n            // don't use lw_taskteam after linking. content was swaped\n\n            task_info = OMPT_CUR_TASK_INFO(master_th);\n            exit_frame_p = &(task_info->frame.exit_frame.ptr);\n            if (ompt_enabled.ompt_callback_implicit_task) {\n              OMPT_CUR_TASK_INFO(master_th)->thread_num =\n                  __kmp_tid_from_gtid(gtid);\n              ompt_callbacks.ompt_callback(ompt_callback_implicit_task)(\n                  ompt_scope_begin, OMPT_CUR_TEAM_DATA(master_th),\n                  &(task_info->task_data), 1,\n                  OMPT_CUR_TASK_INFO(master_th)->thread_num,\n                  ompt_task_implicit);\n            }\n\n            /* OMPT state */\n            master_th->th.ompt_thread_info.state = ompt_state_work_parallel;\n          } else {\n            exit_frame_p = &dummy;\n          }\n#endif\n\n          {\n            KMP_TIME_PARTITIONED_BLOCK(OMP_parallel);\n            KMP_SET_THREAD_STATE_BLOCK(IMPLICIT_TASK);\n            __kmp_invoke_microtask(microtask, gtid, 0, argc,\n                                   parent_team->t.t_argv\n#if OMPT_SUPPORT\n                                   ,\n                                   exit_frame_p\n#endif\n            );\n          }\n\n#if OMPT_SUPPORT\n          if (ompt_enabled.enabled) {\n            *exit_frame_p = NULL;\n            if (ompt_enabled.ompt_callback_implicit_task) {\n              ompt_callbacks.ompt_callback(ompt_callback_implicit_task)(\n                  ompt_scope_end, NULL, &(task_info->task_data), 1,\n                  OMPT_CUR_TASK_INFO(master_th)->thread_num,\n                  ompt_task_implicit);\n            }\n            ompt_parallel_data = *OMPT_CUR_TEAM_DATA(master_th);\n            __ompt_lw_taskteam_unlink(master_th);\n            if (ompt_enabled.ompt_callback_parallel_end) {\n              ompt_callbacks.ompt_callback(ompt_callback_parallel_end)(\n                  &ompt_parallel_data, parent_task_data,\n                  OMPT_INVOKER(call_context) | ompt_parallel_team,\n                  return_address);\n            }\n            master_th->th.ompt_thread_info.state = ompt_state_overhead;\n          }\n#endif\n        } else if (microtask == (microtask_t)__kmp_teams_master) {\n          KMP_DEBUG_ASSERT(master_th->th.th_team ==\n                           master_th->th.th_serial_team);\n          team = master_th->th.th_team;\n          // team->t.t_pkfn = microtask;\n          team->t.t_invoke = invoker;\n          __kmp_alloc_argv_entries(argc, team, TRUE);\n          team->t.t_argc = argc;\n          argv = (void **)team->t.t_argv;\n          if (ap) {\n            for (i = argc - 1; i >= 0; --i)\n              *argv++ = va_arg(kmp_va_deref(ap), void *);\n          } else {\n            for (i = 0; i < argc; ++i)\n              // Get args from parent team for teams construct\n              argv[i] = parent_team->t.t_argv[i];\n          }\n          // AC: revert change made in __kmpc_serialized_parallel()\n          //     because initial code in teams should have level=0\n          team->t.t_level--;\n          // AC: call special invoker for outer \"parallel\" of teams construct\n          invoker(gtid);\n#if OMPT_SUPPORT\n          if (ompt_enabled.enabled) {\n            ompt_task_info_t *task_info = OMPT_CUR_TASK_INFO(master_th);\n            if (ompt_enabled.ompt_callback_implicit_task) {\n              ompt_callbacks.ompt_callback(ompt_callback_implicit_task)(\n                  ompt_scope_end, NULL, &(task_info->task_data), 0,\n                  OMPT_CUR_TASK_INFO(master_th)->thread_num, ompt_task_initial);\n            }\n            if (ompt_enabled.ompt_callback_parallel_end) {\n              ompt_callbacks.ompt_callback(ompt_callback_parallel_end)(\n                  &ompt_parallel_data, parent_task_data,\n                  OMPT_INVOKER(call_context) | ompt_parallel_league,\n                  return_address);\n            }\n            master_th->th.ompt_thread_info.state = ompt_state_overhead;\n          }\n#endif\n        } else {\n          argv = args;\n          for (i = argc - 1; i >= 0; --i)\n            *argv++ = va_arg(kmp_va_deref(ap), void *);\n          KMP_MB();\n\n#if OMPT_SUPPORT\n          void *dummy;\n          void **exit_frame_p;\n          ompt_task_info_t *task_info;\n\n          ompt_lw_taskteam_t lw_taskteam;\n\n          if (ompt_enabled.enabled) {\n            __ompt_lw_taskteam_init(&lw_taskteam, master_th, gtid,\n                                    &ompt_parallel_data, return_address);\n            __ompt_lw_taskteam_link(&lw_taskteam, master_th, 0);\n            // don't use lw_taskteam after linking. content was swaped\n            task_info = OMPT_CUR_TASK_INFO(master_th);\n            exit_frame_p = &(task_info->frame.exit_frame.ptr);\n\n            /* OMPT implicit task begin */\n            implicit_task_data = OMPT_CUR_TASK_DATA(master_th);\n            if (ompt_enabled.ompt_callback_implicit_task) {\n              ompt_callbacks.ompt_callback(ompt_callback_implicit_task)(\n                  ompt_scope_begin, OMPT_CUR_TEAM_DATA(master_th),\n                  implicit_task_data, 1, __kmp_tid_from_gtid(gtid),\n                  ompt_task_implicit);\n              OMPT_CUR_TASK_INFO(master_th)->thread_num =\n                  __kmp_tid_from_gtid(gtid);\n            }\n\n            /* OMPT state */\n            master_th->th.ompt_thread_info.state = ompt_state_work_parallel;\n          } else {\n            exit_frame_p = &dummy;\n          }\n#endif\n\n          {\n            KMP_TIME_PARTITIONED_BLOCK(OMP_parallel);\n            KMP_SET_THREAD_STATE_BLOCK(IMPLICIT_TASK);\n            __kmp_invoke_microtask(microtask, gtid, 0, argc, args\n#if OMPT_SUPPORT\n                                   ,\n                                   exit_frame_p\n#endif\n            );\n          }\n\n#if OMPT_SUPPORT\n          if (ompt_enabled.enabled) {\n            *exit_frame_p = NULL;\n            if (ompt_enabled.ompt_callback_implicit_task) {\n              ompt_callbacks.ompt_callback(ompt_callback_implicit_task)(\n                  ompt_scope_end, NULL, &(task_info->task_data), 1,\n                  OMPT_CUR_TASK_INFO(master_th)->thread_num,\n                  ompt_task_implicit);\n            }\n\n            ompt_parallel_data = *OMPT_CUR_TEAM_DATA(master_th);\n            __ompt_lw_taskteam_unlink(master_th);\n            if (ompt_enabled.ompt_callback_parallel_end) {\n              ompt_callbacks.ompt_callback(ompt_callback_parallel_end)(\n                  &ompt_parallel_data, parent_task_data,\n                  OMPT_INVOKER(call_context) | ompt_parallel_team,\n                  return_address);\n            }\n            master_th->th.ompt_thread_info.state = ompt_state_overhead;\n          }\n#endif\n        }\n      } else if (call_context == fork_context_gnu) {\n#if OMPT_SUPPORT\n        ompt_lw_taskteam_t lwt;\n        __ompt_lw_taskteam_init(&lwt, master_th, gtid, &ompt_parallel_data,\n                                return_address);\n\n        lwt.ompt_task_info.frame.exit_frame = ompt_data_none;\n        __ompt_lw_taskteam_link(&lwt, master_th, 1);\n// don't use lw_taskteam after linking. content was swaped\n#endif\n\n        // we were called from GNU native code\n        KA_TRACE(20, (\"__kmp_fork_call: T#%d serial exit\\n\", gtid));\n        return FALSE;\n      } else {\n        KMP_ASSERT2(call_context < fork_context_last,\n                    \"__kmp_fork_call: unknown fork_context parameter\");\n      }\n\n      KA_TRACE(20, (\"__kmp_fork_call: T#%d serial exit\\n\", gtid));\n      KMP_MB();\n      return FALSE;\n    } // if (nthreads == 1)\n\n    // GEH: only modify the executing flag in the case when not serialized\n    //      serialized case is handled in kmpc_serialized_parallel\n    KF_TRACE(10, (\"__kmp_fork_call: parent_team_aclevel=%d, master_th=%p, \"\n                  \"curtask=%p, curtask_max_aclevel=%d\\n\",\n                  parent_team->t.t_active_level, master_th,\n                  master_th->th.th_current_task,\n                  master_th->th.th_current_task->td_icvs.max_active_levels));\n    // TODO: GEH - cannot do this assertion because root thread not set up as\n    // executing\n    // KMP_ASSERT( master_th->th.th_current_task->td_flags.executing == 1 );\n    master_th->th.th_current_task->td_flags.executing = 0;\n\n    if (!master_th->th.th_teams_microtask || level > teams_level) {\n      /* Increment our nested depth level */\n      KMP_ATOMIC_INC(&root->r.r_in_parallel);\n    }\n\n    // See if we need to make a copy of the ICVs.\n    int nthreads_icv = master_th->th.th_current_task->td_icvs.nproc;\n    if ((level + 1 < __kmp_nested_nth.used) &&\n        (__kmp_nested_nth.nth[level + 1] != nthreads_icv)) {\n      nthreads_icv = __kmp_nested_nth.nth[level + 1];\n    } else {\n      nthreads_icv = 0; // don't update\n    }\n\n    // Figure out the proc_bind_policy for the new team.\n    kmp_proc_bind_t proc_bind = master_th->th.th_set_proc_bind;\n    kmp_proc_bind_t proc_bind_icv =\n        proc_bind_default; // proc_bind_default means don't update\n    if (master_th->th.th_current_task->td_icvs.proc_bind == proc_bind_false) {\n      proc_bind = proc_bind_false;\n    } else {\n      if (proc_bind == proc_bind_default) {\n        // No proc_bind clause specified; use current proc-bind-var for this\n        // parallel region\n        proc_bind = master_th->th.th_current_task->td_icvs.proc_bind;\n      }\n      /* else: The proc_bind policy was specified explicitly on parallel clause.\n         This overrides proc-bind-var for this parallel region, but does not\n         change proc-bind-var. */\n      // Figure the value of proc-bind-var for the child threads.\n      if ((level + 1 < __kmp_nested_proc_bind.used) &&\n          (__kmp_nested_proc_bind.bind_types[level + 1] !=\n           master_th->th.th_current_task->td_icvs.proc_bind)) {\n        proc_bind_icv = __kmp_nested_proc_bind.bind_types[level + 1];\n      }\n    }\n\n    // Reset for next parallel region\n    master_th->th.th_set_proc_bind = proc_bind_default;\n\n    if ((nthreads_icv > 0) || (proc_bind_icv != proc_bind_default)) {\n      kmp_internal_control_t new_icvs;\n      copy_icvs(&new_icvs, &master_th->th.th_current_task->td_icvs);\n      new_icvs.next = NULL;\n      if (nthreads_icv > 0) {\n        new_icvs.nproc = nthreads_icv;\n      }\n      if (proc_bind_icv != proc_bind_default) {\n        new_icvs.proc_bind = proc_bind_icv;\n      }\n\n      /* allocate a new parallel team */\n      KF_TRACE(10, (\"__kmp_fork_call: before __kmp_allocate_team\\n\"));\n      team = __kmp_allocate_team(root, nthreads, nthreads,\n#if OMPT_SUPPORT\n                                 ompt_parallel_data,\n#endif\n                                 proc_bind, &new_icvs,\n                                 argc USE_NESTED_HOT_ARG(master_th));\n    } else {\n      /* allocate a new parallel team */\n      KF_TRACE(10, (\"__kmp_fork_call: before __kmp_allocate_team\\n\"));\n      team = __kmp_allocate_team(root, nthreads, nthreads,\n#if OMPT_SUPPORT\n                                 ompt_parallel_data,\n#endif\n                                 proc_bind,\n                                 &master_th->th.th_current_task->td_icvs,\n                                 argc USE_NESTED_HOT_ARG(master_th));\n    }\n    KF_TRACE(\n        10, (\"__kmp_fork_call: after __kmp_allocate_team - team = %p\\n\", team));\n\n    /* setup the new team */\n    KMP_CHECK_UPDATE(team->t.t_master_tid, master_tid);\n    KMP_CHECK_UPDATE(team->t.t_master_this_cons, master_this_cons);\n    KMP_CHECK_UPDATE(team->t.t_ident, loc);\n    KMP_CHECK_UPDATE(team->t.t_parent, parent_team);\n    KMP_CHECK_UPDATE_SYNC(team->t.t_pkfn, microtask);\n#if OMPT_SUPPORT\n    KMP_CHECK_UPDATE_SYNC(team->t.ompt_team_info.master_return_address,\n                          return_address);\n#endif\n    KMP_CHECK_UPDATE(team->t.t_invoke, invoker); // TODO move to root, maybe\n    // TODO: parent_team->t.t_level == INT_MAX ???\n    if (!master_th->th.th_teams_microtask || level > teams_level) {\n      int new_level = parent_team->t.t_level + 1;\n      KMP_CHECK_UPDATE(team->t.t_level, new_level);\n      new_level = parent_team->t.t_active_level + 1;\n      KMP_CHECK_UPDATE(team->t.t_active_level, new_level);\n    } else {\n      // AC: Do not increase parallel level at start of the teams construct\n      int new_level = parent_team->t.t_level;\n      KMP_CHECK_UPDATE(team->t.t_level, new_level);\n      new_level = parent_team->t.t_active_level;\n      KMP_CHECK_UPDATE(team->t.t_active_level, new_level);\n    }\n    kmp_r_sched_t new_sched = get__sched_2(parent_team, master_tid);\n    // set primary thread's schedule as new run-time schedule\n    KMP_CHECK_UPDATE(team->t.t_sched.sched, new_sched.sched);\n\n    KMP_CHECK_UPDATE(team->t.t_cancel_request, cancel_noreq);\n    KMP_CHECK_UPDATE(team->t.t_def_allocator, master_th->th.th_def_allocator);\n\n    // Update the floating point rounding in the team if required.\n    propagateFPControl(team);\n\n    if (__kmp_tasking_mode != tskm_immediate_exec) {\n      // Set primary thread's task team to team's task team. Unless this is hot\n      // team, it should be NULL.\n      KMP_DEBUG_ASSERT(master_th->th.th_task_team ==\n                       parent_team->t.t_task_team[master_th->th.th_task_state]);\n      KA_TRACE(20, (\"__kmp_fork_call: Primary T#%d pushing task_team %p / team \"\n                    \"%p, new task_team %p / team %p\\n\",\n                    __kmp_gtid_from_thread(master_th),\n                    master_th->th.th_task_team, parent_team,\n                    team->t.t_task_team[master_th->th.th_task_state], team));\n\n      if (active_level || master_th->th.th_task_team) {\n        // Take a memo of primary thread's task_state\n        KMP_DEBUG_ASSERT(master_th->th.th_task_state_memo_stack);\n        if (master_th->th.th_task_state_top >=\n            master_th->th.th_task_state_stack_sz) { // increase size\n          kmp_uint32 new_size = 2 * master_th->th.th_task_state_stack_sz;\n          kmp_uint8 *old_stack, *new_stack;\n          kmp_uint32 i;\n          new_stack = (kmp_uint8 *)__kmp_allocate(new_size);\n          for (i = 0; i < master_th->th.th_task_state_stack_sz; ++i) {\n            new_stack[i] = master_th->th.th_task_state_memo_stack[i];\n          }\n          for (i = master_th->th.th_task_state_stack_sz; i < new_size;\n               ++i) { // zero-init rest of stack\n            new_stack[i] = 0;\n          }\n          old_stack = master_th->th.th_task_state_memo_stack;\n          master_th->th.th_task_state_memo_stack = new_stack;\n          master_th->th.th_task_state_stack_sz = new_size;\n          __kmp_free(old_stack);\n        }\n        // Store primary thread's task_state on stack\n        master_th->th\n            .th_task_state_memo_stack[master_th->th.th_task_state_top] =\n            master_th->th.th_task_state;\n        master_th->th.th_task_state_top++;\n#if KMP_NESTED_HOT_TEAMS\n        if (master_th->th.th_hot_teams &&\n            active_level < __kmp_hot_teams_max_level &&\n            team == master_th->th.th_hot_teams[active_level].hot_team) {\n          // Restore primary thread's nested state if nested hot team\n          master_th->th.th_task_state =\n              master_th->th\n                  .th_task_state_memo_stack[master_th->th.th_task_state_top];\n        } else {\n#endif\n          master_th->th.th_task_state = 0;\n#if KMP_NESTED_HOT_TEAMS\n        }\n#endif\n      }\n#if !KMP_NESTED_HOT_TEAMS\n      KMP_DEBUG_ASSERT((master_th->th.th_task_team == NULL) ||\n                       (team == root->r.r_hot_team));\n#endif\n    }\n\n    KA_TRACE(\n        20,\n        (\"__kmp_fork_call: T#%d(%d:%d)->(%d:0) created a team of %d threads\\n\",\n         gtid, parent_team->t.t_id, team->t.t_master_tid, team->t.t_id,\n         team->t.t_nproc));\n    KMP_DEBUG_ASSERT(team != root->r.r_hot_team ||\n                     (team->t.t_master_tid == 0 &&\n                      (team->t.t_parent == root->r.r_root_team ||\n                       team->t.t_parent->t.t_serialized)));\n    KMP_MB();\n\n    /* now, setup the arguments */\n    argv = (void **)team->t.t_argv;\n    if (ap) {\n      for (i = argc - 1; i >= 0; --i) {\n        void *new_argv = va_arg(kmp_va_deref(ap), void *);\n        KMP_CHECK_UPDATE(*argv, new_argv);\n        argv++;\n      }\n    } else {\n      for (i = 0; i < argc; ++i) {\n        // Get args from parent team for teams construct\n        KMP_CHECK_UPDATE(argv[i], team->t.t_parent->t.t_argv[i]);\n      }\n    }\n\n    /* now actually fork the threads */\n    KMP_CHECK_UPDATE(team->t.t_master_active, master_active);\n    if (!root->r.r_active) // Only do assignment if it prevents cache ping-pong\n      root->r.r_active = TRUE;\n\n    __kmp_fork_team_threads(root, team, master_th, gtid);\n    __kmp_setup_icv_copy(team, nthreads,\n                         &master_th->th.th_current_task->td_icvs, loc);\n\n#if OMPT_SUPPORT\n    master_th->th.ompt_thread_info.state = ompt_state_work_parallel;\n#endif\n\n    __kmp_release_bootstrap_lock(&__kmp_forkjoin_lock);\n\n#if USE_ITT_BUILD\n    if (team->t.t_active_level == 1 // only report frames at level 1\n        && !master_th->th.th_teams_microtask) { // not in teams construct\n#if USE_ITT_NOTIFY\n      if ((__itt_frame_submit_v3_ptr || KMP_ITT_DEBUG) &&\n          (__kmp_forkjoin_frames_mode == 3 ||\n           __kmp_forkjoin_frames_mode == 1)) {\n        kmp_uint64 tmp_time = 0;\n        if (__itt_get_timestamp_ptr)\n          tmp_time = __itt_get_timestamp();\n        // Internal fork - report frame begin\n        master_th->th.th_frame_time = tmp_time;\n        if (__kmp_forkjoin_frames_mode == 3)\n          team->t.t_region_time = tmp_time;\n      } else\n// only one notification scheme (either \"submit\" or \"forking/joined\", not both)\n#endif /* USE_ITT_NOTIFY */\n          if ((__itt_frame_begin_v3_ptr || KMP_ITT_DEBUG) &&\n              __kmp_forkjoin_frames && !__kmp_forkjoin_frames_mode) {\n        // Mark start of \"parallel\" region for Intel(R) VTune(TM) analyzer.\n        __kmp_itt_region_forking(gtid, team->t.t_nproc, 0);\n      }\n    }\n#endif /* USE_ITT_BUILD */\n\n    /* now go on and do the work */\n    KMP_DEBUG_ASSERT(team == __kmp_threads[gtid]->th.th_team);\n    KMP_MB();\n    KF_TRACE(10,\n             (\"__kmp_internal_fork : root=%p, team=%p, master_th=%p, gtid=%d\\n\",\n              root, team, master_th, gtid));\n\n#if USE_ITT_BUILD\n    if (__itt_stack_caller_create_ptr) {\n      // create new stack stitching id before entering fork barrier\n      if (!enter_teams) {\n        KMP_DEBUG_ASSERT(team->t.t_stack_id == NULL);\n        team->t.t_stack_id = __kmp_itt_stack_caller_create();\n      } else if (parent_team->t.t_serialized) {\n        // keep stack stitching id in the serialized parent_team;\n        // current team will be used for parallel inside the teams;\n        // if parent_team is active, then it already keeps stack stitching id\n        // for the league of teams\n        KMP_DEBUG_ASSERT(parent_team->t.t_stack_id == NULL);\n        parent_team->t.t_stack_id = __kmp_itt_stack_caller_create();\n      }\n    }\n#endif /* USE_ITT_BUILD */\n\n    // AC: skip __kmp_internal_fork at teams construct, let only primary\n    // threads execute\n    if (ap) {\n      __kmp_internal_fork(loc, gtid, team);\n      KF_TRACE(10, (\"__kmp_internal_fork : after : root=%p, team=%p, \"\n                    \"master_th=%p, gtid=%d\\n\",\n                    root, team, master_th, gtid));\n    }\n\n    if (call_context == fork_context_gnu) {\n      KA_TRACE(20, (\"__kmp_fork_call: parallel exit T#%d\\n\", gtid));\n      return TRUE;\n    }\n\n    /* Invoke microtask for PRIMARY thread */\n    KA_TRACE(20, (\"__kmp_fork_call: T#%d(%d:0) invoke microtask = %p\\n\", gtid,\n                  team->t.t_id, team->t.t_pkfn));\n  } // END of timer KMP_fork_call block\n\n#if KMP_STATS_ENABLED\n  // If beginning a teams construct, then change thread state\n  stats_state_e previous_state = KMP_GET_THREAD_STATE();\n  if (!ap) {\n    KMP_SET_THREAD_STATE(stats_state_e::TEAMS_REGION);\n  }\n#endif\n\n  if (!team->t.t_invoke(gtid)) {\n    KMP_ASSERT2(0, \"cannot invoke microtask for PRIMARY thread\");\n  }\n\n#if KMP_STATS_ENABLED\n  // If was beginning of a teams construct, then reset thread state\n  if (!ap) {\n    KMP_SET_THREAD_STATE(previous_state);\n  }\n#endif\n\n  KA_TRACE(20, (\"__kmp_fork_call: T#%d(%d:0) done microtask = %p\\n\", gtid,\n                team->t.t_id, team->t.t_pkfn));\n  KMP_MB(); /* Flush all pending memory write invalidates.  */\n\n  KA_TRACE(20, (\"__kmp_fork_call: parallel exit T#%d\\n\", gtid));\n\n#if OMPT_SUPPORT\n  if (ompt_enabled.enabled) {\n    master_th->th.ompt_thread_info.state = ompt_state_overhead;\n  }\n#endif\n\n  return TRUE;\n}\n\n#if OMPT_SUPPORT\nstatic inline void __kmp_join_restore_state(kmp_info_t *thread,\n                                            kmp_team_t *team) {\n  // restore state outside the region\n  thread->th.ompt_thread_info.state =\n      ((team->t.t_serialized) ? ompt_state_work_serial\n                              : ompt_state_work_parallel);\n}\n\nstatic inline void __kmp_join_ompt(int gtid, kmp_info_t *thread,\n                                   kmp_team_t *team, ompt_data_t *parallel_data,\n                                   int flags, void *codeptr) {\n  ompt_task_info_t *task_info = __ompt_get_task_info_object(0);\n  if (ompt_enabled.ompt_callback_parallel_end) {\n    ompt_callbacks.ompt_callback(ompt_callback_parallel_end)(\n        parallel_data, &(task_info->task_data), flags, codeptr);\n  }\n\n  task_info->frame.enter_frame = ompt_data_none;\n  __kmp_join_restore_state(thread, team);\n}\n#endif\n\nvoid __kmp_join_call(ident_t *loc, int gtid\n#if OMPT_SUPPORT\n                     ,\n                     enum fork_context_e fork_context\n#endif\n                     ,\n                     int exit_teams) {\n  KMP_TIME_DEVELOPER_PARTITIONED_BLOCK(KMP_join_call);\n  kmp_team_t *team;\n  kmp_team_t *parent_team;\n  kmp_info_t *master_th;\n  kmp_root_t *root;\n  int master_active;\n\n  KA_TRACE(20, (\"__kmp_join_call: enter T#%d\\n\", gtid));\n\n  /* setup current data */\n  master_th = __kmp_threads[gtid];\n  root = master_th->th.th_root;\n  team = master_th->th.th_team;\n  parent_team = team->t.t_parent;\n\n  master_th->th.th_ident = loc;\n\n#if OMPT_SUPPORT\n  void *team_microtask = (void *)team->t.t_pkfn;\n  // For GOMP interface with serialized parallel, need the\n  // __kmpc_end_serialized_parallel to call hooks for OMPT end-implicit-task\n  // and end-parallel events.\n  if (ompt_enabled.enabled &&\n      !(team->t.t_serialized && fork_context == fork_context_gnu)) {\n    master_th->th.ompt_thread_info.state = ompt_state_overhead;\n  }\n#endif\n\n#if KMP_DEBUG\n  if (__kmp_tasking_mode != tskm_immediate_exec && !exit_teams) {\n    KA_TRACE(20, (\"__kmp_join_call: T#%d, old team = %p old task_team = %p, \"\n                  \"th_task_team = %p\\n\",\n                  __kmp_gtid_from_thread(master_th), team,\n                  team->t.t_task_team[master_th->th.th_task_state],\n                  master_th->th.th_task_team));\n    KMP_DEBUG_ASSERT(master_th->th.th_task_team ==\n                     team->t.t_task_team[master_th->th.th_task_state]);\n  }\n#endif\n\n  if (team->t.t_serialized) {\n    if (master_th->th.th_teams_microtask) {\n      // We are in teams construct\n      int level = team->t.t_level;\n      int tlevel = master_th->th.th_teams_level;\n      if (level == tlevel) {\n        // AC: we haven't incremented it earlier at start of teams construct,\n        //     so do it here - at the end of teams construct\n        team->t.t_level++;\n      } else if (level == tlevel + 1) {\n        // AC: we are exiting parallel inside teams, need to increment\n        // serialization in order to restore it in the next call to\n        // __kmpc_end_serialized_parallel\n        team->t.t_serialized++;\n      }\n    }\n    __kmpc_end_serialized_parallel(loc, gtid);\n\n#if OMPT_SUPPORT\n    if (ompt_enabled.enabled) {\n      __kmp_join_restore_state(master_th, parent_team);\n    }\n#endif\n\n    return;\n  }\n\n  master_active = team->t.t_master_active;\n\n  if (!exit_teams) {\n    // AC: No barrier for internal teams at exit from teams construct.\n    //     But there is barrier for external team (league).\n    __kmp_internal_join(loc, gtid, team);\n#if USE_ITT_BUILD\n    if (__itt_stack_caller_create_ptr) {\n      KMP_DEBUG_ASSERT(team->t.t_stack_id != NULL);\n      // destroy the stack stitching id after join barrier\n      __kmp_itt_stack_caller_destroy((__itt_caller)team->t.t_stack_id);\n      team->t.t_stack_id = NULL;\n    }\n#endif\n  } else {\n    master_th->th.th_task_state =\n        0; // AC: no tasking in teams (out of any parallel)\n#if USE_ITT_BUILD\n    if (__itt_stack_caller_create_ptr && parent_team->t.t_serialized) {\n      KMP_DEBUG_ASSERT(parent_team->t.t_stack_id != NULL);\n      // destroy the stack stitching id on exit from the teams construct\n      // if parent_team is active, then the id will be destroyed later on\n      // by master of the league of teams\n      __kmp_itt_stack_caller_destroy((__itt_caller)parent_team->t.t_stack_id);\n      parent_team->t.t_stack_id = NULL;\n    }\n#endif\n  }\n\n  KMP_MB();\n\n#if OMPT_SUPPORT\n  ompt_data_t *parallel_data = &(team->t.ompt_team_info.parallel_data);\n  void *codeptr = team->t.ompt_team_info.master_return_address;\n#endif\n\n#if USE_ITT_BUILD\n  // Mark end of \"parallel\" region for Intel(R) VTune(TM) analyzer.\n  if (team->t.t_active_level == 1 &&\n      (!master_th->th.th_teams_microtask || /* not in teams construct */\n       master_th->th.th_teams_size.nteams == 1)) {\n    master_th->th.th_ident = loc;\n    // only one notification scheme (either \"submit\" or \"forking/joined\", not\n    // both)\n    if ((__itt_frame_submit_v3_ptr || KMP_ITT_DEBUG) &&\n        __kmp_forkjoin_frames_mode == 3)\n      __kmp_itt_frame_submit(gtid, team->t.t_region_time,\n                             master_th->th.th_frame_time, 0, loc,\n                             master_th->th.th_team_nproc, 1);\n    else if ((__itt_frame_end_v3_ptr || KMP_ITT_DEBUG) &&\n             !__kmp_forkjoin_frames_mode && __kmp_forkjoin_frames)\n      __kmp_itt_region_joined(gtid);\n  } // active_level == 1\n#endif /* USE_ITT_BUILD */\n\n  if (master_th->th.th_teams_microtask && !exit_teams &&\n      team->t.t_pkfn != (microtask_t)__kmp_teams_master &&\n      team->t.t_level == master_th->th.th_teams_level + 1) {\n// AC: We need to leave the team structure intact at the end of parallel\n// inside the teams construct, so that at the next parallel same (hot) team\n// works, only adjust nesting levels\n#if OMPT_SUPPORT\n    ompt_data_t ompt_parallel_data = ompt_data_none;\n    if (ompt_enabled.enabled) {\n      ompt_task_info_t *task_info = __ompt_get_task_info_object(0);\n      if (ompt_enabled.ompt_callback_implicit_task) {\n        int ompt_team_size = team->t.t_nproc;\n        ompt_callbacks.ompt_callback(ompt_callback_implicit_task)(\n            ompt_scope_end, NULL, &(task_info->task_data), ompt_team_size,\n            OMPT_CUR_TASK_INFO(master_th)->thread_num, ompt_task_implicit);\n      }\n      task_info->frame.exit_frame = ompt_data_none;\n      task_info->task_data = ompt_data_none;\n      ompt_parallel_data = *OMPT_CUR_TEAM_DATA(master_th);\n      __ompt_lw_taskteam_unlink(master_th);\n    }\n#endif\n    /* Decrement our nested depth level */\n    team->t.t_level--;\n    team->t.t_active_level--;\n    KMP_ATOMIC_DEC(&root->r.r_in_parallel);\n\n    // Restore number of threads in the team if needed. This code relies on\n    // the proper adjustment of th_teams_size.nth after the fork in\n    // __kmp_teams_master on each teams primary thread in the case that\n    // __kmp_reserve_threads reduced it.\n    if (master_th->th.th_team_nproc < master_th->th.th_teams_size.nth) {\n      int old_num = master_th->th.th_team_nproc;\n      int new_num = master_th->th.th_teams_size.nth;\n      kmp_info_t **other_threads = team->t.t_threads;\n      team->t.t_nproc = new_num;\n      for (int i = 0; i < old_num; ++i) {\n        other_threads[i]->th.th_team_nproc = new_num;\n      }\n      // Adjust states of non-used threads of the team\n      for (int i = old_num; i < new_num; ++i) {\n        // Re-initialize thread's barrier data.\n        KMP_DEBUG_ASSERT(other_threads[i]);\n        kmp_balign_t *balign = other_threads[i]->th.th_bar;\n        for (int b = 0; b < bs_last_barrier; ++b) {\n          balign[b].bb.b_arrived = team->t.t_bar[b].b_arrived;\n          KMP_DEBUG_ASSERT(balign[b].bb.wait_flag != KMP_BARRIER_PARENT_FLAG);\n#if USE_DEBUGGER\n          balign[b].bb.b_worker_arrived = team->t.t_bar[b].b_team_arrived;\n#endif\n        }\n        if (__kmp_tasking_mode != tskm_immediate_exec) {\n          // Synchronize thread's task state\n          other_threads[i]->th.th_task_state = master_th->th.th_task_state;\n        }\n      }\n    }\n\n#if OMPT_SUPPORT\n    if (ompt_enabled.enabled) {\n      __kmp_join_ompt(gtid, master_th, parent_team, &ompt_parallel_data,\n                      OMPT_INVOKER(fork_context) | ompt_parallel_team, codeptr);\n    }\n#endif\n\n    return;\n  }\n\n  /* do cleanup and restore the parent team */\n  master_th->th.th_info.ds.ds_tid = team->t.t_master_tid;\n  master_th->th.th_local.this_construct = team->t.t_master_this_cons;\n\n  master_th->th.th_dispatch = &parent_team->t.t_dispatch[team->t.t_master_tid];\n\n  /* jc: The following lock has instructions with REL and ACQ semantics,\n     separating the parallel user code called in this parallel region\n     from the serial user code called after this function returns. */\n  __kmp_acquire_bootstrap_lock(&__kmp_forkjoin_lock);\n\n  if (!master_th->th.th_teams_microtask ||\n      team->t.t_level > master_th->th.th_teams_level) {\n    /* Decrement our nested depth level */\n    KMP_ATOMIC_DEC(&root->r.r_in_parallel);\n  }\n  KMP_DEBUG_ASSERT(root->r.r_in_parallel >= 0);\n\n#if OMPT_SUPPORT\n  if (ompt_enabled.enabled) {\n    ompt_task_info_t *task_info = __ompt_get_task_info_object(0);\n    if (ompt_enabled.ompt_callback_implicit_task) {\n      int flags = (team_microtask == (void *)__kmp_teams_master)\n                      ? ompt_task_initial\n                      : ompt_task_implicit;\n      int ompt_team_size = (flags == ompt_task_initial) ? 0 : team->t.t_nproc;\n      ompt_callbacks.ompt_callback(ompt_callback_implicit_task)(\n          ompt_scope_end, NULL, &(task_info->task_data), ompt_team_size,\n          OMPT_CUR_TASK_INFO(master_th)->thread_num, flags);\n    }\n    task_info->frame.exit_frame = ompt_data_none;\n    task_info->task_data = ompt_data_none;\n  }\n#endif\n\n  KF_TRACE(10, (\"__kmp_join_call1: T#%d, this_thread=%p team=%p\\n\", 0,\n                master_th, team));\n  __kmp_pop_current_task_from_thread(master_th);\n\n#if KMP_AFFINITY_SUPPORTED\n  // Restore master thread's partition.\n  master_th->th.th_first_place = team->t.t_first_place;\n  master_th->th.th_last_place = team->t.t_last_place;\n#endif // KMP_AFFINITY_SUPPORTED\n  master_th->th.th_def_allocator = team->t.t_def_allocator;\n\n  updateHWFPControl(team);\n\n  if (root->r.r_active != master_active)\n    root->r.r_active = master_active;\n\n  __kmp_free_team(root, team USE_NESTED_HOT_ARG(\n                            master_th)); // this will free worker threads\n\n  /* this race was fun to find. make sure the following is in the critical\n     region otherwise assertions may fail occasionally since the old team may be\n     reallocated and the hierarchy appears inconsistent. it is actually safe to\n     run and won't cause any bugs, but will cause those assertion failures. it's\n     only one deref&assign so might as well put this in the critical region */\n  master_th->th.th_team = parent_team;\n  master_th->th.th_team_nproc = parent_team->t.t_nproc;\n  master_th->th.th_team_master = parent_team->t.t_threads[0];\n  master_th->th.th_team_serialized = parent_team->t.t_serialized;\n\n  /* restore serialized team, if need be */\n  if (parent_team->t.t_serialized &&\n      parent_team != master_th->th.th_serial_team &&\n      parent_team != root->r.r_root_team) {\n    __kmp_free_team(root,\n                    master_th->th.th_serial_team USE_NESTED_HOT_ARG(NULL));\n    master_th->th.th_serial_team = parent_team;\n  }\n\n  if (__kmp_tasking_mode != tskm_immediate_exec) {\n    if (master_th->th.th_task_state_top >\n        0) { // Restore task state from memo stack\n      KMP_DEBUG_ASSERT(master_th->th.th_task_state_memo_stack);\n      // Remember primary thread's state if we re-use this nested hot team\n      master_th->th.th_task_state_memo_stack[master_th->th.th_task_state_top] =\n          master_th->th.th_task_state;\n      --master_th->th.th_task_state_top; // pop\n      // Now restore state at this level\n      master_th->th.th_task_state =\n          master_th->th\n              .th_task_state_memo_stack[master_th->th.th_task_state_top];\n    }\n    // Copy the task team from the parent team to the primary thread\n    master_th->th.th_task_team =\n        parent_team->t.t_task_team[master_th->th.th_task_state];\n    KA_TRACE(20,\n             (\"__kmp_join_call: Primary T#%d restoring task_team %p, team %p\\n\",\n              __kmp_gtid_from_thread(master_th), master_th->th.th_task_team,\n              parent_team));\n  }\n\n  // TODO: GEH - cannot do this assertion because root thread not set up as\n  // executing\n  // KMP_ASSERT( master_th->th.th_current_task->td_flags.executing == 0 );\n  master_th->th.th_current_task->td_flags.executing = 1;\n\n  __kmp_release_bootstrap_lock(&__kmp_forkjoin_lock);\n\n#if OMPT_SUPPORT\n  int flags =\n      OMPT_INVOKER(fork_context) |\n      ((team_microtask == (void *)__kmp_teams_master) ? ompt_parallel_league\n                                                      : ompt_parallel_team);\n  if (ompt_enabled.enabled) {\n    __kmp_join_ompt(gtid, master_th, parent_team, parallel_data, flags,\n                    codeptr);\n  }\n#endif\n\n  KMP_MB();\n  KA_TRACE(20, (\"__kmp_join_call: exit T#%d\\n\", gtid));\n}\n\n/* Check whether we should push an internal control record onto the\n   serial team stack.  If so, do it.  */\nvoid __kmp_save_internal_controls(kmp_info_t *thread) {\n\n  if (thread->th.th_team != thread->th.th_serial_team) {\n    return;\n  }\n  if (thread->th.th_team->t.t_serialized > 1) {\n    int push = 0;\n\n    if (thread->th.th_team->t.t_control_stack_top == NULL) {\n      push = 1;\n    } else {\n      if (thread->th.th_team->t.t_control_stack_top->serial_nesting_level !=\n          thread->th.th_team->t.t_serialized) {\n        push = 1;\n      }\n    }\n    if (push) { /* push a record on the serial team's stack */\n      kmp_internal_control_t *control =\n          (kmp_internal_control_t *)__kmp_allocate(\n              sizeof(kmp_internal_control_t));\n\n      copy_icvs(control, &thread->th.th_current_task->td_icvs);\n\n      control->serial_nesting_level = thread->th.th_team->t.t_serialized;\n\n      control->next = thread->th.th_team->t.t_control_stack_top;\n      thread->th.th_team->t.t_control_stack_top = control;\n    }\n  }\n}\n\n/* Changes set_nproc */\nvoid __kmp_set_num_threads(int new_nth, int gtid) {\n  kmp_info_t *thread;\n  kmp_root_t *root;\n\n  KF_TRACE(10, (\"__kmp_set_num_threads: new __kmp_nth = %d\\n\", new_nth));\n  KMP_DEBUG_ASSERT(__kmp_init_serial);\n\n  if (new_nth < 1)\n    new_nth = 1;\n  else if (new_nth > __kmp_max_nth)\n    new_nth = __kmp_max_nth;\n\n  KMP_COUNT_VALUE(OMP_set_numthreads, new_nth);\n  thread = __kmp_threads[gtid];\n  if (thread->th.th_current_task->td_icvs.nproc == new_nth)\n    return; // nothing to do\n\n  __kmp_save_internal_controls(thread);\n\n  set__nproc(thread, new_nth);\n\n  // If this omp_set_num_threads() call will cause the hot team size to be\n  // reduced (in the absence of a num_threads clause), then reduce it now,\n  // rather than waiting for the next parallel region.\n  root = thread->th.th_root;\n  if (__kmp_init_parallel && (!root->r.r_active) &&\n      (root->r.r_hot_team->t.t_nproc > new_nth)\n#if KMP_NESTED_HOT_TEAMS\n      && __kmp_hot_teams_max_level && !__kmp_hot_teams_mode\n#endif\n  ) {\n    kmp_team_t *hot_team = root->r.r_hot_team;\n    int f;\n\n    __kmp_acquire_bootstrap_lock(&__kmp_forkjoin_lock);\n\n    // Release the extra threads we don't need any more.\n    for (f = new_nth; f < hot_team->t.t_nproc; f++) {\n      KMP_DEBUG_ASSERT(hot_team->t.t_threads[f] != NULL);\n      if (__kmp_tasking_mode != tskm_immediate_exec) {\n        // When decreasing team size, threads no longer in the team should unref\n        // task team.\n        hot_team->t.t_threads[f]->th.th_task_team = NULL;\n      }\n      __kmp_free_thread(hot_team->t.t_threads[f]);\n      hot_team->t.t_threads[f] = NULL;\n    }\n    hot_team->t.t_nproc = new_nth;\n#if KMP_NESTED_HOT_TEAMS\n    if (thread->th.th_hot_teams) {\n      KMP_DEBUG_ASSERT(hot_team == thread->th.th_hot_teams[0].hot_team);\n      thread->th.th_hot_teams[0].hot_team_nth = new_nth;\n    }\n#endif\n\n    __kmp_release_bootstrap_lock(&__kmp_forkjoin_lock);\n\n    // Update the t_nproc field in the threads that are still active.\n    for (f = 0; f < new_nth; f++) {\n      KMP_DEBUG_ASSERT(hot_team->t.t_threads[f] != NULL);\n      hot_team->t.t_threads[f]->th.th_team_nproc = new_nth;\n    }\n    // Special flag in case omp_set_num_threads() call\n    hot_team->t.t_size_changed = -1;\n  }\n}\n\n/* Changes max_active_levels */\nvoid __kmp_set_max_active_levels(int gtid, int max_active_levels) {\n  kmp_info_t *thread;\n\n  KF_TRACE(10, (\"__kmp_set_max_active_levels: new max_active_levels for thread \"\n                \"%d = (%d)\\n\",\n                gtid, max_active_levels));\n  KMP_DEBUG_ASSERT(__kmp_init_serial);\n\n  // validate max_active_levels\n  if (max_active_levels < 0) {\n    KMP_WARNING(ActiveLevelsNegative, max_active_levels);\n    // We ignore this call if the user has specified a negative value.\n    // The current setting won't be changed. The last valid setting will be\n    // used. A warning will be issued (if warnings are allowed as controlled by\n    // the KMP_WARNINGS env var).\n    KF_TRACE(10, (\"__kmp_set_max_active_levels: the call is ignored: new \"\n                  \"max_active_levels for thread %d = (%d)\\n\",\n                  gtid, max_active_levels));\n    return;\n  }\n  if (max_active_levels <= KMP_MAX_ACTIVE_LEVELS_LIMIT) {\n    // it's OK, the max_active_levels is within the valid range: [ 0;\n    // KMP_MAX_ACTIVE_LEVELS_LIMIT ]\n    // We allow a zero value. (implementation defined behavior)\n  } else {\n    KMP_WARNING(ActiveLevelsExceedLimit, max_active_levels,\n                KMP_MAX_ACTIVE_LEVELS_LIMIT);\n    max_active_levels = KMP_MAX_ACTIVE_LEVELS_LIMIT;\n    // Current upper limit is MAX_INT. (implementation defined behavior)\n    // If the input exceeds the upper limit, we correct the input to be the\n    // upper limit. (implementation defined behavior)\n    // Actually, the flow should never get here until we use MAX_INT limit.\n  }\n  KF_TRACE(10, (\"__kmp_set_max_active_levels: after validation: new \"\n                \"max_active_levels for thread %d = (%d)\\n\",\n                gtid, max_active_levels));\n\n  thread = __kmp_threads[gtid];\n\n  __kmp_save_internal_controls(thread);\n\n  set__max_active_levels(thread, max_active_levels);\n}\n\n/* Gets max_active_levels */\nint __kmp_get_max_active_levels(int gtid) {\n  kmp_info_t *thread;\n\n  KF_TRACE(10, (\"__kmp_get_max_active_levels: thread %d\\n\", gtid));\n  KMP_DEBUG_ASSERT(__kmp_init_serial);\n\n  thread = __kmp_threads[gtid];\n  KMP_DEBUG_ASSERT(thread->th.th_current_task);\n  KF_TRACE(10, (\"__kmp_get_max_active_levels: thread %d, curtask=%p, \"\n                \"curtask_maxaclevel=%d\\n\",\n                gtid, thread->th.th_current_task,\n                thread->th.th_current_task->td_icvs.max_active_levels));\n  return thread->th.th_current_task->td_icvs.max_active_levels;\n}\n\n// nteams-var per-device ICV\nvoid __kmp_set_num_teams(int num_teams) {\n  if (num_teams > 0)\n    __kmp_nteams = num_teams;\n}\nint __kmp_get_max_teams(void) { return __kmp_nteams; }\n// teams-thread-limit-var per-device ICV\nvoid __kmp_set_teams_thread_limit(int limit) {\n  if (limit > 0)\n    __kmp_teams_thread_limit = limit;\n}\nint __kmp_get_teams_thread_limit(void) { return __kmp_teams_thread_limit; }\n\nKMP_BUILD_ASSERT(sizeof(kmp_sched_t) == sizeof(int));\nKMP_BUILD_ASSERT(sizeof(enum sched_type) == sizeof(int));\n\n/* Changes def_sched_var ICV values (run-time schedule kind and chunk) */\nvoid __kmp_set_schedule(int gtid, kmp_sched_t kind, int chunk) {\n  kmp_info_t *thread;\n  kmp_sched_t orig_kind;\n  //    kmp_team_t *team;\n\n  KF_TRACE(10, (\"__kmp_set_schedule: new schedule for thread %d = (%d, %d)\\n\",\n                gtid, (int)kind, chunk));\n  KMP_DEBUG_ASSERT(__kmp_init_serial);\n\n  // Check if the kind parameter is valid, correct if needed.\n  // Valid parameters should fit in one of two intervals - standard or extended:\n  //       <lower>, <valid>, <upper_std>, <lower_ext>, <valid>, <upper>\n  // 2008-01-25: 0,  1 - 4,       5,         100,     101 - 102, 103\n  orig_kind = kind;\n  kind = __kmp_sched_without_mods(kind);\n\n  if (kind <= kmp_sched_lower || kind >= kmp_sched_upper ||\n      (kind <= kmp_sched_lower_ext && kind >= kmp_sched_upper_std)) {\n    // TODO: Hint needs attention in case we change the default schedule.\n    __kmp_msg(kmp_ms_warning, KMP_MSG(ScheduleKindOutOfRange, kind),\n              KMP_HNT(DefaultScheduleKindUsed, \"static, no chunk\"),\n              __kmp_msg_null);\n    kind = kmp_sched_default;\n    chunk = 0; // ignore chunk value in case of bad kind\n  }\n\n  thread = __kmp_threads[gtid];\n\n  __kmp_save_internal_controls(thread);\n\n  if (kind < kmp_sched_upper_std) {\n    if (kind == kmp_sched_static && chunk < KMP_DEFAULT_CHUNK) {\n      // differ static chunked vs. unchunked:  chunk should be invalid to\n      // indicate unchunked schedule (which is the default)\n      thread->th.th_current_task->td_icvs.sched.r_sched_type = kmp_sch_static;\n    } else {\n      thread->th.th_current_task->td_icvs.sched.r_sched_type =\n          __kmp_sch_map[kind - kmp_sched_lower - 1];\n    }\n  } else {\n    //    __kmp_sch_map[ kind - kmp_sched_lower_ext + kmp_sched_upper_std -\n    //    kmp_sched_lower - 2 ];\n    thread->th.th_current_task->td_icvs.sched.r_sched_type =\n        __kmp_sch_map[kind - kmp_sched_lower_ext + kmp_sched_upper_std -\n                      kmp_sched_lower - 2];\n  }\n  __kmp_sched_apply_mods_intkind(\n      orig_kind, &(thread->th.th_current_task->td_icvs.sched.r_sched_type));\n  if (kind == kmp_sched_auto || chunk < 1) {\n    // ignore parameter chunk for schedule auto\n    thread->th.th_current_task->td_icvs.sched.chunk = KMP_DEFAULT_CHUNK;\n  } else {\n    thread->th.th_current_task->td_icvs.sched.chunk = chunk;\n  }\n}\n\n/* Gets def_sched_var ICV values */\nvoid __kmp_get_schedule(int gtid, kmp_sched_t *kind, int *chunk) {\n  kmp_info_t *thread;\n  enum sched_type th_type;\n\n  KF_TRACE(10, (\"__kmp_get_schedule: thread %d\\n\", gtid));\n  KMP_DEBUG_ASSERT(__kmp_init_serial);\n\n  thread = __kmp_threads[gtid];\n\n  th_type = thread->th.th_current_task->td_icvs.sched.r_sched_type;\n  switch (SCHEDULE_WITHOUT_MODIFIERS(th_type)) {\n  case kmp_sch_static:\n  case kmp_sch_static_greedy:\n  case kmp_sch_static_balanced:\n    *kind = kmp_sched_static;\n    __kmp_sched_apply_mods_stdkind(kind, th_type);\n    *chunk = 0; // chunk was not set, try to show this fact via zero value\n    return;\n  case kmp_sch_static_chunked:\n    *kind = kmp_sched_static;\n    break;\n  case kmp_sch_dynamic_chunked:\n    *kind = kmp_sched_dynamic;\n    break;\n  case kmp_sch_guided_chunked:\n  case kmp_sch_guided_iterative_chunked:\n  case kmp_sch_guided_analytical_chunked:\n    *kind = kmp_sched_guided;\n    break;\n  case kmp_sch_auto:\n    *kind = kmp_sched_auto;\n    break;\n  case kmp_sch_trapezoidal:\n    *kind = kmp_sched_trapezoidal;\n    break;\n#if KMP_STATIC_STEAL_ENABLED\n  case kmp_sch_static_steal:\n    *kind = kmp_sched_static_steal;\n    break;\n#endif\n  default:\n    KMP_FATAL(UnknownSchedulingType, th_type);\n  }\n\n  __kmp_sched_apply_mods_stdkind(kind, th_type);\n  *chunk = thread->th.th_current_task->td_icvs.sched.chunk;\n}\n\nint __kmp_get_ancestor_thread_num(int gtid, int level) {\n\n  int ii, dd;\n  kmp_team_t *team;\n  kmp_info_t *thr;\n\n  KF_TRACE(10, (\"__kmp_get_ancestor_thread_num: thread %d %d\\n\", gtid, level));\n  KMP_DEBUG_ASSERT(__kmp_init_serial);\n\n  // validate level\n  if (level == 0)\n    return 0;\n  if (level < 0)\n    return -1;\n  thr = __kmp_threads[gtid];\n  team = thr->th.th_team;\n  ii = team->t.t_level;\n  if (level > ii)\n    return -1;\n\n  if (thr->th.th_teams_microtask) {\n    // AC: we are in teams region where multiple nested teams have same level\n    int tlevel = thr->th.th_teams_level; // the level of the teams construct\n    if (level <=\n        tlevel) { // otherwise usual algorithm works (will not touch the teams)\n      KMP_DEBUG_ASSERT(ii >= tlevel);\n      // AC: As we need to pass by the teams league, we need to artificially\n      // increase ii\n      if (ii == tlevel) {\n        ii += 2; // three teams have same level\n      } else {\n        ii++; // two teams have same level\n      }\n    }\n  }\n\n  if (ii == level)\n    return __kmp_tid_from_gtid(gtid);\n\n  dd = team->t.t_serialized;\n  level++;\n  while (ii > level) {\n    for (dd = team->t.t_serialized; (dd > 0) && (ii > level); dd--, ii--) {\n    }\n    if ((team->t.t_serialized) && (!dd)) {\n      team = team->t.t_parent;\n      continue;\n    }\n    if (ii > level) {\n      team = team->t.t_parent;\n      dd = team->t.t_serialized;\n      ii--;\n    }\n  }\n\n  return (dd > 1) ? (0) : (team->t.t_master_tid);\n}\n\nint __kmp_get_team_size(int gtid, int level) {\n\n  int ii, dd;\n  kmp_team_t *team;\n  kmp_info_t *thr;\n\n  KF_TRACE(10, (\"__kmp_get_team_size: thread %d %d\\n\", gtid, level));\n  KMP_DEBUG_ASSERT(__kmp_init_serial);\n\n  // validate level\n  if (level == 0)\n    return 1;\n  if (level < 0)\n    return -1;\n  thr = __kmp_threads[gtid];\n  team = thr->th.th_team;\n  ii = team->t.t_level;\n  if (level > ii)\n    return -1;\n\n  if (thr->th.th_teams_microtask) {\n    // AC: we are in teams region where multiple nested teams have same level\n    int tlevel = thr->th.th_teams_level; // the level of the teams construct\n    if (level <=\n        tlevel) { // otherwise usual algorithm works (will not touch the teams)\n      KMP_DEBUG_ASSERT(ii >= tlevel);\n      // AC: As we need to pass by the teams league, we need to artificially\n      // increase ii\n      if (ii == tlevel) {\n        ii += 2; // three teams have same level\n      } else {\n        ii++; // two teams have same level\n      }\n    }\n  }\n\n  while (ii > level) {\n    for (dd = team->t.t_serialized; (dd > 0) && (ii > level); dd--, ii--) {\n    }\n    if (team->t.t_serialized && (!dd)) {\n      team = team->t.t_parent;\n      continue;\n    }\n    if (ii > level) {\n      team = team->t.t_parent;\n      ii--;\n    }\n  }\n\n  return team->t.t_nproc;\n}\n\nkmp_r_sched_t __kmp_get_schedule_global() {\n  // This routine created because pairs (__kmp_sched, __kmp_chunk) and\n  // (__kmp_static, __kmp_guided) may be changed by kmp_set_defaults\n  // independently. So one can get the updated schedule here.\n\n  kmp_r_sched_t r_sched;\n\n  // create schedule from 4 globals: __kmp_sched, __kmp_chunk, __kmp_static,\n  // __kmp_guided. __kmp_sched should keep original value, so that user can set\n  // KMP_SCHEDULE multiple times, and thus have different run-time schedules in\n  // different roots (even in OMP 2.5)\n  enum sched_type s = SCHEDULE_WITHOUT_MODIFIERS(__kmp_sched);\n  enum sched_type sched_modifiers = SCHEDULE_GET_MODIFIERS(__kmp_sched);\n  if (s == kmp_sch_static) {\n    // replace STATIC with more detailed schedule (balanced or greedy)\n    r_sched.r_sched_type = __kmp_static;\n  } else if (s == kmp_sch_guided_chunked) {\n    // replace GUIDED with more detailed schedule (iterative or analytical)\n    r_sched.r_sched_type = __kmp_guided;\n  } else { // (STATIC_CHUNKED), or (DYNAMIC_CHUNKED), or other\n    r_sched.r_sched_type = __kmp_sched;\n  }\n  SCHEDULE_SET_MODIFIERS(r_sched.r_sched_type, sched_modifiers);\n\n  if (__kmp_chunk < KMP_DEFAULT_CHUNK) {\n    // __kmp_chunk may be wrong here (if it was not ever set)\n    r_sched.chunk = KMP_DEFAULT_CHUNK;\n  } else {\n    r_sched.chunk = __kmp_chunk;\n  }\n\n  return r_sched;\n}\n\n/* Allocate (realloc == FALSE) * or reallocate (realloc == TRUE)\n   at least argc number of *t_argv entries for the requested team. */\nstatic void __kmp_alloc_argv_entries(int argc, kmp_team_t *team, int realloc) {\n\n  KMP_DEBUG_ASSERT(team);\n  if (!realloc || argc > team->t.t_max_argc) {\n\n    KA_TRACE(100, (\"__kmp_alloc_argv_entries: team %d: needed entries=%d, \"\n                   \"current entries=%d\\n\",\n                   team->t.t_id, argc, (realloc) ? team->t.t_max_argc : 0));\n    /* if previously allocated heap space for args, free them */\n    if (realloc && team->t.t_argv != &team->t.t_inline_argv[0])\n      __kmp_free((void *)team->t.t_argv);\n\n    if (argc <= KMP_INLINE_ARGV_ENTRIES) {\n      /* use unused space in the cache line for arguments */\n      team->t.t_max_argc = KMP_INLINE_ARGV_ENTRIES;\n      KA_TRACE(100, (\"__kmp_alloc_argv_entries: team %d: inline allocate %d \"\n                     \"argv entries\\n\",\n                     team->t.t_id, team->t.t_max_argc));\n      team->t.t_argv = &team->t.t_inline_argv[0];\n      if (__kmp_storage_map) {\n        __kmp_print_storage_map_gtid(\n            -1, &team->t.t_inline_argv[0],\n            &team->t.t_inline_argv[KMP_INLINE_ARGV_ENTRIES],\n            (sizeof(void *) * KMP_INLINE_ARGV_ENTRIES), \"team_%d.t_inline_argv\",\n            team->t.t_id);\n      }\n    } else {\n      /* allocate space for arguments in the heap */\n      team->t.t_max_argc = (argc <= (KMP_MIN_MALLOC_ARGV_ENTRIES >> 1))\n                               ? KMP_MIN_MALLOC_ARGV_ENTRIES\n                               : 2 * argc;\n      KA_TRACE(100, (\"__kmp_alloc_argv_entries: team %d: dynamic allocate %d \"\n                     \"argv entries\\n\",\n                     team->t.t_id, team->t.t_max_argc));\n      team->t.t_argv =\n          (void **)__kmp_page_allocate(sizeof(void *) * team->t.t_max_argc);\n      if (__kmp_storage_map) {\n        __kmp_print_storage_map_gtid(-1, &team->t.t_argv[0],\n                                     &team->t.t_argv[team->t.t_max_argc],\n                                     sizeof(void *) * team->t.t_max_argc,\n                                     \"team_%d.t_argv\", team->t.t_id);\n      }\n    }\n  }\n}\n\nstatic void __kmp_allocate_team_arrays(kmp_team_t *team, int max_nth) {\n  int i;\n  int num_disp_buff = max_nth > 1 ? __kmp_dispatch_num_buffers : 2;\n  team->t.t_threads =\n      (kmp_info_t **)__kmp_allocate(sizeof(kmp_info_t *) * max_nth);\n  team->t.t_disp_buffer = (dispatch_shared_info_t *)__kmp_allocate(\n      sizeof(dispatch_shared_info_t) * num_disp_buff);\n  team->t.t_dispatch =\n      (kmp_disp_t *)__kmp_allocate(sizeof(kmp_disp_t) * max_nth);\n  team->t.t_implicit_task_taskdata =\n      (kmp_taskdata_t *)__kmp_allocate(sizeof(kmp_taskdata_t) * max_nth);\n  team->t.t_max_nproc = max_nth;\n\n  /* setup dispatch buffers */\n  for (i = 0; i < num_disp_buff; ++i) {\n    team->t.t_disp_buffer[i].buffer_index = i;\n    team->t.t_disp_buffer[i].doacross_buf_idx = i;\n  }\n}\n\nstatic void __kmp_free_team_arrays(kmp_team_t *team) {\n  /* Note: this does not free the threads in t_threads (__kmp_free_threads) */\n  int i;\n  for (i = 0; i < team->t.t_max_nproc; ++i) {\n    if (team->t.t_dispatch[i].th_disp_buffer != NULL) {\n      __kmp_free(team->t.t_dispatch[i].th_disp_buffer);\n      team->t.t_dispatch[i].th_disp_buffer = NULL;\n    }\n  }\n#if KMP_USE_HIER_SCHED\n  __kmp_dispatch_free_hierarchies(team);\n#endif\n  __kmp_free(team->t.t_threads);\n  __kmp_free(team->t.t_disp_buffer);\n  __kmp_free(team->t.t_dispatch);\n  __kmp_free(team->t.t_implicit_task_taskdata);\n  team->t.t_threads = NULL;\n  team->t.t_disp_buffer = NULL;\n  team->t.t_dispatch = NULL;\n  team->t.t_implicit_task_taskdata = 0;\n}\n\nstatic void __kmp_reallocate_team_arrays(kmp_team_t *team, int max_nth) {\n  kmp_info_t **oldThreads = team->t.t_threads;\n\n  __kmp_free(team->t.t_disp_buffer);\n  __kmp_free(team->t.t_dispatch);\n  __kmp_free(team->t.t_implicit_task_taskdata);\n  __kmp_allocate_team_arrays(team, max_nth);\n\n  KMP_MEMCPY(team->t.t_threads, oldThreads,\n             team->t.t_nproc * sizeof(kmp_info_t *));\n\n  __kmp_free(oldThreads);\n}\n\nstatic kmp_internal_control_t __kmp_get_global_icvs(void) {\n\n  kmp_r_sched_t r_sched =\n      __kmp_get_schedule_global(); // get current state of scheduling globals\n\n  KMP_DEBUG_ASSERT(__kmp_nested_proc_bind.used > 0);\n\n  kmp_internal_control_t g_icvs = {\n    0, // int serial_nesting_level; //corresponds to value of th_team_serialized\n    (kmp_int8)__kmp_global.g.g_dynamic, // internal control for dynamic\n    // adjustment of threads (per thread)\n    (kmp_int8)__kmp_env_blocktime, // int bt_set; //internal control for\n    // whether blocktime is explicitly set\n    __kmp_dflt_blocktime, // int blocktime; //internal control for blocktime\n#if KMP_USE_MONITOR\n    __kmp_bt_intervals, // int bt_intervals; //internal control for blocktime\n// intervals\n#endif\n    __kmp_dflt_team_nth, // int nproc; //internal control for # of threads for\n    // next parallel region (per thread)\n    // (use a max ub on value if __kmp_parallel_initialize not called yet)\n    __kmp_cg_max_nth, // int thread_limit;\n    __kmp_dflt_max_active_levels, // int max_active_levels; //internal control\n    // for max_active_levels\n    r_sched, // kmp_r_sched_t sched; //internal control for runtime schedule\n    // {sched,chunk} pair\n    __kmp_nested_proc_bind.bind_types[0],\n    __kmp_default_device,\n    NULL // struct kmp_internal_control *next;\n  };\n\n  return g_icvs;\n}\n\nstatic kmp_internal_control_t __kmp_get_x_global_icvs(const kmp_team_t *team) {\n\n  kmp_internal_control_t gx_icvs;\n  gx_icvs.serial_nesting_level =\n      0; // probably =team->t.t_serial like in save_inter_controls\n  copy_icvs(&gx_icvs, &team->t.t_threads[0]->th.th_current_task->td_icvs);\n  gx_icvs.next = NULL;\n\n  return gx_icvs;\n}\n\nstatic void __kmp_initialize_root(kmp_root_t *root) {\n  int f;\n  kmp_team_t *root_team;\n  kmp_team_t *hot_team;\n  int hot_team_max_nth;\n  kmp_r_sched_t r_sched =\n      __kmp_get_schedule_global(); // get current state of scheduling globals\n  kmp_internal_control_t r_icvs = __kmp_get_global_icvs();\n  KMP_DEBUG_ASSERT(root);\n  KMP_ASSERT(!root->r.r_begin);\n\n  /* setup the root state structure */\n  __kmp_init_lock(&root->r.r_begin_lock);\n  root->r.r_begin = FALSE;\n  root->r.r_active = FALSE;\n  root->r.r_in_parallel = 0;\n  root->r.r_blocktime = __kmp_dflt_blocktime;\n\n  /* setup the root team for this task */\n  /* allocate the root team structure */\n  KF_TRACE(10, (\"__kmp_initialize_root: before root_team\\n\"));\n\n  root_team =\n      __kmp_allocate_team(root,\n                          1, // new_nproc\n                          1, // max_nproc\n#if OMPT_SUPPORT\n                          ompt_data_none, // root parallel id\n#endif\n                          __kmp_nested_proc_bind.bind_types[0], &r_icvs,\n                          0 // argc\n                          USE_NESTED_HOT_ARG(NULL) // primary thread is unknown\n                          );\n#if USE_DEBUGGER\n  // Non-NULL value should be assigned to make the debugger display the root\n  // team.\n  TCW_SYNC_PTR(root_team->t.t_pkfn, (microtask_t)(~0));\n#endif\n\n  KF_TRACE(10, (\"__kmp_initialize_root: after root_team = %p\\n\", root_team));\n\n  root->r.r_root_team = root_team;\n  root_team->t.t_control_stack_top = NULL;\n\n  /* initialize root team */\n  root_team->t.t_threads[0] = NULL;\n  root_team->t.t_nproc = 1;\n  root_team->t.t_serialized = 1;\n  // TODO???: root_team->t.t_max_active_levels = __kmp_dflt_max_active_levels;\n  root_team->t.t_sched.sched = r_sched.sched;\n  KA_TRACE(\n      20,\n      (\"__kmp_initialize_root: init root team %d arrived: join=%u, plain=%u\\n\",\n       root_team->t.t_id, KMP_INIT_BARRIER_STATE, KMP_INIT_BARRIER_STATE));\n\n  /* setup the  hot team for this task */\n  /* allocate the hot team structure */\n  KF_TRACE(10, (\"__kmp_initialize_root: before hot_team\\n\"));\n\n  hot_team =\n      __kmp_allocate_team(root,\n                          1, // new_nproc\n                          __kmp_dflt_team_nth_ub * 2, // max_nproc\n#if OMPT_SUPPORT\n                          ompt_data_none, // root parallel id\n#endif\n                          __kmp_nested_proc_bind.bind_types[0], &r_icvs,\n                          0 // argc\n                          USE_NESTED_HOT_ARG(NULL) // primary thread is unknown\n                          );\n  KF_TRACE(10, (\"__kmp_initialize_root: after hot_team = %p\\n\", hot_team));\n\n  root->r.r_hot_team = hot_team;\n  root_team->t.t_control_stack_top = NULL;\n\n  /* first-time initialization */\n  hot_team->t.t_parent = root_team;\n\n  /* initialize hot team */\n  hot_team_max_nth = hot_team->t.t_max_nproc;\n  for (f = 0; f < hot_team_max_nth; ++f) {\n    hot_team->t.t_threads[f] = NULL;\n  }\n  hot_team->t.t_nproc = 1;\n  // TODO???: hot_team->t.t_max_active_levels = __kmp_dflt_max_active_levels;\n  hot_team->t.t_sched.sched = r_sched.sched;\n  hot_team->t.t_size_changed = 0;\n}\n\n#ifdef KMP_DEBUG\n\ntypedef struct kmp_team_list_item {\n  kmp_team_p const *entry;\n  struct kmp_team_list_item *next;\n} kmp_team_list_item_t;\ntypedef kmp_team_list_item_t *kmp_team_list_t;\n\nstatic void __kmp_print_structure_team_accum( // Add team to list of teams.\n    kmp_team_list_t list, // List of teams.\n    kmp_team_p const *team // Team to add.\n) {\n\n  // List must terminate with item where both entry and next are NULL.\n  // Team is added to the list only once.\n  // List is sorted in ascending order by team id.\n  // Team id is *not* a key.\n\n  kmp_team_list_t l;\n\n  KMP_DEBUG_ASSERT(list != NULL);\n  if (team == NULL) {\n    return;\n  }\n\n  __kmp_print_structure_team_accum(list, team->t.t_parent);\n  __kmp_print_structure_team_accum(list, team->t.t_next_pool);\n\n  // Search list for the team.\n  l = list;\n  while (l->next != NULL && l->entry != team) {\n    l = l->next;\n  }\n  if (l->next != NULL) {\n    return; // Team has been added before, exit.\n  }\n\n  // Team is not found. Search list again for insertion point.\n  l = list;\n  while (l->next != NULL && l->entry->t.t_id <= team->t.t_id) {\n    l = l->next;\n  }\n\n  // Insert team.\n  {\n    kmp_team_list_item_t *item = (kmp_team_list_item_t *)KMP_INTERNAL_MALLOC(\n        sizeof(kmp_team_list_item_t));\n    *item = *l;\n    l->entry = team;\n    l->next = item;\n  }\n}\n\nstatic void __kmp_print_structure_team(char const *title, kmp_team_p const *team\n\n) {\n  __kmp_printf(\"%s\", title);\n  if (team != NULL) {\n    __kmp_printf(\"%2x %p\\n\", team->t.t_id, team);\n  } else {\n    __kmp_printf(\" - (nil)\\n\");\n  }\n}\n\nstatic void __kmp_print_structure_thread(char const *title,\n                                         kmp_info_p const *thread) {\n  __kmp_printf(\"%s\", title);\n  if (thread != NULL) {\n    __kmp_printf(\"%2d %p\\n\", thread->th.th_info.ds.ds_gtid, thread);\n  } else {\n    __kmp_printf(\" - (nil)\\n\");\n  }\n}\n\nvoid __kmp_print_structure(void) {\n\n  kmp_team_list_t list;\n\n  // Initialize list of teams.\n  list =\n      (kmp_team_list_item_t *)KMP_INTERNAL_MALLOC(sizeof(kmp_team_list_item_t));\n  list->entry = NULL;\n  list->next = NULL;\n\n  __kmp_printf(\"\\n------------------------------\\nGlobal Thread \"\n               \"Table\\n------------------------------\\n\");\n  {\n    int gtid;\n    for (gtid = 0; gtid < __kmp_threads_capacity; ++gtid) {\n      __kmp_printf(\"%2d\", gtid);\n      if (__kmp_threads != NULL) {\n        __kmp_printf(\" %p\", __kmp_threads[gtid]);\n      }\n      if (__kmp_root != NULL) {\n        __kmp_printf(\" %p\", __kmp_root[gtid]);\n      }\n      __kmp_printf(\"\\n\");\n    }\n  }\n\n  // Print out __kmp_threads array.\n  __kmp_printf(\"\\n------------------------------\\nThreads\\n--------------------\"\n               \"----------\\n\");\n  if (__kmp_threads != NULL) {\n    int gtid;\n    for (gtid = 0; gtid < __kmp_threads_capacity; ++gtid) {\n      kmp_info_t const *thread = __kmp_threads[gtid];\n      if (thread != NULL) {\n        __kmp_printf(\"GTID %2d %p:\\n\", gtid, thread);\n        __kmp_printf(\"    Our Root:        %p\\n\", thread->th.th_root);\n        __kmp_print_structure_team(\"    Our Team:     \", thread->th.th_team);\n        __kmp_print_structure_team(\"    Serial Team:  \",\n                                   thread->th.th_serial_team);\n        __kmp_printf(\"    Threads:      %2d\\n\", thread->th.th_team_nproc);\n        __kmp_print_structure_thread(\"    Primary:      \",\n                                     thread->th.th_team_master);\n        __kmp_printf(\"    Serialized?:  %2d\\n\", thread->th.th_team_serialized);\n        __kmp_printf(\"    Set NProc:    %2d\\n\", thread->th.th_set_nproc);\n        __kmp_printf(\"    Set Proc Bind: %2d\\n\", thread->th.th_set_proc_bind);\n        __kmp_print_structure_thread(\"    Next in pool: \",\n                                     thread->th.th_next_pool);\n        __kmp_printf(\"\\n\");\n        __kmp_print_structure_team_accum(list, thread->th.th_team);\n        __kmp_print_structure_team_accum(list, thread->th.th_serial_team);\n      }\n    }\n  } else {\n    __kmp_printf(\"Threads array is not allocated.\\n\");\n  }\n\n  // Print out __kmp_root array.\n  __kmp_printf(\"\\n------------------------------\\nUbers\\n----------------------\"\n               \"--------\\n\");\n  if (__kmp_root != NULL) {\n    int gtid;\n    for (gtid = 0; gtid < __kmp_threads_capacity; ++gtid) {\n      kmp_root_t const *root = __kmp_root[gtid];\n      if (root != NULL) {\n        __kmp_printf(\"GTID %2d %p:\\n\", gtid, root);\n        __kmp_print_structure_team(\"    Root Team:    \", root->r.r_root_team);\n        __kmp_print_structure_team(\"    Hot Team:     \", root->r.r_hot_team);\n        __kmp_print_structure_thread(\"    Uber Thread:  \",\n                                     root->r.r_uber_thread);\n        __kmp_printf(\"    Active?:      %2d\\n\", root->r.r_active);\n        __kmp_printf(\"    In Parallel:  %2d\\n\",\n                     KMP_ATOMIC_LD_RLX(&root->r.r_in_parallel));\n        __kmp_printf(\"\\n\");\n        __kmp_print_structure_team_accum(list, root->r.r_root_team);\n        __kmp_print_structure_team_accum(list, root->r.r_hot_team);\n      }\n    }\n  } else {\n    __kmp_printf(\"Ubers array is not allocated.\\n\");\n  }\n\n  __kmp_printf(\"\\n------------------------------\\nTeams\\n----------------------\"\n               \"--------\\n\");\n  while (list->next != NULL) {\n    kmp_team_p const *team = list->entry;\n    int i;\n    __kmp_printf(\"Team %2x %p:\\n\", team->t.t_id, team);\n    __kmp_print_structure_team(\"    Parent Team:      \", team->t.t_parent);\n    __kmp_printf(\"    Primary TID:      %2d\\n\", team->t.t_master_tid);\n    __kmp_printf(\"    Max threads:      %2d\\n\", team->t.t_max_nproc);\n    __kmp_printf(\"    Levels of serial: %2d\\n\", team->t.t_serialized);\n    __kmp_printf(\"    Number threads:   %2d\\n\", team->t.t_nproc);\n    for (i = 0; i < team->t.t_nproc; ++i) {\n      __kmp_printf(\"    Thread %2d:      \", i);\n      __kmp_print_structure_thread(\"\", team->t.t_threads[i]);\n    }\n    __kmp_print_structure_team(\"    Next in pool:     \", team->t.t_next_pool);\n    __kmp_printf(\"\\n\");\n    list = list->next;\n  }\n\n  // Print out __kmp_thread_pool and __kmp_team_pool.\n  __kmp_printf(\"\\n------------------------------\\nPools\\n----------------------\"\n               \"--------\\n\");\n  __kmp_print_structure_thread(\"Thread pool:          \",\n                               CCAST(kmp_info_t *, __kmp_thread_pool));\n  __kmp_print_structure_team(\"Team pool:            \",\n                             CCAST(kmp_team_t *, __kmp_team_pool));\n  __kmp_printf(\"\\n\");\n\n  // Free team list.\n  while (list != NULL) {\n    kmp_team_list_item_t *item = list;\n    list = list->next;\n    KMP_INTERNAL_FREE(item);\n  }\n}\n\n#endif\n\n//---------------------------------------------------------------------------\n//  Stuff for per-thread fast random number generator\n//  Table of primes\nstatic const unsigned __kmp_primes[] = {\n    0x9e3779b1, 0xffe6cc59, 0x2109f6dd, 0x43977ab5, 0xba5703f5, 0xb495a877,\n    0xe1626741, 0x79695e6b, 0xbc98c09f, 0xd5bee2b3, 0x287488f9, 0x3af18231,\n    0x9677cd4d, 0xbe3a6929, 0xadc6a877, 0xdcf0674b, 0xbe4d6fe9, 0x5f15e201,\n    0x99afc3fd, 0xf3f16801, 0xe222cfff, 0x24ba5fdb, 0x0620452d, 0x79f149e3,\n    0xc8b93f49, 0x972702cd, 0xb07dd827, 0x6c97d5ed, 0x085a3d61, 0x46eb5ea7,\n    0x3d9910ed, 0x2e687b5b, 0x29609227, 0x6eb081f1, 0x0954c4e1, 0x9d114db9,\n    0x542acfa9, 0xb3e6bd7b, 0x0742d917, 0xe9f3ffa7, 0x54581edb, 0xf2480f45,\n    0x0bb9288f, 0xef1affc7, 0x85fa0ca7, 0x3ccc14db, 0xe6baf34b, 0x343377f7,\n    0x5ca19031, 0xe6d9293b, 0xf0a9f391, 0x5d2e980b, 0xfc411073, 0xc3749363,\n    0xb892d829, 0x3549366b, 0x629750ad, 0xb98294e5, 0x892d9483, 0xc235baf3,\n    0x3d2402a3, 0x6bdef3c9, 0xbec333cd, 0x40c9520f};\n\n//---------------------------------------------------------------------------\n//  __kmp_get_random: Get a random number using a linear congruential method.\nunsigned short __kmp_get_random(kmp_info_t *thread) {\n  unsigned x = thread->th.th_x;\n  unsigned short r = (unsigned short)(x >> 16);\n\n  thread->th.th_x = x * thread->th.th_a + 1;\n\n  KA_TRACE(30, (\"__kmp_get_random: THREAD: %d, RETURN: %u\\n\",\n                thread->th.th_info.ds.ds_tid, r));\n\n  return r;\n}\n//--------------------------------------------------------\n// __kmp_init_random: Initialize a random number generator\nvoid __kmp_init_random(kmp_info_t *thread) {\n  unsigned seed = thread->th.th_info.ds.ds_tid;\n\n  thread->th.th_a =\n      __kmp_primes[seed % (sizeof(__kmp_primes) / sizeof(__kmp_primes[0]))];\n  thread->th.th_x = (seed + 1) * thread->th.th_a + 1;\n  KA_TRACE(30,\n           (\"__kmp_init_random: THREAD: %u; A: %u\\n\", seed, thread->th.th_a));\n}\n\n#if KMP_OS_WINDOWS\n/* reclaim array entries for root threads that are already dead, returns number\n * reclaimed */\nstatic int __kmp_reclaim_dead_roots(void) {\n  int i, r = 0;\n\n  for (i = 0; i < __kmp_threads_capacity; ++i) {\n    if (KMP_UBER_GTID(i) &&\n        !__kmp_still_running((kmp_info_t *)TCR_SYNC_PTR(__kmp_threads[i])) &&\n        !__kmp_root[i]\n             ->r.r_active) { // AC: reclaim only roots died in non-active state\n      r += __kmp_unregister_root_other_thread(i);\n    }\n  }\n  return r;\n}\n#endif\n\n/* This function attempts to create free entries in __kmp_threads and\n   __kmp_root, and returns the number of free entries generated.\n\n   For Windows* OS static library, the first mechanism used is to reclaim array\n   entries for root threads that are already dead.\n\n   On all platforms, expansion is attempted on the arrays __kmp_threads_ and\n   __kmp_root, with appropriate update to __kmp_threads_capacity. Array\n   capacity is increased by doubling with clipping to __kmp_tp_capacity, if\n   threadprivate cache array has been created. Synchronization with\n   __kmpc_threadprivate_cached is done using __kmp_tp_cached_lock.\n\n   After any dead root reclamation, if the clipping value allows array expansion\n   to result in the generation of a total of nNeed free slots, the function does\n   that expansion. If not, nothing is done beyond the possible initial root\n   thread reclamation.\n\n   If any argument is negative, the behavior is undefined. */\nstatic int __kmp_expand_threads(int nNeed) {\n  int added = 0;\n  int minimumRequiredCapacity;\n  int newCapacity;\n  kmp_info_t **newThreads;\n  kmp_root_t **newRoot;\n\n  // All calls to __kmp_expand_threads should be under __kmp_forkjoin_lock, so\n  // resizing __kmp_threads does not need additional protection if foreign\n  // threads are present\n\n#if KMP_OS_WINDOWS && !KMP_DYNAMIC_LIB\n  /* only for Windows static library */\n  /* reclaim array entries for root threads that are already dead */\n  added = __kmp_reclaim_dead_roots();\n\n  if (nNeed) {\n    nNeed -= added;\n    if (nNeed < 0)\n      nNeed = 0;\n  }\n#endif\n  if (nNeed <= 0)\n    return added;\n\n  // Note that __kmp_threads_capacity is not bounded by __kmp_max_nth. If\n  // __kmp_max_nth is set to some value less than __kmp_sys_max_nth by the\n  // user via KMP_DEVICE_THREAD_LIMIT, then __kmp_threads_capacity may become\n  // > __kmp_max_nth in one of two ways:\n  //\n  // 1) The initialization thread (gtid = 0) exits.  __kmp_threads[0]\n  //    may not be reused by another thread, so we may need to increase\n  //    __kmp_threads_capacity to __kmp_max_nth + 1.\n  //\n  // 2) New foreign root(s) are encountered.  We always register new foreign\n  //    roots. This may cause a smaller # of threads to be allocated at\n  //    subsequent parallel regions, but the worker threads hang around (and\n  //    eventually go to sleep) and need slots in the __kmp_threads[] array.\n  //\n  // Anyway, that is the reason for moving the check to see if\n  // __kmp_max_nth was exceeded into __kmp_reserve_threads()\n  // instead of having it performed here. -BB\n\n  KMP_DEBUG_ASSERT(__kmp_sys_max_nth >= __kmp_threads_capacity);\n\n  /* compute expansion headroom to check if we can expand */\n  if (__kmp_sys_max_nth - __kmp_threads_capacity < nNeed) {\n    /* possible expansion too small -- give up */\n    return added;\n  }\n  minimumRequiredCapacity = __kmp_threads_capacity + nNeed;\n\n  newCapacity = __kmp_threads_capacity;\n  do {\n    newCapacity = newCapacity <= (__kmp_sys_max_nth >> 1) ? (newCapacity << 1)\n                                                          : __kmp_sys_max_nth;\n  } while (newCapacity < minimumRequiredCapacity);\n  newThreads = (kmp_info_t **)__kmp_allocate(\n      (sizeof(kmp_info_t *) + sizeof(kmp_root_t *)) * newCapacity + CACHE_LINE);\n  newRoot =\n      (kmp_root_t **)((char *)newThreads + sizeof(kmp_info_t *) * newCapacity);\n  KMP_MEMCPY(newThreads, __kmp_threads,\n             __kmp_threads_capacity * sizeof(kmp_info_t *));\n  KMP_MEMCPY(newRoot, __kmp_root,\n             __kmp_threads_capacity * sizeof(kmp_root_t *));\n\n  kmp_info_t **temp_threads = __kmp_threads;\n  *(kmp_info_t * *volatile *)&__kmp_threads = newThreads;\n  *(kmp_root_t * *volatile *)&__kmp_root = newRoot;\n  __kmp_free(temp_threads);\n  added += newCapacity - __kmp_threads_capacity;\n  *(volatile int *)&__kmp_threads_capacity = newCapacity;\n\n  if (newCapacity > __kmp_tp_capacity) {\n    __kmp_acquire_bootstrap_lock(&__kmp_tp_cached_lock);\n    if (__kmp_tp_cached && newCapacity > __kmp_tp_capacity) {\n      __kmp_threadprivate_resize_cache(newCapacity);\n    } else { // increase __kmp_tp_capacity to correspond with kmp_threads size\n      *(volatile int *)&__kmp_tp_capacity = newCapacity;\n    }\n    __kmp_release_bootstrap_lock(&__kmp_tp_cached_lock);\n  }\n\n  return added;\n}\n\n/* Register the current thread as a root thread and obtain our gtid. We must\n   have the __kmp_initz_lock held at this point. Argument TRUE only if are the\n   thread that calls from __kmp_do_serial_initialize() */\nint __kmp_register_root(int initial_thread) {\n  kmp_info_t *root_thread;\n  kmp_root_t *root;\n  int gtid;\n  int capacity;\n  __kmp_acquire_bootstrap_lock(&__kmp_forkjoin_lock);\n  KA_TRACE(20, (\"__kmp_register_root: entered\\n\"));\n  KMP_MB();\n\n  /* 2007-03-02:\n     If initial thread did not invoke OpenMP RTL yet, and this thread is not an\n     initial one, \"__kmp_all_nth >= __kmp_threads_capacity\" condition does not\n     work as expected -- it may return false (that means there is at least one\n     empty slot in __kmp_threads array), but it is possible the only free slot\n     is #0, which is reserved for initial thread and so cannot be used for this\n     one. Following code workarounds this bug.\n\n     However, right solution seems to be not reserving slot #0 for initial\n     thread because:\n     (1) there is no magic in slot #0,\n     (2) we cannot detect initial thread reliably (the first thread which does\n        serial initialization may be not a real initial thread).\n  */\n  capacity = __kmp_threads_capacity;\n  if (!initial_thread && TCR_PTR(__kmp_threads[0]) == NULL) {\n    --capacity;\n  }\n\n  /* see if there are too many threads */\n  if (__kmp_all_nth >= capacity && !__kmp_expand_threads(1)) {\n    if (__kmp_tp_cached) {\n      __kmp_fatal(KMP_MSG(CantRegisterNewThread),\n                  KMP_HNT(Set_ALL_THREADPRIVATE, __kmp_tp_capacity),\n                  KMP_HNT(PossibleSystemLimitOnThreads), __kmp_msg_null);\n    } else {\n      __kmp_fatal(KMP_MSG(CantRegisterNewThread), KMP_HNT(SystemLimitOnThreads),\n                  __kmp_msg_null);\n    }\n  }\n\n  // When hidden helper task is enabled, __kmp_threads is organized as follows:\n  // 0: initial thread, also a regular OpenMP thread.\n  // [1, __kmp_hidden_helper_threads_num]: slots for hidden helper threads.\n  // [__kmp_hidden_helper_threads_num + 1, __kmp_threads_capacity): slots for\n  // regular OpenMP threads.\n  if (TCR_4(__kmp_init_hidden_helper_threads)) {\n    // Find an available thread slot for hidden helper thread. Slots for hidden\n    // helper threads start from 1 to __kmp_hidden_helper_threads_num.\n    for (gtid = 1; TCR_PTR(__kmp_threads[gtid]) != NULL &&\n                   gtid <= __kmp_hidden_helper_threads_num;\n         gtid++)\n      ;\n    KMP_ASSERT(gtid <= __kmp_hidden_helper_threads_num);\n    KA_TRACE(1, (\"__kmp_register_root: found slot in threads array for \"\n                 \"hidden helper thread: T#%d\\n\",\n                 gtid));\n  } else {\n    /* find an available thread slot */\n    // Don't reassign the zero slot since we need that to only be used by\n    // initial thread. Slots for hidden helper threads should also be skipped.\n    if (initial_thread && __kmp_threads[0] == NULL) {\n      gtid = 0;\n    } else {\n      for (gtid = __kmp_hidden_helper_threads_num + 1;\n           TCR_PTR(__kmp_threads[gtid]) != NULL; gtid++)\n        ;\n    }\n    KA_TRACE(\n        1, (\"__kmp_register_root: found slot in threads array: T#%d\\n\", gtid));\n    KMP_ASSERT(gtid < __kmp_threads_capacity);\n  }\n\n  /* update global accounting */\n  __kmp_all_nth++;\n  TCW_4(__kmp_nth, __kmp_nth + 1);\n\n  // if __kmp_adjust_gtid_mode is set, then we use method #1 (sp search) for low\n  // numbers of procs, and method #2 (keyed API call) for higher numbers.\n  if (__kmp_adjust_gtid_mode) {\n    if (__kmp_all_nth >= __kmp_tls_gtid_min) {\n      if (TCR_4(__kmp_gtid_mode) != 2) {\n        TCW_4(__kmp_gtid_mode, 2);\n      }\n    } else {\n      if (TCR_4(__kmp_gtid_mode) != 1) {\n        TCW_4(__kmp_gtid_mode, 1);\n      }\n    }\n  }\n\n#ifdef KMP_ADJUST_BLOCKTIME\n  /* Adjust blocktime to zero if necessary            */\n  /* Middle initialization might not have occurred yet */\n  if (!__kmp_env_blocktime && (__kmp_avail_proc > 0)) {\n    if (__kmp_nth > __kmp_avail_proc) {\n      __kmp_zero_bt = TRUE;\n    }\n  }\n#endif /* KMP_ADJUST_BLOCKTIME */\n\n  /* setup this new hierarchy */\n  if (!(root = __kmp_root[gtid])) {\n    root = __kmp_root[gtid] = (kmp_root_t *)__kmp_allocate(sizeof(kmp_root_t));\n    KMP_DEBUG_ASSERT(!root->r.r_root_team);\n  }\n\n#if KMP_STATS_ENABLED\n  // Initialize stats as soon as possible (right after gtid assignment).\n  __kmp_stats_thread_ptr = __kmp_stats_list->push_back(gtid);\n  __kmp_stats_thread_ptr->startLife();\n  KMP_SET_THREAD_STATE(SERIAL_REGION);\n  KMP_INIT_PARTITIONED_TIMERS(OMP_serial);\n#endif\n  __kmp_initialize_root(root);\n\n  /* setup new root thread structure */\n  if (root->r.r_uber_thread) {\n    root_thread = root->r.r_uber_thread;\n  } else {\n    root_thread = (kmp_info_t *)__kmp_allocate(sizeof(kmp_info_t));\n    if (__kmp_storage_map) {\n      __kmp_print_thread_storage_map(root_thread, gtid);\n    }\n    root_thread->th.th_info.ds.ds_gtid = gtid;\n#if OMPT_SUPPORT\n    root_thread->th.ompt_thread_info.thread_data = ompt_data_none;\n#endif\n    root_thread->th.th_root = root;\n    if (__kmp_env_consistency_check) {\n      root_thread->th.th_cons = __kmp_allocate_cons_stack(gtid);\n    }\n#if USE_FAST_MEMORY\n    __kmp_initialize_fast_memory(root_thread);\n#endif /* USE_FAST_MEMORY */\n\n#if KMP_USE_BGET\n    KMP_DEBUG_ASSERT(root_thread->th.th_local.bget_data == NULL);\n    __kmp_initialize_bget(root_thread);\n#endif\n    __kmp_init_random(root_thread); // Initialize random number generator\n  }\n\n  /* setup the serial team held in reserve by the root thread */\n  if (!root_thread->th.th_serial_team) {\n    kmp_internal_control_t r_icvs = __kmp_get_global_icvs();\n    KF_TRACE(10, (\"__kmp_register_root: before serial_team\\n\"));\n    root_thread->th.th_serial_team = __kmp_allocate_team(\n        root, 1, 1,\n#if OMPT_SUPPORT\n        ompt_data_none, // root parallel id\n#endif\n        proc_bind_default, &r_icvs, 0 USE_NESTED_HOT_ARG(NULL));\n  }\n  KMP_ASSERT(root_thread->th.th_serial_team);\n  KF_TRACE(10, (\"__kmp_register_root: after serial_team = %p\\n\",\n                root_thread->th.th_serial_team));\n\n  /* drop root_thread into place */\n  TCW_SYNC_PTR(__kmp_threads[gtid], root_thread);\n\n  root->r.r_root_team->t.t_threads[0] = root_thread;\n  root->r.r_hot_team->t.t_threads[0] = root_thread;\n  root_thread->th.th_serial_team->t.t_threads[0] = root_thread;\n  // AC: the team created in reserve, not for execution (it is unused for now).\n  root_thread->th.th_serial_team->t.t_serialized = 0;\n  root->r.r_uber_thread = root_thread;\n\n  /* initialize the thread, get it ready to go */\n  __kmp_initialize_info(root_thread, root->r.r_root_team, 0, gtid);\n  TCW_4(__kmp_init_gtid, TRUE);\n\n  /* prepare the primary thread for get_gtid() */\n  __kmp_gtid_set_specific(gtid);\n\n#if USE_ITT_BUILD\n  __kmp_itt_thread_name(gtid);\n#endif /* USE_ITT_BUILD */\n\n#ifdef KMP_TDATA_GTID\n  __kmp_gtid = gtid;\n#endif\n  __kmp_create_worker(gtid, root_thread, __kmp_stksize);\n  KMP_DEBUG_ASSERT(__kmp_gtid_get_specific() == gtid);\n\n  KA_TRACE(20, (\"__kmp_register_root: T#%d init T#%d(%d:%d) arrived: join=%u, \"\n                \"plain=%u\\n\",\n                gtid, __kmp_gtid_from_tid(0, root->r.r_hot_team),\n                root->r.r_hot_team->t.t_id, 0, KMP_INIT_BARRIER_STATE,\n                KMP_INIT_BARRIER_STATE));\n  { // Initialize barrier data.\n    int b;\n    for (b = 0; b < bs_last_barrier; ++b) {\n      root_thread->th.th_bar[b].bb.b_arrived = KMP_INIT_BARRIER_STATE;\n#if USE_DEBUGGER\n      root_thread->th.th_bar[b].bb.b_worker_arrived = 0;\n#endif\n    }\n  }\n  KMP_DEBUG_ASSERT(root->r.r_hot_team->t.t_bar[bs_forkjoin_barrier].b_arrived ==\n                   KMP_INIT_BARRIER_STATE);\n\n#if KMP_AFFINITY_SUPPORTED\n  root_thread->th.th_current_place = KMP_PLACE_UNDEFINED;\n  root_thread->th.th_new_place = KMP_PLACE_UNDEFINED;\n  root_thread->th.th_first_place = KMP_PLACE_UNDEFINED;\n  root_thread->th.th_last_place = KMP_PLACE_UNDEFINED;\n  if (TCR_4(__kmp_init_middle)) {\n    __kmp_affinity_set_init_mask(gtid, TRUE);\n  }\n#endif /* KMP_AFFINITY_SUPPORTED */\n  root_thread->th.th_def_allocator = __kmp_def_allocator;\n  root_thread->th.th_prev_level = 0;\n  root_thread->th.th_prev_num_threads = 1;\n\n  kmp_cg_root_t *tmp = (kmp_cg_root_t *)__kmp_allocate(sizeof(kmp_cg_root_t));\n  tmp->cg_root = root_thread;\n  tmp->cg_thread_limit = __kmp_cg_max_nth;\n  tmp->cg_nthreads = 1;\n  KA_TRACE(100, (\"__kmp_register_root: Thread %p created node %p with\"\n                 \" cg_nthreads init to 1\\n\",\n                 root_thread, tmp));\n  tmp->up = NULL;\n  root_thread->th.th_cg_roots = tmp;\n\n  __kmp_root_counter++;\n\n#if OMPT_SUPPORT\n  if (!initial_thread && ompt_enabled.enabled) {\n\n    kmp_info_t *root_thread = ompt_get_thread();\n\n    ompt_set_thread_state(root_thread, ompt_state_overhead);\n\n    if (ompt_enabled.ompt_callback_thread_begin) {\n      ompt_callbacks.ompt_callback(ompt_callback_thread_begin)(\n          ompt_thread_initial, __ompt_get_thread_data_internal());\n    }\n    ompt_data_t *task_data;\n    ompt_data_t *parallel_data;\n    __ompt_get_task_info_internal(0, NULL, &task_data, NULL, &parallel_data,\n                                  NULL);\n    if (ompt_enabled.ompt_callback_implicit_task) {\n      ompt_callbacks.ompt_callback(ompt_callback_implicit_task)(\n          ompt_scope_begin, parallel_data, task_data, 1, 1, ompt_task_initial);\n    }\n\n    ompt_set_thread_state(root_thread, ompt_state_work_serial);\n  }\n#endif\n\n  KMP_MB();\n  __kmp_release_bootstrap_lock(&__kmp_forkjoin_lock);\n\n  return gtid;\n}\n\n#if KMP_NESTED_HOT_TEAMS\nstatic int __kmp_free_hot_teams(kmp_root_t *root, kmp_info_t *thr, int level,\n                                const int max_level) {\n  int i, n, nth;\n  kmp_hot_team_ptr_t *hot_teams = thr->th.th_hot_teams;\n  if (!hot_teams || !hot_teams[level].hot_team) {\n    return 0;\n  }\n  KMP_DEBUG_ASSERT(level < max_level);\n  kmp_team_t *team = hot_teams[level].hot_team;\n  nth = hot_teams[level].hot_team_nth;\n  n = nth - 1; // primary thread is not freed\n  if (level < max_level - 1) {\n    for (i = 0; i < nth; ++i) {\n      kmp_info_t *th = team->t.t_threads[i];\n      n += __kmp_free_hot_teams(root, th, level + 1, max_level);\n      if (i > 0 && th->th.th_hot_teams) {\n        __kmp_free(th->th.th_hot_teams);\n        th->th.th_hot_teams = NULL;\n      }\n    }\n  }\n  __kmp_free_team(root, team, NULL);\n  return n;\n}\n#endif\n\n// Resets a root thread and clear its root and hot teams.\n// Returns the number of __kmp_threads entries directly and indirectly freed.\nstatic int __kmp_reset_root(int gtid, kmp_root_t *root) {\n  kmp_team_t *root_team = root->r.r_root_team;\n  kmp_team_t *hot_team = root->r.r_hot_team;\n  int n = hot_team->t.t_nproc;\n  int i;\n\n  KMP_DEBUG_ASSERT(!root->r.r_active);\n\n  root->r.r_root_team = NULL;\n  root->r.r_hot_team = NULL;\n  // __kmp_free_team() does not free hot teams, so we have to clear r_hot_team\n  // before call to __kmp_free_team().\n  __kmp_free_team(root, root_team USE_NESTED_HOT_ARG(NULL));\n#if KMP_NESTED_HOT_TEAMS\n  if (__kmp_hot_teams_max_level >\n      0) { // need to free nested hot teams and their threads if any\n    for (i = 0; i < hot_team->t.t_nproc; ++i) {\n      kmp_info_t *th = hot_team->t.t_threads[i];\n      if (__kmp_hot_teams_max_level > 1) {\n        n += __kmp_free_hot_teams(root, th, 1, __kmp_hot_teams_max_level);\n      }\n      if (th->th.th_hot_teams) {\n        __kmp_free(th->th.th_hot_teams);\n        th->th.th_hot_teams = NULL;\n      }\n    }\n  }\n#endif\n  __kmp_free_team(root, hot_team USE_NESTED_HOT_ARG(NULL));\n\n  // Before we can reap the thread, we need to make certain that all other\n  // threads in the teams that had this root as ancestor have stopped trying to\n  // steal tasks.\n  if (__kmp_tasking_mode != tskm_immediate_exec) {\n    __kmp_wait_to_unref_task_teams();\n  }\n\n#if KMP_OS_WINDOWS\n  /* Close Handle of root duplicated in __kmp_create_worker (tr #62919) */\n  KA_TRACE(\n      10, (\"__kmp_reset_root: free handle, th = %p, handle = %\" KMP_UINTPTR_SPEC\n           \"\\n\",\n           (LPVOID) & (root->r.r_uber_thread->th),\n           root->r.r_uber_thread->th.th_info.ds.ds_thread));\n  __kmp_free_handle(root->r.r_uber_thread->th.th_info.ds.ds_thread);\n#endif /* KMP_OS_WINDOWS */\n\n#if OMPT_SUPPORT\n  ompt_data_t *task_data;\n  ompt_data_t *parallel_data;\n  __ompt_get_task_info_internal(0, NULL, &task_data, NULL, &parallel_data,\n                                NULL);\n  if (ompt_enabled.ompt_callback_implicit_task) {\n    ompt_callbacks.ompt_callback(ompt_callback_implicit_task)(\n        ompt_scope_end, parallel_data, task_data, 0, 1, ompt_task_initial);\n  }\n  if (ompt_enabled.ompt_callback_thread_end) {\n    ompt_callbacks.ompt_callback(ompt_callback_thread_end)(\n        &(root->r.r_uber_thread->th.ompt_thread_info.thread_data));\n  }\n#endif\n\n  TCW_4(__kmp_nth,\n        __kmp_nth - 1); // __kmp_reap_thread will decrement __kmp_all_nth.\n  i = root->r.r_uber_thread->th.th_cg_roots->cg_nthreads--;\n  KA_TRACE(100, (\"__kmp_reset_root: Thread %p decrement cg_nthreads on node %p\"\n                 \" to %d\\n\",\n                 root->r.r_uber_thread, root->r.r_uber_thread->th.th_cg_roots,\n                 root->r.r_uber_thread->th.th_cg_roots->cg_nthreads));\n  if (i == 1) {\n    // need to free contention group structure\n    KMP_DEBUG_ASSERT(root->r.r_uber_thread ==\n                     root->r.r_uber_thread->th.th_cg_roots->cg_root);\n    KMP_DEBUG_ASSERT(root->r.r_uber_thread->th.th_cg_roots->up == NULL);\n    __kmp_free(root->r.r_uber_thread->th.th_cg_roots);\n    root->r.r_uber_thread->th.th_cg_roots = NULL;\n  }\n  __kmp_reap_thread(root->r.r_uber_thread, 1);\n\n  // We canot put root thread to __kmp_thread_pool, so we have to reap it\n  // instead of freeing.\n  root->r.r_uber_thread = NULL;\n  /* mark root as no longer in use */\n  root->r.r_begin = FALSE;\n\n  return n;\n}\n\nvoid __kmp_unregister_root_current_thread(int gtid) {\n  KA_TRACE(1, (\"__kmp_unregister_root_current_thread: enter T#%d\\n\", gtid));\n  /* this lock should be ok, since unregister_root_current_thread is never\n     called during an abort, only during a normal close. furthermore, if you\n     have the forkjoin lock, you should never try to get the initz lock */\n  __kmp_acquire_bootstrap_lock(&__kmp_forkjoin_lock);\n  if (TCR_4(__kmp_global.g.g_done) || !__kmp_init_serial) {\n    KC_TRACE(10, (\"__kmp_unregister_root_current_thread: already finished, \"\n                  \"exiting T#%d\\n\",\n                  gtid));\n    __kmp_release_bootstrap_lock(&__kmp_forkjoin_lock);\n    return;\n  }\n  kmp_root_t *root = __kmp_root[gtid];\n\n  KMP_DEBUG_ASSERT(__kmp_threads && __kmp_threads[gtid]);\n  KMP_ASSERT(KMP_UBER_GTID(gtid));\n  KMP_ASSERT(root == __kmp_threads[gtid]->th.th_root);\n  KMP_ASSERT(root->r.r_active == FALSE);\n\n  KMP_MB();\n\n  kmp_info_t *thread = __kmp_threads[gtid];\n  kmp_team_t *team = thread->th.th_team;\n  kmp_task_team_t *task_team = thread->th.th_task_team;\n\n  // we need to wait for the proxy tasks before finishing the thread\n  if (task_team != NULL && task_team->tt.tt_found_proxy_tasks) {\n#if OMPT_SUPPORT\n    // the runtime is shutting down so we won't report any events\n    thread->th.ompt_thread_info.state = ompt_state_undefined;\n#endif\n    __kmp_task_team_wait(thread, team USE_ITT_BUILD_ARG(NULL));\n  }\n\n  __kmp_reset_root(gtid, root);\n\n  KMP_MB();\n  KC_TRACE(10,\n           (\"__kmp_unregister_root_current_thread: T#%d unregistered\\n\", gtid));\n\n  __kmp_release_bootstrap_lock(&__kmp_forkjoin_lock);\n}\n\n#if KMP_OS_WINDOWS\n/* __kmp_forkjoin_lock must be already held\n   Unregisters a root thread that is not the current thread.  Returns the number\n   of __kmp_threads entries freed as a result. */\nstatic int __kmp_unregister_root_other_thread(int gtid) {\n  kmp_root_t *root = __kmp_root[gtid];\n  int r;\n\n  KA_TRACE(1, (\"__kmp_unregister_root_other_thread: enter T#%d\\n\", gtid));\n  KMP_DEBUG_ASSERT(__kmp_threads && __kmp_threads[gtid]);\n  KMP_ASSERT(KMP_UBER_GTID(gtid));\n  KMP_ASSERT(root == __kmp_threads[gtid]->th.th_root);\n  KMP_ASSERT(root->r.r_active == FALSE);\n\n  r = __kmp_reset_root(gtid, root);\n  KC_TRACE(10,\n           (\"__kmp_unregister_root_other_thread: T#%d unregistered\\n\", gtid));\n  return r;\n}\n#endif\n\n#if KMP_DEBUG\nvoid __kmp_task_info() {\n\n  kmp_int32 gtid = __kmp_entry_gtid();\n  kmp_int32 tid = __kmp_tid_from_gtid(gtid);\n  kmp_info_t *this_thr = __kmp_threads[gtid];\n  kmp_team_t *steam = this_thr->th.th_serial_team;\n  kmp_team_t *team = this_thr->th.th_team;\n\n  __kmp_printf(\n      \"__kmp_task_info: gtid=%d tid=%d t_thread=%p team=%p steam=%p curtask=%p \"\n      \"ptask=%p\\n\",\n      gtid, tid, this_thr, team, steam, this_thr->th.th_current_task,\n      team->t.t_implicit_task_taskdata[tid].td_parent);\n}\n#endif // KMP_DEBUG\n\n/* TODO optimize with one big memclr, take out what isn't needed, split\n   responsibility to workers as much as possible, and delay initialization of\n   features as much as possible  */\nstatic void __kmp_initialize_info(kmp_info_t *this_thr, kmp_team_t *team,\n                                  int tid, int gtid) {\n  /* this_thr->th.th_info.ds.ds_gtid is setup in\n     kmp_allocate_thread/create_worker.\n     this_thr->th.th_serial_team is setup in __kmp_allocate_thread */\n  kmp_info_t *master = team->t.t_threads[0];\n  KMP_DEBUG_ASSERT(this_thr != NULL);\n  KMP_DEBUG_ASSERT(this_thr->th.th_serial_team);\n  KMP_DEBUG_ASSERT(team);\n  KMP_DEBUG_ASSERT(team->t.t_threads);\n  KMP_DEBUG_ASSERT(team->t.t_dispatch);\n  KMP_DEBUG_ASSERT(master);\n  KMP_DEBUG_ASSERT(master->th.th_root);\n\n  KMP_MB();\n\n  TCW_SYNC_PTR(this_thr->th.th_team, team);\n\n  this_thr->th.th_info.ds.ds_tid = tid;\n  this_thr->th.th_set_nproc = 0;\n  if (__kmp_tasking_mode != tskm_immediate_exec)\n    // When tasking is possible, threads are not safe to reap until they are\n    // done tasking; this will be set when tasking code is exited in wait\n    this_thr->th.th_reap_state = KMP_NOT_SAFE_TO_REAP;\n  else // no tasking --> always safe to reap\n    this_thr->th.th_reap_state = KMP_SAFE_TO_REAP;\n  this_thr->th.th_set_proc_bind = proc_bind_default;\n#if KMP_AFFINITY_SUPPORTED\n  this_thr->th.th_new_place = this_thr->th.th_current_place;\n#endif\n  this_thr->th.th_root = master->th.th_root;\n\n  /* setup the thread's cache of the team structure */\n  this_thr->th.th_team_nproc = team->t.t_nproc;\n  this_thr->th.th_team_master = master;\n  this_thr->th.th_team_serialized = team->t.t_serialized;\n  TCW_PTR(this_thr->th.th_sleep_loc, NULL);\n\n  KMP_DEBUG_ASSERT(team->t.t_implicit_task_taskdata);\n\n  KF_TRACE(10, (\"__kmp_initialize_info1: T#%d:%d this_thread=%p curtask=%p\\n\",\n                tid, gtid, this_thr, this_thr->th.th_current_task));\n\n  __kmp_init_implicit_task(this_thr->th.th_team_master->th.th_ident, this_thr,\n                           team, tid, TRUE);\n\n  KF_TRACE(10, (\"__kmp_initialize_info2: T#%d:%d this_thread=%p curtask=%p\\n\",\n                tid, gtid, this_thr, this_thr->th.th_current_task));\n  // TODO: Initialize ICVs from parent; GEH - isn't that already done in\n  // __kmp_initialize_team()?\n\n  /* TODO no worksharing in speculative threads */\n  this_thr->th.th_dispatch = &team->t.t_dispatch[tid];\n\n  this_thr->th.th_local.this_construct = 0;\n\n  if (!this_thr->th.th_pri_common) {\n    this_thr->th.th_pri_common =\n        (struct common_table *)__kmp_allocate(sizeof(struct common_table));\n    if (__kmp_storage_map) {\n      __kmp_print_storage_map_gtid(\n          gtid, this_thr->th.th_pri_common, this_thr->th.th_pri_common + 1,\n          sizeof(struct common_table), \"th_%d.th_pri_common\\n\", gtid);\n    }\n    this_thr->th.th_pri_head = NULL;\n  }\n\n  if (this_thr != master && // Primary thread's CG root is initialized elsewhere\n      this_thr->th.th_cg_roots != master->th.th_cg_roots) { // CG root not set\n    // Make new thread's CG root same as primary thread's\n    KMP_DEBUG_ASSERT(master->th.th_cg_roots);\n    kmp_cg_root_t *tmp = this_thr->th.th_cg_roots;\n    if (tmp) {\n      // worker changes CG, need to check if old CG should be freed\n      int i = tmp->cg_nthreads--;\n      KA_TRACE(100, (\"__kmp_initialize_info: Thread %p decrement cg_nthreads\"\n                     \" on node %p of thread %p to %d\\n\",\n                     this_thr, tmp, tmp->cg_root, tmp->cg_nthreads));\n      if (i == 1) {\n        __kmp_free(tmp); // last thread left CG --> free it\n      }\n    }\n    this_thr->th.th_cg_roots = master->th.th_cg_roots;\n    // Increment new thread's CG root's counter to add the new thread\n    this_thr->th.th_cg_roots->cg_nthreads++;\n    KA_TRACE(100, (\"__kmp_initialize_info: Thread %p increment cg_nthreads on\"\n                   \" node %p of thread %p to %d\\n\",\n                   this_thr, this_thr->th.th_cg_roots,\n                   this_thr->th.th_cg_roots->cg_root,\n                   this_thr->th.th_cg_roots->cg_nthreads));\n    this_thr->th.th_current_task->td_icvs.thread_limit =\n        this_thr->th.th_cg_roots->cg_thread_limit;\n  }\n\n  /* Initialize dynamic dispatch */\n  {\n    volatile kmp_disp_t *dispatch = this_thr->th.th_dispatch;\n    // Use team max_nproc since this will never change for the team.\n    size_t disp_size =\n        sizeof(dispatch_private_info_t) *\n        (team->t.t_max_nproc == 1 ? 1 : __kmp_dispatch_num_buffers);\n    KD_TRACE(10, (\"__kmp_initialize_info: T#%d max_nproc: %d\\n\", gtid,\n                  team->t.t_max_nproc));\n    KMP_ASSERT(dispatch);\n    KMP_DEBUG_ASSERT(team->t.t_dispatch);\n    KMP_DEBUG_ASSERT(dispatch == &team->t.t_dispatch[tid]);\n\n    dispatch->th_disp_index = 0;\n    dispatch->th_doacross_buf_idx = 0;\n    if (!dispatch->th_disp_buffer) {\n      dispatch->th_disp_buffer =\n          (dispatch_private_info_t *)__kmp_allocate(disp_size);\n\n      if (__kmp_storage_map) {\n        __kmp_print_storage_map_gtid(\n            gtid, &dispatch->th_disp_buffer[0],\n            &dispatch->th_disp_buffer[team->t.t_max_nproc == 1\n                                          ? 1\n                                          : __kmp_dispatch_num_buffers],\n            disp_size,\n            \"th_%d.th_dispatch.th_disp_buffer \"\n            \"(team_%d.t_dispatch[%d].th_disp_buffer)\",\n            gtid, team->t.t_id, gtid);\n      }\n    } else {\n      memset(&dispatch->th_disp_buffer[0], '\\0', disp_size);\n    }\n\n    dispatch->th_dispatch_pr_current = 0;\n    dispatch->th_dispatch_sh_current = 0;\n\n    dispatch->th_deo_fcn = 0; /* ORDERED     */\n    dispatch->th_dxo_fcn = 0; /* END ORDERED */\n  }\n\n  this_thr->th.th_next_pool = NULL;\n\n  if (!this_thr->th.th_task_state_memo_stack) {\n    size_t i;\n    this_thr->th.th_task_state_memo_stack =\n        (kmp_uint8 *)__kmp_allocate(4 * sizeof(kmp_uint8));\n    this_thr->th.th_task_state_top = 0;\n    this_thr->th.th_task_state_stack_sz = 4;\n    for (i = 0; i < this_thr->th.th_task_state_stack_sz;\n         ++i) // zero init the stack\n      this_thr->th.th_task_state_memo_stack[i] = 0;\n  }\n\n  KMP_DEBUG_ASSERT(!this_thr->th.th_spin_here);\n  KMP_DEBUG_ASSERT(this_thr->th.th_next_waiting == 0);\n\n  KMP_MB();\n}\n\n/* allocate a new thread for the requesting team. this is only called from\n   within a forkjoin critical section. we will first try to get an available\n   thread from the thread pool. if none is available, we will fork a new one\n   assuming we are able to create a new one. this should be assured, as the\n   caller should check on this first. */\nkmp_info_t *__kmp_allocate_thread(kmp_root_t *root, kmp_team_t *team,\n                                  int new_tid) {\n  kmp_team_t *serial_team;\n  kmp_info_t *new_thr;\n  int new_gtid;\n\n  KA_TRACE(20, (\"__kmp_allocate_thread: T#%d\\n\", __kmp_get_gtid()));\n  KMP_DEBUG_ASSERT(root && team);\n#if !KMP_NESTED_HOT_TEAMS\n  KMP_DEBUG_ASSERT(KMP_MASTER_GTID(__kmp_get_gtid()));\n#endif\n  KMP_MB();\n\n  /* first, try to get one from the thread pool */\n  if (__kmp_thread_pool) {\n    new_thr = CCAST(kmp_info_t *, __kmp_thread_pool);\n    __kmp_thread_pool = (volatile kmp_info_t *)new_thr->th.th_next_pool;\n    if (new_thr == __kmp_thread_pool_insert_pt) {\n      __kmp_thread_pool_insert_pt = NULL;\n    }\n    TCW_4(new_thr->th.th_in_pool, FALSE);\n    __kmp_suspend_initialize_thread(new_thr);\n    __kmp_lock_suspend_mx(new_thr);\n    if (new_thr->th.th_active_in_pool == TRUE) {\n      KMP_DEBUG_ASSERT(new_thr->th.th_active == TRUE);\n      KMP_ATOMIC_DEC(&__kmp_thread_pool_active_nth);\n      new_thr->th.th_active_in_pool = FALSE;\n    }\n    __kmp_unlock_suspend_mx(new_thr);\n\n    KA_TRACE(20, (\"__kmp_allocate_thread: T#%d using thread T#%d\\n\",\n                  __kmp_get_gtid(), new_thr->th.th_info.ds.ds_gtid));\n    KMP_ASSERT(!new_thr->th.th_team);\n    KMP_DEBUG_ASSERT(__kmp_nth < __kmp_threads_capacity);\n\n    /* setup the thread structure */\n    __kmp_initialize_info(new_thr, team, new_tid,\n                          new_thr->th.th_info.ds.ds_gtid);\n    KMP_DEBUG_ASSERT(new_thr->th.th_serial_team);\n\n    TCW_4(__kmp_nth, __kmp_nth + 1);\n\n    new_thr->th.th_task_state = 0;\n    new_thr->th.th_task_state_top = 0;\n    new_thr->th.th_task_state_stack_sz = 4;\n\n#ifdef KMP_ADJUST_BLOCKTIME\n    /* Adjust blocktime back to zero if necessary */\n    /* Middle initialization might not have occurred yet */\n    if (!__kmp_env_blocktime && (__kmp_avail_proc > 0)) {\n      if (__kmp_nth > __kmp_avail_proc) {\n        __kmp_zero_bt = TRUE;\n      }\n    }\n#endif /* KMP_ADJUST_BLOCKTIME */\n\n#if KMP_DEBUG\n    // If thread entered pool via __kmp_free_thread, wait_flag should !=\n    // KMP_BARRIER_PARENT_FLAG.\n    int b;\n    kmp_balign_t *balign = new_thr->th.th_bar;\n    for (b = 0; b < bs_last_barrier; ++b)\n      KMP_DEBUG_ASSERT(balign[b].bb.wait_flag != KMP_BARRIER_PARENT_FLAG);\n#endif\n\n    KF_TRACE(10, (\"__kmp_allocate_thread: T#%d using thread %p T#%d\\n\",\n                  __kmp_get_gtid(), new_thr, new_thr->th.th_info.ds.ds_gtid));\n\n    KMP_MB();\n    return new_thr;\n  }\n\n  /* no, well fork a new one */\n  KMP_ASSERT(__kmp_nth == __kmp_all_nth);\n  KMP_ASSERT(__kmp_all_nth < __kmp_threads_capacity);\n\n#if KMP_USE_MONITOR\n  // If this is the first worker thread the RTL is creating, then also\n  // launch the monitor thread.  We try to do this as early as possible.\n  if (!TCR_4(__kmp_init_monitor)) {\n    __kmp_acquire_bootstrap_lock(&__kmp_monitor_lock);\n    if (!TCR_4(__kmp_init_monitor)) {\n      KF_TRACE(10, (\"before __kmp_create_monitor\\n\"));\n      TCW_4(__kmp_init_monitor, 1);\n      __kmp_create_monitor(&__kmp_monitor);\n      KF_TRACE(10, (\"after __kmp_create_monitor\\n\"));\n#if KMP_OS_WINDOWS\n      // AC: wait until monitor has started. This is a fix for CQ232808.\n      // The reason is that if the library is loaded/unloaded in a loop with\n      // small (parallel) work in between, then there is high probability that\n      // monitor thread started after the library shutdown. At shutdown it is\n      // too late to cope with the problem, because when the primary thread is\n      // in DllMain (process detach) the monitor has no chances to start (it is\n      // blocked), and primary thread has no means to inform the monitor that\n      // the library has gone, because all the memory which the monitor can\n      // access is going to be released/reset.\n      while (TCR_4(__kmp_init_monitor) < 2) {\n        KMP_YIELD(TRUE);\n      }\n      KF_TRACE(10, (\"after monitor thread has started\\n\"));\n#endif\n    }\n    __kmp_release_bootstrap_lock(&__kmp_monitor_lock);\n  }\n#endif\n\n  KMP_MB();\n\n  {\n    int new_start_gtid = TCR_4(__kmp_init_hidden_helper_threads)\n                             ? 1\n                             : __kmp_hidden_helper_threads_num + 1;\n\n    for (new_gtid = new_start_gtid; TCR_PTR(__kmp_threads[new_gtid]) != NULL;\n         ++new_gtid) {\n      KMP_DEBUG_ASSERT(new_gtid < __kmp_threads_capacity);\n    }\n\n    if (TCR_4(__kmp_init_hidden_helper_threads)) {\n      KMP_DEBUG_ASSERT(new_gtid <= __kmp_hidden_helper_threads_num);\n    }\n  }\n\n  /* allocate space for it. */\n  new_thr = (kmp_info_t *)__kmp_allocate(sizeof(kmp_info_t));\n\n  TCW_SYNC_PTR(__kmp_threads[new_gtid], new_thr);\n\n#if USE_ITT_BUILD && USE_ITT_NOTIFY && KMP_DEBUG\n  // suppress race conditions detection on synchronization flags in debug mode\n  // this helps to analyze library internals eliminating false positives\n  __itt_suppress_mark_range(\n      __itt_suppress_range, __itt_suppress_threading_errors,\n      &new_thr->th.th_sleep_loc, sizeof(new_thr->th.th_sleep_loc));\n  __itt_suppress_mark_range(\n      __itt_suppress_range, __itt_suppress_threading_errors,\n      &new_thr->th.th_reap_state, sizeof(new_thr->th.th_reap_state));\n#if KMP_OS_WINDOWS\n  __itt_suppress_mark_range(\n      __itt_suppress_range, __itt_suppress_threading_errors,\n      &new_thr->th.th_suspend_init, sizeof(new_thr->th.th_suspend_init));\n#else\n  __itt_suppress_mark_range(__itt_suppress_range,\n                            __itt_suppress_threading_errors,\n                            &new_thr->th.th_suspend_init_count,\n                            sizeof(new_thr->th.th_suspend_init_count));\n#endif\n  // TODO: check if we need to also suppress b_arrived flags\n  __itt_suppress_mark_range(__itt_suppress_range,\n                            __itt_suppress_threading_errors,\n                            CCAST(kmp_uint64 *, &new_thr->th.th_bar[0].bb.b_go),\n                            sizeof(new_thr->th.th_bar[0].bb.b_go));\n  __itt_suppress_mark_range(__itt_suppress_range,\n                            __itt_suppress_threading_errors,\n                            CCAST(kmp_uint64 *, &new_thr->th.th_bar[1].bb.b_go),\n                            sizeof(new_thr->th.th_bar[1].bb.b_go));\n  __itt_suppress_mark_range(__itt_suppress_range,\n                            __itt_suppress_threading_errors,\n                            CCAST(kmp_uint64 *, &new_thr->th.th_bar[2].bb.b_go),\n                            sizeof(new_thr->th.th_bar[2].bb.b_go));\n#endif /* USE_ITT_BUILD && USE_ITT_NOTIFY && KMP_DEBUG */\n  if (__kmp_storage_map) {\n    __kmp_print_thread_storage_map(new_thr, new_gtid);\n  }\n\n  // add the reserve serialized team, initialized from the team's primary thread\n  {\n    kmp_internal_control_t r_icvs = __kmp_get_x_global_icvs(team);\n    KF_TRACE(10, (\"__kmp_allocate_thread: before th_serial/serial_team\\n\"));\n    new_thr->th.th_serial_team = serial_team =\n        (kmp_team_t *)__kmp_allocate_team(root, 1, 1,\n#if OMPT_SUPPORT\n                                          ompt_data_none, // root parallel id\n#endif\n                                          proc_bind_default, &r_icvs,\n                                          0 USE_NESTED_HOT_ARG(NULL));\n  }\n  KMP_ASSERT(serial_team);\n  serial_team->t.t_serialized = 0; // AC: the team created in reserve, not for\n  // execution (it is unused for now).\n  serial_team->t.t_threads[0] = new_thr;\n  KF_TRACE(10,\n           (\"__kmp_allocate_thread: after th_serial/serial_team : new_thr=%p\\n\",\n            new_thr));\n\n  /* setup the thread structures */\n  __kmp_initialize_info(new_thr, team, new_tid, new_gtid);\n\n#if USE_FAST_MEMORY\n  __kmp_initialize_fast_memory(new_thr);\n#endif /* USE_FAST_MEMORY */\n\n#if KMP_USE_BGET\n  KMP_DEBUG_ASSERT(new_thr->th.th_local.bget_data == NULL);\n  __kmp_initialize_bget(new_thr);\n#endif\n\n  __kmp_init_random(new_thr); // Initialize random number generator\n\n  /* Initialize these only once when thread is grabbed for a team allocation */\n  KA_TRACE(20,\n           (\"__kmp_allocate_thread: T#%d init go fork=%u, plain=%u\\n\",\n            __kmp_get_gtid(), KMP_INIT_BARRIER_STATE, KMP_INIT_BARRIER_STATE));\n\n  int b;\n  kmp_balign_t *balign = new_thr->th.th_bar;\n  for (b = 0; b < bs_last_barrier; ++b) {\n    balign[b].bb.b_go = KMP_INIT_BARRIER_STATE;\n    balign[b].bb.team = NULL;\n    balign[b].bb.wait_flag = KMP_BARRIER_NOT_WAITING;\n    balign[b].bb.use_oncore_barrier = 0;\n  }\n\n  new_thr->th.th_spin_here = FALSE;\n  new_thr->th.th_next_waiting = 0;\n#if KMP_OS_UNIX\n  new_thr->th.th_blocking = false;\n#endif\n\n#if KMP_AFFINITY_SUPPORTED\n  new_thr->th.th_current_place = KMP_PLACE_UNDEFINED;\n  new_thr->th.th_new_place = KMP_PLACE_UNDEFINED;\n  new_thr->th.th_first_place = KMP_PLACE_UNDEFINED;\n  new_thr->th.th_last_place = KMP_PLACE_UNDEFINED;\n#endif\n  new_thr->th.th_def_allocator = __kmp_def_allocator;\n  new_thr->th.th_prev_level = 0;\n  new_thr->th.th_prev_num_threads = 1;\n\n  TCW_4(new_thr->th.th_in_pool, FALSE);\n  new_thr->th.th_active_in_pool = FALSE;\n  TCW_4(new_thr->th.th_active, TRUE);\n\n  /* adjust the global counters */\n  __kmp_all_nth++;\n  __kmp_nth++;\n\n  // if __kmp_adjust_gtid_mode is set, then we use method #1 (sp search) for low\n  // numbers of procs, and method #2 (keyed API call) for higher numbers.\n  if (__kmp_adjust_gtid_mode) {\n    if (__kmp_all_nth >= __kmp_tls_gtid_min) {\n      if (TCR_4(__kmp_gtid_mode) != 2) {\n        TCW_4(__kmp_gtid_mode, 2);\n      }\n    } else {\n      if (TCR_4(__kmp_gtid_mode) != 1) {\n        TCW_4(__kmp_gtid_mode, 1);\n      }\n    }\n  }\n\n#ifdef KMP_ADJUST_BLOCKTIME\n  /* Adjust blocktime back to zero if necessary       */\n  /* Middle initialization might not have occurred yet */\n  if (!__kmp_env_blocktime && (__kmp_avail_proc > 0)) {\n    if (__kmp_nth > __kmp_avail_proc) {\n      __kmp_zero_bt = TRUE;\n    }\n  }\n#endif /* KMP_ADJUST_BLOCKTIME */\n\n  /* actually fork it and create the new worker thread */\n  KF_TRACE(\n      10, (\"__kmp_allocate_thread: before __kmp_create_worker: %p\\n\", new_thr));\n  __kmp_create_worker(new_gtid, new_thr, __kmp_stksize);\n  KF_TRACE(10,\n           (\"__kmp_allocate_thread: after __kmp_create_worker: %p\\n\", new_thr));\n\n  KA_TRACE(20, (\"__kmp_allocate_thread: T#%d forked T#%d\\n\", __kmp_get_gtid(),\n                new_gtid));\n  KMP_MB();\n  return new_thr;\n}\n\n/* Reinitialize team for reuse.\n   The hot team code calls this case at every fork barrier, so EPCC barrier\n   test are extremely sensitive to changes in it, esp. writes to the team\n   struct, which cause a cache invalidation in all threads.\n   IF YOU TOUCH THIS ROUTINE, RUN EPCC C SYNCBENCH ON A BIG-IRON MACHINE!!! */\nstatic void __kmp_reinitialize_team(kmp_team_t *team,\n                                    kmp_internal_control_t *new_icvs,\n                                    ident_t *loc) {\n  KF_TRACE(10, (\"__kmp_reinitialize_team: enter this_thread=%p team=%p\\n\",\n                team->t.t_threads[0], team));\n  KMP_DEBUG_ASSERT(team && new_icvs);\n  KMP_DEBUG_ASSERT((!TCR_4(__kmp_init_parallel)) || new_icvs->nproc);\n  KMP_CHECK_UPDATE(team->t.t_ident, loc);\n\n  KMP_CHECK_UPDATE(team->t.t_id, KMP_GEN_TEAM_ID());\n  // Copy ICVs to the primary thread's implicit taskdata\n  __kmp_init_implicit_task(loc, team->t.t_threads[0], team, 0, FALSE);\n  copy_icvs(&team->t.t_implicit_task_taskdata[0].td_icvs, new_icvs);\n\n  KF_TRACE(10, (\"__kmp_reinitialize_team: exit this_thread=%p team=%p\\n\",\n                team->t.t_threads[0], team));\n}\n\n/* Initialize the team data structure.\n   This assumes the t_threads and t_max_nproc are already set.\n   Also, we don't touch the arguments */\nstatic void __kmp_initialize_team(kmp_team_t *team, int new_nproc,\n                                  kmp_internal_control_t *new_icvs,\n                                  ident_t *loc) {\n  KF_TRACE(10, (\"__kmp_initialize_team: enter: team=%p\\n\", team));\n\n  /* verify */\n  KMP_DEBUG_ASSERT(team);\n  KMP_DEBUG_ASSERT(new_nproc <= team->t.t_max_nproc);\n  KMP_DEBUG_ASSERT(team->t.t_threads);\n  KMP_MB();\n\n  team->t.t_master_tid = 0; /* not needed */\n  /* team->t.t_master_bar;        not needed */\n  team->t.t_serialized = new_nproc > 1 ? 0 : 1;\n  team->t.t_nproc = new_nproc;\n\n  /* team->t.t_parent     = NULL; TODO not needed & would mess up hot team */\n  team->t.t_next_pool = NULL;\n  /* memset( team->t.t_threads, 0, sizeof(kmp_info_t*)*new_nproc ); would mess\n   * up hot team */\n\n  TCW_SYNC_PTR(team->t.t_pkfn, NULL); /* not needed */\n  team->t.t_invoke = NULL; /* not needed */\n\n  // TODO???: team->t.t_max_active_levels       = new_max_active_levels;\n  team->t.t_sched.sched = new_icvs->sched.sched;\n\n#if KMP_ARCH_X86 || KMP_ARCH_X86_64\n  team->t.t_fp_control_saved = FALSE; /* not needed */\n  team->t.t_x87_fpu_control_word = 0; /* not needed */\n  team->t.t_mxcsr = 0; /* not needed */\n#endif /* KMP_ARCH_X86 || KMP_ARCH_X86_64 */\n\n  team->t.t_construct = 0;\n\n  team->t.t_ordered.dt.t_value = 0;\n  team->t.t_master_active = FALSE;\n\n#ifdef KMP_DEBUG\n  team->t.t_copypriv_data = NULL; /* not necessary, but nice for debugging */\n#endif\n#if KMP_OS_WINDOWS\n  team->t.t_copyin_counter = 0; /* for barrier-free copyin implementation */\n#endif\n\n  team->t.t_control_stack_top = NULL;\n\n  __kmp_reinitialize_team(team, new_icvs, loc);\n\n  KMP_MB();\n  KF_TRACE(10, (\"__kmp_initialize_team: exit: team=%p\\n\", team));\n}\n\n#if (KMP_OS_LINUX || KMP_OS_FREEBSD) && KMP_AFFINITY_SUPPORTED\n/* Sets full mask for thread and returns old mask, no changes to structures. */\nstatic void\n__kmp_set_thread_affinity_mask_full_tmp(kmp_affin_mask_t *old_mask) {\n  if (KMP_AFFINITY_CAPABLE()) {\n    int status;\n    if (old_mask != NULL) {\n      status = __kmp_get_system_affinity(old_mask, TRUE);\n      int error = errno;\n      if (status != 0) {\n        __kmp_fatal(KMP_MSG(ChangeThreadAffMaskError), KMP_ERR(error),\n                    __kmp_msg_null);\n      }\n    }\n    __kmp_set_system_affinity(__kmp_affin_fullMask, TRUE);\n  }\n}\n#endif\n\n#if KMP_AFFINITY_SUPPORTED\n\n// __kmp_partition_places() is the heart of the OpenMP 4.0 affinity mechanism.\n// It calculates the worker + primary thread's partition based upon the parent\n// thread's partition, and binds each worker to a thread in their partition.\n// The primary thread's partition should already include its current binding.\nstatic void __kmp_partition_places(kmp_team_t *team, int update_master_only) {\n  // Copy the primary thread's place partition to the team struct\n  kmp_info_t *master_th = team->t.t_threads[0];\n  KMP_DEBUG_ASSERT(master_th != NULL);\n  kmp_proc_bind_t proc_bind = team->t.t_proc_bind;\n  int first_place = master_th->th.th_first_place;\n  int last_place = master_th->th.th_last_place;\n  int masters_place = master_th->th.th_current_place;\n  team->t.t_first_place = first_place;\n  team->t.t_last_place = last_place;\n\n  KA_TRACE(20, (\"__kmp_partition_places: enter: proc_bind = %d T#%d(%d:0) \"\n                \"bound to place %d partition = [%d,%d]\\n\",\n                proc_bind, __kmp_gtid_from_thread(team->t.t_threads[0]),\n                team->t.t_id, masters_place, first_place, last_place));\n\n  switch (proc_bind) {\n\n  case proc_bind_default:\n    // Serial teams might have the proc_bind policy set to proc_bind_default.\n    // Not an issue -- we don't rebind primary thread for any proc_bind policy.\n    KMP_DEBUG_ASSERT(team->t.t_nproc == 1);\n    break;\n\n  case proc_bind_primary: {\n    int f;\n    int n_th = team->t.t_nproc;\n    for (f = 1; f < n_th; f++) {\n      kmp_info_t *th = team->t.t_threads[f];\n      KMP_DEBUG_ASSERT(th != NULL);\n      th->th.th_first_place = first_place;\n      th->th.th_last_place = last_place;\n      th->th.th_new_place = masters_place;\n      if (__kmp_display_affinity && masters_place != th->th.th_current_place &&\n          team->t.t_display_affinity != 1) {\n        team->t.t_display_affinity = 1;\n      }\n\n      KA_TRACE(100, (\"__kmp_partition_places: primary: T#%d(%d:%d) place %d \"\n                     \"partition = [%d,%d]\\n\",\n                     __kmp_gtid_from_thread(team->t.t_threads[f]), team->t.t_id,\n                     f, masters_place, first_place, last_place));\n    }\n  } break;\n\n  case proc_bind_close: {\n    int f;\n    int n_th = team->t.t_nproc;\n    int n_places;\n    if (first_place <= last_place) {\n      n_places = last_place - first_place + 1;\n    } else {\n      n_places = __kmp_affinity_num_masks - first_place + last_place + 1;\n    }\n    if (n_th <= n_places) {\n      int place = masters_place;\n      for (f = 1; f < n_th; f++) {\n        kmp_info_t *th = team->t.t_threads[f];\n        KMP_DEBUG_ASSERT(th != NULL);\n\n        if (place == last_place) {\n          place = first_place;\n        } else if (place == (int)(__kmp_affinity_num_masks - 1)) {\n          place = 0;\n        } else {\n          place++;\n        }\n        th->th.th_first_place = first_place;\n        th->th.th_last_place = last_place;\n        th->th.th_new_place = place;\n        if (__kmp_display_affinity && place != th->th.th_current_place &&\n            team->t.t_display_affinity != 1) {\n          team->t.t_display_affinity = 1;\n        }\n\n        KA_TRACE(100, (\"__kmp_partition_places: close: T#%d(%d:%d) place %d \"\n                       \"partition = [%d,%d]\\n\",\n                       __kmp_gtid_from_thread(team->t.t_threads[f]),\n                       team->t.t_id, f, place, first_place, last_place));\n      }\n    } else {\n      int S, rem, gap, s_count;\n      S = n_th / n_places;\n      s_count = 0;\n      rem = n_th - (S * n_places);\n      gap = rem > 0 ? n_places / rem : n_places;\n      int place = masters_place;\n      int gap_ct = gap;\n      for (f = 0; f < n_th; f++) {\n        kmp_info_t *th = team->t.t_threads[f];\n        KMP_DEBUG_ASSERT(th != NULL);\n\n        th->th.th_first_place = first_place;\n        th->th.th_last_place = last_place;\n        th->th.th_new_place = place;\n        if (__kmp_display_affinity && place != th->th.th_current_place &&\n            team->t.t_display_affinity != 1) {\n          team->t.t_display_affinity = 1;\n        }\n        s_count++;\n\n        if ((s_count == S) && rem && (gap_ct == gap)) {\n          // do nothing, add an extra thread to place on next iteration\n        } else if ((s_count == S + 1) && rem && (gap_ct == gap)) {\n          // we added an extra thread to this place; move to next place\n          if (place == last_place) {\n            place = first_place;\n          } else if (place == (int)(__kmp_affinity_num_masks - 1)) {\n            place = 0;\n          } else {\n            place++;\n          }\n          s_count = 0;\n          gap_ct = 1;\n          rem--;\n        } else if (s_count == S) { // place full; don't add extra\n          if (place == last_place) {\n            place = first_place;\n          } else if (place == (int)(__kmp_affinity_num_masks - 1)) {\n            place = 0;\n          } else {\n            place++;\n          }\n          gap_ct++;\n          s_count = 0;\n        }\n\n        KA_TRACE(100,\n                 (\"__kmp_partition_places: close: T#%d(%d:%d) place %d \"\n                  \"partition = [%d,%d]\\n\",\n                  __kmp_gtid_from_thread(team->t.t_threads[f]), team->t.t_id, f,\n                  th->th.th_new_place, first_place, last_place));\n      }\n      KMP_DEBUG_ASSERT(place == masters_place);\n    }\n  } break;\n\n  case proc_bind_spread: {\n    int f;\n    int n_th = team->t.t_nproc;\n    int n_places;\n    int thidx;\n    if (first_place <= last_place) {\n      n_places = last_place - first_place + 1;\n    } else {\n      n_places = __kmp_affinity_num_masks - first_place + last_place + 1;\n    }\n    if (n_th <= n_places) {\n      int place = -1;\n\n      if (n_places != static_cast<int>(__kmp_affinity_num_masks)) {\n        int S = n_places / n_th;\n        int s_count, rem, gap, gap_ct;\n\n        place = masters_place;\n        rem = n_places - n_th * S;\n        gap = rem ? n_th / rem : 1;\n        gap_ct = gap;\n        thidx = n_th;\n        if (update_master_only == 1)\n          thidx = 1;\n        for (f = 0; f < thidx; f++) {\n          kmp_info_t *th = team->t.t_threads[f];\n          KMP_DEBUG_ASSERT(th != NULL);\n\n          th->th.th_first_place = place;\n          th->th.th_new_place = place;\n          if (__kmp_display_affinity && place != th->th.th_current_place &&\n              team->t.t_display_affinity != 1) {\n            team->t.t_display_affinity = 1;\n          }\n          s_count = 1;\n          while (s_count < S) {\n            if (place == last_place) {\n              place = first_place;\n            } else if (place == (int)(__kmp_affinity_num_masks - 1)) {\n              place = 0;\n            } else {\n              place++;\n            }\n            s_count++;\n          }\n          if (rem && (gap_ct == gap)) {\n            if (place == last_place) {\n              place = first_place;\n            } else if (place == (int)(__kmp_affinity_num_masks - 1)) {\n              place = 0;\n            } else {\n              place++;\n            }\n            rem--;\n            gap_ct = 0;\n          }\n          th->th.th_last_place = place;\n          gap_ct++;\n\n          if (place == last_place) {\n            place = first_place;\n          } else if (place == (int)(__kmp_affinity_num_masks - 1)) {\n            place = 0;\n          } else {\n            place++;\n          }\n\n          KA_TRACE(100,\n                   (\"__kmp_partition_places: spread: T#%d(%d:%d) place %d \"\n                    \"partition = [%d,%d], __kmp_affinity_num_masks: %u\\n\",\n                    __kmp_gtid_from_thread(team->t.t_threads[f]), team->t.t_id,\n                    f, th->th.th_new_place, th->th.th_first_place,\n                    th->th.th_last_place, __kmp_affinity_num_masks));\n        }\n      } else {\n        /* Having uniform space of available computation places I can create\n           T partitions of round(P/T) size and put threads into the first\n           place of each partition. */\n        double current = static_cast<double>(masters_place);\n        double spacing =\n            (static_cast<double>(n_places + 1) / static_cast<double>(n_th));\n        int first, last;\n        kmp_info_t *th;\n\n        thidx = n_th + 1;\n        if (update_master_only == 1)\n          thidx = 1;\n        for (f = 0; f < thidx; f++) {\n          first = static_cast<int>(current);\n          last = static_cast<int>(current + spacing) - 1;\n          KMP_DEBUG_ASSERT(last >= first);\n          if (first >= n_places) {\n            if (masters_place) {\n              first -= n_places;\n              last -= n_places;\n              if (first == (masters_place + 1)) {\n                KMP_DEBUG_ASSERT(f == n_th);\n                first--;\n              }\n              if (last == masters_place) {\n                KMP_DEBUG_ASSERT(f == (n_th - 1));\n                last--;\n              }\n            } else {\n              KMP_DEBUG_ASSERT(f == n_th);\n              first = 0;\n              last = 0;\n            }\n          }\n          if (last >= n_places) {\n            last = (n_places - 1);\n          }\n          place = first;\n          current += spacing;\n          if (f < n_th) {\n            KMP_DEBUG_ASSERT(0 <= first);\n            KMP_DEBUG_ASSERT(n_places > first);\n            KMP_DEBUG_ASSERT(0 <= last);\n            KMP_DEBUG_ASSERT(n_places > last);\n            KMP_DEBUG_ASSERT(last_place >= first_place);\n            th = team->t.t_threads[f];\n            KMP_DEBUG_ASSERT(th);\n            th->th.th_first_place = first;\n            th->th.th_new_place = place;\n            th->th.th_last_place = last;\n            if (__kmp_display_affinity && place != th->th.th_current_place &&\n                team->t.t_display_affinity != 1) {\n              team->t.t_display_affinity = 1;\n            }\n            KA_TRACE(100,\n                     (\"__kmp_partition_places: spread: T#%d(%d:%d) place %d \"\n                      \"partition = [%d,%d], spacing = %.4f\\n\",\n                      __kmp_gtid_from_thread(team->t.t_threads[f]),\n                      team->t.t_id, f, th->th.th_new_place,\n                      th->th.th_first_place, th->th.th_last_place, spacing));\n          }\n        }\n      }\n      KMP_DEBUG_ASSERT(update_master_only || place == masters_place);\n    } else {\n      int S, rem, gap, s_count;\n      S = n_th / n_places;\n      s_count = 0;\n      rem = n_th - (S * n_places);\n      gap = rem > 0 ? n_places / rem : n_places;\n      int place = masters_place;\n      int gap_ct = gap;\n      thidx = n_th;\n      if (update_master_only == 1)\n        thidx = 1;\n      for (f = 0; f < thidx; f++) {\n        kmp_info_t *th = team->t.t_threads[f];\n        KMP_DEBUG_ASSERT(th != NULL);\n\n        th->th.th_first_place = place;\n        th->th.th_last_place = place;\n        th->th.th_new_place = place;\n        if (__kmp_display_affinity && place != th->th.th_current_place &&\n            team->t.t_display_affinity != 1) {\n          team->t.t_display_affinity = 1;\n        }\n        s_count++;\n\n        if ((s_count == S) && rem && (gap_ct == gap)) {\n          // do nothing, add an extra thread to place on next iteration\n        } else if ((s_count == S + 1) && rem && (gap_ct == gap)) {\n          // we added an extra thread to this place; move on to next place\n          if (place == last_place) {\n            place = first_place;\n          } else if (place == (int)(__kmp_affinity_num_masks - 1)) {\n            place = 0;\n          } else {\n            place++;\n          }\n          s_count = 0;\n          gap_ct = 1;\n          rem--;\n        } else if (s_count == S) { // place is full; don't add extra thread\n          if (place == last_place) {\n            place = first_place;\n          } else if (place == (int)(__kmp_affinity_num_masks - 1)) {\n            place = 0;\n          } else {\n            place++;\n          }\n          gap_ct++;\n          s_count = 0;\n        }\n\n        KA_TRACE(100, (\"__kmp_partition_places: spread: T#%d(%d:%d) place %d \"\n                       \"partition = [%d,%d]\\n\",\n                       __kmp_gtid_from_thread(team->t.t_threads[f]),\n                       team->t.t_id, f, th->th.th_new_place,\n                       th->th.th_first_place, th->th.th_last_place));\n      }\n      KMP_DEBUG_ASSERT(update_master_only || place == masters_place);\n    }\n  } break;\n\n  default:\n    break;\n  }\n\n  KA_TRACE(20, (\"__kmp_partition_places: exit T#%d\\n\", team->t.t_id));\n}\n\n#endif // KMP_AFFINITY_SUPPORTED\n\n/* allocate a new team data structure to use.  take one off of the free pool if\n   available */\nkmp_team_t *\n__kmp_allocate_team(kmp_root_t *root, int new_nproc, int max_nproc,\n#if OMPT_SUPPORT\n                    ompt_data_t ompt_parallel_data,\n#endif\n                    kmp_proc_bind_t new_proc_bind,\n                    kmp_internal_control_t *new_icvs,\n                    int argc USE_NESTED_HOT_ARG(kmp_info_t *master)) {\n  KMP_TIME_DEVELOPER_PARTITIONED_BLOCK(KMP_allocate_team);\n  int f;\n  kmp_team_t *team;\n  int use_hot_team = !root->r.r_active;\n  int level = 0;\n\n  KA_TRACE(20, (\"__kmp_allocate_team: called\\n\"));\n  KMP_DEBUG_ASSERT(new_nproc >= 1 && argc >= 0);\n  KMP_DEBUG_ASSERT(max_nproc >= new_nproc);\n  KMP_MB();\n\n#if KMP_NESTED_HOT_TEAMS\n  kmp_hot_team_ptr_t *hot_teams;\n  if (master) {\n    team = master->th.th_team;\n    level = team->t.t_active_level;\n    if (master->th.th_teams_microtask) { // in teams construct?\n      if (master->th.th_teams_size.nteams > 1 &&\n          ( // #teams > 1\n              team->t.t_pkfn ==\n                  (microtask_t)__kmp_teams_master || // inner fork of the teams\n              master->th.th_teams_level <\n                  team->t.t_level)) { // or nested parallel inside the teams\n        ++level; // not increment if #teams==1, or for outer fork of the teams;\n        // increment otherwise\n      }\n    }\n    hot_teams = master->th.th_hot_teams;\n    if (level < __kmp_hot_teams_max_level && hot_teams &&\n        hot_teams[level].hot_team) {\n      // hot team has already been allocated for given level\n      use_hot_team = 1;\n    } else {\n      use_hot_team = 0;\n    }\n  } else {\n    // check we won't access uninitialized hot_teams, just in case\n    KMP_DEBUG_ASSERT(new_nproc == 1);\n  }\n#endif\n  // Optimization to use a \"hot\" team\n  if (use_hot_team && new_nproc > 1) {\n    KMP_DEBUG_ASSERT(new_nproc <= max_nproc);\n#if KMP_NESTED_HOT_TEAMS\n    team = hot_teams[level].hot_team;\n#else\n    team = root->r.r_hot_team;\n#endif\n#if KMP_DEBUG\n    if (__kmp_tasking_mode != tskm_immediate_exec) {\n      KA_TRACE(20, (\"__kmp_allocate_team: hot team task_team[0] = %p \"\n                    \"task_team[1] = %p before reinit\\n\",\n                    team->t.t_task_team[0], team->t.t_task_team[1]));\n    }\n#endif\n\n    // Has the number of threads changed?\n    /* Let's assume the most common case is that the number of threads is\n       unchanged, and put that case first. */\n    if (team->t.t_nproc == new_nproc) { // Check changes in number of threads\n      KA_TRACE(20, (\"__kmp_allocate_team: reusing hot team\\n\"));\n      // This case can mean that omp_set_num_threads() was called and the hot\n      // team size was already reduced, so we check the special flag\n      if (team->t.t_size_changed == -1) {\n        team->t.t_size_changed = 1;\n      } else {\n        KMP_CHECK_UPDATE(team->t.t_size_changed, 0);\n      }\n\n      // TODO???: team->t.t_max_active_levels = new_max_active_levels;\n      kmp_r_sched_t new_sched = new_icvs->sched;\n      // set primary thread's schedule as new run-time schedule\n      KMP_CHECK_UPDATE(team->t.t_sched.sched, new_sched.sched);\n\n      __kmp_reinitialize_team(team, new_icvs,\n                              root->r.r_uber_thread->th.th_ident);\n\n      KF_TRACE(10, (\"__kmp_allocate_team2: T#%d, this_thread=%p team=%p\\n\", 0,\n                    team->t.t_threads[0], team));\n      __kmp_push_current_task_to_thread(team->t.t_threads[0], team, 0);\n\n#if KMP_AFFINITY_SUPPORTED\n      if ((team->t.t_size_changed == 0) &&\n          (team->t.t_proc_bind == new_proc_bind)) {\n        if (new_proc_bind == proc_bind_spread) {\n          __kmp_partition_places(\n              team, 1); // add flag to update only master for spread\n        }\n        KA_TRACE(200, (\"__kmp_allocate_team: reusing hot team #%d bindings: \"\n                       \"proc_bind = %d, partition = [%d,%d]\\n\",\n                       team->t.t_id, new_proc_bind, team->t.t_first_place,\n                       team->t.t_last_place));\n      } else {\n        KMP_CHECK_UPDATE(team->t.t_proc_bind, new_proc_bind);\n        __kmp_partition_places(team);\n      }\n#else\n      KMP_CHECK_UPDATE(team->t.t_proc_bind, new_proc_bind);\n#endif /* KMP_AFFINITY_SUPPORTED */\n    } else if (team->t.t_nproc > new_nproc) {\n      KA_TRACE(20,\n               (\"__kmp_allocate_team: decreasing hot team thread count to %d\\n\",\n                new_nproc));\n\n      team->t.t_size_changed = 1;\n#if KMP_NESTED_HOT_TEAMS\n      if (__kmp_hot_teams_mode == 0) {\n        // AC: saved number of threads should correspond to team's value in this\n        // mode, can be bigger in mode 1, when hot team has threads in reserve\n        KMP_DEBUG_ASSERT(hot_teams[level].hot_team_nth == team->t.t_nproc);\n        hot_teams[level].hot_team_nth = new_nproc;\n#endif // KMP_NESTED_HOT_TEAMS\n        /* release the extra threads we don't need any more */\n        for (f = new_nproc; f < team->t.t_nproc; f++) {\n          KMP_DEBUG_ASSERT(team->t.t_threads[f]);\n          if (__kmp_tasking_mode != tskm_immediate_exec) {\n            // When decreasing team size, threads no longer in the team should\n            // unref task team.\n            team->t.t_threads[f]->th.th_task_team = NULL;\n          }\n          __kmp_free_thread(team->t.t_threads[f]);\n          team->t.t_threads[f] = NULL;\n        }\n#if KMP_NESTED_HOT_TEAMS\n      } // (__kmp_hot_teams_mode == 0)\n      else {\n        // When keeping extra threads in team, switch threads to wait on own\n        // b_go flag\n        for (f = new_nproc; f < team->t.t_nproc; ++f) {\n          KMP_DEBUG_ASSERT(team->t.t_threads[f]);\n          kmp_balign_t *balign = team->t.t_threads[f]->th.th_bar;\n          for (int b = 0; b < bs_last_barrier; ++b) {\n            if (balign[b].bb.wait_flag == KMP_BARRIER_PARENT_FLAG) {\n              balign[b].bb.wait_flag = KMP_BARRIER_SWITCH_TO_OWN_FLAG;\n            }\n            KMP_CHECK_UPDATE(balign[b].bb.leaf_kids, 0);\n          }\n        }\n      }\n#endif // KMP_NESTED_HOT_TEAMS\n      team->t.t_nproc = new_nproc;\n      // TODO???: team->t.t_max_active_levels = new_max_active_levels;\n      KMP_CHECK_UPDATE(team->t.t_sched.sched, new_icvs->sched.sched);\n      __kmp_reinitialize_team(team, new_icvs,\n                              root->r.r_uber_thread->th.th_ident);\n\n      // Update remaining threads\n      for (f = 0; f < new_nproc; ++f) {\n        team->t.t_threads[f]->th.th_team_nproc = new_nproc;\n      }\n\n      // restore the current task state of the primary thread: should be the\n      // implicit task\n      KF_TRACE(10, (\"__kmp_allocate_team: T#%d, this_thread=%p team=%p\\n\", 0,\n                    team->t.t_threads[0], team));\n\n      __kmp_push_current_task_to_thread(team->t.t_threads[0], team, 0);\n\n#ifdef KMP_DEBUG\n      for (f = 0; f < team->t.t_nproc; f++) {\n        KMP_DEBUG_ASSERT(team->t.t_threads[f] &&\n                         team->t.t_threads[f]->th.th_team_nproc ==\n                             team->t.t_nproc);\n      }\n#endif\n\n      KMP_CHECK_UPDATE(team->t.t_proc_bind, new_proc_bind);\n#if KMP_AFFINITY_SUPPORTED\n      __kmp_partition_places(team);\n#endif\n    } else { // team->t.t_nproc < new_nproc\n#if (KMP_OS_LINUX || KMP_OS_FREEBSD) && KMP_AFFINITY_SUPPORTED\n      kmp_affin_mask_t *old_mask;\n      if (KMP_AFFINITY_CAPABLE()) {\n        KMP_CPU_ALLOC(old_mask);\n      }\n#endif\n\n      KA_TRACE(20,\n               (\"__kmp_allocate_team: increasing hot team thread count to %d\\n\",\n                new_nproc));\n\n      team->t.t_size_changed = 1;\n\n#if KMP_NESTED_HOT_TEAMS\n      int avail_threads = hot_teams[level].hot_team_nth;\n      if (new_nproc < avail_threads)\n        avail_threads = new_nproc;\n      kmp_info_t **other_threads = team->t.t_threads;\n      for (f = team->t.t_nproc; f < avail_threads; ++f) {\n        // Adjust barrier data of reserved threads (if any) of the team\n        // Other data will be set in __kmp_initialize_info() below.\n        int b;\n        kmp_balign_t *balign = other_threads[f]->th.th_bar;\n        for (b = 0; b < bs_last_barrier; ++b) {\n          balign[b].bb.b_arrived = team->t.t_bar[b].b_arrived;\n          KMP_DEBUG_ASSERT(balign[b].bb.wait_flag != KMP_BARRIER_PARENT_FLAG);\n#if USE_DEBUGGER\n          balign[b].bb.b_worker_arrived = team->t.t_bar[b].b_team_arrived;\n#endif\n        }\n      }\n      if (hot_teams[level].hot_team_nth >= new_nproc) {\n        // we have all needed threads in reserve, no need to allocate any\n        // this only possible in mode 1, cannot have reserved threads in mode 0\n        KMP_DEBUG_ASSERT(__kmp_hot_teams_mode == 1);\n        team->t.t_nproc = new_nproc; // just get reserved threads involved\n      } else {\n        // we may have some threads in reserve, but not enough\n        team->t.t_nproc =\n            hot_teams[level]\n                .hot_team_nth; // get reserved threads involved if any\n        hot_teams[level].hot_team_nth = new_nproc; // adjust hot team max size\n#endif // KMP_NESTED_HOT_TEAMS\n        if (team->t.t_max_nproc < new_nproc) {\n          /* reallocate larger arrays */\n          __kmp_reallocate_team_arrays(team, new_nproc);\n          __kmp_reinitialize_team(team, new_icvs, NULL);\n        }\n\n#if (KMP_OS_LINUX || KMP_OS_FREEBSD) && KMP_AFFINITY_SUPPORTED\n        /* Temporarily set full mask for primary thread before creation of\n           workers. The reason is that workers inherit the affinity from the\n           primary thread, so if a lot of workers are created on the single\n           core quickly, they don't get a chance to set their own affinity for\n           a long time. */\n        __kmp_set_thread_affinity_mask_full_tmp(old_mask);\n#endif\n\n        /* allocate new threads for the hot team */\n        for (f = team->t.t_nproc; f < new_nproc; f++) {\n          kmp_info_t *new_worker = __kmp_allocate_thread(root, team, f);\n          KMP_DEBUG_ASSERT(new_worker);\n          team->t.t_threads[f] = new_worker;\n\n          KA_TRACE(20,\n                   (\"__kmp_allocate_team: team %d init T#%d arrived: \"\n                    \"join=%llu, plain=%llu\\n\",\n                    team->t.t_id, __kmp_gtid_from_tid(f, team), team->t.t_id, f,\n                    team->t.t_bar[bs_forkjoin_barrier].b_arrived,\n                    team->t.t_bar[bs_plain_barrier].b_arrived));\n\n          { // Initialize barrier data for new threads.\n            int b;\n            kmp_balign_t *balign = new_worker->th.th_bar;\n            for (b = 0; b < bs_last_barrier; ++b) {\n              balign[b].bb.b_arrived = team->t.t_bar[b].b_arrived;\n              KMP_DEBUG_ASSERT(balign[b].bb.wait_flag !=\n                               KMP_BARRIER_PARENT_FLAG);\n#if USE_DEBUGGER\n              balign[b].bb.b_worker_arrived = team->t.t_bar[b].b_team_arrived;\n#endif\n            }\n          }\n        }\n\n#if (KMP_OS_LINUX || KMP_OS_FREEBSD) && KMP_AFFINITY_SUPPORTED\n        if (KMP_AFFINITY_CAPABLE()) {\n          /* Restore initial primary thread's affinity mask */\n          __kmp_set_system_affinity(old_mask, TRUE);\n          KMP_CPU_FREE(old_mask);\n        }\n#endif\n#if KMP_NESTED_HOT_TEAMS\n      } // end of check of t_nproc vs. new_nproc vs. hot_team_nth\n#endif // KMP_NESTED_HOT_TEAMS\n      /* make sure everyone is syncronized */\n      int old_nproc = team->t.t_nproc; // save old value and use to update only\n      // new threads below\n      __kmp_initialize_team(team, new_nproc, new_icvs,\n                            root->r.r_uber_thread->th.th_ident);\n\n      /* reinitialize the threads */\n      KMP_DEBUG_ASSERT(team->t.t_nproc == new_nproc);\n      for (f = 0; f < team->t.t_nproc; ++f)\n        __kmp_initialize_info(team->t.t_threads[f], team, f,\n                              __kmp_gtid_from_tid(f, team));\n\n      if (level) { // set th_task_state for new threads in nested hot team\n        // __kmp_initialize_info() no longer zeroes th_task_state, so we should\n        // only need to set the th_task_state for the new threads. th_task_state\n        // for primary thread will not be accurate until after this in\n        // __kmp_fork_call(), so we look to the primary thread's memo_stack to\n        // get the correct value.\n        for (f = old_nproc; f < team->t.t_nproc; ++f)\n          team->t.t_threads[f]->th.th_task_state =\n              team->t.t_threads[0]->th.th_task_state_memo_stack[level];\n      } else { // set th_task_state for new threads in non-nested hot team\n        // copy primary thread's state\n        kmp_uint8 old_state = team->t.t_threads[0]->th.th_task_state;\n        for (f = old_nproc; f < team->t.t_nproc; ++f)\n          team->t.t_threads[f]->th.th_task_state = old_state;\n      }\n\n#ifdef KMP_DEBUG\n      for (f = 0; f < team->t.t_nproc; ++f) {\n        KMP_DEBUG_ASSERT(team->t.t_threads[f] &&\n                         team->t.t_threads[f]->th.th_team_nproc ==\n                             team->t.t_nproc);\n      }\n#endif\n\n      KMP_CHECK_UPDATE(team->t.t_proc_bind, new_proc_bind);\n#if KMP_AFFINITY_SUPPORTED\n      __kmp_partition_places(team);\n#endif\n    } // Check changes in number of threads\n\n    kmp_info_t *master = team->t.t_threads[0];\n    if (master->th.th_teams_microtask) {\n      for (f = 1; f < new_nproc; ++f) {\n        // propagate teams construct specific info to workers\n        kmp_info_t *thr = team->t.t_threads[f];\n        thr->th.th_teams_microtask = master->th.th_teams_microtask;\n        thr->th.th_teams_level = master->th.th_teams_level;\n        thr->th.th_teams_size = master->th.th_teams_size;\n      }\n    }\n#if KMP_NESTED_HOT_TEAMS\n    if (level) {\n      // Sync barrier state for nested hot teams, not needed for outermost hot\n      // team.\n      for (f = 1; f < new_nproc; ++f) {\n        kmp_info_t *thr = team->t.t_threads[f];\n        int b;\n        kmp_balign_t *balign = thr->th.th_bar;\n        for (b = 0; b < bs_last_barrier; ++b) {\n          balign[b].bb.b_arrived = team->t.t_bar[b].b_arrived;\n          KMP_DEBUG_ASSERT(balign[b].bb.wait_flag != KMP_BARRIER_PARENT_FLAG);\n#if USE_DEBUGGER\n          balign[b].bb.b_worker_arrived = team->t.t_bar[b].b_team_arrived;\n#endif\n        }\n      }\n    }\n#endif // KMP_NESTED_HOT_TEAMS\n\n    /* reallocate space for arguments if necessary */\n    __kmp_alloc_argv_entries(argc, team, TRUE);\n    KMP_CHECK_UPDATE(team->t.t_argc, argc);\n    // The hot team re-uses the previous task team,\n    // if untouched during the previous release->gather phase.\n\n    KF_TRACE(10, (\" hot_team = %p\\n\", team));\n\n#if KMP_DEBUG\n    if (__kmp_tasking_mode != tskm_immediate_exec) {\n      KA_TRACE(20, (\"__kmp_allocate_team: hot team task_team[0] = %p \"\n                    \"task_team[1] = %p after reinit\\n\",\n                    team->t.t_task_team[0], team->t.t_task_team[1]));\n    }\n#endif\n\n#if OMPT_SUPPORT\n    __ompt_team_assign_id(team, ompt_parallel_data);\n#endif\n\n    KMP_MB();\n\n    return team;\n  }\n\n  /* next, let's try to take one from the team pool */\n  KMP_MB();\n  for (team = CCAST(kmp_team_t *, __kmp_team_pool); (team);) {\n    /* TODO: consider resizing undersized teams instead of reaping them, now\n       that we have a resizing mechanism */\n    if (team->t.t_max_nproc >= max_nproc) {\n      /* take this team from the team pool */\n      __kmp_team_pool = team->t.t_next_pool;\n\n      /* setup the team for fresh use */\n      __kmp_initialize_team(team, new_nproc, new_icvs, NULL);\n\n      KA_TRACE(20, (\"__kmp_allocate_team: setting task_team[0] %p and \"\n                    \"task_team[1] %p to NULL\\n\",\n                    &team->t.t_task_team[0], &team->t.t_task_team[1]));\n      team->t.t_task_team[0] = NULL;\n      team->t.t_task_team[1] = NULL;\n\n      /* reallocate space for arguments if necessary */\n      __kmp_alloc_argv_entries(argc, team, TRUE);\n      KMP_CHECK_UPDATE(team->t.t_argc, argc);\n\n      KA_TRACE(\n          20, (\"__kmp_allocate_team: team %d init arrived: join=%u, plain=%u\\n\",\n               team->t.t_id, KMP_INIT_BARRIER_STATE, KMP_INIT_BARRIER_STATE));\n      { // Initialize barrier data.\n        int b;\n        for (b = 0; b < bs_last_barrier; ++b) {\n          team->t.t_bar[b].b_arrived = KMP_INIT_BARRIER_STATE;\n#if USE_DEBUGGER\n          team->t.t_bar[b].b_master_arrived = 0;\n          team->t.t_bar[b].b_team_arrived = 0;\n#endif\n        }\n      }\n\n      team->t.t_proc_bind = new_proc_bind;\n\n      KA_TRACE(20, (\"__kmp_allocate_team: using team from pool %d.\\n\",\n                    team->t.t_id));\n\n#if OMPT_SUPPORT\n      __ompt_team_assign_id(team, ompt_parallel_data);\n#endif\n\n      KMP_MB();\n\n      return team;\n    }\n\n    /* reap team if it is too small, then loop back and check the next one */\n    // not sure if this is wise, but, will be redone during the hot-teams\n    // rewrite.\n    /* TODO: Use technique to find the right size hot-team, don't reap them */\n    team = __kmp_reap_team(team);\n    __kmp_team_pool = team;\n  }\n\n  /* nothing available in the pool, no matter, make a new team! */\n  KMP_MB();\n  team = (kmp_team_t *)__kmp_allocate(sizeof(kmp_team_t));\n\n  /* and set it up */\n  team->t.t_max_nproc = max_nproc;\n  /* NOTE well, for some reason allocating one big buffer and dividing it up\n     seems to really hurt performance a lot on the P4, so, let's not use this */\n  __kmp_allocate_team_arrays(team, max_nproc);\n\n  KA_TRACE(20, (\"__kmp_allocate_team: making a new team\\n\"));\n  __kmp_initialize_team(team, new_nproc, new_icvs, NULL);\n\n  KA_TRACE(20, (\"__kmp_allocate_team: setting task_team[0] %p and task_team[1] \"\n                \"%p to NULL\\n\",\n                &team->t.t_task_team[0], &team->t.t_task_team[1]));\n  team->t.t_task_team[0] = NULL; // to be removed, as __kmp_allocate zeroes\n  // memory, no need to duplicate\n  team->t.t_task_team[1] = NULL; // to be removed, as __kmp_allocate zeroes\n  // memory, no need to duplicate\n\n  if (__kmp_storage_map) {\n    __kmp_print_team_storage_map(\"team\", team, team->t.t_id, new_nproc);\n  }\n\n  /* allocate space for arguments */\n  __kmp_alloc_argv_entries(argc, team, FALSE);\n  team->t.t_argc = argc;\n\n  KA_TRACE(20,\n           (\"__kmp_allocate_team: team %d init arrived: join=%u, plain=%u\\n\",\n            team->t.t_id, KMP_INIT_BARRIER_STATE, KMP_INIT_BARRIER_STATE));\n  { // Initialize barrier data.\n    int b;\n    for (b = 0; b < bs_last_barrier; ++b) {\n      team->t.t_bar[b].b_arrived = KMP_INIT_BARRIER_STATE;\n#if USE_DEBUGGER\n      team->t.t_bar[b].b_master_arrived = 0;\n      team->t.t_bar[b].b_team_arrived = 0;\n#endif\n    }\n  }\n\n  team->t.t_proc_bind = new_proc_bind;\n\n#if OMPT_SUPPORT\n  __ompt_team_assign_id(team, ompt_parallel_data);\n  team->t.ompt_serialized_team_info = NULL;\n#endif\n\n  KMP_MB();\n\n  KA_TRACE(20, (\"__kmp_allocate_team: done creating a new team %d.\\n\",\n                team->t.t_id));\n\n  return team;\n}\n\n/* TODO implement hot-teams at all levels */\n/* TODO implement lazy thread release on demand (disband request) */\n\n/* free the team.  return it to the team pool.  release all the threads\n * associated with it */\nvoid __kmp_free_team(kmp_root_t *root,\n                     kmp_team_t *team USE_NESTED_HOT_ARG(kmp_info_t *master)) {\n  int f;\n  KA_TRACE(20, (\"__kmp_free_team: T#%d freeing team %d\\n\", __kmp_get_gtid(),\n                team->t.t_id));\n\n  /* verify state */\n  KMP_DEBUG_ASSERT(root);\n  KMP_DEBUG_ASSERT(team);\n  KMP_DEBUG_ASSERT(team->t.t_nproc <= team->t.t_max_nproc);\n  KMP_DEBUG_ASSERT(team->t.t_threads);\n\n  int use_hot_team = team == root->r.r_hot_team;\n#if KMP_NESTED_HOT_TEAMS\n  int level;\n  kmp_hot_team_ptr_t *hot_teams;\n  if (master) {\n    level = team->t.t_active_level - 1;\n    if (master->th.th_teams_microtask) { // in teams construct?\n      if (master->th.th_teams_size.nteams > 1) {\n        ++level; // level was not increased in teams construct for\n        // team_of_masters\n      }\n      if (team->t.t_pkfn != (microtask_t)__kmp_teams_master &&\n          master->th.th_teams_level == team->t.t_level) {\n        ++level; // level was not increased in teams construct for\n        // team_of_workers before the parallel\n      } // team->t.t_level will be increased inside parallel\n    }\n    hot_teams = master->th.th_hot_teams;\n    if (level < __kmp_hot_teams_max_level) {\n      KMP_DEBUG_ASSERT(team == hot_teams[level].hot_team);\n      use_hot_team = 1;\n    }\n  }\n#endif // KMP_NESTED_HOT_TEAMS\n\n  /* team is done working */\n  TCW_SYNC_PTR(team->t.t_pkfn,\n               NULL); // Important for Debugging Support Library.\n#if KMP_OS_WINDOWS\n  team->t.t_copyin_counter = 0; // init counter for possible reuse\n#endif\n  // Do not reset pointer to parent team to NULL for hot teams.\n\n  /* if we are non-hot team, release our threads */\n  if (!use_hot_team) {\n    if (__kmp_tasking_mode != tskm_immediate_exec) {\n      // Wait for threads to reach reapable state\n      for (f = 1; f < team->t.t_nproc; ++f) {\n        KMP_DEBUG_ASSERT(team->t.t_threads[f]);\n        kmp_info_t *th = team->t.t_threads[f];\n        volatile kmp_uint32 *state = &th->th.th_reap_state;\n        while (*state != KMP_SAFE_TO_REAP) {\n#if KMP_OS_WINDOWS\n          // On Windows a thread can be killed at any time, check this\n          DWORD ecode;\n          if (!__kmp_is_thread_alive(th, &ecode)) {\n            *state = KMP_SAFE_TO_REAP; // reset the flag for dead thread\n            break;\n          }\n#endif\n          // first check if thread is sleeping\n          kmp_flag_64<> fl(&th->th.th_bar[bs_forkjoin_barrier].bb.b_go, th);\n          if (fl.is_sleeping())\n            fl.resume(__kmp_gtid_from_thread(th));\n          KMP_CPU_PAUSE();\n        }\n      }\n\n      // Delete task teams\n      int tt_idx;\n      for (tt_idx = 0; tt_idx < 2; ++tt_idx) {\n        kmp_task_team_t *task_team = team->t.t_task_team[tt_idx];\n        if (task_team != NULL) {\n          for (f = 0; f < team->t.t_nproc; ++f) { // threads unref task teams\n            KMP_DEBUG_ASSERT(team->t.t_threads[f]);\n            team->t.t_threads[f]->th.th_task_team = NULL;\n          }\n          KA_TRACE(\n              20,\n              (\"__kmp_free_team: T#%d deactivating task_team %p on team %d\\n\",\n               __kmp_get_gtid(), task_team, team->t.t_id));\n#if KMP_NESTED_HOT_TEAMS\n          __kmp_free_task_team(master, task_team);\n#endif\n          team->t.t_task_team[tt_idx] = NULL;\n        }\n      }\n    }\n\n    // Reset pointer to parent team only for non-hot teams.\n    team->t.t_parent = NULL;\n    team->t.t_level = 0;\n    team->t.t_active_level = 0;\n\n    /* free the worker threads */\n    for (f = 1; f < team->t.t_nproc; ++f) {\n      KMP_DEBUG_ASSERT(team->t.t_threads[f]);\n      __kmp_free_thread(team->t.t_threads[f]);\n      team->t.t_threads[f] = NULL;\n    }\n\n    /* put the team back in the team pool */\n    /* TODO limit size of team pool, call reap_team if pool too large */\n    team->t.t_next_pool = CCAST(kmp_team_t *, __kmp_team_pool);\n    __kmp_team_pool = (volatile kmp_team_t *)team;\n  } else { // Check if team was created for primary threads in teams construct\n    // See if first worker is a CG root\n    KMP_DEBUG_ASSERT(team->t.t_threads[1] &&\n                     team->t.t_threads[1]->th.th_cg_roots);\n    if (team->t.t_threads[1]->th.th_cg_roots->cg_root == team->t.t_threads[1]) {\n      // Clean up the CG root nodes on workers so that this team can be re-used\n      for (f = 1; f < team->t.t_nproc; ++f) {\n        kmp_info_t *thr = team->t.t_threads[f];\n        KMP_DEBUG_ASSERT(thr && thr->th.th_cg_roots &&\n                         thr->th.th_cg_roots->cg_root == thr);\n        // Pop current CG root off list\n        kmp_cg_root_t *tmp = thr->th.th_cg_roots;\n        thr->th.th_cg_roots = tmp->up;\n        KA_TRACE(100, (\"__kmp_free_team: Thread %p popping node %p and moving\"\n                       \" up to node %p. cg_nthreads was %d\\n\",\n                       thr, tmp, thr->th.th_cg_roots, tmp->cg_nthreads));\n        int i = tmp->cg_nthreads--;\n        if (i == 1) {\n          __kmp_free(tmp); // free CG if we are the last thread in it\n        }\n        // Restore current task's thread_limit from CG root\n        if (thr->th.th_cg_roots)\n          thr->th.th_current_task->td_icvs.thread_limit =\n              thr->th.th_cg_roots->cg_thread_limit;\n      }\n    }\n  }\n\n  KMP_MB();\n}\n\n/* reap the team.  destroy it, reclaim all its resources and free its memory */\nkmp_team_t *__kmp_reap_team(kmp_team_t *team) {\n  kmp_team_t *next_pool = team->t.t_next_pool;\n\n  KMP_DEBUG_ASSERT(team);\n  KMP_DEBUG_ASSERT(team->t.t_dispatch);\n  KMP_DEBUG_ASSERT(team->t.t_disp_buffer);\n  KMP_DEBUG_ASSERT(team->t.t_threads);\n  KMP_DEBUG_ASSERT(team->t.t_argv);\n\n  /* TODO clean the threads that are a part of this? */\n\n  /* free stuff */\n  __kmp_free_team_arrays(team);\n  if (team->t.t_argv != &team->t.t_inline_argv[0])\n    __kmp_free((void *)team->t.t_argv);\n  __kmp_free(team);\n\n  KMP_MB();\n  return next_pool;\n}\n\n// Free the thread.  Don't reap it, just place it on the pool of available\n// threads.\n//\n// Changes for Quad issue 527845: We need a predictable OMP tid <-> gtid\n// binding for the affinity mechanism to be useful.\n//\n// Now, we always keep the free list (__kmp_thread_pool) sorted by gtid.\n// However, we want to avoid a potential performance problem by always\n// scanning through the list to find the correct point at which to insert\n// the thread (potential N**2 behavior).  To do this we keep track of the\n// last place a thread struct was inserted (__kmp_thread_pool_insert_pt).\n// With single-level parallelism, threads will always be added to the tail\n// of the list, kept track of by __kmp_thread_pool_insert_pt.  With nested\n// parallelism, all bets are off and we may need to scan through the entire\n// free list.\n//\n// This change also has a potentially large performance benefit, for some\n// applications.  Previously, as threads were freed from the hot team, they\n// would be placed back on the free list in inverse order.  If the hot team\n// grew back to it's original size, then the freed thread would be placed\n// back on the hot team in reverse order.  This could cause bad cache\n// locality problems on programs where the size of the hot team regularly\n// grew and shrunk.\n//\n// Now, for single-level parallelism, the OMP tid is always == gtid.\nvoid __kmp_free_thread(kmp_info_t *this_th) {\n  int gtid;\n  kmp_info_t **scan;\n\n  KA_TRACE(20, (\"__kmp_free_thread: T#%d putting T#%d back on free pool.\\n\",\n                __kmp_get_gtid(), this_th->th.th_info.ds.ds_gtid));\n\n  KMP_DEBUG_ASSERT(this_th);\n\n  // When moving thread to pool, switch thread to wait on own b_go flag, and\n  // uninitialized (NULL team).\n  int b;\n  kmp_balign_t *balign = this_th->th.th_bar;\n  for (b = 0; b < bs_last_barrier; ++b) {\n    if (balign[b].bb.wait_flag == KMP_BARRIER_PARENT_FLAG)\n      balign[b].bb.wait_flag = KMP_BARRIER_SWITCH_TO_OWN_FLAG;\n    balign[b].bb.team = NULL;\n    balign[b].bb.leaf_kids = 0;\n  }\n  this_th->th.th_task_state = 0;\n  this_th->th.th_reap_state = KMP_SAFE_TO_REAP;\n\n  /* put thread back on the free pool */\n  TCW_PTR(this_th->th.th_team, NULL);\n  TCW_PTR(this_th->th.th_root, NULL);\n  TCW_PTR(this_th->th.th_dispatch, NULL); /* NOT NEEDED */\n\n  while (this_th->th.th_cg_roots) {\n    this_th->th.th_cg_roots->cg_nthreads--;\n    KA_TRACE(100, (\"__kmp_free_thread: Thread %p decrement cg_nthreads on node\"\n                   \" %p of thread  %p to %d\\n\",\n                   this_th, this_th->th.th_cg_roots,\n                   this_th->th.th_cg_roots->cg_root,\n                   this_th->th.th_cg_roots->cg_nthreads));\n    kmp_cg_root_t *tmp = this_th->th.th_cg_roots;\n    if (tmp->cg_root == this_th) { // Thread is a cg_root\n      KMP_DEBUG_ASSERT(tmp->cg_nthreads == 0);\n      KA_TRACE(\n          5, (\"__kmp_free_thread: Thread %p freeing node %p\\n\", this_th, tmp));\n      this_th->th.th_cg_roots = tmp->up;\n      __kmp_free(tmp);\n    } else { // Worker thread\n      if (tmp->cg_nthreads == 0) { // last thread leaves contention group\n        __kmp_free(tmp);\n      }\n      this_th->th.th_cg_roots = NULL;\n      break;\n    }\n  }\n\n  /* If the implicit task assigned to this thread can be used by other threads\n   * -> multiple threads can share the data and try to free the task at\n   * __kmp_reap_thread at exit. This duplicate use of the task data can happen\n   * with higher probability when hot team is disabled but can occurs even when\n   * the hot team is enabled */\n  __kmp_free_implicit_task(this_th);\n  this_th->th.th_current_task = NULL;\n\n  // If the __kmp_thread_pool_insert_pt is already past the new insert\n  // point, then we need to re-scan the entire list.\n  gtid = this_th->th.th_info.ds.ds_gtid;\n  if (__kmp_thread_pool_insert_pt != NULL) {\n    KMP_DEBUG_ASSERT(__kmp_thread_pool != NULL);\n    if (__kmp_thread_pool_insert_pt->th.th_info.ds.ds_gtid > gtid) {\n      __kmp_thread_pool_insert_pt = NULL;\n    }\n  }\n\n  // Scan down the list to find the place to insert the thread.\n  // scan is the address of a link in the list, possibly the address of\n  // __kmp_thread_pool itself.\n  //\n  // In the absence of nested parallelism, the for loop will have 0 iterations.\n  if (__kmp_thread_pool_insert_pt != NULL) {\n    scan = &(__kmp_thread_pool_insert_pt->th.th_next_pool);\n  } else {\n    scan = CCAST(kmp_info_t **, &__kmp_thread_pool);\n  }\n  for (; (*scan != NULL) && ((*scan)->th.th_info.ds.ds_gtid < gtid);\n       scan = &((*scan)->th.th_next_pool))\n    ;\n\n  // Insert the new element on the list, and set __kmp_thread_pool_insert_pt\n  // to its address.\n  TCW_PTR(this_th->th.th_next_pool, *scan);\n  __kmp_thread_pool_insert_pt = *scan = this_th;\n  KMP_DEBUG_ASSERT((this_th->th.th_next_pool == NULL) ||\n                   (this_th->th.th_info.ds.ds_gtid <\n                    this_th->th.th_next_pool->th.th_info.ds.ds_gtid));\n  TCW_4(this_th->th.th_in_pool, TRUE);\n  __kmp_suspend_initialize_thread(this_th);\n  __kmp_lock_suspend_mx(this_th);\n  if (this_th->th.th_active == TRUE) {\n    KMP_ATOMIC_INC(&__kmp_thread_pool_active_nth);\n    this_th->th.th_active_in_pool = TRUE;\n  }\n#if KMP_DEBUG\n  else {\n    KMP_DEBUG_ASSERT(this_th->th.th_active_in_pool == FALSE);\n  }\n#endif\n  __kmp_unlock_suspend_mx(this_th);\n\n  TCW_4(__kmp_nth, __kmp_nth - 1);\n\n#ifdef KMP_ADJUST_BLOCKTIME\n  /* Adjust blocktime back to user setting or default if necessary */\n  /* Middle initialization might never have occurred                */\n  if (!__kmp_env_blocktime && (__kmp_avail_proc > 0)) {\n    KMP_DEBUG_ASSERT(__kmp_avail_proc > 0);\n    if (__kmp_nth <= __kmp_avail_proc) {\n      __kmp_zero_bt = FALSE;\n    }\n  }\n#endif /* KMP_ADJUST_BLOCKTIME */\n\n  KMP_MB();\n}\n\n/* ------------------------------------------------------------------------ */\n\nvoid *__kmp_launch_thread(kmp_info_t *this_thr) {\n#if OMP_PROFILING_SUPPORT\n  ProfileTraceFile = getenv(\"LIBOMPTARGET_PROFILE\");\n  // TODO: add a configuration option for time granularity\n  if (ProfileTraceFile)\n    llvm::timeTraceProfilerInitialize(500 /* us */, \"libomptarget\");\n#endif\n\n  int gtid = this_thr->th.th_info.ds.ds_gtid;\n  /*    void                 *stack_data;*/\n  kmp_team_t **volatile pteam;\n\n  KMP_MB();\n  KA_TRACE(10, (\"__kmp_launch_thread: T#%d start\\n\", gtid));\n\n  if (__kmp_env_consistency_check) {\n    this_thr->th.th_cons = __kmp_allocate_cons_stack(gtid); // ATT: Memory leak?\n  }\n\n#if OMPT_SUPPORT\n  ompt_data_t *thread_data;\n  if (ompt_enabled.enabled) {\n    thread_data = &(this_thr->th.ompt_thread_info.thread_data);\n    *thread_data = ompt_data_none;\n\n    this_thr->th.ompt_thread_info.state = ompt_state_overhead;\n    this_thr->th.ompt_thread_info.wait_id = 0;\n    this_thr->th.ompt_thread_info.idle_frame = OMPT_GET_FRAME_ADDRESS(0);\n    this_thr->th.ompt_thread_info.parallel_flags = 0;\n    if (ompt_enabled.ompt_callback_thread_begin) {\n      ompt_callbacks.ompt_callback(ompt_callback_thread_begin)(\n          ompt_thread_worker, thread_data);\n    }\n    this_thr->th.ompt_thread_info.state = ompt_state_idle;\n  }\n#endif\n\n  /* This is the place where threads wait for work */\n  while (!TCR_4(__kmp_global.g.g_done)) {\n    KMP_DEBUG_ASSERT(this_thr == __kmp_threads[gtid]);\n    KMP_MB();\n\n    /* wait for work to do */\n    KA_TRACE(20, (\"__kmp_launch_thread: T#%d waiting for work\\n\", gtid));\n\n    /* No tid yet since not part of a team */\n    __kmp_fork_barrier(gtid, KMP_GTID_DNE);\n\n#if OMPT_SUPPORT\n    if (ompt_enabled.enabled) {\n      this_thr->th.ompt_thread_info.state = ompt_state_overhead;\n    }\n#endif\n\n    pteam = &this_thr->th.th_team;\n\n    /* have we been allocated? */\n    if (TCR_SYNC_PTR(*pteam) && !TCR_4(__kmp_global.g.g_done)) {\n      /* we were just woken up, so run our new task */\n      if (TCR_SYNC_PTR((*pteam)->t.t_pkfn) != NULL) {\n        int rc;\n        KA_TRACE(20,\n                 (\"__kmp_launch_thread: T#%d(%d:%d) invoke microtask = %p\\n\",\n                  gtid, (*pteam)->t.t_id, __kmp_tid_from_gtid(gtid),\n                  (*pteam)->t.t_pkfn));\n\n        updateHWFPControl(*pteam);\n\n#if OMPT_SUPPORT\n        if (ompt_enabled.enabled) {\n          this_thr->th.ompt_thread_info.state = ompt_state_work_parallel;\n        }\n#endif\n\n        rc = (*pteam)->t.t_invoke(gtid);\n        KMP_ASSERT(rc);\n\n        KMP_MB();\n        KA_TRACE(20, (\"__kmp_launch_thread: T#%d(%d:%d) done microtask = %p\\n\",\n                      gtid, (*pteam)->t.t_id, __kmp_tid_from_gtid(gtid),\n                      (*pteam)->t.t_pkfn));\n      }\n#if OMPT_SUPPORT\n      if (ompt_enabled.enabled) {\n        /* no frame set while outside task */\n        __ompt_get_task_info_object(0)->frame.exit_frame = ompt_data_none;\n\n        this_thr->th.ompt_thread_info.state = ompt_state_overhead;\n      }\n#endif\n      /* join barrier after parallel region */\n      __kmp_join_barrier(gtid);\n    }\n  }\n  TCR_SYNC_PTR((intptr_t)__kmp_global.g.g_done);\n\n#if OMPT_SUPPORT\n  if (ompt_enabled.ompt_callback_thread_end) {\n    ompt_callbacks.ompt_callback(ompt_callback_thread_end)(thread_data);\n  }\n#endif\n\n  this_thr->th.th_task_team = NULL;\n  /* run the destructors for the threadprivate data for this thread */\n  __kmp_common_destroy_gtid(gtid);\n\n  KA_TRACE(10, (\"__kmp_launch_thread: T#%d done\\n\", gtid));\n  KMP_MB();\n\n#if OMP_PROFILING_SUPPORT\n  llvm::timeTraceProfilerFinishThread();\n#endif\n  return this_thr;\n}\n\n/* ------------------------------------------------------------------------ */\n\nvoid __kmp_internal_end_dest(void *specific_gtid) {\n  // Make sure no significant bits are lost\n  int gtid;\n  __kmp_type_convert((kmp_intptr_t)specific_gtid - 1, &gtid);\n\n  KA_TRACE(30, (\"__kmp_internal_end_dest: T#%d\\n\", gtid));\n  /* NOTE: the gtid is stored as gitd+1 in the thread-local-storage\n   * this is because 0 is reserved for the nothing-stored case */\n\n  __kmp_internal_end_thread(gtid);\n}\n\n#if KMP_OS_UNIX && KMP_DYNAMIC_LIB\n\n__attribute__((destructor)) void __kmp_internal_end_dtor(void) {\n  __kmp_internal_end_atexit();\n}\n\n#endif\n\n/* [Windows] josh: when the atexit handler is called, there may still be more\n   than one thread alive */\nvoid __kmp_internal_end_atexit(void) {\n  KA_TRACE(30, (\"__kmp_internal_end_atexit\\n\"));\n  /* [Windows]\n     josh: ideally, we want to completely shutdown the library in this atexit\n     handler, but stat code that depends on thread specific data for gtid fails\n     because that data becomes unavailable at some point during the shutdown, so\n     we call __kmp_internal_end_thread instead. We should eventually remove the\n     dependency on __kmp_get_specific_gtid in the stat code and use\n     __kmp_internal_end_library to cleanly shutdown the library.\n\n     // TODO: Can some of this comment about GVS be removed?\n     I suspect that the offending stat code is executed when the calling thread\n     tries to clean up a dead root thread's data structures, resulting in GVS\n     code trying to close the GVS structures for that thread, but since the stat\n     code uses __kmp_get_specific_gtid to get the gtid with the assumption that\n     the calling thread is cleaning up itself instead of another thread, it get\n     confused. This happens because allowing a thread to unregister and cleanup\n     another thread is a recent modification for addressing an issue.\n     Based on the current design (20050722), a thread may end up\n     trying to unregister another thread only if thread death does not trigger\n     the calling of __kmp_internal_end_thread.  For Linux* OS, there is the\n     thread specific data destructor function to detect thread death. For\n     Windows dynamic, there is DllMain(THREAD_DETACH). For Windows static, there\n     is nothing.  Thus, the workaround is applicable only for Windows static\n     stat library. */\n  __kmp_internal_end_library(-1);\n#if KMP_OS_WINDOWS\n  __kmp_close_console();\n#endif\n}\n\nstatic void __kmp_reap_thread(kmp_info_t *thread, int is_root) {\n  // It is assumed __kmp_forkjoin_lock is acquired.\n\n  int gtid;\n\n  KMP_DEBUG_ASSERT(thread != NULL);\n\n  gtid = thread->th.th_info.ds.ds_gtid;\n\n  if (!is_root) {\n    if (__kmp_dflt_blocktime != KMP_MAX_BLOCKTIME) {\n      /* Assume the threads are at the fork barrier here */\n      KA_TRACE(\n          20, (\"__kmp_reap_thread: releasing T#%d from fork barrier for reap\\n\",\n               gtid));\n      /* Need release fence here to prevent seg faults for tree forkjoin barrier\n       * (GEH) */\n      ANNOTATE_HAPPENS_BEFORE(thread);\n      kmp_flag_64<> flag(&thread->th.th_bar[bs_forkjoin_barrier].bb.b_go,\n                         thread);\n      __kmp_release_64(&flag);\n    }\n\n    // Terminate OS thread.\n    __kmp_reap_worker(thread);\n\n    // The thread was killed asynchronously.  If it was actively\n    // spinning in the thread pool, decrement the global count.\n    //\n    // There is a small timing hole here - if the worker thread was just waking\n    // up after sleeping in the pool, had reset it's th_active_in_pool flag but\n    // not decremented the global counter __kmp_thread_pool_active_nth yet, then\n    // the global counter might not get updated.\n    //\n    // Currently, this can only happen as the library is unloaded,\n    // so there are no harmful side effects.\n    if (thread->th.th_active_in_pool) {\n      thread->th.th_active_in_pool = FALSE;\n      KMP_ATOMIC_DEC(&__kmp_thread_pool_active_nth);\n      KMP_DEBUG_ASSERT(__kmp_thread_pool_active_nth >= 0);\n    }\n  }\n\n  __kmp_free_implicit_task(thread);\n\n// Free the fast memory for tasking\n#if USE_FAST_MEMORY\n  __kmp_free_fast_memory(thread);\n#endif /* USE_FAST_MEMORY */\n\n  __kmp_suspend_uninitialize_thread(thread);\n\n  KMP_DEBUG_ASSERT(__kmp_threads[gtid] == thread);\n  TCW_SYNC_PTR(__kmp_threads[gtid], NULL);\n\n  --__kmp_all_nth;\n  // __kmp_nth was decremented when thread is added to the pool.\n\n#ifdef KMP_ADJUST_BLOCKTIME\n  /* Adjust blocktime back to user setting or default if necessary */\n  /* Middle initialization might never have occurred                */\n  if (!__kmp_env_blocktime && (__kmp_avail_proc > 0)) {\n    KMP_DEBUG_ASSERT(__kmp_avail_proc > 0);\n    if (__kmp_nth <= __kmp_avail_proc) {\n      __kmp_zero_bt = FALSE;\n    }\n  }\n#endif /* KMP_ADJUST_BLOCKTIME */\n\n  /* free the memory being used */\n  if (__kmp_env_consistency_check) {\n    if (thread->th.th_cons) {\n      __kmp_free_cons_stack(thread->th.th_cons);\n      thread->th.th_cons = NULL;\n    }\n  }\n\n  if (thread->th.th_pri_common != NULL) {\n    __kmp_free(thread->th.th_pri_common);\n    thread->th.th_pri_common = NULL;\n  }\n\n  if (thread->th.th_task_state_memo_stack != NULL) {\n    __kmp_free(thread->th.th_task_state_memo_stack);\n    thread->th.th_task_state_memo_stack = NULL;\n  }\n\n#if KMP_USE_BGET\n  if (thread->th.th_local.bget_data != NULL) {\n    __kmp_finalize_bget(thread);\n  }\n#endif\n\n#if KMP_AFFINITY_SUPPORTED\n  if (thread->th.th_affin_mask != NULL) {\n    KMP_CPU_FREE(thread->th.th_affin_mask);\n    thread->th.th_affin_mask = NULL;\n  }\n#endif /* KMP_AFFINITY_SUPPORTED */\n\n#if KMP_USE_HIER_SCHED\n  if (thread->th.th_hier_bar_data != NULL) {\n    __kmp_free(thread->th.th_hier_bar_data);\n    thread->th.th_hier_bar_data = NULL;\n  }\n#endif\n\n  __kmp_reap_team(thread->th.th_serial_team);\n  thread->th.th_serial_team = NULL;\n  __kmp_free(thread);\n\n  KMP_MB();\n\n} // __kmp_reap_thread\n\nstatic void __kmp_internal_end(void) {\n  int i;\n\n  /* First, unregister the library */\n  __kmp_unregister_library();\n\n#if KMP_OS_WINDOWS\n  /* In Win static library, we can't tell when a root actually dies, so we\n     reclaim the data structures for any root threads that have died but not\n     unregistered themselves, in order to shut down cleanly.\n     In Win dynamic library we also can't tell when a thread dies.  */\n  __kmp_reclaim_dead_roots(); // AC: moved here to always clean resources of\n// dead roots\n#endif\n\n  for (i = 0; i < __kmp_threads_capacity; i++)\n    if (__kmp_root[i])\n      if (__kmp_root[i]->r.r_active)\n        break;\n  KMP_MB(); /* Flush all pending memory write invalidates.  */\n  TCW_SYNC_4(__kmp_global.g.g_done, TRUE);\n\n  if (i < __kmp_threads_capacity) {\n#if KMP_USE_MONITOR\n    // 2009-09-08 (lev): Other alive roots found. Why do we kill the monitor??\n    KMP_MB(); /* Flush all pending memory write invalidates.  */\n\n    // Need to check that monitor was initialized before reaping it. If we are\n    // called form __kmp_atfork_child (which sets __kmp_init_parallel = 0), then\n    // __kmp_monitor will appear to contain valid data, but it is only valid in\n    // the parent process, not the child.\n    // New behavior (201008): instead of keying off of the flag\n    // __kmp_init_parallel, the monitor thread creation is keyed off\n    // of the new flag __kmp_init_monitor.\n    __kmp_acquire_bootstrap_lock(&__kmp_monitor_lock);\n    if (TCR_4(__kmp_init_monitor)) {\n      __kmp_reap_monitor(&__kmp_monitor);\n      TCW_4(__kmp_init_monitor, 0);\n    }\n    __kmp_release_bootstrap_lock(&__kmp_monitor_lock);\n    KA_TRACE(10, (\"__kmp_internal_end: monitor reaped\\n\"));\n#endif // KMP_USE_MONITOR\n  } else {\n/* TODO move this to cleanup code */\n#ifdef KMP_DEBUG\n    /* make sure that everything has properly ended */\n    for (i = 0; i < __kmp_threads_capacity; i++) {\n      if (__kmp_root[i]) {\n        //                    KMP_ASSERT( ! KMP_UBER_GTID( i ) );         // AC:\n        //                    there can be uber threads alive here\n        KMP_ASSERT(!__kmp_root[i]->r.r_active); // TODO: can they be active?\n      }\n    }\n#endif\n\n    KMP_MB();\n\n    // Reap the worker threads.\n    // This is valid for now, but be careful if threads are reaped sooner.\n    while (__kmp_thread_pool != NULL) { // Loop thru all the thread in the pool.\n      // Get the next thread from the pool.\n      kmp_info_t *thread = CCAST(kmp_info_t *, __kmp_thread_pool);\n      __kmp_thread_pool = thread->th.th_next_pool;\n      // Reap it.\n      KMP_DEBUG_ASSERT(thread->th.th_reap_state == KMP_SAFE_TO_REAP);\n      thread->th.th_next_pool = NULL;\n      thread->th.th_in_pool = FALSE;\n      __kmp_reap_thread(thread, 0);\n    }\n    __kmp_thread_pool_insert_pt = NULL;\n\n    // Reap teams.\n    while (__kmp_team_pool != NULL) { // Loop thru all the teams in the pool.\n      // Get the next team from the pool.\n      kmp_team_t *team = CCAST(kmp_team_t *, __kmp_team_pool);\n      __kmp_team_pool = team->t.t_next_pool;\n      // Reap it.\n      team->t.t_next_pool = NULL;\n      __kmp_reap_team(team);\n    }\n\n    __kmp_reap_task_teams();\n\n#if KMP_OS_UNIX\n    // Threads that are not reaped should not access any resources since they\n    // are going to be deallocated soon, so the shutdown sequence should wait\n    // until all threads either exit the final spin-waiting loop or begin\n    // sleeping after the given blocktime.\n    for (i = 0; i < __kmp_threads_capacity; i++) {\n      kmp_info_t *thr = __kmp_threads[i];\n      while (thr && KMP_ATOMIC_LD_ACQ(&thr->th.th_blocking))\n        KMP_CPU_PAUSE();\n    }\n#endif\n\n    for (i = 0; i < __kmp_threads_capacity; ++i) {\n      // TBD: Add some checking...\n      // Something like KMP_DEBUG_ASSERT( __kmp_thread[ i ] == NULL );\n    }\n\n    /* Make sure all threadprivate destructors get run by joining with all\n       worker threads before resetting this flag */\n    TCW_SYNC_4(__kmp_init_common, FALSE);\n\n    KA_TRACE(10, (\"__kmp_internal_end: all workers reaped\\n\"));\n    KMP_MB();\n\n#if KMP_USE_MONITOR\n    // See note above: One of the possible fixes for CQ138434 / CQ140126\n    //\n    // FIXME: push both code fragments down and CSE them?\n    // push them into __kmp_cleanup() ?\n    __kmp_acquire_bootstrap_lock(&__kmp_monitor_lock);\n    if (TCR_4(__kmp_init_monitor)) {\n      __kmp_reap_monitor(&__kmp_monitor);\n      TCW_4(__kmp_init_monitor, 0);\n    }\n    __kmp_release_bootstrap_lock(&__kmp_monitor_lock);\n    KA_TRACE(10, (\"__kmp_internal_end: monitor reaped\\n\"));\n#endif\n  } /* else !__kmp_global.t_active */\n  TCW_4(__kmp_init_gtid, FALSE);\n  KMP_MB(); /* Flush all pending memory write invalidates.  */\n\n  __kmp_cleanup();\n#if OMPT_SUPPORT\n  ompt_fini();\n#endif\n}\n\nvoid __kmp_internal_end_library(int gtid_req) {\n  /* if we have already cleaned up, don't try again, it wouldn't be pretty */\n  /* this shouldn't be a race condition because __kmp_internal_end() is the\n     only place to clear __kmp_serial_init */\n  /* we'll check this later too, after we get the lock */\n  // 2009-09-06: We do not set g_abort without setting g_done. This check looks\n  // redundant, because the next check will work in any case.\n  if (__kmp_global.g.g_abort) {\n    KA_TRACE(11, (\"__kmp_internal_end_library: abort, exiting\\n\"));\n    /* TODO abort? */\n    return;\n  }\n  if (TCR_4(__kmp_global.g.g_done) || !__kmp_init_serial) {\n    KA_TRACE(10, (\"__kmp_internal_end_library: already finished\\n\"));\n    return;\n  }\n\n  KMP_MB(); /* Flush all pending memory write invalidates.  */\n  /* find out who we are and what we should do */\n  {\n    int gtid = (gtid_req >= 0) ? gtid_req : __kmp_gtid_get_specific();\n    KA_TRACE(\n        10, (\"__kmp_internal_end_library: enter T#%d  (%d)\\n\", gtid, gtid_req));\n    if (gtid == KMP_GTID_SHUTDOWN) {\n      KA_TRACE(10, (\"__kmp_internal_end_library: !__kmp_init_runtime, system \"\n                    \"already shutdown\\n\"));\n      return;\n    } else if (gtid == KMP_GTID_MONITOR) {\n      KA_TRACE(10, (\"__kmp_internal_end_library: monitor thread, gtid not \"\n                    \"registered, or system shutdown\\n\"));\n      return;\n    } else if (gtid == KMP_GTID_DNE) {\n      KA_TRACE(10, (\"__kmp_internal_end_library: gtid not registered or system \"\n                    \"shutdown\\n\"));\n      /* we don't know who we are, but we may still shutdown the library */\n    } else if (KMP_UBER_GTID(gtid)) {\n      /* unregister ourselves as an uber thread.  gtid is no longer valid */\n      if (__kmp_root[gtid]->r.r_active) {\n        __kmp_global.g.g_abort = -1;\n        TCW_SYNC_4(__kmp_global.g.g_done, TRUE);\n        __kmp_unregister_library();\n        KA_TRACE(10,\n                 (\"__kmp_internal_end_library: root still active, abort T#%d\\n\",\n                  gtid));\n        return;\n      } else {\n        KA_TRACE(\n            10,\n            (\"__kmp_internal_end_library: unregistering sibling T#%d\\n\", gtid));\n        __kmp_unregister_root_current_thread(gtid);\n      }\n    } else {\n/* worker threads may call this function through the atexit handler, if they\n * call exit() */\n/* For now, skip the usual subsequent processing and just dump the debug buffer.\n   TODO: do a thorough shutdown instead */\n#ifdef DUMP_DEBUG_ON_EXIT\n      if (__kmp_debug_buf)\n        __kmp_dump_debug_buffer();\n#endif\n      // added unregister library call here when we switch to shm linux\n      // if we don't, it will leave lots of files in /dev/shm\n      // cleanup shared memory file before exiting.\n      __kmp_unregister_library();\n      return;\n    }\n  }\n  /* synchronize the termination process */\n  __kmp_acquire_bootstrap_lock(&__kmp_initz_lock);\n\n  /* have we already finished */\n  if (__kmp_global.g.g_abort) {\n    KA_TRACE(10, (\"__kmp_internal_end_library: abort, exiting\\n\"));\n    /* TODO abort? */\n    __kmp_release_bootstrap_lock(&__kmp_initz_lock);\n    return;\n  }\n  if (TCR_4(__kmp_global.g.g_done) || !__kmp_init_serial) {\n    __kmp_release_bootstrap_lock(&__kmp_initz_lock);\n    return;\n  }\n\n  /* We need this lock to enforce mutex between this reading of\n     __kmp_threads_capacity and the writing by __kmp_register_root.\n     Alternatively, we can use a counter of roots that is atomically updated by\n     __kmp_get_global_thread_id_reg, __kmp_do_serial_initialize and\n     __kmp_internal_end_*.  */\n  __kmp_acquire_bootstrap_lock(&__kmp_forkjoin_lock);\n\n  /* now we can safely conduct the actual termination */\n  __kmp_internal_end();\n\n  __kmp_release_bootstrap_lock(&__kmp_forkjoin_lock);\n  __kmp_release_bootstrap_lock(&__kmp_initz_lock);\n\n  KA_TRACE(10, (\"__kmp_internal_end_library: exit\\n\"));\n\n#ifdef DUMP_DEBUG_ON_EXIT\n  if (__kmp_debug_buf)\n    __kmp_dump_debug_buffer();\n#endif\n\n#if KMP_OS_WINDOWS\n  __kmp_close_console();\n#endif\n\n  __kmp_fini_allocator();\n\n} // __kmp_internal_end_library\n\nvoid __kmp_internal_end_thread(int gtid_req) {\n  int i;\n\n  /* if we have already cleaned up, don't try again, it wouldn't be pretty */\n  /* this shouldn't be a race condition because __kmp_internal_end() is the\n   * only place to clear __kmp_serial_init */\n  /* we'll check this later too, after we get the lock */\n  // 2009-09-06: We do not set g_abort without setting g_done. This check looks\n  // redundant, because the next check will work in any case.\n  if (__kmp_global.g.g_abort) {\n    KA_TRACE(11, (\"__kmp_internal_end_thread: abort, exiting\\n\"));\n    /* TODO abort? */\n    return;\n  }\n  if (TCR_4(__kmp_global.g.g_done) || !__kmp_init_serial) {\n    KA_TRACE(10, (\"__kmp_internal_end_thread: already finished\\n\"));\n    return;\n  }\n\n  // If hidden helper team has been initialized, we need to deinit it\n  if (TCR_4(__kmp_init_hidden_helper)) {\n    TCW_SYNC_4(__kmp_hidden_helper_team_done, TRUE);\n    // First release the main thread to let it continue its work\n    __kmp_hidden_helper_main_thread_release();\n    // Wait until the hidden helper team has been destroyed\n    __kmp_hidden_helper_threads_deinitz_wait();\n  }\n\n  KMP_MB(); /* Flush all pending memory write invalidates.  */\n\n  /* find out who we are and what we should do */\n  {\n    int gtid = (gtid_req >= 0) ? gtid_req : __kmp_gtid_get_specific();\n    KA_TRACE(10,\n             (\"__kmp_internal_end_thread: enter T#%d  (%d)\\n\", gtid, gtid_req));\n    if (gtid == KMP_GTID_SHUTDOWN) {\n      KA_TRACE(10, (\"__kmp_internal_end_thread: !__kmp_init_runtime, system \"\n                    \"already shutdown\\n\"));\n      return;\n    } else if (gtid == KMP_GTID_MONITOR) {\n      KA_TRACE(10, (\"__kmp_internal_end_thread: monitor thread, gtid not \"\n                    \"registered, or system shutdown\\n\"));\n      return;\n    } else if (gtid == KMP_GTID_DNE) {\n      KA_TRACE(10, (\"__kmp_internal_end_thread: gtid not registered or system \"\n                    \"shutdown\\n\"));\n      return;\n      /* we don't know who we are */\n    } else if (KMP_UBER_GTID(gtid)) {\n      /* unregister ourselves as an uber thread.  gtid is no longer valid */\n      if (__kmp_root[gtid]->r.r_active) {\n        __kmp_global.g.g_abort = -1;\n        TCW_SYNC_4(__kmp_global.g.g_done, TRUE);\n        KA_TRACE(10,\n                 (\"__kmp_internal_end_thread: root still active, abort T#%d\\n\",\n                  gtid));\n        return;\n      } else {\n        KA_TRACE(10, (\"__kmp_internal_end_thread: unregistering sibling T#%d\\n\",\n                      gtid));\n        __kmp_unregister_root_current_thread(gtid);\n      }\n    } else {\n      /* just a worker thread, let's leave */\n      KA_TRACE(10, (\"__kmp_internal_end_thread: worker thread T#%d\\n\", gtid));\n\n      if (gtid >= 0) {\n        __kmp_threads[gtid]->th.th_task_team = NULL;\n      }\n\n      KA_TRACE(10,\n               (\"__kmp_internal_end_thread: worker thread done, exiting T#%d\\n\",\n                gtid));\n      return;\n    }\n  }\n#if KMP_DYNAMIC_LIB\n  if (__kmp_pause_status != kmp_hard_paused)\n  // AC: lets not shutdown the dynamic library at the exit of uber thread,\n  // because we will better shutdown later in the library destructor.\n  {\n    KA_TRACE(10, (\"__kmp_internal_end_thread: exiting T#%d\\n\", gtid_req));\n    return;\n  }\n#endif\n  /* synchronize the termination process */\n  __kmp_acquire_bootstrap_lock(&__kmp_initz_lock);\n\n  /* have we already finished */\n  if (__kmp_global.g.g_abort) {\n    KA_TRACE(10, (\"__kmp_internal_end_thread: abort, exiting\\n\"));\n    /* TODO abort? */\n    __kmp_release_bootstrap_lock(&__kmp_initz_lock);\n    return;\n  }\n  if (TCR_4(__kmp_global.g.g_done) || !__kmp_init_serial) {\n    __kmp_release_bootstrap_lock(&__kmp_initz_lock);\n    return;\n  }\n\n  /* We need this lock to enforce mutex between this reading of\n     __kmp_threads_capacity and the writing by __kmp_register_root.\n     Alternatively, we can use a counter of roots that is atomically updated by\n     __kmp_get_global_thread_id_reg, __kmp_do_serial_initialize and\n     __kmp_internal_end_*.  */\n\n  /* should we finish the run-time?  are all siblings done? */\n  __kmp_acquire_bootstrap_lock(&__kmp_forkjoin_lock);\n\n  for (i = 0; i < __kmp_threads_capacity; ++i) {\n    if (KMP_UBER_GTID(i)) {\n      KA_TRACE(\n          10,\n          (\"__kmp_internal_end_thread: remaining sibling task: gtid==%d\\n\", i));\n      __kmp_release_bootstrap_lock(&__kmp_forkjoin_lock);\n      __kmp_release_bootstrap_lock(&__kmp_initz_lock);\n      return;\n    }\n  }\n\n  /* now we can safely conduct the actual termination */\n\n  __kmp_internal_end();\n\n  __kmp_release_bootstrap_lock(&__kmp_forkjoin_lock);\n  __kmp_release_bootstrap_lock(&__kmp_initz_lock);\n\n  KA_TRACE(10, (\"__kmp_internal_end_thread: exit T#%d\\n\", gtid_req));\n\n#ifdef DUMP_DEBUG_ON_EXIT\n  if (__kmp_debug_buf)\n    __kmp_dump_debug_buffer();\n#endif\n} // __kmp_internal_end_thread\n\n// -----------------------------------------------------------------------------\n// Library registration stuff.\n\nstatic long __kmp_registration_flag = 0;\n// Random value used to indicate library initialization.\nstatic char *__kmp_registration_str = NULL;\n// Value to be saved in env var __KMP_REGISTERED_LIB_<pid>.\n\nstatic inline char *__kmp_reg_status_name() {\n/* On RHEL 3u5 if linked statically, getpid() returns different values in\n   each thread. If registration and unregistration go in different threads\n   (omp_misc_other_root_exit.cpp test case), the name of registered_lib_env\n   env var can not be found, because the name will contain different pid. */\n// macOS* complains about name being too long with additional getuid()\n#if KMP_OS_UNIX && !KMP_OS_DARWIN && KMP_DYNAMIC_LIB\n  return __kmp_str_format(\"__KMP_REGISTERED_LIB_%d_%d\", (int)getpid(),\n                          (int)getuid());\n#else\n  return __kmp_str_format(\"__KMP_REGISTERED_LIB_%d\", (int)getpid());\n#endif\n} // __kmp_reg_status_get\n\nvoid __kmp_register_library_startup(void) {\n\n  char *name = __kmp_reg_status_name(); // Name of the environment variable.\n  int done = 0;\n  union {\n    double dtime;\n    long ltime;\n  } time;\n#if KMP_ARCH_X86 || KMP_ARCH_X86_64\n  __kmp_initialize_system_tick();\n#endif\n  __kmp_read_system_time(&time.dtime);\n  __kmp_registration_flag = 0xCAFE0000L | (time.ltime & 0x0000FFFFL);\n  __kmp_registration_str =\n      __kmp_str_format(\"%p-%lx-%s\", &__kmp_registration_flag,\n                       __kmp_registration_flag, KMP_LIBRARY_FILE);\n\n  KA_TRACE(50, (\"__kmp_register_library_startup: %s=\\\"%s\\\"\\n\", name,\n                __kmp_registration_str));\n\n  while (!done) {\n\n    char *value = NULL; // Actual value of the environment variable.\n\n#if KMP_OS_UNIX && KMP_DYNAMIC_LIB // shared memory is with dynamic library\n    char *shm_name = __kmp_str_format(\"/%s\", name);\n    int shm_preexist = 0;\n    char *data1;\n    int fd1 = shm_open(shm_name, O_CREAT | O_EXCL | O_RDWR, 0666);\n    if ((fd1 == -1) && (errno == EEXIST)) {\n      // file didn't open because it already exists.\n      // try opening existing file\n      fd1 = shm_open(shm_name, O_RDWR, 0666);\n      if (fd1 == -1) { // file didn't open\n        // error out here\n        __kmp_fatal(KMP_MSG(FunctionError, \"Can't open SHM\"), KMP_ERR(0),\n                    __kmp_msg_null);\n      } else {\n        // able to open existing file\n        shm_preexist = 1;\n      }\n    } else if (fd1 == -1) { // SHM didn't open; it was due to error other than\n      // already exists.\n      // error out here.\n      __kmp_fatal(KMP_MSG(FunctionError, \"Can't open SHM2\"), KMP_ERR(errno),\n                  __kmp_msg_null);\n    }\n    if (shm_preexist == 0) {\n      // we created SHM now set size\n      if (ftruncate(fd1, SHM_SIZE) == -1) {\n        // error occured setting size;\n        __kmp_fatal(KMP_MSG(FunctionError, \"Can't set size of SHM\"),\n                    KMP_ERR(errno), __kmp_msg_null);\n      }\n    }\n    data1 =\n        (char *)mmap(0, SHM_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd1, 0);\n    if (data1 == MAP_FAILED) {\n      // failed to map shared memory\n      __kmp_fatal(KMP_MSG(FunctionError, \"Can't map SHM\"), KMP_ERR(errno),\n                  __kmp_msg_null);\n    }\n    if (shm_preexist == 0) { // set data to SHM, set value\n      KMP_STRCPY_S(data1, SHM_SIZE, __kmp_registration_str);\n    }\n    // Read value from either what we just wrote or existing file.\n    value = __kmp_str_format(\"%s\", data1); // read value from SHM\n    munmap(data1, SHM_SIZE);\n    close(fd1);\n#else // Windows and unix with static library\n    // Set environment variable, but do not overwrite if it is exist.\n    __kmp_env_set(name, __kmp_registration_str, 0);\n    // read value to see if it got set\n    value = __kmp_env_get(name);\n#endif\n\n    if (value != NULL && strcmp(value, __kmp_registration_str) == 0) {\n      done = 1; // Ok, environment variable set successfully, exit the loop.\n    } else {\n      // Oops. Write failed. Another copy of OpenMP RTL is in memory.\n      // Check whether it alive or dead.\n      int neighbor = 0; // 0 -- unknown status, 1 -- alive, 2 -- dead.\n      char *tail = value;\n      char *flag_addr_str = NULL;\n      char *flag_val_str = NULL;\n      char const *file_name = NULL;\n      __kmp_str_split(tail, '-', &flag_addr_str, &tail);\n      __kmp_str_split(tail, '-', &flag_val_str, &tail);\n      file_name = tail;\n      if (tail != NULL) {\n        long *flag_addr = 0;\n        unsigned long flag_val = 0;\n        KMP_SSCANF(flag_addr_str, \"%p\", RCAST(void **, &flag_addr));\n        KMP_SSCANF(flag_val_str, \"%lx\", &flag_val);\n        if (flag_addr != 0 && flag_val != 0 && strcmp(file_name, \"\") != 0) {\n          // First, check whether environment-encoded address is mapped into\n          // addr space.\n          // If so, dereference it to see if it still has the right value.\n          if (__kmp_is_address_mapped(flag_addr) && *flag_addr == flag_val) {\n            neighbor = 1;\n          } else {\n            // If not, then we know the other copy of the library is no longer\n            // running.\n            neighbor = 2;\n          }\n        }\n      }\n      switch (neighbor) {\n      case 0: // Cannot parse environment variable -- neighbor status unknown.\n        // Assume it is the incompatible format of future version of the\n        // library. Assume the other library is alive.\n        // WARN( ... ); // TODO: Issue a warning.\n        file_name = \"unknown library\";\n        KMP_FALLTHROUGH();\n      // Attention! Falling to the next case. That's intentional.\n      case 1: { // Neighbor is alive.\n        // Check it is allowed.\n        char *duplicate_ok = __kmp_env_get(\"KMP_DUPLICATE_LIB_OK\");\n        if (!__kmp_str_match_true(duplicate_ok)) {\n          // That's not allowed. Issue fatal error.\n          __kmp_fatal(KMP_MSG(DuplicateLibrary, KMP_LIBRARY_FILE, file_name),\n                      KMP_HNT(DuplicateLibrary), __kmp_msg_null);\n        }\n        KMP_INTERNAL_FREE(duplicate_ok);\n        __kmp_duplicate_library_ok = 1;\n        done = 1; // Exit the loop.\n      } break;\n      case 2: { // Neighbor is dead.\n\n#if KMP_OS_UNIX && KMP_DYNAMIC_LIB // shared memory is with dynamic library\n        // close shared memory.\n        shm_unlink(shm_name); // this removes file in /dev/shm\n#else\n        // Clear the variable and try to register library again.\n        __kmp_env_unset(name);\n#endif\n      } break;\n      default: {\n        KMP_DEBUG_ASSERT(0);\n      } break;\n      }\n    }\n    KMP_INTERNAL_FREE((void *)value);\n#if KMP_OS_UNIX && KMP_DYNAMIC_LIB // shared memory is with dynamic library\n    KMP_INTERNAL_FREE((void *)shm_name);\n#endif\n  } // while\n  KMP_INTERNAL_FREE((void *)name);\n\n} // func __kmp_register_library_startup\n\nvoid __kmp_unregister_library(void) {\n\n  char *name = __kmp_reg_status_name();\n  char *value = NULL;\n\n#if KMP_OS_UNIX && KMP_DYNAMIC_LIB // shared memory is with dynamic library\n  char *shm_name = __kmp_str_format(\"/%s\", name);\n  int fd1 = shm_open(shm_name, O_RDONLY, 0666);\n  if (fd1 == -1) {\n    // file did not open. return.\n    return;\n  }\n  char *data1 = (char *)mmap(0, SHM_SIZE, PROT_READ, MAP_SHARED, fd1, 0);\n  if (data1 != MAP_FAILED) {\n    value = __kmp_str_format(\"%s\", data1); // read value from SHM\n    munmap(data1, SHM_SIZE);\n  }\n  close(fd1);\n#else\n  value = __kmp_env_get(name);\n#endif\n\n  KMP_DEBUG_ASSERT(__kmp_registration_flag != 0);\n  KMP_DEBUG_ASSERT(__kmp_registration_str != NULL);\n  if (value != NULL && strcmp(value, __kmp_registration_str) == 0) {\n//  Ok, this is our variable. Delete it.\n#if KMP_OS_UNIX && KMP_DYNAMIC_LIB // shared memory is with dynamic library\n    shm_unlink(shm_name); // this removes file in /dev/shm\n#else\n    __kmp_env_unset(name);\n#endif\n  }\n\n#if KMP_OS_UNIX && KMP_DYNAMIC_LIB // shared memory is with dynamic library\n  KMP_INTERNAL_FREE(shm_name);\n#endif\n\n  KMP_INTERNAL_FREE(__kmp_registration_str);\n  KMP_INTERNAL_FREE(value);\n  KMP_INTERNAL_FREE(name);\n\n  __kmp_registration_flag = 0;\n  __kmp_registration_str = NULL;\n\n} // __kmp_unregister_library\n\n// End of Library registration stuff.\n// -----------------------------------------------------------------------------\n\n#if KMP_MIC_SUPPORTED\n\nstatic void __kmp_check_mic_type() {\n  kmp_cpuid_t cpuid_state = {0};\n  kmp_cpuid_t *cs_p = &cpuid_state;\n  __kmp_x86_cpuid(1, 0, cs_p);\n  // We don't support mic1 at the moment\n  if ((cs_p->eax & 0xff0) == 0xB10) {\n    __kmp_mic_type = mic2;\n  } else if ((cs_p->eax & 0xf0ff0) == 0x50670) {\n    __kmp_mic_type = mic3;\n  } else {\n    __kmp_mic_type = non_mic;\n  }\n}\n\n#endif /* KMP_MIC_SUPPORTED */\n\n#if KMP_HAVE_UMWAIT\nstatic void __kmp_user_level_mwait_init() {\n  struct kmp_cpuid buf;\n  __kmp_x86_cpuid(7, 0, &buf);\n  __kmp_umwait_enabled = ((buf.ecx >> 5) & 1) && __kmp_user_level_mwait;\n  KF_TRACE(30, (\"__kmp_user_level_mwait_init: __kmp_umwait_enabled = %d\\n\",\n                __kmp_umwait_enabled));\n}\n#elif KMP_HAVE_MWAIT\n#ifndef AT_INTELPHIUSERMWAIT\n// Spurious, non-existent value that should always fail to return anything.\n// Will be replaced with the correct value when we know that.\n#define AT_INTELPHIUSERMWAIT 10000\n#endif\n// getauxval() function is available in RHEL7 and SLES12. If a system with an\n// earlier OS is used to build the RTL, we'll use the following internal\n// function when the entry is not found.\nunsigned long getauxval(unsigned long) KMP_WEAK_ATTRIBUTE_EXTERNAL;\nunsigned long getauxval(unsigned long) { return 0; }\n\nstatic void __kmp_user_level_mwait_init() {\n  // When getauxval() and correct value of AT_INTELPHIUSERMWAIT are available\n  // use them to find if the user-level mwait is enabled. Otherwise, forcibly\n  // set __kmp_mwait_enabled=TRUE on Intel MIC if the environment variable\n  // KMP_USER_LEVEL_MWAIT was set to TRUE.\n  if (__kmp_mic_type == mic3) {\n    unsigned long res = getauxval(AT_INTELPHIUSERMWAIT);\n    if ((res & 0x1) || __kmp_user_level_mwait) {\n      __kmp_mwait_enabled = TRUE;\n      if (__kmp_user_level_mwait) {\n        KMP_INFORM(EnvMwaitWarn);\n      }\n    } else {\n      __kmp_mwait_enabled = FALSE;\n    }\n  }\n  KF_TRACE(30, (\"__kmp_user_level_mwait_init: __kmp_mic_type = %d, \"\n                \"__kmp_mwait_enabled = %d\\n\",\n                __kmp_mic_type, __kmp_mwait_enabled));\n}\n#endif /* KMP_HAVE_UMWAIT */\n\nstatic void __kmp_do_serial_initialize(void) {\n  int i, gtid;\n  size_t size;\n\n  KA_TRACE(10, (\"__kmp_do_serial_initialize: enter\\n\"));\n\n  KMP_DEBUG_ASSERT(sizeof(kmp_int32) == 4);\n  KMP_DEBUG_ASSERT(sizeof(kmp_uint32) == 4);\n  KMP_DEBUG_ASSERT(sizeof(kmp_int64) == 8);\n  KMP_DEBUG_ASSERT(sizeof(kmp_uint64) == 8);\n  KMP_DEBUG_ASSERT(sizeof(kmp_intptr_t) == sizeof(void *));\n\n#if OMPT_SUPPORT\n  ompt_pre_init();\n#endif\n\n  __kmp_validate_locks();\n\n  /* Initialize internal memory allocator */\n  __kmp_init_allocator();\n\n  /* Register the library startup via an environment variable and check to see\n     whether another copy of the library is already registered. */\n\n  __kmp_register_library_startup();\n\n  /* TODO reinitialization of library */\n  if (TCR_4(__kmp_global.g.g_done)) {\n    KA_TRACE(10, (\"__kmp_do_serial_initialize: reinitialization of library\\n\"));\n  }\n\n  __kmp_global.g.g_abort = 0;\n  TCW_SYNC_4(__kmp_global.g.g_done, FALSE);\n\n/* initialize the locks */\n#if KMP_USE_ADAPTIVE_LOCKS\n#if KMP_DEBUG_ADAPTIVE_LOCKS\n  __kmp_init_speculative_stats();\n#endif\n#endif\n#if KMP_STATS_ENABLED\n  __kmp_stats_init();\n#endif\n  __kmp_init_lock(&__kmp_global_lock);\n  __kmp_init_queuing_lock(&__kmp_dispatch_lock);\n  __kmp_init_lock(&__kmp_debug_lock);\n  __kmp_init_atomic_lock(&__kmp_atomic_lock);\n  __kmp_init_atomic_lock(&__kmp_atomic_lock_1i);\n  __kmp_init_atomic_lock(&__kmp_atomic_lock_2i);\n  __kmp_init_atomic_lock(&__kmp_atomic_lock_4i);\n  __kmp_init_atomic_lock(&__kmp_atomic_lock_4r);\n  __kmp_init_atomic_lock(&__kmp_atomic_lock_8i);\n  __kmp_init_atomic_lock(&__kmp_atomic_lock_8r);\n  __kmp_init_atomic_lock(&__kmp_atomic_lock_8c);\n  __kmp_init_atomic_lock(&__kmp_atomic_lock_10r);\n  __kmp_init_atomic_lock(&__kmp_atomic_lock_16r);\n  __kmp_init_atomic_lock(&__kmp_atomic_lock_16c);\n  __kmp_init_atomic_lock(&__kmp_atomic_lock_20c);\n  __kmp_init_atomic_lock(&__kmp_atomic_lock_32c);\n  __kmp_init_bootstrap_lock(&__kmp_forkjoin_lock);\n  __kmp_init_bootstrap_lock(&__kmp_exit_lock);\n#if KMP_USE_MONITOR\n  __kmp_init_bootstrap_lock(&__kmp_monitor_lock);\n#endif\n  __kmp_init_bootstrap_lock(&__kmp_tp_cached_lock);\n\n  /* conduct initialization and initial setup of configuration */\n\n  __kmp_runtime_initialize();\n\n#if KMP_MIC_SUPPORTED\n  __kmp_check_mic_type();\n#endif\n\n// Some global variable initialization moved here from kmp_env_initialize()\n#ifdef KMP_DEBUG\n  kmp_diag = 0;\n#endif\n  __kmp_abort_delay = 0;\n\n  // From __kmp_init_dflt_team_nth()\n  /* assume the entire machine will be used */\n  __kmp_dflt_team_nth_ub = __kmp_xproc;\n  if (__kmp_dflt_team_nth_ub < KMP_MIN_NTH) {\n    __kmp_dflt_team_nth_ub = KMP_MIN_NTH;\n  }\n  if (__kmp_dflt_team_nth_ub > __kmp_sys_max_nth) {\n    __kmp_dflt_team_nth_ub = __kmp_sys_max_nth;\n  }\n  __kmp_max_nth = __kmp_sys_max_nth;\n  __kmp_cg_max_nth = __kmp_sys_max_nth;\n  __kmp_teams_max_nth = __kmp_xproc; // set a \"reasonable\" default\n  if (__kmp_teams_max_nth > __kmp_sys_max_nth) {\n    __kmp_teams_max_nth = __kmp_sys_max_nth;\n  }\n\n  // Three vars below moved here from __kmp_env_initialize() \"KMP_BLOCKTIME\"\n  // part\n  __kmp_dflt_blocktime = KMP_DEFAULT_BLOCKTIME;\n#if KMP_USE_MONITOR\n  __kmp_monitor_wakeups =\n      KMP_WAKEUPS_FROM_BLOCKTIME(__kmp_dflt_blocktime, __kmp_monitor_wakeups);\n  __kmp_bt_intervals =\n      KMP_INTERVALS_FROM_BLOCKTIME(__kmp_dflt_blocktime, __kmp_monitor_wakeups);\n#endif\n  // From \"KMP_LIBRARY\" part of __kmp_env_initialize()\n  __kmp_library = library_throughput;\n  // From KMP_SCHEDULE initialization\n  __kmp_static = kmp_sch_static_balanced;\n// AC: do not use analytical here, because it is non-monotonous\n//__kmp_guided = kmp_sch_guided_iterative_chunked;\n//__kmp_auto = kmp_sch_guided_analytical_chunked; // AC: it is the default, no\n// need to repeat assignment\n// Barrier initialization. Moved here from __kmp_env_initialize() Barrier branch\n// bit control and barrier method control parts\n#if KMP_FAST_REDUCTION_BARRIER\n#define kmp_reduction_barrier_gather_bb ((int)1)\n#define kmp_reduction_barrier_release_bb ((int)1)\n#define kmp_reduction_barrier_gather_pat bp_hyper_bar\n#define kmp_reduction_barrier_release_pat bp_hyper_bar\n#endif // KMP_FAST_REDUCTION_BARRIER\n  for (i = bs_plain_barrier; i < bs_last_barrier; i++) {\n    __kmp_barrier_gather_branch_bits[i] = __kmp_barrier_gather_bb_dflt;\n    __kmp_barrier_release_branch_bits[i] = __kmp_barrier_release_bb_dflt;\n    __kmp_barrier_gather_pattern[i] = __kmp_barrier_gather_pat_dflt;\n    __kmp_barrier_release_pattern[i] = __kmp_barrier_release_pat_dflt;\n#if KMP_FAST_REDUCTION_BARRIER\n    if (i == bs_reduction_barrier) { // tested and confirmed on ALTIX only (\n      // lin_64 ): hyper,1\n      __kmp_barrier_gather_branch_bits[i] = kmp_reduction_barrier_gather_bb;\n      __kmp_barrier_release_branch_bits[i] = kmp_reduction_barrier_release_bb;\n      __kmp_barrier_gather_pattern[i] = kmp_reduction_barrier_gather_pat;\n      __kmp_barrier_release_pattern[i] = kmp_reduction_barrier_release_pat;\n    }\n#endif // KMP_FAST_REDUCTION_BARRIER\n  }\n#if KMP_FAST_REDUCTION_BARRIER\n#undef kmp_reduction_barrier_release_pat\n#undef kmp_reduction_barrier_gather_pat\n#undef kmp_reduction_barrier_release_bb\n#undef kmp_reduction_barrier_gather_bb\n#endif // KMP_FAST_REDUCTION_BARRIER\n#if KMP_MIC_SUPPORTED\n  if (__kmp_mic_type == mic2) { // KNC\n    // AC: plane=3,2, forkjoin=2,1 are optimal for 240 threads on KNC\n    __kmp_barrier_gather_branch_bits[bs_plain_barrier] = 3; // plain gather\n    __kmp_barrier_release_branch_bits[bs_forkjoin_barrier] =\n        1; // forkjoin release\n    __kmp_barrier_gather_pattern[bs_forkjoin_barrier] = bp_hierarchical_bar;\n    __kmp_barrier_release_pattern[bs_forkjoin_barrier] = bp_hierarchical_bar;\n  }\n#if KMP_FAST_REDUCTION_BARRIER\n  if (__kmp_mic_type == mic2) { // KNC\n    __kmp_barrier_gather_pattern[bs_reduction_barrier] = bp_hierarchical_bar;\n    __kmp_barrier_release_pattern[bs_reduction_barrier] = bp_hierarchical_bar;\n  }\n#endif // KMP_FAST_REDUCTION_BARRIER\n#endif // KMP_MIC_SUPPORTED\n\n// From KMP_CHECKS initialization\n#ifdef KMP_DEBUG\n  __kmp_env_checks = TRUE; /* development versions have the extra checks */\n#else\n  __kmp_env_checks = FALSE; /* port versions do not have the extra checks */\n#endif\n\n  // From \"KMP_FOREIGN_THREADS_THREADPRIVATE\" initialization\n  __kmp_foreign_tp = TRUE;\n\n  __kmp_global.g.g_dynamic = FALSE;\n  __kmp_global.g.g_dynamic_mode = dynamic_default;\n\n  __kmp_env_initialize(NULL);\n\n#if KMP_HAVE_MWAIT || KMP_HAVE_UMWAIT\n  __kmp_user_level_mwait_init();\n#endif\n// Print all messages in message catalog for testing purposes.\n#ifdef KMP_DEBUG\n  char const *val = __kmp_env_get(\"KMP_DUMP_CATALOG\");\n  if (__kmp_str_match_true(val)) {\n    kmp_str_buf_t buffer;\n    __kmp_str_buf_init(&buffer);\n    __kmp_i18n_dump_catalog(&buffer);\n    __kmp_printf(\"%s\", buffer.str);\n    __kmp_str_buf_free(&buffer);\n  }\n  __kmp_env_free(&val);\n#endif\n\n  __kmp_threads_capacity =\n      __kmp_initial_threads_capacity(__kmp_dflt_team_nth_ub);\n  // Moved here from __kmp_env_initialize() \"KMP_ALL_THREADPRIVATE\" part\n  __kmp_tp_capacity = __kmp_default_tp_capacity(\n      __kmp_dflt_team_nth_ub, __kmp_max_nth, __kmp_allThreadsSpecified);\n\n  // If the library is shut down properly, both pools must be NULL. Just in\n  // case, set them to NULL -- some memory may leak, but subsequent code will\n  // work even if pools are not freed.\n  KMP_DEBUG_ASSERT(__kmp_thread_pool == NULL);\n  KMP_DEBUG_ASSERT(__kmp_thread_pool_insert_pt == NULL);\n  KMP_DEBUG_ASSERT(__kmp_team_pool == NULL);\n  __kmp_thread_pool = NULL;\n  __kmp_thread_pool_insert_pt = NULL;\n  __kmp_team_pool = NULL;\n\n  /* Allocate all of the variable sized records */\n  /* NOTE: __kmp_threads_capacity entries are allocated, but the arrays are\n   * expandable */\n  /* Since allocation is cache-aligned, just add extra padding at the end */\n  size =\n      (sizeof(kmp_info_t *) + sizeof(kmp_root_t *)) * __kmp_threads_capacity +\n      CACHE_LINE;\n  __kmp_threads = (kmp_info_t **)__kmp_allocate(size);\n  __kmp_root = (kmp_root_t **)((char *)__kmp_threads +\n                               sizeof(kmp_info_t *) * __kmp_threads_capacity);\n\n  /* init thread counts */\n  KMP_DEBUG_ASSERT(__kmp_all_nth ==\n                   0); // Asserts fail if the library is reinitializing and\n  KMP_DEBUG_ASSERT(__kmp_nth == 0); // something was wrong in termination.\n  __kmp_all_nth = 0;\n  __kmp_nth = 0;\n\n  /* setup the uber master thread and hierarchy */\n  gtid = __kmp_register_root(TRUE);\n  KA_TRACE(10, (\"__kmp_do_serial_initialize  T#%d\\n\", gtid));\n  KMP_ASSERT(KMP_UBER_GTID(gtid));\n  KMP_ASSERT(KMP_INITIAL_GTID(gtid));\n\n  KMP_MB(); /* Flush all pending memory write invalidates.  */\n\n  __kmp_common_initialize();\n\n#if KMP_OS_UNIX\n  /* invoke the child fork handler */\n  __kmp_register_atfork();\n#endif\n\n#if !KMP_DYNAMIC_LIB\n  {\n    /* Invoke the exit handler when the program finishes, only for static\n       library. For dynamic library, we already have _fini and DllMain. */\n    int rc = atexit(__kmp_internal_end_atexit);\n    if (rc != 0) {\n      __kmp_fatal(KMP_MSG(FunctionError, \"atexit()\"), KMP_ERR(rc),\n                  __kmp_msg_null);\n    }\n  }\n#endif\n\n#if KMP_HANDLE_SIGNALS\n#if KMP_OS_UNIX\n  /* NOTE: make sure that this is called before the user installs their own\n     signal handlers so that the user handlers are called first. this way they\n     can return false, not call our handler, avoid terminating the library, and\n     continue execution where they left off. */\n  __kmp_install_signals(FALSE);\n#endif /* KMP_OS_UNIX */\n#if KMP_OS_WINDOWS\n  __kmp_install_signals(TRUE);\n#endif /* KMP_OS_WINDOWS */\n#endif\n\n  /* we have finished the serial initialization */\n  __kmp_init_counter++;\n\n  __kmp_init_serial = TRUE;\n\n  if (__kmp_settings) {\n    __kmp_env_print();\n  }\n\n  if (__kmp_display_env || __kmp_display_env_verbose) {\n    __kmp_env_print_2();\n  }\n\n#if OMPT_SUPPORT\n  ompt_post_init();\n#endif\n\n  KMP_MB();\n\n  KA_TRACE(10, (\"__kmp_do_serial_initialize: exit\\n\"));\n}\n\nvoid __kmp_serial_initialize(void) {\n  if (__kmp_init_serial) {\n    return;\n  }\n  __kmp_acquire_bootstrap_lock(&__kmp_initz_lock);\n  if (__kmp_init_serial) {\n    __kmp_release_bootstrap_lock(&__kmp_initz_lock);\n    return;\n  }\n  __kmp_do_serial_initialize();\n  __kmp_release_bootstrap_lock(&__kmp_initz_lock);\n}\n\nstatic void __kmp_do_middle_initialize(void) {\n  int i, j;\n  int prev_dflt_team_nth;\n\n  if (!__kmp_init_serial) {\n    __kmp_do_serial_initialize();\n  }\n\n  KA_TRACE(10, (\"__kmp_middle_initialize: enter\\n\"));\n\n  // Save the previous value for the __kmp_dflt_team_nth so that\n  // we can avoid some reinitialization if it hasn't changed.\n  prev_dflt_team_nth = __kmp_dflt_team_nth;\n\n#if KMP_AFFINITY_SUPPORTED\n  // __kmp_affinity_initialize() will try to set __kmp_ncores to the\n  // number of cores on the machine.\n  __kmp_affinity_initialize();\n\n  // Run through the __kmp_threads array and set the affinity mask\n  // for each root thread that is currently registered with the RTL.\n  for (i = 0; i < __kmp_threads_capacity; i++) {\n    if (TCR_PTR(__kmp_threads[i]) != NULL) {\n      __kmp_affinity_set_init_mask(i, TRUE);\n    }\n  }\n#endif /* KMP_AFFINITY_SUPPORTED */\n\n  KMP_ASSERT(__kmp_xproc > 0);\n  if (__kmp_avail_proc == 0) {\n    __kmp_avail_proc = __kmp_xproc;\n  }\n\n  // If there were empty places in num_threads list (OMP_NUM_THREADS=,,2,3),\n  // correct them now\n  j = 0;\n  while ((j < __kmp_nested_nth.used) && !__kmp_nested_nth.nth[j]) {\n    __kmp_nested_nth.nth[j] = __kmp_dflt_team_nth = __kmp_dflt_team_nth_ub =\n        __kmp_avail_proc;\n    j++;\n  }\n\n  if (__kmp_dflt_team_nth == 0) {\n#ifdef KMP_DFLT_NTH_CORES\n    // Default #threads = #cores\n    __kmp_dflt_team_nth = __kmp_ncores;\n    KA_TRACE(20, (\"__kmp_middle_initialize: setting __kmp_dflt_team_nth = \"\n                  \"__kmp_ncores (%d)\\n\",\n                  __kmp_dflt_team_nth));\n#else\n    // Default #threads = #available OS procs\n    __kmp_dflt_team_nth = __kmp_avail_proc;\n    KA_TRACE(20, (\"__kmp_middle_initialize: setting __kmp_dflt_team_nth = \"\n                  \"__kmp_avail_proc(%d)\\n\",\n                  __kmp_dflt_team_nth));\n#endif /* KMP_DFLT_NTH_CORES */\n  }\n\n  if (__kmp_dflt_team_nth < KMP_MIN_NTH) {\n    __kmp_dflt_team_nth = KMP_MIN_NTH;\n  }\n  if (__kmp_dflt_team_nth > __kmp_sys_max_nth) {\n    __kmp_dflt_team_nth = __kmp_sys_max_nth;\n  }\n\n  // There's no harm in continuing if the following check fails,\n  // but it indicates an error in the previous logic.\n  KMP_DEBUG_ASSERT(__kmp_dflt_team_nth <= __kmp_dflt_team_nth_ub);\n\n  if (__kmp_dflt_team_nth != prev_dflt_team_nth) {\n    // Run through the __kmp_threads array and set the num threads icv for each\n    // root thread that is currently registered with the RTL (which has not\n    // already explicitly set its nthreads-var with a call to\n    // omp_set_num_threads()).\n    for (i = 0; i < __kmp_threads_capacity; i++) {\n      kmp_info_t *thread = __kmp_threads[i];\n      if (thread == NULL)\n        continue;\n      if (thread->th.th_current_task->td_icvs.nproc != 0)\n        continue;\n\n      set__nproc(__kmp_threads[i], __kmp_dflt_team_nth);\n    }\n  }\n  KA_TRACE(\n      20,\n      (\"__kmp_middle_initialize: final value for __kmp_dflt_team_nth = %d\\n\",\n       __kmp_dflt_team_nth));\n\n#ifdef KMP_ADJUST_BLOCKTIME\n  /* Adjust blocktime to zero if necessary  now that __kmp_avail_proc is set */\n  if (!__kmp_env_blocktime && (__kmp_avail_proc > 0)) {\n    KMP_DEBUG_ASSERT(__kmp_avail_proc > 0);\n    if (__kmp_nth > __kmp_avail_proc) {\n      __kmp_zero_bt = TRUE;\n    }\n  }\n#endif /* KMP_ADJUST_BLOCKTIME */\n\n  /* we have finished middle initialization */\n  TCW_SYNC_4(__kmp_init_middle, TRUE);\n\n  KA_TRACE(10, (\"__kmp_do_middle_initialize: exit\\n\"));\n}\n\nvoid __kmp_middle_initialize(void) {\n  if (__kmp_init_middle) {\n    return;\n  }\n  __kmp_acquire_bootstrap_lock(&__kmp_initz_lock);\n  if (__kmp_init_middle) {\n    __kmp_release_bootstrap_lock(&__kmp_initz_lock);\n    return;\n  }\n  __kmp_do_middle_initialize();\n  __kmp_release_bootstrap_lock(&__kmp_initz_lock);\n}\n\nvoid __kmp_parallel_initialize(void) {\n  int gtid = __kmp_entry_gtid(); // this might be a new root\n\n  /* synchronize parallel initialization (for sibling) */\n  if (TCR_4(__kmp_init_parallel))\n    return;\n  __kmp_acquire_bootstrap_lock(&__kmp_initz_lock);\n  if (TCR_4(__kmp_init_parallel)) {\n    __kmp_release_bootstrap_lock(&__kmp_initz_lock);\n    return;\n  }\n\n  /* TODO reinitialization after we have already shut down */\n  if (TCR_4(__kmp_global.g.g_done)) {\n    KA_TRACE(\n        10,\n        (\"__kmp_parallel_initialize: attempt to init while shutting down\\n\"));\n    __kmp_infinite_loop();\n  }\n\n  /* jc: The lock __kmp_initz_lock is already held, so calling\n     __kmp_serial_initialize would cause a deadlock.  So we call\n     __kmp_do_serial_initialize directly. */\n  if (!__kmp_init_middle) {\n    __kmp_do_middle_initialize();\n  }\n  __kmp_resume_if_hard_paused();\n\n  /* begin initialization */\n  KA_TRACE(10, (\"__kmp_parallel_initialize: enter\\n\"));\n  KMP_ASSERT(KMP_UBER_GTID(gtid));\n\n#if KMP_ARCH_X86 || KMP_ARCH_X86_64\n  // Save the FP control regs.\n  // Worker threads will set theirs to these values at thread startup.\n  __kmp_store_x87_fpu_control_word(&__kmp_init_x87_fpu_control_word);\n  __kmp_store_mxcsr(&__kmp_init_mxcsr);\n  __kmp_init_mxcsr &= KMP_X86_MXCSR_MASK;\n#endif /* KMP_ARCH_X86 || KMP_ARCH_X86_64 */\n\n#if KMP_OS_UNIX\n#if KMP_HANDLE_SIGNALS\n  /*  must be after __kmp_serial_initialize  */\n  __kmp_install_signals(TRUE);\n#endif\n#endif\n\n  __kmp_suspend_initialize();\n\n#if defined(USE_LOAD_BALANCE)\n  if (__kmp_global.g.g_dynamic_mode == dynamic_default) {\n    __kmp_global.g.g_dynamic_mode = dynamic_load_balance;\n  }\n#else\n  if (__kmp_global.g.g_dynamic_mode == dynamic_default) {\n    __kmp_global.g.g_dynamic_mode = dynamic_thread_limit;\n  }\n#endif\n\n  if (__kmp_version) {\n    __kmp_print_version_2();\n  }\n\n  /* we have finished parallel initialization */\n  TCW_SYNC_4(__kmp_init_parallel, TRUE);\n\n  KMP_MB();\n  KA_TRACE(10, (\"__kmp_parallel_initialize: exit\\n\"));\n\n  __kmp_release_bootstrap_lock(&__kmp_initz_lock);\n}\n\nvoid __kmp_hidden_helper_initialize() {\n  if (TCR_4(__kmp_init_hidden_helper))\n    return;\n\n  // __kmp_parallel_initialize is required before we initialize hidden helper\n  if (!TCR_4(__kmp_init_parallel))\n    __kmp_parallel_initialize();\n\n  // Double check. Note that this double check should not be placed before\n  // __kmp_parallel_initialize as it will cause dead lock.\n  __kmp_acquire_bootstrap_lock(&__kmp_initz_lock);\n  if (TCR_4(__kmp_init_hidden_helper)) {\n    __kmp_release_bootstrap_lock(&__kmp_initz_lock);\n    return;\n  }\n\n  // Set the count of hidden helper tasks to be executed to zero\n  KMP_ATOMIC_ST_REL(&__kmp_unexecuted_hidden_helper_tasks, 0);\n\n  // Set the global variable indicating that we're initializing hidden helper\n  // team/threads\n  TCW_SYNC_4(__kmp_init_hidden_helper_threads, TRUE);\n\n  // Platform independent initialization\n  __kmp_do_initialize_hidden_helper_threads();\n\n  // Wait here for the finish of initialization of hidden helper teams\n  __kmp_hidden_helper_threads_initz_wait();\n\n  // We have finished hidden helper initialization\n  TCW_SYNC_4(__kmp_init_hidden_helper, TRUE);\n\n  __kmp_release_bootstrap_lock(&__kmp_initz_lock);\n}\n\n/* ------------------------------------------------------------------------ */\n\nvoid __kmp_run_before_invoked_task(int gtid, int tid, kmp_info_t *this_thr,\n                                   kmp_team_t *team) {\n  kmp_disp_t *dispatch;\n\n  KMP_MB();\n\n  /* none of the threads have encountered any constructs, yet. */\n  this_thr->th.th_local.this_construct = 0;\n#if KMP_CACHE_MANAGE\n  KMP_CACHE_PREFETCH(&this_thr->th.th_bar[bs_forkjoin_barrier].bb.b_arrived);\n#endif /* KMP_CACHE_MANAGE */\n  dispatch = (kmp_disp_t *)TCR_PTR(this_thr->th.th_dispatch);\n  KMP_DEBUG_ASSERT(dispatch);\n  KMP_DEBUG_ASSERT(team->t.t_dispatch);\n  // KMP_DEBUG_ASSERT( this_thr->th.th_dispatch == &team->t.t_dispatch[\n  // this_thr->th.th_info.ds.ds_tid ] );\n\n  dispatch->th_disp_index = 0; /* reset the dispatch buffer counter */\n  dispatch->th_doacross_buf_idx = 0; // reset doacross dispatch buffer counter\n  if (__kmp_env_consistency_check)\n    __kmp_push_parallel(gtid, team->t.t_ident);\n\n  KMP_MB(); /* Flush all pending memory write invalidates.  */\n}\n\nvoid __kmp_run_after_invoked_task(int gtid, int tid, kmp_info_t *this_thr,\n                                  kmp_team_t *team) {\n  if (__kmp_env_consistency_check)\n    __kmp_pop_parallel(gtid, team->t.t_ident);\n\n  __kmp_finish_implicit_task(this_thr);\n}\n\nint __kmp_invoke_task_func(int gtid) {\n  int rc;\n  int tid = __kmp_tid_from_gtid(gtid);\n  kmp_info_t *this_thr = __kmp_threads[gtid];\n  kmp_team_t *team = this_thr->th.th_team;\n\n  __kmp_run_before_invoked_task(gtid, tid, this_thr, team);\n#if USE_ITT_BUILD\n  if (__itt_stack_caller_create_ptr) {\n    // inform ittnotify about entering user's code\n    if (team->t.t_stack_id != NULL) {\n      __kmp_itt_stack_callee_enter((__itt_caller)team->t.t_stack_id);\n    } else {\n      KMP_DEBUG_ASSERT(team->t.t_parent->t.t_stack_id != NULL);\n      __kmp_itt_stack_callee_enter(\n          (__itt_caller)team->t.t_parent->t.t_stack_id);\n    }\n  }\n#endif /* USE_ITT_BUILD */\n#if INCLUDE_SSC_MARKS\n  SSC_MARK_INVOKING();\n#endif\n\n#if OMPT_SUPPORT\n  void *dummy;\n  void **exit_frame_p;\n  ompt_data_t *my_task_data;\n  ompt_data_t *my_parallel_data;\n  int ompt_team_size;\n\n  if (ompt_enabled.enabled) {\n    exit_frame_p = &(team->t.t_implicit_task_taskdata[tid]\n                         .ompt_task_info.frame.exit_frame.ptr);\n  } else {\n    exit_frame_p = &dummy;\n  }\n\n  my_task_data =\n      &(team->t.t_implicit_task_taskdata[tid].ompt_task_info.task_data);\n  my_parallel_data = &(team->t.ompt_team_info.parallel_data);\n  if (ompt_enabled.ompt_callback_implicit_task) {\n    ompt_team_size = team->t.t_nproc;\n    ompt_callbacks.ompt_callback(ompt_callback_implicit_task)(\n        ompt_scope_begin, my_parallel_data, my_task_data, ompt_team_size,\n        __kmp_tid_from_gtid(gtid), ompt_task_implicit);\n    OMPT_CUR_TASK_INFO(this_thr)->thread_num = __kmp_tid_from_gtid(gtid);\n  }\n#endif\n\n#if KMP_STATS_ENABLED\n  stats_state_e previous_state = KMP_GET_THREAD_STATE();\n  if (previous_state == stats_state_e::TEAMS_REGION) {\n    KMP_PUSH_PARTITIONED_TIMER(OMP_teams);\n  } else {\n    KMP_PUSH_PARTITIONED_TIMER(OMP_parallel);\n  }\n  KMP_SET_THREAD_STATE(IMPLICIT_TASK);\n#endif\n\n  rc = __kmp_invoke_microtask((microtask_t)TCR_SYNC_PTR(team->t.t_pkfn), gtid,\n                              tid, (int)team->t.t_argc, (void **)team->t.t_argv\n#if OMPT_SUPPORT\n                              ,\n                              exit_frame_p\n#endif\n  );\n#if OMPT_SUPPORT\n  *exit_frame_p = NULL;\n  this_thr->th.ompt_thread_info.parallel_flags |= ompt_parallel_team;\n#endif\n\n#if KMP_STATS_ENABLED\n  if (previous_state == stats_state_e::TEAMS_REGION) {\n    KMP_SET_THREAD_STATE(previous_state);\n  }\n  KMP_POP_PARTITIONED_TIMER();\n#endif\n\n#if USE_ITT_BUILD\n  if (__itt_stack_caller_create_ptr) {\n    // inform ittnotify about leaving user's code\n    if (team->t.t_stack_id != NULL) {\n      __kmp_itt_stack_callee_leave((__itt_caller)team->t.t_stack_id);\n    } else {\n      KMP_DEBUG_ASSERT(team->t.t_parent->t.t_stack_id != NULL);\n      __kmp_itt_stack_callee_leave(\n          (__itt_caller)team->t.t_parent->t.t_stack_id);\n    }\n  }\n#endif /* USE_ITT_BUILD */\n  __kmp_run_after_invoked_task(gtid, tid, this_thr, team);\n\n  return rc;\n}\n\nvoid __kmp_teams_master(int gtid) {\n  // This routine is called by all primary threads in teams construct\n  kmp_info_t *thr = __kmp_threads[gtid];\n  kmp_team_t *team = thr->th.th_team;\n  ident_t *loc = team->t.t_ident;\n  thr->th.th_set_nproc = thr->th.th_teams_size.nth;\n  KMP_DEBUG_ASSERT(thr->th.th_teams_microtask);\n  KMP_DEBUG_ASSERT(thr->th.th_set_nproc);\n  KA_TRACE(20, (\"__kmp_teams_master: T#%d, Tid %d, microtask %p\\n\", gtid,\n                __kmp_tid_from_gtid(gtid), thr->th.th_teams_microtask));\n\n  // This thread is a new CG root.  Set up the proper variables.\n  kmp_cg_root_t *tmp = (kmp_cg_root_t *)__kmp_allocate(sizeof(kmp_cg_root_t));\n  tmp->cg_root = thr; // Make thr the CG root\n  // Init to thread limit stored when league primary threads were forked\n  tmp->cg_thread_limit = thr->th.th_current_task->td_icvs.thread_limit;\n  tmp->cg_nthreads = 1; // Init counter to one active thread, this one\n  KA_TRACE(100, (\"__kmp_teams_master: Thread %p created node %p and init\"\n                 \" cg_nthreads to 1\\n\",\n                 thr, tmp));\n  tmp->up = thr->th.th_cg_roots;\n  thr->th.th_cg_roots = tmp;\n\n// Launch league of teams now, but not let workers execute\n// (they hang on fork barrier until next parallel)\n#if INCLUDE_SSC_MARKS\n  SSC_MARK_FORKING();\n#endif\n  __kmp_fork_call(loc, gtid, fork_context_intel, team->t.t_argc,\n                  (microtask_t)thr->th.th_teams_microtask, // \"wrapped\" task\n                  VOLATILE_CAST(launch_t) __kmp_invoke_task_func, NULL);\n#if INCLUDE_SSC_MARKS\n  SSC_MARK_JOINING();\n#endif\n  // If the team size was reduced from the limit, set it to the new size\n  if (thr->th.th_team_nproc < thr->th.th_teams_size.nth)\n    thr->th.th_teams_size.nth = thr->th.th_team_nproc;\n  // AC: last parameter \"1\" eliminates join barrier which won't work because\n  // worker threads are in a fork barrier waiting for more parallel regions\n  __kmp_join_call(loc, gtid\n#if OMPT_SUPPORT\n                  ,\n                  fork_context_intel\n#endif\n                  ,\n                  1);\n}\n\nint __kmp_invoke_teams_master(int gtid) {\n  kmp_info_t *this_thr = __kmp_threads[gtid];\n  kmp_team_t *team = this_thr->th.th_team;\n#if KMP_DEBUG\n  if (!__kmp_threads[gtid]->th.th_team->t.t_serialized)\n    KMP_DEBUG_ASSERT((void *)__kmp_threads[gtid]->th.th_team->t.t_pkfn ==\n                     (void *)__kmp_teams_master);\n#endif\n  __kmp_run_before_invoked_task(gtid, 0, this_thr, team);\n#if OMPT_SUPPORT\n  int tid = __kmp_tid_from_gtid(gtid);\n  ompt_data_t *task_data =\n      &team->t.t_implicit_task_taskdata[tid].ompt_task_info.task_data;\n  ompt_data_t *parallel_data = &team->t.ompt_team_info.parallel_data;\n  if (ompt_enabled.ompt_callback_implicit_task) {\n    ompt_callbacks.ompt_callback(ompt_callback_implicit_task)(\n        ompt_scope_begin, parallel_data, task_data, team->t.t_nproc, tid,\n        ompt_task_initial);\n    OMPT_CUR_TASK_INFO(this_thr)->thread_num = tid;\n  }\n#endif\n  __kmp_teams_master(gtid);\n#if OMPT_SUPPORT\n  this_thr->th.ompt_thread_info.parallel_flags |= ompt_parallel_league;\n#endif\n  __kmp_run_after_invoked_task(gtid, 0, this_thr, team);\n  return 1;\n}\n\n/* this sets the requested number of threads for the next parallel region\n   encountered by this team. since this should be enclosed in the forkjoin\n   critical section it should avoid race conditions with asymmetrical nested\n   parallelism */\n\nvoid __kmp_push_num_threads(ident_t *id, int gtid, int num_threads) {\n  kmp_info_t *thr = __kmp_threads[gtid];\n\n  if (num_threads > 0)\n    thr->th.th_set_nproc = num_threads;\n}\n\nstatic void __kmp_push_thread_limit(kmp_info_t *thr, int num_teams,\n                                    int num_threads) {\n  KMP_DEBUG_ASSERT(thr);\n  // Remember the number of threads for inner parallel regions\n  if (!TCR_4(__kmp_init_middle))\n    __kmp_middle_initialize(); // get internal globals calculated\n  KMP_DEBUG_ASSERT(__kmp_avail_proc);\n  KMP_DEBUG_ASSERT(__kmp_dflt_team_nth);\n\n  if (num_threads == 0) {\n    if (__kmp_teams_thread_limit > 0) {\n      num_threads = __kmp_teams_thread_limit;\n    } else {\n      num_threads = __kmp_avail_proc / num_teams;\n    }\n    // adjust num_threads w/o warning as it is not user setting\n    // num_threads = min(num_threads, nthreads-var, thread-limit-var)\n    // no thread_limit clause specified -  do not change thread-limit-var ICV\n    if (num_threads > __kmp_dflt_team_nth) {\n      num_threads = __kmp_dflt_team_nth; // honor nthreads-var ICV\n    }\n    if (num_threads > thr->th.th_current_task->td_icvs.thread_limit) {\n      num_threads = thr->th.th_current_task->td_icvs.thread_limit;\n    } // prevent team size to exceed thread-limit-var\n    if (num_teams * num_threads > __kmp_teams_max_nth) {\n      num_threads = __kmp_teams_max_nth / num_teams;\n    }\n    if (num_threads == 0) {\n      num_threads = 1;\n    }\n  } else {\n    // This thread will be the primary thread of the league primary threads\n    // Store new thread limit; old limit is saved in th_cg_roots list\n    thr->th.th_current_task->td_icvs.thread_limit = num_threads;\n    // num_threads = min(num_threads, nthreads-var)\n    if (num_threads > __kmp_dflt_team_nth) {\n      num_threads = __kmp_dflt_team_nth; // honor nthreads-var ICV\n    }\n    if (num_teams * num_threads > __kmp_teams_max_nth) {\n      int new_threads = __kmp_teams_max_nth / num_teams;\n      if (new_threads == 0) {\n        new_threads = 1;\n      }\n      if (new_threads != num_threads) {\n        if (!__kmp_reserve_warn) { // user asked for too many threads\n          __kmp_reserve_warn = 1; // conflicts with KMP_TEAMS_THREAD_LIMIT\n          __kmp_msg(kmp_ms_warning,\n                    KMP_MSG(CantFormThrTeam, num_threads, new_threads),\n                    KMP_HNT(Unset_ALL_THREADS), __kmp_msg_null);\n        }\n      }\n      num_threads = new_threads;\n    }\n  }\n  thr->th.th_teams_size.nth = num_threads;\n}\n\n/* this sets the requested number of teams for the teams region and/or\n   the number of threads for the next parallel region encountered  */\nvoid __kmp_push_num_teams(ident_t *id, int gtid, int num_teams,\n                          int num_threads) {\n  kmp_info_t *thr = __kmp_threads[gtid];\n  KMP_DEBUG_ASSERT(num_teams >= 0);\n  KMP_DEBUG_ASSERT(num_threads >= 0);\n\n  if (num_teams == 0) {\n    if (__kmp_nteams > 0) {\n      num_teams = __kmp_nteams;\n    } else {\n      num_teams = 1; // default number of teams is 1.\n    }\n  }\n  if (num_teams > __kmp_teams_max_nth) { // if too many teams requested?\n    if (!__kmp_reserve_warn) {\n      __kmp_reserve_warn = 1;\n      __kmp_msg(kmp_ms_warning,\n                KMP_MSG(CantFormThrTeam, num_teams, __kmp_teams_max_nth),\n                KMP_HNT(Unset_ALL_THREADS), __kmp_msg_null);\n    }\n    num_teams = __kmp_teams_max_nth;\n  }\n  // Set number of teams (number of threads in the outer \"parallel\" of the\n  // teams)\n  thr->th.th_set_nproc = thr->th.th_teams_size.nteams = num_teams;\n\n  __kmp_push_thread_limit(thr, num_teams, num_threads);\n}\n\n/* This sets the requested number of teams for the teams region and/or\n   the number of threads for the next parallel region encountered  */\nvoid __kmp_push_num_teams_51(ident_t *id, int gtid, int num_teams_lb,\n                             int num_teams_ub, int num_threads) {\n  kmp_info_t *thr = __kmp_threads[gtid];\n  KMP_DEBUG_ASSERT(num_teams_lb >= 0 && num_teams_ub >= 0);\n  KMP_DEBUG_ASSERT(num_teams_ub >= num_teams_lb);\n  KMP_DEBUG_ASSERT(num_threads >= 0);\n\n  if (num_teams_lb > num_teams_ub) {\n    __kmp_fatal(KMP_MSG(FailedToCreateTeam, num_teams_lb, num_teams_ub),\n                KMP_HNT(SetNewBound, __kmp_teams_max_nth), __kmp_msg_null);\n  }\n\n  int num_teams = 1; // defalt number of teams is 1.\n\n  if (num_teams_lb == 0 && num_teams_ub > 0)\n    num_teams_lb = num_teams_ub;\n\n  if (num_teams_lb == 0 && num_teams_ub == 0) { // no num_teams clause\n    num_teams = (__kmp_nteams > 0) ? __kmp_nteams : num_teams;\n    if (num_teams > __kmp_teams_max_nth) {\n      if (!__kmp_reserve_warn) {\n        __kmp_reserve_warn = 1;\n        __kmp_msg(kmp_ms_warning,\n                  KMP_MSG(CantFormThrTeam, num_teams, __kmp_teams_max_nth),\n                  KMP_HNT(Unset_ALL_THREADS), __kmp_msg_null);\n      }\n      num_teams = __kmp_teams_max_nth;\n    }\n  } else if (num_teams_lb == num_teams_ub) { // requires exact number of teams\n    num_teams = num_teams_ub;\n  } else { // num_teams_lb <= num_teams <= num_teams_ub\n    if (num_threads == 0) {\n      if (num_teams_ub > __kmp_teams_max_nth) {\n        num_teams = num_teams_lb;\n      } else {\n        num_teams = num_teams_ub;\n      }\n    } else {\n      num_teams = (num_threads > __kmp_teams_max_nth)\n                      ? num_teams\n                      : __kmp_teams_max_nth / num_threads;\n      if (num_teams < num_teams_lb) {\n        num_teams = num_teams_lb;\n      } else if (num_teams > num_teams_ub) {\n        num_teams = num_teams_ub;\n      }\n    }\n  }\n  // Set number of teams (number of threads in the outer \"parallel\" of the\n  // teams)\n  thr->th.th_set_nproc = thr->th.th_teams_size.nteams = num_teams;\n\n  __kmp_push_thread_limit(thr, num_teams, num_threads);\n}\n\n// Set the proc_bind var to use in the following parallel region.\nvoid __kmp_push_proc_bind(ident_t *id, int gtid, kmp_proc_bind_t proc_bind) {\n  kmp_info_t *thr = __kmp_threads[gtid];\n  thr->th.th_set_proc_bind = proc_bind;\n}\n\n/* Launch the worker threads into the microtask. */\n\nvoid __kmp_internal_fork(ident_t *id, int gtid, kmp_team_t *team) {\n  kmp_info_t *this_thr = __kmp_threads[gtid];\n\n#ifdef KMP_DEBUG\n  int f;\n#endif /* KMP_DEBUG */\n\n  KMP_DEBUG_ASSERT(team);\n  KMP_DEBUG_ASSERT(this_thr->th.th_team == team);\n  KMP_ASSERT(KMP_MASTER_GTID(gtid));\n  KMP_MB(); /* Flush all pending memory write invalidates.  */\n\n  team->t.t_construct = 0; /* no single directives seen yet */\n  team->t.t_ordered.dt.t_value =\n      0; /* thread 0 enters the ordered section first */\n\n  /* Reset the identifiers on the dispatch buffer */\n  KMP_DEBUG_ASSERT(team->t.t_disp_buffer);\n  if (team->t.t_max_nproc > 1) {\n    int i;\n    for (i = 0; i < __kmp_dispatch_num_buffers; ++i) {\n      team->t.t_disp_buffer[i].buffer_index = i;\n      team->t.t_disp_buffer[i].doacross_buf_idx = i;\n    }\n  } else {\n    team->t.t_disp_buffer[0].buffer_index = 0;\n    team->t.t_disp_buffer[0].doacross_buf_idx = 0;\n  }\n\n  KMP_MB(); /* Flush all pending memory write invalidates.  */\n  KMP_ASSERT(this_thr->th.th_team == team);\n\n#ifdef KMP_DEBUG\n  for (f = 0; f < team->t.t_nproc; f++) {\n    KMP_DEBUG_ASSERT(team->t.t_threads[f] &&\n                     team->t.t_threads[f]->th.th_team_nproc == team->t.t_nproc);\n  }\n#endif /* KMP_DEBUG */\n\n  /* release the worker threads so they may begin working */\n  __kmp_fork_barrier(gtid, 0);\n}\n\nvoid __kmp_internal_join(ident_t *id, int gtid, kmp_team_t *team) {\n  kmp_info_t *this_thr = __kmp_threads[gtid];\n\n  KMP_DEBUG_ASSERT(team);\n  KMP_DEBUG_ASSERT(this_thr->th.th_team == team);\n  KMP_ASSERT(KMP_MASTER_GTID(gtid));\n  KMP_MB(); /* Flush all pending memory write invalidates.  */\n\n  /* Join barrier after fork */\n\n#ifdef KMP_DEBUG\n  if (__kmp_threads[gtid] &&\n      __kmp_threads[gtid]->th.th_team_nproc != team->t.t_nproc) {\n    __kmp_printf(\"GTID: %d, __kmp_threads[%d]=%p\\n\", gtid, gtid,\n                 __kmp_threads[gtid]);\n    __kmp_printf(\"__kmp_threads[%d]->th.th_team_nproc=%d, TEAM: %p, \"\n                 \"team->t.t_nproc=%d\\n\",\n                 gtid, __kmp_threads[gtid]->th.th_team_nproc, team,\n                 team->t.t_nproc);\n    __kmp_print_structure();\n  }\n  KMP_DEBUG_ASSERT(__kmp_threads[gtid] &&\n                   __kmp_threads[gtid]->th.th_team_nproc == team->t.t_nproc);\n#endif /* KMP_DEBUG */\n\n  __kmp_join_barrier(gtid); /* wait for everyone */\n#if OMPT_SUPPORT\n  if (ompt_enabled.enabled &&\n      this_thr->th.ompt_thread_info.state == ompt_state_wait_barrier_implicit) {\n    int ds_tid = this_thr->th.th_info.ds.ds_tid;\n    ompt_data_t *task_data = OMPT_CUR_TASK_DATA(this_thr);\n    this_thr->th.ompt_thread_info.state = ompt_state_overhead;\n#if OMPT_OPTIONAL\n    void *codeptr = NULL;\n    if (KMP_MASTER_TID(ds_tid) &&\n        (ompt_callbacks.ompt_callback(ompt_callback_sync_region_wait) ||\n         ompt_callbacks.ompt_callback(ompt_callback_sync_region)))\n      codeptr = OMPT_CUR_TEAM_INFO(this_thr)->master_return_address;\n\n    if (ompt_enabled.ompt_callback_sync_region_wait) {\n      ompt_callbacks.ompt_callback(ompt_callback_sync_region_wait)(\n          ompt_sync_region_barrier_implicit, ompt_scope_end, NULL, task_data,\n          codeptr);\n    }\n    if (ompt_enabled.ompt_callback_sync_region) {\n      ompt_callbacks.ompt_callback(ompt_callback_sync_region)(\n          ompt_sync_region_barrier_implicit, ompt_scope_end, NULL, task_data,\n          codeptr);\n    }\n#endif\n    if (!KMP_MASTER_TID(ds_tid) && ompt_enabled.ompt_callback_implicit_task) {\n      ompt_callbacks.ompt_callback(ompt_callback_implicit_task)(\n          ompt_scope_end, NULL, task_data, 0, ds_tid,\n          ompt_task_implicit); // TODO: Can this be ompt_task_initial?\n    }\n  }\n#endif\n\n  KMP_MB(); /* Flush all pending memory write invalidates.  */\n  KMP_ASSERT(this_thr->th.th_team == team);\n}\n\n/* ------------------------------------------------------------------------ */\n\n#ifdef USE_LOAD_BALANCE\n\n// Return the worker threads actively spinning in the hot team, if we\n// are at the outermost level of parallelism.  Otherwise, return 0.\nstatic int __kmp_active_hot_team_nproc(kmp_root_t *root) {\n  int i;\n  int retval;\n  kmp_team_t *hot_team;\n\n  if (root->r.r_active) {\n    return 0;\n  }\n  hot_team = root->r.r_hot_team;\n  if (__kmp_dflt_blocktime == KMP_MAX_BLOCKTIME) {\n    return hot_team->t.t_nproc - 1; // Don't count primary thread\n  }\n\n  // Skip the primary thread - it is accounted for elsewhere.\n  retval = 0;\n  for (i = 1; i < hot_team->t.t_nproc; i++) {\n    if (hot_team->t.t_threads[i]->th.th_active) {\n      retval++;\n    }\n  }\n  return retval;\n}\n\n// Perform an automatic adjustment to the number of\n// threads used by the next parallel region.\nstatic int __kmp_load_balance_nproc(kmp_root_t *root, int set_nproc) {\n  int retval;\n  int pool_active;\n  int hot_team_active;\n  int team_curr_active;\n  int system_active;\n\n  KB_TRACE(20, (\"__kmp_load_balance_nproc: called root:%p set_nproc:%d\\n\", root,\n                set_nproc));\n  KMP_DEBUG_ASSERT(root);\n  KMP_DEBUG_ASSERT(root->r.r_root_team->t.t_threads[0]\n                       ->th.th_current_task->td_icvs.dynamic == TRUE);\n  KMP_DEBUG_ASSERT(set_nproc > 1);\n\n  if (set_nproc == 1) {\n    KB_TRACE(20, (\"__kmp_load_balance_nproc: serial execution.\\n\"));\n    return 1;\n  }\n\n  // Threads that are active in the thread pool, active in the hot team for this\n  // particular root (if we are at the outer par level), and the currently\n  // executing thread (to become the primary thread) are available to add to the\n  // new team, but are currently contributing to the system load, and must be\n  // accounted for.\n  pool_active = __kmp_thread_pool_active_nth;\n  hot_team_active = __kmp_active_hot_team_nproc(root);\n  team_curr_active = pool_active + hot_team_active + 1;\n\n  // Check the system load.\n  system_active = __kmp_get_load_balance(__kmp_avail_proc + team_curr_active);\n  KB_TRACE(30, (\"__kmp_load_balance_nproc: system active = %d pool active = %d \"\n                \"hot team active = %d\\n\",\n                system_active, pool_active, hot_team_active));\n\n  if (system_active < 0) {\n    // There was an error reading the necessary info from /proc, so use the\n    // thread limit algorithm instead. Once we set __kmp_global.g.g_dynamic_mode\n    // = dynamic_thread_limit, we shouldn't wind up getting back here.\n    __kmp_global.g.g_dynamic_mode = dynamic_thread_limit;\n    KMP_WARNING(CantLoadBalUsing, \"KMP_DYNAMIC_MODE=thread limit\");\n\n    // Make this call behave like the thread limit algorithm.\n    retval = __kmp_avail_proc - __kmp_nth +\n             (root->r.r_active ? 1 : root->r.r_hot_team->t.t_nproc);\n    if (retval > set_nproc) {\n      retval = set_nproc;\n    }\n    if (retval < KMP_MIN_NTH) {\n      retval = KMP_MIN_NTH;\n    }\n\n    KB_TRACE(20, (\"__kmp_load_balance_nproc: thread limit exit. retval:%d\\n\",\n                  retval));\n    return retval;\n  }\n\n  // There is a slight delay in the load balance algorithm in detecting new\n  // running procs. The real system load at this instant should be at least as\n  // large as the #active omp thread that are available to add to the team.\n  if (system_active < team_curr_active) {\n    system_active = team_curr_active;\n  }\n  retval = __kmp_avail_proc - system_active + team_curr_active;\n  if (retval > set_nproc) {\n    retval = set_nproc;\n  }\n  if (retval < KMP_MIN_NTH) {\n    retval = KMP_MIN_NTH;\n  }\n\n  KB_TRACE(20, (\"__kmp_load_balance_nproc: exit. retval:%d\\n\", retval));\n  return retval;\n} // __kmp_load_balance_nproc()\n\n#endif /* USE_LOAD_BALANCE */\n\n/* ------------------------------------------------------------------------ */\n\n/* NOTE: this is called with the __kmp_init_lock held */\nvoid __kmp_cleanup(void) {\n  int f;\n\n  KA_TRACE(10, (\"__kmp_cleanup: enter\\n\"));\n\n  if (TCR_4(__kmp_init_parallel)) {\n#if KMP_HANDLE_SIGNALS\n    __kmp_remove_signals();\n#endif\n    TCW_4(__kmp_init_parallel, FALSE);\n  }\n\n  if (TCR_4(__kmp_init_middle)) {\n#if KMP_AFFINITY_SUPPORTED\n    __kmp_affinity_uninitialize();\n#endif /* KMP_AFFINITY_SUPPORTED */\n    __kmp_cleanup_hierarchy();\n    TCW_4(__kmp_init_middle, FALSE);\n  }\n\n  KA_TRACE(10, (\"__kmp_cleanup: go serial cleanup\\n\"));\n\n  if (__kmp_init_serial) {\n    __kmp_runtime_destroy();\n    __kmp_init_serial = FALSE;\n  }\n\n  __kmp_cleanup_threadprivate_caches();\n\n  for (f = 0; f < __kmp_threads_capacity; f++) {\n    if (__kmp_root[f] != NULL) {\n      __kmp_free(__kmp_root[f]);\n      __kmp_root[f] = NULL;\n    }\n  }\n  __kmp_free(__kmp_threads);\n  // __kmp_threads and __kmp_root were allocated at once, as single block, so\n  // there is no need in freeing __kmp_root.\n  __kmp_threads = NULL;\n  __kmp_root = NULL;\n  __kmp_threads_capacity = 0;\n\n#if KMP_USE_DYNAMIC_LOCK\n  __kmp_cleanup_indirect_user_locks();\n#else\n  __kmp_cleanup_user_locks();\n#endif\n\n#if KMP_AFFINITY_SUPPORTED\n  KMP_INTERNAL_FREE(CCAST(char *, __kmp_cpuinfo_file));\n  __kmp_cpuinfo_file = NULL;\n#endif /* KMP_AFFINITY_SUPPORTED */\n\n#if KMP_USE_ADAPTIVE_LOCKS\n#if KMP_DEBUG_ADAPTIVE_LOCKS\n  __kmp_print_speculative_stats();\n#endif\n#endif\n  KMP_INTERNAL_FREE(__kmp_nested_nth.nth);\n  __kmp_nested_nth.nth = NULL;\n  __kmp_nested_nth.size = 0;\n  __kmp_nested_nth.used = 0;\n  KMP_INTERNAL_FREE(__kmp_nested_proc_bind.bind_types);\n  __kmp_nested_proc_bind.bind_types = NULL;\n  __kmp_nested_proc_bind.size = 0;\n  __kmp_nested_proc_bind.used = 0;\n  if (__kmp_affinity_format) {\n    KMP_INTERNAL_FREE(__kmp_affinity_format);\n    __kmp_affinity_format = NULL;\n  }\n\n  __kmp_i18n_catclose();\n\n#if KMP_USE_HIER_SCHED\n  __kmp_hier_scheds.deallocate();\n#endif\n\n#if KMP_STATS_ENABLED\n  __kmp_stats_fini();\n#endif\n\n  KA_TRACE(10, (\"__kmp_cleanup: exit\\n\"));\n}\n\n/* ------------------------------------------------------------------------ */\n\nint __kmp_ignore_mppbeg(void) {\n  char *env;\n\n  if ((env = getenv(\"KMP_IGNORE_MPPBEG\")) != NULL) {\n    if (__kmp_str_match_false(env))\n      return FALSE;\n  }\n  // By default __kmpc_begin() is no-op.\n  return TRUE;\n}\n\nint __kmp_ignore_mppend(void) {\n  char *env;\n\n  if ((env = getenv(\"KMP_IGNORE_MPPEND\")) != NULL) {\n    if (__kmp_str_match_false(env))\n      return FALSE;\n  }\n  // By default __kmpc_end() is no-op.\n  return TRUE;\n}\n\nvoid __kmp_internal_begin(void) {\n  int gtid;\n  kmp_root_t *root;\n\n  /* this is a very important step as it will register new sibling threads\n     and assign these new uber threads a new gtid */\n  gtid = __kmp_entry_gtid();\n  root = __kmp_threads[gtid]->th.th_root;\n  KMP_ASSERT(KMP_UBER_GTID(gtid));\n\n  if (root->r.r_begin)\n    return;\n  __kmp_acquire_lock(&root->r.r_begin_lock, gtid);\n  if (root->r.r_begin) {\n    __kmp_release_lock(&root->r.r_begin_lock, gtid);\n    return;\n  }\n\n  root->r.r_begin = TRUE;\n\n  __kmp_release_lock(&root->r.r_begin_lock, gtid);\n}\n\n/* ------------------------------------------------------------------------ */\n\nvoid __kmp_user_set_library(enum library_type arg) {\n  int gtid;\n  kmp_root_t *root;\n  kmp_info_t *thread;\n\n  /* first, make sure we are initialized so we can get our gtid */\n\n  gtid = __kmp_entry_gtid();\n  thread = __kmp_threads[gtid];\n\n  root = thread->th.th_root;\n\n  KA_TRACE(20, (\"__kmp_user_set_library: enter T#%d, arg: %d, %d\\n\", gtid, arg,\n                library_serial));\n  if (root->r.r_in_parallel) { /* Must be called in serial section of top-level\n                                  thread */\n    KMP_WARNING(SetLibraryIncorrectCall);\n    return;\n  }\n\n  switch (arg) {\n  case library_serial:\n    thread->th.th_set_nproc = 0;\n    set__nproc(thread, 1);\n    break;\n  case library_turnaround:\n    thread->th.th_set_nproc = 0;\n    set__nproc(thread, __kmp_dflt_team_nth ? __kmp_dflt_team_nth\n                                           : __kmp_dflt_team_nth_ub);\n    break;\n  case library_throughput:\n    thread->th.th_set_nproc = 0;\n    set__nproc(thread, __kmp_dflt_team_nth ? __kmp_dflt_team_nth\n                                           : __kmp_dflt_team_nth_ub);\n    break;\n  default:\n    KMP_FATAL(UnknownLibraryType, arg);\n  }\n\n  __kmp_aux_set_library(arg);\n}\n\nvoid __kmp_aux_set_stacksize(size_t arg) {\n  if (!__kmp_init_serial)\n    __kmp_serial_initialize();\n\n#if KMP_OS_DARWIN\n  if (arg & (0x1000 - 1)) {\n    arg &= ~(0x1000 - 1);\n    if (arg + 0x1000) /* check for overflow if we round up */\n      arg += 0x1000;\n  }\n#endif\n  __kmp_acquire_bootstrap_lock(&__kmp_initz_lock);\n\n  /* only change the default stacksize before the first parallel region */\n  if (!TCR_4(__kmp_init_parallel)) {\n    size_t value = arg; /* argument is in bytes */\n\n    if (value < __kmp_sys_min_stksize)\n      value = __kmp_sys_min_stksize;\n    else if (value > KMP_MAX_STKSIZE)\n      value = KMP_MAX_STKSIZE;\n\n    __kmp_stksize = value;\n\n    __kmp_env_stksize = TRUE; /* was KMP_STACKSIZE specified? */\n  }\n\n  __kmp_release_bootstrap_lock(&__kmp_initz_lock);\n}\n\n/* set the behaviour of the runtime library */\n/* TODO this can cause some odd behaviour with sibling parallelism... */\nvoid __kmp_aux_set_library(enum library_type arg) {\n  __kmp_library = arg;\n\n  switch (__kmp_library) {\n  case library_serial: {\n    KMP_INFORM(LibraryIsSerial);\n  } break;\n  case library_turnaround:\n    if (__kmp_use_yield == 1 && !__kmp_use_yield_exp_set)\n      __kmp_use_yield = 2; // only yield when oversubscribed\n    break;\n  case library_throughput:\n    if (__kmp_dflt_blocktime == KMP_MAX_BLOCKTIME)\n      __kmp_dflt_blocktime = 200;\n    break;\n  default:\n    KMP_FATAL(UnknownLibraryType, arg);\n  }\n}\n\n/* Getting team information common for all team API */\n// Returns NULL if not in teams construct\nstatic kmp_team_t *__kmp_aux_get_team_info(int &teams_serialized) {\n  kmp_info_t *thr = __kmp_entry_thread();\n  teams_serialized = 0;\n  if (thr->th.th_teams_microtask) {\n    kmp_team_t *team = thr->th.th_team;\n    int tlevel = thr->th.th_teams_level; // the level of the teams construct\n    int ii = team->t.t_level;\n    teams_serialized = team->t.t_serialized;\n    int level = tlevel + 1;\n    KMP_DEBUG_ASSERT(ii >= tlevel);\n    while (ii > level) {\n      for (teams_serialized = team->t.t_serialized;\n           (teams_serialized > 0) && (ii > level); teams_serialized--, ii--) {\n      }\n      if (team->t.t_serialized && (!teams_serialized)) {\n        team = team->t.t_parent;\n        continue;\n      }\n      if (ii > level) {\n        team = team->t.t_parent;\n        ii--;\n      }\n    }\n    return team;\n  }\n  return NULL;\n}\n\nint __kmp_aux_get_team_num() {\n  int serialized;\n  kmp_team_t *team = __kmp_aux_get_team_info(serialized);\n  if (team) {\n    if (serialized > 1) {\n      return 0; // teams region is serialized ( 1 team of 1 thread ).\n    } else {\n      return team->t.t_master_tid;\n    }\n  }\n  return 0;\n}\n\nint __kmp_aux_get_num_teams() {\n  int serialized;\n  kmp_team_t *team = __kmp_aux_get_team_info(serialized);\n  if (team) {\n    if (serialized > 1) {\n      return 1;\n    } else {\n      return team->t.t_parent->t.t_nproc;\n    }\n  }\n  return 1;\n}\n\n/* ------------------------------------------------------------------------ */\n\n/*\n * Affinity Format Parser\n *\n * Field is in form of: %[[[0].]size]type\n * % and type are required (%% means print a literal '%')\n * type is either single char or long name surrounded by {},\n * e.g., N or {num_threads}\n * 0 => leading zeros\n * . => right justified when size is specified\n * by default output is left justified\n * size is the *minimum* field length\n * All other characters are printed as is\n *\n * Available field types:\n * L {thread_level}      - omp_get_level()\n * n {thread_num}        - omp_get_thread_num()\n * h {host}              - name of host machine\n * P {process_id}        - process id (integer)\n * T {thread_identifier} - native thread identifier (integer)\n * N {num_threads}       - omp_get_num_threads()\n * A {ancestor_tnum}     - omp_get_ancestor_thread_num(omp_get_level()-1)\n * a {thread_affinity}   - comma separated list of integers or integer ranges\n *                         (values of affinity mask)\n *\n * Implementation-specific field types can be added\n * If a type is unknown, print \"undefined\"\n */\n\n// Structure holding the short name, long name, and corresponding data type\n// for snprintf.  A table of these will represent the entire valid keyword\n// field types.\ntypedef struct kmp_affinity_format_field_t {\n  char short_name; // from spec e.g., L -> thread level\n  const char *long_name; // from spec thread_level -> thread level\n  char field_format; // data type for snprintf (typically 'd' or 's'\n  // for integer or string)\n} kmp_affinity_format_field_t;\n\nstatic const kmp_affinity_format_field_t __kmp_affinity_format_table[] = {\n#if KMP_AFFINITY_SUPPORTED\n    {'A', \"thread_affinity\", 's'},\n#endif\n    {'t', \"team_num\", 'd'},\n    {'T', \"num_teams\", 'd'},\n    {'L', \"nesting_level\", 'd'},\n    {'n', \"thread_num\", 'd'},\n    {'N', \"num_threads\", 'd'},\n    {'a', \"ancestor_tnum\", 'd'},\n    {'H', \"host\", 's'},\n    {'P', \"process_id\", 'd'},\n    {'i', \"native_thread_id\", 'd'}};\n\n// Return the number of characters it takes to hold field\nstatic int __kmp_aux_capture_affinity_field(int gtid, const kmp_info_t *th,\n                                            const char **ptr,\n                                            kmp_str_buf_t *field_buffer) {\n  int rc, format_index, field_value;\n  const char *width_left, *width_right;\n  bool pad_zeros, right_justify, parse_long_name, found_valid_name;\n  static const int FORMAT_SIZE = 20;\n  char format[FORMAT_SIZE] = {0};\n  char absolute_short_name = 0;\n\n  KMP_DEBUG_ASSERT(gtid >= 0);\n  KMP_DEBUG_ASSERT(th);\n  KMP_DEBUG_ASSERT(**ptr == '%');\n  KMP_DEBUG_ASSERT(field_buffer);\n\n  __kmp_str_buf_clear(field_buffer);\n\n  // Skip the initial %\n  (*ptr)++;\n\n  // Check for %% first\n  if (**ptr == '%') {\n    __kmp_str_buf_cat(field_buffer, \"%\", 1);\n    (*ptr)++; // skip over the second %\n    return 1;\n  }\n\n  // Parse field modifiers if they are present\n  pad_zeros = false;\n  if (**ptr == '0') {\n    pad_zeros = true;\n    (*ptr)++; // skip over 0\n  }\n  right_justify = false;\n  if (**ptr == '.') {\n    right_justify = true;\n    (*ptr)++; // skip over .\n  }\n  // Parse width of field: [width_left, width_right)\n  width_left = width_right = NULL;\n  if (**ptr >= '0' && **ptr <= '9') {\n    width_left = *ptr;\n    SKIP_DIGITS(*ptr);\n    width_right = *ptr;\n  }\n\n  // Create the format for KMP_SNPRINTF based on flags parsed above\n  format_index = 0;\n  format[format_index++] = '%';\n  if (!right_justify)\n    format[format_index++] = '-';\n  if (pad_zeros)\n    format[format_index++] = '0';\n  if (width_left && width_right) {\n    int i = 0;\n    // Only allow 8 digit number widths.\n    // This also prevents overflowing format variable\n    while (i < 8 && width_left < width_right) {\n      format[format_index++] = *width_left;\n      width_left++;\n      i++;\n    }\n  }\n\n  // Parse a name (long or short)\n  // Canonicalize the name into absolute_short_name\n  found_valid_name = false;\n  parse_long_name = (**ptr == '{');\n  if (parse_long_name)\n    (*ptr)++; // skip initial left brace\n  for (size_t i = 0; i < sizeof(__kmp_affinity_format_table) /\n                             sizeof(__kmp_affinity_format_table[0]);\n       ++i) {\n    char short_name = __kmp_affinity_format_table[i].short_name;\n    const char *long_name = __kmp_affinity_format_table[i].long_name;\n    char field_format = __kmp_affinity_format_table[i].field_format;\n    if (parse_long_name) {\n      size_t length = KMP_STRLEN(long_name);\n      if (strncmp(*ptr, long_name, length) == 0) {\n        found_valid_name = true;\n        (*ptr) += length; // skip the long name\n      }\n    } else if (**ptr == short_name) {\n      found_valid_name = true;\n      (*ptr)++; // skip the short name\n    }\n    if (found_valid_name) {\n      format[format_index++] = field_format;\n      format[format_index++] = '\\0';\n      absolute_short_name = short_name;\n      break;\n    }\n  }\n  if (parse_long_name) {\n    if (**ptr != '}') {\n      absolute_short_name = 0;\n    } else {\n      (*ptr)++; // skip over the right brace\n    }\n  }\n\n  // Attempt to fill the buffer with the requested\n  // value using snprintf within __kmp_str_buf_print()\n  switch (absolute_short_name) {\n  case 't':\n    rc = __kmp_str_buf_print(field_buffer, format, __kmp_aux_get_team_num());\n    break;\n  case 'T':\n    rc = __kmp_str_buf_print(field_buffer, format, __kmp_aux_get_num_teams());\n    break;\n  case 'L':\n    rc = __kmp_str_buf_print(field_buffer, format, th->th.th_team->t.t_level);\n    break;\n  case 'n':\n    rc = __kmp_str_buf_print(field_buffer, format, __kmp_tid_from_gtid(gtid));\n    break;\n  case 'H': {\n    static const int BUFFER_SIZE = 256;\n    char buf[BUFFER_SIZE];\n    __kmp_expand_host_name(buf, BUFFER_SIZE);\n    rc = __kmp_str_buf_print(field_buffer, format, buf);\n  } break;\n  case 'P':\n    rc = __kmp_str_buf_print(field_buffer, format, getpid());\n    break;\n  case 'i':\n    rc = __kmp_str_buf_print(field_buffer, format, __kmp_gettid());\n    break;\n  case 'N':\n    rc = __kmp_str_buf_print(field_buffer, format, th->th.th_team->t.t_nproc);\n    break;\n  case 'a':\n    field_value =\n        __kmp_get_ancestor_thread_num(gtid, th->th.th_team->t.t_level - 1);\n    rc = __kmp_str_buf_print(field_buffer, format, field_value);\n    break;\n#if KMP_AFFINITY_SUPPORTED\n  case 'A': {\n    kmp_str_buf_t buf;\n    __kmp_str_buf_init(&buf);\n    __kmp_affinity_str_buf_mask(&buf, th->th.th_affin_mask);\n    rc = __kmp_str_buf_print(field_buffer, format, buf.str);\n    __kmp_str_buf_free(&buf);\n  } break;\n#endif\n  default:\n    // According to spec, If an implementation does not have info for field\n    // type, then \"undefined\" is printed\n    rc = __kmp_str_buf_print(field_buffer, \"%s\", \"undefined\");\n    // Skip the field\n    if (parse_long_name) {\n      SKIP_TOKEN(*ptr);\n      if (**ptr == '}')\n        (*ptr)++;\n    } else {\n      (*ptr)++;\n    }\n  }\n\n  KMP_ASSERT(format_index <= FORMAT_SIZE);\n  return rc;\n}\n\n/*\n * Return number of characters needed to hold the affinity string\n * (not including null byte character)\n * The resultant string is printed to buffer, which the caller can then\n * handle afterwards\n */\nsize_t __kmp_aux_capture_affinity(int gtid, const char *format,\n                                  kmp_str_buf_t *buffer) {\n  const char *parse_ptr;\n  size_t retval;\n  const kmp_info_t *th;\n  kmp_str_buf_t field;\n\n  KMP_DEBUG_ASSERT(buffer);\n  KMP_DEBUG_ASSERT(gtid >= 0);\n\n  __kmp_str_buf_init(&field);\n  __kmp_str_buf_clear(buffer);\n\n  th = __kmp_threads[gtid];\n  retval = 0;\n\n  // If format is NULL or zero-length string, then we use\n  // affinity-format-var ICV\n  parse_ptr = format;\n  if (parse_ptr == NULL || *parse_ptr == '\\0') {\n    parse_ptr = __kmp_affinity_format;\n  }\n  KMP_DEBUG_ASSERT(parse_ptr);\n\n  while (*parse_ptr != '\\0') {\n    // Parse a field\n    if (*parse_ptr == '%') {\n      // Put field in the buffer\n      int rc = __kmp_aux_capture_affinity_field(gtid, th, &parse_ptr, &field);\n      __kmp_str_buf_catbuf(buffer, &field);\n      retval += rc;\n    } else {\n      // Put literal character in buffer\n      __kmp_str_buf_cat(buffer, parse_ptr, 1);\n      retval++;\n      parse_ptr++;\n    }\n  }\n  __kmp_str_buf_free(&field);\n  return retval;\n}\n\n// Displays the affinity string to stdout\nvoid __kmp_aux_display_affinity(int gtid, const char *format) {\n  kmp_str_buf_t buf;\n  __kmp_str_buf_init(&buf);\n  __kmp_aux_capture_affinity(gtid, format, &buf);\n  __kmp_fprintf(kmp_out, \"%s\" KMP_END_OF_LINE, buf.str);\n  __kmp_str_buf_free(&buf);\n}\n\n/* ------------------------------------------------------------------------ */\n\nvoid __kmp_aux_set_blocktime(int arg, kmp_info_t *thread, int tid) {\n  int blocktime = arg; /* argument is in milliseconds */\n#if KMP_USE_MONITOR\n  int bt_intervals;\n#endif\n  kmp_int8 bt_set;\n\n  __kmp_save_internal_controls(thread);\n\n  /* Normalize and set blocktime for the teams */\n  if (blocktime < KMP_MIN_BLOCKTIME)\n    blocktime = KMP_MIN_BLOCKTIME;\n  else if (blocktime > KMP_MAX_BLOCKTIME)\n    blocktime = KMP_MAX_BLOCKTIME;\n\n  set__blocktime_team(thread->th.th_team, tid, blocktime);\n  set__blocktime_team(thread->th.th_serial_team, 0, blocktime);\n\n#if KMP_USE_MONITOR\n  /* Calculate and set blocktime intervals for the teams */\n  bt_intervals = KMP_INTERVALS_FROM_BLOCKTIME(blocktime, __kmp_monitor_wakeups);\n\n  set__bt_intervals_team(thread->th.th_team, tid, bt_intervals);\n  set__bt_intervals_team(thread->th.th_serial_team, 0, bt_intervals);\n#endif\n\n  /* Set whether blocktime has been set to \"TRUE\" */\n  bt_set = TRUE;\n\n  set__bt_set_team(thread->th.th_team, tid, bt_set);\n  set__bt_set_team(thread->th.th_serial_team, 0, bt_set);\n#if KMP_USE_MONITOR\n  KF_TRACE(10, (\"kmp_set_blocktime: T#%d(%d:%d), blocktime=%d, \"\n                \"bt_intervals=%d, monitor_updates=%d\\n\",\n                __kmp_gtid_from_tid(tid, thread->th.th_team),\n                thread->th.th_team->t.t_id, tid, blocktime, bt_intervals,\n                __kmp_monitor_wakeups));\n#else\n  KF_TRACE(10, (\"kmp_set_blocktime: T#%d(%d:%d), blocktime=%d\\n\",\n                __kmp_gtid_from_tid(tid, thread->th.th_team),\n                thread->th.th_team->t.t_id, tid, blocktime));\n#endif\n}\n\nvoid __kmp_aux_set_defaults(char const *str, size_t len) {\n  if (!__kmp_init_serial) {\n    __kmp_serial_initialize();\n  }\n  __kmp_env_initialize(str);\n\n  if (__kmp_settings || __kmp_display_env || __kmp_display_env_verbose) {\n    __kmp_env_print();\n  }\n} // __kmp_aux_set_defaults\n\n/* ------------------------------------------------------------------------ */\n/* internal fast reduction routines */\n\nPACKED_REDUCTION_METHOD_T\n__kmp_determine_reduction_method(\n    ident_t *loc, kmp_int32 global_tid, kmp_int32 num_vars, size_t reduce_size,\n    void *reduce_data, void (*reduce_func)(void *lhs_data, void *rhs_data),\n    kmp_critical_name *lck) {\n\n  // Default reduction method: critical construct ( lck != NULL, like in current\n  // PAROPT )\n  // If ( reduce_data!=NULL && reduce_func!=NULL ): the tree-reduction method\n  // can be selected by RTL\n  // If loc->flags contains KMP_IDENT_ATOMIC_REDUCE, the atomic reduce method\n  // can be selected by RTL\n  // Finally, it's up to OpenMP RTL to make a decision on which method to select\n  // among generated by PAROPT.\n\n  PACKED_REDUCTION_METHOD_T retval;\n\n  int team_size;\n\n  KMP_DEBUG_ASSERT(loc); // it would be nice to test ( loc != 0 )\n  KMP_DEBUG_ASSERT(lck); // it would be nice to test ( lck != 0 )\n\n#define FAST_REDUCTION_ATOMIC_METHOD_GENERATED                                 \\\n  ((loc->flags & (KMP_IDENT_ATOMIC_REDUCE)) == (KMP_IDENT_ATOMIC_REDUCE))\n#define FAST_REDUCTION_TREE_METHOD_GENERATED ((reduce_data) && (reduce_func))\n\n  retval = critical_reduce_block;\n\n  // another choice of getting a team size (with 1 dynamic deference) is slower\n  team_size = __kmp_get_team_num_threads(global_tid);\n  if (team_size == 1) {\n\n    retval = empty_reduce_block;\n\n  } else {\n\n    int atomic_available = FAST_REDUCTION_ATOMIC_METHOD_GENERATED;\n\n#if KMP_ARCH_X86_64 || KMP_ARCH_PPC64 || KMP_ARCH_AARCH64 ||                   \\\n    KMP_ARCH_MIPS64 || KMP_ARCH_RISCV64\n\n#if KMP_OS_LINUX || KMP_OS_DRAGONFLY || KMP_OS_FREEBSD || KMP_OS_NETBSD ||     \\\n    KMP_OS_OPENBSD || KMP_OS_WINDOWS || KMP_OS_DARWIN || KMP_OS_HURD\n\n    int teamsize_cutoff = 4;\n\n#if KMP_MIC_SUPPORTED\n    if (__kmp_mic_type != non_mic) {\n      teamsize_cutoff = 8;\n    }\n#endif\n    int tree_available = FAST_REDUCTION_TREE_METHOD_GENERATED;\n    if (tree_available) {\n      if (team_size <= teamsize_cutoff) {\n        if (atomic_available) {\n          retval = atomic_reduce_block;\n        }\n      } else {\n        retval = TREE_REDUCE_BLOCK_WITH_REDUCTION_BARRIER;\n      }\n    } else if (atomic_available) {\n      retval = atomic_reduce_block;\n    }\n#else\n#error \"Unknown or unsupported OS\"\n#endif // KMP_OS_LINUX || KMP_OS_DRAGONFLY || KMP_OS_FREEBSD || KMP_OS_NETBSD ||\n       // KMP_OS_OPENBSD || KMP_OS_WINDOWS || KMP_OS_DARWIN || KMP_OS_HURD\n\n#elif KMP_ARCH_X86 || KMP_ARCH_ARM || KMP_ARCH_AARCH || KMP_ARCH_MIPS\n\n#if KMP_OS_LINUX || KMP_OS_FREEBSD || KMP_OS_WINDOWS || KMP_OS_HURD\n\n    // basic tuning\n\n    if (atomic_available) {\n      if (num_vars <= 2) { // && ( team_size <= 8 ) due to false-sharing ???\n        retval = atomic_reduce_block;\n      }\n    } // otherwise: use critical section\n\n#elif KMP_OS_DARWIN\n\n    int tree_available = FAST_REDUCTION_TREE_METHOD_GENERATED;\n    if (atomic_available && (num_vars <= 3)) {\n      retval = atomic_reduce_block;\n    } else if (tree_available) {\n      if ((reduce_size > (9 * sizeof(kmp_real64))) &&\n          (reduce_size < (2000 * sizeof(kmp_real64)))) {\n        retval = TREE_REDUCE_BLOCK_WITH_PLAIN_BARRIER;\n      }\n    } // otherwise: use critical section\n\n#else\n#error \"Unknown or unsupported OS\"\n#endif\n\n#else\n#error \"Unknown or unsupported architecture\"\n#endif\n  }\n\n  // KMP_FORCE_REDUCTION\n\n  // If the team is serialized (team_size == 1), ignore the forced reduction\n  // method and stay with the unsynchronized method (empty_reduce_block)\n  if (__kmp_force_reduction_method != reduction_method_not_defined &&\n      team_size != 1) {\n\n    PACKED_REDUCTION_METHOD_T forced_retval = critical_reduce_block;\n\n    int atomic_available, tree_available;\n\n    switch ((forced_retval = __kmp_force_reduction_method)) {\n    case critical_reduce_block:\n      KMP_ASSERT(lck); // lck should be != 0\n      break;\n\n    case atomic_reduce_block:\n      atomic_available = FAST_REDUCTION_ATOMIC_METHOD_GENERATED;\n      if (!atomic_available) {\n        KMP_WARNING(RedMethodNotSupported, \"atomic\");\n        forced_retval = critical_reduce_block;\n      }\n      break;\n\n    case tree_reduce_block:\n      tree_available = FAST_REDUCTION_TREE_METHOD_GENERATED;\n      if (!tree_available) {\n        KMP_WARNING(RedMethodNotSupported, \"tree\");\n        forced_retval = critical_reduce_block;\n      } else {\n#if KMP_FAST_REDUCTION_BARRIER\n        forced_retval = TREE_REDUCE_BLOCK_WITH_REDUCTION_BARRIER;\n#endif\n      }\n      break;\n\n    default:\n      KMP_ASSERT(0); // \"unsupported method specified\"\n    }\n\n    retval = forced_retval;\n  }\n\n  KA_TRACE(10, (\"reduction method selected=%08x\\n\", retval));\n\n#undef FAST_REDUCTION_TREE_METHOD_GENERATED\n#undef FAST_REDUCTION_ATOMIC_METHOD_GENERATED\n\n  return (retval);\n}\n// this function is for testing set/get/determine reduce method\nkmp_int32 __kmp_get_reduce_method(void) {\n  return ((__kmp_entry_thread()->th.th_local.packed_reduction_method) >> 8);\n}\n\n// Soft pause sets up threads to ignore blocktime and just go to sleep.\n// Spin-wait code checks __kmp_pause_status and reacts accordingly.\nvoid __kmp_soft_pause() { __kmp_pause_status = kmp_soft_paused; }\n\n// Hard pause shuts down the runtime completely.  Resume happens naturally when\n// OpenMP is used subsequently.\nvoid __kmp_hard_pause() {\n  __kmp_pause_status = kmp_hard_paused;\n  __kmp_internal_end_thread(-1);\n}\n\n// Soft resume sets __kmp_pause_status, and wakes up all threads.\nvoid __kmp_resume_if_soft_paused() {\n  if (__kmp_pause_status == kmp_soft_paused) {\n    __kmp_pause_status = kmp_not_paused;\n\n    for (int gtid = 1; gtid < __kmp_threads_capacity; ++gtid) {\n      kmp_info_t *thread = __kmp_threads[gtid];\n      if (thread) { // Wake it if sleeping\n        kmp_flag_64<> fl(&thread->th.th_bar[bs_forkjoin_barrier].bb.b_go,\n                         thread);\n        if (fl.is_sleeping())\n          fl.resume(gtid);\n        else if (__kmp_try_suspend_mx(thread)) { // got suspend lock\n          __kmp_unlock_suspend_mx(thread); // unlock it; it won't sleep\n        } else { // thread holds the lock and may sleep soon\n          do { // until either the thread sleeps, or we can get the lock\n            if (fl.is_sleeping()) {\n              fl.resume(gtid);\n              break;\n            } else if (__kmp_try_suspend_mx(thread)) {\n              __kmp_unlock_suspend_mx(thread);\n              break;\n            }\n          } while (1);\n        }\n      }\n    }\n  }\n}\n\n// This function is called via __kmpc_pause_resource. Returns 0 if successful.\n// TODO: add warning messages\nint __kmp_pause_resource(kmp_pause_status_t level) {\n  if (level == kmp_not_paused) { // requesting resume\n    if (__kmp_pause_status == kmp_not_paused) {\n      // error message about runtime not being paused, so can't resume\n      return 1;\n    } else {\n      KMP_DEBUG_ASSERT(__kmp_pause_status == kmp_soft_paused ||\n                       __kmp_pause_status == kmp_hard_paused);\n      __kmp_pause_status = kmp_not_paused;\n      return 0;\n    }\n  } else if (level == kmp_soft_paused) { // requesting soft pause\n    if (__kmp_pause_status != kmp_not_paused) {\n      // error message about already being paused\n      return 1;\n    } else {\n      __kmp_soft_pause();\n      return 0;\n    }\n  } else if (level == kmp_hard_paused) { // requesting hard pause\n    if (__kmp_pause_status != kmp_not_paused) {\n      // error message about already being paused\n      return 1;\n    } else {\n      __kmp_hard_pause();\n      return 0;\n    }\n  } else {\n    // error message about invalid level\n    return 1;\n  }\n}\n\nvoid __kmp_omp_display_env(int verbose) {\n  __kmp_acquire_bootstrap_lock(&__kmp_initz_lock);\n  if (__kmp_init_serial == 0)\n    __kmp_do_serial_initialize();\n  __kmp_display_env_impl(!verbose, verbose);\n  __kmp_release_bootstrap_lock(&__kmp_initz_lock);\n}\n\n// Globals and functions for hidden helper task\nkmp_info_t **__kmp_hidden_helper_threads;\nkmp_info_t *__kmp_hidden_helper_main_thread;\nkmp_int32 __kmp_hidden_helper_threads_num = 8;\nstd::atomic<kmp_int32> __kmp_unexecuted_hidden_helper_tasks;\n#if KMP_OS_LINUX\nkmp_int32 __kmp_enable_hidden_helper = TRUE;\n#else\nkmp_int32 __kmp_enable_hidden_helper = FALSE;\n#endif\n\nnamespace {\nstd::atomic<kmp_int32> __kmp_hit_hidden_helper_threads_num;\n\nvoid __kmp_hidden_helper_wrapper_fn(int *gtid, int *, ...) {\n  // This is an explicit synchronization on all hidden helper threads in case\n  // that when a regular thread pushes a hidden helper task to one hidden\n  // helper thread, the thread has not been awaken once since they're released\n  // by the main thread after creating the team.\n  KMP_ATOMIC_INC(&__kmp_hit_hidden_helper_threads_num);\n  while (KMP_ATOMIC_LD_ACQ(&__kmp_hit_hidden_helper_threads_num) !=\n         __kmp_hidden_helper_threads_num)\n    ;\n\n  // If main thread, then wait for signal\n  if (__kmpc_master(nullptr, *gtid)) {\n    // First, unset the initial state and release the initial thread\n    TCW_4(__kmp_init_hidden_helper_threads, FALSE);\n    __kmp_hidden_helper_initz_release();\n    __kmp_hidden_helper_main_thread_wait();\n    // Now wake up all worker threads\n    for (int i = 1; i < __kmp_hit_hidden_helper_threads_num; ++i) {\n      __kmp_hidden_helper_worker_thread_signal();\n    }\n  }\n}\n} // namespace\n\nvoid __kmp_hidden_helper_threads_initz_routine() {\n  // Create a new root for hidden helper team/threads\n  const int gtid = __kmp_register_root(TRUE);\n  __kmp_hidden_helper_main_thread = __kmp_threads[gtid];\n  __kmp_hidden_helper_threads = &__kmp_threads[gtid];\n  __kmp_hidden_helper_main_thread->th.th_set_nproc =\n      __kmp_hidden_helper_threads_num;\n\n  KMP_ATOMIC_ST_REL(&__kmp_hit_hidden_helper_threads_num, 0);\n\n  __kmpc_fork_call(nullptr, 0, __kmp_hidden_helper_wrapper_fn);\n\n  // Set the initialization flag to FALSE\n  TCW_SYNC_4(__kmp_init_hidden_helper, FALSE);\n\n  __kmp_hidden_helper_threads_deinitz_release();\n}\n"}, "7": {"id": 7, "path": "/home/vsts/work/1/llvm-project/openmp/runtime/src/ompt-internal.h", "content": "/*\n * ompt-internal.h - header of OMPT internal data structures\n */\n\n//===----------------------------------------------------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef __OMPT_INTERNAL_H__\n#define __OMPT_INTERNAL_H__\n\n#include \"ompt-event-specific.h\"\n#include \"omp-tools.h\"\n\n#define OMPT_VERSION 1\n\n#define _OMP_EXTERN extern \"C\"\n\n#define OMPT_INVOKER(x)                                                        \\\n  ((x == fork_context_gnu) ? ompt_parallel_invoker_program                     \\\n                           : ompt_parallel_invoker_runtime)\n\n#define ompt_callback(e) e##_callback\n\ntypedef struct ompt_callbacks_internal_s {\n#define ompt_event_macro(event, callback, eventid)                             \\\n  callback ompt_callback(event);\n\n  FOREACH_OMPT_EVENT(ompt_event_macro)\n\n#undef ompt_event_macro\n} ompt_callbacks_internal_t;\n\ntypedef struct ompt_callbacks_active_s {\n  unsigned int enabled : 1;\n#define ompt_event_macro(event, callback, eventid) unsigned int event : 1;\n\n  FOREACH_OMPT_EVENT(ompt_event_macro)\n\n#undef ompt_event_macro\n} ompt_callbacks_active_t;\n\n#define TASK_TYPE_DETAILS_FORMAT(info)                                         \\\n  ((info->td_flags.task_serial || info->td_flags.tasking_ser)                  \\\n       ? ompt_task_undeferred                                                  \\\n       : 0x0) |                                                                \\\n      ((!(info->td_flags.tiedness)) ? ompt_task_untied : 0x0) |                \\\n      (info->td_flags.final ? ompt_task_final : 0x0) |                         \\\n      (info->td_flags.merged_if0 ? ompt_task_mergeable : 0x0)\n\ntypedef struct {\n  ompt_frame_t frame;\n  ompt_data_t task_data;\n  struct kmp_taskdata *scheduling_parent;\n  int thread_num;\n} ompt_task_info_t;\n\ntypedef struct {\n  ompt_data_t parallel_data;\n  void *master_return_address;\n} ompt_team_info_t;\n\ntypedef struct ompt_lw_taskteam_s {\n  ompt_team_info_t ompt_team_info;\n  ompt_task_info_t ompt_task_info;\n  int heap;\n  struct ompt_lw_taskteam_s *parent;\n} ompt_lw_taskteam_t;\n\ntypedef struct {\n  ompt_data_t thread_data;\n  ompt_data_t task_data; /* stored here from implicit barrier-begin until\n                            implicit-task-end */\n  void *return_address; /* stored here on entry of runtime */\n  ompt_state_t state;\n  ompt_wait_id_t wait_id;\n  int ompt_task_yielded;\n  int parallel_flags; // information for the last parallel region invoked\n  void *idle_frame;\n} ompt_thread_info_t;\n\nextern ompt_callbacks_internal_t ompt_callbacks;\n\n#if OMPT_SUPPORT && OMPT_OPTIONAL\n#if USE_FAST_MEMORY\n#define KMP_OMPT_DEPS_ALLOC __kmp_fast_allocate\n#define KMP_OMPT_DEPS_FREE __kmp_fast_free\n#else\n#define KMP_OMPT_DEPS_ALLOC __kmp_thread_malloc\n#define KMP_OMPT_DEPS_FREE __kmp_thread_free\n#endif\n#endif /* OMPT_SUPPORT && OMPT_OPTIONAL */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nvoid ompt_pre_init(void);\nvoid ompt_post_init(void);\nvoid ompt_fini(void);\n\n#define OMPT_GET_RETURN_ADDRESS(level) __builtin_return_address(level)\n#define OMPT_GET_FRAME_ADDRESS(level) __builtin_frame_address(level)\n\nint __kmp_control_tool(uint64_t command, uint64_t modifier, void *arg);\n\nextern ompt_callbacks_active_t ompt_enabled;\n\n#if KMP_OS_WINDOWS\n#define UNLIKELY(x) (x)\n#define OMPT_NOINLINE __declspec(noinline)\n#else\n#define UNLIKELY(x) __builtin_expect(!!(x), 0)\n#define OMPT_NOINLINE __attribute__((noinline))\n#endif\n\n#ifdef __cplusplus\n};\n#endif\n\n#endif\n"}}, "reports": [{"events": [{"location": {"col": 15, "file": 0, "line": 494}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/build/projects/openmp/runtime/src/omp-tools.h", "reportHash": "9dcd10a054da7c801f8725e48025ea60", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 16, "file": 0, "line": 499}, "message": "default constructor 'ompt_frame_t' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/build/projects/openmp/runtime/src/omp-tools.h", "reportHash": "14f33891369de7bc06cce5d07050b895", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 1, "line": 487}, "message": "default constructor 'kmp_r_sched' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/openmp/runtime/src/kmp.h", "reportHash": "217582a60bd63aff5dc82f0d265fa05b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 1, "line": 487}, "message": "destructor '~kmp_r_sched' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/openmp/runtime/src/kmp.h", "reportHash": "682d40ce51bf4a5e573b47283d6f8f56", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 1, "line": 487}, "message": "move constructor 'kmp_r_sched' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/openmp/runtime/src/kmp.h", "reportHash": "0e56dab06e4b52e763dcae1cfa563e7d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 1, "line": 488}, "message": "default constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/openmp/runtime/src/kmp.h", "reportHash": "6b268b385eea7748730357483ad7e5ef", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 1, "line": 488}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/openmp/runtime/src/kmp.h", "reportHash": "6735adc3e1823a43cac97b23693d46b6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 1, "line": 488}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/openmp/runtime/src/kmp.h", "reportHash": "20c4553889c630ba7873ffd05783549a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 16, "file": 1, "line": 1931}, "message": "default constructor 'kmp_internal_control' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/openmp/runtime/src/kmp.h", "reportHash": "0c9163d728105a98ea4d47fdd8e6ca65", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 16, "file": 1, "line": 1931}, "message": "destructor '~kmp_internal_control' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/openmp/runtime/src/kmp.h", "reportHash": "04c5c26ef07b5f87f0b173fc23d85a89", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 16, "file": 1, "line": 1931}, "message": "move constructor 'kmp_internal_control' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/openmp/runtime/src/kmp.h", "reportHash": "e40d76eea91cd8e9bb1ffc2dd482071a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 4, "line": 6407}, "message": "default constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/openmp/runtime/src/kmp_runtime.cpp", "reportHash": "16c0719182f890a8a6915d7d0a542076", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 16, "file": 4, "line": 8090}, "message": "destructor '~kmp_affinity_format_field_t' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/openmp/runtime/src/kmp_runtime.cpp", "reportHash": "aff4bff44bcf5d3640ab84c1964e8688", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 7, "line": 55}, "message": "default constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/openmp/runtime/src/ompt-internal.h", "reportHash": "8e6a04117413f384f523276db8e23497", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 7, "line": 62}, "message": "default constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/openmp/runtime/src/ompt-internal.h", "reportHash": "8e6a04117413f384f523276db8e23497", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 16, "file": 7, "line": 67}, "message": "default constructor 'ompt_lw_taskteam_s' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/openmp/runtime/src/ompt-internal.h", "reportHash": "6a4df4cd911bddf09be6f84817122c74", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
