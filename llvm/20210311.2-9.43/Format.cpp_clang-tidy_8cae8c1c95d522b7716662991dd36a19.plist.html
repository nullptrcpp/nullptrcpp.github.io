<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/CommentOptions.h", "content": "//===- CommentOptions.h - Options for parsing comments ----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n/// Defines the clang::CommentOptions interface.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_BASIC_COMMENTOPTIONS_H\n#define LLVM_CLANG_BASIC_COMMENTOPTIONS_H\n\n#include <string>\n#include <vector>\n\nnamespace clang {\n\n/// Options for controlling comment parsing.\nstruct CommentOptions {\n  using BlockCommandNamesTy = std::vector<std::string>;\n\n  /// Command names to treat as block commands in comments.\n  /// Should not include the leading backslash.\n  BlockCommandNamesTy BlockCommandNames;\n\n  /// Treat ordinary comments as documentation comments.\n  bool ParseAllComments = false;\n\n  CommentOptions() = default;\n};\n\n} // namespace clang\n\n#endif // LLVM_CLANG_BASIC_COMMENTOPTIONS_H\n"}, "12": {"id": 12, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Format/Format.h", "content": "//===--- Format.h - Format C++ code -----------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n///\n/// \\file\n/// Various functions to configurably format source code.\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_FORMAT_FORMAT_H\n#define LLVM_CLANG_FORMAT_FORMAT_H\n\n#include \"clang/Basic/LangOptions.h\"\n#include \"clang/Tooling/Core/Replacement.h\"\n#include \"clang/Tooling/Inclusions/IncludeStyle.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/Support/Regex.h\"\n#include \"llvm/Support/SourceMgr.h\"\n#include <system_error>\n\nnamespace llvm {\nnamespace vfs {\nclass FileSystem;\n}\n} // namespace llvm\n\nnamespace clang {\n\nclass Lexer;\nclass SourceManager;\nclass DiagnosticConsumer;\n\nnamespace format {\n\nenum class ParseError {\n  Success = 0,\n  Error,\n  Unsuitable,\n  BinPackTrailingCommaConflict\n};\nclass ParseErrorCategory final : public std::error_category {\npublic:\n  const char *name() const noexcept override;\n  std::string message(int EV) const override;\n};\nconst std::error_category &getParseCategory();\nstd::error_code make_error_code(ParseError e);\n\n/// The ``FormatStyle`` is used to configure the formatting to follow\n/// specific guidelines.\nstruct FormatStyle {\n  // If the BasedOn: was InheritParentConfig and this style needs the file from\n  // the parent directories. It is not part of the actual style for formatting.\n  // Thus the // instead of ///.\n  bool InheritsParentConfig;\n\n  /// The extra indent or outdent of access modifiers, e.g. ``public:``.\n  int AccessModifierOffset;\n\n  /// Different styles for aligning after open brackets.\n  enum BracketAlignmentStyle : unsigned char {\n    /// Align parameters on the open bracket, e.g.:\n    /// \\code\n    ///   someLongFunction(argument1,\n    ///                    argument2);\n    /// \\endcode\n    BAS_Align,\n    /// Don't align, instead use ``ContinuationIndentWidth``, e.g.:\n    /// \\code\n    ///   someLongFunction(argument1,\n    ///       argument2);\n    /// \\endcode\n    BAS_DontAlign,\n    /// Always break after an open bracket, if the parameters don't fit\n    /// on a single line, e.g.:\n    /// \\code\n    ///   someLongFunction(\n    ///       argument1, argument2);\n    /// \\endcode\n    BAS_AlwaysBreak,\n  };\n\n  /// If ``true``, horizontally aligns arguments after an open bracket.\n  ///\n  /// This applies to round brackets (parentheses), angle brackets and square\n  /// brackets.\n  BracketAlignmentStyle AlignAfterOpenBracket;\n\n  /// Styles for alignment of consecutive tokens. Tokens can be assignment signs\n  /// (see\n  /// ``AlignConsecutiveAssignments``), bitfield member separators (see\n  /// ``AlignConsecutiveBitFields``), names in declarations (see\n  /// ``AlignConsecutiveDeclarations``) or macro definitions (see\n  /// ``AlignConsecutiveMacros``).\n  enum AlignConsecutiveStyle {\n    ACS_None,\n    ACS_Consecutive,\n    ACS_AcrossEmptyLines,\n    ACS_AcrossComments,\n    ACS_AcrossEmptyLinesAndComments\n  };\n\n  /// Style of aligning consecutive macro definitions.\n  ///\n  /// ``Consecutive`` will result in formattings like:\n  /// \\code\n  ///   #define SHORT_NAME       42\n  ///   #define LONGER_NAME      0x007f\n  ///   #define EVEN_LONGER_NAME (2)\n  ///   #define foo(x)           (x * x)\n  ///   #define bar(y, z)        (y + z)\n  /// \\endcode\n  ///\n  /// Possible values:\n  ///\n  /// * ``ACS_None`` (in configuration: ``None``)\n  ///    Do not align macro definitions on consecutive lines.\n  ///\n  /// * ``ACS_Consecutive`` (in configuration: ``Consecutive``)\n  ///    Align macro definitions on consecutive lines. This will result in\n  ///    formattings like:\n  ///    \\code\n  ///      #define SHORT_NAME       42\n  ///      #define LONGER_NAME      0x007f\n  ///      #define EVEN_LONGER_NAME (2)\n  ///\n  ///      #define foo(x) (x * x)\n  ///      /* some comment */\n  ///      #define bar(y, z) (y + z)\n  ///    \\endcode\n  ///\n  /// * ``ACS_AcrossEmptyLines`` (in configuration: ``AcrossEmptyLines``)\n  ///    Same as ACS_Consecutive, but also spans over empty lines, e.g.\n  ///    \\code\n  ///      #define SHORT_NAME       42\n  ///      #define LONGER_NAME      0x007f\n  ///      #define EVEN_LONGER_NAME (2)\n  ///\n  ///      #define foo(x)           (x * x)\n  ///      /* some comment */\n  ///      #define bar(y, z) (y + z)\n  ///    \\endcode\n  ///\n  /// * ``ACS_AcrossComments`` (in configuration: ``AcrossComments``)\n  ///    Same as ACS_Consecutive, but also spans over lines only containing\n  ///    comments, e.g.\n  ///    \\code\n  ///      #define SHORT_NAME       42\n  ///      #define LONGER_NAME      0x007f\n  ///      #define EVEN_LONGER_NAME (2)\n  ///\n  ///      #define foo(x)    (x * x)\n  ///      /* some comment */\n  ///      #define bar(y, z) (y + z)\n  ///    \\endcode\n  ///\n  /// * ``ACS_AcrossEmptyLinesAndComments``\n  ///   (in configuration: ``AcrossEmptyLinesAndComments``)\n  ///\n  ///    Same as ACS_Consecutive, but also spans over lines only containing\n  ///    comments and empty lines, e.g.\n  ///    \\code\n  ///      #define SHORT_NAME       42\n  ///      #define LONGER_NAME      0x007f\n  ///      #define EVEN_LONGER_NAME (2)\n  ///\n  ///      #define foo(x)           (x * x)\n  ///      /* some comment */\n  ///      #define bar(y, z)        (y + z)\n  ///    \\endcode\n  AlignConsecutiveStyle AlignConsecutiveMacros;\n\n  /// Style of aligning consecutive assignments.\n  ///\n  /// ``Consecutive`` will result in formattings like:\n  /// \\code\n  ///   int a            = 1;\n  ///   int somelongname = 2;\n  ///   double c         = 3;\n  /// \\endcode\n  ///\n  /// Possible values:\n  ///\n  /// * ``ACS_None`` (in configuration: ``None``)\n  ///    Do not align assignments on consecutive lines.\n  ///\n  /// * ``ACS_Consecutive`` (in configuration: ``Consecutive``)\n  ///    Align assignments on consecutive lines. This will result in\n  ///    formattings like:\n  ///    \\code\n  ///      int a            = 1;\n  ///      int somelongname = 2;\n  ///      double c         = 3;\n  ///\n  ///      int d = 3;\n  ///      /* A comment. */\n  ///      double e = 4;\n  ///    \\endcode\n  ///\n  /// * ``ACS_AcrossEmptyLines`` (in configuration: ``AcrossEmptyLines``)\n  ///    Same as ACS_Consecutive, but also spans over empty lines, e.g.\n  ///    \\code\n  ///      int a            = 1;\n  ///      int somelongname = 2;\n  ///      double c         = 3;\n  ///\n  ///      int d            = 3;\n  ///      /* A comment. */\n  ///      double e = 4;\n  ///    \\endcode\n  ///\n  /// * ``ACS_AcrossComments`` (in configuration: ``AcrossComments``)\n  ///    Same as ACS_Consecutive, but also spans over lines only containing\n  ///    comments, e.g.\n  ///    \\code\n  ///      int a            = 1;\n  ///      int somelongname = 2;\n  ///      double c         = 3;\n  ///\n  ///      int d    = 3;\n  ///      /* A comment. */\n  ///      double e = 4;\n  ///    \\endcode\n  ///\n  /// * ``ACS_AcrossEmptyLinesAndComments``\n  ///   (in configuration: ``AcrossEmptyLinesAndComments``)\n  ///\n  ///    Same as ACS_Consecutive, but also spans over lines only containing\n  ///    comments and empty lines, e.g.\n  ///    \\code\n  ///      int a            = 1;\n  ///      int somelongname = 2;\n  ///      double c         = 3;\n  ///\n  ///      int d            = 3;\n  ///      /* A comment. */\n  ///      double e         = 4;\n  ///    \\endcode\n  AlignConsecutiveStyle AlignConsecutiveAssignments;\n\n  /// Style of aligning consecutive bit field.\n  ///\n  /// ``Consecutive`` will align the bitfield separators of consecutive lines.\n  /// This will result in formattings like:\n  /// \\code\n  ///   int aaaa : 1;\n  ///   int b    : 12;\n  ///   int ccc  : 8;\n  /// \\endcode\n  ///\n  /// Possible values:\n  ///\n  /// * ``ACS_None`` (in configuration: ``None``)\n  ///    Do not align bit fields on consecutive lines.\n  ///\n  /// * ``ACS_Consecutive`` (in configuration: ``Consecutive``)\n  ///    Align bit fields on consecutive lines. This will result in\n  ///    formattings like:\n  ///    \\code\n  ///      int aaaa : 1;\n  ///      int b    : 12;\n  ///      int ccc  : 8;\n  ///\n  ///      int d : 2;\n  ///      /* A comment. */\n  ///      int ee : 3;\n  ///    \\endcode\n  ///\n  /// * ``ACS_AcrossEmptyLines`` (in configuration: ``AcrossEmptyLines``)\n  ///    Same as ACS_Consecutive, but also spans over empty lines, e.g.\n  ///    \\code\n  ///      int aaaa : 1;\n  ///      int b    : 12;\n  ///      int ccc  : 8;\n  ///\n  ///      int d    : 2;\n  ///      /* A comment. */\n  ///      int ee : 3;\n  ///    \\endcode\n  ///\n  /// * ``ACS_AcrossComments`` (in configuration: ``AcrossComments``)\n  ///    Same as ACS_Consecutive, but also spans over lines only containing\n  ///    comments, e.g.\n  ///    \\code\n  ///      int aaaa : 1;\n  ///      int b    : 12;\n  ///      int ccc  : 8;\n  ///\n  ///      int d  : 2;\n  ///      /* A comment. */\n  ///      int ee : 3;\n  ///    \\endcode\n  ///\n  /// * ``ACS_AcrossEmptyLinesAndComments``\n  ///   (in configuration: ``AcrossEmptyLinesAndComments``)\n  ///\n  ///    Same as ACS_Consecutive, but also spans over lines only containing\n  ///    comments and empty lines, e.g.\n  ///    \\code\n  ///      int aaaa : 1;\n  ///      int b    : 12;\n  ///      int ccc  : 8;\n  ///\n  ///      int d    : 2;\n  ///      /* A comment. */\n  ///      int ee   : 3;\n  ///    \\endcode\n  AlignConsecutiveStyle AlignConsecutiveBitFields;\n\n  /// Style of aligning consecutive declarations.\n  ///\n  /// ``Consecutive`` will align the declaration names of consecutive lines.\n  /// This will result in formattings like:\n  /// \\code\n  ///   int         aaaa = 12;\n  ///   float       b = 23;\n  ///   std::string ccc;\n  /// \\endcode\n  ///\n  /// Possible values:\n  ///\n  /// * ``ACS_None`` (in configuration: ``None``)\n  ///    Do not align bit declarations on consecutive lines.\n  ///\n  /// * ``ACS_Consecutive`` (in configuration: ``Consecutive``)\n  ///    Align declarations on consecutive lines. This will result in\n  ///    formattings like:\n  ///    \\code\n  ///      int         aaaa = 12;\n  ///      float       b = 23;\n  ///      std::string ccc;\n  ///\n  ///      int a = 42;\n  ///      /* A comment. */\n  ///      bool c = false;\n  ///    \\endcode\n  ///\n  /// * ``ACS_AcrossEmptyLines`` (in configuration: ``AcrossEmptyLines``)\n  ///    Same as ACS_Consecutive, but also spans over empty lines, e.g.\n  ///    \\code\n  ///      int         aaaa = 12;\n  ///      float       b = 23;\n  ///      std::string ccc;\n  ///\n  ///      int         a = 42;\n  ///      /* A comment. */\n  ///      bool c = false;\n  ///    \\endcode\n  ///\n  /// * ``ACS_AcrossComments`` (in configuration: ``AcrossComments``)\n  ///    Same as ACS_Consecutive, but also spans over lines only containing\n  ///    comments, e.g.\n  ///    \\code\n  ///      int         aaaa = 12;\n  ///      float       b = 23;\n  ///      std::string ccc;\n  ///\n  ///      int  a = 42;\n  ///      /* A comment. */\n  ///      bool c = false;\n  ///    \\endcode\n  ///\n  /// * ``ACS_AcrossEmptyLinesAndComments``\n  ///   (in configuration: ``AcrossEmptyLinesAndComments``)\n  ///\n  ///    Same as ACS_Consecutive, but also spans over lines only containing\n  ///    comments and empty lines, e.g.\n  ///    \\code\n  ///      int         aaaa = 12;\n  ///      float       b = 23;\n  ///      std::string ccc;\n  ///\n  ///      int         a = 42;\n  ///      /* A comment. */\n  ///      bool        c = false;\n  ///    \\endcode\n  AlignConsecutiveStyle AlignConsecutiveDeclarations;\n\n  /// Different styles for aligning escaped newlines.\n  enum EscapedNewlineAlignmentStyle : unsigned char {\n    /// Don't align escaped newlines.\n    /// \\code\n    ///   #define A \\\n    ///     int aaaa; \\\n    ///     int b; \\\n    ///     int dddddddddd;\n    /// \\endcode\n    ENAS_DontAlign,\n    /// Align escaped newlines as far left as possible.\n    /// \\code\n    ///   true:\n    ///   #define A   \\\n    ///     int aaaa; \\\n    ///     int b;    \\\n    ///     int dddddddddd;\n    ///\n    ///   false:\n    /// \\endcode\n    ENAS_Left,\n    /// Align escaped newlines in the right-most column.\n    /// \\code\n    ///   #define A                                                                      \\\n    ///     int aaaa;                                                                    \\\n    ///     int b;                                                                       \\\n    ///     int dddddddddd;\n    /// \\endcode\n    ENAS_Right,\n  };\n\n  /// Options for aligning backslashes in escaped newlines.\n  EscapedNewlineAlignmentStyle AlignEscapedNewlines;\n\n  /// Different styles for aligning operands.\n  enum OperandAlignmentStyle : unsigned char {\n    /// Do not align operands of binary and ternary expressions.\n    /// The wrapped lines are indented ``ContinuationIndentWidth`` spaces from\n    /// the start of the line.\n    OAS_DontAlign,\n    /// Horizontally align operands of binary and ternary expressions.\n    ///\n    /// Specifically, this aligns operands of a single expression that needs\n    /// to be split over multiple lines, e.g.:\n    /// \\code\n    ///   int aaa = bbbbbbbbbbbbbbb +\n    ///             ccccccccccccccc;\n    /// \\endcode\n    ///\n    /// When ``BreakBeforeBinaryOperators`` is set, the wrapped operator is\n    /// aligned with the operand on the first line.\n    /// \\code\n    ///   int aaa = bbbbbbbbbbbbbbb\n    ///             + ccccccccccccccc;\n    /// \\endcode\n    OAS_Align,\n    /// Horizontally align operands of binary and ternary expressions.\n    ///\n    /// This is similar to ``AO_Align``, except when\n    /// ``BreakBeforeBinaryOperators`` is set, the operator is un-indented so\n    /// that the wrapped operand is aligned with the operand on the first line.\n    /// \\code\n    ///   int aaa = bbbbbbbbbbbbbbb\n    ///           + ccccccccccccccc;\n    /// \\endcode\n    OAS_AlignAfterOperator,\n  };\n\n  /// If ``true``, horizontally align operands of binary and ternary\n  /// expressions.\n  OperandAlignmentStyle AlignOperands;\n\n  /// If ``true``, aligns trailing comments.\n  /// \\code\n  ///   true:                                   false:\n  ///   int a;     // My comment a      vs.     int a; // My comment a\n  ///   int b = 2; // comment  b                int b = 2; // comment about b\n  /// \\endcode\n  bool AlignTrailingComments;\n\n  /// \\brief If a function call or braced initializer list doesn't fit on a\n  /// line, allow putting all arguments onto the next line, even if\n  /// ``BinPackArguments`` is ``false``.\n  /// \\code\n  ///   true:\n  ///   callFunction(\n  ///       a, b, c, d);\n  ///\n  ///   false:\n  ///   callFunction(a,\n  ///                b,\n  ///                c,\n  ///                d);\n  /// \\endcode\n  bool AllowAllArgumentsOnNextLine;\n\n  /// \\brief If a constructor definition with a member initializer list doesn't\n  /// fit on a single line, allow putting all member initializers onto the next\n  /// line, if ```ConstructorInitializerAllOnOneLineOrOnePerLine``` is true.\n  /// Note that this parameter has no effect if\n  /// ```ConstructorInitializerAllOnOneLineOrOnePerLine``` is false.\n  /// \\code\n  ///   true:\n  ///   MyClass::MyClass() :\n  ///       member0(0), member1(2) {}\n  ///\n  ///   false:\n  ///   MyClass::MyClass() :\n  ///       member0(0),\n  ///       member1(2) {}\n  bool AllowAllConstructorInitializersOnNextLine;\n\n  /// If the function declaration doesn't fit on a line,\n  /// allow putting all parameters of a function declaration onto\n  /// the next line even if ``BinPackParameters`` is ``false``.\n  /// \\code\n  ///   true:\n  ///   void myFunction(\n  ///       int a, int b, int c, int d, int e);\n  ///\n  ///   false:\n  ///   void myFunction(int a,\n  ///                   int b,\n  ///                   int c,\n  ///                   int d,\n  ///                   int e);\n  /// \\endcode\n  bool AllowAllParametersOfDeclarationOnNextLine;\n\n  /// Allow short enums on a single line.\n  /// \\code\n  ///   true:\n  ///   enum { A, B } myEnum;\n  ///\n  ///   false:\n  ///   enum\n  ///   {\n  ///     A,\n  ///     B\n  ///   } myEnum;\n  /// \\endcode\n  bool AllowShortEnumsOnASingleLine;\n\n  /// Different styles for merging short blocks containing at most one\n  /// statement.\n  enum ShortBlockStyle : unsigned char {\n    /// Never merge blocks into a single line.\n    /// \\code\n    ///   while (true) {\n    ///   }\n    ///   while (true) {\n    ///     continue;\n    ///   }\n    /// \\endcode\n    SBS_Never,\n    /// Only merge empty blocks.\n    /// \\code\n    ///   while (true) {}\n    ///   while (true) {\n    ///     continue;\n    ///   }\n    /// \\endcode\n    SBS_Empty,\n    /// Always merge short blocks into a single line.\n    /// \\code\n    ///   while (true) {}\n    ///   while (true) { continue; }\n    /// \\endcode\n    SBS_Always,\n  };\n\n  /// Dependent on the value, ``while (true) { continue; }`` can be put on a\n  /// single line.\n  ShortBlockStyle AllowShortBlocksOnASingleLine;\n\n  /// If ``true``, short case labels will be contracted to a single line.\n  /// \\code\n  ///   true:                                   false:\n  ///   switch (a) {                    vs.     switch (a) {\n  ///   case 1: x = 1; break;                   case 1:\n  ///   case 2: return;                           x = 1;\n  ///   }                                         break;\n  ///                                           case 2:\n  ///                                             return;\n  ///                                           }\n  /// \\endcode\n  bool AllowShortCaseLabelsOnASingleLine;\n\n  /// Different styles for merging short functions containing at most one\n  /// statement.\n  enum ShortFunctionStyle : unsigned char {\n    /// Never merge functions into a single line.\n    SFS_None,\n    /// Only merge functions defined inside a class. Same as \"inline\",\n    /// except it does not implies \"empty\": i.e. top level empty functions\n    /// are not merged either.\n    /// \\code\n    ///   class Foo {\n    ///     void f() { foo(); }\n    ///   };\n    ///   void f() {\n    ///     foo();\n    ///   }\n    ///   void f() {\n    ///   }\n    /// \\endcode\n    SFS_InlineOnly,\n    /// Only merge empty functions.\n    /// \\code\n    ///   void f() {}\n    ///   void f2() {\n    ///     bar2();\n    ///   }\n    /// \\endcode\n    SFS_Empty,\n    /// Only merge functions defined inside a class. Implies \"empty\".\n    /// \\code\n    ///   class Foo {\n    ///     void f() { foo(); }\n    ///   };\n    ///   void f() {\n    ///     foo();\n    ///   }\n    ///   void f() {}\n    /// \\endcode\n    SFS_Inline,\n    /// Merge all functions fitting on a single line.\n    /// \\code\n    ///   class Foo {\n    ///     void f() { foo(); }\n    ///   };\n    ///   void f() { bar(); }\n    /// \\endcode\n    SFS_All,\n  };\n\n  /// Dependent on the value, ``int f() { return 0; }`` can be put on a\n  /// single line.\n  ShortFunctionStyle AllowShortFunctionsOnASingleLine;\n\n  /// Different styles for handling short if lines\n  enum ShortIfStyle : unsigned char {\n    /// Never put short ifs on the same line.\n    /// \\code\n    ///   if (a)\n    ///     return ;\n    ///   else {\n    ///     return;\n    ///   }\n    /// \\endcode\n    SIS_Never,\n    /// Without else put short ifs on the same line only if\n    /// the else is not a compound statement.\n    /// \\code\n    ///   if (a) return;\n    ///   else\n    ///     return;\n    /// \\endcode\n    SIS_WithoutElse,\n    /// Always put short ifs on the same line if\n    /// the else is not a compound statement or not.\n    /// \\code\n    ///   if (a) return;\n    ///   else {\n    ///     return;\n    ///   }\n    /// \\endcode\n    SIS_Always,\n  };\n\n  /// If ``true``, ``if (a) return;`` can be put on a single line.\n  ShortIfStyle AllowShortIfStatementsOnASingleLine;\n\n  /// Different styles for merging short lambdas containing at most one\n  /// statement.\n  enum ShortLambdaStyle : unsigned char {\n    /// Never merge lambdas into a single line.\n    SLS_None,\n    /// Only merge empty lambdas.\n    /// \\code\n    ///   auto lambda = [](int a) {}\n    ///   auto lambda2 = [](int a) {\n    ///       return a;\n    ///   };\n    /// \\endcode\n    SLS_Empty,\n    /// Merge lambda into a single line if argument of a function.\n    /// \\code\n    ///   auto lambda = [](int a) {\n    ///       return a;\n    ///   };\n    ///   sort(a.begin(), a.end(), ()[] { return x < y; })\n    /// \\endcode\n    SLS_Inline,\n    /// Merge all lambdas fitting on a single line.\n    /// \\code\n    ///   auto lambda = [](int a) {}\n    ///   auto lambda2 = [](int a) { return a; };\n    /// \\endcode\n    SLS_All,\n  };\n\n  /// Dependent on the value, ``auto lambda []() { return 0; }`` can be put on a\n  /// single line.\n  ShortLambdaStyle AllowShortLambdasOnASingleLine;\n\n  /// If ``true``, ``while (true) continue;`` can be put on a single\n  /// line.\n  bool AllowShortLoopsOnASingleLine;\n\n  /// Different ways to break after the function definition return type.\n  /// This option is **deprecated** and is retained for backwards compatibility.\n  enum DefinitionReturnTypeBreakingStyle : unsigned char {\n    /// Break after return type automatically.\n    /// ``PenaltyReturnTypeOnItsOwnLine`` is taken into account.\n    DRTBS_None,\n    /// Always break after the return type.\n    DRTBS_All,\n    /// Always break after the return types of top-level functions.\n    DRTBS_TopLevel,\n  };\n\n  /// Different ways to break after the function definition or\n  /// declaration return type.\n  enum ReturnTypeBreakingStyle : unsigned char {\n    /// Break after return type automatically.\n    /// ``PenaltyReturnTypeOnItsOwnLine`` is taken into account.\n    /// \\code\n    ///   class A {\n    ///     int f() { return 0; };\n    ///   };\n    ///   int f();\n    ///   int f() { return 1; }\n    /// \\endcode\n    RTBS_None,\n    /// Always break after the return type.\n    /// \\code\n    ///   class A {\n    ///     int\n    ///     f() {\n    ///       return 0;\n    ///     };\n    ///   };\n    ///   int\n    ///   f();\n    ///   int\n    ///   f() {\n    ///     return 1;\n    ///   }\n    /// \\endcode\n    RTBS_All,\n    /// Always break after the return types of top-level functions.\n    /// \\code\n    ///   class A {\n    ///     int f() { return 0; };\n    ///   };\n    ///   int\n    ///   f();\n    ///   int\n    ///   f() {\n    ///     return 1;\n    ///   }\n    /// \\endcode\n    RTBS_TopLevel,\n    /// Always break after the return type of function definitions.\n    /// \\code\n    ///   class A {\n    ///     int\n    ///     f() {\n    ///       return 0;\n    ///     };\n    ///   };\n    ///   int f();\n    ///   int\n    ///   f() {\n    ///     return 1;\n    ///   }\n    /// \\endcode\n    RTBS_AllDefinitions,\n    /// Always break after the return type of top-level definitions.\n    /// \\code\n    ///   class A {\n    ///     int f() { return 0; };\n    ///   };\n    ///   int f();\n    ///   int\n    ///   f() {\n    ///     return 1;\n    ///   }\n    /// \\endcode\n    RTBS_TopLevelDefinitions,\n  };\n\n  /// The function definition return type breaking style to use.  This\n  /// option is **deprecated** and is retained for backwards compatibility.\n  DefinitionReturnTypeBreakingStyle AlwaysBreakAfterDefinitionReturnType;\n\n  /// The function declaration return type breaking style to use.\n  ReturnTypeBreakingStyle AlwaysBreakAfterReturnType;\n\n  /// If ``true``, always break before multiline string literals.\n  ///\n  /// This flag is mean to make cases where there are multiple multiline strings\n  /// in a file look more consistent. Thus, it will only take effect if wrapping\n  /// the string at that point leads to it being indented\n  /// ``ContinuationIndentWidth`` spaces from the start of the line.\n  /// \\code\n  ///    true:                                  false:\n  ///    aaaa =                         vs.     aaaa = \"bbbb\"\n  ///        \"bbbb\"                                    \"cccc\";\n  ///        \"cccc\";\n  /// \\endcode\n  bool AlwaysBreakBeforeMultilineStrings;\n\n  /// Different ways to break after the template declaration.\n  enum BreakTemplateDeclarationsStyle : unsigned char {\n    /// Do not force break before declaration.\n    /// ``PenaltyBreakTemplateDeclaration`` is taken into account.\n    /// \\code\n    ///    template <typename T> T foo() {\n    ///    }\n    ///    template <typename T> T foo(int aaaaaaaaaaaaaaaaaaaaa,\n    ///                                int bbbbbbbbbbbbbbbbbbbbb) {\n    ///    }\n    /// \\endcode\n    BTDS_No,\n    /// Force break after template declaration only when the following\n    /// declaration spans multiple lines.\n    /// \\code\n    ///    template <typename T> T foo() {\n    ///    }\n    ///    template <typename T>\n    ///    T foo(int aaaaaaaaaaaaaaaaaaaaa,\n    ///          int bbbbbbbbbbbbbbbbbbbbb) {\n    ///    }\n    /// \\endcode\n    BTDS_MultiLine,\n    /// Always break after template declaration.\n    /// \\code\n    ///    template <typename T>\n    ///    T foo() {\n    ///    }\n    ///    template <typename T>\n    ///    T foo(int aaaaaaaaaaaaaaaaaaaaa,\n    ///          int bbbbbbbbbbbbbbbbbbbbb) {\n    ///    }\n    /// \\endcode\n    BTDS_Yes\n  };\n\n  /// The template declaration breaking style to use.\n  BreakTemplateDeclarationsStyle AlwaysBreakTemplateDeclarations;\n\n  /// A vector of strings that should be interpreted as attributes/qualifiers\n  /// instead of identifiers. This can be useful for language extensions or\n  /// static analyzer annotations.\n  ///\n  /// For example:\n  /// \\code\n  ///   x = (char *__capability)&y;\n  ///   int function(void) __ununsed;\n  ///   void only_writes_to_buffer(char *__output buffer);\n  /// \\endcode\n  ///\n  /// In the .clang-format configuration file, this can be configured like:\n  /// \\code{.yaml}\n  ///   AttributeMacros: ['__capability', '__output', '__ununsed']\n  /// \\endcode\n  ///\n  std::vector<std::string> AttributeMacros;\n\n  /// If ``false``, a function call's arguments will either be all on the\n  /// same line or will have one line each.\n  /// \\code\n  ///   true:\n  ///   void f() {\n  ///     f(aaaaaaaaaaaaaaaaaaaa, aaaaaaaaaaaaaaaaaaaa,\n  ///       aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);\n  ///   }\n  ///\n  ///   false:\n  ///   void f() {\n  ///     f(aaaaaaaaaaaaaaaaaaaa,\n  ///       aaaaaaaaaaaaaaaaaaaa,\n  ///       aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);\n  ///   }\n  /// \\endcode\n  bool BinPackArguments;\n\n  /// The style of inserting trailing commas into container literals.\n  enum TrailingCommaStyle : unsigned char {\n    /// Do not insert trailing commas.\n    TCS_None,\n    /// Insert trailing commas in container literals that were wrapped over\n    /// multiple lines. Note that this is conceptually incompatible with\n    /// bin-packing, because the trailing comma is used as an indicator\n    /// that a container should be formatted one-per-line (i.e. not bin-packed).\n    /// So inserting a trailing comma counteracts bin-packing.\n    TCS_Wrapped,\n  };\n\n  /// If set to ``TCS_Wrapped`` will insert trailing commas in container\n  /// literals (arrays and objects) that wrap across multiple lines.\n  /// It is currently only available for JavaScript\n  /// and disabled by default ``TCS_None``.\n  /// ``InsertTrailingCommas`` cannot be used together with ``BinPackArguments``\n  /// as inserting the comma disables bin-packing.\n  /// \\code\n  ///   TSC_Wrapped:\n  ///   const someArray = [\n  ///   aaaaaaaaaaaaaaaaaaaaaaaaaa,\n  ///   aaaaaaaaaaaaaaaaaaaaaaaaaa,\n  ///   aaaaaaaaaaaaaaaaaaaaaaaaaa,\n  ///   //                        ^ inserted\n  ///   ]\n  /// \\endcode\n  TrailingCommaStyle InsertTrailingCommas;\n\n  /// If ``false``, a function declaration's or function definition's\n  /// parameters will either all be on the same line or will have one line each.\n  /// \\code\n  ///   true:\n  ///   void f(int aaaaaaaaaaaaaaaaaaaa, int aaaaaaaaaaaaaaaaaaaa,\n  ///          int aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) {}\n  ///\n  ///   false:\n  ///   void f(int aaaaaaaaaaaaaaaaaaaa,\n  ///          int aaaaaaaaaaaaaaaaaaaa,\n  ///          int aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) {}\n  /// \\endcode\n  bool BinPackParameters;\n\n  /// The style of wrapping parameters on the same line (bin-packed) or\n  /// on one line each.\n  enum BinPackStyle : unsigned char {\n    /// Automatically determine parameter bin-packing behavior.\n    BPS_Auto,\n    /// Always bin-pack parameters.\n    BPS_Always,\n    /// Never bin-pack parameters.\n    BPS_Never,\n  };\n\n  /// The style of breaking before or after binary operators.\n  enum BinaryOperatorStyle : unsigned char {\n    /// Break after operators.\n    /// \\code\n    ///    LooooooooooongType loooooooooooooooooooooongVariable =\n    ///        someLooooooooooooooooongFunction();\n    ///\n    ///    bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa +\n    ///                         aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa ==\n    ///                     aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa &&\n    ///                 aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa >\n    ///                     ccccccccccccccccccccccccccccccccccccccccc;\n    /// \\endcode\n    BOS_None,\n    /// Break before operators that aren't assignments.\n    /// \\code\n    ///    LooooooooooongType loooooooooooooooooooooongVariable =\n    ///        someLooooooooooooooooongFunction();\n    ///\n    ///    bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n    ///                         + aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n    ///                     == aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n    ///                 && aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n    ///                        > ccccccccccccccccccccccccccccccccccccccccc;\n    /// \\endcode\n    BOS_NonAssignment,\n    /// Break before operators.\n    /// \\code\n    ///    LooooooooooongType loooooooooooooooooooooongVariable\n    ///        = someLooooooooooooooooongFunction();\n    ///\n    ///    bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n    ///                         + aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n    ///                     == aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n    ///                 && aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n    ///                        > ccccccccccccccccccccccccccccccccccccccccc;\n    /// \\endcode\n    BOS_All,\n  };\n\n  /// The way to wrap binary operators.\n  BinaryOperatorStyle BreakBeforeBinaryOperators;\n\n  /// Different ways to attach braces to their surrounding context.\n  enum BraceBreakingStyle : unsigned char {\n    /// Always attach braces to surrounding context.\n    /// \\code\n    ///   namespace N {\n    ///   enum E {\n    ///     E1,\n    ///     E2,\n    ///   };\n    ///\n    ///   class C {\n    ///   public:\n    ///     C();\n    ///   };\n    ///\n    ///   bool baz(int i) {\n    ///     try {\n    ///       do {\n    ///         switch (i) {\n    ///         case 1: {\n    ///           foobar();\n    ///           break;\n    ///         }\n    ///         default: {\n    ///           break;\n    ///         }\n    ///         }\n    ///       } while (--i);\n    ///       return true;\n    ///     } catch (...) {\n    ///       handleError();\n    ///       return false;\n    ///     }\n    ///   }\n    ///\n    ///   void foo(bool b) {\n    ///     if (b) {\n    ///       baz(2);\n    ///     } else {\n    ///       baz(5);\n    ///     }\n    ///   }\n    ///\n    ///   void bar() { foo(true); }\n    ///   } // namespace N\n    /// \\endcode\n    BS_Attach,\n    /// Like ``Attach``, but break before braces on function, namespace and\n    /// class definitions.\n    /// \\code\n    ///   namespace N\n    ///   {\n    ///   enum E {\n    ///     E1,\n    ///     E2,\n    ///   };\n    ///\n    ///   class C\n    ///   {\n    ///   public:\n    ///     C();\n    ///   };\n    ///\n    ///   bool baz(int i)\n    ///   {\n    ///     try {\n    ///       do {\n    ///         switch (i) {\n    ///         case 1: {\n    ///           foobar();\n    ///           break;\n    ///         }\n    ///         default: {\n    ///           break;\n    ///         }\n    ///         }\n    ///       } while (--i);\n    ///       return true;\n    ///     } catch (...) {\n    ///       handleError();\n    ///       return false;\n    ///     }\n    ///   }\n    ///\n    ///   void foo(bool b)\n    ///   {\n    ///     if (b) {\n    ///       baz(2);\n    ///     } else {\n    ///       baz(5);\n    ///     }\n    ///   }\n    ///\n    ///   void bar() { foo(true); }\n    ///   } // namespace N\n    /// \\endcode\n    BS_Linux,\n    /// Like ``Attach``, but break before braces on enum, function, and record\n    /// definitions.\n    /// \\code\n    ///   namespace N {\n    ///   enum E\n    ///   {\n    ///     E1,\n    ///     E2,\n    ///   };\n    ///\n    ///   class C\n    ///   {\n    ///   public:\n    ///     C();\n    ///   };\n    ///\n    ///   bool baz(int i)\n    ///   {\n    ///     try {\n    ///       do {\n    ///         switch (i) {\n    ///         case 1: {\n    ///           foobar();\n    ///           break;\n    ///         }\n    ///         default: {\n    ///           break;\n    ///         }\n    ///         }\n    ///       } while (--i);\n    ///       return true;\n    ///     } catch (...) {\n    ///       handleError();\n    ///       return false;\n    ///     }\n    ///   }\n    ///\n    ///   void foo(bool b)\n    ///   {\n    ///     if (b) {\n    ///       baz(2);\n    ///     } else {\n    ///       baz(5);\n    ///     }\n    ///   }\n    ///\n    ///   void bar() { foo(true); }\n    ///   } // namespace N\n    /// \\endcode\n    BS_Mozilla,\n    /// Like ``Attach``, but break before function definitions, ``catch``, and\n    /// ``else``.\n    /// \\code\n    ///   namespace N {\n    ///   enum E {\n    ///     E1,\n    ///     E2,\n    ///   };\n    ///\n    ///   class C {\n    ///   public:\n    ///     C();\n    ///   };\n    ///\n    ///   bool baz(int i)\n    ///   {\n    ///     try {\n    ///       do {\n    ///         switch (i) {\n    ///         case 1: {\n    ///           foobar();\n    ///           break;\n    ///         }\n    ///         default: {\n    ///           break;\n    ///         }\n    ///         }\n    ///       } while (--i);\n    ///       return true;\n    ///     }\n    ///     catch (...) {\n    ///       handleError();\n    ///       return false;\n    ///     }\n    ///   }\n    ///\n    ///   void foo(bool b)\n    ///   {\n    ///     if (b) {\n    ///       baz(2);\n    ///     }\n    ///     else {\n    ///       baz(5);\n    ///     }\n    ///   }\n    ///\n    ///   void bar() { foo(true); }\n    ///   } // namespace N\n    /// \\endcode\n    BS_Stroustrup,\n    /// Always break before braces.\n    /// \\code\n    ///   namespace N\n    ///   {\n    ///   enum E\n    ///   {\n    ///     E1,\n    ///     E2,\n    ///   };\n    ///\n    ///   class C\n    ///   {\n    ///   public:\n    ///     C();\n    ///   };\n    ///\n    ///   bool baz(int i)\n    ///   {\n    ///     try\n    ///     {\n    ///       do\n    ///       {\n    ///         switch (i)\n    ///         {\n    ///         case 1:\n    ///         {\n    ///           foobar();\n    ///           break;\n    ///         }\n    ///         default:\n    ///         {\n    ///           break;\n    ///         }\n    ///         }\n    ///       } while (--i);\n    ///       return true;\n    ///     }\n    ///     catch (...)\n    ///     {\n    ///       handleError();\n    ///       return false;\n    ///     }\n    ///   }\n    ///\n    ///   void foo(bool b)\n    ///   {\n    ///     if (b)\n    ///     {\n    ///       baz(2);\n    ///     }\n    ///     else\n    ///     {\n    ///       baz(5);\n    ///     }\n    ///   }\n    ///\n    ///   void bar() { foo(true); }\n    ///   } // namespace N\n    /// \\endcode\n    BS_Allman,\n    /// Like ``Allman`` but always indent braces and line up code with braces.\n    /// \\code\n    ///   namespace N\n    ///     {\n    ///   enum E\n    ///     {\n    ///     E1,\n    ///     E2,\n    ///     };\n    ///\n    ///   class C\n    ///     {\n    ///   public:\n    ///     C();\n    ///     };\n    ///\n    ///   bool baz(int i)\n    ///     {\n    ///     try\n    ///       {\n    ///       do\n    ///         {\n    ///         switch (i)\n    ///           {\n    ///           case 1:\n    ///           {\n    ///           foobar();\n    ///           break;\n    ///           }\n    ///           default:\n    ///           {\n    ///           break;\n    ///           }\n    ///           }\n    ///         } while (--i);\n    ///       return true;\n    ///       }\n    ///     catch (...)\n    ///       {\n    ///       handleError();\n    ///       return false;\n    ///       }\n    ///     }\n    ///\n    ///   void foo(bool b)\n    ///     {\n    ///     if (b)\n    ///       {\n    ///       baz(2);\n    ///       }\n    ///     else\n    ///       {\n    ///       baz(5);\n    ///       }\n    ///     }\n    ///\n    ///   void bar() { foo(true); }\n    ///     } // namespace N\n    /// \\endcode\n    BS_Whitesmiths,\n    /// Always break before braces and add an extra level of indentation to\n    /// braces of control statements, not to those of class, function\n    /// or other definitions.\n    /// \\code\n    ///   namespace N\n    ///   {\n    ///   enum E\n    ///   {\n    ///     E1,\n    ///     E2,\n    ///   };\n    ///\n    ///   class C\n    ///   {\n    ///   public:\n    ///     C();\n    ///   };\n    ///\n    ///   bool baz(int i)\n    ///   {\n    ///     try\n    ///       {\n    ///         do\n    ///           {\n    ///             switch (i)\n    ///               {\n    ///               case 1:\n    ///                 {\n    ///                   foobar();\n    ///                   break;\n    ///                 }\n    ///               default:\n    ///                 {\n    ///                   break;\n    ///                 }\n    ///               }\n    ///           }\n    ///         while (--i);\n    ///         return true;\n    ///       }\n    ///     catch (...)\n    ///       {\n    ///         handleError();\n    ///         return false;\n    ///       }\n    ///   }\n    ///\n    ///   void foo(bool b)\n    ///   {\n    ///     if (b)\n    ///       {\n    ///         baz(2);\n    ///       }\n    ///     else\n    ///       {\n    ///         baz(5);\n    ///       }\n    ///   }\n    ///\n    ///   void bar() { foo(true); }\n    ///   } // namespace N\n    /// \\endcode\n    BS_GNU,\n    /// Like ``Attach``, but break before functions.\n    /// \\code\n    ///   namespace N {\n    ///   enum E {\n    ///     E1,\n    ///     E2,\n    ///   };\n    ///\n    ///   class C {\n    ///   public:\n    ///     C();\n    ///   };\n    ///\n    ///   bool baz(int i)\n    ///   {\n    ///     try {\n    ///       do {\n    ///         switch (i) {\n    ///         case 1: {\n    ///           foobar();\n    ///           break;\n    ///         }\n    ///         default: {\n    ///           break;\n    ///         }\n    ///         }\n    ///       } while (--i);\n    ///       return true;\n    ///     } catch (...) {\n    ///       handleError();\n    ///       return false;\n    ///     }\n    ///   }\n    ///\n    ///   void foo(bool b)\n    ///   {\n    ///     if (b) {\n    ///       baz(2);\n    ///     } else {\n    ///       baz(5);\n    ///     }\n    ///   }\n    ///\n    ///   void bar() { foo(true); }\n    ///   } // namespace N\n    /// \\endcode\n    BS_WebKit,\n    /// Configure each individual brace in `BraceWrapping`.\n    BS_Custom\n  };\n\n  /// The brace breaking style to use.\n  BraceBreakingStyle BreakBeforeBraces;\n\n  /// Different ways to wrap braces after control statements.\n  enum BraceWrappingAfterControlStatementStyle : unsigned char {\n    /// Never wrap braces after a control statement.\n    /// \\code\n    ///   if (foo()) {\n    ///   } else {\n    ///   }\n    ///   for (int i = 0; i < 10; ++i) {\n    ///   }\n    /// \\endcode\n    BWACS_Never,\n    /// Only wrap braces after a multi-line control statement.\n    /// \\code\n    ///   if (foo && bar &&\n    ///       baz)\n    ///   {\n    ///     quux();\n    ///   }\n    ///   while (foo || bar) {\n    ///   }\n    /// \\endcode\n    BWACS_MultiLine,\n    /// Always wrap braces after a control statement.\n    /// \\code\n    ///   if (foo())\n    ///   {\n    ///   } else\n    ///   {}\n    ///   for (int i = 0; i < 10; ++i)\n    ///   {}\n    /// \\endcode\n    BWACS_Always\n  };\n\n  /// Precise control over the wrapping of braces.\n  /// \\code\n  ///   # Should be declared this way:\n  ///   BreakBeforeBraces: Custom\n  ///   BraceWrapping:\n  ///       AfterClass: true\n  /// \\endcode\n  struct BraceWrappingFlags {\n    /// Wrap case labels.\n    /// \\code\n    ///   false:                                true:\n    ///   switch (foo) {                vs.     switch (foo) {\n    ///     case 1: {                             case 1:\n    ///       bar();                              {\n    ///       break;                                bar();\n    ///     }                                       break;\n    ///     default: {                            }\n    ///       plop();                             default:\n    ///     }                                     {\n    ///   }                                         plop();\n    ///                                           }\n    ///                                         }\n    /// \\endcode\n    bool AfterCaseLabel;\n    /// Wrap class definitions.\n    /// \\code\n    ///   true:\n    ///   class foo {};\n    ///\n    ///   false:\n    ///   class foo\n    ///   {};\n    /// \\endcode\n    bool AfterClass;\n\n    /// Wrap control statements (``if``/``for``/``while``/``switch``/..).\n    BraceWrappingAfterControlStatementStyle AfterControlStatement;\n    /// Wrap enum definitions.\n    /// \\code\n    ///   true:\n    ///   enum X : int\n    ///   {\n    ///     B\n    ///   };\n    ///\n    ///   false:\n    ///   enum X : int { B };\n    /// \\endcode\n    bool AfterEnum;\n    /// Wrap function definitions.\n    /// \\code\n    ///   true:\n    ///   void foo()\n    ///   {\n    ///     bar();\n    ///     bar2();\n    ///   }\n    ///\n    ///   false:\n    ///   void foo() {\n    ///     bar();\n    ///     bar2();\n    ///   }\n    /// \\endcode\n    bool AfterFunction;\n    /// Wrap namespace definitions.\n    /// \\code\n    ///   true:\n    ///   namespace\n    ///   {\n    ///   int foo();\n    ///   int bar();\n    ///   }\n    ///\n    ///   false:\n    ///   namespace {\n    ///   int foo();\n    ///   int bar();\n    ///   }\n    /// \\endcode\n    bool AfterNamespace;\n    /// Wrap ObjC definitions (interfaces, implementations...).\n    /// \\note @autoreleasepool and @synchronized blocks are wrapped\n    /// according to `AfterControlStatement` flag.\n    bool AfterObjCDeclaration;\n    /// Wrap struct definitions.\n    /// \\code\n    ///   true:\n    ///   struct foo\n    ///   {\n    ///     int x;\n    ///   };\n    ///\n    ///   false:\n    ///   struct foo {\n    ///     int x;\n    ///   };\n    /// \\endcode\n    bool AfterStruct;\n    /// Wrap union definitions.\n    /// \\code\n    ///   true:\n    ///   union foo\n    ///   {\n    ///     int x;\n    ///   }\n    ///\n    ///   false:\n    ///   union foo {\n    ///     int x;\n    ///   }\n    /// \\endcode\n    bool AfterUnion;\n    /// Wrap extern blocks.\n    /// \\code\n    ///   true:\n    ///   extern \"C\"\n    ///   {\n    ///     int foo();\n    ///   }\n    ///\n    ///   false:\n    ///   extern \"C\" {\n    ///   int foo();\n    ///   }\n    /// \\endcode\n    bool AfterExternBlock; // Partially superseded by IndentExternBlock\n    /// Wrap before ``catch``.\n    /// \\code\n    ///   true:\n    ///   try {\n    ///     foo();\n    ///   }\n    ///   catch () {\n    ///   }\n    ///\n    ///   false:\n    ///   try {\n    ///     foo();\n    ///   } catch () {\n    ///   }\n    /// \\endcode\n    bool BeforeCatch;\n    /// Wrap before ``else``.\n    /// \\code\n    ///   true:\n    ///   if (foo()) {\n    ///   }\n    ///   else {\n    ///   }\n    ///\n    ///   false:\n    ///   if (foo()) {\n    ///   } else {\n    ///   }\n    /// \\endcode\n    bool BeforeElse;\n    /// Wrap lambda block.\n    /// \\code\n    ///   true:\n    ///   connect(\n    ///     []()\n    ///     {\n    ///       foo();\n    ///       bar();\n    ///     });\n    ///\n    ///   false:\n    ///   connect([]() {\n    ///     foo();\n    ///     bar();\n    ///   });\n    /// \\endcode\n    bool BeforeLambdaBody;\n    /// Wrap before ``while``.\n    /// \\code\n    ///   true:\n    ///   do {\n    ///     foo();\n    ///   }\n    ///   while (1);\n    ///\n    ///   false:\n    ///   do {\n    ///     foo();\n    ///   } while (1);\n    /// \\endcode\n    bool BeforeWhile;\n    /// Indent the wrapped braces themselves.\n    bool IndentBraces;\n    /// If ``false``, empty function body can be put on a single line.\n    /// This option is used only if the opening brace of the function has\n    /// already been wrapped, i.e. the `AfterFunction` brace wrapping mode is\n    /// set, and the function could/should not be put on a single line (as per\n    /// `AllowShortFunctionsOnASingleLine` and constructor formatting options).\n    /// \\code\n    ///   int f()   vs.   int f()\n    ///   {}              {\n    ///                   }\n    /// \\endcode\n    ///\n    bool SplitEmptyFunction;\n    /// If ``false``, empty record (e.g. class, struct or union) body\n    /// can be put on a single line. This option is used only if the opening\n    /// brace of the record has already been wrapped, i.e. the `AfterClass`\n    /// (for classes) brace wrapping mode is set.\n    /// \\code\n    ///   class Foo   vs.  class Foo\n    ///   {}               {\n    ///                    }\n    /// \\endcode\n    ///\n    bool SplitEmptyRecord;\n    /// If ``false``, empty namespace body can be put on a single line.\n    /// This option is used only if the opening brace of the namespace has\n    /// already been wrapped, i.e. the `AfterNamespace` brace wrapping mode is\n    /// set.\n    /// \\code\n    ///   namespace Foo   vs.  namespace Foo\n    ///   {}                   {\n    ///                        }\n    /// \\endcode\n    ///\n    bool SplitEmptyNamespace;\n  };\n\n  /// Control of individual brace wrapping cases.\n  ///\n  /// If ``BreakBeforeBraces`` is set to ``BS_Custom``, use this to specify how\n  /// each individual brace case should be handled. Otherwise, this is ignored.\n  /// \\code{.yaml}\n  ///   # Example of usage:\n  ///   BreakBeforeBraces: Custom\n  ///   BraceWrapping:\n  ///     AfterEnum: true\n  ///     AfterStruct: false\n  ///     SplitEmptyFunction: false\n  /// \\endcode\n  BraceWrappingFlags BraceWrapping;\n\n  /// If ``true``, concept will be placed on a new line.\n  /// \\code\n  ///   true:\n  ///    template<typename T>\n  ///    concept ...\n  ///\n  ///   false:\n  ///    template<typename T> concept ...\n  /// \\endcode\n  bool BreakBeforeConceptDeclarations;\n\n  /// If ``true``, ternary operators will be placed after line breaks.\n  /// \\code\n  ///    true:\n  ///    veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongDescription\n  ///        ? firstValue\n  ///        : SecondValueVeryVeryVeryVeryLong;\n  ///\n  ///    false:\n  ///    veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongDescription ?\n  ///        firstValue :\n  ///        SecondValueVeryVeryVeryVeryLong;\n  /// \\endcode\n  bool BreakBeforeTernaryOperators;\n\n  /// Different ways to break initializers.\n  enum BreakConstructorInitializersStyle : unsigned char {\n    /// Break constructor initializers before the colon and after the commas.\n    /// \\code\n    ///    Constructor()\n    ///        : initializer1(),\n    ///          initializer2()\n    /// \\endcode\n    BCIS_BeforeColon,\n    /// Break constructor initializers before the colon and commas, and align\n    /// the commas with the colon.\n    /// \\code\n    ///    Constructor()\n    ///        : initializer1()\n    ///        , initializer2()\n    /// \\endcode\n    BCIS_BeforeComma,\n    /// Break constructor initializers after the colon and commas.\n    /// \\code\n    ///    Constructor() :\n    ///        initializer1(),\n    ///        initializer2()\n    /// \\endcode\n    BCIS_AfterColon\n  };\n\n  /// The constructor initializers style to use.\n  BreakConstructorInitializersStyle BreakConstructorInitializers;\n\n  /// Break after each annotation on a field in Java files.\n  /// \\code{.java}\n  ///    true:                                  false:\n  ///    @Partial                       vs.     @Partial @Mock DataLoad loader;\n  ///    @Mock\n  ///    DataLoad loader;\n  /// \\endcode\n  bool BreakAfterJavaFieldAnnotations;\n\n  /// Allow breaking string literals when formatting.\n  /// \\code\n  ///    true:\n  ///    const char* x = \"veryVeryVeryVeryVeryVe\"\n  ///                    \"ryVeryVeryVeryVeryVery\"\n  ///                    \"VeryLongString\";\n  ///\n  ///    false:\n  ///    const char* x =\n  ///      \"veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongString\";\n  /// \\endcode\n  bool BreakStringLiterals;\n\n  /// The column limit.\n  ///\n  /// A column limit of ``0`` means that there is no column limit. In this case,\n  /// clang-format will respect the input's line breaking decisions within\n  /// statements unless they contradict other rules.\n  unsigned ColumnLimit;\n\n  /// A regular expression that describes comments with special meaning,\n  /// which should not be split into lines or otherwise changed.\n  /// \\code\n  ///    // CommentPragmas: '^ FOOBAR pragma:'\n  ///    // Will leave the following line unaffected\n  ///    #include <vector> // FOOBAR pragma: keep\n  /// \\endcode\n  std::string CommentPragmas;\n\n  /// Different ways to break inheritance list.\n  enum BreakInheritanceListStyle : unsigned char {\n    /// Break inheritance list before the colon and after the commas.\n    /// \\code\n    ///    class Foo\n    ///        : Base1,\n    ///          Base2\n    ///    {};\n    /// \\endcode\n    BILS_BeforeColon,\n    /// Break inheritance list before the colon and commas, and align\n    /// the commas with the colon.\n    /// \\code\n    ///    class Foo\n    ///        : Base1\n    ///        , Base2\n    ///    {};\n    /// \\endcode\n    BILS_BeforeComma,\n    /// Break inheritance list after the colon and commas.\n    /// \\code\n    ///    class Foo :\n    ///        Base1,\n    ///        Base2\n    ///    {};\n    /// \\endcode\n    BILS_AfterColon\n  };\n\n  /// The inheritance list style to use.\n  BreakInheritanceListStyle BreakInheritanceList;\n\n  /// If ``true``, consecutive namespace declarations will be on the same\n  /// line. If ``false``, each namespace is declared on a new line.\n  /// \\code\n  ///   true:\n  ///   namespace Foo { namespace Bar {\n  ///   }}\n  ///\n  ///   false:\n  ///   namespace Foo {\n  ///   namespace Bar {\n  ///   }\n  ///   }\n  /// \\endcode\n  ///\n  /// If it does not fit on a single line, the overflowing namespaces get\n  /// wrapped:\n  /// \\code\n  ///   namespace Foo { namespace Bar {\n  ///   namespace Extra {\n  ///   }}}\n  /// \\endcode\n  bool CompactNamespaces;\n\n  // clang-format off\n  /// If the constructor initializers don't fit on a line, put each\n  /// initializer on its own line.\n  /// \\code\n  ///   true:\n  ///   SomeClass::Constructor()\n  ///       : aaaaaaaa(aaaaaaaa), aaaaaaaa(aaaaaaaa), aaaaaaaa(aaaaaaaaaaaaaaaaaaaaaaaaa) {\n  ///     return 0;\n  ///   }\n  ///\n  ///   false:\n  ///   SomeClass::Constructor()\n  ///       : aaaaaaaa(aaaaaaaa), aaaaaaaa(aaaaaaaa),\n  ///         aaaaaaaa(aaaaaaaaaaaaaaaaaaaaaaaaa) {\n  ///     return 0;\n  ///   }\n  /// \\endcode\n  bool ConstructorInitializerAllOnOneLineOrOnePerLine;\n  // clang-format on\n\n  /// The number of characters to use for indentation of constructor\n  /// initializer lists as well as inheritance lists.\n  unsigned ConstructorInitializerIndentWidth;\n\n  /// Indent width for line continuations.\n  /// \\code\n  ///    ContinuationIndentWidth: 2\n  ///\n  ///    int i =         //  VeryVeryVeryVeryVeryLongComment\n  ///      longFunction( // Again a long comment\n  ///        arg);\n  /// \\endcode\n  unsigned ContinuationIndentWidth;\n\n  /// If ``true``, format braced lists as best suited for C++11 braced\n  /// lists.\n  ///\n  /// Important differences:\n  /// - No spaces inside the braced list.\n  /// - No line break before the closing brace.\n  /// - Indentation with the continuation indent, not with the block indent.\n  ///\n  /// Fundamentally, C++11 braced lists are formatted exactly like function\n  /// calls would be formatted in their place. If the braced list follows a name\n  /// (e.g. a type or variable name), clang-format formats as if the ``{}`` were\n  /// the parentheses of a function call with that name. If there is no name,\n  /// a zero-length name is assumed.\n  /// \\code\n  ///    true:                                  false:\n  ///    vector<int> x{1, 2, 3, 4};     vs.     vector<int> x{ 1, 2, 3, 4 };\n  ///    vector<T> x{{}, {}, {}, {}};           vector<T> x{ {}, {}, {}, {} };\n  ///    f(MyMap[{composite, key}]);            f(MyMap[{ composite, key }]);\n  ///    new int[3]{1, 2, 3};                   new int[3]{ 1, 2, 3 };\n  /// \\endcode\n  bool Cpp11BracedListStyle;\n\n  /// \\brief Analyze the formatted file for the most used line ending (``\\r\\n``\n  /// or ``\\n``). ``UseCRLF`` is only used as a fallback if none can be derived.\n  bool DeriveLineEnding;\n\n  /// If ``true``, analyze the formatted file for the most common\n  /// alignment of ``&`` and ``*``.\n  /// Pointer and reference alignment styles are going to be updated according\n  /// to the preferences found in the file.\n  /// ``PointerAlignment`` is then used only as fallback.\n  bool DerivePointerAlignment;\n\n  /// Disables formatting completely.\n  bool DisableFormat;\n\n  /// Different styles for empty line before access modifiers.\n  enum EmptyLineBeforeAccessModifierStyle : unsigned char {\n    /// Remove all empty lines before access modifiers.\n    /// \\code\n    ///   struct foo {\n    ///   private:\n    ///     int i;\n    ///   protected:\n    ///     int j;\n    ///     /* comment */\n    ///   public:\n    ///     foo() {}\n    ///   private:\n    ///   protected:\n    ///   };\n    /// \\endcode\n    ELBAMS_Never,\n    /// Keep existing empty lines before access modifiers.\n    ELBAMS_Leave,\n    /// Add empty line only when access modifier starts a new logical block.\n    /// Logical block is a group of one or more member fields or functions.\n    /// \\code\n    ///   struct foo {\n    ///   private:\n    ///     int i;\n    ///\n    ///   protected:\n    ///     int j;\n    ///     /* comment */\n    ///   public:\n    ///     foo() {}\n    ///\n    ///   private:\n    ///   protected:\n    ///   };\n    /// \\endcode\n    ELBAMS_LogicalBlock,\n    /// Always add empty line before access modifiers unless access modifier\n    /// is at the start of struct or class definition.\n    /// \\code\n    ///   struct foo {\n    ///   private:\n    ///     int i;\n    ///\n    ///   protected:\n    ///     int j;\n    ///     /* comment */\n    ///\n    ///   public:\n    ///     foo() {}\n    ///\n    ///   private:\n    ///\n    ///   protected:\n    ///   };\n    /// \\endcode\n    ELBAMS_Always,\n  };\n\n  /// Defines in which cases to put empty line before access modifiers.\n  EmptyLineBeforeAccessModifierStyle EmptyLineBeforeAccessModifier;\n\n  /// If ``true``, clang-format detects whether function calls and\n  /// definitions are formatted with one parameter per line.\n  ///\n  /// Each call can be bin-packed, one-per-line or inconclusive. If it is\n  /// inconclusive, e.g. completely on one line, but a decision needs to be\n  /// made, clang-format analyzes whether there are other bin-packed cases in\n  /// the input file and act accordingly.\n  ///\n  /// NOTE: This is an experimental flag, that might go away or be renamed. Do\n  /// not use this in config files, etc. Use at your own risk.\n  bool ExperimentalAutoDetectBinPacking;\n\n  /// If ``true``, clang-format adds missing namespace end comments for\n  /// short namespaces and fixes invalid existing ones. Short ones are\n  /// controlled by \"ShortNamespaceLines\".\n  /// \\code\n  ///    true:                                  false:\n  ///    namespace a {                  vs.     namespace a {\n  ///    foo();                                 foo();\n  ///    bar();                                 bar();\n  ///    } // namespace a                       }\n  /// \\endcode\n  bool FixNamespaceComments;\n\n  /// A vector of macros that should be interpreted as foreach loops\n  /// instead of as function calls.\n  ///\n  /// These are expected to be macros of the form:\n  /// \\code\n  ///   FOREACH(<variable-declaration>, ...)\n  ///     <loop-body>\n  /// \\endcode\n  ///\n  /// In the .clang-format configuration file, this can be configured like:\n  /// \\code{.yaml}\n  ///   ForEachMacros: ['RANGES_FOR', 'FOREACH']\n  /// \\endcode\n  ///\n  /// For example: BOOST_FOREACH.\n  std::vector<std::string> ForEachMacros;\n\n  /// \\brief A vector of macros that should be interpreted as type declarations\n  /// instead of as function calls.\n  ///\n  /// These are expected to be macros of the form:\n  /// \\code\n  ///   STACK_OF(...)\n  /// \\endcode\n  ///\n  /// In the .clang-format configuration file, this can be configured like:\n  /// \\code{.yaml}\n  ///   TypenameMacros: ['STACK_OF', 'LIST']\n  /// \\endcode\n  ///\n  /// For example: OpenSSL STACK_OF, BSD LIST_ENTRY.\n  std::vector<std::string> TypenameMacros;\n\n  /// A vector of macros that should be interpreted as complete\n  /// statements.\n  ///\n  /// Typical macros are expressions, and require a semi-colon to be\n  /// added; sometimes this is not the case, and this allows to make\n  /// clang-format aware of such cases.\n  ///\n  /// For example: Q_UNUSED\n  std::vector<std::string> StatementMacros;\n\n  /// A vector of macros which are used to open namespace blocks.\n  ///\n  /// These are expected to be macros of the form:\n  /// \\code\n  ///   NAMESPACE(<namespace-name>, ...) {\n  ///     <namespace-content>\n  ///   }\n  /// \\endcode\n  ///\n  /// For example: TESTSUITE\n  std::vector<std::string> NamespaceMacros;\n\n  /// A vector of macros which are whitespace-sensitive and should not\n  /// be touched.\n  ///\n  /// These are expected to be macros of the form:\n  /// \\code\n  ///   STRINGIZE(...)\n  /// \\endcode\n  ///\n  /// In the .clang-format configuration file, this can be configured like:\n  /// \\code{.yaml}\n  ///   WhitespaceSensitiveMacros: ['STRINGIZE', 'PP_STRINGIZE']\n  /// \\endcode\n  ///\n  /// For example: BOOST_PP_STRINGIZE\n  std::vector<std::string> WhitespaceSensitiveMacros;\n\n  tooling::IncludeStyle IncludeStyle;\n\n  /// Specify whether access modifiers should have their own indentation level.\n  ///\n  /// When ``false``, access modifiers are indented (or outdented) relative to\n  /// the record members, respecting the ``AccessModifierOffset``. Record\n  /// members are indented one level below the record.\n  /// When ``true``, access modifiers get their own indentation level. As a\n  /// consequence, record members are always indented 2 levels below the record,\n  /// regardless of the access modifier presence. Value of the\n  /// ``AccessModifierOffset`` is ignored.\n  /// \\code\n  ///    false:                                 true:\n  ///    class C {                      vs.     class C {\n  ///      class D {                                class D {\n  ///        void bar();                                void bar();\n  ///      protected:                                 protected:\n  ///        D();                                       D();\n  ///      };                                       };\n  ///    public:                                  public:\n  ///      C();                                     C();\n  ///    };                                     };\n  ///    void foo() {                           void foo() {\n  ///      return 1;                              return 1;\n  ///    }                                      }\n  /// \\endcode\n  bool IndentAccessModifiers;\n\n  /// Indent case labels one level from the switch statement.\n  ///\n  /// When ``false``, use the same indentation level as for the switch\n  /// statement. Switch statement body is always indented one level more than\n  /// case labels (except the first block following the case label, which\n  /// itself indents the code - unless IndentCaseBlocks is enabled).\n  /// \\code\n  ///    false:                                 true:\n  ///    switch (fool) {                vs.     switch (fool) {\n  ///    case 1:                                  case 1:\n  ///      bar();                                   bar();\n  ///      break;                                   break;\n  ///    default:                                 default:\n  ///      plop();                                  plop();\n  ///    }                                      }\n  /// \\endcode\n  bool IndentCaseLabels;\n\n  /// Indent case label blocks one level from the case label.\n  ///\n  /// When ``false``, the block following the case label uses the same\n  /// indentation level as for the case label, treating the case label the same\n  /// as an if-statement.\n  /// When ``true``, the block gets indented as a scope block.\n  /// \\code\n  ///    false:                                 true:\n  ///    switch (fool) {                vs.     switch (fool) {\n  ///    case 1: {                              case 1:\n  ///      bar();                                 {\n  ///    } break;                                   bar();\n  ///    default: {                               }\n  ///      plop();                                break;\n  ///    }                                      default:\n  ///    }                                        {\n  ///                                               plop();\n  ///                                             }\n  ///                                           }\n  /// \\endcode\n  bool IndentCaseBlocks;\n\n  /// Indent goto labels.\n  ///\n  /// When ``false``, goto labels are flushed left.\n  /// \\code\n  ///    true:                                  false:\n  ///    int f() {                      vs.     int f() {\n  ///      if (foo()) {                           if (foo()) {\n  ///      label1:                              label1:\n  ///        bar();                                 bar();\n  ///      }                                      }\n  ///    label2:                                label2:\n  ///      return 1;                              return 1;\n  ///    }                                      }\n  /// \\endcode\n  bool IndentGotoLabels;\n\n  /// Options for indenting preprocessor directives.\n  enum PPDirectiveIndentStyle : unsigned char {\n    /// Does not indent any directives.\n    /// \\code\n    ///    #if FOO\n    ///    #if BAR\n    ///    #include <foo>\n    ///    #endif\n    ///    #endif\n    /// \\endcode\n    PPDIS_None,\n    /// Indents directives after the hash.\n    /// \\code\n    ///    #if FOO\n    ///    #  if BAR\n    ///    #    include <foo>\n    ///    #  endif\n    ///    #endif\n    /// \\endcode\n    PPDIS_AfterHash,\n    /// Indents directives before the hash.\n    /// \\code\n    ///    #if FOO\n    ///      #if BAR\n    ///        #include <foo>\n    ///      #endif\n    ///    #endif\n    /// \\endcode\n    PPDIS_BeforeHash\n  };\n\n  /// The preprocessor directive indenting style to use.\n  PPDirectiveIndentStyle IndentPPDirectives;\n\n  /// Indents extern blocks\n  enum IndentExternBlockStyle : unsigned char {\n    /// Backwards compatible with AfterExternBlock's indenting.\n    /// \\code\n    ///    IndentExternBlock: AfterExternBlock\n    ///    BraceWrapping.AfterExternBlock: true\n    ///    extern \"C\"\n    ///    {\n    ///        void foo();\n    ///    }\n    /// \\endcode\n    ///\n    /// \\code\n    ///    IndentExternBlock: AfterExternBlock\n    ///    BraceWrapping.AfterExternBlock: false\n    ///    extern \"C\" {\n    ///    void foo();\n    ///    }\n    /// \\endcode\n    IEBS_AfterExternBlock,\n    /// Does not indent extern blocks.\n    /// \\code\n    ///     extern \"C\" {\n    ///     void foo();\n    ///     }\n    /// \\endcode\n    IEBS_NoIndent,\n    /// Indents extern blocks.\n    /// \\code\n    ///     extern \"C\" {\n    ///       void foo();\n    ///     }\n    /// \\endcode\n    IEBS_Indent,\n  };\n\n  /// IndentExternBlockStyle is the type of indenting of extern blocks.\n  IndentExternBlockStyle IndentExternBlock;\n\n  /// Indent the requires clause in a template\n  /// \\code\n  ///    true:\n  ///    template <typename It>\n  ///      requires Iterator<It>\n  ///    void sort(It begin, It end) {\n  ///      //....\n  ///    }\n  ///\n  ///    false:\n  ///    template <typename It>\n  ///    requires Iterator<It>\n  ///    void sort(It begin, It end) {\n  ///      //....\n  ///    }\n  /// \\endcode\n  bool IndentRequires;\n\n  /// The number of columns to use for indentation.\n  /// \\code\n  ///    IndentWidth: 3\n  ///\n  ///    void f() {\n  ///       someFunction();\n  ///       if (true, false) {\n  ///          f();\n  ///       }\n  ///    }\n  /// \\endcode\n  unsigned IndentWidth;\n\n  /// Indent if a function definition or declaration is wrapped after the\n  /// type.\n  /// \\code\n  ///    true:\n  ///    LoooooooooooooooooooooooooooooooooooooooongReturnType\n  ///        LoooooooooooooooooooooooooooooooongFunctionDeclaration();\n  ///\n  ///    false:\n  ///    LoooooooooooooooooooooooooooooooooooooooongReturnType\n  ///    LoooooooooooooooooooooooooooooooongFunctionDeclaration();\n  /// \\endcode\n  bool IndentWrappedFunctionNames;\n\n  /// A vector of prefixes ordered by the desired groups for Java imports.\n  ///\n  /// One group's prefix can be a subset of another - the longest prefix is\n  /// always matched. Within a group, the imports are ordered lexicographically.\n  /// Static imports are grouped separately and follow the same group rules.\n  /// By default, static imports are placed before non-static imports,\n  /// but this behavior is changed by another option,\n  /// ``SortJavaStaticImport``.\n  ///\n  /// In the .clang-format configuration file, this can be configured like\n  /// in the following yaml example. This will result in imports being\n  /// formatted as in the Java example below.\n  /// \\code{.yaml}\n  ///   JavaImportGroups: ['com.example', 'com', 'org']\n  /// \\endcode\n  ///\n  /// \\code{.java}\n  ///    import static com.example.function1;\n  ///\n  ///    import static com.test.function2;\n  ///\n  ///    import static org.example.function3;\n  ///\n  ///    import com.example.ClassA;\n  ///    import com.example.Test;\n  ///    import com.example.a.ClassB;\n  ///\n  ///    import com.test.ClassC;\n  ///\n  ///    import org.example.ClassD;\n  /// \\endcode\n  std::vector<std::string> JavaImportGroups;\n\n  /// Quotation styles for JavaScript strings. Does not affect template\n  /// strings.\n  enum JavaScriptQuoteStyle : unsigned char {\n    /// Leave string quotes as they are.\n    /// \\code{.js}\n    ///    string1 = \"foo\";\n    ///    string2 = 'bar';\n    /// \\endcode\n    JSQS_Leave,\n    /// Always use single quotes.\n    /// \\code{.js}\n    ///    string1 = 'foo';\n    ///    string2 = 'bar';\n    /// \\endcode\n    JSQS_Single,\n    /// Always use double quotes.\n    /// \\code{.js}\n    ///    string1 = \"foo\";\n    ///    string2 = \"bar\";\n    /// \\endcode\n    JSQS_Double\n  };\n\n  /// The JavaScriptQuoteStyle to use for JavaScript strings.\n  JavaScriptQuoteStyle JavaScriptQuotes;\n\n  // clang-format off\n  /// Whether to wrap JavaScript import/export statements.\n  /// \\code{.js}\n  ///    true:\n  ///    import {\n  ///        VeryLongImportsAreAnnoying,\n  ///        VeryLongImportsAreAnnoying,\n  ///        VeryLongImportsAreAnnoying,\n  ///    } from 'some/module.js'\n  ///\n  ///    false:\n  ///    import {VeryLongImportsAreAnnoying, VeryLongImportsAreAnnoying, VeryLongImportsAreAnnoying,} from \"some/module.js\"\n  /// \\endcode\n  bool JavaScriptWrapImports;\n  // clang-format on\n\n  /// If true, the empty line at the start of blocks is kept.\n  /// \\code\n  ///    true:                                  false:\n  ///    if (foo) {                     vs.     if (foo) {\n  ///                                             bar();\n  ///      bar();                               }\n  ///    }\n  /// \\endcode\n  bool KeepEmptyLinesAtTheStartOfBlocks;\n\n  /// Supported languages.\n  ///\n  /// When stored in a configuration file, specifies the language, that the\n  /// configuration targets. When passed to the ``reformat()`` function, enables\n  /// syntax features specific to the language.\n  enum LanguageKind : unsigned char {\n    /// Do not use.\n    LK_None,\n    /// Should be used for C, C++.\n    LK_Cpp,\n    /// Should be used for C#.\n    LK_CSharp,\n    /// Should be used for Java.\n    LK_Java,\n    /// Should be used for JavaScript.\n    LK_JavaScript,\n    /// Should be used for Objective-C, Objective-C++.\n    LK_ObjC,\n    /// Should be used for Protocol Buffers\n    /// (https://developers.google.com/protocol-buffers/).\n    LK_Proto,\n    /// Should be used for TableGen code.\n    LK_TableGen,\n    /// Should be used for Protocol Buffer messages in text format\n    /// (https://developers.google.com/protocol-buffers/).\n    LK_TextProto\n  };\n  bool isCpp() const { return Language == LK_Cpp || Language == LK_ObjC; }\n  bool isCSharp() const { return Language == LK_CSharp; }\n\n  /// Language, this format style is targeted at.\n  LanguageKind Language;\n\n  /// A regular expression matching macros that start a block.\n  /// \\code\n  ///    # With:\n  ///    MacroBlockBegin: \"^NS_MAP_BEGIN|\\\n  ///    NS_TABLE_HEAD$\"\n  ///    MacroBlockEnd: \"^\\\n  ///    NS_MAP_END|\\\n  ///    NS_TABLE_.*_END$\"\n  ///\n  ///    NS_MAP_BEGIN\n  ///      foo();\n  ///    NS_MAP_END\n  ///\n  ///    NS_TABLE_HEAD\n  ///      bar();\n  ///    NS_TABLE_FOO_END\n  ///\n  ///    # Without:\n  ///    NS_MAP_BEGIN\n  ///    foo();\n  ///    NS_MAP_END\n  ///\n  ///    NS_TABLE_HEAD\n  ///    bar();\n  ///    NS_TABLE_FOO_END\n  /// \\endcode\n  std::string MacroBlockBegin;\n\n  /// A regular expression matching macros that end a block.\n  std::string MacroBlockEnd;\n\n  /// The maximum number of consecutive empty lines to keep.\n  /// \\code\n  ///    MaxEmptyLinesToKeep: 1         vs.     MaxEmptyLinesToKeep: 0\n  ///    int f() {                              int f() {\n  ///      int = 1;                                 int i = 1;\n  ///                                               i = foo();\n  ///      i = foo();                               return i;\n  ///                                           }\n  ///      return i;\n  ///    }\n  /// \\endcode\n  unsigned MaxEmptyLinesToKeep;\n\n  /// Different ways to indent namespace contents.\n  enum NamespaceIndentationKind : unsigned char {\n    /// Don't indent in namespaces.\n    /// \\code\n    ///    namespace out {\n    ///    int i;\n    ///    namespace in {\n    ///    int i;\n    ///    }\n    ///    }\n    /// \\endcode\n    NI_None,\n    /// Indent only in inner namespaces (nested in other namespaces).\n    /// \\code\n    ///    namespace out {\n    ///    int i;\n    ///    namespace in {\n    ///      int i;\n    ///    }\n    ///    }\n    /// \\endcode\n    NI_Inner,\n    /// Indent in all namespaces.\n    /// \\code\n    ///    namespace out {\n    ///      int i;\n    ///      namespace in {\n    ///        int i;\n    ///      }\n    ///    }\n    /// \\endcode\n    NI_All\n  };\n\n  /// The indentation used for namespaces.\n  NamespaceIndentationKind NamespaceIndentation;\n\n  /// Controls bin-packing Objective-C protocol conformance list\n  /// items into as few lines as possible when they go over ``ColumnLimit``.\n  ///\n  /// If ``Auto`` (the default), delegates to the value in\n  /// ``BinPackParameters``. If that is ``true``, bin-packs Objective-C\n  /// protocol conformance list items into as few lines as possible\n  /// whenever they go over ``ColumnLimit``.\n  ///\n  /// If ``Always``, always bin-packs Objective-C protocol conformance\n  /// list items into as few lines as possible whenever they go over\n  /// ``ColumnLimit``.\n  ///\n  /// If ``Never``, lays out Objective-C protocol conformance list items\n  /// onto individual lines whenever they go over ``ColumnLimit``.\n  ///\n  /// \\code{.objc}\n  ///    Always (or Auto, if BinPackParameters=true):\n  ///    @interface ccccccccccccc () <\n  ///        ccccccccccccc, ccccccccccccc,\n  ///        ccccccccccccc, ccccccccccccc> {\n  ///    }\n  ///\n  ///    Never (or Auto, if BinPackParameters=false):\n  ///    @interface ddddddddddddd () <\n  ///        ddddddddddddd,\n  ///        ddddddddddddd,\n  ///        ddddddddddddd,\n  ///        ddddddddddddd> {\n  ///    }\n  /// \\endcode\n  BinPackStyle ObjCBinPackProtocolList;\n\n  /// The number of characters to use for indentation of ObjC blocks.\n  /// \\code{.objc}\n  ///    ObjCBlockIndentWidth: 4\n  ///\n  ///    [operation setCompletionBlock:^{\n  ///        [self onOperationDone];\n  ///    }];\n  /// \\endcode\n  unsigned ObjCBlockIndentWidth;\n\n  /// Add a space after ``@property`` in Objective-C, i.e. use\n  /// ``@property (readonly)`` instead of ``@property(readonly)``.\n  bool ObjCSpaceAfterProperty;\n\n  /// Break parameters list into lines when there is nested block\n  /// parameters in a function call.\n  /// \\code\n  ///   false:\n  ///    - (void)_aMethod\n  ///    {\n  ///        [self.test1 t:self w:self callback:^(typeof(self) self, NSNumber\n  ///        *u, NSNumber *v) {\n  ///            u = c;\n  ///        }]\n  ///    }\n  ///    true:\n  ///    - (void)_aMethod\n  ///    {\n  ///       [self.test1 t:self\n  ///                    w:self\n  ///           callback:^(typeof(self) self, NSNumber *u, NSNumber *v) {\n  ///                u = c;\n  ///            }]\n  ///    }\n  /// \\endcode\n  bool ObjCBreakBeforeNestedBlockParam;\n\n  /// Add a space in front of an Objective-C protocol list, i.e. use\n  /// ``Foo <Protocol>`` instead of ``Foo<Protocol>``.\n  bool ObjCSpaceBeforeProtocolList;\n\n  /// The penalty for breaking around an assignment operator.\n  unsigned PenaltyBreakAssignment;\n\n  /// The penalty for breaking a function call after ``call(``.\n  unsigned PenaltyBreakBeforeFirstCallParameter;\n\n  /// The penalty for each line break introduced inside a comment.\n  unsigned PenaltyBreakComment;\n\n  /// The penalty for breaking before the first ``<<``.\n  unsigned PenaltyBreakFirstLessLess;\n\n  /// The penalty for each line break introduced inside a string literal.\n  unsigned PenaltyBreakString;\n\n  /// The penalty for breaking after template declaration.\n  unsigned PenaltyBreakTemplateDeclaration;\n\n  /// The penalty for each character outside of the column limit.\n  unsigned PenaltyExcessCharacter;\n\n  /// Penalty for putting the return type of a function onto its own\n  /// line.\n  unsigned PenaltyReturnTypeOnItsOwnLine;\n\n  /// Penalty for each character of whitespace indentation\n  /// (counted relative to leading non-whitespace column).\n  unsigned PenaltyIndentedWhitespace;\n\n  /// The ``&`` and ``*`` alignment style.\n  enum PointerAlignmentStyle : unsigned char {\n    /// Align pointer to the left.\n    /// \\code\n    ///   int* a;\n    /// \\endcode\n    PAS_Left,\n    /// Align pointer to the right.\n    /// \\code\n    ///   int *a;\n    /// \\endcode\n    PAS_Right,\n    /// Align pointer in the middle.\n    /// \\code\n    ///   int * a;\n    /// \\endcode\n    PAS_Middle\n  };\n\n  /// Pointer and reference alignment style.\n  PointerAlignmentStyle PointerAlignment;\n\n  /// See documentation of ``RawStringFormats``.\n  struct RawStringFormat {\n    /// The language of this raw string.\n    LanguageKind Language;\n    /// A list of raw string delimiters that match this language.\n    std::vector<std::string> Delimiters;\n    /// A list of enclosing function names that match this language.\n    std::vector<std::string> EnclosingFunctions;\n    /// The canonical delimiter for this language.\n    std::string CanonicalDelimiter;\n    /// The style name on which this raw string format is based on.\n    /// If not specified, the raw string format is based on the style that this\n    /// format is based on.\n    std::string BasedOnStyle;\n    bool operator==(const RawStringFormat &Other) const {\n      return Language == Other.Language && Delimiters == Other.Delimiters &&\n             EnclosingFunctions == Other.EnclosingFunctions &&\n             CanonicalDelimiter == Other.CanonicalDelimiter &&\n             BasedOnStyle == Other.BasedOnStyle;\n    }\n  };\n\n  /// Defines hints for detecting supported languages code blocks in raw\n  /// strings.\n  ///\n  /// A raw string with a matching delimiter or a matching enclosing function\n  /// name will be reformatted assuming the specified language based on the\n  /// style for that language defined in the .clang-format file. If no style has\n  /// been defined in the .clang-format file for the specific language, a\n  /// predefined style given by 'BasedOnStyle' is used. If 'BasedOnStyle' is not\n  /// found, the formatting is based on llvm style. A matching delimiter takes\n  /// precedence over a matching enclosing function name for determining the\n  /// language of the raw string contents.\n  ///\n  /// If a canonical delimiter is specified, occurrences of other delimiters for\n  /// the same language will be updated to the canonical if possible.\n  ///\n  /// There should be at most one specification per language and each delimiter\n  /// and enclosing function should not occur in multiple specifications.\n  ///\n  /// To configure this in the .clang-format file, use:\n  /// \\code{.yaml}\n  ///   RawStringFormats:\n  ///     - Language: TextProto\n  ///         Delimiters:\n  ///           - 'pb'\n  ///           - 'proto'\n  ///         EnclosingFunctions:\n  ///           - 'PARSE_TEXT_PROTO'\n  ///         BasedOnStyle: google\n  ///     - Language: Cpp\n  ///         Delimiters:\n  ///           - 'cc'\n  ///           - 'cpp'\n  ///         BasedOnStyle: llvm\n  ///         CanonicalDelimiter: 'cc'\n  /// \\endcode\n  std::vector<RawStringFormat> RawStringFormats;\n\n  // clang-format off\n  /// If ``true``, clang-format will attempt to re-flow comments.\n  /// \\code\n  ///    false:\n  ///    // veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of information\n  ///    /* second veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of information */\n  ///\n  ///    true:\n  ///    // veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of\n  ///    // information\n  ///    /* second veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of\n  ///     * information */\n  /// \\endcode\n  bool ReflowComments;\n  // clang-format on\n\n  /// The maximal number of unwrapped lines that a short namespace spans.\n  /// Defaults to 1.\n  ///\n  /// This determines the maximum length of short namespaces by counting\n  /// unwrapped lines (i.e. containing neither opening nor closing\n  /// namespace brace) and makes \"FixNamespaceComments\" omit adding\n  /// end comments for those.\n  /// \\code\n  ///    ShortNamespaceLines: 1     vs.     ShortNamespaceLines: 0\n  ///    namespace a {                      namespace a {\n  ///      int foo;                           int foo;\n  ///    }                                  } // namespace a\n  ///\n  ///    ShortNamespaceLines: 1     vs.     ShortNamespaceLines: 0\n  ///    namespace b {                      namespace b {\n  ///      int foo;                           int foo;\n  ///      int bar;                           int bar;\n  ///    } // namespace b                   } // namespace b\n  /// \\endcode\n  unsigned ShortNamespaceLines;\n\n  /// Include sorting options.\n  enum SortIncludesOptions : unsigned char {\n    /// Includes are never sorted.\n    /// \\code\n    ///    #include \"B/A.h\"\n    ///    #include \"A/B.h\"\n    ///    #include \"a/b.h\"\n    ///    #include \"A/b.h\"\n    ///    #include \"B/a.h\"\n    /// \\endcode\n    SI_Never,\n    /// Includes are sorted in an ASCIIbetical or case sensitive fashion.\n    /// \\code\n    ///    #include \"A/B.h\"\n    ///    #include \"A/b.h\"\n    ///    #include \"B/A.h\"\n    ///    #include \"B/a.h\"\n    ///    #include \"a/b.h\"\n    /// \\endcode\n    SI_CaseSensitive,\n    /// Includes are sorted in an alphabetical or case insensitive fashion.\n    /// \\code\n    ///    #include \"A/B.h\"\n    ///    #include \"A/b.h\"\n    ///    #include \"a/b.h\"\n    ///    #include \"B/A.h\"\n    ///    #include \"B/a.h\"\n    /// \\endcode\n    SI_CaseInsensitive,\n  };\n\n  /// Controls if and how clang-format will sort ``#includes``.\n  /// If ``Never``, includes are never sorted.\n  /// If ``CaseInsensitive``, includes are sorted in an ASCIIbetical or case\n  /// insensitive fashion.\n  /// If ``CaseSensitive``, includes are sorted in an alphabetical or case\n  /// sensitive fashion.\n  SortIncludesOptions SortIncludes;\n\n  /// Position for Java Static imports.\n  enum SortJavaStaticImportOptions : unsigned char {\n    /// Static imports are placed before non-static imports.\n    /// \\code{.java}\n    ///   import static org.example.function1;\n    ///\n    ///   import org.example.ClassA;\n    /// \\endcode\n    SJSIO_Before,\n    /// Static imports are placed after non-static imports.\n    /// \\code{.java}\n    ///   import org.example.ClassA;\n    ///\n    ///   import static org.example.function1;\n    /// \\endcode\n    SJSIO_After,\n  };\n\n  /// When sorting Java imports, by default static imports are placed before\n  /// non-static imports. If ``JavaStaticImportAfterImport`` is ``After``,\n  /// static imports are placed after non-static imports.\n  SortJavaStaticImportOptions SortJavaStaticImport;\n\n  /// If ``true``, clang-format will sort using declarations.\n  ///\n  /// The order of using declarations is defined as follows:\n  /// Split the strings by \"::\" and discard any initial empty strings. The last\n  /// element of each list is a non-namespace name; all others are namespace\n  /// names. Sort the lists of names lexicographically, where the sort order of\n  /// individual names is that all non-namespace names come before all namespace\n  /// names, and within those groups, names are in case-insensitive\n  /// lexicographic order.\n  /// \\code\n  ///    false:                                 true:\n  ///    using std::cout;               vs.     using std::cin;\n  ///    using std::cin;                        using std::cout;\n  /// \\endcode\n  bool SortUsingDeclarations;\n\n  /// If ``true``, a space is inserted after C style casts.\n  /// \\code\n  ///    true:                                  false:\n  ///    (int) i;                       vs.     (int)i;\n  /// \\endcode\n  bool SpaceAfterCStyleCast;\n\n  /// If ``true``, a space is inserted after the logical not operator (``!``).\n  /// \\code\n  ///    true:                                  false:\n  ///    ! someExpression();            vs.     !someExpression();\n  /// \\endcode\n  bool SpaceAfterLogicalNot;\n\n  /// If \\c true, a space will be inserted after the 'template' keyword.\n  /// \\code\n  ///    true:                                  false:\n  ///    template <int> void foo();     vs.     template<int> void foo();\n  /// \\endcode\n  bool SpaceAfterTemplateKeyword;\n\n  /// Different ways to put a space before opening parentheses.\n  enum SpaceAroundPointerQualifiersStyle : unsigned char {\n    /// Don't ensure spaces around pointer qualifiers and use PointerAlignment\n    /// instead.\n    /// \\code\n    ///    PointerAlignment: Left                 PointerAlignment: Right\n    ///    void* const* x = NULL;         vs.     void *const *x = NULL;\n    /// \\endcode\n    SAPQ_Default,\n    /// Ensure that there is a space before pointer qualifiers.\n    /// \\code\n    ///    PointerAlignment: Left                 PointerAlignment: Right\n    ///    void* const* x = NULL;         vs.     void * const *x = NULL;\n    /// \\endcode\n    SAPQ_Before,\n    /// Ensure that there is a space after pointer qualifiers.\n    /// \\code\n    ///    PointerAlignment: Left                 PointerAlignment: Right\n    ///    void* const * x = NULL;         vs.     void *const *x = NULL;\n    /// \\endcode\n    SAPQ_After,\n    /// Ensure that there is a space both before and after pointer qualifiers.\n    /// \\code\n    ///    PointerAlignment: Left                 PointerAlignment: Right\n    ///    void* const * x = NULL;         vs.     void * const *x = NULL;\n    /// \\endcode\n    SAPQ_Both,\n  };\n\n  ///  Defines in which cases to put a space before or after pointer qualifiers\n  SpaceAroundPointerQualifiersStyle SpaceAroundPointerQualifiers;\n\n  /// If ``false``, spaces will be removed before assignment operators.\n  /// \\code\n  ///    true:                                  false:\n  ///    int a = 5;                     vs.     int a= 5;\n  ///    a += 42;                               a+= 42;\n  /// \\endcode\n  bool SpaceBeforeAssignmentOperators;\n\n  /// If ``false``, spaces will be removed before case colon.\n  /// \\code\n  ///   true:                                   false\n  ///   switch (x) {                    vs.     switch (x) {\n  ///     case 1 : break;                         case 1: break;\n  ///   }                                       }\n  /// \\endcode\n  bool SpaceBeforeCaseColon;\n\n  /// If ``true``, a space will be inserted before a C++11 braced list\n  /// used to initialize an object (after the preceding identifier or type).\n  /// \\code\n  ///    true:                                  false:\n  ///    Foo foo { bar };               vs.     Foo foo{ bar };\n  ///    Foo {};                                Foo{};\n  ///    vector<int> { 1, 2, 3 };               vector<int>{ 1, 2, 3 };\n  ///    new int[3] { 1, 2, 3 };                new int[3]{ 1, 2, 3 };\n  /// \\endcode\n  bool SpaceBeforeCpp11BracedList;\n\n  /// If ``false``, spaces will be removed before constructor initializer\n  /// colon.\n  /// \\code\n  ///    true:                                  false:\n  ///    Foo::Foo() : a(a) {}                   Foo::Foo(): a(a) {}\n  /// \\endcode\n  bool SpaceBeforeCtorInitializerColon;\n\n  /// If ``false``, spaces will be removed before inheritance colon.\n  /// \\code\n  ///    true:                                  false:\n  ///    class Foo : Bar {}             vs.     class Foo: Bar {}\n  /// \\endcode\n  bool SpaceBeforeInheritanceColon;\n\n  /// Different ways to put a space before opening parentheses.\n  enum SpaceBeforeParensOptions : unsigned char {\n    /// Never put a space before opening parentheses.\n    /// \\code\n    ///    void f() {\n    ///      if(true) {\n    ///        f();\n    ///      }\n    ///    }\n    /// \\endcode\n    SBPO_Never,\n    /// Put a space before opening parentheses only after control statement\n    /// keywords (``for/if/while...``).\n    /// \\code\n    ///    void f() {\n    ///      if (true) {\n    ///        f();\n    ///      }\n    ///    }\n    /// \\endcode\n    SBPO_ControlStatements,\n    /// Same as ``SBPO_ControlStatements`` except this option doesn't apply to\n    /// ForEach macros. This is useful in projects where ForEach macros are\n    /// treated as function calls instead of control statements.\n    /// \\code\n    ///    void f() {\n    ///      Q_FOREACH(...) {\n    ///        f();\n    ///      }\n    ///    }\n    /// \\endcode\n    SBPO_ControlStatementsExceptForEachMacros,\n    /// Put a space before opening parentheses only if the parentheses are not\n    /// empty i.e. '()'\n    /// \\code\n    ///   void() {\n    ///     if (true) {\n    ///       f();\n    ///       g (x, y, z);\n    ///     }\n    ///   }\n    /// \\endcode\n    SBPO_NonEmptyParentheses,\n    /// Always put a space before opening parentheses, except when it's\n    /// prohibited by the syntax rules (in function-like macro definitions) or\n    /// when determined by other style rules (after unary operators, opening\n    /// parentheses, etc.)\n    /// \\code\n    ///    void f () {\n    ///      if (true) {\n    ///        f ();\n    ///      }\n    ///    }\n    /// \\endcode\n    SBPO_Always\n  };\n\n  /// Defines in which cases to put a space before opening parentheses.\n  SpaceBeforeParensOptions SpaceBeforeParens;\n\n  /// If ``false``, spaces will be removed before range-based for loop\n  /// colon.\n  /// \\code\n  ///    true:                                  false:\n  ///    for (auto v : values) {}       vs.     for(auto v: values) {}\n  /// \\endcode\n  bool SpaceBeforeRangeBasedForLoopColon;\n\n  /// If ``true``, spaces will be inserted into ``{}``.\n  /// \\code\n  ///    true:                                false:\n  ///    void f() { }                   vs.   void f() {}\n  ///    while (true) { }                     while (true) {}\n  /// \\endcode\n  bool SpaceInEmptyBlock;\n\n  /// If ``true``, spaces may be inserted into ``()``.\n  /// \\code\n  ///    true:                                false:\n  ///    void f( ) {                    vs.   void f() {\n  ///      int x[] = {foo( ), bar( )};          int x[] = {foo(), bar()};\n  ///      if (true) {                          if (true) {\n  ///        f( );                                f();\n  ///      }                                    }\n  ///    }                                    }\n  /// \\endcode\n  bool SpaceInEmptyParentheses;\n\n  /// The number of spaces before trailing line comments\n  /// (``//`` - comments).\n  ///\n  /// This does not affect trailing block comments (``/*`` - comments) as\n  /// those commonly have different usage patterns and a number of special\n  /// cases.\n  /// \\code\n  ///    SpacesBeforeTrailingComments: 3\n  ///    void f() {\n  ///      if (true) {   // foo1\n  ///        f();        // bar\n  ///      }             // foo\n  ///    }\n  /// \\endcode\n  unsigned SpacesBeforeTrailingComments;\n\n  /// If ``true``, spaces will be inserted after ``<`` and before ``>``\n  /// in template argument lists.\n  /// \\code\n  ///    true:                                  false:\n  ///    static_cast< int >(arg);       vs.     static_cast<int>(arg);\n  ///    std::function< void(int) > fct;        std::function<void(int)> fct;\n  /// \\endcode\n  bool SpacesInAngles;\n\n  /// If ``true``, spaces will be inserted around if/for/switch/while\n  /// conditions.\n  /// \\code\n  ///    true:                                  false:\n  ///    if ( a )  { ... }              vs.     if (a) { ... }\n  ///    while ( i < 5 )  { ... }               while (i < 5) { ... }\n  /// \\endcode\n  bool SpacesInConditionalStatement;\n\n  /// If ``true``, spaces are inserted inside container literals (e.g.\n  /// ObjC and Javascript array and dict literals).\n  /// \\code{.js}\n  ///    true:                                  false:\n  ///    var arr = [ 1, 2, 3 ];         vs.     var arr = [1, 2, 3];\n  ///    f({a : 1, b : 2, c : 3});              f({a: 1, b: 2, c: 3});\n  /// \\endcode\n  bool SpacesInContainerLiterals;\n\n  /// If ``true``, spaces may be inserted into C style casts.\n  /// \\code\n  ///    true:                                  false:\n  ///    x = ( int32 )y                 vs.     x = (int32)y\n  /// \\endcode\n  bool SpacesInCStyleCastParentheses;\n\n  /// Control of spaces within a single line comment\n  struct SpacesInLineComment {\n    /// The minimum number of spaces at the start of the comment.\n    unsigned Minimum;\n    /// The maximum number of spaces at the start of the comment.\n    unsigned Maximum;\n  };\n\n  /// How many spaces are allowed at the start of a line comment. To disable the\n  /// maximum set it to ``-1``, apart from that the maximum takes precedence\n  /// over the minimum.\n  /// \\code Minimum = 1 Maximum = -1\n  /// // One space is forced\n  ///\n  /// //  but more spaces are possible\n  ///\n  /// Minimum = 0\n  /// Maximum = 0\n  /// //Forces to start every comment directly after the slashes\n  /// \\endcode\n  ///\n  /// Note that in line comment sections the relative indent of the subsequent\n  /// lines is kept, that means the following:\n  /// \\code\n  /// before:                                   after:\n  /// Minimum: 1\n  /// //if (b) {                                // if (b) {\n  /// //  return true;                          //   return true;\n  /// //}                                       // }\n  ///\n  /// Maximum: 0\n  /// /// List:                                 ///List:\n  /// ///  - Foo                                /// - Foo\n  /// ///    - Bar                              ///   - Bar\n  /// \\endcode\n  SpacesInLineComment SpacesInLineCommentPrefix;\n\n  /// If ``true``, spaces will be inserted after ``(`` and before ``)``.\n  /// \\code\n  ///    true:                                  false:\n  ///    t f( Deleted & ) & = delete;   vs.     t f(Deleted &) & = delete;\n  /// \\endcode\n  bool SpacesInParentheses;\n\n  /// If ``true``, spaces will be inserted after ``[`` and before ``]``.\n  /// Lambdas without arguments or unspecified size array declarations will not\n  /// be affected.\n  /// \\code\n  ///    true:                                  false:\n  ///    int a[ 5 ];                    vs.     int a[5];\n  ///    std::unique_ptr<int[]> foo() {} // Won't be affected\n  /// \\endcode\n  bool SpacesInSquareBrackets;\n\n  /// If ``true``, spaces will be before  ``[``.\n  /// Lambdas will not be affected. Only the first ``[`` will get a space added.\n  /// \\code\n  ///    true:                                  false:\n  ///    int a [5];                    vs.      int a[5];\n  ///    int a [5][5];                 vs.      int a[5][5];\n  /// \\endcode\n  bool SpaceBeforeSquareBrackets;\n\n  /// Styles for adding spacing around ``:`` in bitfield definitions.\n  enum BitFieldColonSpacingStyle : unsigned char {\n    /// Add one space on each side of the ``:``\n    /// \\code\n    ///   unsigned bf : 2;\n    /// \\endcode\n    BFCS_Both,\n    /// Add no space around the ``:`` (except when needed for\n    /// ``AlignConsecutiveBitFields``).\n    /// \\code\n    ///   unsigned bf:2;\n    /// \\endcode\n    BFCS_None,\n    /// Add space before the ``:`` only\n    /// \\code\n    ///   unsigned bf :2;\n    /// \\endcode\n    BFCS_Before,\n    /// Add space after the ``:`` only (space may be added before if\n    /// needed for ``AlignConsecutiveBitFields``).\n    /// \\code\n    ///   unsigned bf: 2;\n    /// \\endcode\n    BFCS_After\n  };\n  /// The BitFieldColonSpacingStyle to use for bitfields.\n  BitFieldColonSpacingStyle BitFieldColonSpacing;\n\n  /// Supported language standards for parsing and formatting C++ constructs.\n  /// \\code\n  ///    Latest:                                vector<set<int>>\n  ///    c++03                          vs.     vector<set<int> >\n  /// \\endcode\n  ///\n  /// The correct way to spell a specific language version is e.g. ``c++11``.\n  /// The historical aliases ``Cpp03`` and ``Cpp11`` are deprecated.\n  enum LanguageStandard : unsigned char {\n    /// Parse and format as C++03.\n    /// ``Cpp03`` is a deprecated alias for ``c++03``\n    LS_Cpp03, // c++03\n    /// Parse and format as C++11.\n    LS_Cpp11, // c++11\n    /// Parse and format as C++14.\n    LS_Cpp14, // c++14\n    /// Parse and format as C++17.\n    LS_Cpp17, // c++17\n    /// Parse and format as C++20.\n    LS_Cpp20, // c++20\n    /// Parse and format using the latest supported language version.\n    /// ``Cpp11`` is a deprecated alias for ``Latest``\n    LS_Latest,\n    /// Automatic detection based on the input.\n    LS_Auto,\n  };\n\n  /// Parse and format C++ constructs compatible with this standard.\n  /// \\code\n  ///    c++03:                                 latest:\n  ///    vector<set<int> > x;           vs.     vector<set<int>> x;\n  /// \\endcode\n  LanguageStandard Standard;\n\n  /// Macros which are ignored in front of a statement, as if they were an\n  /// attribute. So that they are not parsed as identifier, for example for Qts\n  /// emit.\n  /// \\code\n  ///   AlignConsecutiveDeclarations: true\n  ///   StatementAttributeLikeMacros: []\n  ///   unsigned char data = 'x';\n  ///   emit          signal(data); // This is parsed as variable declaration.\n  ///\n  ///   AlignConsecutiveDeclarations: true\n  ///   StatementAttributeLikeMacros: [emit]\n  ///   unsigned char data = 'x';\n  ///   emit signal(data); // Now it's fine again.\n  /// \\endcode\n  std::vector<std::string> StatementAttributeLikeMacros;\n\n  /// The number of columns used for tab stops.\n  unsigned TabWidth;\n\n  /// Different ways to use tab in formatting.\n  enum UseTabStyle : unsigned char {\n    /// Never use tab.\n    UT_Never,\n    /// Use tabs only for indentation.\n    UT_ForIndentation,\n    /// Fill all leading whitespace with tabs, and use spaces for alignment that\n    /// appears within a line (e.g. consecutive assignments and declarations).\n    UT_ForContinuationAndIndentation,\n    /// Use tabs for line continuation and indentation, and spaces for\n    /// alignment.\n    UT_AlignWithSpaces,\n    /// Use tabs whenever we need to fill whitespace that spans at least from\n    /// one tab stop to the next one.\n    UT_Always\n  };\n\n  /// \\brief Use ``\\r\\n`` instead of ``\\n`` for line breaks.\n  /// Also used as fallback if ``DeriveLineEnding`` is true.\n  bool UseCRLF;\n\n  /// The way to use tab characters in the resulting file.\n  UseTabStyle UseTab;\n\n  bool operator==(const FormatStyle &R) const {\n    return AccessModifierOffset == R.AccessModifierOffset &&\n           AlignAfterOpenBracket == R.AlignAfterOpenBracket &&\n           AlignConsecutiveAssignments == R.AlignConsecutiveAssignments &&\n           AlignConsecutiveBitFields == R.AlignConsecutiveBitFields &&\n           AlignConsecutiveDeclarations == R.AlignConsecutiveDeclarations &&\n           AlignConsecutiveMacros == R.AlignConsecutiveMacros &&\n           AlignEscapedNewlines == R.AlignEscapedNewlines &&\n           AlignOperands == R.AlignOperands &&\n           AlignTrailingComments == R.AlignTrailingComments &&\n           AllowAllArgumentsOnNextLine == R.AllowAllArgumentsOnNextLine &&\n           AllowAllConstructorInitializersOnNextLine ==\n               R.AllowAllConstructorInitializersOnNextLine &&\n           AllowAllParametersOfDeclarationOnNextLine ==\n               R.AllowAllParametersOfDeclarationOnNextLine &&\n           AllowShortEnumsOnASingleLine == R.AllowShortEnumsOnASingleLine &&\n           AllowShortBlocksOnASingleLine == R.AllowShortBlocksOnASingleLine &&\n           AllowShortCaseLabelsOnASingleLine ==\n               R.AllowShortCaseLabelsOnASingleLine &&\n           AllowShortFunctionsOnASingleLine ==\n               R.AllowShortFunctionsOnASingleLine &&\n           AllowShortIfStatementsOnASingleLine ==\n               R.AllowShortIfStatementsOnASingleLine &&\n           AllowShortLambdasOnASingleLine == R.AllowShortLambdasOnASingleLine &&\n           AllowShortLoopsOnASingleLine == R.AllowShortLoopsOnASingleLine &&\n           AlwaysBreakAfterReturnType == R.AlwaysBreakAfterReturnType &&\n           AlwaysBreakBeforeMultilineStrings ==\n               R.AlwaysBreakBeforeMultilineStrings &&\n           AlwaysBreakTemplateDeclarations ==\n               R.AlwaysBreakTemplateDeclarations &&\n           AttributeMacros == R.AttributeMacros &&\n           BinPackArguments == R.BinPackArguments &&\n           BinPackParameters == R.BinPackParameters &&\n           BreakBeforeBinaryOperators == R.BreakBeforeBinaryOperators &&\n           BreakBeforeBraces == R.BreakBeforeBraces &&\n           BreakBeforeConceptDeclarations == R.BreakBeforeConceptDeclarations &&\n           BreakBeforeTernaryOperators == R.BreakBeforeTernaryOperators &&\n           BreakConstructorInitializers == R.BreakConstructorInitializers &&\n           CompactNamespaces == R.CompactNamespaces &&\n           BreakAfterJavaFieldAnnotations == R.BreakAfterJavaFieldAnnotations &&\n           BreakStringLiterals == R.BreakStringLiterals &&\n           ColumnLimit == R.ColumnLimit && CommentPragmas == R.CommentPragmas &&\n           BreakInheritanceList == R.BreakInheritanceList &&\n           ConstructorInitializerAllOnOneLineOrOnePerLine ==\n               R.ConstructorInitializerAllOnOneLineOrOnePerLine &&\n           ConstructorInitializerIndentWidth ==\n               R.ConstructorInitializerIndentWidth &&\n           ContinuationIndentWidth == R.ContinuationIndentWidth &&\n           Cpp11BracedListStyle == R.Cpp11BracedListStyle &&\n           DeriveLineEnding == R.DeriveLineEnding &&\n           DerivePointerAlignment == R.DerivePointerAlignment &&\n           DisableFormat == R.DisableFormat &&\n           EmptyLineBeforeAccessModifier == R.EmptyLineBeforeAccessModifier &&\n           ExperimentalAutoDetectBinPacking ==\n               R.ExperimentalAutoDetectBinPacking &&\n           FixNamespaceComments == R.FixNamespaceComments &&\n           ForEachMacros == R.ForEachMacros &&\n           IncludeStyle.IncludeBlocks == R.IncludeStyle.IncludeBlocks &&\n           IncludeStyle.IncludeCategories == R.IncludeStyle.IncludeCategories &&\n           IncludeStyle.IncludeIsMainRegex ==\n               R.IncludeStyle.IncludeIsMainRegex &&\n           IncludeStyle.IncludeIsMainSourceRegex ==\n               R.IncludeStyle.IncludeIsMainSourceRegex &&\n           IndentAccessModifiers == R.IndentAccessModifiers &&\n           IndentCaseLabels == R.IndentCaseLabels &&\n           IndentCaseBlocks == R.IndentCaseBlocks &&\n           IndentGotoLabels == R.IndentGotoLabels &&\n           IndentPPDirectives == R.IndentPPDirectives &&\n           IndentExternBlock == R.IndentExternBlock &&\n           IndentRequires == R.IndentRequires && IndentWidth == R.IndentWidth &&\n           Language == R.Language &&\n           IndentWrappedFunctionNames == R.IndentWrappedFunctionNames &&\n           JavaImportGroups == R.JavaImportGroups &&\n           JavaScriptQuotes == R.JavaScriptQuotes &&\n           JavaScriptWrapImports == R.JavaScriptWrapImports &&\n           KeepEmptyLinesAtTheStartOfBlocks ==\n               R.KeepEmptyLinesAtTheStartOfBlocks &&\n           MacroBlockBegin == R.MacroBlockBegin &&\n           MacroBlockEnd == R.MacroBlockEnd &&\n           MaxEmptyLinesToKeep == R.MaxEmptyLinesToKeep &&\n           NamespaceIndentation == R.NamespaceIndentation &&\n           NamespaceMacros == R.NamespaceMacros &&\n           ObjCBinPackProtocolList == R.ObjCBinPackProtocolList &&\n           ObjCBlockIndentWidth == R.ObjCBlockIndentWidth &&\n           ObjCBreakBeforeNestedBlockParam ==\n               R.ObjCBreakBeforeNestedBlockParam &&\n           ObjCSpaceAfterProperty == R.ObjCSpaceAfterProperty &&\n           ObjCSpaceBeforeProtocolList == R.ObjCSpaceBeforeProtocolList &&\n           PenaltyBreakAssignment == R.PenaltyBreakAssignment &&\n           PenaltyBreakBeforeFirstCallParameter ==\n               R.PenaltyBreakBeforeFirstCallParameter &&\n           PenaltyBreakComment == R.PenaltyBreakComment &&\n           PenaltyBreakFirstLessLess == R.PenaltyBreakFirstLessLess &&\n           PenaltyBreakString == R.PenaltyBreakString &&\n           PenaltyExcessCharacter == R.PenaltyExcessCharacter &&\n           PenaltyReturnTypeOnItsOwnLine == R.PenaltyReturnTypeOnItsOwnLine &&\n           PenaltyBreakTemplateDeclaration ==\n               R.PenaltyBreakTemplateDeclaration &&\n           PointerAlignment == R.PointerAlignment &&\n           RawStringFormats == R.RawStringFormats &&\n           ShortNamespaceLines == R.ShortNamespaceLines &&\n           SortIncludes == R.SortIncludes &&\n           SortJavaStaticImport == R.SortJavaStaticImport &&\n           SpaceAfterCStyleCast == R.SpaceAfterCStyleCast &&\n           SpaceAfterLogicalNot == R.SpaceAfterLogicalNot &&\n           SpaceAfterTemplateKeyword == R.SpaceAfterTemplateKeyword &&\n           SpaceBeforeAssignmentOperators == R.SpaceBeforeAssignmentOperators &&\n           SpaceBeforeCaseColon == R.SpaceBeforeCaseColon &&\n           SpaceBeforeCpp11BracedList == R.SpaceBeforeCpp11BracedList &&\n           SpaceBeforeCtorInitializerColon ==\n               R.SpaceBeforeCtorInitializerColon &&\n           SpaceBeforeInheritanceColon == R.SpaceBeforeInheritanceColon &&\n           SpaceBeforeParens == R.SpaceBeforeParens &&\n           SpaceAroundPointerQualifiers == R.SpaceAroundPointerQualifiers &&\n           SpaceBeforeRangeBasedForLoopColon ==\n               R.SpaceBeforeRangeBasedForLoopColon &&\n           SpaceInEmptyBlock == R.SpaceInEmptyBlock &&\n           SpaceInEmptyParentheses == R.SpaceInEmptyParentheses &&\n           SpacesBeforeTrailingComments == R.SpacesBeforeTrailingComments &&\n           SpacesInAngles == R.SpacesInAngles &&\n           SpacesInConditionalStatement == R.SpacesInConditionalStatement &&\n           SpacesInContainerLiterals == R.SpacesInContainerLiterals &&\n           SpacesInCStyleCastParentheses == R.SpacesInCStyleCastParentheses &&\n           SpacesInLineCommentPrefix.Minimum ==\n               R.SpacesInLineCommentPrefix.Minimum &&\n           SpacesInLineCommentPrefix.Maximum ==\n               R.SpacesInLineCommentPrefix.Maximum &&\n           SpacesInParentheses == R.SpacesInParentheses &&\n           SpacesInSquareBrackets == R.SpacesInSquareBrackets &&\n           SpaceBeforeSquareBrackets == R.SpaceBeforeSquareBrackets &&\n           BitFieldColonSpacing == R.BitFieldColonSpacing &&\n           Standard == R.Standard &&\n           StatementAttributeLikeMacros == R.StatementAttributeLikeMacros &&\n           StatementMacros == R.StatementMacros && TabWidth == R.TabWidth &&\n           UseTab == R.UseTab && UseCRLF == R.UseCRLF &&\n           TypenameMacros == R.TypenameMacros;\n  }\n\n  llvm::Optional<FormatStyle> GetLanguageStyle(LanguageKind Language) const;\n\n  // Stores per-language styles. A FormatStyle instance inside has an empty\n  // StyleSet. A FormatStyle instance returned by the Get method has its\n  // StyleSet set to a copy of the originating StyleSet, effectively keeping the\n  // internal representation of that StyleSet alive.\n  //\n  // The memory management and ownership reminds of a birds nest: chicks\n  // leaving the nest take photos of the nest with them.\n  struct FormatStyleSet {\n    typedef std::map<FormatStyle::LanguageKind, FormatStyle> MapType;\n\n    llvm::Optional<FormatStyle> Get(FormatStyle::LanguageKind Language) const;\n\n    // Adds \\p Style to this FormatStyleSet. Style must not have an associated\n    // FormatStyleSet.\n    // Style.Language should be different than LK_None. If this FormatStyleSet\n    // already contains an entry for Style.Language, that gets replaced with the\n    // passed Style.\n    void Add(FormatStyle Style);\n\n    // Clears this FormatStyleSet.\n    void Clear();\n\n  private:\n    std::shared_ptr<MapType> Styles;\n  };\n\n  static FormatStyleSet BuildStyleSetFromConfiguration(\n      const FormatStyle &MainStyle,\n      const std::vector<FormatStyle> &ConfigurationStyles);\n\nprivate:\n  FormatStyleSet StyleSet;\n\n  friend std::error_code\n  parseConfiguration(llvm::MemoryBufferRef Config, FormatStyle *Style,\n                     bool AllowUnknownOptions,\n                     llvm::SourceMgr::DiagHandlerTy DiagHandler,\n                     void *DiagHandlerCtxt);\n};\n\n/// Returns a format style complying with the LLVM coding standards:\n/// http://llvm.org/docs/CodingStandards.html.\nFormatStyle getLLVMStyle(\n    FormatStyle::LanguageKind Language = FormatStyle::LanguageKind::LK_Cpp);\n\n/// Returns a format style complying with one of Google's style guides:\n/// http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml.\n/// http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml.\n/// https://developers.google.com/protocol-buffers/docs/style.\nFormatStyle getGoogleStyle(FormatStyle::LanguageKind Language);\n\n/// Returns a format style complying with Chromium's style guide:\n/// http://www.chromium.org/developers/coding-style.\nFormatStyle getChromiumStyle(FormatStyle::LanguageKind Language);\n\n/// Returns a format style complying with Mozilla's style guide:\n/// https://developer.mozilla.org/en-US/docs/Developer_Guide/Coding_Style.\nFormatStyle getMozillaStyle();\n\n/// Returns a format style complying with Webkit's style guide:\n/// http://www.webkit.org/coding/coding-style.html\nFormatStyle getWebKitStyle();\n\n/// Returns a format style complying with GNU Coding Standards:\n/// http://www.gnu.org/prep/standards/standards.html\nFormatStyle getGNUStyle();\n\n/// Returns a format style complying with Microsoft style guide:\n/// https://docs.microsoft.com/en-us/visualstudio/ide/editorconfig-code-style-settings-reference?view=vs-2017\nFormatStyle getMicrosoftStyle(FormatStyle::LanguageKind Language);\n\n/// Returns style indicating formatting should be not applied at all.\nFormatStyle getNoStyle();\n\n/// Gets a predefined style for the specified language by name.\n///\n/// Currently supported names: LLVM, Google, Chromium, Mozilla. Names are\n/// compared case-insensitively.\n///\n/// Returns ``true`` if the Style has been set.\nbool getPredefinedStyle(StringRef Name, FormatStyle::LanguageKind Language,\n                        FormatStyle *Style);\n\n/// Parse configuration from YAML-formatted text.\n///\n/// Style->Language is used to get the base style, if the ``BasedOnStyle``\n/// option is present.\n///\n/// The FormatStyleSet of Style is reset.\n///\n/// When ``BasedOnStyle`` is not present, options not present in the YAML\n/// document, are retained in \\p Style.\n///\n/// If AllowUnknownOptions is true, no errors are emitted if unknown\n/// format options are occured.\n///\n/// If set all diagnostics are emitted through the DiagHandler.\nstd::error_code\nparseConfiguration(llvm::MemoryBufferRef Config, FormatStyle *Style,\n                   bool AllowUnknownOptions = false,\n                   llvm::SourceMgr::DiagHandlerTy DiagHandler = nullptr,\n                   void *DiagHandlerCtx = nullptr);\n\n/// Like above but accepts an unnamed buffer.\ninline std::error_code parseConfiguration(StringRef Config, FormatStyle *Style,\n                                          bool AllowUnknownOptions = false) {\n  return parseConfiguration(llvm::MemoryBufferRef(Config, \"YAML\"), Style,\n                            AllowUnknownOptions);\n}\n\n/// Gets configuration in a YAML string.\nstd::string configurationAsText(const FormatStyle &Style);\n\n/// Returns the replacements necessary to sort all ``#include`` blocks\n/// that are affected by ``Ranges``.\ntooling::Replacements sortIncludes(const FormatStyle &Style, StringRef Code,\n                                   ArrayRef<tooling::Range> Ranges,\n                                   StringRef FileName,\n                                   unsigned *Cursor = nullptr);\n\n/// Returns the replacements corresponding to applying and formatting\n/// \\p Replaces on success; otheriwse, return an llvm::Error carrying\n/// llvm::StringError.\nllvm::Expected<tooling::Replacements>\nformatReplacements(StringRef Code, const tooling::Replacements &Replaces,\n                   const FormatStyle &Style);\n\n/// Returns the replacements corresponding to applying \\p Replaces and\n/// cleaning up the code after that on success; otherwise, return an llvm::Error\n/// carrying llvm::StringError.\n/// This also supports inserting/deleting C++ #include directives:\n/// - If a replacement has offset UINT_MAX, length 0, and a replacement text\n///   that is an #include directive, this will insert the #include into the\n///   correct block in the \\p Code.\n/// - If a replacement has offset UINT_MAX, length 1, and a replacement text\n///   that is the name of the header to be removed, the header will be removed\n///   from \\p Code if it exists.\n/// The include manipulation is done via `tooling::HeaderInclude`, see its\n/// documentation for more details on how include insertion points are found and\n/// what edits are produced.\nllvm::Expected<tooling::Replacements>\ncleanupAroundReplacements(StringRef Code, const tooling::Replacements &Replaces,\n                          const FormatStyle &Style);\n\n/// Represents the status of a formatting attempt.\nstruct FormattingAttemptStatus {\n  /// A value of ``false`` means that any of the affected ranges were not\n  /// formatted due to a non-recoverable syntax error.\n  bool FormatComplete = true;\n\n  /// If ``FormatComplete`` is false, ``Line`` records a one-based\n  /// original line number at which a syntax error might have occurred. This is\n  /// based on a best-effort analysis and could be imprecise.\n  unsigned Line = 0;\n};\n\n/// Reformats the given \\p Ranges in \\p Code.\n///\n/// Each range is extended on either end to its next bigger logic unit, i.e.\n/// everything that might influence its formatting or might be influenced by its\n/// formatting.\n///\n/// Returns the ``Replacements`` necessary to make all \\p Ranges comply with\n/// \\p Style.\n///\n/// If ``Status`` is non-null, its value will be populated with the status of\n/// this formatting attempt. See \\c FormattingAttemptStatus.\ntooling::Replacements reformat(const FormatStyle &Style, StringRef Code,\n                               ArrayRef<tooling::Range> Ranges,\n                               StringRef FileName = \"<stdin>\",\n                               FormattingAttemptStatus *Status = nullptr);\n\n/// Same as above, except if ``IncompleteFormat`` is non-null, its value\n/// will be set to true if any of the affected ranges were not formatted due to\n/// a non-recoverable syntax error.\ntooling::Replacements reformat(const FormatStyle &Style, StringRef Code,\n                               ArrayRef<tooling::Range> Ranges,\n                               StringRef FileName, bool *IncompleteFormat);\n\n/// Clean up any erroneous/redundant code in the given \\p Ranges in \\p\n/// Code.\n///\n/// Returns the ``Replacements`` that clean up all \\p Ranges in \\p Code.\ntooling::Replacements cleanup(const FormatStyle &Style, StringRef Code,\n                              ArrayRef<tooling::Range> Ranges,\n                              StringRef FileName = \"<stdin>\");\n\n/// Fix namespace end comments in the given \\p Ranges in \\p Code.\n///\n/// Returns the ``Replacements`` that fix the namespace comments in all\n/// \\p Ranges in \\p Code.\ntooling::Replacements fixNamespaceEndComments(const FormatStyle &Style,\n                                              StringRef Code,\n                                              ArrayRef<tooling::Range> Ranges,\n                                              StringRef FileName = \"<stdin>\");\n\n/// Sort consecutive using declarations in the given \\p Ranges in\n/// \\p Code.\n///\n/// Returns the ``Replacements`` that sort the using declarations in all\n/// \\p Ranges in \\p Code.\ntooling::Replacements sortUsingDeclarations(const FormatStyle &Style,\n                                            StringRef Code,\n                                            ArrayRef<tooling::Range> Ranges,\n                                            StringRef FileName = \"<stdin>\");\n\n/// Returns the ``LangOpts`` that the formatter expects you to set.\n///\n/// \\param Style determines specific settings for lexing mode.\nLangOptions getFormattingLangOpts(const FormatStyle &Style = getLLVMStyle());\n\n/// Description to be used for help text for a ``llvm::cl`` option for\n/// specifying format style. The description is closely related to the operation\n/// of ``getStyle()``.\nextern const char *StyleOptionHelpDescription;\n\n/// The suggested format style to use by default. This allows tools using\n/// `getStyle` to have a consistent default style.\n/// Different builds can modify the value to the preferred styles.\nextern const char *DefaultFormatStyle;\n\n/// The suggested predefined style to use as the fallback style in `getStyle`.\n/// Different builds can modify the value to the preferred styles.\nextern const char *DefaultFallbackStyle;\n\n/// Construct a FormatStyle based on ``StyleName``.\n///\n/// ``StyleName`` can take several forms:\n/// * \"{<key>: <value>, ...}\" - Set specic style parameters.\n/// * \"<style name>\" - One of the style names supported by\n/// getPredefinedStyle().\n/// * \"file\" - Load style configuration from a file called ``.clang-format``\n/// located in one of the parent directories of ``FileName`` or the current\n/// directory if ``FileName`` is empty.\n///\n/// \\param[in] StyleName Style name to interpret according to the description\n/// above.\n/// \\param[in] FileName Path to start search for .clang-format if ``StyleName``\n/// == \"file\".\n/// \\param[in] FallbackStyle The name of a predefined style used to fallback to\n/// in case \\p StyleName is \"file\" and no file can be found.\n/// \\param[in] Code The actual code to be formatted. Used to determine the\n/// language if the filename isn't sufficient.\n/// \\param[in] FS The underlying file system, in which the file resides. By\n/// default, the file system is the real file system.\n/// \\param[in] AllowUnknownOptions If true, unknown format options only\n///             emit a warning. If false, errors are emitted on unknown format\n///             options.\n///\n/// \\returns FormatStyle as specified by ``StyleName``. If ``StyleName`` is\n/// \"file\" and no file is found, returns ``FallbackStyle``. If no style could be\n/// determined, returns an Error.\nllvm::Expected<FormatStyle> getStyle(StringRef StyleName, StringRef FileName,\n                                     StringRef FallbackStyle,\n                                     StringRef Code = \"\",\n                                     llvm::vfs::FileSystem *FS = nullptr,\n                                     bool AllowUnknownOptions = false);\n\n// Guesses the language from the ``FileName`` and ``Code`` to be formatted.\n// Defaults to FormatStyle::LK_Cpp.\nFormatStyle::LanguageKind guessLanguage(StringRef FileName, StringRef Code);\n\n// Returns a string representation of ``Language``.\ninline StringRef getLanguageName(FormatStyle::LanguageKind Language) {\n  switch (Language) {\n  case FormatStyle::LK_Cpp:\n    return \"C++\";\n  case FormatStyle::LK_CSharp:\n    return \"CSharp\";\n  case FormatStyle::LK_ObjC:\n    return \"Objective-C\";\n  case FormatStyle::LK_Java:\n    return \"Java\";\n  case FormatStyle::LK_JavaScript:\n    return \"JavaScript\";\n  case FormatStyle::LK_Proto:\n    return \"Proto\";\n  case FormatStyle::LK_TableGen:\n    return \"TableGen\";\n  case FormatStyle::LK_TextProto:\n    return \"TextProto\";\n  default:\n    return \"Unknown\";\n  }\n}\n\n} // end namespace format\n} // end namespace clang\n\nnamespace std {\ntemplate <>\nstruct is_error_code_enum<clang::format::ParseError> : std::true_type {};\n} // namespace std\n\n#endif // LLVM_CLANG_FORMAT_FORMAT_H\n"}, "16": {"id": 16, "path": "/home/vsts/work/1/llvm-project/clang/lib/Format/Format.cpp", "content": "//===--- Format.cpp - Format C++ code -------------------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n///\n/// \\file\n/// This file implements functions declared in Format.h. This will be\n/// split into separate files as we go.\n///\n//===----------------------------------------------------------------------===//\n\n#include \"clang/Format/Format.h\"\n#include \"AffectedRangeManager.h\"\n#include \"BreakableToken.h\"\n#include \"ContinuationIndenter.h\"\n#include \"FormatInternal.h\"\n#include \"FormatTokenLexer.h\"\n#include \"NamespaceEndCommentsFixer.h\"\n#include \"SortJavaScriptImports.h\"\n#include \"TokenAnalyzer.h\"\n#include \"TokenAnnotator.h\"\n#include \"UnwrappedLineFormatter.h\"\n#include \"UnwrappedLineParser.h\"\n#include \"UsingDeclarationsSorter.h\"\n#include \"WhitespaceManager.h\"\n#include \"clang/Basic/Diagnostic.h\"\n#include \"clang/Basic/DiagnosticOptions.h\"\n#include \"clang/Basic/SourceManager.h\"\n#include \"clang/Lex/Lexer.h\"\n#include \"clang/Tooling/Inclusions/HeaderIncludes.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/Debug.h\"\n#include \"llvm/Support/Path.h\"\n#include \"llvm/Support/Regex.h\"\n#include \"llvm/Support/VirtualFileSystem.h\"\n#include \"llvm/Support/YAMLTraits.h\"\n#include <algorithm>\n#include <memory>\n#include <mutex>\n#include <string>\n#include <unordered_map>\n\n#define DEBUG_TYPE \"format-formatter\"\n\nusing clang::format::FormatStyle;\n\nLLVM_YAML_IS_SEQUENCE_VECTOR(clang::format::FormatStyle::RawStringFormat)\n\nnamespace llvm {\nnamespace yaml {\ntemplate <> struct ScalarEnumerationTraits<FormatStyle::LanguageKind> {\n  static void enumeration(IO &IO, FormatStyle::LanguageKind &Value) {\n    IO.enumCase(Value, \"Cpp\", FormatStyle::LK_Cpp);\n    IO.enumCase(Value, \"Java\", FormatStyle::LK_Java);\n    IO.enumCase(Value, \"JavaScript\", FormatStyle::LK_JavaScript);\n    IO.enumCase(Value, \"ObjC\", FormatStyle::LK_ObjC);\n    IO.enumCase(Value, \"Proto\", FormatStyle::LK_Proto);\n    IO.enumCase(Value, \"TableGen\", FormatStyle::LK_TableGen);\n    IO.enumCase(Value, \"TextProto\", FormatStyle::LK_TextProto);\n    IO.enumCase(Value, \"CSharp\", FormatStyle::LK_CSharp);\n  }\n};\n\ntemplate <> struct ScalarEnumerationTraits<FormatStyle::LanguageStandard> {\n  static void enumeration(IO &IO, FormatStyle::LanguageStandard &Value) {\n    IO.enumCase(Value, \"c++03\", FormatStyle::LS_Cpp03);\n    IO.enumCase(Value, \"C++03\", FormatStyle::LS_Cpp03); // Legacy alias\n    IO.enumCase(Value, \"Cpp03\", FormatStyle::LS_Cpp03); // Legacy alias\n\n    IO.enumCase(Value, \"c++11\", FormatStyle::LS_Cpp11);\n    IO.enumCase(Value, \"C++11\", FormatStyle::LS_Cpp11); // Legacy alias\n\n    IO.enumCase(Value, \"c++14\", FormatStyle::LS_Cpp14);\n    IO.enumCase(Value, \"c++17\", FormatStyle::LS_Cpp17);\n    IO.enumCase(Value, \"c++20\", FormatStyle::LS_Cpp20);\n\n    IO.enumCase(Value, \"Latest\", FormatStyle::LS_Latest);\n    IO.enumCase(Value, \"Cpp11\", FormatStyle::LS_Latest); // Legacy alias\n    IO.enumCase(Value, \"Auto\", FormatStyle::LS_Auto);\n  }\n};\n\ntemplate <> struct ScalarEnumerationTraits<FormatStyle::UseTabStyle> {\n  static void enumeration(IO &IO, FormatStyle::UseTabStyle &Value) {\n    IO.enumCase(Value, \"Never\", FormatStyle::UT_Never);\n    IO.enumCase(Value, \"false\", FormatStyle::UT_Never);\n    IO.enumCase(Value, \"Always\", FormatStyle::UT_Always);\n    IO.enumCase(Value, \"true\", FormatStyle::UT_Always);\n    IO.enumCase(Value, \"ForIndentation\", FormatStyle::UT_ForIndentation);\n    IO.enumCase(Value, \"ForContinuationAndIndentation\",\n                FormatStyle::UT_ForContinuationAndIndentation);\n    IO.enumCase(Value, \"AlignWithSpaces\", FormatStyle::UT_AlignWithSpaces);\n  }\n};\n\ntemplate <> struct ScalarEnumerationTraits<FormatStyle::JavaScriptQuoteStyle> {\n  static void enumeration(IO &IO, FormatStyle::JavaScriptQuoteStyle &Value) {\n    IO.enumCase(Value, \"Leave\", FormatStyle::JSQS_Leave);\n    IO.enumCase(Value, \"Single\", FormatStyle::JSQS_Single);\n    IO.enumCase(Value, \"Double\", FormatStyle::JSQS_Double);\n  }\n};\n\ntemplate <> struct ScalarEnumerationTraits<FormatStyle::ShortBlockStyle> {\n  static void enumeration(IO &IO, FormatStyle::ShortBlockStyle &Value) {\n    IO.enumCase(Value, \"Never\", FormatStyle::SBS_Never);\n    IO.enumCase(Value, \"false\", FormatStyle::SBS_Never);\n    IO.enumCase(Value, \"Always\", FormatStyle::SBS_Always);\n    IO.enumCase(Value, \"true\", FormatStyle::SBS_Always);\n    IO.enumCase(Value, \"Empty\", FormatStyle::SBS_Empty);\n  }\n};\n\ntemplate <> struct ScalarEnumerationTraits<FormatStyle::ShortFunctionStyle> {\n  static void enumeration(IO &IO, FormatStyle::ShortFunctionStyle &Value) {\n    IO.enumCase(Value, \"None\", FormatStyle::SFS_None);\n    IO.enumCase(Value, \"false\", FormatStyle::SFS_None);\n    IO.enumCase(Value, \"All\", FormatStyle::SFS_All);\n    IO.enumCase(Value, \"true\", FormatStyle::SFS_All);\n    IO.enumCase(Value, \"Inline\", FormatStyle::SFS_Inline);\n    IO.enumCase(Value, \"InlineOnly\", FormatStyle::SFS_InlineOnly);\n    IO.enumCase(Value, \"Empty\", FormatStyle::SFS_Empty);\n  }\n};\n\ntemplate <> struct ScalarEnumerationTraits<FormatStyle::AlignConsecutiveStyle> {\n  static void enumeration(IO &IO, FormatStyle::AlignConsecutiveStyle &Value) {\n    IO.enumCase(Value, \"None\", FormatStyle::ACS_None);\n    IO.enumCase(Value, \"Consecutive\", FormatStyle::ACS_Consecutive);\n    IO.enumCase(Value, \"AcrossEmptyLines\", FormatStyle::ACS_AcrossEmptyLines);\n    IO.enumCase(Value, \"AcrossComments\", FormatStyle::ACS_AcrossComments);\n    IO.enumCase(Value, \"AcrossEmptyLinesAndComments\",\n                FormatStyle::ACS_AcrossEmptyLinesAndComments);\n\n    // For backward compability.\n    IO.enumCase(Value, \"true\", FormatStyle::ACS_Consecutive);\n    IO.enumCase(Value, \"false\", FormatStyle::ACS_None);\n  }\n};\n\ntemplate <> struct ScalarEnumerationTraits<FormatStyle::ShortIfStyle> {\n  static void enumeration(IO &IO, FormatStyle::ShortIfStyle &Value) {\n    IO.enumCase(Value, \"Never\", FormatStyle::SIS_Never);\n    IO.enumCase(Value, \"Always\", FormatStyle::SIS_Always);\n    IO.enumCase(Value, \"WithoutElse\", FormatStyle::SIS_WithoutElse);\n\n    // For backward compatibility.\n    IO.enumCase(Value, \"false\", FormatStyle::SIS_Never);\n    IO.enumCase(Value, \"true\", FormatStyle::SIS_WithoutElse);\n  }\n};\n\ntemplate <> struct ScalarEnumerationTraits<FormatStyle::ShortLambdaStyle> {\n  static void enumeration(IO &IO, FormatStyle::ShortLambdaStyle &Value) {\n    IO.enumCase(Value, \"None\", FormatStyle::SLS_None);\n    IO.enumCase(Value, \"false\", FormatStyle::SLS_None);\n    IO.enumCase(Value, \"Empty\", FormatStyle::SLS_Empty);\n    IO.enumCase(Value, \"Inline\", FormatStyle::SLS_Inline);\n    IO.enumCase(Value, \"All\", FormatStyle::SLS_All);\n    IO.enumCase(Value, \"true\", FormatStyle::SLS_All);\n  }\n};\n\ntemplate <> struct ScalarEnumerationTraits<FormatStyle::BinPackStyle> {\n  static void enumeration(IO &IO, FormatStyle::BinPackStyle &Value) {\n    IO.enumCase(Value, \"Auto\", FormatStyle::BPS_Auto);\n    IO.enumCase(Value, \"Always\", FormatStyle::BPS_Always);\n    IO.enumCase(Value, \"Never\", FormatStyle::BPS_Never);\n  }\n};\n\ntemplate <> struct ScalarEnumerationTraits<FormatStyle::TrailingCommaStyle> {\n  static void enumeration(IO &IO, FormatStyle::TrailingCommaStyle &Value) {\n    IO.enumCase(Value, \"None\", FormatStyle::TCS_None);\n    IO.enumCase(Value, \"Wrapped\", FormatStyle::TCS_Wrapped);\n  }\n};\n\ntemplate <> struct ScalarEnumerationTraits<FormatStyle::BinaryOperatorStyle> {\n  static void enumeration(IO &IO, FormatStyle::BinaryOperatorStyle &Value) {\n    IO.enumCase(Value, \"All\", FormatStyle::BOS_All);\n    IO.enumCase(Value, \"true\", FormatStyle::BOS_All);\n    IO.enumCase(Value, \"None\", FormatStyle::BOS_None);\n    IO.enumCase(Value, \"false\", FormatStyle::BOS_None);\n    IO.enumCase(Value, \"NonAssignment\", FormatStyle::BOS_NonAssignment);\n  }\n};\n\ntemplate <> struct ScalarEnumerationTraits<FormatStyle::BraceBreakingStyle> {\n  static void enumeration(IO &IO, FormatStyle::BraceBreakingStyle &Value) {\n    IO.enumCase(Value, \"Attach\", FormatStyle::BS_Attach);\n    IO.enumCase(Value, \"Linux\", FormatStyle::BS_Linux);\n    IO.enumCase(Value, \"Mozilla\", FormatStyle::BS_Mozilla);\n    IO.enumCase(Value, \"Stroustrup\", FormatStyle::BS_Stroustrup);\n    IO.enumCase(Value, \"Allman\", FormatStyle::BS_Allman);\n    IO.enumCase(Value, \"Whitesmiths\", FormatStyle::BS_Whitesmiths);\n    IO.enumCase(Value, \"GNU\", FormatStyle::BS_GNU);\n    IO.enumCase(Value, \"WebKit\", FormatStyle::BS_WebKit);\n    IO.enumCase(Value, \"Custom\", FormatStyle::BS_Custom);\n  }\n};\n\ntemplate <>\nstruct ScalarEnumerationTraits<\n    FormatStyle::BraceWrappingAfterControlStatementStyle> {\n  static void\n  enumeration(IO &IO,\n              FormatStyle::BraceWrappingAfterControlStatementStyle &Value) {\n    IO.enumCase(Value, \"Never\", FormatStyle::BWACS_Never);\n    IO.enumCase(Value, \"MultiLine\", FormatStyle::BWACS_MultiLine);\n    IO.enumCase(Value, \"Always\", FormatStyle::BWACS_Always);\n\n    // For backward compatibility.\n    IO.enumCase(Value, \"false\", FormatStyle::BWACS_Never);\n    IO.enumCase(Value, \"true\", FormatStyle::BWACS_Always);\n  }\n};\n\ntemplate <>\nstruct ScalarEnumerationTraits<FormatStyle::BreakConstructorInitializersStyle> {\n  static void\n  enumeration(IO &IO, FormatStyle::BreakConstructorInitializersStyle &Value) {\n    IO.enumCase(Value, \"BeforeColon\", FormatStyle::BCIS_BeforeColon);\n    IO.enumCase(Value, \"BeforeComma\", FormatStyle::BCIS_BeforeComma);\n    IO.enumCase(Value, \"AfterColon\", FormatStyle::BCIS_AfterColon);\n  }\n};\n\ntemplate <>\nstruct ScalarEnumerationTraits<FormatStyle::BreakInheritanceListStyle> {\n  static void enumeration(IO &IO,\n                          FormatStyle::BreakInheritanceListStyle &Value) {\n    IO.enumCase(Value, \"BeforeColon\", FormatStyle::BILS_BeforeColon);\n    IO.enumCase(Value, \"BeforeComma\", FormatStyle::BILS_BeforeComma);\n    IO.enumCase(Value, \"AfterColon\", FormatStyle::BILS_AfterColon);\n  }\n};\n\ntemplate <>\nstruct ScalarEnumerationTraits<\n    FormatStyle::EmptyLineBeforeAccessModifierStyle> {\n  static void\n  enumeration(IO &IO, FormatStyle::EmptyLineBeforeAccessModifierStyle &Value) {\n    IO.enumCase(Value, \"Never\", FormatStyle::ELBAMS_Never);\n    IO.enumCase(Value, \"Leave\", FormatStyle::ELBAMS_Leave);\n    IO.enumCase(Value, \"LogicalBlock\", FormatStyle::ELBAMS_LogicalBlock);\n    IO.enumCase(Value, \"Always\", FormatStyle::ELBAMS_Always);\n  }\n};\n\ntemplate <>\nstruct ScalarEnumerationTraits<FormatStyle::PPDirectiveIndentStyle> {\n  static void enumeration(IO &IO, FormatStyle::PPDirectiveIndentStyle &Value) {\n    IO.enumCase(Value, \"None\", FormatStyle::PPDIS_None);\n    IO.enumCase(Value, \"AfterHash\", FormatStyle::PPDIS_AfterHash);\n    IO.enumCase(Value, \"BeforeHash\", FormatStyle::PPDIS_BeforeHash);\n  }\n};\n\ntemplate <>\nstruct ScalarEnumerationTraits<FormatStyle::IndentExternBlockStyle> {\n  static void enumeration(IO &IO, FormatStyle::IndentExternBlockStyle &Value) {\n    IO.enumCase(Value, \"AfterExternBlock\", FormatStyle::IEBS_AfterExternBlock);\n    IO.enumCase(Value, \"Indent\", FormatStyle::IEBS_Indent);\n    IO.enumCase(Value, \"NoIndent\", FormatStyle::IEBS_NoIndent);\n    IO.enumCase(Value, \"true\", FormatStyle::IEBS_Indent);\n    IO.enumCase(Value, \"false\", FormatStyle::IEBS_NoIndent);\n  }\n};\n\ntemplate <>\nstruct ScalarEnumerationTraits<FormatStyle::ReturnTypeBreakingStyle> {\n  static void enumeration(IO &IO, FormatStyle::ReturnTypeBreakingStyle &Value) {\n    IO.enumCase(Value, \"None\", FormatStyle::RTBS_None);\n    IO.enumCase(Value, \"All\", FormatStyle::RTBS_All);\n    IO.enumCase(Value, \"TopLevel\", FormatStyle::RTBS_TopLevel);\n    IO.enumCase(Value, \"TopLevelDefinitions\",\n                FormatStyle::RTBS_TopLevelDefinitions);\n    IO.enumCase(Value, \"AllDefinitions\", FormatStyle::RTBS_AllDefinitions);\n  }\n};\n\ntemplate <>\nstruct ScalarEnumerationTraits<FormatStyle::BreakTemplateDeclarationsStyle> {\n  static void enumeration(IO &IO,\n                          FormatStyle::BreakTemplateDeclarationsStyle &Value) {\n    IO.enumCase(Value, \"No\", FormatStyle::BTDS_No);\n    IO.enumCase(Value, \"MultiLine\", FormatStyle::BTDS_MultiLine);\n    IO.enumCase(Value, \"Yes\", FormatStyle::BTDS_Yes);\n\n    // For backward compatibility.\n    IO.enumCase(Value, \"false\", FormatStyle::BTDS_MultiLine);\n    IO.enumCase(Value, \"true\", FormatStyle::BTDS_Yes);\n  }\n};\n\ntemplate <>\nstruct ScalarEnumerationTraits<FormatStyle::DefinitionReturnTypeBreakingStyle> {\n  static void\n  enumeration(IO &IO, FormatStyle::DefinitionReturnTypeBreakingStyle &Value) {\n    IO.enumCase(Value, \"None\", FormatStyle::DRTBS_None);\n    IO.enumCase(Value, \"All\", FormatStyle::DRTBS_All);\n    IO.enumCase(Value, \"TopLevel\", FormatStyle::DRTBS_TopLevel);\n\n    // For backward compatibility.\n    IO.enumCase(Value, \"false\", FormatStyle::DRTBS_None);\n    IO.enumCase(Value, \"true\", FormatStyle::DRTBS_All);\n  }\n};\n\ntemplate <>\nstruct ScalarEnumerationTraits<FormatStyle::NamespaceIndentationKind> {\n  static void enumeration(IO &IO,\n                          FormatStyle::NamespaceIndentationKind &Value) {\n    IO.enumCase(Value, \"None\", FormatStyle::NI_None);\n    IO.enumCase(Value, \"Inner\", FormatStyle::NI_Inner);\n    IO.enumCase(Value, \"All\", FormatStyle::NI_All);\n  }\n};\n\ntemplate <> struct ScalarEnumerationTraits<FormatStyle::BracketAlignmentStyle> {\n  static void enumeration(IO &IO, FormatStyle::BracketAlignmentStyle &Value) {\n    IO.enumCase(Value, \"Align\", FormatStyle::BAS_Align);\n    IO.enumCase(Value, \"DontAlign\", FormatStyle::BAS_DontAlign);\n    IO.enumCase(Value, \"AlwaysBreak\", FormatStyle::BAS_AlwaysBreak);\n\n    // For backward compatibility.\n    IO.enumCase(Value, \"true\", FormatStyle::BAS_Align);\n    IO.enumCase(Value, \"false\", FormatStyle::BAS_DontAlign);\n  }\n};\n\ntemplate <>\nstruct ScalarEnumerationTraits<FormatStyle::EscapedNewlineAlignmentStyle> {\n  static void enumeration(IO &IO,\n                          FormatStyle::EscapedNewlineAlignmentStyle &Value) {\n    IO.enumCase(Value, \"DontAlign\", FormatStyle::ENAS_DontAlign);\n    IO.enumCase(Value, \"Left\", FormatStyle::ENAS_Left);\n    IO.enumCase(Value, \"Right\", FormatStyle::ENAS_Right);\n\n    // For backward compatibility.\n    IO.enumCase(Value, \"true\", FormatStyle::ENAS_Left);\n    IO.enumCase(Value, \"false\", FormatStyle::ENAS_Right);\n  }\n};\n\ntemplate <> struct ScalarEnumerationTraits<FormatStyle::OperandAlignmentStyle> {\n  static void enumeration(IO &IO, FormatStyle::OperandAlignmentStyle &Value) {\n    IO.enumCase(Value, \"DontAlign\", FormatStyle::OAS_DontAlign);\n    IO.enumCase(Value, \"Align\", FormatStyle::OAS_Align);\n    IO.enumCase(Value, \"AlignAfterOperator\",\n                FormatStyle::OAS_AlignAfterOperator);\n\n    // For backward compatibility.\n    IO.enumCase(Value, \"true\", FormatStyle::OAS_Align);\n    IO.enumCase(Value, \"false\", FormatStyle::OAS_DontAlign);\n  }\n};\n\ntemplate <> struct ScalarEnumerationTraits<FormatStyle::PointerAlignmentStyle> {\n  static void enumeration(IO &IO, FormatStyle::PointerAlignmentStyle &Value) {\n    IO.enumCase(Value, \"Middle\", FormatStyle::PAS_Middle);\n    IO.enumCase(Value, \"Left\", FormatStyle::PAS_Left);\n    IO.enumCase(Value, \"Right\", FormatStyle::PAS_Right);\n\n    // For backward compatibility.\n    IO.enumCase(Value, \"true\", FormatStyle::PAS_Left);\n    IO.enumCase(Value, \"false\", FormatStyle::PAS_Right);\n  }\n};\n\ntemplate <>\nstruct ScalarEnumerationTraits<FormatStyle::SpaceAroundPointerQualifiersStyle> {\n  static void\n  enumeration(IO &IO, FormatStyle::SpaceAroundPointerQualifiersStyle &Value) {\n    IO.enumCase(Value, \"Default\", FormatStyle::SAPQ_Default);\n    IO.enumCase(Value, \"Before\", FormatStyle::SAPQ_Before);\n    IO.enumCase(Value, \"After\", FormatStyle::SAPQ_After);\n    IO.enumCase(Value, \"Both\", FormatStyle::SAPQ_Both);\n  }\n};\n\ntemplate <>\nstruct ScalarEnumerationTraits<FormatStyle::SpaceBeforeParensOptions> {\n  static void enumeration(IO &IO,\n                          FormatStyle::SpaceBeforeParensOptions &Value) {\n    IO.enumCase(Value, \"Never\", FormatStyle::SBPO_Never);\n    IO.enumCase(Value, \"ControlStatements\",\n                FormatStyle::SBPO_ControlStatements);\n    IO.enumCase(Value, \"ControlStatementsExceptForEachMacros\",\n                FormatStyle::SBPO_ControlStatementsExceptForEachMacros);\n    IO.enumCase(Value, \"NonEmptyParentheses\",\n                FormatStyle::SBPO_NonEmptyParentheses);\n    IO.enumCase(Value, \"Always\", FormatStyle::SBPO_Always);\n\n    // For backward compatibility.\n    IO.enumCase(Value, \"false\", FormatStyle::SBPO_Never);\n    IO.enumCase(Value, \"true\", FormatStyle::SBPO_ControlStatements);\n  }\n};\n\ntemplate <>\nstruct ScalarEnumerationTraits<FormatStyle::BitFieldColonSpacingStyle> {\n  static void enumeration(IO &IO,\n                          FormatStyle::BitFieldColonSpacingStyle &Value) {\n    IO.enumCase(Value, \"Both\", FormatStyle::BFCS_Both);\n    IO.enumCase(Value, \"None\", FormatStyle::BFCS_None);\n    IO.enumCase(Value, \"Before\", FormatStyle::BFCS_Before);\n    IO.enumCase(Value, \"After\", FormatStyle::BFCS_After);\n  }\n};\n\ntemplate <> struct ScalarEnumerationTraits<FormatStyle::SortIncludesOptions> {\n  static void enumeration(IO &IO, FormatStyle::SortIncludesOptions &Value) {\n    IO.enumCase(Value, \"Never\", FormatStyle::SI_Never);\n    IO.enumCase(Value, \"CaseInsensitive\", FormatStyle::SI_CaseInsensitive);\n    IO.enumCase(Value, \"CaseSensitive\", FormatStyle::SI_CaseSensitive);\n\n    // For backward compatibility.\n    IO.enumCase(Value, \"false\", FormatStyle::SI_Never);\n    IO.enumCase(Value, \"true\", FormatStyle::SI_CaseSensitive);\n  }\n};\n\ntemplate <>\nstruct ScalarEnumerationTraits<FormatStyle::SortJavaStaticImportOptions> {\n  static void enumeration(IO &IO,\n                          FormatStyle::SortJavaStaticImportOptions &Value) {\n    IO.enumCase(Value, \"Before\", FormatStyle::SJSIO_Before);\n    IO.enumCase(Value, \"After\", FormatStyle::SJSIO_After);\n  }\n};\n\ntemplate <> struct MappingTraits<FormatStyle> {\n  static void mapping(IO &IO, FormatStyle &Style) {\n    // When reading, read the language first, we need it for getPredefinedStyle.\n    IO.mapOptional(\"Language\", Style.Language);\n\n    if (IO.outputting()) {\n      StringRef StylesArray[] = {\"LLVM\",   \"Google\", \"Chromium\", \"Mozilla\",\n                                 \"WebKit\", \"GNU\",    \"Microsoft\"};\n      ArrayRef<StringRef> Styles(StylesArray);\n      for (size_t i = 0, e = Styles.size(); i < e; ++i) {\n        StringRef StyleName(Styles[i]);\n        FormatStyle PredefinedStyle;\n        if (getPredefinedStyle(StyleName, Style.Language, &PredefinedStyle) &&\n            Style == PredefinedStyle) {\n          IO.mapOptional(\"# BasedOnStyle\", StyleName);\n          break;\n        }\n      }\n    } else {\n      StringRef BasedOnStyle;\n      IO.mapOptional(\"BasedOnStyle\", BasedOnStyle);\n      if (!BasedOnStyle.empty()) {\n        FormatStyle::LanguageKind OldLanguage = Style.Language;\n        FormatStyle::LanguageKind Language =\n            ((FormatStyle *)IO.getContext())->Language;\n        if (!getPredefinedStyle(BasedOnStyle, Language, &Style)) {\n          IO.setError(Twine(\"Unknown value for BasedOnStyle: \", BasedOnStyle));\n          return;\n        }\n        Style.Language = OldLanguage;\n      }\n    }\n\n    // For backward compatibility.\n    if (!IO.outputting()) {\n      IO.mapOptional(\"AlignEscapedNewlinesLeft\", Style.AlignEscapedNewlines);\n      IO.mapOptional(\"DerivePointerBinding\", Style.DerivePointerAlignment);\n      IO.mapOptional(\"IndentFunctionDeclarationAfterType\",\n                     Style.IndentWrappedFunctionNames);\n      IO.mapOptional(\"PointerBindsToType\", Style.PointerAlignment);\n      IO.mapOptional(\"SpaceAfterControlStatementKeyword\",\n                     Style.SpaceBeforeParens);\n    }\n\n    IO.mapOptional(\"AccessModifierOffset\", Style.AccessModifierOffset);\n    IO.mapOptional(\"AlignAfterOpenBracket\", Style.AlignAfterOpenBracket);\n    IO.mapOptional(\"AlignConsecutiveMacros\", Style.AlignConsecutiveMacros);\n    IO.mapOptional(\"AlignConsecutiveAssignments\",\n                   Style.AlignConsecutiveAssignments);\n    IO.mapOptional(\"AlignConsecutiveBitFields\",\n                   Style.AlignConsecutiveBitFields);\n    IO.mapOptional(\"AlignConsecutiveDeclarations\",\n                   Style.AlignConsecutiveDeclarations);\n    IO.mapOptional(\"AlignEscapedNewlines\", Style.AlignEscapedNewlines);\n    IO.mapOptional(\"AlignOperands\", Style.AlignOperands);\n    IO.mapOptional(\"AlignTrailingComments\", Style.AlignTrailingComments);\n    IO.mapOptional(\"AllowAllArgumentsOnNextLine\",\n                   Style.AllowAllArgumentsOnNextLine);\n    IO.mapOptional(\"AllowAllConstructorInitializersOnNextLine\",\n                   Style.AllowAllConstructorInitializersOnNextLine);\n    IO.mapOptional(\"AllowAllParametersOfDeclarationOnNextLine\",\n                   Style.AllowAllParametersOfDeclarationOnNextLine);\n    IO.mapOptional(\"AllowShortEnumsOnASingleLine\",\n                   Style.AllowShortEnumsOnASingleLine);\n    IO.mapOptional(\"AllowShortBlocksOnASingleLine\",\n                   Style.AllowShortBlocksOnASingleLine);\n    IO.mapOptional(\"AllowShortCaseLabelsOnASingleLine\",\n                   Style.AllowShortCaseLabelsOnASingleLine);\n    IO.mapOptional(\"AllowShortFunctionsOnASingleLine\",\n                   Style.AllowShortFunctionsOnASingleLine);\n    IO.mapOptional(\"AllowShortLambdasOnASingleLine\",\n                   Style.AllowShortLambdasOnASingleLine);\n    IO.mapOptional(\"AllowShortIfStatementsOnASingleLine\",\n                   Style.AllowShortIfStatementsOnASingleLine);\n    IO.mapOptional(\"AllowShortLoopsOnASingleLine\",\n                   Style.AllowShortLoopsOnASingleLine);\n    IO.mapOptional(\"AlwaysBreakAfterDefinitionReturnType\",\n                   Style.AlwaysBreakAfterDefinitionReturnType);\n    IO.mapOptional(\"AlwaysBreakAfterReturnType\",\n                   Style.AlwaysBreakAfterReturnType);\n\n    // If AlwaysBreakAfterDefinitionReturnType was specified but\n    // AlwaysBreakAfterReturnType was not, initialize the latter from the\n    // former for backwards compatibility.\n    if (Style.AlwaysBreakAfterDefinitionReturnType != FormatStyle::DRTBS_None &&\n        Style.AlwaysBreakAfterReturnType == FormatStyle::RTBS_None) {\n      if (Style.AlwaysBreakAfterDefinitionReturnType == FormatStyle::DRTBS_All)\n        Style.AlwaysBreakAfterReturnType = FormatStyle::RTBS_AllDefinitions;\n      else if (Style.AlwaysBreakAfterDefinitionReturnType ==\n               FormatStyle::DRTBS_TopLevel)\n        Style.AlwaysBreakAfterReturnType =\n            FormatStyle::RTBS_TopLevelDefinitions;\n    }\n\n    IO.mapOptional(\"AlwaysBreakBeforeMultilineStrings\",\n                   Style.AlwaysBreakBeforeMultilineStrings);\n    IO.mapOptional(\"AlwaysBreakTemplateDeclarations\",\n                   Style.AlwaysBreakTemplateDeclarations);\n    IO.mapOptional(\"AttributeMacros\", Style.AttributeMacros);\n    IO.mapOptional(\"BinPackArguments\", Style.BinPackArguments);\n    IO.mapOptional(\"BinPackParameters\", Style.BinPackParameters);\n    IO.mapOptional(\"BraceWrapping\", Style.BraceWrapping);\n    IO.mapOptional(\"BreakBeforeBinaryOperators\",\n                   Style.BreakBeforeBinaryOperators);\n    IO.mapOptional(\"BreakBeforeConceptDeclarations\",\n                   Style.BreakBeforeConceptDeclarations);\n    IO.mapOptional(\"BreakBeforeBraces\", Style.BreakBeforeBraces);\n\n    bool BreakBeforeInheritanceComma = false;\n    IO.mapOptional(\"BreakBeforeInheritanceComma\", BreakBeforeInheritanceComma);\n    IO.mapOptional(\"BreakInheritanceList\", Style.BreakInheritanceList);\n    // If BreakBeforeInheritanceComma was specified but\n    // BreakInheritance was not, initialize the latter from the\n    // former for backwards compatibility.\n    if (BreakBeforeInheritanceComma &&\n        Style.BreakInheritanceList == FormatStyle::BILS_BeforeColon)\n      Style.BreakInheritanceList = FormatStyle::BILS_BeforeComma;\n\n    IO.mapOptional(\"BreakBeforeTernaryOperators\",\n                   Style.BreakBeforeTernaryOperators);\n\n    bool BreakConstructorInitializersBeforeComma = false;\n    IO.mapOptional(\"BreakConstructorInitializersBeforeComma\",\n                   BreakConstructorInitializersBeforeComma);\n    IO.mapOptional(\"BreakConstructorInitializers\",\n                   Style.BreakConstructorInitializers);\n    // If BreakConstructorInitializersBeforeComma was specified but\n    // BreakConstructorInitializers was not, initialize the latter from the\n    // former for backwards compatibility.\n    if (BreakConstructorInitializersBeforeComma &&\n        Style.BreakConstructorInitializers == FormatStyle::BCIS_BeforeColon)\n      Style.BreakConstructorInitializers = FormatStyle::BCIS_BeforeComma;\n\n    IO.mapOptional(\"BreakAfterJavaFieldAnnotations\",\n                   Style.BreakAfterJavaFieldAnnotations);\n    IO.mapOptional(\"BreakStringLiterals\", Style.BreakStringLiterals);\n    IO.mapOptional(\"ColumnLimit\", Style.ColumnLimit);\n    IO.mapOptional(\"CommentPragmas\", Style.CommentPragmas);\n    IO.mapOptional(\"CompactNamespaces\", Style.CompactNamespaces);\n    IO.mapOptional(\"ConstructorInitializerAllOnOneLineOrOnePerLine\",\n                   Style.ConstructorInitializerAllOnOneLineOrOnePerLine);\n    IO.mapOptional(\"ConstructorInitializerIndentWidth\",\n                   Style.ConstructorInitializerIndentWidth);\n    IO.mapOptional(\"ContinuationIndentWidth\", Style.ContinuationIndentWidth);\n    IO.mapOptional(\"Cpp11BracedListStyle\", Style.Cpp11BracedListStyle);\n    IO.mapOptional(\"DeriveLineEnding\", Style.DeriveLineEnding);\n    IO.mapOptional(\"DerivePointerAlignment\", Style.DerivePointerAlignment);\n    IO.mapOptional(\"DisableFormat\", Style.DisableFormat);\n    IO.mapOptional(\"EmptyLineBeforeAccessModifier\",\n                   Style.EmptyLineBeforeAccessModifier);\n    IO.mapOptional(\"ExperimentalAutoDetectBinPacking\",\n                   Style.ExperimentalAutoDetectBinPacking);\n    IO.mapOptional(\"FixNamespaceComments\", Style.FixNamespaceComments);\n    IO.mapOptional(\"ForEachMacros\", Style.ForEachMacros);\n    IO.mapOptional(\"StatementAttributeLikeMacros\",\n                   Style.StatementAttributeLikeMacros);\n    IO.mapOptional(\"IncludeBlocks\", Style.IncludeStyle.IncludeBlocks);\n    IO.mapOptional(\"IncludeCategories\", Style.IncludeStyle.IncludeCategories);\n    IO.mapOptional(\"IncludeIsMainRegex\", Style.IncludeStyle.IncludeIsMainRegex);\n    IO.mapOptional(\"IncludeIsMainSourceRegex\",\n                   Style.IncludeStyle.IncludeIsMainSourceRegex);\n    IO.mapOptional(\"IndentAccessModifiers\", Style.IndentAccessModifiers);\n    IO.mapOptional(\"IndentCaseLabels\", Style.IndentCaseLabels);\n    IO.mapOptional(\"IndentCaseBlocks\", Style.IndentCaseBlocks);\n    IO.mapOptional(\"IndentGotoLabels\", Style.IndentGotoLabels);\n    IO.mapOptional(\"IndentPPDirectives\", Style.IndentPPDirectives);\n    IO.mapOptional(\"IndentExternBlock\", Style.IndentExternBlock);\n    IO.mapOptional(\"IndentRequires\", Style.IndentRequires);\n    IO.mapOptional(\"IndentWidth\", Style.IndentWidth);\n    IO.mapOptional(\"IndentWrappedFunctionNames\",\n                   Style.IndentWrappedFunctionNames);\n    IO.mapOptional(\"InsertTrailingCommas\", Style.InsertTrailingCommas);\n    IO.mapOptional(\"JavaImportGroups\", Style.JavaImportGroups);\n    IO.mapOptional(\"JavaScriptQuotes\", Style.JavaScriptQuotes);\n    IO.mapOptional(\"JavaScriptWrapImports\", Style.JavaScriptWrapImports);\n    IO.mapOptional(\"KeepEmptyLinesAtTheStartOfBlocks\",\n                   Style.KeepEmptyLinesAtTheStartOfBlocks);\n    IO.mapOptional(\"MacroBlockBegin\", Style.MacroBlockBegin);\n    IO.mapOptional(\"MacroBlockEnd\", Style.MacroBlockEnd);\n    IO.mapOptional(\"MaxEmptyLinesToKeep\", Style.MaxEmptyLinesToKeep);\n    IO.mapOptional(\"NamespaceIndentation\", Style.NamespaceIndentation);\n    IO.mapOptional(\"NamespaceMacros\", Style.NamespaceMacros);\n    IO.mapOptional(\"ObjCBinPackProtocolList\", Style.ObjCBinPackProtocolList);\n    IO.mapOptional(\"ObjCBlockIndentWidth\", Style.ObjCBlockIndentWidth);\n    IO.mapOptional(\"ObjCBreakBeforeNestedBlockParam\",\n                   Style.ObjCBreakBeforeNestedBlockParam);\n    IO.mapOptional(\"ObjCSpaceAfterProperty\", Style.ObjCSpaceAfterProperty);\n    IO.mapOptional(\"ObjCSpaceBeforeProtocolList\",\n                   Style.ObjCSpaceBeforeProtocolList);\n    IO.mapOptional(\"PenaltyBreakAssignment\", Style.PenaltyBreakAssignment);\n    IO.mapOptional(\"PenaltyBreakBeforeFirstCallParameter\",\n                   Style.PenaltyBreakBeforeFirstCallParameter);\n    IO.mapOptional(\"PenaltyBreakComment\", Style.PenaltyBreakComment);\n    IO.mapOptional(\"PenaltyBreakFirstLessLess\",\n                   Style.PenaltyBreakFirstLessLess);\n    IO.mapOptional(\"PenaltyBreakString\", Style.PenaltyBreakString);\n    IO.mapOptional(\"PenaltyBreakTemplateDeclaration\",\n                   Style.PenaltyBreakTemplateDeclaration);\n    IO.mapOptional(\"PenaltyExcessCharacter\", Style.PenaltyExcessCharacter);\n    IO.mapOptional(\"PenaltyReturnTypeOnItsOwnLine\",\n                   Style.PenaltyReturnTypeOnItsOwnLine);\n    IO.mapOptional(\"PenaltyIndentedWhitespace\",\n                   Style.PenaltyIndentedWhitespace);\n    IO.mapOptional(\"PointerAlignment\", Style.PointerAlignment);\n    IO.mapOptional(\"RawStringFormats\", Style.RawStringFormats);\n    IO.mapOptional(\"ReflowComments\", Style.ReflowComments);\n    IO.mapOptional(\"ShortNamespaceLines\", Style.ShortNamespaceLines);\n    IO.mapOptional(\"SortIncludes\", Style.SortIncludes);\n    IO.mapOptional(\"SortJavaStaticImport\", Style.SortJavaStaticImport);\n    IO.mapOptional(\"SortUsingDeclarations\", Style.SortUsingDeclarations);\n    IO.mapOptional(\"SpaceAfterCStyleCast\", Style.SpaceAfterCStyleCast);\n    IO.mapOptional(\"SpaceAfterLogicalNot\", Style.SpaceAfterLogicalNot);\n    IO.mapOptional(\"SpaceAfterTemplateKeyword\",\n                   Style.SpaceAfterTemplateKeyword);\n    IO.mapOptional(\"SpaceBeforeAssignmentOperators\",\n                   Style.SpaceBeforeAssignmentOperators);\n    IO.mapOptional(\"SpaceBeforeCaseColon\", Style.SpaceBeforeCaseColon);\n    IO.mapOptional(\"SpaceBeforeCpp11BracedList\",\n                   Style.SpaceBeforeCpp11BracedList);\n    IO.mapOptional(\"SpaceBeforeCtorInitializerColon\",\n                   Style.SpaceBeforeCtorInitializerColon);\n    IO.mapOptional(\"SpaceBeforeInheritanceColon\",\n                   Style.SpaceBeforeInheritanceColon);\n    IO.mapOptional(\"SpaceBeforeParens\", Style.SpaceBeforeParens);\n    IO.mapOptional(\"SpaceAroundPointerQualifiers\",\n                   Style.SpaceAroundPointerQualifiers);\n    IO.mapOptional(\"SpaceBeforeRangeBasedForLoopColon\",\n                   Style.SpaceBeforeRangeBasedForLoopColon);\n    IO.mapOptional(\"SpaceInEmptyBlock\", Style.SpaceInEmptyBlock);\n    IO.mapOptional(\"SpaceInEmptyParentheses\", Style.SpaceInEmptyParentheses);\n    IO.mapOptional(\"SpacesBeforeTrailingComments\",\n                   Style.SpacesBeforeTrailingComments);\n    IO.mapOptional(\"SpacesInAngles\", Style.SpacesInAngles);\n    IO.mapOptional(\"SpacesInConditionalStatement\",\n                   Style.SpacesInConditionalStatement);\n    IO.mapOptional(\"SpacesInContainerLiterals\",\n                   Style.SpacesInContainerLiterals);\n    IO.mapOptional(\"SpacesInCStyleCastParentheses\",\n                   Style.SpacesInCStyleCastParentheses);\n    IO.mapOptional(\"SpacesInLineCommentPrefix\",\n                   Style.SpacesInLineCommentPrefix);\n    IO.mapOptional(\"SpacesInParentheses\", Style.SpacesInParentheses);\n    IO.mapOptional(\"SpacesInSquareBrackets\", Style.SpacesInSquareBrackets);\n    IO.mapOptional(\"SpaceBeforeSquareBrackets\",\n                   Style.SpaceBeforeSquareBrackets);\n    IO.mapOptional(\"BitFieldColonSpacing\", Style.BitFieldColonSpacing);\n    IO.mapOptional(\"Standard\", Style.Standard);\n    IO.mapOptional(\"StatementMacros\", Style.StatementMacros);\n    IO.mapOptional(\"TabWidth\", Style.TabWidth);\n    IO.mapOptional(\"TypenameMacros\", Style.TypenameMacros);\n    IO.mapOptional(\"UseCRLF\", Style.UseCRLF);\n    IO.mapOptional(\"UseTab\", Style.UseTab);\n    IO.mapOptional(\"WhitespaceSensitiveMacros\",\n                   Style.WhitespaceSensitiveMacros);\n  }\n};\n\ntemplate <> struct MappingTraits<FormatStyle::BraceWrappingFlags> {\n  static void mapping(IO &IO, FormatStyle::BraceWrappingFlags &Wrapping) {\n    IO.mapOptional(\"AfterCaseLabel\", Wrapping.AfterCaseLabel);\n    IO.mapOptional(\"AfterClass\", Wrapping.AfterClass);\n    IO.mapOptional(\"AfterControlStatement\", Wrapping.AfterControlStatement);\n    IO.mapOptional(\"AfterEnum\", Wrapping.AfterEnum);\n    IO.mapOptional(\"AfterFunction\", Wrapping.AfterFunction);\n    IO.mapOptional(\"AfterNamespace\", Wrapping.AfterNamespace);\n    IO.mapOptional(\"AfterObjCDeclaration\", Wrapping.AfterObjCDeclaration);\n    IO.mapOptional(\"AfterStruct\", Wrapping.AfterStruct);\n    IO.mapOptional(\"AfterUnion\", Wrapping.AfterUnion);\n    IO.mapOptional(\"AfterExternBlock\", Wrapping.AfterExternBlock);\n    IO.mapOptional(\"BeforeCatch\", Wrapping.BeforeCatch);\n    IO.mapOptional(\"BeforeElse\", Wrapping.BeforeElse);\n    IO.mapOptional(\"BeforeLambdaBody\", Wrapping.BeforeLambdaBody);\n    IO.mapOptional(\"BeforeWhile\", Wrapping.BeforeWhile);\n    IO.mapOptional(\"IndentBraces\", Wrapping.IndentBraces);\n    IO.mapOptional(\"SplitEmptyFunction\", Wrapping.SplitEmptyFunction);\n    IO.mapOptional(\"SplitEmptyRecord\", Wrapping.SplitEmptyRecord);\n    IO.mapOptional(\"SplitEmptyNamespace\", Wrapping.SplitEmptyNamespace);\n  }\n};\n\ntemplate <> struct MappingTraits<FormatStyle::RawStringFormat> {\n  static void mapping(IO &IO, FormatStyle::RawStringFormat &Format) {\n    IO.mapOptional(\"Language\", Format.Language);\n    IO.mapOptional(\"Delimiters\", Format.Delimiters);\n    IO.mapOptional(\"EnclosingFunctions\", Format.EnclosingFunctions);\n    IO.mapOptional(\"CanonicalDelimiter\", Format.CanonicalDelimiter);\n    IO.mapOptional(\"BasedOnStyle\", Format.BasedOnStyle);\n  }\n};\n\ntemplate <> struct MappingTraits<FormatStyle::SpacesInLineComment> {\n  static void mapping(IO &IO, FormatStyle::SpacesInLineComment &Space) {\n    // Transform the maximum to signed, to parse \"-1\" correctly\n    int signedMaximum = static_cast<int>(Space.Maximum);\n    IO.mapOptional(\"Minimum\", Space.Minimum);\n    IO.mapOptional(\"Maximum\", signedMaximum);\n    Space.Maximum = static_cast<unsigned>(signedMaximum);\n\n    if (Space.Maximum != -1u) {\n      Space.Minimum = std::min(Space.Minimum, Space.Maximum);\n    }\n  }\n};\n\n// Allows to read vector<FormatStyle> while keeping default values.\n// IO.getContext() should contain a pointer to the FormatStyle structure, that\n// will be used to get default values for missing keys.\n// If the first element has no Language specified, it will be treated as the\n// default one for the following elements.\ntemplate <> struct DocumentListTraits<std::vector<FormatStyle>> {\n  static size_t size(IO &IO, std::vector<FormatStyle> &Seq) {\n    return Seq.size();\n  }\n  static FormatStyle &element(IO &IO, std::vector<FormatStyle> &Seq,\n                              size_t Index) {\n    if (Index >= Seq.size()) {\n      assert(Index == Seq.size());\n      FormatStyle Template;\n      if (!Seq.empty() && Seq[0].Language == FormatStyle::LK_None) {\n        Template = Seq[0];\n      } else {\n        Template = *((const FormatStyle *)IO.getContext());\n        Template.Language = FormatStyle::LK_None;\n      }\n      Seq.resize(Index + 1, Template);\n    }\n    return Seq[Index];\n  }\n};\n} // namespace yaml\n} // namespace llvm\n\nnamespace clang {\nnamespace format {\n\nconst std::error_category &getParseCategory() {\n  static const ParseErrorCategory C{};\n  return C;\n}\nstd::error_code make_error_code(ParseError e) {\n  return std::error_code(static_cast<int>(e), getParseCategory());\n}\n\ninline llvm::Error make_string_error(const llvm::Twine &Message) {\n  return llvm::make_error<llvm::StringError>(Message,\n                                             llvm::inconvertibleErrorCode());\n}\n\nconst char *ParseErrorCategory::name() const noexcept {\n  return \"clang-format.parse_error\";\n}\n\nstd::string ParseErrorCategory::message(int EV) const {\n  switch (static_cast<ParseError>(EV)) {\n  case ParseError::Success:\n    return \"Success\";\n  case ParseError::Error:\n    return \"Invalid argument\";\n  case ParseError::Unsuitable:\n    return \"Unsuitable\";\n  case ParseError::BinPackTrailingCommaConflict:\n    return \"trailing comma insertion cannot be used with bin packing\";\n  }\n  llvm_unreachable(\"unexpected parse error\");\n}\n\nstatic FormatStyle expandPresets(const FormatStyle &Style) {\n  if (Style.BreakBeforeBraces == FormatStyle::BS_Custom)\n    return Style;\n  FormatStyle Expanded = Style;\n  Expanded.BraceWrapping = {/*AfterCaseLabel=*/false,\n                            /*AfterClass=*/false,\n                            /*AfterControlStatement=*/FormatStyle::BWACS_Never,\n                            /*AfterEnum=*/false,\n                            /*AfterFunction=*/false,\n                            /*AfterNamespace=*/false,\n                            /*AfterObjCDeclaration=*/false,\n                            /*AfterStruct=*/false,\n                            /*AfterUnion=*/false,\n                            /*AfterExternBlock=*/false,\n                            /*BeforeCatch=*/false,\n                            /*BeforeElse=*/false,\n                            /*BeforeLambdaBody=*/false,\n                            /*BeforeWhile=*/false,\n                            /*IndentBraces=*/false,\n                            /*SplitEmptyFunction=*/true,\n                            /*SplitEmptyRecord=*/true,\n                            /*SplitEmptyNamespace=*/true};\n  switch (Style.BreakBeforeBraces) {\n  case FormatStyle::BS_Linux:\n    Expanded.BraceWrapping.AfterClass = true;\n    Expanded.BraceWrapping.AfterFunction = true;\n    Expanded.BraceWrapping.AfterNamespace = true;\n    break;\n  case FormatStyle::BS_Mozilla:\n    Expanded.BraceWrapping.AfterClass = true;\n    Expanded.BraceWrapping.AfterEnum = true;\n    Expanded.BraceWrapping.AfterFunction = true;\n    Expanded.BraceWrapping.AfterStruct = true;\n    Expanded.BraceWrapping.AfterUnion = true;\n    Expanded.BraceWrapping.AfterExternBlock = true;\n    Expanded.IndentExternBlock = FormatStyle::IEBS_AfterExternBlock;\n    Expanded.BraceWrapping.SplitEmptyFunction = true;\n    Expanded.BraceWrapping.SplitEmptyRecord = false;\n    break;\n  case FormatStyle::BS_Stroustrup:\n    Expanded.BraceWrapping.AfterFunction = true;\n    Expanded.BraceWrapping.BeforeCatch = true;\n    Expanded.BraceWrapping.BeforeElse = true;\n    break;\n  case FormatStyle::BS_Allman:\n    Expanded.BraceWrapping.AfterCaseLabel = true;\n    Expanded.BraceWrapping.AfterClass = true;\n    Expanded.BraceWrapping.AfterControlStatement = FormatStyle::BWACS_Always;\n    Expanded.BraceWrapping.AfterEnum = true;\n    Expanded.BraceWrapping.AfterFunction = true;\n    Expanded.BraceWrapping.AfterNamespace = true;\n    Expanded.BraceWrapping.AfterObjCDeclaration = true;\n    Expanded.BraceWrapping.AfterStruct = true;\n    Expanded.BraceWrapping.AfterUnion = true;\n    Expanded.BraceWrapping.AfterExternBlock = true;\n    Expanded.IndentExternBlock = FormatStyle::IEBS_AfterExternBlock;\n    Expanded.BraceWrapping.BeforeCatch = true;\n    Expanded.BraceWrapping.BeforeElse = true;\n    Expanded.BraceWrapping.BeforeLambdaBody = true;\n    break;\n  case FormatStyle::BS_Whitesmiths:\n    Expanded.BraceWrapping.AfterCaseLabel = true;\n    Expanded.BraceWrapping.AfterClass = true;\n    Expanded.BraceWrapping.AfterControlStatement = FormatStyle::BWACS_Always;\n    Expanded.BraceWrapping.AfterEnum = true;\n    Expanded.BraceWrapping.AfterFunction = true;\n    Expanded.BraceWrapping.AfterNamespace = true;\n    Expanded.BraceWrapping.AfterObjCDeclaration = true;\n    Expanded.BraceWrapping.AfterStruct = true;\n    Expanded.BraceWrapping.AfterExternBlock = true;\n    Expanded.IndentExternBlock = FormatStyle::IEBS_AfterExternBlock;\n    Expanded.BraceWrapping.BeforeCatch = true;\n    Expanded.BraceWrapping.BeforeElse = true;\n    Expanded.BraceWrapping.BeforeLambdaBody = true;\n    break;\n  case FormatStyle::BS_GNU:\n    Expanded.BraceWrapping = {\n        /*AfterCaseLabel=*/true,\n        /*AfterClass=*/true,\n        /*AfterControlStatement=*/FormatStyle::BWACS_Always,\n        /*AfterEnum=*/true,\n        /*AfterFunction=*/true,\n        /*AfterNamespace=*/true,\n        /*AfterObjCDeclaration=*/true,\n        /*AfterStruct=*/true,\n        /*AfterUnion=*/true,\n        /*AfterExternBlock=*/true,\n        /*BeforeCatch=*/true,\n        /*BeforeElse=*/true,\n        /*BeforeLambdaBody=*/false,\n        /*BeforeWhile=*/true,\n        /*IndentBraces=*/true,\n        /*SplitEmptyFunction=*/true,\n        /*SplitEmptyRecord=*/true,\n        /*SplitEmptyNamespace=*/true};\n    Expanded.IndentExternBlock = FormatStyle::IEBS_AfterExternBlock;\n    break;\n  case FormatStyle::BS_WebKit:\n    Expanded.BraceWrapping.AfterFunction = true;\n    break;\n  default:\n    break;\n  }\n  return Expanded;\n}\n\nFormatStyle getLLVMStyle(FormatStyle::LanguageKind Language) {\n  FormatStyle LLVMStyle;\n  LLVMStyle.InheritsParentConfig = false;\n  LLVMStyle.Language = Language;\n  LLVMStyle.AccessModifierOffset = -2;\n  LLVMStyle.AlignEscapedNewlines = FormatStyle::ENAS_Right;\n  LLVMStyle.AlignAfterOpenBracket = FormatStyle::BAS_Align;\n  LLVMStyle.AlignOperands = FormatStyle::OAS_Align;\n  LLVMStyle.AlignTrailingComments = true;\n  LLVMStyle.AlignConsecutiveAssignments = FormatStyle::ACS_None;\n  LLVMStyle.AlignConsecutiveBitFields = FormatStyle::ACS_None;\n  LLVMStyle.AlignConsecutiveDeclarations = FormatStyle::ACS_None;\n  LLVMStyle.AlignConsecutiveMacros = FormatStyle::ACS_None;\n  LLVMStyle.AllowAllArgumentsOnNextLine = true;\n  LLVMStyle.AllowAllConstructorInitializersOnNextLine = true;\n  LLVMStyle.AllowAllParametersOfDeclarationOnNextLine = true;\n  LLVMStyle.AllowShortEnumsOnASingleLine = true;\n  LLVMStyle.AllowShortFunctionsOnASingleLine = FormatStyle::SFS_All;\n  LLVMStyle.AllowShortBlocksOnASingleLine = FormatStyle::SBS_Never;\n  LLVMStyle.AllowShortCaseLabelsOnASingleLine = false;\n  LLVMStyle.AllowShortIfStatementsOnASingleLine = FormatStyle::SIS_Never;\n  LLVMStyle.AllowShortLambdasOnASingleLine = FormatStyle::SLS_All;\n  LLVMStyle.AllowShortLoopsOnASingleLine = false;\n  LLVMStyle.AlwaysBreakAfterReturnType = FormatStyle::RTBS_None;\n  LLVMStyle.AlwaysBreakAfterDefinitionReturnType = FormatStyle::DRTBS_None;\n  LLVMStyle.AlwaysBreakBeforeMultilineStrings = false;\n  LLVMStyle.AlwaysBreakTemplateDeclarations = FormatStyle::BTDS_MultiLine;\n  LLVMStyle.AttributeMacros.push_back(\"__capability\");\n  LLVMStyle.BinPackArguments = true;\n  LLVMStyle.BinPackParameters = true;\n  LLVMStyle.BreakBeforeBinaryOperators = FormatStyle::BOS_None;\n  LLVMStyle.BreakBeforeConceptDeclarations = true;\n  LLVMStyle.BreakBeforeTernaryOperators = true;\n  LLVMStyle.BreakBeforeBraces = FormatStyle::BS_Attach;\n  LLVMStyle.BraceWrapping = {/*AfterCaseLabel=*/false,\n                             /*AfterClass=*/false,\n                             /*AfterControlStatement=*/FormatStyle::BWACS_Never,\n                             /*AfterEnum=*/false,\n                             /*AfterFunction=*/false,\n                             /*AfterNamespace=*/false,\n                             /*AfterObjCDeclaration=*/false,\n                             /*AfterStruct=*/false,\n                             /*AfterUnion=*/false,\n                             /*AfterExternBlock=*/false,\n                             /*BeforeCatch=*/false,\n                             /*BeforeElse=*/false,\n                             /*BeforeLambdaBody=*/false,\n                             /*BeforeWhile=*/false,\n                             /*IndentBraces=*/false,\n                             /*SplitEmptyFunction=*/true,\n                             /*SplitEmptyRecord=*/true,\n                             /*SplitEmptyNamespace=*/true};\n  LLVMStyle.IndentExternBlock = FormatStyle::IEBS_AfterExternBlock;\n  LLVMStyle.BreakAfterJavaFieldAnnotations = false;\n  LLVMStyle.BreakConstructorInitializers = FormatStyle::BCIS_BeforeColon;\n  LLVMStyle.BreakInheritanceList = FormatStyle::BILS_BeforeColon;\n  LLVMStyle.BreakStringLiterals = true;\n  LLVMStyle.ColumnLimit = 80;\n  LLVMStyle.CommentPragmas = \"^ IWYU pragma:\";\n  LLVMStyle.CompactNamespaces = false;\n  LLVMStyle.ConstructorInitializerAllOnOneLineOrOnePerLine = false;\n  LLVMStyle.ConstructorInitializerIndentWidth = 4;\n  LLVMStyle.ContinuationIndentWidth = 4;\n  LLVMStyle.Cpp11BracedListStyle = true;\n  LLVMStyle.DeriveLineEnding = true;\n  LLVMStyle.DerivePointerAlignment = false;\n  LLVMStyle.EmptyLineBeforeAccessModifier = FormatStyle::ELBAMS_LogicalBlock;\n  LLVMStyle.ExperimentalAutoDetectBinPacking = false;\n  LLVMStyle.FixNamespaceComments = true;\n  LLVMStyle.ForEachMacros.push_back(\"foreach\");\n  LLVMStyle.ForEachMacros.push_back(\"Q_FOREACH\");\n  LLVMStyle.ForEachMacros.push_back(\"BOOST_FOREACH\");\n  LLVMStyle.IncludeStyle.IncludeCategories = {\n      {\"^\\\"(llvm|llvm-c|clang|clang-c)/\", 2, 0, false},\n      {\"^(<|\\\"(gtest|gmock|isl|json)/)\", 3, 0, false},\n      {\".*\", 1, 0, false}};\n  LLVMStyle.IncludeStyle.IncludeIsMainRegex = \"(Test)?$\";\n  LLVMStyle.IncludeStyle.IncludeBlocks = tooling::IncludeStyle::IBS_Preserve;\n  LLVMStyle.IndentAccessModifiers = false;\n  LLVMStyle.IndentCaseLabels = false;\n  LLVMStyle.IndentCaseBlocks = false;\n  LLVMStyle.IndentGotoLabels = true;\n  LLVMStyle.IndentPPDirectives = FormatStyle::PPDIS_None;\n  LLVMStyle.IndentRequires = false;\n  LLVMStyle.IndentWrappedFunctionNames = false;\n  LLVMStyle.IndentWidth = 2;\n  LLVMStyle.InsertTrailingCommas = FormatStyle::TCS_None;\n  LLVMStyle.JavaScriptQuotes = FormatStyle::JSQS_Leave;\n  LLVMStyle.JavaScriptWrapImports = true;\n  LLVMStyle.TabWidth = 8;\n  LLVMStyle.MaxEmptyLinesToKeep = 1;\n  LLVMStyle.KeepEmptyLinesAtTheStartOfBlocks = true;\n  LLVMStyle.NamespaceIndentation = FormatStyle::NI_None;\n  LLVMStyle.ObjCBinPackProtocolList = FormatStyle::BPS_Auto;\n  LLVMStyle.ObjCBlockIndentWidth = 2;\n  LLVMStyle.ObjCBreakBeforeNestedBlockParam = true;\n  LLVMStyle.ObjCSpaceAfterProperty = false;\n  LLVMStyle.ObjCSpaceBeforeProtocolList = true;\n  LLVMStyle.PointerAlignment = FormatStyle::PAS_Right;\n  LLVMStyle.ShortNamespaceLines = 1;\n  LLVMStyle.SpacesBeforeTrailingComments = 1;\n  LLVMStyle.Standard = FormatStyle::LS_Latest;\n  LLVMStyle.UseCRLF = false;\n  LLVMStyle.UseTab = FormatStyle::UT_Never;\n  LLVMStyle.ReflowComments = true;\n  LLVMStyle.SpacesInParentheses = false;\n  LLVMStyle.SpacesInSquareBrackets = false;\n  LLVMStyle.SpaceInEmptyBlock = false;\n  LLVMStyle.SpaceInEmptyParentheses = false;\n  LLVMStyle.SpacesInContainerLiterals = true;\n  LLVMStyle.SpacesInCStyleCastParentheses = false;\n  LLVMStyle.SpacesInLineCommentPrefix = {/*Minimum=*/1, /*Maximum=*/-1u};\n  LLVMStyle.SpaceAfterCStyleCast = false;\n  LLVMStyle.SpaceAfterLogicalNot = false;\n  LLVMStyle.SpaceAfterTemplateKeyword = true;\n  LLVMStyle.SpaceAroundPointerQualifiers = FormatStyle::SAPQ_Default;\n  LLVMStyle.SpaceBeforeCaseColon = false;\n  LLVMStyle.SpaceBeforeCtorInitializerColon = true;\n  LLVMStyle.SpaceBeforeInheritanceColon = true;\n  LLVMStyle.SpaceBeforeParens = FormatStyle::SBPO_ControlStatements;\n  LLVMStyle.SpaceBeforeRangeBasedForLoopColon = true;\n  LLVMStyle.SpaceBeforeAssignmentOperators = true;\n  LLVMStyle.SpaceBeforeCpp11BracedList = false;\n  LLVMStyle.SpaceBeforeSquareBrackets = false;\n  LLVMStyle.BitFieldColonSpacing = FormatStyle::BFCS_Both;\n  LLVMStyle.SpacesInAngles = false;\n  LLVMStyle.SpacesInConditionalStatement = false;\n\n  LLVMStyle.PenaltyBreakAssignment = prec::Assignment;\n  LLVMStyle.PenaltyBreakComment = 300;\n  LLVMStyle.PenaltyBreakFirstLessLess = 120;\n  LLVMStyle.PenaltyBreakString = 1000;\n  LLVMStyle.PenaltyExcessCharacter = 1000000;\n  LLVMStyle.PenaltyReturnTypeOnItsOwnLine = 60;\n  LLVMStyle.PenaltyBreakBeforeFirstCallParameter = 19;\n  LLVMStyle.PenaltyBreakTemplateDeclaration = prec::Relational;\n  LLVMStyle.PenaltyIndentedWhitespace = 0;\n\n  LLVMStyle.DisableFormat = false;\n  LLVMStyle.SortIncludes = FormatStyle::SI_CaseSensitive;\n  LLVMStyle.SortJavaStaticImport = FormatStyle::SJSIO_Before;\n  LLVMStyle.SortUsingDeclarations = true;\n  LLVMStyle.StatementAttributeLikeMacros.push_back(\"Q_EMIT\");\n  LLVMStyle.StatementMacros.push_back(\"Q_UNUSED\");\n  LLVMStyle.StatementMacros.push_back(\"QT_REQUIRE_VERSION\");\n  LLVMStyle.WhitespaceSensitiveMacros.push_back(\"STRINGIZE\");\n  LLVMStyle.WhitespaceSensitiveMacros.push_back(\"PP_STRINGIZE\");\n  LLVMStyle.WhitespaceSensitiveMacros.push_back(\"BOOST_PP_STRINGIZE\");\n  LLVMStyle.WhitespaceSensitiveMacros.push_back(\"NS_SWIFT_NAME\");\n  LLVMStyle.WhitespaceSensitiveMacros.push_back(\"CF_SWIFT_NAME\");\n\n  // Defaults that differ when not C++.\n  if (Language == FormatStyle::LK_TableGen) {\n    LLVMStyle.SpacesInContainerLiterals = false;\n  }\n\n  return LLVMStyle;\n}\n\nFormatStyle getGoogleStyle(FormatStyle::LanguageKind Language) {\n  if (Language == FormatStyle::LK_TextProto) {\n    FormatStyle GoogleStyle = getGoogleStyle(FormatStyle::LK_Proto);\n    GoogleStyle.Language = FormatStyle::LK_TextProto;\n\n    return GoogleStyle;\n  }\n\n  FormatStyle GoogleStyle = getLLVMStyle(Language);\n\n  GoogleStyle.AccessModifierOffset = -1;\n  GoogleStyle.AlignEscapedNewlines = FormatStyle::ENAS_Left;\n  GoogleStyle.AllowShortIfStatementsOnASingleLine =\n      FormatStyle::SIS_WithoutElse;\n  GoogleStyle.AllowShortLoopsOnASingleLine = true;\n  GoogleStyle.AlwaysBreakBeforeMultilineStrings = true;\n  GoogleStyle.AlwaysBreakTemplateDeclarations = FormatStyle::BTDS_Yes;\n  GoogleStyle.ConstructorInitializerAllOnOneLineOrOnePerLine = true;\n  GoogleStyle.DerivePointerAlignment = true;\n  GoogleStyle.IncludeStyle.IncludeCategories = {{\"^<ext/.*\\\\.h>\", 2, 0, false},\n                                                {\"^<.*\\\\.h>\", 1, 0, false},\n                                                {\"^<.*\", 2, 0, false},\n                                                {\".*\", 3, 0, false}};\n  GoogleStyle.IncludeStyle.IncludeIsMainRegex = \"([-_](test|unittest))?$\";\n  GoogleStyle.IncludeStyle.IncludeBlocks = tooling::IncludeStyle::IBS_Regroup;\n  GoogleStyle.IndentCaseLabels = true;\n  GoogleStyle.KeepEmptyLinesAtTheStartOfBlocks = false;\n  GoogleStyle.ObjCBinPackProtocolList = FormatStyle::BPS_Never;\n  GoogleStyle.ObjCSpaceAfterProperty = false;\n  GoogleStyle.ObjCSpaceBeforeProtocolList = true;\n  GoogleStyle.PointerAlignment = FormatStyle::PAS_Left;\n  GoogleStyle.RawStringFormats = {\n      {\n          FormatStyle::LK_Cpp,\n          /*Delimiters=*/\n          {\n              \"cc\",\n              \"CC\",\n              \"cpp\",\n              \"Cpp\",\n              \"CPP\",\n              \"c++\",\n              \"C++\",\n          },\n          /*EnclosingFunctionNames=*/\n          {},\n          /*CanonicalDelimiter=*/\"\",\n          /*BasedOnStyle=*/\"google\",\n      },\n      {\n          FormatStyle::LK_TextProto,\n          /*Delimiters=*/\n          {\n              \"pb\",\n              \"PB\",\n              \"proto\",\n              \"PROTO\",\n          },\n          /*EnclosingFunctionNames=*/\n          {\n              \"EqualsProto\",\n              \"EquivToProto\",\n              \"PARSE_PARTIAL_TEXT_PROTO\",\n              \"PARSE_TEST_PROTO\",\n              \"PARSE_TEXT_PROTO\",\n              \"ParseTextOrDie\",\n              \"ParseTextProtoOrDie\",\n              \"ParseTestProto\",\n              \"ParsePartialTestProto\",\n          },\n          /*CanonicalDelimiter=*/\"pb\",\n          /*BasedOnStyle=*/\"google\",\n      },\n  };\n  GoogleStyle.SpacesBeforeTrailingComments = 2;\n  GoogleStyle.Standard = FormatStyle::LS_Auto;\n\n  GoogleStyle.PenaltyReturnTypeOnItsOwnLine = 200;\n  GoogleStyle.PenaltyBreakBeforeFirstCallParameter = 1;\n\n  if (Language == FormatStyle::LK_Java) {\n    GoogleStyle.AlignAfterOpenBracket = FormatStyle::BAS_DontAlign;\n    GoogleStyle.AlignOperands = FormatStyle::OAS_DontAlign;\n    GoogleStyle.AlignTrailingComments = false;\n    GoogleStyle.AllowShortFunctionsOnASingleLine = FormatStyle::SFS_Empty;\n    GoogleStyle.AllowShortIfStatementsOnASingleLine = FormatStyle::SIS_Never;\n    GoogleStyle.AlwaysBreakBeforeMultilineStrings = false;\n    GoogleStyle.BreakBeforeBinaryOperators = FormatStyle::BOS_NonAssignment;\n    GoogleStyle.ColumnLimit = 100;\n    GoogleStyle.SpaceAfterCStyleCast = true;\n    GoogleStyle.SpacesBeforeTrailingComments = 1;\n  } else if (Language == FormatStyle::LK_JavaScript) {\n    GoogleStyle.AlignAfterOpenBracket = FormatStyle::BAS_AlwaysBreak;\n    GoogleStyle.AlignOperands = FormatStyle::OAS_DontAlign;\n    GoogleStyle.AllowShortFunctionsOnASingleLine = FormatStyle::SFS_Empty;\n    // TODO: still under discussion whether to switch to SLS_All.\n    GoogleStyle.AllowShortLambdasOnASingleLine = FormatStyle::SLS_Empty;\n    GoogleStyle.AlwaysBreakBeforeMultilineStrings = false;\n    GoogleStyle.BreakBeforeTernaryOperators = false;\n    // taze:, triple slash directives (`/// <...`), tslint:, and @see, which is\n    // commonly followed by overlong URLs.\n    GoogleStyle.CommentPragmas = \"(taze:|^/[ \\t]*<|tslint:|@see)\";\n    // TODO: enable once decided, in particular re disabling bin packing.\n    // https://google.github.io/styleguide/jsguide.html#features-arrays-trailing-comma\n    // GoogleStyle.InsertTrailingCommas = FormatStyle::TCS_Wrapped;\n    GoogleStyle.MaxEmptyLinesToKeep = 3;\n    GoogleStyle.NamespaceIndentation = FormatStyle::NI_All;\n    GoogleStyle.SpacesInContainerLiterals = false;\n    GoogleStyle.JavaScriptQuotes = FormatStyle::JSQS_Single;\n    GoogleStyle.JavaScriptWrapImports = false;\n  } else if (Language == FormatStyle::LK_Proto) {\n    GoogleStyle.AllowShortFunctionsOnASingleLine = FormatStyle::SFS_Empty;\n    GoogleStyle.AlwaysBreakBeforeMultilineStrings = false;\n    GoogleStyle.SpacesInContainerLiterals = false;\n    GoogleStyle.Cpp11BracedListStyle = false;\n    // This affects protocol buffer options specifications and text protos.\n    // Text protos are currently mostly formatted inside C++ raw string literals\n    // and often the current breaking behavior of string literals is not\n    // beneficial there. Investigate turning this on once proper string reflow\n    // has been implemented.\n    GoogleStyle.BreakStringLiterals = false;\n  } else if (Language == FormatStyle::LK_ObjC) {\n    GoogleStyle.AlwaysBreakBeforeMultilineStrings = false;\n    GoogleStyle.ColumnLimit = 100;\n    // \"Regroup\" doesn't work well for ObjC yet (main header heuristic,\n    // relationship between ObjC standard library headers and other heades,\n    // #imports, etc.)\n    GoogleStyle.IncludeStyle.IncludeBlocks =\n        tooling::IncludeStyle::IBS_Preserve;\n  } else if (Language == FormatStyle::LK_CSharp) {\n    GoogleStyle.AllowShortFunctionsOnASingleLine = FormatStyle::SFS_Empty;\n    GoogleStyle.AllowShortIfStatementsOnASingleLine = FormatStyle::SIS_Never;\n    GoogleStyle.BreakStringLiterals = false;\n    GoogleStyle.ColumnLimit = 100;\n    GoogleStyle.NamespaceIndentation = FormatStyle::NI_All;\n  }\n\n  return GoogleStyle;\n}\n\nFormatStyle getChromiumStyle(FormatStyle::LanguageKind Language) {\n  FormatStyle ChromiumStyle = getGoogleStyle(Language);\n\n  // Disable include reordering across blocks in Chromium code.\n  // - clang-format tries to detect that foo.h is the \"main\" header for\n  //   foo.cc and foo_unittest.cc via IncludeIsMainRegex. However, Chromium\n  //   uses many other suffices (_win.cc, _mac.mm, _posix.cc, _browsertest.cc,\n  //   _private.cc, _impl.cc etc) in different permutations\n  //   (_win_browsertest.cc) so disable this until IncludeIsMainRegex has a\n  //   better default for Chromium code.\n  // - The default for .cc and .mm files is different (r357695) for Google style\n  //   for the same reason. The plan is to unify this again once the main\n  //   header detection works for Google's ObjC code, but this hasn't happened\n  //   yet. Since Chromium has some ObjC code, switching Chromium is blocked\n  //   on that.\n  // - Finally, \"If include reordering is harmful, put things in different\n  //   blocks to prevent it\" has been a recommendation for a long time that\n  //   people are used to. We'll need a dev education push to change this to\n  //   \"If include reordering is harmful, put things in a different block and\n  //   _prepend that with a comment_ to prevent it\" before changing behavior.\n  ChromiumStyle.IncludeStyle.IncludeBlocks =\n      tooling::IncludeStyle::IBS_Preserve;\n\n  if (Language == FormatStyle::LK_Java) {\n    ChromiumStyle.AllowShortIfStatementsOnASingleLine =\n        FormatStyle::SIS_WithoutElse;\n    ChromiumStyle.BreakAfterJavaFieldAnnotations = true;\n    ChromiumStyle.ContinuationIndentWidth = 8;\n    ChromiumStyle.IndentWidth = 4;\n    // See styleguide for import groups:\n    // https://chromium.googlesource.com/chromium/src/+/master/styleguide/java/java.md#Import-Order\n    ChromiumStyle.JavaImportGroups = {\n        \"android\",\n        \"androidx\",\n        \"com\",\n        \"dalvik\",\n        \"junit\",\n        \"org\",\n        \"com.google.android.apps.chrome\",\n        \"org.chromium\",\n        \"java\",\n        \"javax\",\n    };\n    ChromiumStyle.SortIncludes = FormatStyle::SI_CaseSensitive;\n  } else if (Language == FormatStyle::LK_JavaScript) {\n    ChromiumStyle.AllowShortIfStatementsOnASingleLine = FormatStyle::SIS_Never;\n    ChromiumStyle.AllowShortLoopsOnASingleLine = false;\n  } else {\n    ChromiumStyle.AllowAllParametersOfDeclarationOnNextLine = false;\n    ChromiumStyle.AllowShortFunctionsOnASingleLine = FormatStyle::SFS_Inline;\n    ChromiumStyle.AllowShortIfStatementsOnASingleLine = FormatStyle::SIS_Never;\n    ChromiumStyle.AllowShortLoopsOnASingleLine = false;\n    ChromiumStyle.BinPackParameters = false;\n    ChromiumStyle.DerivePointerAlignment = false;\n    if (Language == FormatStyle::LK_ObjC)\n      ChromiumStyle.ColumnLimit = 80;\n  }\n  return ChromiumStyle;\n}\n\nFormatStyle getMozillaStyle() {\n  FormatStyle MozillaStyle = getLLVMStyle();\n  MozillaStyle.AllowAllParametersOfDeclarationOnNextLine = false;\n  MozillaStyle.AllowShortFunctionsOnASingleLine = FormatStyle::SFS_Inline;\n  MozillaStyle.AlwaysBreakAfterReturnType = FormatStyle::RTBS_TopLevel;\n  MozillaStyle.AlwaysBreakAfterDefinitionReturnType =\n      FormatStyle::DRTBS_TopLevel;\n  MozillaStyle.AlwaysBreakTemplateDeclarations = FormatStyle::BTDS_Yes;\n  MozillaStyle.BinPackParameters = false;\n  MozillaStyle.BinPackArguments = false;\n  MozillaStyle.BreakBeforeBraces = FormatStyle::BS_Mozilla;\n  MozillaStyle.BreakConstructorInitializers = FormatStyle::BCIS_BeforeComma;\n  MozillaStyle.BreakInheritanceList = FormatStyle::BILS_BeforeComma;\n  MozillaStyle.ConstructorInitializerIndentWidth = 2;\n  MozillaStyle.ContinuationIndentWidth = 2;\n  MozillaStyle.Cpp11BracedListStyle = false;\n  MozillaStyle.FixNamespaceComments = false;\n  MozillaStyle.IndentCaseLabels = true;\n  MozillaStyle.ObjCSpaceAfterProperty = true;\n  MozillaStyle.ObjCSpaceBeforeProtocolList = false;\n  MozillaStyle.PenaltyReturnTypeOnItsOwnLine = 200;\n  MozillaStyle.PointerAlignment = FormatStyle::PAS_Left;\n  MozillaStyle.SpaceAfterTemplateKeyword = false;\n  return MozillaStyle;\n}\n\nFormatStyle getWebKitStyle() {\n  FormatStyle Style = getLLVMStyle();\n  Style.AccessModifierOffset = -4;\n  Style.AlignAfterOpenBracket = FormatStyle::BAS_DontAlign;\n  Style.AlignOperands = FormatStyle::OAS_DontAlign;\n  Style.AlignTrailingComments = false;\n  Style.AllowShortBlocksOnASingleLine = FormatStyle::SBS_Empty;\n  Style.BreakBeforeBinaryOperators = FormatStyle::BOS_All;\n  Style.BreakBeforeBraces = FormatStyle::BS_WebKit;\n  Style.BreakConstructorInitializers = FormatStyle::BCIS_BeforeComma;\n  Style.Cpp11BracedListStyle = false;\n  Style.ColumnLimit = 0;\n  Style.FixNamespaceComments = false;\n  Style.IndentWidth = 4;\n  Style.NamespaceIndentation = FormatStyle::NI_Inner;\n  Style.ObjCBlockIndentWidth = 4;\n  Style.ObjCSpaceAfterProperty = true;\n  Style.PointerAlignment = FormatStyle::PAS_Left;\n  Style.SpaceBeforeCpp11BracedList = true;\n  Style.SpaceInEmptyBlock = true;\n  return Style;\n}\n\nFormatStyle getGNUStyle() {\n  FormatStyle Style = getLLVMStyle();\n  Style.AlwaysBreakAfterDefinitionReturnType = FormatStyle::DRTBS_All;\n  Style.AlwaysBreakAfterReturnType = FormatStyle::RTBS_AllDefinitions;\n  Style.BreakBeforeBinaryOperators = FormatStyle::BOS_All;\n  Style.BreakBeforeBraces = FormatStyle::BS_GNU;\n  Style.BreakBeforeTernaryOperators = true;\n  Style.Cpp11BracedListStyle = false;\n  Style.ColumnLimit = 79;\n  Style.FixNamespaceComments = false;\n  Style.SpaceBeforeParens = FormatStyle::SBPO_Always;\n  Style.Standard = FormatStyle::LS_Cpp03;\n  return Style;\n}\n\nFormatStyle getMicrosoftStyle(FormatStyle::LanguageKind Language) {\n  FormatStyle Style = getLLVMStyle(Language);\n  Style.ColumnLimit = 120;\n  Style.TabWidth = 4;\n  Style.IndentWidth = 4;\n  Style.UseTab = FormatStyle::UT_Never;\n  Style.BreakBeforeBraces = FormatStyle::BS_Custom;\n  Style.BraceWrapping.AfterClass = true;\n  Style.BraceWrapping.AfterControlStatement = FormatStyle::BWACS_Always;\n  Style.BraceWrapping.AfterEnum = true;\n  Style.BraceWrapping.AfterFunction = true;\n  Style.BraceWrapping.AfterNamespace = true;\n  Style.BraceWrapping.AfterObjCDeclaration = true;\n  Style.BraceWrapping.AfterStruct = true;\n  Style.BraceWrapping.AfterExternBlock = true;\n  Style.IndentExternBlock = FormatStyle::IEBS_AfterExternBlock;\n  Style.BraceWrapping.BeforeCatch = true;\n  Style.BraceWrapping.BeforeElse = true;\n  Style.BraceWrapping.BeforeWhile = false;\n  Style.PenaltyReturnTypeOnItsOwnLine = 1000;\n  Style.AllowShortEnumsOnASingleLine = false;\n  Style.AllowShortFunctionsOnASingleLine = FormatStyle::SFS_None;\n  Style.AllowShortCaseLabelsOnASingleLine = false;\n  Style.AllowShortIfStatementsOnASingleLine = FormatStyle::SIS_Never;\n  Style.AllowShortLoopsOnASingleLine = false;\n  Style.AlwaysBreakAfterDefinitionReturnType = FormatStyle::DRTBS_None;\n  Style.AlwaysBreakAfterReturnType = FormatStyle::RTBS_None;\n  return Style;\n}\n\nFormatStyle getNoStyle() {\n  FormatStyle NoStyle = getLLVMStyle();\n  NoStyle.DisableFormat = true;\n  NoStyle.SortIncludes = FormatStyle::SI_Never;\n  NoStyle.SortUsingDeclarations = false;\n  return NoStyle;\n}\n\nbool getPredefinedStyle(StringRef Name, FormatStyle::LanguageKind Language,\n                        FormatStyle *Style) {\n  if (Name.equals_lower(\"llvm\")) {\n    *Style = getLLVMStyle(Language);\n  } else if (Name.equals_lower(\"chromium\")) {\n    *Style = getChromiumStyle(Language);\n  } else if (Name.equals_lower(\"mozilla\")) {\n    *Style = getMozillaStyle();\n  } else if (Name.equals_lower(\"google\")) {\n    *Style = getGoogleStyle(Language);\n  } else if (Name.equals_lower(\"webkit\")) {\n    *Style = getWebKitStyle();\n  } else if (Name.equals_lower(\"gnu\")) {\n    *Style = getGNUStyle();\n  } else if (Name.equals_lower(\"microsoft\")) {\n    *Style = getMicrosoftStyle(Language);\n  } else if (Name.equals_lower(\"none\")) {\n    *Style = getNoStyle();\n  } else if (Name.equals_lower(\"inheritparentconfig\")) {\n    Style->InheritsParentConfig = true;\n  } else {\n    return false;\n  }\n\n  Style->Language = Language;\n  return true;\n}\n\nstd::error_code parseConfiguration(llvm::MemoryBufferRef Config,\n                                   FormatStyle *Style, bool AllowUnknownOptions,\n                                   llvm::SourceMgr::DiagHandlerTy DiagHandler,\n                                   void *DiagHandlerCtxt) {\n  assert(Style);\n  FormatStyle::LanguageKind Language = Style->Language;\n  assert(Language != FormatStyle::LK_None);\n  if (Config.getBuffer().trim().empty())\n    return make_error_code(ParseError::Error);\n  Style->StyleSet.Clear();\n  std::vector<FormatStyle> Styles;\n  llvm::yaml::Input Input(Config, /*Ctxt=*/nullptr, DiagHandler,\n                          DiagHandlerCtxt);\n  // DocumentListTraits<vector<FormatStyle>> uses the context to get default\n  // values for the fields, keys for which are missing from the configuration.\n  // Mapping also uses the context to get the language to find the correct\n  // base style.\n  Input.setContext(Style);\n  Input.setAllowUnknownKeys(AllowUnknownOptions);\n  Input >> Styles;\n  if (Input.error())\n    return Input.error();\n\n  for (unsigned i = 0; i < Styles.size(); ++i) {\n    // Ensures that only the first configuration can skip the Language option.\n    if (Styles[i].Language == FormatStyle::LK_None && i != 0)\n      return make_error_code(ParseError::Error);\n    // Ensure that each language is configured at most once.\n    for (unsigned j = 0; j < i; ++j) {\n      if (Styles[i].Language == Styles[j].Language) {\n        LLVM_DEBUG(llvm::dbgs()\n                   << \"Duplicate languages in the config file on positions \"\n                   << j << \" and \" << i << \"\\n\");\n        return make_error_code(ParseError::Error);\n      }\n    }\n  }\n  // Look for a suitable configuration starting from the end, so we can\n  // find the configuration for the specific language first, and the default\n  // configuration (which can only be at slot 0) after it.\n  FormatStyle::FormatStyleSet StyleSet;\n  bool LanguageFound = false;\n  for (int i = Styles.size() - 1; i >= 0; --i) {\n    if (Styles[i].Language != FormatStyle::LK_None)\n      StyleSet.Add(Styles[i]);\n    if (Styles[i].Language == Language)\n      LanguageFound = true;\n  }\n  if (!LanguageFound) {\n    if (Styles.empty() || Styles[0].Language != FormatStyle::LK_None)\n      return make_error_code(ParseError::Unsuitable);\n    FormatStyle DefaultStyle = Styles[0];\n    DefaultStyle.Language = Language;\n    StyleSet.Add(std::move(DefaultStyle));\n  }\n  *Style = *StyleSet.Get(Language);\n  if (Style->InsertTrailingCommas != FormatStyle::TCS_None &&\n      Style->BinPackArguments) {\n    // See comment on FormatStyle::TSC_Wrapped.\n    return make_error_code(ParseError::BinPackTrailingCommaConflict);\n  }\n  return make_error_code(ParseError::Success);\n}\n\nstd::string configurationAsText(const FormatStyle &Style) {\n  std::string Text;\n  llvm::raw_string_ostream Stream(Text);\n  llvm::yaml::Output Output(Stream);\n  // We use the same mapping method for input and output, so we need a non-const\n  // reference here.\n  FormatStyle NonConstStyle = expandPresets(Style);\n  Output << NonConstStyle;\n  return Stream.str();\n}\n\nllvm::Optional<FormatStyle>\nFormatStyle::FormatStyleSet::Get(FormatStyle::LanguageKind Language) const {\n  if (!Styles)\n    return None;\n  auto It = Styles->find(Language);\n  if (It == Styles->end())\n    return None;\n  FormatStyle Style = It->second;\n  Style.StyleSet = *this;\n  return Style;\n}\n\nvoid FormatStyle::FormatStyleSet::Add(FormatStyle Style) {\n  assert(Style.Language != LK_None &&\n         \"Cannot add a style for LK_None to a StyleSet\");\n  assert(\n      !Style.StyleSet.Styles &&\n      \"Cannot add a style associated with an existing StyleSet to a StyleSet\");\n  if (!Styles)\n    Styles = std::make_shared<MapType>();\n  (*Styles)[Style.Language] = std::move(Style);\n}\n\nvoid FormatStyle::FormatStyleSet::Clear() { Styles.reset(); }\n\nllvm::Optional<FormatStyle>\nFormatStyle::GetLanguageStyle(FormatStyle::LanguageKind Language) const {\n  return StyleSet.Get(Language);\n}\n\nnamespace {\n\nclass JavaScriptRequoter : public TokenAnalyzer {\npublic:\n  JavaScriptRequoter(const Environment &Env, const FormatStyle &Style)\n      : TokenAnalyzer(Env, Style) {}\n\n  std::pair<tooling::Replacements, unsigned>\n  analyze(TokenAnnotator &Annotator,\n          SmallVectorImpl<AnnotatedLine *> &AnnotatedLines,\n          FormatTokenLexer &Tokens) override {\n    AffectedRangeMgr.computeAffectedLines(AnnotatedLines);\n    tooling::Replacements Result;\n    requoteJSStringLiteral(AnnotatedLines, Result);\n    return {Result, 0};\n  }\n\nprivate:\n  // Replaces double/single-quoted string literal as appropriate, re-escaping\n  // the contents in the process.\n  void requoteJSStringLiteral(SmallVectorImpl<AnnotatedLine *> &Lines,\n                              tooling::Replacements &Result) {\n    for (AnnotatedLine *Line : Lines) {\n      requoteJSStringLiteral(Line->Children, Result);\n      if (!Line->Affected)\n        continue;\n      for (FormatToken *FormatTok = Line->First; FormatTok;\n           FormatTok = FormatTok->Next) {\n        StringRef Input = FormatTok->TokenText;\n        if (FormatTok->Finalized || !FormatTok->isStringLiteral() ||\n            // NB: testing for not starting with a double quote to avoid\n            // breaking `template strings`.\n            (Style.JavaScriptQuotes == FormatStyle::JSQS_Single &&\n             !Input.startswith(\"\\\"\")) ||\n            (Style.JavaScriptQuotes == FormatStyle::JSQS_Double &&\n             !Input.startswith(\"\\'\")))\n          continue;\n\n        // Change start and end quote.\n        bool IsSingle = Style.JavaScriptQuotes == FormatStyle::JSQS_Single;\n        SourceLocation Start = FormatTok->Tok.getLocation();\n        auto Replace = [&](SourceLocation Start, unsigned Length,\n                           StringRef ReplacementText) {\n          auto Err = Result.add(tooling::Replacement(\n              Env.getSourceManager(), Start, Length, ReplacementText));\n          // FIXME: handle error. For now, print error message and skip the\n          // replacement for release version.\n          if (Err) {\n            llvm::errs() << llvm::toString(std::move(Err)) << \"\\n\";\n            assert(false);\n          }\n        };\n        Replace(Start, 1, IsSingle ? \"'\" : \"\\\"\");\n        Replace(FormatTok->Tok.getEndLoc().getLocWithOffset(-1), 1,\n                IsSingle ? \"'\" : \"\\\"\");\n\n        // Escape internal quotes.\n        bool Escaped = false;\n        for (size_t i = 1; i < Input.size() - 1; i++) {\n          switch (Input[i]) {\n          case '\\\\':\n            if (!Escaped && i + 1 < Input.size() &&\n                ((IsSingle && Input[i + 1] == '\"') ||\n                 (!IsSingle && Input[i + 1] == '\\''))) {\n              // Remove this \\, it's escaping a \" or ' that no longer needs\n              // escaping\n              Replace(Start.getLocWithOffset(i), 1, \"\");\n              continue;\n            }\n            Escaped = !Escaped;\n            break;\n          case '\\\"':\n          case '\\'':\n            if (!Escaped && IsSingle == (Input[i] == '\\'')) {\n              // Escape the quote.\n              Replace(Start.getLocWithOffset(i), 0, \"\\\\\");\n            }\n            Escaped = false;\n            break;\n          default:\n            Escaped = false;\n            break;\n          }\n        }\n      }\n    }\n  }\n};\n\nclass Formatter : public TokenAnalyzer {\npublic:\n  Formatter(const Environment &Env, const FormatStyle &Style,\n            FormattingAttemptStatus *Status)\n      : TokenAnalyzer(Env, Style), Status(Status) {}\n\n  std::pair<tooling::Replacements, unsigned>\n  analyze(TokenAnnotator &Annotator,\n          SmallVectorImpl<AnnotatedLine *> &AnnotatedLines,\n          FormatTokenLexer &Tokens) override {\n    tooling::Replacements Result;\n    deriveLocalStyle(AnnotatedLines);\n    AffectedRangeMgr.computeAffectedLines(AnnotatedLines);\n    for (unsigned i = 0, e = AnnotatedLines.size(); i != e; ++i) {\n      Annotator.calculateFormattingInformation(*AnnotatedLines[i]);\n    }\n    Annotator.setCommentLineLevels(AnnotatedLines);\n\n    WhitespaceManager Whitespaces(\n        Env.getSourceManager(), Style,\n        Style.DeriveLineEnding\n            ? inputUsesCRLF(\n                  Env.getSourceManager().getBufferData(Env.getFileID()),\n                  Style.UseCRLF)\n            : Style.UseCRLF);\n    ContinuationIndenter Indenter(Style, Tokens.getKeywords(),\n                                  Env.getSourceManager(), Whitespaces, Encoding,\n                                  BinPackInconclusiveFunctions);\n    unsigned Penalty =\n        UnwrappedLineFormatter(&Indenter, &Whitespaces, Style,\n                               Tokens.getKeywords(), Env.getSourceManager(),\n                               Status)\n            .format(AnnotatedLines, /*DryRun=*/false,\n                    /*AdditionalIndent=*/0,\n                    /*FixBadIndentation=*/false,\n                    /*FirstStartColumn=*/Env.getFirstStartColumn(),\n                    /*NextStartColumn=*/Env.getNextStartColumn(),\n                    /*LastStartColumn=*/Env.getLastStartColumn());\n    for (const auto &R : Whitespaces.generateReplacements())\n      if (Result.add(R))\n        return std::make_pair(Result, 0);\n    return std::make_pair(Result, Penalty);\n  }\n\nprivate:\n  static bool inputUsesCRLF(StringRef Text, bool DefaultToCRLF) {\n    size_t LF = Text.count('\\n');\n    size_t CR = Text.count('\\r') * 2;\n    return LF == CR ? DefaultToCRLF : CR > LF;\n  }\n\n  bool\n  hasCpp03IncompatibleFormat(const SmallVectorImpl<AnnotatedLine *> &Lines) {\n    for (const AnnotatedLine *Line : Lines) {\n      if (hasCpp03IncompatibleFormat(Line->Children))\n        return true;\n      for (FormatToken *Tok = Line->First->Next; Tok; Tok = Tok->Next) {\n        if (Tok->WhitespaceRange.getBegin() == Tok->WhitespaceRange.getEnd()) {\n          if (Tok->is(tok::coloncolon) && Tok->Previous->is(TT_TemplateOpener))\n            return true;\n          if (Tok->is(TT_TemplateCloser) &&\n              Tok->Previous->is(TT_TemplateCloser))\n            return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  int countVariableAlignments(const SmallVectorImpl<AnnotatedLine *> &Lines) {\n    int AlignmentDiff = 0;\n    for (const AnnotatedLine *Line : Lines) {\n      AlignmentDiff += countVariableAlignments(Line->Children);\n      for (FormatToken *Tok = Line->First; Tok && Tok->Next; Tok = Tok->Next) {\n        if (!Tok->is(TT_PointerOrReference))\n          continue;\n        bool SpaceBefore =\n            Tok->WhitespaceRange.getBegin() != Tok->WhitespaceRange.getEnd();\n        bool SpaceAfter = Tok->Next->WhitespaceRange.getBegin() !=\n                          Tok->Next->WhitespaceRange.getEnd();\n        if (SpaceBefore && !SpaceAfter)\n          ++AlignmentDiff;\n        if (!SpaceBefore && SpaceAfter)\n          --AlignmentDiff;\n      }\n    }\n    return AlignmentDiff;\n  }\n\n  void\n  deriveLocalStyle(const SmallVectorImpl<AnnotatedLine *> &AnnotatedLines) {\n    bool HasBinPackedFunction = false;\n    bool HasOnePerLineFunction = false;\n    for (unsigned i = 0, e = AnnotatedLines.size(); i != e; ++i) {\n      if (!AnnotatedLines[i]->First->Next)\n        continue;\n      FormatToken *Tok = AnnotatedLines[i]->First->Next;\n      while (Tok->Next) {\n        if (Tok->is(PPK_BinPacked))\n          HasBinPackedFunction = true;\n        if (Tok->is(PPK_OnePerLine))\n          HasOnePerLineFunction = true;\n\n        Tok = Tok->Next;\n      }\n    }\n    if (Style.DerivePointerAlignment)\n      Style.PointerAlignment = countVariableAlignments(AnnotatedLines) <= 0\n                                   ? FormatStyle::PAS_Left\n                                   : FormatStyle::PAS_Right;\n    if (Style.Standard == FormatStyle::LS_Auto)\n      Style.Standard = hasCpp03IncompatibleFormat(AnnotatedLines)\n                           ? FormatStyle::LS_Latest\n                           : FormatStyle::LS_Cpp03;\n    BinPackInconclusiveFunctions =\n        HasBinPackedFunction || !HasOnePerLineFunction;\n  }\n\n  bool BinPackInconclusiveFunctions;\n  FormattingAttemptStatus *Status;\n};\n\n/// TrailingCommaInserter inserts trailing commas into container literals.\n/// E.g.:\n///     const x = [\n///       1,\n///     ];\n/// TrailingCommaInserter runs after formatting. To avoid causing a required\n/// reformatting (and thus reflow), it never inserts a comma that'd exceed the\n/// ColumnLimit.\n///\n/// Because trailing commas disable binpacking of arrays, TrailingCommaInserter\n/// is conceptually incompatible with bin packing.\nclass TrailingCommaInserter : public TokenAnalyzer {\npublic:\n  TrailingCommaInserter(const Environment &Env, const FormatStyle &Style)\n      : TokenAnalyzer(Env, Style) {}\n\n  std::pair<tooling::Replacements, unsigned>\n  analyze(TokenAnnotator &Annotator,\n          SmallVectorImpl<AnnotatedLine *> &AnnotatedLines,\n          FormatTokenLexer &Tokens) override {\n    AffectedRangeMgr.computeAffectedLines(AnnotatedLines);\n    tooling::Replacements Result;\n    insertTrailingCommas(AnnotatedLines, Result);\n    return {Result, 0};\n  }\n\nprivate:\n  /// Inserts trailing commas in [] and {} initializers if they wrap over\n  /// multiple lines.\n  void insertTrailingCommas(SmallVectorImpl<AnnotatedLine *> &Lines,\n                            tooling::Replacements &Result) {\n    for (AnnotatedLine *Line : Lines) {\n      insertTrailingCommas(Line->Children, Result);\n      if (!Line->Affected)\n        continue;\n      for (FormatToken *FormatTok = Line->First; FormatTok;\n           FormatTok = FormatTok->Next) {\n        if (FormatTok->NewlinesBefore == 0)\n          continue;\n        FormatToken *Matching = FormatTok->MatchingParen;\n        if (!Matching || !FormatTok->getPreviousNonComment())\n          continue;\n        if (!(FormatTok->is(tok::r_square) &&\n              Matching->is(TT_ArrayInitializerLSquare)) &&\n            !(FormatTok->is(tok::r_brace) && Matching->is(TT_DictLiteral)))\n          continue;\n        FormatToken *Prev = FormatTok->getPreviousNonComment();\n        if (Prev->is(tok::comma) || Prev->is(tok::semi))\n          continue;\n        // getEndLoc is not reliably set during re-lexing, use text length\n        // instead.\n        SourceLocation Start =\n            Prev->Tok.getLocation().getLocWithOffset(Prev->TokenText.size());\n        // If inserting a comma would push the code over the column limit, skip\n        // this location - it'd introduce an unstable formatting due to the\n        // required reflow.\n        unsigned ColumnNumber =\n            Env.getSourceManager().getSpellingColumnNumber(Start);\n        if (ColumnNumber > Style.ColumnLimit)\n          continue;\n        // Comma insertions cannot conflict with each other, and this pass has a\n        // clean set of Replacements, so the operation below cannot fail.\n        cantFail(Result.add(\n            tooling::Replacement(Env.getSourceManager(), Start, 0, \",\")));\n      }\n    }\n  }\n};\n\n// This class clean up the erroneous/redundant code around the given ranges in\n// file.\nclass Cleaner : public TokenAnalyzer {\npublic:\n  Cleaner(const Environment &Env, const FormatStyle &Style)\n      : TokenAnalyzer(Env, Style),\n        DeletedTokens(FormatTokenLess(Env.getSourceManager())) {}\n\n  // FIXME: eliminate unused parameters.\n  std::pair<tooling::Replacements, unsigned>\n  analyze(TokenAnnotator &Annotator,\n          SmallVectorImpl<AnnotatedLine *> &AnnotatedLines,\n          FormatTokenLexer &Tokens) override {\n    // FIXME: in the current implementation the granularity of affected range\n    // is an annotated line. However, this is not sufficient. Furthermore,\n    // redundant code introduced by replacements does not necessarily\n    // intercept with ranges of replacements that result in the redundancy.\n    // To determine if some redundant code is actually introduced by\n    // replacements(e.g. deletions), we need to come up with a more\n    // sophisticated way of computing affected ranges.\n    AffectedRangeMgr.computeAffectedLines(AnnotatedLines);\n\n    checkEmptyNamespace(AnnotatedLines);\n\n    for (auto *Line : AnnotatedLines)\n      cleanupLine(Line);\n\n    return {generateFixes(), 0};\n  }\n\nprivate:\n  void cleanupLine(AnnotatedLine *Line) {\n    for (auto *Child : Line->Children) {\n      cleanupLine(Child);\n    }\n\n    if (Line->Affected) {\n      cleanupRight(Line->First, tok::comma, tok::comma);\n      cleanupRight(Line->First, TT_CtorInitializerColon, tok::comma);\n      cleanupRight(Line->First, tok::l_paren, tok::comma);\n      cleanupLeft(Line->First, tok::comma, tok::r_paren);\n      cleanupLeft(Line->First, TT_CtorInitializerComma, tok::l_brace);\n      cleanupLeft(Line->First, TT_CtorInitializerColon, tok::l_brace);\n      cleanupLeft(Line->First, TT_CtorInitializerColon, tok::equal);\n    }\n  }\n\n  bool containsOnlyComments(const AnnotatedLine &Line) {\n    for (FormatToken *Tok = Line.First; Tok != nullptr; Tok = Tok->Next) {\n      if (Tok->isNot(tok::comment))\n        return false;\n    }\n    return true;\n  }\n\n  // Iterate through all lines and remove any empty (nested) namespaces.\n  void checkEmptyNamespace(SmallVectorImpl<AnnotatedLine *> &AnnotatedLines) {\n    std::set<unsigned> DeletedLines;\n    for (unsigned i = 0, e = AnnotatedLines.size(); i != e; ++i) {\n      auto &Line = *AnnotatedLines[i];\n      if (Line.startsWithNamespace()) {\n        checkEmptyNamespace(AnnotatedLines, i, i, DeletedLines);\n      }\n    }\n\n    for (auto Line : DeletedLines) {\n      FormatToken *Tok = AnnotatedLines[Line]->First;\n      while (Tok) {\n        deleteToken(Tok);\n        Tok = Tok->Next;\n      }\n    }\n  }\n\n  // The function checks if the namespace, which starts from \\p CurrentLine, and\n  // its nested namespaces are empty and delete them if they are empty. It also\n  // sets \\p NewLine to the last line checked.\n  // Returns true if the current namespace is empty.\n  bool checkEmptyNamespace(SmallVectorImpl<AnnotatedLine *> &AnnotatedLines,\n                           unsigned CurrentLine, unsigned &NewLine,\n                           std::set<unsigned> &DeletedLines) {\n    unsigned InitLine = CurrentLine, End = AnnotatedLines.size();\n    if (Style.BraceWrapping.AfterNamespace) {\n      // If the left brace is in a new line, we should consume it first so that\n      // it does not make the namespace non-empty.\n      // FIXME: error handling if there is no left brace.\n      if (!AnnotatedLines[++CurrentLine]->startsWith(tok::l_brace)) {\n        NewLine = CurrentLine;\n        return false;\n      }\n    } else if (!AnnotatedLines[CurrentLine]->endsWith(tok::l_brace)) {\n      return false;\n    }\n    while (++CurrentLine < End) {\n      if (AnnotatedLines[CurrentLine]->startsWith(tok::r_brace))\n        break;\n\n      if (AnnotatedLines[CurrentLine]->startsWithNamespace()) {\n        if (!checkEmptyNamespace(AnnotatedLines, CurrentLine, NewLine,\n                                 DeletedLines))\n          return false;\n        CurrentLine = NewLine;\n        continue;\n      }\n\n      if (containsOnlyComments(*AnnotatedLines[CurrentLine]))\n        continue;\n\n      // If there is anything other than comments or nested namespaces in the\n      // current namespace, the namespace cannot be empty.\n      NewLine = CurrentLine;\n      return false;\n    }\n\n    NewLine = CurrentLine;\n    if (CurrentLine >= End)\n      return false;\n\n    // Check if the empty namespace is actually affected by changed ranges.\n    if (!AffectedRangeMgr.affectsCharSourceRange(CharSourceRange::getCharRange(\n            AnnotatedLines[InitLine]->First->Tok.getLocation(),\n            AnnotatedLines[CurrentLine]->Last->Tok.getEndLoc())))\n      return false;\n\n    for (unsigned i = InitLine; i <= CurrentLine; ++i) {\n      DeletedLines.insert(i);\n    }\n\n    return true;\n  }\n\n  // Checks pairs {start, start->next},..., {end->previous, end} and deletes one\n  // of the token in the pair if the left token has \\p LK token kind and the\n  // right token has \\p RK token kind. If \\p DeleteLeft is true, the left token\n  // is deleted on match; otherwise, the right token is deleted.\n  template <typename LeftKind, typename RightKind>\n  void cleanupPair(FormatToken *Start, LeftKind LK, RightKind RK,\n                   bool DeleteLeft) {\n    auto NextNotDeleted = [this](const FormatToken &Tok) -> FormatToken * {\n      for (auto *Res = Tok.Next; Res; Res = Res->Next)\n        if (!Res->is(tok::comment) &&\n            DeletedTokens.find(Res) == DeletedTokens.end())\n          return Res;\n      return nullptr;\n    };\n    for (auto *Left = Start; Left;) {\n      auto *Right = NextNotDeleted(*Left);\n      if (!Right)\n        break;\n      if (Left->is(LK) && Right->is(RK)) {\n        deleteToken(DeleteLeft ? Left : Right);\n        for (auto *Tok = Left->Next; Tok && Tok != Right; Tok = Tok->Next)\n          deleteToken(Tok);\n        // If the right token is deleted, we should keep the left token\n        // unchanged and pair it with the new right token.\n        if (!DeleteLeft)\n          continue;\n      }\n      Left = Right;\n    }\n  }\n\n  template <typename LeftKind, typename RightKind>\n  void cleanupLeft(FormatToken *Start, LeftKind LK, RightKind RK) {\n    cleanupPair(Start, LK, RK, /*DeleteLeft=*/true);\n  }\n\n  template <typename LeftKind, typename RightKind>\n  void cleanupRight(FormatToken *Start, LeftKind LK, RightKind RK) {\n    cleanupPair(Start, LK, RK, /*DeleteLeft=*/false);\n  }\n\n  // Delete the given token.\n  inline void deleteToken(FormatToken *Tok) {\n    if (Tok)\n      DeletedTokens.insert(Tok);\n  }\n\n  tooling::Replacements generateFixes() {\n    tooling::Replacements Fixes;\n    std::vector<FormatToken *> Tokens;\n    std::copy(DeletedTokens.begin(), DeletedTokens.end(),\n              std::back_inserter(Tokens));\n\n    // Merge multiple continuous token deletions into one big deletion so that\n    // the number of replacements can be reduced. This makes computing affected\n    // ranges more efficient when we run reformat on the changed code.\n    unsigned Idx = 0;\n    while (Idx < Tokens.size()) {\n      unsigned St = Idx, End = Idx;\n      while ((End + 1) < Tokens.size() &&\n             Tokens[End]->Next == Tokens[End + 1]) {\n        End++;\n      }\n      auto SR = CharSourceRange::getCharRange(Tokens[St]->Tok.getLocation(),\n                                              Tokens[End]->Tok.getEndLoc());\n      auto Err =\n          Fixes.add(tooling::Replacement(Env.getSourceManager(), SR, \"\"));\n      // FIXME: better error handling. for now just print error message and skip\n      // for the release version.\n      if (Err) {\n        llvm::errs() << llvm::toString(std::move(Err)) << \"\\n\";\n        assert(false && \"Fixes must not conflict!\");\n      }\n      Idx = End + 1;\n    }\n\n    return Fixes;\n  }\n\n  // Class for less-than inequality comparason for the set `RedundantTokens`.\n  // We store tokens in the order they appear in the translation unit so that\n  // we do not need to sort them in `generateFixes()`.\n  struct FormatTokenLess {\n    FormatTokenLess(const SourceManager &SM) : SM(SM) {}\n\n    bool operator()(const FormatToken *LHS, const FormatToken *RHS) const {\n      return SM.isBeforeInTranslationUnit(LHS->Tok.getLocation(),\n                                          RHS->Tok.getLocation());\n    }\n    const SourceManager &SM;\n  };\n\n  // Tokens to be deleted.\n  std::set<FormatToken *, FormatTokenLess> DeletedTokens;\n};\n\nclass ObjCHeaderStyleGuesser : public TokenAnalyzer {\npublic:\n  ObjCHeaderStyleGuesser(const Environment &Env, const FormatStyle &Style)\n      : TokenAnalyzer(Env, Style), IsObjC(false) {}\n\n  std::pair<tooling::Replacements, unsigned>\n  analyze(TokenAnnotator &Annotator,\n          SmallVectorImpl<AnnotatedLine *> &AnnotatedLines,\n          FormatTokenLexer &Tokens) override {\n    assert(Style.Language == FormatStyle::LK_Cpp);\n    IsObjC = guessIsObjC(Env.getSourceManager(), AnnotatedLines,\n                         Tokens.getKeywords());\n    tooling::Replacements Result;\n    return {Result, 0};\n  }\n\n  bool isObjC() { return IsObjC; }\n\nprivate:\n  static bool\n  guessIsObjC(const SourceManager &SourceManager,\n              const SmallVectorImpl<AnnotatedLine *> &AnnotatedLines,\n              const AdditionalKeywords &Keywords) {\n    // Keep this array sorted, since we are binary searching over it.\n    static constexpr llvm::StringLiteral FoundationIdentifiers[] = {\n        \"CGFloat\",\n        \"CGPoint\",\n        \"CGPointMake\",\n        \"CGPointZero\",\n        \"CGRect\",\n        \"CGRectEdge\",\n        \"CGRectInfinite\",\n        \"CGRectMake\",\n        \"CGRectNull\",\n        \"CGRectZero\",\n        \"CGSize\",\n        \"CGSizeMake\",\n        \"CGVector\",\n        \"CGVectorMake\",\n        \"NSAffineTransform\",\n        \"NSArray\",\n        \"NSAttributedString\",\n        \"NSBlockOperation\",\n        \"NSBundle\",\n        \"NSCache\",\n        \"NSCalendar\",\n        \"NSCharacterSet\",\n        \"NSCountedSet\",\n        \"NSData\",\n        \"NSDataDetector\",\n        \"NSDecimal\",\n        \"NSDecimalNumber\",\n        \"NSDictionary\",\n        \"NSEdgeInsets\",\n        \"NSHashTable\",\n        \"NSIndexPath\",\n        \"NSIndexSet\",\n        \"NSInteger\",\n        \"NSInvocationOperation\",\n        \"NSLocale\",\n        \"NSMapTable\",\n        \"NSMutableArray\",\n        \"NSMutableAttributedString\",\n        \"NSMutableCharacterSet\",\n        \"NSMutableData\",\n        \"NSMutableDictionary\",\n        \"NSMutableIndexSet\",\n        \"NSMutableOrderedSet\",\n        \"NSMutableSet\",\n        \"NSMutableString\",\n        \"NSNumber\",\n        \"NSNumberFormatter\",\n        \"NSObject\",\n        \"NSOperation\",\n        \"NSOperationQueue\",\n        \"NSOperationQueuePriority\",\n        \"NSOrderedSet\",\n        \"NSPoint\",\n        \"NSPointerArray\",\n        \"NSQualityOfService\",\n        \"NSRange\",\n        \"NSRect\",\n        \"NSRegularExpression\",\n        \"NSSet\",\n        \"NSSize\",\n        \"NSString\",\n        \"NSTimeZone\",\n        \"NSUInteger\",\n        \"NSURL\",\n        \"NSURLComponents\",\n        \"NSURLQueryItem\",\n        \"NSUUID\",\n        \"NSValue\",\n        \"UIImage\",\n        \"UIView\",\n    };\n\n    for (auto Line : AnnotatedLines) {\n      if (Line->First && (Line->First->TokenText.startswith(\"#\") ||\n                          Line->First->TokenText == \"__pragma\" ||\n                          Line->First->TokenText == \"_Pragma\"))\n        continue;\n      for (const FormatToken *FormatTok = Line->First; FormatTok;\n           FormatTok = FormatTok->Next) {\n        if ((FormatTok->Previous && FormatTok->Previous->is(tok::at) &&\n             (FormatTok->Tok.getObjCKeywordID() != tok::objc_not_keyword ||\n              FormatTok->isOneOf(tok::numeric_constant, tok::l_square,\n                                 tok::l_brace))) ||\n            (FormatTok->Tok.isAnyIdentifier() &&\n             std::binary_search(std::begin(FoundationIdentifiers),\n                                std::end(FoundationIdentifiers),\n                                FormatTok->TokenText)) ||\n            FormatTok->is(TT_ObjCStringLiteral) ||\n            FormatTok->isOneOf(Keywords.kw_NS_CLOSED_ENUM, Keywords.kw_NS_ENUM,\n                               Keywords.kw_NS_OPTIONS, TT_ObjCBlockLBrace,\n                               TT_ObjCBlockLParen, TT_ObjCDecl, TT_ObjCForIn,\n                               TT_ObjCMethodExpr, TT_ObjCMethodSpecifier,\n                               TT_ObjCProperty)) {\n          LLVM_DEBUG(llvm::dbgs()\n                     << \"Detected ObjC at location \"\n                     << FormatTok->Tok.getLocation().printToString(\n                            SourceManager)\n                     << \" token: \" << FormatTok->TokenText << \" token type: \"\n                     << getTokenTypeName(FormatTok->getType()) << \"\\n\");\n          return true;\n        }\n        if (guessIsObjC(SourceManager, Line->Children, Keywords))\n          return true;\n      }\n    }\n    return false;\n  }\n\n  bool IsObjC;\n};\n\nstruct IncludeDirective {\n  StringRef Filename;\n  StringRef Text;\n  unsigned Offset;\n  int Category;\n  int Priority;\n};\n\nstruct JavaImportDirective {\n  StringRef Identifier;\n  StringRef Text;\n  unsigned Offset;\n  std::vector<StringRef> AssociatedCommentLines;\n  bool IsStatic;\n};\n\n} // end anonymous namespace\n\n// Determines whether 'Ranges' intersects with ('Start', 'End').\nstatic bool affectsRange(ArrayRef<tooling::Range> Ranges, unsigned Start,\n                         unsigned End) {\n  for (auto Range : Ranges) {\n    if (Range.getOffset() < End &&\n        Range.getOffset() + Range.getLength() > Start)\n      return true;\n  }\n  return false;\n}\n\n// Returns a pair (Index, OffsetToEOL) describing the position of the cursor\n// before sorting/deduplicating. Index is the index of the include under the\n// cursor in the original set of includes. If this include has duplicates, it is\n// the index of the first of the duplicates as the others are going to be\n// removed. OffsetToEOL describes the cursor's position relative to the end of\n// its current line.\n// If `Cursor` is not on any #include, `Index` will be UINT_MAX.\nstatic std::pair<unsigned, unsigned>\nFindCursorIndex(const SmallVectorImpl<IncludeDirective> &Includes,\n                const SmallVectorImpl<unsigned> &Indices, unsigned Cursor) {\n  unsigned CursorIndex = UINT_MAX;\n  unsigned OffsetToEOL = 0;\n  for (int i = 0, e = Includes.size(); i != e; ++i) {\n    unsigned Start = Includes[Indices[i]].Offset;\n    unsigned End = Start + Includes[Indices[i]].Text.size();\n    if (!(Cursor >= Start && Cursor < End))\n      continue;\n    CursorIndex = Indices[i];\n    OffsetToEOL = End - Cursor;\n    // Put the cursor on the only remaining #include among the duplicate\n    // #includes.\n    while (--i >= 0 && Includes[CursorIndex].Text == Includes[Indices[i]].Text)\n      CursorIndex = i;\n    break;\n  }\n  return std::make_pair(CursorIndex, OffsetToEOL);\n}\n\n// Replace all \"\\r\\n\" with \"\\n\".\nstd::string replaceCRLF(const std::string &Code) {\n  std::string NewCode;\n  size_t Pos = 0, LastPos = 0;\n\n  do {\n    Pos = Code.find(\"\\r\\n\", LastPos);\n    if (Pos == LastPos) {\n      LastPos++;\n      continue;\n    }\n    if (Pos == std::string::npos) {\n      NewCode += Code.substr(LastPos);\n      break;\n    }\n    NewCode += Code.substr(LastPos, Pos - LastPos) + \"\\n\";\n    LastPos = Pos + 2;\n  } while (Pos != std::string::npos);\n\n  return NewCode;\n}\n\n// Sorts and deduplicate a block of includes given by 'Includes' alphabetically\n// adding the necessary replacement to 'Replaces'. 'Includes' must be in strict\n// source order.\n// #include directives with the same text will be deduplicated, and only the\n// first #include in the duplicate #includes remains. If the `Cursor` is\n// provided and put on a deleted #include, it will be moved to the remaining\n// #include in the duplicate #includes.\nstatic void sortCppIncludes(const FormatStyle &Style,\n                            const SmallVectorImpl<IncludeDirective> &Includes,\n                            ArrayRef<tooling::Range> Ranges, StringRef FileName,\n                            StringRef Code, tooling::Replacements &Replaces,\n                            unsigned *Cursor) {\n  tooling::IncludeCategoryManager Categories(Style.IncludeStyle, FileName);\n  unsigned IncludesBeginOffset = Includes.front().Offset;\n  unsigned IncludesEndOffset =\n      Includes.back().Offset + Includes.back().Text.size();\n  unsigned IncludesBlockSize = IncludesEndOffset - IncludesBeginOffset;\n  if (!affectsRange(Ranges, IncludesBeginOffset, IncludesEndOffset))\n    return;\n  SmallVector<unsigned, 16> Indices;\n  for (unsigned i = 0, e = Includes.size(); i != e; ++i) {\n    Indices.push_back(i);\n  }\n\n  if (Style.SortIncludes == FormatStyle::SI_CaseInsensitive) {\n    llvm::stable_sort(Indices, [&](unsigned LHSI, unsigned RHSI) {\n      const auto LHSFilenameLower = Includes[LHSI].Filename.lower();\n      const auto RHSFilenameLower = Includes[RHSI].Filename.lower();\n      return std::tie(Includes[LHSI].Priority, LHSFilenameLower,\n                      Includes[LHSI].Filename) <\n             std::tie(Includes[RHSI].Priority, RHSFilenameLower,\n                      Includes[RHSI].Filename);\n    });\n  } else {\n    llvm::stable_sort(Indices, [&](unsigned LHSI, unsigned RHSI) {\n      return std::tie(Includes[LHSI].Priority, Includes[LHSI].Filename) <\n             std::tie(Includes[RHSI].Priority, Includes[RHSI].Filename);\n    });\n  }\n\n  // The index of the include on which the cursor will be put after\n  // sorting/deduplicating.\n  unsigned CursorIndex;\n  // The offset from cursor to the end of line.\n  unsigned CursorToEOLOffset;\n  if (Cursor)\n    std::tie(CursorIndex, CursorToEOLOffset) =\n        FindCursorIndex(Includes, Indices, *Cursor);\n\n  // Deduplicate #includes.\n  Indices.erase(std::unique(Indices.begin(), Indices.end(),\n                            [&](unsigned LHSI, unsigned RHSI) {\n                              return Includes[LHSI].Text.trim() ==\n                                     Includes[RHSI].Text.trim();\n                            }),\n                Indices.end());\n\n  int CurrentCategory = Includes.front().Category;\n\n  // If the #includes are out of order, we generate a single replacement fixing\n  // the entire block. Otherwise, no replacement is generated.\n  // In case Style.IncldueStyle.IncludeBlocks != IBS_Preserve, this check is not\n  // enough as additional newlines might be added or removed across #include\n  // blocks. This we handle below by generating the updated #imclude blocks and\n  // comparing it to the original.\n  if (Indices.size() == Includes.size() && llvm::is_sorted(Indices) &&\n      Style.IncludeStyle.IncludeBlocks == tooling::IncludeStyle::IBS_Preserve)\n    return;\n\n  std::string result;\n  for (unsigned Index : Indices) {\n    if (!result.empty()) {\n      result += \"\\n\";\n      if (Style.IncludeStyle.IncludeBlocks ==\n              tooling::IncludeStyle::IBS_Regroup &&\n          CurrentCategory != Includes[Index].Category)\n        result += \"\\n\";\n    }\n    result += Includes[Index].Text;\n    if (Cursor && CursorIndex == Index)\n      *Cursor = IncludesBeginOffset + result.size() - CursorToEOLOffset;\n    CurrentCategory = Includes[Index].Category;\n  }\n\n  // If the #includes are out of order, we generate a single replacement fixing\n  // the entire range of blocks. Otherwise, no replacement is generated.\n  if (replaceCRLF(result) == replaceCRLF(std::string(Code.substr(\n                                 IncludesBeginOffset, IncludesBlockSize))))\n    return;\n\n  auto Err = Replaces.add(tooling::Replacement(\n      FileName, Includes.front().Offset, IncludesBlockSize, result));\n  // FIXME: better error handling. For now, just skip the replacement for the\n  // release version.\n  if (Err) {\n    llvm::errs() << llvm::toString(std::move(Err)) << \"\\n\";\n    assert(false);\n  }\n}\n\nnamespace {\n\nconst char CppIncludeRegexPattern[] =\n    R\"(^[\\t\\ ]*#[\\t\\ ]*(import|include)[^\"<]*([\"<][^\">]*[\">]))\";\n\n} // anonymous namespace\n\ntooling::Replacements sortCppIncludes(const FormatStyle &Style, StringRef Code,\n                                      ArrayRef<tooling::Range> Ranges,\n                                      StringRef FileName,\n                                      tooling::Replacements &Replaces,\n                                      unsigned *Cursor) {\n  unsigned Prev = llvm::StringSwitch<size_t>(Code)\n                      .StartsWith(\"\\xEF\\xBB\\xBF\", 3) // UTF-8 BOM\n                      .Default(0);\n  unsigned SearchFrom = 0;\n  llvm::Regex IncludeRegex(CppIncludeRegexPattern);\n  SmallVector<StringRef, 4> Matches;\n  SmallVector<IncludeDirective, 16> IncludesInBlock;\n\n  // In compiled files, consider the first #include to be the main #include of\n  // the file if it is not a system #include. This ensures that the header\n  // doesn't have hidden dependencies\n  // (http://llvm.org/docs/CodingStandards.html#include-style).\n  //\n  // FIXME: Do some sanity checking, e.g. edit distance of the base name, to fix\n  // cases where the first #include is unlikely to be the main header.\n  tooling::IncludeCategoryManager Categories(Style.IncludeStyle, FileName);\n  bool FirstIncludeBlock = true;\n  bool MainIncludeFound = false;\n  bool FormattingOff = false;\n\n  for (;;) {\n    auto Pos = Code.find('\\n', SearchFrom);\n    StringRef Line =\n        Code.substr(Prev, (Pos != StringRef::npos ? Pos : Code.size()) - Prev);\n\n    StringRef Trimmed = Line.trim();\n    if (Trimmed == \"// clang-format off\" || Trimmed == \"/* clang-format off */\")\n      FormattingOff = true;\n    else if (Trimmed == \"// clang-format on\" ||\n             Trimmed == \"/* clang-format on */\")\n      FormattingOff = false;\n\n    const bool EmptyLineSkipped =\n        Trimmed.empty() &&\n        (Style.IncludeStyle.IncludeBlocks == tooling::IncludeStyle::IBS_Merge ||\n         Style.IncludeStyle.IncludeBlocks ==\n             tooling::IncludeStyle::IBS_Regroup);\n\n    bool MergeWithNextLine = Trimmed.endswith(\"\\\\\");\n    if (!FormattingOff && !MergeWithNextLine) {\n      if (IncludeRegex.match(Line, &Matches)) {\n        StringRef IncludeName = Matches[2];\n        int Category = Categories.getIncludePriority(\n            IncludeName,\n            /*CheckMainHeader=*/!MainIncludeFound && FirstIncludeBlock);\n        int Priority = Categories.getSortIncludePriority(\n            IncludeName, !MainIncludeFound && FirstIncludeBlock);\n        if (Category == 0)\n          MainIncludeFound = true;\n        IncludesInBlock.push_back(\n            {IncludeName, Line, Prev, Category, Priority});\n      } else if (!IncludesInBlock.empty() && !EmptyLineSkipped) {\n        sortCppIncludes(Style, IncludesInBlock, Ranges, FileName, Code,\n                        Replaces, Cursor);\n        IncludesInBlock.clear();\n        if (Trimmed.startswith(\"#pragma hdrstop\")) // Precompiled headers.\n          FirstIncludeBlock = true;\n        else\n          FirstIncludeBlock = false;\n      }\n    }\n    if (Pos == StringRef::npos || Pos + 1 == Code.size())\n      break;\n\n    if (!MergeWithNextLine)\n      Prev = Pos + 1;\n    SearchFrom = Pos + 1;\n  }\n  if (!IncludesInBlock.empty()) {\n    sortCppIncludes(Style, IncludesInBlock, Ranges, FileName, Code, Replaces,\n                    Cursor);\n  }\n  return Replaces;\n}\n\n// Returns group number to use as a first order sort on imports. Gives UINT_MAX\n// if the import does not match any given groups.\nstatic unsigned findJavaImportGroup(const FormatStyle &Style,\n                                    StringRef ImportIdentifier) {\n  unsigned LongestMatchIndex = UINT_MAX;\n  unsigned LongestMatchLength = 0;\n  for (unsigned I = 0; I < Style.JavaImportGroups.size(); I++) {\n    std::string GroupPrefix = Style.JavaImportGroups[I];\n    if (ImportIdentifier.startswith(GroupPrefix) &&\n        GroupPrefix.length() > LongestMatchLength) {\n      LongestMatchIndex = I;\n      LongestMatchLength = GroupPrefix.length();\n    }\n  }\n  return LongestMatchIndex;\n}\n\n// Sorts and deduplicates a block of includes given by 'Imports' based on\n// JavaImportGroups, then adding the necessary replacement to 'Replaces'.\n// Import declarations with the same text will be deduplicated. Between each\n// import group, a newline is inserted, and within each import group, a\n// lexicographic sort based on ASCII value is performed.\nstatic void sortJavaImports(const FormatStyle &Style,\n                            const SmallVectorImpl<JavaImportDirective> &Imports,\n                            ArrayRef<tooling::Range> Ranges, StringRef FileName,\n                            StringRef Code, tooling::Replacements &Replaces) {\n  unsigned ImportsBeginOffset = Imports.front().Offset;\n  unsigned ImportsEndOffset =\n      Imports.back().Offset + Imports.back().Text.size();\n  unsigned ImportsBlockSize = ImportsEndOffset - ImportsBeginOffset;\n  if (!affectsRange(Ranges, ImportsBeginOffset, ImportsEndOffset))\n    return;\n  SmallVector<unsigned, 16> Indices;\n  SmallVector<unsigned, 16> JavaImportGroups;\n  for (unsigned i = 0, e = Imports.size(); i != e; ++i) {\n    Indices.push_back(i);\n    JavaImportGroups.push_back(\n        findJavaImportGroup(Style, Imports[i].Identifier));\n  }\n  bool StaticImportAfterNormalImport =\n      Style.SortJavaStaticImport == FormatStyle::SJSIO_After;\n  llvm::sort(Indices, [&](unsigned LHSI, unsigned RHSI) {\n    // Negating IsStatic to push static imports above non-static imports.\n    return std::make_tuple(!Imports[LHSI].IsStatic ^\n                               StaticImportAfterNormalImport,\n                           JavaImportGroups[LHSI], Imports[LHSI].Identifier) <\n           std::make_tuple(!Imports[RHSI].IsStatic ^\n                               StaticImportAfterNormalImport,\n                           JavaImportGroups[RHSI], Imports[RHSI].Identifier);\n  });\n\n  // Deduplicate imports.\n  Indices.erase(std::unique(Indices.begin(), Indices.end(),\n                            [&](unsigned LHSI, unsigned RHSI) {\n                              return Imports[LHSI].Text == Imports[RHSI].Text;\n                            }),\n                Indices.end());\n\n  bool CurrentIsStatic = Imports[Indices.front()].IsStatic;\n  unsigned CurrentImportGroup = JavaImportGroups[Indices.front()];\n\n  std::string result;\n  for (unsigned Index : Indices) {\n    if (!result.empty()) {\n      result += \"\\n\";\n      if (CurrentIsStatic != Imports[Index].IsStatic ||\n          CurrentImportGroup != JavaImportGroups[Index])\n        result += \"\\n\";\n    }\n    for (StringRef CommentLine : Imports[Index].AssociatedCommentLines) {\n      result += CommentLine;\n      result += \"\\n\";\n    }\n    result += Imports[Index].Text;\n    CurrentIsStatic = Imports[Index].IsStatic;\n    CurrentImportGroup = JavaImportGroups[Index];\n  }\n\n  // If the imports are out of order, we generate a single replacement fixing\n  // the entire block. Otherwise, no replacement is generated.\n  if (replaceCRLF(result) == replaceCRLF(std::string(Code.substr(\n                                 Imports.front().Offset, ImportsBlockSize))))\n    return;\n\n  auto Err = Replaces.add(tooling::Replacement(FileName, Imports.front().Offset,\n                                               ImportsBlockSize, result));\n  // FIXME: better error handling. For now, just skip the replacement for the\n  // release version.\n  if (Err) {\n    llvm::errs() << llvm::toString(std::move(Err)) << \"\\n\";\n    assert(false);\n  }\n}\n\nnamespace {\n\nconst char JavaImportRegexPattern[] =\n    \"^[\\t ]*import[\\t ]+(static[\\t ]*)?([^\\t ]*)[\\t ]*;\";\n\n} // anonymous namespace\n\ntooling::Replacements sortJavaImports(const FormatStyle &Style, StringRef Code,\n                                      ArrayRef<tooling::Range> Ranges,\n                                      StringRef FileName,\n                                      tooling::Replacements &Replaces) {\n  unsigned Prev = 0;\n  unsigned SearchFrom = 0;\n  llvm::Regex ImportRegex(JavaImportRegexPattern);\n  SmallVector<StringRef, 4> Matches;\n  SmallVector<JavaImportDirective, 16> ImportsInBlock;\n  std::vector<StringRef> AssociatedCommentLines;\n\n  bool FormattingOff = false;\n\n  for (;;) {\n    auto Pos = Code.find('\\n', SearchFrom);\n    StringRef Line =\n        Code.substr(Prev, (Pos != StringRef::npos ? Pos : Code.size()) - Prev);\n\n    StringRef Trimmed = Line.trim();\n    if (Trimmed == \"// clang-format off\")\n      FormattingOff = true;\n    else if (Trimmed == \"// clang-format on\")\n      FormattingOff = false;\n\n    if (ImportRegex.match(Line, &Matches)) {\n      if (FormattingOff) {\n        // If at least one import line has formatting turned off, turn off\n        // formatting entirely.\n        return Replaces;\n      }\n      StringRef Static = Matches[1];\n      StringRef Identifier = Matches[2];\n      bool IsStatic = false;\n      if (Static.contains(\"static\")) {\n        IsStatic = true;\n      }\n      ImportsInBlock.push_back(\n          {Identifier, Line, Prev, AssociatedCommentLines, IsStatic});\n      AssociatedCommentLines.clear();\n    } else if (Trimmed.size() > 0 && !ImportsInBlock.empty()) {\n      // Associating comments within the imports with the nearest import below\n      AssociatedCommentLines.push_back(Line);\n    }\n    Prev = Pos + 1;\n    if (Pos == StringRef::npos || Pos + 1 == Code.size())\n      break;\n    SearchFrom = Pos + 1;\n  }\n  if (!ImportsInBlock.empty())\n    sortJavaImports(Style, ImportsInBlock, Ranges, FileName, Code, Replaces);\n  return Replaces;\n}\n\nbool isMpegTS(StringRef Code) {\n  // MPEG transport streams use the \".ts\" file extension. clang-format should\n  // not attempt to format those. MPEG TS' frame format starts with 0x47 every\n  // 189 bytes - detect that and return.\n  return Code.size() > 188 && Code[0] == 0x47 && Code[188] == 0x47;\n}\n\nbool isLikelyXml(StringRef Code) { return Code.ltrim().startswith(\"<\"); }\n\ntooling::Replacements sortIncludes(const FormatStyle &Style, StringRef Code,\n                                   ArrayRef<tooling::Range> Ranges,\n                                   StringRef FileName, unsigned *Cursor) {\n  tooling::Replacements Replaces;\n  if (!Style.SortIncludes)\n    return Replaces;\n  if (isLikelyXml(Code))\n    return Replaces;\n  if (Style.Language == FormatStyle::LanguageKind::LK_JavaScript &&\n      isMpegTS(Code))\n    return Replaces;\n  if (Style.Language == FormatStyle::LanguageKind::LK_JavaScript)\n    return sortJavaScriptImports(Style, Code, Ranges, FileName);\n  if (Style.Language == FormatStyle::LanguageKind::LK_Java)\n    return sortJavaImports(Style, Code, Ranges, FileName, Replaces);\n  sortCppIncludes(Style, Code, Ranges, FileName, Replaces, Cursor);\n  return Replaces;\n}\n\ntemplate <typename T>\nstatic llvm::Expected<tooling::Replacements>\nprocessReplacements(T ProcessFunc, StringRef Code,\n                    const tooling::Replacements &Replaces,\n                    const FormatStyle &Style) {\n  if (Replaces.empty())\n    return tooling::Replacements();\n\n  auto NewCode = applyAllReplacements(Code, Replaces);\n  if (!NewCode)\n    return NewCode.takeError();\n  std::vector<tooling::Range> ChangedRanges = Replaces.getAffectedRanges();\n  StringRef FileName = Replaces.begin()->getFilePath();\n\n  tooling::Replacements FormatReplaces =\n      ProcessFunc(Style, *NewCode, ChangedRanges, FileName);\n\n  return Replaces.merge(FormatReplaces);\n}\n\nllvm::Expected<tooling::Replacements>\nformatReplacements(StringRef Code, const tooling::Replacements &Replaces,\n                   const FormatStyle &Style) {\n  // We need to use lambda function here since there are two versions of\n  // `sortIncludes`.\n  auto SortIncludes = [](const FormatStyle &Style, StringRef Code,\n                         std::vector<tooling::Range> Ranges,\n                         StringRef FileName) -> tooling::Replacements {\n    return sortIncludes(Style, Code, Ranges, FileName);\n  };\n  auto SortedReplaces =\n      processReplacements(SortIncludes, Code, Replaces, Style);\n  if (!SortedReplaces)\n    return SortedReplaces.takeError();\n\n  // We need to use lambda function here since there are two versions of\n  // `reformat`.\n  auto Reformat = [](const FormatStyle &Style, StringRef Code,\n                     std::vector<tooling::Range> Ranges,\n                     StringRef FileName) -> tooling::Replacements {\n    return reformat(Style, Code, Ranges, FileName);\n  };\n  return processReplacements(Reformat, Code, *SortedReplaces, Style);\n}\n\nnamespace {\n\ninline bool isHeaderInsertion(const tooling::Replacement &Replace) {\n  return Replace.getOffset() == UINT_MAX && Replace.getLength() == 0 &&\n         llvm::Regex(CppIncludeRegexPattern)\n             .match(Replace.getReplacementText());\n}\n\ninline bool isHeaderDeletion(const tooling::Replacement &Replace) {\n  return Replace.getOffset() == UINT_MAX && Replace.getLength() == 1;\n}\n\n// FIXME: insert empty lines between newly created blocks.\ntooling::Replacements\nfixCppIncludeInsertions(StringRef Code, const tooling::Replacements &Replaces,\n                        const FormatStyle &Style) {\n  if (!Style.isCpp())\n    return Replaces;\n\n  tooling::Replacements HeaderInsertions;\n  std::set<llvm::StringRef> HeadersToDelete;\n  tooling::Replacements Result;\n  for (const auto &R : Replaces) {\n    if (isHeaderInsertion(R)) {\n      // Replacements from \\p Replaces must be conflict-free already, so we can\n      // simply consume the error.\n      llvm::consumeError(HeaderInsertions.add(R));\n    } else if (isHeaderDeletion(R)) {\n      HeadersToDelete.insert(R.getReplacementText());\n    } else if (R.getOffset() == UINT_MAX) {\n      llvm::errs() << \"Insertions other than header #include insertion are \"\n                      \"not supported! \"\n                   << R.getReplacementText() << \"\\n\";\n    } else {\n      llvm::consumeError(Result.add(R));\n    }\n  }\n  if (HeaderInsertions.empty() && HeadersToDelete.empty())\n    return Replaces;\n\n  StringRef FileName = Replaces.begin()->getFilePath();\n  tooling::HeaderIncludes Includes(FileName, Code, Style.IncludeStyle);\n\n  for (const auto &Header : HeadersToDelete) {\n    tooling::Replacements Replaces =\n        Includes.remove(Header.trim(\"\\\"<>\"), Header.startswith(\"<\"));\n    for (const auto &R : Replaces) {\n      auto Err = Result.add(R);\n      if (Err) {\n        // Ignore the deletion on conflict.\n        llvm::errs() << \"Failed to add header deletion replacement for \"\n                     << Header << \": \" << llvm::toString(std::move(Err))\n                     << \"\\n\";\n      }\n    }\n  }\n\n  llvm::Regex IncludeRegex = llvm::Regex(CppIncludeRegexPattern);\n  llvm::SmallVector<StringRef, 4> Matches;\n  for (const auto &R : HeaderInsertions) {\n    auto IncludeDirective = R.getReplacementText();\n    bool Matched = IncludeRegex.match(IncludeDirective, &Matches);\n    assert(Matched && \"Header insertion replacement must have replacement text \"\n                      \"'#include ...'\");\n    (void)Matched;\n    auto IncludeName = Matches[2];\n    auto Replace =\n        Includes.insert(IncludeName.trim(\"\\\"<>\"), IncludeName.startswith(\"<\"));\n    if (Replace) {\n      auto Err = Result.add(*Replace);\n      if (Err) {\n        llvm::consumeError(std::move(Err));\n        unsigned NewOffset =\n            Result.getShiftedCodePosition(Replace->getOffset());\n        auto Shifted = tooling::Replacement(FileName, NewOffset, 0,\n                                            Replace->getReplacementText());\n        Result = Result.merge(tooling::Replacements(Shifted));\n      }\n    }\n  }\n  return Result;\n}\n\n} // anonymous namespace\n\nllvm::Expected<tooling::Replacements>\ncleanupAroundReplacements(StringRef Code, const tooling::Replacements &Replaces,\n                          const FormatStyle &Style) {\n  // We need to use lambda function here since there are two versions of\n  // `cleanup`.\n  auto Cleanup = [](const FormatStyle &Style, StringRef Code,\n                    std::vector<tooling::Range> Ranges,\n                    StringRef FileName) -> tooling::Replacements {\n    return cleanup(Style, Code, Ranges, FileName);\n  };\n  // Make header insertion replacements insert new headers into correct blocks.\n  tooling::Replacements NewReplaces =\n      fixCppIncludeInsertions(Code, Replaces, Style);\n  return processReplacements(Cleanup, Code, NewReplaces, Style);\n}\n\nnamespace internal {\nstd::pair<tooling::Replacements, unsigned>\nreformat(const FormatStyle &Style, StringRef Code,\n         ArrayRef<tooling::Range> Ranges, unsigned FirstStartColumn,\n         unsigned NextStartColumn, unsigned LastStartColumn, StringRef FileName,\n         FormattingAttemptStatus *Status) {\n  FormatStyle Expanded = expandPresets(Style);\n  if (Expanded.DisableFormat)\n    return {tooling::Replacements(), 0};\n  if (isLikelyXml(Code))\n    return {tooling::Replacements(), 0};\n  if (Expanded.Language == FormatStyle::LK_JavaScript && isMpegTS(Code))\n    return {tooling::Replacements(), 0};\n\n  typedef std::function<std::pair<tooling::Replacements, unsigned>(\n      const Environment &)>\n      AnalyzerPass;\n  SmallVector<AnalyzerPass, 4> Passes;\n\n  if (Style.Language == FormatStyle::LK_Cpp) {\n    if (Style.FixNamespaceComments)\n      Passes.emplace_back([&](const Environment &Env) {\n        return NamespaceEndCommentsFixer(Env, Expanded).process();\n      });\n\n    if (Style.SortUsingDeclarations)\n      Passes.emplace_back([&](const Environment &Env) {\n        return UsingDeclarationsSorter(Env, Expanded).process();\n      });\n  }\n\n  if (Style.Language == FormatStyle::LK_JavaScript &&\n      Style.JavaScriptQuotes != FormatStyle::JSQS_Leave)\n    Passes.emplace_back([&](const Environment &Env) {\n      return JavaScriptRequoter(Env, Expanded).process();\n    });\n\n  Passes.emplace_back([&](const Environment &Env) {\n    return Formatter(Env, Expanded, Status).process();\n  });\n\n  if (Style.Language == FormatStyle::LK_JavaScript &&\n      Style.InsertTrailingCommas == FormatStyle::TCS_Wrapped)\n    Passes.emplace_back([&](const Environment &Env) {\n      return TrailingCommaInserter(Env, Expanded).process();\n    });\n\n  auto Env =\n      std::make_unique<Environment>(Code, FileName, Ranges, FirstStartColumn,\n                                    NextStartColumn, LastStartColumn);\n  llvm::Optional<std::string> CurrentCode = None;\n  tooling::Replacements Fixes;\n  unsigned Penalty = 0;\n  for (size_t I = 0, E = Passes.size(); I < E; ++I) {\n    std::pair<tooling::Replacements, unsigned> PassFixes = Passes[I](*Env);\n    auto NewCode = applyAllReplacements(\n        CurrentCode ? StringRef(*CurrentCode) : Code, PassFixes.first);\n    if (NewCode) {\n      Fixes = Fixes.merge(PassFixes.first);\n      Penalty += PassFixes.second;\n      if (I + 1 < E) {\n        CurrentCode = std::move(*NewCode);\n        Env = std::make_unique<Environment>(\n            *CurrentCode, FileName,\n            tooling::calculateRangesAfterReplacements(Fixes, Ranges),\n            FirstStartColumn, NextStartColumn, LastStartColumn);\n      }\n    }\n  }\n\n  return {Fixes, Penalty};\n}\n} // namespace internal\n\ntooling::Replacements reformat(const FormatStyle &Style, StringRef Code,\n                               ArrayRef<tooling::Range> Ranges,\n                               StringRef FileName,\n                               FormattingAttemptStatus *Status) {\n  return internal::reformat(Style, Code, Ranges,\n                            /*FirstStartColumn=*/0,\n                            /*NextStartColumn=*/0,\n                            /*LastStartColumn=*/0, FileName, Status)\n      .first;\n}\n\ntooling::Replacements cleanup(const FormatStyle &Style, StringRef Code,\n                              ArrayRef<tooling::Range> Ranges,\n                              StringRef FileName) {\n  // cleanups only apply to C++ (they mostly concern ctor commas etc.)\n  if (Style.Language != FormatStyle::LK_Cpp)\n    return tooling::Replacements();\n  return Cleaner(Environment(Code, FileName, Ranges), Style).process().first;\n}\n\ntooling::Replacements reformat(const FormatStyle &Style, StringRef Code,\n                               ArrayRef<tooling::Range> Ranges,\n                               StringRef FileName, bool *IncompleteFormat) {\n  FormattingAttemptStatus Status;\n  auto Result = reformat(Style, Code, Ranges, FileName, &Status);\n  if (!Status.FormatComplete)\n    *IncompleteFormat = true;\n  return Result;\n}\n\ntooling::Replacements fixNamespaceEndComments(const FormatStyle &Style,\n                                              StringRef Code,\n                                              ArrayRef<tooling::Range> Ranges,\n                                              StringRef FileName) {\n  return NamespaceEndCommentsFixer(Environment(Code, FileName, Ranges), Style)\n      .process()\n      .first;\n}\n\ntooling::Replacements sortUsingDeclarations(const FormatStyle &Style,\n                                            StringRef Code,\n                                            ArrayRef<tooling::Range> Ranges,\n                                            StringRef FileName) {\n  return UsingDeclarationsSorter(Environment(Code, FileName, Ranges), Style)\n      .process()\n      .first;\n}\n\nLangOptions getFormattingLangOpts(const FormatStyle &Style) {\n  LangOptions LangOpts;\n\n  FormatStyle::LanguageStandard LexingStd = Style.Standard;\n  if (LexingStd == FormatStyle::LS_Auto)\n    LexingStd = FormatStyle::LS_Latest;\n  if (LexingStd == FormatStyle::LS_Latest)\n    LexingStd = FormatStyle::LS_Cpp20;\n  LangOpts.CPlusPlus = 1;\n  LangOpts.CPlusPlus11 = LexingStd >= FormatStyle::LS_Cpp11;\n  LangOpts.CPlusPlus14 = LexingStd >= FormatStyle::LS_Cpp14;\n  LangOpts.CPlusPlus17 = LexingStd >= FormatStyle::LS_Cpp17;\n  LangOpts.CPlusPlus20 = LexingStd >= FormatStyle::LS_Cpp20;\n  LangOpts.Char8 = LexingStd >= FormatStyle::LS_Cpp20;\n\n  LangOpts.LineComment = 1;\n  bool AlternativeOperators = Style.isCpp();\n  LangOpts.CXXOperatorNames = AlternativeOperators ? 1 : 0;\n  LangOpts.Bool = 1;\n  LangOpts.ObjC = 1;\n  LangOpts.MicrosoftExt = 1;    // To get kw___try, kw___finally.\n  LangOpts.DeclSpecKeyword = 1; // To get __declspec.\n  LangOpts.C99 = 1; // To get kw_restrict for non-underscore-prefixed restrict.\n  return LangOpts;\n}\n\nconst char *StyleOptionHelpDescription =\n    \"Coding style, currently supports:\\n\"\n    \"  LLVM, GNU, Google, Chromium, Microsoft, Mozilla, WebKit.\\n\"\n    \"Use -style=file to load style configuration from\\n\"\n    \".clang-format file located in one of the parent\\n\"\n    \"directories of the source file (or current\\n\"\n    \"directory for stdin).\\n\"\n    \"Use -style=\\\"{key: value, ...}\\\" to set specific\\n\"\n    \"parameters, e.g.:\\n\"\n    \"  -style=\\\"{BasedOnStyle: llvm, IndentWidth: 8}\\\"\";\n\nstatic FormatStyle::LanguageKind getLanguageByFileName(StringRef FileName) {\n  if (FileName.endswith(\".java\"))\n    return FormatStyle::LK_Java;\n  if (FileName.endswith_lower(\".js\") || FileName.endswith_lower(\".mjs\") ||\n      FileName.endswith_lower(\".ts\"))\n    return FormatStyle::LK_JavaScript; // (module) JavaScript or TypeScript.\n  if (FileName.endswith(\".m\") || FileName.endswith(\".mm\"))\n    return FormatStyle::LK_ObjC;\n  if (FileName.endswith_lower(\".proto\") ||\n      FileName.endswith_lower(\".protodevel\"))\n    return FormatStyle::LK_Proto;\n  if (FileName.endswith_lower(\".textpb\") ||\n      FileName.endswith_lower(\".pb.txt\") ||\n      FileName.endswith_lower(\".textproto\") ||\n      FileName.endswith_lower(\".asciipb\"))\n    return FormatStyle::LK_TextProto;\n  if (FileName.endswith_lower(\".td\"))\n    return FormatStyle::LK_TableGen;\n  if (FileName.endswith_lower(\".cs\"))\n    return FormatStyle::LK_CSharp;\n  return FormatStyle::LK_Cpp;\n}\n\nFormatStyle::LanguageKind guessLanguage(StringRef FileName, StringRef Code) {\n  const auto GuessedLanguage = getLanguageByFileName(FileName);\n  if (GuessedLanguage == FormatStyle::LK_Cpp) {\n    auto Extension = llvm::sys::path::extension(FileName);\n    // If there's no file extension (or it's .h), we need to check the contents\n    // of the code to see if it contains Objective-C.\n    if (Extension.empty() || Extension == \".h\") {\n      auto NonEmptyFileName = FileName.empty() ? \"guess.h\" : FileName;\n      Environment Env(Code, NonEmptyFileName, /*Ranges=*/{});\n      ObjCHeaderStyleGuesser Guesser(Env, getLLVMStyle());\n      Guesser.process();\n      if (Guesser.isObjC())\n        return FormatStyle::LK_ObjC;\n    }\n  }\n  return GuessedLanguage;\n}\n\nconst char *DefaultFormatStyle = \"file\";\n\nconst char *DefaultFallbackStyle = \"LLVM\";\n\nllvm::Expected<FormatStyle> getStyle(StringRef StyleName, StringRef FileName,\n                                     StringRef FallbackStyleName,\n                                     StringRef Code, llvm::vfs::FileSystem *FS,\n                                     bool AllowUnknownOptions) {\n  if (!FS) {\n    FS = llvm::vfs::getRealFileSystem().get();\n  }\n  FormatStyle Style = getLLVMStyle(guessLanguage(FileName, Code));\n\n  FormatStyle FallbackStyle = getNoStyle();\n  if (!getPredefinedStyle(FallbackStyleName, Style.Language, &FallbackStyle))\n    return make_string_error(\"Invalid fallback style \\\"\" + FallbackStyleName);\n\n  llvm::SmallVector<std::unique_ptr<llvm::MemoryBuffer>, 1>\n      ChildFormatTextToApply;\n\n  if (StyleName.startswith(\"{\")) {\n    // Parse YAML/JSON style from the command line.\n    StringRef Source = \"<command-line>\";\n    if (std::error_code ec =\n            parseConfiguration(llvm::MemoryBufferRef(StyleName, Source), &Style,\n                               AllowUnknownOptions))\n      return make_string_error(\"Error parsing -style: \" + ec.message());\n    if (Style.InheritsParentConfig)\n      ChildFormatTextToApply.emplace_back(\n          llvm::MemoryBuffer::getMemBuffer(StyleName, Source, false));\n    else\n      return Style;\n  }\n\n  // If the style inherits the parent configuration it is a command line\n  // configuration, which wants to inherit, so we have to skip the check of the\n  // StyleName.\n  if (!Style.InheritsParentConfig && !StyleName.equals_lower(\"file\")) {\n    if (!getPredefinedStyle(StyleName, Style.Language, &Style))\n      return make_string_error(\"Invalid value for -style\");\n    if (!Style.InheritsParentConfig)\n      return Style;\n  }\n\n  // Reset possible inheritance\n  Style.InheritsParentConfig = false;\n\n  // Look for .clang-format/_clang-format file in the file's parent directories.\n  SmallString<128> UnsuitableConfigFiles;\n  SmallString<128> Path(FileName);\n  if (std::error_code EC = FS->makeAbsolute(Path))\n    return make_string_error(EC.message());\n\n  llvm::SmallVector<std::string, 2> FilesToLookFor;\n  FilesToLookFor.push_back(\".clang-format\");\n  FilesToLookFor.push_back(\"_clang-format\");\n\n  auto dropDiagnosticHandler = [](const llvm::SMDiagnostic &, void *) {};\n\n  for (StringRef Directory = Path; !Directory.empty();\n       Directory = llvm::sys::path::parent_path(Directory)) {\n\n    auto Status = FS->status(Directory);\n    if (!Status ||\n        Status->getType() != llvm::sys::fs::file_type::directory_file) {\n      continue;\n    }\n\n    for (const auto &F : FilesToLookFor) {\n      SmallString<128> ConfigFile(Directory);\n\n      llvm::sys::path::append(ConfigFile, F);\n      LLVM_DEBUG(llvm::dbgs() << \"Trying \" << ConfigFile << \"...\\n\");\n\n      Status = FS->status(ConfigFile.str());\n\n      if (Status &&\n          (Status->getType() == llvm::sys::fs::file_type::regular_file)) {\n        llvm::ErrorOr<std::unique_ptr<llvm::MemoryBuffer>> Text =\n            FS->getBufferForFile(ConfigFile.str());\n        if (std::error_code EC = Text.getError())\n          return make_string_error(EC.message());\n        if (std::error_code ec =\n                parseConfiguration(*Text.get(), &Style, AllowUnknownOptions)) {\n          if (ec == ParseError::Unsuitable) {\n            if (!UnsuitableConfigFiles.empty())\n              UnsuitableConfigFiles.append(\", \");\n            UnsuitableConfigFiles.append(ConfigFile);\n            continue;\n          }\n          return make_string_error(\"Error reading \" + ConfigFile + \": \" +\n                                   ec.message());\n        }\n        LLVM_DEBUG(llvm::dbgs()\n                   << \"Using configuration file \" << ConfigFile << \"\\n\");\n\n        if (!Style.InheritsParentConfig) {\n          if (ChildFormatTextToApply.empty())\n            return Style;\n\n          LLVM_DEBUG(llvm::dbgs() << \"Applying child configurations\\n\");\n\n          for (const auto& MemBuf : llvm::reverse(ChildFormatTextToApply)){\n            auto Ec = parseConfiguration(*MemBuf, &Style, AllowUnknownOptions,\n                                         dropDiagnosticHandler);\n            // It was already correctly parsed.\n            assert(!Ec);\n            static_cast<void>(Ec);\n          }\n\n          return Style;\n        }\n\n        LLVM_DEBUG(llvm::dbgs() << \"Inherits parent configuration\\n\");\n\n        // Reset inheritance of style\n        Style.InheritsParentConfig = false;\n\n        ChildFormatTextToApply.emplace_back(std::move(*Text));\n\n        // Breaking out of the inner loop, since we don't want to parse\n        // .clang-format AND _clang-format, if both exist. Then we continue the\n        // inner loop (parent directories) in search for the parent\n        // configuration.\n        break;\n      }\n    }\n  }\n  if (!UnsuitableConfigFiles.empty())\n    return make_string_error(\"Configuration file(s) do(es) not support \" +\n                             getLanguageName(Style.Language) + \": \" +\n                             UnsuitableConfigFiles);\n\n  if (!ChildFormatTextToApply.empty()) {\n    assert(ChildFormatTextToApply.size() == 1);\n\n    LLVM_DEBUG(llvm::dbgs()\n               << \"Applying child configuration on fallback style\\n\");\n\n    auto Ec =\n        parseConfiguration(*ChildFormatTextToApply.front(), &FallbackStyle,\n                           AllowUnknownOptions, dropDiagnosticHandler);\n    // It was already correctly parsed.\n    assert(!Ec);\n    static_cast<void>(Ec);\n  }\n\n  return FallbackStyle;\n}\n\n} // namespace format\n} // namespace clang\n"}}, "reports": [{"events": [{"location": {"col": 8, "file": 0, "line": 23}, "message": "move constructor 'CommentOptions' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/CommentOptions.h", "reportHash": "22eb6f443ac0c6fd7525175700ebf571", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 12, "line": 45}, "message": "default constructor 'ParseErrorCategory' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Format/Format.h", "reportHash": "bab11610d296f785ed4907364ba0f356", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 12, "line": 45}, "message": "destructor '~ParseErrorCategory' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Format/Format.h", "reportHash": "b9e9e03c139564b8395a9691ec7ee1aa", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 16, "line": 1507}, "message": "destructor '~JavaScriptRequoter' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Format/Format.cpp", "reportHash": "ebba4e08dbe5744b967bec12f5a1241f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 16, "line": 1594}, "message": "destructor '~Formatter' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Format/Format.cpp", "reportHash": "7781877db37cf07edb7ea8581fa79c14", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 16, "line": 1727}, "message": "destructor '~TrailingCommaInserter' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Format/Format.cpp", "reportHash": "90231c5773565be955d2eb226bc94a49", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 16, "line": 1787}, "message": "destructor '~Cleaner' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Format/Format.cpp", "reportHash": "0e0a32dc1410cf9b4963701b6d2eae3d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 16, "line": 1998}, "message": "destructor '~FormatTokenLess' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Format/Format.cpp", "reportHash": "d31cdd44441d97cc0b2a7b7e6ea58f7f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 16, "line": 2012}, "message": "destructor '~ObjCHeaderStyleGuesser' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Format/Format.cpp", "reportHash": "061f6a18db73b7c68fe555a6ce9ee199", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 23, "file": 16, "line": 2621}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Format/Format.cpp", "reportHash": "2928fa5cecff0adf29a3d6000efd9803", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 23, "file": 16, "line": 2621}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Format/Format.cpp", "reportHash": "2852685c90edafad37c62fe4804cec53", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 19, "file": 16, "line": 2633}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Format/Format.cpp", "reportHash": "136c3b8a1703fdeba8a37e2af8807f66", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 19, "file": 16, "line": 2633}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Format/Format.cpp", "reportHash": "6f7517010b2e456055f7350686e9e494", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 18, "file": 16, "line": 2731}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Format/Format.cpp", "reportHash": "d8395e44ce1ad6440ed09ea4e103a96f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 18, "file": 16, "line": 2731}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Format/Format.cpp", "reportHash": "7c0188b31d511cdc110a9257e2fb4f0a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 32, "file": 16, "line": 2999}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Format/Format.cpp", "reportHash": "ec2c7b062572fac8f2074249a2e86d07", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 32, "file": 16, "line": 2999}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Format/Format.cpp", "reportHash": "4269dd60d77eece3bd8d3e2e9f8ab896", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
