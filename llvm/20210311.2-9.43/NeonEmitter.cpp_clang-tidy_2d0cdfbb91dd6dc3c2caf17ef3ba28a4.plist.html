<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/home/vsts/work/1/llvm-project/clang/utils/TableGen/NeonEmitter.cpp", "content": "//===- NeonEmitter.cpp - Generate arm_neon.h for use with clang -*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This tablegen backend is responsible for emitting arm_neon.h, which includes\n// a declaration and definition of each function specified by the ARM NEON\n// compiler interface.  See ARM document DUI0348B.\n//\n// Each NEON instruction is implemented in terms of 1 or more functions which\n// are suffixed with the element type of the input vectors.  Functions may be\n// implemented in terms of generic vector operations such as +, *, -, etc. or\n// by calling a __builtin_-prefixed function which will be handled by clang's\n// CodeGen library.\n//\n// Additional validation code can be generated by this file when runHeader() is\n// called, rather than the normal run() entry point.\n//\n// See also the documentation in include/clang/Basic/arm_neon.td.\n//\n//===----------------------------------------------------------------------===//\n\n#include \"TableGenBackends.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringExtras.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include \"llvm/TableGen/Error.h\"\n#include \"llvm/TableGen/Record.h\"\n#include \"llvm/TableGen/SetTheory.h\"\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cstddef>\n#include <cstdint>\n#include <deque>\n#include <map>\n#include <set>\n#include <sstream>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace llvm;\n\nnamespace {\n\n// While globals are generally bad, this one allows us to perform assertions\n// liberally and somehow still trace them back to the def they indirectly\n// came from.\nstatic Record *CurrentRecord = nullptr;\nstatic void assert_with_loc(bool Assertion, const std::string &Str) {\n  if (!Assertion) {\n    if (CurrentRecord)\n      PrintFatalError(CurrentRecord->getLoc(), Str);\n    else\n      PrintFatalError(Str);\n  }\n}\n\nenum ClassKind {\n  ClassNone,\n  ClassI,     // generic integer instruction, e.g., \"i8\" suffix\n  ClassS,     // signed/unsigned/poly, e.g., \"s8\", \"u8\" or \"p8\" suffix\n  ClassW,     // width-specific instruction, e.g., \"8\" suffix\n  ClassB,     // bitcast arguments with enum argument to specify type\n  ClassL,     // Logical instructions which are op instructions\n              // but we need to not emit any suffix for in our\n              // tests.\n  ClassNoTest // Instructions which we do not test since they are\n              // not TRUE instructions.\n};\n\n/// NeonTypeFlags - Flags to identify the types for overloaded Neon\n/// builtins.  These must be kept in sync with the flags in\n/// include/clang/Basic/TargetBuiltins.h.\nnamespace NeonTypeFlags {\n\nenum { EltTypeMask = 0xf, UnsignedFlag = 0x10, QuadFlag = 0x20 };\n\nenum EltType {\n  Int8,\n  Int16,\n  Int32,\n  Int64,\n  Poly8,\n  Poly16,\n  Poly64,\n  Poly128,\n  Float16,\n  Float32,\n  Float64,\n  BFloat16\n};\n\n} // end namespace NeonTypeFlags\n\nclass NeonEmitter;\n\n//===----------------------------------------------------------------------===//\n// TypeSpec\n//===----------------------------------------------------------------------===//\n\n/// A TypeSpec is just a simple wrapper around a string, but gets its own type\n/// for strong typing purposes.\n///\n/// A TypeSpec can be used to create a type.\nclass TypeSpec : public std::string {\npublic:\n  static std::vector<TypeSpec> fromTypeSpecs(StringRef Str) {\n    std::vector<TypeSpec> Ret;\n    TypeSpec Acc;\n    for (char I : Str.str()) {\n      if (islower(I)) {\n        Acc.push_back(I);\n        Ret.push_back(TypeSpec(Acc));\n        Acc.clear();\n      } else {\n        Acc.push_back(I);\n      }\n    }\n    return Ret;\n  }\n};\n\n//===----------------------------------------------------------------------===//\n// Type\n//===----------------------------------------------------------------------===//\n\n/// A Type. Not much more to say here.\nclass Type {\nprivate:\n  TypeSpec TS;\n\n  enum TypeKind {\n    Void,\n    Float,\n    SInt,\n    UInt,\n    Poly,\n    BFloat16,\n  };\n  TypeKind Kind;\n  bool Immediate, Constant, Pointer;\n  // ScalarForMangling and NoManglingQ are really not suited to live here as\n  // they are not related to the type. But they live in the TypeSpec (not the\n  // prototype), so this is really the only place to store them.\n  bool ScalarForMangling, NoManglingQ;\n  unsigned Bitwidth, ElementBitwidth, NumVectors;\n\npublic:\n  Type()\n      : Kind(Void), Immediate(false), Constant(false),\n        Pointer(false), ScalarForMangling(false), NoManglingQ(false),\n        Bitwidth(0), ElementBitwidth(0), NumVectors(0) {}\n\n  Type(TypeSpec TS, StringRef CharMods)\n      : TS(std::move(TS)), Kind(Void), Immediate(false),\n        Constant(false), Pointer(false), ScalarForMangling(false),\n        NoManglingQ(false), Bitwidth(0), ElementBitwidth(0), NumVectors(0) {\n    applyModifiers(CharMods);\n  }\n\n  /// Returns a type representing \"void\".\n  static Type getVoid() { return Type(); }\n\n  bool operator==(const Type &Other) const { return str() == Other.str(); }\n  bool operator!=(const Type &Other) const { return !operator==(Other); }\n\n  //\n  // Query functions\n  //\n  bool isScalarForMangling() const { return ScalarForMangling; }\n  bool noManglingQ() const { return NoManglingQ; }\n\n  bool isPointer() const { return Pointer; }\n  bool isValue() const { return !isVoid() && !isPointer(); }\n  bool isScalar() const { return isValue() && NumVectors == 0; }\n  bool isVector() const { return isValue() && NumVectors > 0; }\n  bool isConstPointer() const { return Constant; }\n  bool isFloating() const { return Kind == Float; }\n  bool isInteger() const { return Kind == SInt || Kind == UInt; }\n  bool isPoly() const { return Kind == Poly; }\n  bool isSigned() const { return Kind == SInt; }\n  bool isImmediate() const { return Immediate; }\n  bool isFloat() const { return isFloating() && ElementBitwidth == 32; }\n  bool isDouble() const { return isFloating() && ElementBitwidth == 64; }\n  bool isHalf() const { return isFloating() && ElementBitwidth == 16; }\n  bool isChar() const { return ElementBitwidth == 8; }\n  bool isShort() const { return isInteger() && ElementBitwidth == 16; }\n  bool isInt() const { return isInteger() && ElementBitwidth == 32; }\n  bool isLong() const { return isInteger() && ElementBitwidth == 64; }\n  bool isVoid() const { return Kind == Void; }\n  bool isBFloat16() const { return Kind == BFloat16; }\n  unsigned getNumElements() const { return Bitwidth / ElementBitwidth; }\n  unsigned getSizeInBits() const { return Bitwidth; }\n  unsigned getElementSizeInBits() const { return ElementBitwidth; }\n  unsigned getNumVectors() const { return NumVectors; }\n\n  //\n  // Mutator functions\n  //\n  void makeUnsigned() {\n    assert(!isVoid() && \"not a potentially signed type\");\n    Kind = UInt;\n  }\n  void makeSigned() {\n    assert(!isVoid() && \"not a potentially signed type\");\n    Kind = SInt;\n  }\n\n  void makeInteger(unsigned ElemWidth, bool Sign) {\n    assert(!isVoid() && \"converting void to int probably not useful\");\n    Kind = Sign ? SInt : UInt;\n    Immediate = false;\n    ElementBitwidth = ElemWidth;\n  }\n\n  void makeImmediate(unsigned ElemWidth) {\n    Kind = SInt;\n    Immediate = true;\n    ElementBitwidth = ElemWidth;\n  }\n\n  void makeScalar() {\n    Bitwidth = ElementBitwidth;\n    NumVectors = 0;\n  }\n\n  void makeOneVector() {\n    assert(isVector());\n    NumVectors = 1;\n  }\n\n  void make32BitElement() {\n    assert_with_loc(Bitwidth > 32, \"Not enough bits to make it 32!\");\n    ElementBitwidth = 32;\n  }\n\n  void doubleLanes() {\n    assert_with_loc(Bitwidth != 128, \"Can't get bigger than 128!\");\n    Bitwidth = 128;\n  }\n\n  void halveLanes() {\n    assert_with_loc(Bitwidth != 64, \"Can't get smaller than 64!\");\n    Bitwidth = 64;\n  }\n\n  /// Return the C string representation of a type, which is the typename\n  /// defined in stdint.h or arm_neon.h.\n  std::string str() const;\n\n  /// Return the string representation of a type, which is an encoded\n  /// string for passing to the BUILTIN() macro in Builtins.def.\n  std::string builtin_str() const;\n\n  /// Return the value in NeonTypeFlags for this type.\n  unsigned getNeonEnum() const;\n\n  /// Parse a type from a stdint.h or arm_neon.h typedef name,\n  /// for example uint32x2_t or int64_t.\n  static Type fromTypedefName(StringRef Name);\n\nprivate:\n  /// Creates the type based on the typespec string in TS.\n  /// Sets \"Quad\" to true if the \"Q\" or \"H\" modifiers were\n  /// seen. This is needed by applyModifier as some modifiers\n  /// only take effect if the type size was changed by \"Q\" or \"H\".\n  void applyTypespec(bool &Quad);\n  /// Applies prototype modifiers to the type.\n  void applyModifiers(StringRef Mods);\n};\n\n//===----------------------------------------------------------------------===//\n// Variable\n//===----------------------------------------------------------------------===//\n\n/// A variable is a simple class that just has a type and a name.\nclass Variable {\n  Type T;\n  std::string N;\n\npublic:\n  Variable() : T(Type::getVoid()), N(\"\") {}\n  Variable(Type T, std::string N) : T(std::move(T)), N(std::move(N)) {}\n\n  Type getType() const { return T; }\n  std::string getName() const { return \"__\" + N; }\n};\n\n//===----------------------------------------------------------------------===//\n// Intrinsic\n//===----------------------------------------------------------------------===//\n\n/// The main grunt class. This represents an instantiation of an intrinsic with\n/// a particular typespec and prototype.\nclass Intrinsic {\n  /// The Record this intrinsic was created from.\n  Record *R;\n  /// The unmangled name.\n  std::string Name;\n  /// The input and output typespecs. InTS == OutTS except when\n  /// CartesianProductWith is non-empty - this is the case for vreinterpret.\n  TypeSpec OutTS, InTS;\n  /// The base class kind. Most intrinsics use ClassS, which has full type\n  /// info for integers (s32/u32). Some use ClassI, which doesn't care about\n  /// signedness (i32), while some (ClassB) have no type at all, only a width\n  /// (32).\n  ClassKind CK;\n  /// The list of DAGs for the body. May be empty, in which case we should\n  /// emit a builtin call.\n  ListInit *Body;\n  /// The architectural #ifdef guard.\n  std::string Guard;\n  /// Set if the Unavailable bit is 1. This means we don't generate a body,\n  /// just an \"unavailable\" attribute on a declaration.\n  bool IsUnavailable;\n  /// Is this intrinsic safe for big-endian? or does it need its arguments\n  /// reversing?\n  bool BigEndianSafe;\n\n  /// The types of return value [0] and parameters [1..].\n  std::vector<Type> Types;\n  /// The index of the key type passed to CGBuiltin.cpp for polymorphic calls.\n  int PolymorphicKeyType;\n  /// The local variables defined.\n  std::map<std::string, Variable> Variables;\n  /// NeededEarly - set if any other intrinsic depends on this intrinsic.\n  bool NeededEarly;\n  /// UseMacro - set if we should implement using a macro or unset for a\n  ///            function.\n  bool UseMacro;\n  /// The set of intrinsics that this intrinsic uses/requires.\n  std::set<Intrinsic *> Dependencies;\n  /// The \"base type\", which is Type('d', OutTS). InBaseType is only\n  /// different if CartesianProductWith is non-empty (for vreinterpret).\n  Type BaseType, InBaseType;\n  /// The return variable.\n  Variable RetVar;\n  /// A postfix to apply to every variable. Defaults to \"\".\n  std::string VariablePostfix;\n\n  NeonEmitter &Emitter;\n  std::stringstream OS;\n\n  bool isBigEndianSafe() const {\n    if (BigEndianSafe)\n      return true;\n\n    for (const auto &T : Types){\n      if (T.isVector() && T.getNumElements() > 1)\n        return false;\n    }\n    return true;\n  }\n\npublic:\n  Intrinsic(Record *R, StringRef Name, StringRef Proto, TypeSpec OutTS,\n            TypeSpec InTS, ClassKind CK, ListInit *Body, NeonEmitter &Emitter,\n            StringRef Guard, bool IsUnavailable, bool BigEndianSafe)\n      : R(R), Name(Name.str()), OutTS(OutTS), InTS(InTS), CK(CK), Body(Body),\n        Guard(Guard.str()), IsUnavailable(IsUnavailable),\n        BigEndianSafe(BigEndianSafe), PolymorphicKeyType(0), NeededEarly(false),\n        UseMacro(false), BaseType(OutTS, \".\"), InBaseType(InTS, \".\"),\n        Emitter(Emitter) {\n    // Modify the TypeSpec per-argument to get a concrete Type, and create\n    // known variables for each.\n    // Types[0] is the return value.\n    unsigned Pos = 0;\n    Types.emplace_back(OutTS, getNextModifiers(Proto, Pos));\n    StringRef Mods = getNextModifiers(Proto, Pos);\n    while (!Mods.empty()) {\n      Types.emplace_back(InTS, Mods);\n      if (Mods.find('!') != StringRef::npos)\n        PolymorphicKeyType = Types.size() - 1;\n\n      Mods = getNextModifiers(Proto, Pos);\n    }\n\n    for (auto Type : Types) {\n      // If this builtin takes an immediate argument, we need to #define it rather\n      // than use a standard declaration, so that SemaChecking can range check\n      // the immediate passed by the user.\n\n      // Pointer arguments need to use macros to avoid hiding aligned attributes\n      // from the pointer type.\n\n      // It is not permitted to pass or return an __fp16 by value, so intrinsics\n      // taking a scalar float16_t must be implemented as macros.\n      if (Type.isImmediate() || Type.isPointer() ||\n          (Type.isScalar() && Type.isHalf()))\n        UseMacro = true;\n    }\n  }\n\n  /// Get the Record that this intrinsic is based off.\n  Record *getRecord() const { return R; }\n  /// Get the set of Intrinsics that this intrinsic calls.\n  /// this is the set of immediate dependencies, NOT the\n  /// transitive closure.\n  const std::set<Intrinsic *> &getDependencies() const { return Dependencies; }\n  /// Get the architectural guard string (#ifdef).\n  std::string getGuard() const { return Guard; }\n  /// Get the non-mangled name.\n  std::string getName() const { return Name; }\n\n  /// Return true if the intrinsic takes an immediate operand.\n  bool hasImmediate() const {\n    return std::any_of(Types.begin(), Types.end(),\n                       [](const Type &T) { return T.isImmediate(); });\n  }\n\n  /// Return the parameter index of the immediate operand.\n  unsigned getImmediateIdx() const {\n    for (unsigned Idx = 0; Idx < Types.size(); ++Idx)\n      if (Types[Idx].isImmediate())\n        return Idx - 1;\n    llvm_unreachable(\"Intrinsic has no immediate\");\n  }\n\n\n  unsigned getNumParams() const { return Types.size() - 1; }\n  Type getReturnType() const { return Types[0]; }\n  Type getParamType(unsigned I) const { return Types[I + 1]; }\n  Type getBaseType() const { return BaseType; }\n  Type getPolymorphicKeyType() const { return Types[PolymorphicKeyType]; }\n\n  /// Return true if the prototype has a scalar argument.\n  bool protoHasScalar() const;\n\n  /// Return the index that parameter PIndex will sit at\n  /// in a generated function call. This is often just PIndex,\n  /// but may not be as things such as multiple-vector operands\n  /// and sret parameters need to be taken into accont.\n  unsigned getGeneratedParamIdx(unsigned PIndex) {\n    unsigned Idx = 0;\n    if (getReturnType().getNumVectors() > 1)\n      // Multiple vectors are passed as sret.\n      ++Idx;\n\n    for (unsigned I = 0; I < PIndex; ++I)\n      Idx += std::max(1U, getParamType(I).getNumVectors());\n\n    return Idx;\n  }\n\n  bool hasBody() const { return Body && !Body->getValues().empty(); }\n\n  void setNeededEarly() { NeededEarly = true; }\n\n  bool operator<(const Intrinsic &Other) const {\n    // Sort lexicographically on a two-tuple (Guard, Name)\n    if (Guard != Other.Guard)\n      return Guard < Other.Guard;\n    return Name < Other.Name;\n  }\n\n  ClassKind getClassKind(bool UseClassBIfScalar = false) {\n    if (UseClassBIfScalar && !protoHasScalar())\n      return ClassB;\n    return CK;\n  }\n\n  /// Return the name, mangled with type information.\n  /// If ForceClassS is true, use ClassS (u32/s32) instead\n  /// of the intrinsic's own type class.\n  std::string getMangledName(bool ForceClassS = false) const;\n  /// Return the type code for a builtin function call.\n  std::string getInstTypeCode(Type T, ClassKind CK) const;\n  /// Return the type string for a BUILTIN() macro in Builtins.def.\n  std::string getBuiltinTypeStr();\n\n  /// Generate the intrinsic, returning code.\n  std::string generate();\n  /// Perform type checking and populate the dependency graph, but\n  /// don't generate code yet.\n  void indexBody();\n\nprivate:\n  StringRef getNextModifiers(StringRef Proto, unsigned &Pos) const;\n\n  std::string mangleName(std::string Name, ClassKind CK) const;\n\n  void initVariables();\n  std::string replaceParamsIn(std::string S);\n\n  void emitBodyAsBuiltinCall();\n\n  void generateImpl(bool ReverseArguments,\n                    StringRef NamePrefix, StringRef CallPrefix);\n  void emitReturn();\n  void emitBody(StringRef CallPrefix);\n  void emitShadowedArgs();\n  void emitArgumentReversal();\n  void emitReturnReversal();\n  void emitReverseVariable(Variable &Dest, Variable &Src);\n  void emitNewLine();\n  void emitClosingBrace();\n  void emitOpeningBrace();\n  void emitPrototype(StringRef NamePrefix);\n\n  class DagEmitter {\n    Intrinsic &Intr;\n    StringRef CallPrefix;\n\n  public:\n    DagEmitter(Intrinsic &Intr, StringRef CallPrefix) :\n      Intr(Intr), CallPrefix(CallPrefix) {\n    }\n    std::pair<Type, std::string> emitDagArg(Init *Arg, std::string ArgName);\n    std::pair<Type, std::string> emitDagSaveTemp(DagInit *DI);\n    std::pair<Type, std::string> emitDagSplat(DagInit *DI);\n    std::pair<Type, std::string> emitDagDup(DagInit *DI);\n    std::pair<Type, std::string> emitDagDupTyped(DagInit *DI);\n    std::pair<Type, std::string> emitDagShuffle(DagInit *DI);\n    std::pair<Type, std::string> emitDagCast(DagInit *DI, bool IsBitCast);\n    std::pair<Type, std::string> emitDagCall(DagInit *DI,\n                                             bool MatchMangledName);\n    std::pair<Type, std::string> emitDagNameReplace(DagInit *DI);\n    std::pair<Type, std::string> emitDagLiteral(DagInit *DI);\n    std::pair<Type, std::string> emitDagOp(DagInit *DI);\n    std::pair<Type, std::string> emitDag(DagInit *DI);\n  };\n};\n\n//===----------------------------------------------------------------------===//\n// NeonEmitter\n//===----------------------------------------------------------------------===//\n\nclass NeonEmitter {\n  RecordKeeper &Records;\n  DenseMap<Record *, ClassKind> ClassMap;\n  std::map<std::string, std::deque<Intrinsic>> IntrinsicMap;\n  unsigned UniqueNumber;\n\n  void createIntrinsic(Record *R, SmallVectorImpl<Intrinsic *> &Out);\n  void genBuiltinsDef(raw_ostream &OS, SmallVectorImpl<Intrinsic *> &Defs);\n  void genOverloadTypeCheckCode(raw_ostream &OS,\n                                SmallVectorImpl<Intrinsic *> &Defs);\n  void genIntrinsicRangeCheckCode(raw_ostream &OS,\n                                  SmallVectorImpl<Intrinsic *> &Defs);\n\npublic:\n  /// Called by Intrinsic - this attempts to get an intrinsic that takes\n  /// the given types as arguments.\n  Intrinsic &getIntrinsic(StringRef Name, ArrayRef<Type> Types,\n                          Optional<std::string> MangledName);\n\n  /// Called by Intrinsic - returns a globally-unique number.\n  unsigned getUniqueNumber() { return UniqueNumber++; }\n\n  NeonEmitter(RecordKeeper &R) : Records(R), UniqueNumber(0) {\n    Record *SI = R.getClass(\"SInst\");\n    Record *II = R.getClass(\"IInst\");\n    Record *WI = R.getClass(\"WInst\");\n    Record *SOpI = R.getClass(\"SOpInst\");\n    Record *IOpI = R.getClass(\"IOpInst\");\n    Record *WOpI = R.getClass(\"WOpInst\");\n    Record *LOpI = R.getClass(\"LOpInst\");\n    Record *NoTestOpI = R.getClass(\"NoTestOpInst\");\n\n    ClassMap[SI] = ClassS;\n    ClassMap[II] = ClassI;\n    ClassMap[WI] = ClassW;\n    ClassMap[SOpI] = ClassS;\n    ClassMap[IOpI] = ClassI;\n    ClassMap[WOpI] = ClassW;\n    ClassMap[LOpI] = ClassL;\n    ClassMap[NoTestOpI] = ClassNoTest;\n  }\n\n  // Emit arm_neon.h.inc\n  void run(raw_ostream &o);\n\n  // Emit arm_fp16.h.inc\n  void runFP16(raw_ostream &o);\n\n  // Emit arm_bf16.h.inc\n  void runBF16(raw_ostream &o);\n\n  // Emit all the __builtin prototypes used in arm_neon.h, arm_fp16.h and\n  // arm_bf16.h\n  void runHeader(raw_ostream &o);\n};\n\n} // end anonymous namespace\n\n//===----------------------------------------------------------------------===//\n// Type implementation\n//===----------------------------------------------------------------------===//\n\nstd::string Type::str() const {\n  if (isVoid())\n    return \"void\";\n  std::string S;\n\n  if (isInteger() && !isSigned())\n    S += \"u\";\n\n  if (isPoly())\n    S += \"poly\";\n  else if (isFloating())\n    S += \"float\";\n  else if (isBFloat16())\n    S += \"bfloat\";\n  else\n    S += \"int\";\n\n  S += utostr(ElementBitwidth);\n  if (isVector())\n    S += \"x\" + utostr(getNumElements());\n  if (NumVectors > 1)\n    S += \"x\" + utostr(NumVectors);\n  S += \"_t\";\n\n  if (Constant)\n    S += \" const\";\n  if (Pointer)\n    S += \" *\";\n\n  return S;\n}\n\nstd::string Type::builtin_str() const {\n  std::string S;\n  if (isVoid())\n    return \"v\";\n\n  if (isPointer()) {\n    // All pointers are void pointers.\n    S = \"v\";\n    if (isConstPointer())\n      S += \"C\";\n    S += \"*\";\n    return S;\n  } else if (isInteger())\n    switch (ElementBitwidth) {\n    case 8: S += \"c\"; break;\n    case 16: S += \"s\"; break;\n    case 32: S += \"i\"; break;\n    case 64: S += \"Wi\"; break;\n    case 128: S += \"LLLi\"; break;\n    default: llvm_unreachable(\"Unhandled case!\");\n    }\n  else if (isBFloat16()) {\n    assert(ElementBitwidth == 16 && \"BFloat16 can only be 16 bits\");\n    S += \"y\";\n  } else\n    switch (ElementBitwidth) {\n    case 16: S += \"h\"; break;\n    case 32: S += \"f\"; break;\n    case 64: S += \"d\"; break;\n    default: llvm_unreachable(\"Unhandled case!\");\n    }\n\n  // FIXME: NECESSARY???????????????????????????????????????????????????????????????????????\n  if (isChar() && !isPointer() && isSigned())\n    // Make chars explicitly signed.\n    S = \"S\" + S;\n  else if (isInteger() && !isSigned())\n    S = \"U\" + S;\n\n  // Constant indices are \"int\", but have the \"constant expression\" modifier.\n  if (isImmediate()) {\n    assert(isInteger() && isSigned());\n    S = \"I\" + S;\n  }\n\n  if (isScalar())\n    return S;\n\n  std::string Ret;\n  for (unsigned I = 0; I < NumVectors; ++I)\n    Ret += \"V\" + utostr(getNumElements()) + S;\n\n  return Ret;\n}\n\nunsigned Type::getNeonEnum() const {\n  unsigned Addend;\n  switch (ElementBitwidth) {\n  case 8: Addend = 0; break;\n  case 16: Addend = 1; break;\n  case 32: Addend = 2; break;\n  case 64: Addend = 3; break;\n  case 128: Addend = 4; break;\n  default: llvm_unreachable(\"Unhandled element bitwidth!\");\n  }\n\n  unsigned Base = (unsigned)NeonTypeFlags::Int8 + Addend;\n  if (isPoly()) {\n    // Adjustment needed because Poly32 doesn't exist.\n    if (Addend >= 2)\n      --Addend;\n    Base = (unsigned)NeonTypeFlags::Poly8 + Addend;\n  }\n  if (isFloating()) {\n    assert(Addend != 0 && \"Float8 doesn't exist!\");\n    Base = (unsigned)NeonTypeFlags::Float16 + (Addend - 1);\n  }\n\n  if (isBFloat16()) {\n    assert(Addend == 1 && \"BFloat16 is only 16 bit\");\n    Base = (unsigned)NeonTypeFlags::BFloat16;\n  }\n\n  if (Bitwidth == 128)\n    Base |= (unsigned)NeonTypeFlags::QuadFlag;\n  if (isInteger() && !isSigned())\n    Base |= (unsigned)NeonTypeFlags::UnsignedFlag;\n\n  return Base;\n}\n\nType Type::fromTypedefName(StringRef Name) {\n  Type T;\n  T.Kind = SInt;\n\n  if (Name.front() == 'u') {\n    T.Kind = UInt;\n    Name = Name.drop_front();\n  }\n\n  if (Name.startswith(\"float\")) {\n    T.Kind = Float;\n    Name = Name.drop_front(5);\n  } else if (Name.startswith(\"poly\")) {\n    T.Kind = Poly;\n    Name = Name.drop_front(4);\n  } else if (Name.startswith(\"bfloat\")) {\n    T.Kind = BFloat16;\n    Name = Name.drop_front(6);\n  } else {\n    assert(Name.startswith(\"int\"));\n    Name = Name.drop_front(3);\n  }\n\n  unsigned I = 0;\n  for (I = 0; I < Name.size(); ++I) {\n    if (!isdigit(Name[I]))\n      break;\n  }\n  Name.substr(0, I).getAsInteger(10, T.ElementBitwidth);\n  Name = Name.drop_front(I);\n\n  T.Bitwidth = T.ElementBitwidth;\n  T.NumVectors = 1;\n\n  if (Name.front() == 'x') {\n    Name = Name.drop_front();\n    unsigned I = 0;\n    for (I = 0; I < Name.size(); ++I) {\n      if (!isdigit(Name[I]))\n        break;\n    }\n    unsigned NumLanes;\n    Name.substr(0, I).getAsInteger(10, NumLanes);\n    Name = Name.drop_front(I);\n    T.Bitwidth = T.ElementBitwidth * NumLanes;\n  } else {\n    // Was scalar.\n    T.NumVectors = 0;\n  }\n  if (Name.front() == 'x') {\n    Name = Name.drop_front();\n    unsigned I = 0;\n    for (I = 0; I < Name.size(); ++I) {\n      if (!isdigit(Name[I]))\n        break;\n    }\n    Name.substr(0, I).getAsInteger(10, T.NumVectors);\n    Name = Name.drop_front(I);\n  }\n\n  assert(Name.startswith(\"_t\") && \"Malformed typedef!\");\n  return T;\n}\n\nvoid Type::applyTypespec(bool &Quad) {\n  std::string S = TS;\n  ScalarForMangling = false;\n  Kind = SInt;\n  ElementBitwidth = ~0U;\n  NumVectors = 1;\n\n  for (char I : S) {\n    switch (I) {\n    case 'S':\n      ScalarForMangling = true;\n      break;\n    case 'H':\n      NoManglingQ = true;\n      Quad = true;\n      break;\n    case 'Q':\n      Quad = true;\n      break;\n    case 'P':\n      Kind = Poly;\n      break;\n    case 'U':\n      Kind = UInt;\n      break;\n    case 'c':\n      ElementBitwidth = 8;\n      break;\n    case 'h':\n      Kind = Float;\n      LLVM_FALLTHROUGH;\n    case 's':\n      ElementBitwidth = 16;\n      break;\n    case 'f':\n      Kind = Float;\n      LLVM_FALLTHROUGH;\n    case 'i':\n      ElementBitwidth = 32;\n      break;\n    case 'd':\n      Kind = Float;\n      LLVM_FALLTHROUGH;\n    case 'l':\n      ElementBitwidth = 64;\n      break;\n    case 'k':\n      ElementBitwidth = 128;\n      // Poly doesn't have a 128x1 type.\n      if (isPoly())\n        NumVectors = 0;\n      break;\n    case 'b':\n      Kind = BFloat16;\n      ElementBitwidth = 16;\n      break;\n    default:\n      llvm_unreachable(\"Unhandled type code!\");\n    }\n  }\n  assert(ElementBitwidth != ~0U && \"Bad element bitwidth!\");\n\n  Bitwidth = Quad ? 128 : 64;\n}\n\nvoid Type::applyModifiers(StringRef Mods) {\n  bool AppliedQuad = false;\n  applyTypespec(AppliedQuad);\n\n  for (char Mod : Mods) {\n    switch (Mod) {\n    case '.':\n      break;\n    case 'v':\n      Kind = Void;\n      break;\n    case 'S':\n      Kind = SInt;\n      break;\n    case 'U':\n      Kind = UInt;\n      break;\n    case 'B':\n      Kind = BFloat16;\n      ElementBitwidth = 16;\n      break;\n    case 'F':\n      Kind = Float;\n      break;\n    case 'P':\n      Kind = Poly;\n      break;\n    case '>':\n      assert(ElementBitwidth < 128);\n      ElementBitwidth *= 2;\n      break;\n    case '<':\n      assert(ElementBitwidth > 8);\n      ElementBitwidth /= 2;\n      break;\n    case '1':\n      NumVectors = 0;\n      break;\n    case '2':\n      NumVectors = 2;\n      break;\n    case '3':\n      NumVectors = 3;\n      break;\n    case '4':\n      NumVectors = 4;\n      break;\n    case '*':\n      Pointer = true;\n      break;\n    case 'c':\n      Constant = true;\n      break;\n    case 'Q':\n      Bitwidth = 128;\n      break;\n    case 'q':\n      Bitwidth = 64;\n      break;\n    case 'I':\n      Kind = SInt;\n      ElementBitwidth = Bitwidth = 32;\n      NumVectors = 0;\n      Immediate = true;\n      break;\n    case 'p':\n      if (isPoly())\n        Kind = UInt;\n      break;\n    case '!':\n      // Key type, handled elsewhere.\n      break;\n    default:\n      llvm_unreachable(\"Unhandled character!\");\n    }\n  }\n}\n\n//===----------------------------------------------------------------------===//\n// Intrinsic implementation\n//===----------------------------------------------------------------------===//\n\nStringRef Intrinsic::getNextModifiers(StringRef Proto, unsigned &Pos) const {\n  if (Proto.size() == Pos)\n    return StringRef();\n  else if (Proto[Pos] != '(')\n    return Proto.substr(Pos++, 1);\n\n  size_t Start = Pos + 1;\n  size_t End = Proto.find(')', Start);\n  assert_with_loc(End != StringRef::npos, \"unmatched modifier group paren\");\n  Pos = End + 1;\n  return Proto.slice(Start, End);\n}\n\nstd::string Intrinsic::getInstTypeCode(Type T, ClassKind CK) const {\n  char typeCode = '\\0';\n  bool printNumber = true;\n\n  if (CK == ClassB)\n    return \"\";\n\n  if (T.isBFloat16())\n    return \"bf16\";\n\n  if (T.isPoly())\n    typeCode = 'p';\n  else if (T.isInteger())\n    typeCode = T.isSigned() ? 's' : 'u';\n  else\n    typeCode = 'f';\n\n  if (CK == ClassI) {\n    switch (typeCode) {\n    default:\n      break;\n    case 's':\n    case 'u':\n    case 'p':\n      typeCode = 'i';\n      break;\n    }\n  }\n  if (CK == ClassB) {\n    typeCode = '\\0';\n  }\n\n  std::string S;\n  if (typeCode != '\\0')\n    S.push_back(typeCode);\n  if (printNumber)\n    S += utostr(T.getElementSizeInBits());\n\n  return S;\n}\n\nstd::string Intrinsic::getBuiltinTypeStr() {\n  ClassKind LocalCK = getClassKind(true);\n  std::string S;\n\n  Type RetT = getReturnType();\n  if ((LocalCK == ClassI || LocalCK == ClassW) && RetT.isScalar() &&\n      !RetT.isFloating() && !RetT.isBFloat16())\n    RetT.makeInteger(RetT.getElementSizeInBits(), false);\n\n  // Since the return value must be one type, return a vector type of the\n  // appropriate width which we will bitcast.  An exception is made for\n  // returning structs of 2, 3, or 4 vectors which are returned in a sret-like\n  // fashion, storing them to a pointer arg.\n  if (RetT.getNumVectors() > 1) {\n    S += \"vv*\"; // void result with void* first argument\n  } else {\n    if (RetT.isPoly())\n      RetT.makeInteger(RetT.getElementSizeInBits(), false);\n    if (!RetT.isScalar() && RetT.isInteger() && !RetT.isSigned())\n      RetT.makeSigned();\n\n    if (LocalCK == ClassB && RetT.isValue() && !RetT.isScalar())\n      // Cast to vector of 8-bit elements.\n      RetT.makeInteger(8, true);\n\n    S += RetT.builtin_str();\n  }\n\n  for (unsigned I = 0; I < getNumParams(); ++I) {\n    Type T = getParamType(I);\n    if (T.isPoly())\n      T.makeInteger(T.getElementSizeInBits(), false);\n\n    if (LocalCK == ClassB && !T.isScalar())\n      T.makeInteger(8, true);\n    // Halves always get converted to 8-bit elements.\n    if (T.isHalf() && T.isVector() && !T.isScalarForMangling())\n      T.makeInteger(8, true);\n\n    if (LocalCK == ClassI && T.isInteger())\n      T.makeSigned();\n\n    if (hasImmediate() && getImmediateIdx() == I)\n      T.makeImmediate(32);\n\n    S += T.builtin_str();\n  }\n\n  // Extra constant integer to hold type class enum for this function, e.g. s8\n  if (LocalCK == ClassB)\n    S += \"i\";\n\n  return S;\n}\n\nstd::string Intrinsic::getMangledName(bool ForceClassS) const {\n  // Check if the prototype has a scalar operand with the type of the vector\n  // elements.  If not, bitcasting the args will take care of arg checking.\n  // The actual signedness etc. will be taken care of with special enums.\n  ClassKind LocalCK = CK;\n  if (!protoHasScalar())\n    LocalCK = ClassB;\n\n  return mangleName(Name, ForceClassS ? ClassS : LocalCK);\n}\n\nstd::string Intrinsic::mangleName(std::string Name, ClassKind LocalCK) const {\n  std::string typeCode = getInstTypeCode(BaseType, LocalCK);\n  std::string S = Name;\n\n  if (Name == \"vcvt_f16_f32\" || Name == \"vcvt_f32_f16\" ||\n      Name == \"vcvt_f32_f64\" || Name == \"vcvt_f64_f32\" ||\n      Name == \"vcvt_f32_bf16\")\n    return Name;\n\n  if (!typeCode.empty()) {\n    // If the name ends with _xN (N = 2,3,4), insert the typeCode before _xN.\n    if (Name.size() >= 3 && isdigit(Name.back()) &&\n        Name[Name.length() - 2] == 'x' && Name[Name.length() - 3] == '_')\n      S.insert(S.length() - 3, \"_\" + typeCode);\n    else\n      S += \"_\" + typeCode;\n  }\n\n  if (BaseType != InBaseType) {\n    // A reinterpret - out the input base type at the end.\n    S += \"_\" + getInstTypeCode(InBaseType, LocalCK);\n  }\n\n  if (LocalCK == ClassB)\n    S += \"_v\";\n\n  // Insert a 'q' before the first '_' character so that it ends up before\n  // _lane or _n on vector-scalar operations.\n  if (BaseType.getSizeInBits() == 128 && !BaseType.noManglingQ()) {\n    size_t Pos = S.find('_');\n    S.insert(Pos, \"q\");\n  }\n\n  char Suffix = '\\0';\n  if (BaseType.isScalarForMangling()) {\n    switch (BaseType.getElementSizeInBits()) {\n    case 8: Suffix = 'b'; break;\n    case 16: Suffix = 'h'; break;\n    case 32: Suffix = 's'; break;\n    case 64: Suffix = 'd'; break;\n    default: llvm_unreachable(\"Bad suffix!\");\n    }\n  }\n  if (Suffix != '\\0') {\n    size_t Pos = S.find('_');\n    S.insert(Pos, &Suffix, 1);\n  }\n\n  return S;\n}\n\nstd::string Intrinsic::replaceParamsIn(std::string S) {\n  while (S.find('$') != std::string::npos) {\n    size_t Pos = S.find('$');\n    size_t End = Pos + 1;\n    while (isalpha(S[End]))\n      ++End;\n\n    std::string VarName = S.substr(Pos + 1, End - Pos - 1);\n    assert_with_loc(Variables.find(VarName) != Variables.end(),\n                    \"Variable not defined!\");\n    S.replace(Pos, End - Pos, Variables.find(VarName)->second.getName());\n  }\n\n  return S;\n}\n\nvoid Intrinsic::initVariables() {\n  Variables.clear();\n\n  // Modify the TypeSpec per-argument to get a concrete Type, and create\n  // known variables for each.\n  for (unsigned I = 1; I < Types.size(); ++I) {\n    char NameC = '0' + (I - 1);\n    std::string Name = \"p\";\n    Name.push_back(NameC);\n\n    Variables[Name] = Variable(Types[I], Name + VariablePostfix);\n  }\n  RetVar = Variable(Types[0], \"ret\" + VariablePostfix);\n}\n\nvoid Intrinsic::emitPrototype(StringRef NamePrefix) {\n  if (UseMacro)\n    OS << \"#define \";\n  else\n    OS << \"__ai \" << Types[0].str() << \" \";\n\n  OS << NamePrefix.str() << mangleName(Name, ClassS) << \"(\";\n\n  for (unsigned I = 0; I < getNumParams(); ++I) {\n    if (I != 0)\n      OS << \", \";\n\n    char NameC = '0' + I;\n    std::string Name = \"p\";\n    Name.push_back(NameC);\n    assert(Variables.find(Name) != Variables.end());\n    Variable &V = Variables[Name];\n\n    if (!UseMacro)\n      OS << V.getType().str() << \" \";\n    OS << V.getName();\n  }\n\n  OS << \")\";\n}\n\nvoid Intrinsic::emitOpeningBrace() {\n  if (UseMacro)\n    OS << \" __extension__ ({\";\n  else\n    OS << \" {\";\n  emitNewLine();\n}\n\nvoid Intrinsic::emitClosingBrace() {\n  if (UseMacro)\n    OS << \"})\";\n  else\n    OS << \"}\";\n}\n\nvoid Intrinsic::emitNewLine() {\n  if (UseMacro)\n    OS << \" \\\\\\n\";\n  else\n    OS << \"\\n\";\n}\n\nvoid Intrinsic::emitReverseVariable(Variable &Dest, Variable &Src) {\n  if (Dest.getType().getNumVectors() > 1) {\n    emitNewLine();\n\n    for (unsigned K = 0; K < Dest.getType().getNumVectors(); ++K) {\n      OS << \"  \" << Dest.getName() << \".val[\" << K << \"] = \"\n         << \"__builtin_shufflevector(\"\n         << Src.getName() << \".val[\" << K << \"], \"\n         << Src.getName() << \".val[\" << K << \"]\";\n      for (int J = Dest.getType().getNumElements() - 1; J >= 0; --J)\n        OS << \", \" << J;\n      OS << \");\";\n      emitNewLine();\n    }\n  } else {\n    OS << \"  \" << Dest.getName()\n       << \" = __builtin_shufflevector(\" << Src.getName() << \", \" << Src.getName();\n    for (int J = Dest.getType().getNumElements() - 1; J >= 0; --J)\n      OS << \", \" << J;\n    OS << \");\";\n    emitNewLine();\n  }\n}\n\nvoid Intrinsic::emitArgumentReversal() {\n  if (isBigEndianSafe())\n    return;\n\n  // Reverse all vector arguments.\n  for (unsigned I = 0; I < getNumParams(); ++I) {\n    std::string Name = \"p\" + utostr(I);\n    std::string NewName = \"rev\" + utostr(I);\n\n    Variable &V = Variables[Name];\n    Variable NewV(V.getType(), NewName + VariablePostfix);\n\n    if (!NewV.getType().isVector() || NewV.getType().getNumElements() == 1)\n      continue;\n\n    OS << \"  \" << NewV.getType().str() << \" \" << NewV.getName() << \";\";\n    emitReverseVariable(NewV, V);\n    V = NewV;\n  }\n}\n\nvoid Intrinsic::emitReturnReversal() {\n  if (isBigEndianSafe())\n    return;\n  if (!getReturnType().isVector() || getReturnType().isVoid() ||\n      getReturnType().getNumElements() == 1)\n    return;\n  emitReverseVariable(RetVar, RetVar);\n}\n\nvoid Intrinsic::emitShadowedArgs() {\n  // Macro arguments are not type-checked like inline function arguments,\n  // so assign them to local temporaries to get the right type checking.\n  if (!UseMacro)\n    return;\n\n  for (unsigned I = 0; I < getNumParams(); ++I) {\n    // Do not create a temporary for an immediate argument.\n    // That would defeat the whole point of using a macro!\n    if (getParamType(I).isImmediate())\n      continue;\n    // Do not create a temporary for pointer arguments. The input\n    // pointer may have an alignment hint.\n    if (getParamType(I).isPointer())\n      continue;\n\n    std::string Name = \"p\" + utostr(I);\n\n    assert(Variables.find(Name) != Variables.end());\n    Variable &V = Variables[Name];\n\n    std::string NewName = \"s\" + utostr(I);\n    Variable V2(V.getType(), NewName + VariablePostfix);\n\n    OS << \"  \" << V2.getType().str() << \" \" << V2.getName() << \" = \"\n       << V.getName() << \";\";\n    emitNewLine();\n\n    V = V2;\n  }\n}\n\nbool Intrinsic::protoHasScalar() const {\n  return std::any_of(Types.begin(), Types.end(), [](const Type &T) {\n    return T.isScalar() && !T.isImmediate();\n  });\n}\n\nvoid Intrinsic::emitBodyAsBuiltinCall() {\n  std::string S;\n\n  // If this builtin returns a struct 2, 3, or 4 vectors, pass it as an implicit\n  // sret-like argument.\n  bool SRet = getReturnType().getNumVectors() >= 2;\n\n  StringRef N = Name;\n  ClassKind LocalCK = CK;\n  if (!protoHasScalar())\n    LocalCK = ClassB;\n\n  if (!getReturnType().isVoid() && !SRet)\n    S += \"(\" + RetVar.getType().str() + \") \";\n\n  S += \"__builtin_neon_\" + mangleName(std::string(N), LocalCK) + \"(\";\n\n  if (SRet)\n    S += \"&\" + RetVar.getName() + \", \";\n\n  for (unsigned I = 0; I < getNumParams(); ++I) {\n    Variable &V = Variables[\"p\" + utostr(I)];\n    Type T = V.getType();\n\n    // Handle multiple-vector values specially, emitting each subvector as an\n    // argument to the builtin.\n    if (T.getNumVectors() > 1) {\n      // Check if an explicit cast is needed.\n      std::string Cast;\n      if (LocalCK == ClassB) {\n        Type T2 = T;\n        T2.makeOneVector();\n        T2.makeInteger(8, /*Signed=*/true);\n        Cast = \"(\" + T2.str() + \")\";\n      }\n\n      for (unsigned J = 0; J < T.getNumVectors(); ++J)\n        S += Cast + V.getName() + \".val[\" + utostr(J) + \"], \";\n      continue;\n    }\n\n    std::string Arg = V.getName();\n    Type CastToType = T;\n\n    // Check if an explicit cast is needed.\n    if (CastToType.isVector() &&\n        (LocalCK == ClassB || (T.isHalf() && !T.isScalarForMangling()))) {\n      CastToType.makeInteger(8, true);\n      Arg = \"(\" + CastToType.str() + \")\" + Arg;\n    } else if (CastToType.isVector() && LocalCK == ClassI) {\n      if (CastToType.isInteger())\n        CastToType.makeSigned();\n      Arg = \"(\" + CastToType.str() + \")\" + Arg;\n    }\n\n    S += Arg + \", \";\n  }\n\n  // Extra constant integer to hold type class enum for this function, e.g. s8\n  if (getClassKind(true) == ClassB) {\n    S += utostr(getPolymorphicKeyType().getNeonEnum());\n  } else {\n    // Remove extraneous \", \".\n    S.pop_back();\n    S.pop_back();\n  }\n  S += \");\";\n\n  std::string RetExpr;\n  if (!SRet && !RetVar.getType().isVoid())\n    RetExpr = RetVar.getName() + \" = \";\n\n  OS << \"  \" << RetExpr << S;\n  emitNewLine();\n}\n\nvoid Intrinsic::emitBody(StringRef CallPrefix) {\n  std::vector<std::string> Lines;\n\n  assert(RetVar.getType() == Types[0]);\n  // Create a return variable, if we're not void.\n  if (!RetVar.getType().isVoid()) {\n    OS << \"  \" << RetVar.getType().str() << \" \" << RetVar.getName() << \";\";\n    emitNewLine();\n  }\n\n  if (!Body || Body->getValues().empty()) {\n    // Nothing specific to output - must output a builtin.\n    emitBodyAsBuiltinCall();\n    return;\n  }\n\n  // We have a list of \"things to output\". The last should be returned.\n  for (auto *I : Body->getValues()) {\n    if (StringInit *SI = dyn_cast<StringInit>(I)) {\n      Lines.push_back(replaceParamsIn(SI->getAsString()));\n    } else if (DagInit *DI = dyn_cast<DagInit>(I)) {\n      DagEmitter DE(*this, CallPrefix);\n      Lines.push_back(DE.emitDag(DI).second + \";\");\n    }\n  }\n\n  assert(!Lines.empty() && \"Empty def?\");\n  if (!RetVar.getType().isVoid())\n    Lines.back().insert(0, RetVar.getName() + \" = \");\n\n  for (auto &L : Lines) {\n    OS << \"  \" << L;\n    emitNewLine();\n  }\n}\n\nvoid Intrinsic::emitReturn() {\n  if (RetVar.getType().isVoid())\n    return;\n  if (UseMacro)\n    OS << \"  \" << RetVar.getName() << \";\";\n  else\n    OS << \"  return \" << RetVar.getName() << \";\";\n  emitNewLine();\n}\n\nstd::pair<Type, std::string> Intrinsic::DagEmitter::emitDag(DagInit *DI) {\n  // At this point we should only be seeing a def.\n  DefInit *DefI = cast<DefInit>(DI->getOperator());\n  std::string Op = DefI->getAsString();\n\n  if (Op == \"cast\" || Op == \"bitcast\")\n    return emitDagCast(DI, Op == \"bitcast\");\n  if (Op == \"shuffle\")\n    return emitDagShuffle(DI);\n  if (Op == \"dup\")\n    return emitDagDup(DI);\n  if (Op == \"dup_typed\")\n    return emitDagDupTyped(DI);\n  if (Op == \"splat\")\n    return emitDagSplat(DI);\n  if (Op == \"save_temp\")\n    return emitDagSaveTemp(DI);\n  if (Op == \"op\")\n    return emitDagOp(DI);\n  if (Op == \"call\" || Op == \"call_mangled\")\n    return emitDagCall(DI, Op == \"call_mangled\");\n  if (Op == \"name_replace\")\n    return emitDagNameReplace(DI);\n  if (Op == \"literal\")\n    return emitDagLiteral(DI);\n  assert_with_loc(false, \"Unknown operation!\");\n  return std::make_pair(Type::getVoid(), \"\");\n}\n\nstd::pair<Type, std::string> Intrinsic::DagEmitter::emitDagOp(DagInit *DI) {\n  std::string Op = cast<StringInit>(DI->getArg(0))->getAsUnquotedString();\n  if (DI->getNumArgs() == 2) {\n    // Unary op.\n    std::pair<Type, std::string> R =\n        emitDagArg(DI->getArg(1), std::string(DI->getArgNameStr(1)));\n    return std::make_pair(R.first, Op + R.second);\n  } else {\n    assert(DI->getNumArgs() == 3 && \"Can only handle unary and binary ops!\");\n    std::pair<Type, std::string> R1 =\n        emitDagArg(DI->getArg(1), std::string(DI->getArgNameStr(1)));\n    std::pair<Type, std::string> R2 =\n        emitDagArg(DI->getArg(2), std::string(DI->getArgNameStr(2)));\n    assert_with_loc(R1.first == R2.first, \"Argument type mismatch!\");\n    return std::make_pair(R1.first, R1.second + \" \" + Op + \" \" + R2.second);\n  }\n}\n\nstd::pair<Type, std::string>\nIntrinsic::DagEmitter::emitDagCall(DagInit *DI, bool MatchMangledName) {\n  std::vector<Type> Types;\n  std::vector<std::string> Values;\n  for (unsigned I = 0; I < DI->getNumArgs() - 1; ++I) {\n    std::pair<Type, std::string> R =\n        emitDagArg(DI->getArg(I + 1), std::string(DI->getArgNameStr(I + 1)));\n    Types.push_back(R.first);\n    Values.push_back(R.second);\n  }\n\n  // Look up the called intrinsic.\n  std::string N;\n  if (StringInit *SI = dyn_cast<StringInit>(DI->getArg(0)))\n    N = SI->getAsUnquotedString();\n  else\n    N = emitDagArg(DI->getArg(0), \"\").second;\n  Optional<std::string> MangledName;\n  if (MatchMangledName) {\n    if (Intr.getRecord()->getValueAsBit(\"isLaneQ\"))\n      N += \"q\";\n    MangledName = Intr.mangleName(N, ClassS);\n  }\n  Intrinsic &Callee = Intr.Emitter.getIntrinsic(N, Types, MangledName);\n\n  // Make sure the callee is known as an early def.\n  Callee.setNeededEarly();\n  Intr.Dependencies.insert(&Callee);\n\n  // Now create the call itself.\n  std::string S = \"\";\n  if (!Callee.isBigEndianSafe())\n    S += CallPrefix.str();\n  S += Callee.getMangledName(true) + \"(\";\n  for (unsigned I = 0; I < DI->getNumArgs() - 1; ++I) {\n    if (I != 0)\n      S += \", \";\n    S += Values[I];\n  }\n  S += \")\";\n\n  return std::make_pair(Callee.getReturnType(), S);\n}\n\nstd::pair<Type, std::string> Intrinsic::DagEmitter::emitDagCast(DagInit *DI,\n                                                                bool IsBitCast){\n  // (cast MOD* VAL) -> cast VAL to type given by MOD.\n  std::pair<Type, std::string> R =\n      emitDagArg(DI->getArg(DI->getNumArgs() - 1),\n                 std::string(DI->getArgNameStr(DI->getNumArgs() - 1)));\n  Type castToType = R.first;\n  for (unsigned ArgIdx = 0; ArgIdx < DI->getNumArgs() - 1; ++ArgIdx) {\n\n    // MOD can take several forms:\n    //   1. $X - take the type of parameter / variable X.\n    //   2. The value \"R\" - take the type of the return type.\n    //   3. a type string\n    //   4. The value \"U\" or \"S\" to switch the signedness.\n    //   5. The value \"H\" or \"D\" to half or double the bitwidth.\n    //   6. The value \"8\" to convert to 8-bit (signed) integer lanes.\n    if (!DI->getArgNameStr(ArgIdx).empty()) {\n      assert_with_loc(Intr.Variables.find(std::string(\n                          DI->getArgNameStr(ArgIdx))) != Intr.Variables.end(),\n                      \"Variable not found\");\n      castToType =\n          Intr.Variables[std::string(DI->getArgNameStr(ArgIdx))].getType();\n    } else {\n      StringInit *SI = dyn_cast<StringInit>(DI->getArg(ArgIdx));\n      assert_with_loc(SI, \"Expected string type or $Name for cast type\");\n\n      if (SI->getAsUnquotedString() == \"R\") {\n        castToType = Intr.getReturnType();\n      } else if (SI->getAsUnquotedString() == \"U\") {\n        castToType.makeUnsigned();\n      } else if (SI->getAsUnquotedString() == \"S\") {\n        castToType.makeSigned();\n      } else if (SI->getAsUnquotedString() == \"H\") {\n        castToType.halveLanes();\n      } else if (SI->getAsUnquotedString() == \"D\") {\n        castToType.doubleLanes();\n      } else if (SI->getAsUnquotedString() == \"8\") {\n        castToType.makeInteger(8, true);\n      } else if (SI->getAsUnquotedString() == \"32\") {\n        castToType.make32BitElement();\n      } else {\n        castToType = Type::fromTypedefName(SI->getAsUnquotedString());\n        assert_with_loc(!castToType.isVoid(), \"Unknown typedef\");\n      }\n    }\n  }\n\n  std::string S;\n  if (IsBitCast) {\n    // Emit a reinterpret cast. The second operand must be an lvalue, so create\n    // a temporary.\n    std::string N = \"reint\";\n    unsigned I = 0;\n    while (Intr.Variables.find(N) != Intr.Variables.end())\n      N = \"reint\" + utostr(++I);\n    Intr.Variables[N] = Variable(R.first, N + Intr.VariablePostfix);\n\n    Intr.OS << R.first.str() << \" \" << Intr.Variables[N].getName() << \" = \"\n            << R.second << \";\";\n    Intr.emitNewLine();\n\n    S = \"*(\" + castToType.str() + \" *) &\" + Intr.Variables[N].getName() + \"\";\n  } else {\n    // Emit a normal (static) cast.\n    S = \"(\" + castToType.str() + \")(\" + R.second + \")\";\n  }\n\n  return std::make_pair(castToType, S);\n}\n\nstd::pair<Type, std::string> Intrinsic::DagEmitter::emitDagShuffle(DagInit *DI){\n  // See the documentation in arm_neon.td for a description of these operators.\n  class LowHalf : public SetTheory::Operator {\n  public:\n    void apply(SetTheory &ST, DagInit *Expr, SetTheory::RecSet &Elts,\n               ArrayRef<SMLoc> Loc) override {\n      SetTheory::RecSet Elts2;\n      ST.evaluate(Expr->arg_begin(), Expr->arg_end(), Elts2, Loc);\n      Elts.insert(Elts2.begin(), Elts2.begin() + (Elts2.size() / 2));\n    }\n  };\n\n  class HighHalf : public SetTheory::Operator {\n  public:\n    void apply(SetTheory &ST, DagInit *Expr, SetTheory::RecSet &Elts,\n               ArrayRef<SMLoc> Loc) override {\n      SetTheory::RecSet Elts2;\n      ST.evaluate(Expr->arg_begin(), Expr->arg_end(), Elts2, Loc);\n      Elts.insert(Elts2.begin() + (Elts2.size() / 2), Elts2.end());\n    }\n  };\n\n  class Rev : public SetTheory::Operator {\n    unsigned ElementSize;\n\n  public:\n    Rev(unsigned ElementSize) : ElementSize(ElementSize) {}\n\n    void apply(SetTheory &ST, DagInit *Expr, SetTheory::RecSet &Elts,\n               ArrayRef<SMLoc> Loc) override {\n      SetTheory::RecSet Elts2;\n      ST.evaluate(Expr->arg_begin() + 1, Expr->arg_end(), Elts2, Loc);\n\n      int64_t VectorSize = cast<IntInit>(Expr->getArg(0))->getValue();\n      VectorSize /= ElementSize;\n\n      std::vector<Record *> Revved;\n      for (unsigned VI = 0; VI < Elts2.size(); VI += VectorSize) {\n        for (int LI = VectorSize - 1; LI >= 0; --LI) {\n          Revved.push_back(Elts2[VI + LI]);\n        }\n      }\n\n      Elts.insert(Revved.begin(), Revved.end());\n    }\n  };\n\n  class MaskExpander : public SetTheory::Expander {\n    unsigned N;\n\n  public:\n    MaskExpander(unsigned N) : N(N) {}\n\n    void expand(SetTheory &ST, Record *R, SetTheory::RecSet &Elts) override {\n      unsigned Addend = 0;\n      if (R->getName() == \"mask0\")\n        Addend = 0;\n      else if (R->getName() == \"mask1\")\n        Addend = N;\n      else\n        return;\n      for (unsigned I = 0; I < N; ++I)\n        Elts.insert(R->getRecords().getDef(\"sv\" + utostr(I + Addend)));\n    }\n  };\n\n  // (shuffle arg1, arg2, sequence)\n  std::pair<Type, std::string> Arg1 =\n      emitDagArg(DI->getArg(0), std::string(DI->getArgNameStr(0)));\n  std::pair<Type, std::string> Arg2 =\n      emitDagArg(DI->getArg(1), std::string(DI->getArgNameStr(1)));\n  assert_with_loc(Arg1.first == Arg2.first,\n                  \"Different types in arguments to shuffle!\");\n\n  SetTheory ST;\n  SetTheory::RecSet Elts;\n  ST.addOperator(\"lowhalf\", std::make_unique<LowHalf>());\n  ST.addOperator(\"highhalf\", std::make_unique<HighHalf>());\n  ST.addOperator(\"rev\",\n                 std::make_unique<Rev>(Arg1.first.getElementSizeInBits()));\n  ST.addExpander(\"MaskExpand\",\n                 std::make_unique<MaskExpander>(Arg1.first.getNumElements()));\n  ST.evaluate(DI->getArg(2), Elts, None);\n\n  std::string S = \"__builtin_shufflevector(\" + Arg1.second + \", \" + Arg2.second;\n  for (auto &E : Elts) {\n    StringRef Name = E->getName();\n    assert_with_loc(Name.startswith(\"sv\"),\n                    \"Incorrect element kind in shuffle mask!\");\n    S += \", \" + Name.drop_front(2).str();\n  }\n  S += \")\";\n\n  // Recalculate the return type - the shuffle may have halved or doubled it.\n  Type T(Arg1.first);\n  if (Elts.size() > T.getNumElements()) {\n    assert_with_loc(\n        Elts.size() == T.getNumElements() * 2,\n        \"Can only double or half the number of elements in a shuffle!\");\n    T.doubleLanes();\n  } else if (Elts.size() < T.getNumElements()) {\n    assert_with_loc(\n        Elts.size() == T.getNumElements() / 2,\n        \"Can only double or half the number of elements in a shuffle!\");\n    T.halveLanes();\n  }\n\n  return std::make_pair(T, S);\n}\n\nstd::pair<Type, std::string> Intrinsic::DagEmitter::emitDagDup(DagInit *DI) {\n  assert_with_loc(DI->getNumArgs() == 1, \"dup() expects one argument\");\n  std::pair<Type, std::string> A =\n      emitDagArg(DI->getArg(0), std::string(DI->getArgNameStr(0)));\n  assert_with_loc(A.first.isScalar(), \"dup() expects a scalar argument\");\n\n  Type T = Intr.getBaseType();\n  assert_with_loc(T.isVector(), \"dup() used but default type is scalar!\");\n  std::string S = \"(\" + T.str() + \") {\";\n  for (unsigned I = 0; I < T.getNumElements(); ++I) {\n    if (I != 0)\n      S += \", \";\n    S += A.second;\n  }\n  S += \"}\";\n\n  return std::make_pair(T, S);\n}\n\nstd::pair<Type, std::string> Intrinsic::DagEmitter::emitDagDupTyped(DagInit *DI) {\n  assert_with_loc(DI->getNumArgs() == 2, \"dup_typed() expects two arguments\");\n  std::pair<Type, std::string> B =\n      emitDagArg(DI->getArg(1), std::string(DI->getArgNameStr(1)));\n  assert_with_loc(B.first.isScalar(),\n                  \"dup_typed() requires a scalar as the second argument\");\n  Type T;\n  // If the type argument is a constant string, construct the type directly.\n  if (StringInit *SI = dyn_cast<StringInit>(DI->getArg(0))) {\n    T = Type::fromTypedefName(SI->getAsUnquotedString());\n    assert_with_loc(!T.isVoid(), \"Unknown typedef\");\n  } else\n    T = emitDagArg(DI->getArg(0), std::string(DI->getArgNameStr(0))).first;\n\n  assert_with_loc(T.isVector(), \"dup_typed() used but target type is scalar!\");\n  std::string S = \"(\" + T.str() + \") {\";\n  for (unsigned I = 0; I < T.getNumElements(); ++I) {\n    if (I != 0)\n      S += \", \";\n    S += B.second;\n  }\n  S += \"}\";\n\n  return std::make_pair(T, S);\n}\n\nstd::pair<Type, std::string> Intrinsic::DagEmitter::emitDagSplat(DagInit *DI) {\n  assert_with_loc(DI->getNumArgs() == 2, \"splat() expects two arguments\");\n  std::pair<Type, std::string> A =\n      emitDagArg(DI->getArg(0), std::string(DI->getArgNameStr(0)));\n  std::pair<Type, std::string> B =\n      emitDagArg(DI->getArg(1), std::string(DI->getArgNameStr(1)));\n\n  assert_with_loc(B.first.isScalar(),\n                  \"splat() requires a scalar int as the second argument\");\n\n  std::string S = \"__builtin_shufflevector(\" + A.second + \", \" + A.second;\n  for (unsigned I = 0; I < Intr.getBaseType().getNumElements(); ++I) {\n    S += \", \" + B.second;\n  }\n  S += \")\";\n\n  return std::make_pair(Intr.getBaseType(), S);\n}\n\nstd::pair<Type, std::string> Intrinsic::DagEmitter::emitDagSaveTemp(DagInit *DI) {\n  assert_with_loc(DI->getNumArgs() == 2, \"save_temp() expects two arguments\");\n  std::pair<Type, std::string> A =\n      emitDagArg(DI->getArg(1), std::string(DI->getArgNameStr(1)));\n\n  assert_with_loc(!A.first.isVoid(),\n                  \"Argument to save_temp() must have non-void type!\");\n\n  std::string N = std::string(DI->getArgNameStr(0));\n  assert_with_loc(!N.empty(),\n                  \"save_temp() expects a name as the first argument\");\n\n  assert_with_loc(Intr.Variables.find(N) == Intr.Variables.end(),\n                  \"Variable already defined!\");\n  Intr.Variables[N] = Variable(A.first, N + Intr.VariablePostfix);\n\n  std::string S =\n      A.first.str() + \" \" + Intr.Variables[N].getName() + \" = \" + A.second;\n\n  return std::make_pair(Type::getVoid(), S);\n}\n\nstd::pair<Type, std::string>\nIntrinsic::DagEmitter::emitDagNameReplace(DagInit *DI) {\n  std::string S = Intr.Name;\n\n  assert_with_loc(DI->getNumArgs() == 2, \"name_replace requires 2 arguments!\");\n  std::string ToReplace = cast<StringInit>(DI->getArg(0))->getAsUnquotedString();\n  std::string ReplaceWith = cast<StringInit>(DI->getArg(1))->getAsUnquotedString();\n\n  size_t Idx = S.find(ToReplace);\n\n  assert_with_loc(Idx != std::string::npos, \"name should contain '\" + ToReplace + \"'!\");\n  S.replace(Idx, ToReplace.size(), ReplaceWith);\n\n  return std::make_pair(Type::getVoid(), S);\n}\n\nstd::pair<Type, std::string> Intrinsic::DagEmitter::emitDagLiteral(DagInit *DI){\n  std::string Ty = cast<StringInit>(DI->getArg(0))->getAsUnquotedString();\n  std::string Value = cast<StringInit>(DI->getArg(1))->getAsUnquotedString();\n  return std::make_pair(Type::fromTypedefName(Ty), Value);\n}\n\nstd::pair<Type, std::string>\nIntrinsic::DagEmitter::emitDagArg(Init *Arg, std::string ArgName) {\n  if (!ArgName.empty()) {\n    assert_with_loc(!Arg->isComplete(),\n                    \"Arguments must either be DAGs or names, not both!\");\n    assert_with_loc(Intr.Variables.find(ArgName) != Intr.Variables.end(),\n                    \"Variable not defined!\");\n    Variable &V = Intr.Variables[ArgName];\n    return std::make_pair(V.getType(), V.getName());\n  }\n\n  assert(Arg && \"Neither ArgName nor Arg?!\");\n  DagInit *DI = dyn_cast<DagInit>(Arg);\n  assert_with_loc(DI, \"Arguments must either be DAGs or names!\");\n\n  return emitDag(DI);\n}\n\nstd::string Intrinsic::generate() {\n  // Avoid duplicated code for big and little endian\n  if (isBigEndianSafe()) {\n    generateImpl(false, \"\", \"\");\n    return OS.str();\n  }\n  // Little endian intrinsics are simple and don't require any argument\n  // swapping.\n  OS << \"#ifdef __LITTLE_ENDIAN__\\n\";\n\n  generateImpl(false, \"\", \"\");\n\n  OS << \"#else\\n\";\n\n  // Big endian intrinsics are more complex. The user intended these\n  // intrinsics to operate on a vector \"as-if\" loaded by (V)LDR,\n  // but we load as-if (V)LD1. So we should swap all arguments and\n  // swap the return value too.\n  //\n  // If we call sub-intrinsics, we should call a version that does\n  // not re-swap the arguments!\n  generateImpl(true, \"\", \"__noswap_\");\n\n  // If we're needed early, create a non-swapping variant for\n  // big-endian.\n  if (NeededEarly) {\n    generateImpl(false, \"__noswap_\", \"__noswap_\");\n  }\n  OS << \"#endif\\n\\n\";\n\n  return OS.str();\n}\n\nvoid Intrinsic::generateImpl(bool ReverseArguments,\n                             StringRef NamePrefix, StringRef CallPrefix) {\n  CurrentRecord = R;\n\n  // If we call a macro, our local variables may be corrupted due to\n  // lack of proper lexical scoping. So, add a globally unique postfix\n  // to every variable.\n  //\n  // indexBody() should have set up the Dependencies set by now.\n  for (auto *I : Dependencies)\n    if (I->UseMacro) {\n      VariablePostfix = \"_\" + utostr(Emitter.getUniqueNumber());\n      break;\n    }\n\n  initVariables();\n\n  emitPrototype(NamePrefix);\n\n  if (IsUnavailable) {\n    OS << \" __attribute__((unavailable));\";\n  } else {\n    emitOpeningBrace();\n    emitShadowedArgs();\n    if (ReverseArguments)\n      emitArgumentReversal();\n    emitBody(CallPrefix);\n    if (ReverseArguments)\n      emitReturnReversal();\n    emitReturn();\n    emitClosingBrace();\n  }\n  OS << \"\\n\";\n\n  CurrentRecord = nullptr;\n}\n\nvoid Intrinsic::indexBody() {\n  CurrentRecord = R;\n\n  initVariables();\n  emitBody(\"\");\n  OS.str(\"\");\n\n  CurrentRecord = nullptr;\n}\n\n//===----------------------------------------------------------------------===//\n// NeonEmitter implementation\n//===----------------------------------------------------------------------===//\n\nIntrinsic &NeonEmitter::getIntrinsic(StringRef Name, ArrayRef<Type> Types,\n                                     Optional<std::string> MangledName) {\n  // First, look up the name in the intrinsic map.\n  assert_with_loc(IntrinsicMap.find(Name.str()) != IntrinsicMap.end(),\n                  (\"Intrinsic '\" + Name + \"' not found!\").str());\n  auto &V = IntrinsicMap.find(Name.str())->second;\n  std::vector<Intrinsic *> GoodVec;\n\n  // Create a string to print if we end up failing.\n  std::string ErrMsg = \"looking up intrinsic '\" + Name.str() + \"(\";\n  for (unsigned I = 0; I < Types.size(); ++I) {\n    if (I != 0)\n      ErrMsg += \", \";\n    ErrMsg += Types[I].str();\n  }\n  ErrMsg += \")'\\n\";\n  ErrMsg += \"Available overloads:\\n\";\n\n  // Now, look through each intrinsic implementation and see if the types are\n  // compatible.\n  for (auto &I : V) {\n    ErrMsg += \"  - \" + I.getReturnType().str() + \" \" + I.getMangledName();\n    ErrMsg += \"(\";\n    for (unsigned A = 0; A < I.getNumParams(); ++A) {\n      if (A != 0)\n        ErrMsg += \", \";\n      ErrMsg += I.getParamType(A).str();\n    }\n    ErrMsg += \")\\n\";\n\n    if (MangledName && MangledName != I.getMangledName(true))\n      continue;\n\n    if (I.getNumParams() != Types.size())\n      continue;\n\n    unsigned ArgNum = 0;\n    bool MatchingArgumentTypes =\n        std::all_of(Types.begin(), Types.end(), [&](const auto &Type) {\n          return Type == I.getParamType(ArgNum++);\n        });\n\n    if (MatchingArgumentTypes)\n      GoodVec.push_back(&I);\n  }\n\n  assert_with_loc(!GoodVec.empty(),\n                  \"No compatible intrinsic found - \" + ErrMsg);\n  assert_with_loc(GoodVec.size() == 1, \"Multiple overloads found - \" + ErrMsg);\n\n  return *GoodVec.front();\n}\n\nvoid NeonEmitter::createIntrinsic(Record *R,\n                                  SmallVectorImpl<Intrinsic *> &Out) {\n  std::string Name = std::string(R->getValueAsString(\"Name\"));\n  std::string Proto = std::string(R->getValueAsString(\"Prototype\"));\n  std::string Types = std::string(R->getValueAsString(\"Types\"));\n  Record *OperationRec = R->getValueAsDef(\"Operation\");\n  bool BigEndianSafe  = R->getValueAsBit(\"BigEndianSafe\");\n  std::string Guard = std::string(R->getValueAsString(\"ArchGuard\"));\n  bool IsUnavailable = OperationRec->getValueAsBit(\"Unavailable\");\n  std::string CartesianProductWith = std::string(R->getValueAsString(\"CartesianProductWith\"));\n\n  // Set the global current record. This allows assert_with_loc to produce\n  // decent location information even when highly nested.\n  CurrentRecord = R;\n\n  ListInit *Body = OperationRec->getValueAsListInit(\"Ops\");\n\n  std::vector<TypeSpec> TypeSpecs = TypeSpec::fromTypeSpecs(Types);\n\n  ClassKind CK = ClassNone;\n  if (R->getSuperClasses().size() >= 2)\n    CK = ClassMap[R->getSuperClasses()[1].first];\n\n  std::vector<std::pair<TypeSpec, TypeSpec>> NewTypeSpecs;\n  if (!CartesianProductWith.empty()) {\n    std::vector<TypeSpec> ProductTypeSpecs = TypeSpec::fromTypeSpecs(CartesianProductWith);\n    for (auto TS : TypeSpecs) {\n      Type DefaultT(TS, \".\");\n      for (auto SrcTS : ProductTypeSpecs) {\n        Type DefaultSrcT(SrcTS, \".\");\n        if (TS == SrcTS ||\n            DefaultSrcT.getSizeInBits() != DefaultT.getSizeInBits())\n          continue;\n        NewTypeSpecs.push_back(std::make_pair(TS, SrcTS));\n      }\n    }\n  } else {\n    for (auto TS : TypeSpecs) {\n      NewTypeSpecs.push_back(std::make_pair(TS, TS));\n    }\n  }\n\n  llvm::sort(NewTypeSpecs);\n  NewTypeSpecs.erase(std::unique(NewTypeSpecs.begin(), NewTypeSpecs.end()),\n\t\t     NewTypeSpecs.end());\n  auto &Entry = IntrinsicMap[Name];\n\n  for (auto &I : NewTypeSpecs) {\n    Entry.emplace_back(R, Name, Proto, I.first, I.second, CK, Body, *this,\n                       Guard, IsUnavailable, BigEndianSafe);\n    Out.push_back(&Entry.back());\n  }\n\n  CurrentRecord = nullptr;\n}\n\n/// genBuiltinsDef: Generate the BuiltinsARM.def and  BuiltinsAArch64.def\n/// declaration of builtins, checking for unique builtin declarations.\nvoid NeonEmitter::genBuiltinsDef(raw_ostream &OS,\n                                 SmallVectorImpl<Intrinsic *> &Defs) {\n  OS << \"#ifdef GET_NEON_BUILTINS\\n\";\n\n  // We only want to emit a builtin once, and we want to emit them in\n  // alphabetical order, so use a std::set.\n  std::set<std::string> Builtins;\n\n  for (auto *Def : Defs) {\n    if (Def->hasBody())\n      continue;\n\n    std::string S = \"BUILTIN(__builtin_neon_\" + Def->getMangledName() + \", \\\"\";\n\n    S += Def->getBuiltinTypeStr();\n    S += \"\\\", \\\"n\\\")\";\n\n    Builtins.insert(S);\n  }\n\n  for (auto &S : Builtins)\n    OS << S << \"\\n\";\n  OS << \"#endif\\n\\n\";\n}\n\n/// Generate the ARM and AArch64 overloaded type checking code for\n/// SemaChecking.cpp, checking for unique builtin declarations.\nvoid NeonEmitter::genOverloadTypeCheckCode(raw_ostream &OS,\n                                           SmallVectorImpl<Intrinsic *> &Defs) {\n  OS << \"#ifdef GET_NEON_OVERLOAD_CHECK\\n\";\n\n  // We record each overload check line before emitting because subsequent Inst\n  // definitions may extend the number of permitted types (i.e. augment the\n  // Mask). Use std::map to avoid sorting the table by hash number.\n  struct OverloadInfo {\n    uint64_t Mask;\n    int PtrArgNum;\n    bool HasConstPtr;\n    OverloadInfo() : Mask(0ULL), PtrArgNum(0), HasConstPtr(false) {}\n  };\n  std::map<std::string, OverloadInfo> OverloadMap;\n\n  for (auto *Def : Defs) {\n    // If the def has a body (that is, it has Operation DAGs), it won't call\n    // __builtin_neon_* so we don't need to generate a definition for it.\n    if (Def->hasBody())\n      continue;\n    // Functions which have a scalar argument cannot be overloaded, no need to\n    // check them if we are emitting the type checking code.\n    if (Def->protoHasScalar())\n      continue;\n\n    uint64_t Mask = 0ULL;\n    Mask |= 1ULL << Def->getPolymorphicKeyType().getNeonEnum();\n\n    // Check if the function has a pointer or const pointer argument.\n    int PtrArgNum = -1;\n    bool HasConstPtr = false;\n    for (unsigned I = 0; I < Def->getNumParams(); ++I) {\n      const auto &Type = Def->getParamType(I);\n      if (Type.isPointer()) {\n        PtrArgNum = I;\n        HasConstPtr = Type.isConstPointer();\n      }\n    }\n\n    // For sret builtins, adjust the pointer argument index.\n    if (PtrArgNum >= 0 && Def->getReturnType().getNumVectors() > 1)\n      PtrArgNum += 1;\n\n    std::string Name = Def->getName();\n    // Omit type checking for the pointer arguments of vld1_lane, vld1_dup,\n    // and vst1_lane intrinsics.  Using a pointer to the vector element\n    // type with one of those operations causes codegen to select an aligned\n    // load/store instruction.  If you want an unaligned operation,\n    // the pointer argument needs to have less alignment than element type,\n    // so just accept any pointer type.\n    if (Name == \"vld1_lane\" || Name == \"vld1_dup\" || Name == \"vst1_lane\") {\n      PtrArgNum = -1;\n      HasConstPtr = false;\n    }\n\n    if (Mask) {\n      std::string Name = Def->getMangledName();\n      OverloadMap.insert(std::make_pair(Name, OverloadInfo()));\n      OverloadInfo &OI = OverloadMap[Name];\n      OI.Mask |= Mask;\n      OI.PtrArgNum |= PtrArgNum;\n      OI.HasConstPtr = HasConstPtr;\n    }\n  }\n\n  for (auto &I : OverloadMap) {\n    OverloadInfo &OI = I.second;\n\n    OS << \"case NEON::BI__builtin_neon_\" << I.first << \": \";\n    OS << \"mask = 0x\" << Twine::utohexstr(OI.Mask) << \"ULL\";\n    if (OI.PtrArgNum >= 0)\n      OS << \"; PtrArgNum = \" << OI.PtrArgNum;\n    if (OI.HasConstPtr)\n      OS << \"; HasConstPtr = true\";\n    OS << \"; break;\\n\";\n  }\n  OS << \"#endif\\n\\n\";\n}\n\nvoid NeonEmitter::genIntrinsicRangeCheckCode(raw_ostream &OS,\n                                        SmallVectorImpl<Intrinsic *> &Defs) {\n  OS << \"#ifdef GET_NEON_IMMEDIATE_CHECK\\n\";\n\n  std::set<std::string> Emitted;\n\n  for (auto *Def : Defs) {\n    if (Def->hasBody())\n      continue;\n    // Functions which do not have an immediate do not need to have range\n    // checking code emitted.\n    if (!Def->hasImmediate())\n      continue;\n    if (Emitted.find(Def->getMangledName()) != Emitted.end())\n      continue;\n\n    std::string LowerBound, UpperBound;\n\n    Record *R = Def->getRecord();\n    if (R->getValueAsBit(\"isVXAR\")) {\n      //VXAR takes an immediate in the range [0, 63]\n      LowerBound = \"0\";\n      UpperBound = \"63\";\n    } else if (R->getValueAsBit(\"isVCVT_N\")) {\n      // VCVT between floating- and fixed-point values takes an immediate\n      // in the range [1, 32) for f32 or [1, 64) for f64 or [1, 16) for f16.\n      LowerBound = \"1\";\n\t  if (Def->getBaseType().getElementSizeInBits() == 16 ||\n\t\t  Def->getName().find('h') != std::string::npos)\n\t\t// VCVTh operating on FP16 intrinsics in range [1, 16)\n\t\tUpperBound = \"15\";\n\t  else if (Def->getBaseType().getElementSizeInBits() == 32)\n        UpperBound = \"31\";\n\t  else\n        UpperBound = \"63\";\n    } else if (R->getValueAsBit(\"isScalarShift\")) {\n      // Right shifts have an 'r' in the name, left shifts do not. Convert\n      // instructions have the same bounds and right shifts.\n      if (Def->getName().find('r') != std::string::npos ||\n          Def->getName().find(\"cvt\") != std::string::npos)\n        LowerBound = \"1\";\n\n      UpperBound = utostr(Def->getReturnType().getElementSizeInBits() - 1);\n    } else if (R->getValueAsBit(\"isShift\")) {\n      // Builtins which are overloaded by type will need to have their upper\n      // bound computed at Sema time based on the type constant.\n\n      // Right shifts have an 'r' in the name, left shifts do not.\n      if (Def->getName().find('r') != std::string::npos)\n        LowerBound = \"1\";\n      UpperBound = \"RFT(TV, true)\";\n    } else if (Def->getClassKind(true) == ClassB) {\n      // ClassB intrinsics have a type (and hence lane number) that is only\n      // known at runtime.\n      if (R->getValueAsBit(\"isLaneQ\"))\n        UpperBound = \"RFT(TV, false, true)\";\n      else\n        UpperBound = \"RFT(TV, false, false)\";\n    } else {\n      // The immediate generally refers to a lane in the preceding argument.\n      assert(Def->getImmediateIdx() > 0);\n      Type T = Def->getParamType(Def->getImmediateIdx() - 1);\n      UpperBound = utostr(T.getNumElements() - 1);\n    }\n\n    // Calculate the index of the immediate that should be range checked.\n    unsigned Idx = Def->getNumParams();\n    if (Def->hasImmediate())\n      Idx = Def->getGeneratedParamIdx(Def->getImmediateIdx());\n\n    OS << \"case NEON::BI__builtin_neon_\" << Def->getMangledName() << \": \"\n       << \"i = \" << Idx << \";\";\n    if (!LowerBound.empty())\n      OS << \" l = \" << LowerBound << \";\";\n    if (!UpperBound.empty())\n      OS << \" u = \" << UpperBound << \";\";\n    OS << \" break;\\n\";\n\n    Emitted.insert(Def->getMangledName());\n  }\n\n  OS << \"#endif\\n\\n\";\n}\n\n/// runHeader - Emit a file with sections defining:\n/// 1. the NEON section of BuiltinsARM.def and BuiltinsAArch64.def.\n/// 2. the SemaChecking code for the type overload checking.\n/// 3. the SemaChecking code for validation of intrinsic immediate arguments.\nvoid NeonEmitter::runHeader(raw_ostream &OS) {\n  std::vector<Record *> RV = Records.getAllDerivedDefinitions(\"Inst\");\n\n  SmallVector<Intrinsic *, 128> Defs;\n  for (auto *R : RV)\n    createIntrinsic(R, Defs);\n\n  // Generate shared BuiltinsXXX.def\n  genBuiltinsDef(OS, Defs);\n\n  // Generate ARM overloaded type checking code for SemaChecking.cpp\n  genOverloadTypeCheckCode(OS, Defs);\n\n  // Generate ARM range checking code for shift/lane immediates.\n  genIntrinsicRangeCheckCode(OS, Defs);\n}\n\nstatic void emitNeonTypeDefs(const std::string& types, raw_ostream &OS) {\n  std::string TypedefTypes(types);\n  std::vector<TypeSpec> TDTypeVec = TypeSpec::fromTypeSpecs(TypedefTypes);\n\n  // Emit vector typedefs.\n  bool InIfdef = false;\n  for (auto &TS : TDTypeVec) {\n    bool IsA64 = false;\n    Type T(TS, \".\");\n    if (T.isDouble())\n      IsA64 = true;\n\n    if (InIfdef && !IsA64) {\n      OS << \"#endif\\n\";\n      InIfdef = false;\n    }\n    if (!InIfdef && IsA64) {\n      OS << \"#ifdef __aarch64__\\n\";\n      InIfdef = true;\n    }\n\n    if (T.isPoly())\n      OS << \"typedef __attribute__((neon_polyvector_type(\";\n    else\n      OS << \"typedef __attribute__((neon_vector_type(\";\n\n    Type T2 = T;\n    T2.makeScalar();\n    OS << T.getNumElements() << \"))) \";\n    OS << T2.str();\n    OS << \" \" << T.str() << \";\\n\";\n  }\n  if (InIfdef)\n    OS << \"#endif\\n\";\n  OS << \"\\n\";\n\n  // Emit struct typedefs.\n  InIfdef = false;\n  for (unsigned NumMembers = 2; NumMembers <= 4; ++NumMembers) {\n    for (auto &TS : TDTypeVec) {\n      bool IsA64 = false;\n      Type T(TS, \".\");\n      if (T.isDouble())\n        IsA64 = true;\n\n      if (InIfdef && !IsA64) {\n        OS << \"#endif\\n\";\n        InIfdef = false;\n      }\n      if (!InIfdef && IsA64) {\n        OS << \"#ifdef __aarch64__\\n\";\n        InIfdef = true;\n      }\n\n      const char Mods[] = { static_cast<char>('2' + (NumMembers - 2)), 0};\n      Type VT(TS, Mods);\n      OS << \"typedef struct \" << VT.str() << \" {\\n\";\n      OS << \"  \" << T.str() << \" val\";\n      OS << \"[\" << NumMembers << \"]\";\n      OS << \";\\n} \";\n      OS << VT.str() << \";\\n\";\n      OS << \"\\n\";\n    }\n  }\n  if (InIfdef)\n    OS << \"#endif\\n\";\n}\n\n/// run - Read the records in arm_neon.td and output arm_neon.h.  arm_neon.h\n/// is comprised of type definitions and function declarations.\nvoid NeonEmitter::run(raw_ostream &OS) {\n  OS << \"/*===---- arm_neon.h - ARM Neon intrinsics \"\n        \"------------------------------\"\n        \"---===\\n\"\n        \" *\\n\"\n        \" * Permission is hereby granted, free of charge, to any person \"\n        \"obtaining \"\n        \"a copy\\n\"\n        \" * of this software and associated documentation files (the \"\n        \"\\\"Software\\\"),\"\n        \" to deal\\n\"\n        \" * in the Software without restriction, including without limitation \"\n        \"the \"\n        \"rights\\n\"\n        \" * to use, copy, modify, merge, publish, distribute, sublicense, \"\n        \"and/or sell\\n\"\n        \" * copies of the Software, and to permit persons to whom the Software \"\n        \"is\\n\"\n        \" * furnished to do so, subject to the following conditions:\\n\"\n        \" *\\n\"\n        \" * The above copyright notice and this permission notice shall be \"\n        \"included in\\n\"\n        \" * all copies or substantial portions of the Software.\\n\"\n        \" *\\n\"\n        \" * THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, \"\n        \"EXPRESS OR\\n\"\n        \" * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF \"\n        \"MERCHANTABILITY,\\n\"\n        \" * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT \"\n        \"SHALL THE\\n\"\n        \" * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR \"\n        \"OTHER\\n\"\n        \" * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, \"\n        \"ARISING FROM,\\n\"\n        \" * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \"\n        \"DEALINGS IN\\n\"\n        \" * THE SOFTWARE.\\n\"\n        \" *\\n\"\n        \" *===-----------------------------------------------------------------\"\n        \"---\"\n        \"---===\\n\"\n        \" */\\n\\n\";\n\n  OS << \"#ifndef __ARM_NEON_H\\n\";\n  OS << \"#define __ARM_NEON_H\\n\\n\";\n\n  OS << \"#ifndef __ARM_FP\\n\";\n  OS << \"#error \\\"NEON intrinsics not available with the soft-float ABI. \"\n        \"Please use -mfloat-abi=softfp or -mfloat-abi=hard\\\"\\n\";\n  OS << \"#else\\n\\n\";\n\n  OS << \"#if !defined(__ARM_NEON)\\n\";\n  OS << \"#error \\\"NEON support not enabled\\\"\\n\";\n  OS << \"#else\\n\\n\";\n\n  OS << \"#include <stdint.h>\\n\\n\";\n\n  OS << \"#ifdef __ARM_FEATURE_BF16\\n\";\n  OS << \"#include <arm_bf16.h>\\n\";\n  OS << \"typedef __bf16 bfloat16_t;\\n\";\n  OS << \"#endif\\n\\n\";\n\n  // Emit NEON-specific scalar typedefs.\n  OS << \"typedef float float32_t;\\n\";\n  OS << \"typedef __fp16 float16_t;\\n\";\n\n  OS << \"#ifdef __aarch64__\\n\";\n  OS << \"typedef double float64_t;\\n\";\n  OS << \"#endif\\n\\n\";\n\n  // For now, signedness of polynomial types depends on target\n  OS << \"#ifdef __aarch64__\\n\";\n  OS << \"typedef uint8_t poly8_t;\\n\";\n  OS << \"typedef uint16_t poly16_t;\\n\";\n  OS << \"typedef uint64_t poly64_t;\\n\";\n  OS << \"typedef __uint128_t poly128_t;\\n\";\n  OS << \"#else\\n\";\n  OS << \"typedef int8_t poly8_t;\\n\";\n  OS << \"typedef int16_t poly16_t;\\n\";\n  OS << \"typedef int64_t poly64_t;\\n\";\n  OS << \"#endif\\n\";\n\n  emitNeonTypeDefs(\"cQcsQsiQilQlUcQUcUsQUsUiQUiUlQUlhQhfQfdQdPcQPcPsQPsPlQPl\", OS);\n\n  OS << \"#ifdef __ARM_FEATURE_BF16\\n\";\n  emitNeonTypeDefs(\"bQb\", OS);\n  OS << \"#endif\\n\\n\";\n\n  OS << \"#define __ai static __inline__ __attribute__((__always_inline__, \"\n        \"__nodebug__))\\n\\n\";\n\n  SmallVector<Intrinsic *, 128> Defs;\n  std::vector<Record *> RV = Records.getAllDerivedDefinitions(\"Inst\");\n  for (auto *R : RV)\n    createIntrinsic(R, Defs);\n\n  for (auto *I : Defs)\n    I->indexBody();\n\n  llvm::stable_sort(Defs, llvm::deref<std::less<>>());\n\n  // Only emit a def when its requirements have been met.\n  // FIXME: This loop could be made faster, but it's fast enough for now.\n  bool MadeProgress = true;\n  std::string InGuard;\n  while (!Defs.empty() && MadeProgress) {\n    MadeProgress = false;\n\n    for (SmallVector<Intrinsic *, 128>::iterator I = Defs.begin();\n         I != Defs.end(); /*No step*/) {\n      bool DependenciesSatisfied = true;\n      for (auto *II : (*I)->getDependencies()) {\n        if (llvm::is_contained(Defs, II))\n          DependenciesSatisfied = false;\n      }\n      if (!DependenciesSatisfied) {\n        // Try the next one.\n        ++I;\n        continue;\n      }\n\n      // Emit #endif/#if pair if needed.\n      if ((*I)->getGuard() != InGuard) {\n        if (!InGuard.empty())\n          OS << \"#endif\\n\";\n        InGuard = (*I)->getGuard();\n        if (!InGuard.empty())\n          OS << \"#if \" << InGuard << \"\\n\";\n      }\n\n      // Actually generate the intrinsic code.\n      OS << (*I)->generate();\n\n      MadeProgress = true;\n      I = Defs.erase(I);\n    }\n  }\n  assert(Defs.empty() && \"Some requirements were not satisfied!\");\n  if (!InGuard.empty())\n    OS << \"#endif\\n\";\n\n  OS << \"\\n\";\n  OS << \"#undef __ai\\n\\n\";\n  OS << \"#endif /* if !defined(__ARM_NEON) */\\n\";\n  OS << \"#endif /* ifndef __ARM_FP */\\n\";\n  OS << \"#endif /* __ARM_NEON_H */\\n\";\n}\n\n/// run - Read the records in arm_fp16.td and output arm_fp16.h.  arm_fp16.h\n/// is comprised of type definitions and function declarations.\nvoid NeonEmitter::runFP16(raw_ostream &OS) {\n  OS << \"/*===---- arm_fp16.h - ARM FP16 intrinsics \"\n        \"------------------------------\"\n        \"---===\\n\"\n        \" *\\n\"\n        \" * Permission is hereby granted, free of charge, to any person \"\n        \"obtaining a copy\\n\"\n        \" * of this software and associated documentation files (the \"\n\t\t\t\t\"\\\"Software\\\"), to deal\\n\"\n        \" * in the Software without restriction, including without limitation \"\n\t\t\t\t\"the rights\\n\"\n        \" * to use, copy, modify, merge, publish, distribute, sublicense, \"\n\t\t\t\t\"and/or sell\\n\"\n        \" * copies of the Software, and to permit persons to whom the Software \"\n\t\t\t\t\"is\\n\"\n        \" * furnished to do so, subject to the following conditions:\\n\"\n        \" *\\n\"\n        \" * The above copyright notice and this permission notice shall be \"\n        \"included in\\n\"\n        \" * all copies or substantial portions of the Software.\\n\"\n        \" *\\n\"\n        \" * THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, \"\n        \"EXPRESS OR\\n\"\n        \" * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF \"\n        \"MERCHANTABILITY,\\n\"\n        \" * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT \"\n        \"SHALL THE\\n\"\n        \" * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR \"\n        \"OTHER\\n\"\n        \" * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, \"\n        \"ARISING FROM,\\n\"\n        \" * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \"\n        \"DEALINGS IN\\n\"\n        \" * THE SOFTWARE.\\n\"\n        \" *\\n\"\n        \" *===-----------------------------------------------------------------\"\n        \"---\"\n        \"---===\\n\"\n        \" */\\n\\n\";\n\n  OS << \"#ifndef __ARM_FP16_H\\n\";\n  OS << \"#define __ARM_FP16_H\\n\\n\";\n\n  OS << \"#include <stdint.h>\\n\\n\";\n\n  OS << \"typedef __fp16 float16_t;\\n\";\n\n  OS << \"#define __ai static __inline__ __attribute__((__always_inline__, \"\n        \"__nodebug__))\\n\\n\";\n\n  SmallVector<Intrinsic *, 128> Defs;\n  std::vector<Record *> RV = Records.getAllDerivedDefinitions(\"Inst\");\n  for (auto *R : RV)\n    createIntrinsic(R, Defs);\n\n  for (auto *I : Defs)\n    I->indexBody();\n\n  llvm::stable_sort(Defs, llvm::deref<std::less<>>());\n\n  // Only emit a def when its requirements have been met.\n  // FIXME: This loop could be made faster, but it's fast enough for now.\n  bool MadeProgress = true;\n  std::string InGuard;\n  while (!Defs.empty() && MadeProgress) {\n    MadeProgress = false;\n\n    for (SmallVector<Intrinsic *, 128>::iterator I = Defs.begin();\n         I != Defs.end(); /*No step*/) {\n      bool DependenciesSatisfied = true;\n      for (auto *II : (*I)->getDependencies()) {\n        if (llvm::is_contained(Defs, II))\n          DependenciesSatisfied = false;\n      }\n      if (!DependenciesSatisfied) {\n        // Try the next one.\n        ++I;\n        continue;\n      }\n\n      // Emit #endif/#if pair if needed.\n      if ((*I)->getGuard() != InGuard) {\n        if (!InGuard.empty())\n          OS << \"#endif\\n\";\n        InGuard = (*I)->getGuard();\n        if (!InGuard.empty())\n          OS << \"#if \" << InGuard << \"\\n\";\n      }\n\n      // Actually generate the intrinsic code.\n      OS << (*I)->generate();\n\n      MadeProgress = true;\n      I = Defs.erase(I);\n    }\n  }\n  assert(Defs.empty() && \"Some requirements were not satisfied!\");\n  if (!InGuard.empty())\n    OS << \"#endif\\n\";\n\n  OS << \"\\n\";\n  OS << \"#undef __ai\\n\\n\";\n  OS << \"#endif /* __ARM_FP16_H */\\n\";\n}\n\nvoid NeonEmitter::runBF16(raw_ostream &OS) {\n  OS << \"/*===---- arm_bf16.h - ARM BF16 intrinsics \"\n        \"-----------------------------------===\\n\"\n        \" *\\n\"\n        \" *\\n\"\n        \" * Part of the LLVM Project, under the Apache License v2.0 with LLVM \"\n        \"Exceptions.\\n\"\n        \" * See https://llvm.org/LICENSE.txt for license information.\\n\"\n        \" * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\\n\"\n        \" *\\n\"\n        \" *===-----------------------------------------------------------------\"\n        \"------===\\n\"\n        \" */\\n\\n\";\n\n  OS << \"#ifndef __ARM_BF16_H\\n\";\n  OS << \"#define __ARM_BF16_H\\n\\n\";\n\n  OS << \"typedef __bf16 bfloat16_t;\\n\";\n\n  OS << \"#define __ai static __inline__ __attribute__((__always_inline__, \"\n        \"__nodebug__))\\n\\n\";\n\n  SmallVector<Intrinsic *, 128> Defs;\n  std::vector<Record *> RV = Records.getAllDerivedDefinitions(\"Inst\");\n  for (auto *R : RV)\n    createIntrinsic(R, Defs);\n\n  for (auto *I : Defs)\n    I->indexBody();\n\n  llvm::stable_sort(Defs, llvm::deref<std::less<>>());\n\n  // Only emit a def when its requirements have been met.\n  // FIXME: This loop could be made faster, but it's fast enough for now.\n  bool MadeProgress = true;\n  std::string InGuard;\n  while (!Defs.empty() && MadeProgress) {\n    MadeProgress = false;\n\n    for (SmallVector<Intrinsic *, 128>::iterator I = Defs.begin();\n         I != Defs.end(); /*No step*/) {\n      bool DependenciesSatisfied = true;\n      for (auto *II : (*I)->getDependencies()) {\n        if (llvm::is_contained(Defs, II))\n          DependenciesSatisfied = false;\n      }\n      if (!DependenciesSatisfied) {\n        // Try the next one.\n        ++I;\n        continue;\n      }\n\n      // Emit #endif/#if pair if needed.\n      if ((*I)->getGuard() != InGuard) {\n        if (!InGuard.empty())\n          OS << \"#endif\\n\";\n        InGuard = (*I)->getGuard();\n        if (!InGuard.empty())\n          OS << \"#if \" << InGuard << \"\\n\";\n      }\n\n      // Actually generate the intrinsic code.\n      OS << (*I)->generate();\n\n      MadeProgress = true;\n      I = Defs.erase(I);\n    }\n  }\n  assert(Defs.empty() && \"Some requirements were not satisfied!\");\n  if (!InGuard.empty())\n    OS << \"#endif\\n\";\n\n  OS << \"\\n\";\n  OS << \"#undef __ai\\n\\n\";\n\n  OS << \"#endif\\n\";\n}\n\nvoid clang::EmitNeon(RecordKeeper &Records, raw_ostream &OS) {\n  NeonEmitter(Records).run(OS);\n}\n\nvoid clang::EmitFP16(RecordKeeper &Records, raw_ostream &OS) {\n  NeonEmitter(Records).runFP16(OS);\n}\n\nvoid clang::EmitBF16(RecordKeeper &Records, raw_ostream &OS) {\n  NeonEmitter(Records).runBF16(OS);\n}\n\nvoid clang::EmitNeonSema(RecordKeeper &Records, raw_ostream &OS) {\n  NeonEmitter(Records).runHeader(OS);\n}\n\nvoid clang::EmitNeonTest(RecordKeeper &Records, raw_ostream &OS) {\n  llvm_unreachable(\"Neon test generation no longer implemented!\");\n}\n"}, "4": {"id": 4, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/DenseMap.h", "content": "//===- llvm/ADT/DenseMap.h - Dense probed hash table ------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the DenseMap class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_DENSEMAP_H\n#define LLVM_ADT_DENSEMAP_H\n\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/ADT/EpochTracker.h\"\n#include \"llvm/Support/AlignOf.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include \"llvm/Support/MemAlloc.h\"\n#include \"llvm/Support/ReverseIteration.h\"\n#include \"llvm/Support/type_traits.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstddef>\n#include <cstring>\n#include <initializer_list>\n#include <iterator>\n#include <new>\n#include <type_traits>\n#include <utility>\n\nnamespace llvm {\n\nnamespace detail {\n\n// We extend a pair to allow users to override the bucket type with their own\n// implementation without requiring two members.\ntemplate <typename KeyT, typename ValueT>\nstruct DenseMapPair : public std::pair<KeyT, ValueT> {\n  using std::pair<KeyT, ValueT>::pair;\n\n  KeyT &getFirst() { return std::pair<KeyT, ValueT>::first; }\n  const KeyT &getFirst() const { return std::pair<KeyT, ValueT>::first; }\n  ValueT &getSecond() { return std::pair<KeyT, ValueT>::second; }\n  const ValueT &getSecond() const { return std::pair<KeyT, ValueT>::second; }\n};\n\n} // end namespace detail\n\ntemplate <typename KeyT, typename ValueT,\n          typename KeyInfoT = DenseMapInfo<KeyT>,\n          typename Bucket = llvm::detail::DenseMapPair<KeyT, ValueT>,\n          bool IsConst = false>\nclass DenseMapIterator;\n\ntemplate <typename DerivedT, typename KeyT, typename ValueT, typename KeyInfoT,\n          typename BucketT>\nclass DenseMapBase : public DebugEpochBase {\n  template <typename T>\n  using const_arg_type_t = typename const_pointer_or_const_ref<T>::type;\n\npublic:\n  using size_type = unsigned;\n  using key_type = KeyT;\n  using mapped_type = ValueT;\n  using value_type = BucketT;\n\n  using iterator = DenseMapIterator<KeyT, ValueT, KeyInfoT, BucketT>;\n  using const_iterator =\n      DenseMapIterator<KeyT, ValueT, KeyInfoT, BucketT, true>;\n\n  inline iterator begin() {\n    // When the map is empty, avoid the overhead of advancing/retreating past\n    // empty buckets.\n    if (empty())\n      return end();\n    if (shouldReverseIterate<KeyT>())\n      return makeIterator(getBucketsEnd() - 1, getBuckets(), *this);\n    return makeIterator(getBuckets(), getBucketsEnd(), *this);\n  }\n  inline iterator end() {\n    return makeIterator(getBucketsEnd(), getBucketsEnd(), *this, true);\n  }\n  inline const_iterator begin() const {\n    if (empty())\n      return end();\n    if (shouldReverseIterate<KeyT>())\n      return makeConstIterator(getBucketsEnd() - 1, getBuckets(), *this);\n    return makeConstIterator(getBuckets(), getBucketsEnd(), *this);\n  }\n  inline const_iterator end() const {\n    return makeConstIterator(getBucketsEnd(), getBucketsEnd(), *this, true);\n  }\n\n  LLVM_NODISCARD bool empty() const {\n    return getNumEntries() == 0;\n  }\n  unsigned size() const { return getNumEntries(); }\n\n  /// Grow the densemap so that it can contain at least \\p NumEntries items\n  /// before resizing again.\n  void reserve(size_type NumEntries) {\n    auto NumBuckets = getMinBucketToReserveForEntries(NumEntries);\n    incrementEpoch();\n    if (NumBuckets > getNumBuckets())\n      grow(NumBuckets);\n  }\n\n  void clear() {\n    incrementEpoch();\n    if (getNumEntries() == 0 && getNumTombstones() == 0) return;\n\n    // If the capacity of the array is huge, and the # elements used is small,\n    // shrink the array.\n    if (getNumEntries() * 4 < getNumBuckets() && getNumBuckets() > 64) {\n      shrink_and_clear();\n      return;\n    }\n\n    const KeyT EmptyKey = getEmptyKey(), TombstoneKey = getTombstoneKey();\n    if (std::is_trivially_destructible<ValueT>::value) {\n      // Use a simpler loop when values don't need destruction.\n      for (BucketT *P = getBuckets(), *E = getBucketsEnd(); P != E; ++P)\n        P->getFirst() = EmptyKey;\n    } else {\n      unsigned NumEntries = getNumEntries();\n      for (BucketT *P = getBuckets(), *E = getBucketsEnd(); P != E; ++P) {\n        if (!KeyInfoT::isEqual(P->getFirst(), EmptyKey)) {\n          if (!KeyInfoT::isEqual(P->getFirst(), TombstoneKey)) {\n            P->getSecond().~ValueT();\n            --NumEntries;\n          }\n          P->getFirst() = EmptyKey;\n        }\n      }\n      assert(NumEntries == 0 && \"Node count imbalance!\");\n    }\n    setNumEntries(0);\n    setNumTombstones(0);\n  }\n\n  /// Return 1 if the specified key is in the map, 0 otherwise.\n  size_type count(const_arg_type_t<KeyT> Val) const {\n    const BucketT *TheBucket;\n    return LookupBucketFor(Val, TheBucket) ? 1 : 0;\n  }\n\n  iterator find(const_arg_type_t<KeyT> Val) {\n    BucketT *TheBucket;\n    if (LookupBucketFor(Val, TheBucket))\n      return makeIterator(TheBucket,\n                          shouldReverseIterate<KeyT>() ? getBuckets()\n                                                       : getBucketsEnd(),\n                          *this, true);\n    return end();\n  }\n  const_iterator find(const_arg_type_t<KeyT> Val) const {\n    const BucketT *TheBucket;\n    if (LookupBucketFor(Val, TheBucket))\n      return makeConstIterator(TheBucket,\n                               shouldReverseIterate<KeyT>() ? getBuckets()\n                                                            : getBucketsEnd(),\n                               *this, true);\n    return end();\n  }\n\n  /// Alternate version of find() which allows a different, and possibly\n  /// less expensive, key type.\n  /// The DenseMapInfo is responsible for supplying methods\n  /// getHashValue(LookupKeyT) and isEqual(LookupKeyT, KeyT) for each key\n  /// type used.\n  template<class LookupKeyT>\n  iterator find_as(const LookupKeyT &Val) {\n    BucketT *TheBucket;\n    if (LookupBucketFor(Val, TheBucket))\n      return makeIterator(TheBucket,\n                          shouldReverseIterate<KeyT>() ? getBuckets()\n                                                       : getBucketsEnd(),\n                          *this, true);\n    return end();\n  }\n  template<class LookupKeyT>\n  const_iterator find_as(const LookupKeyT &Val) const {\n    const BucketT *TheBucket;\n    if (LookupBucketFor(Val, TheBucket))\n      return makeConstIterator(TheBucket,\n                               shouldReverseIterate<KeyT>() ? getBuckets()\n                                                            : getBucketsEnd(),\n                               *this, true);\n    return end();\n  }\n\n  /// lookup - Return the entry for the specified key, or a default\n  /// constructed value if no such entry exists.\n  ValueT lookup(const_arg_type_t<KeyT> Val) const {\n    const BucketT *TheBucket;\n    if (LookupBucketFor(Val, TheBucket))\n      return TheBucket->getSecond();\n    return ValueT();\n  }\n\n  // Inserts key,value pair into the map if the key isn't already in the map.\n  // If the key is already in the map, it returns false and doesn't update the\n  // value.\n  std::pair<iterator, bool> insert(const std::pair<KeyT, ValueT> &KV) {\n    return try_emplace(KV.first, KV.second);\n  }\n\n  // Inserts key,value pair into the map if the key isn't already in the map.\n  // If the key is already in the map, it returns false and doesn't update the\n  // value.\n  std::pair<iterator, bool> insert(std::pair<KeyT, ValueT> &&KV) {\n    return try_emplace(std::move(KV.first), std::move(KV.second));\n  }\n\n  // Inserts key,value pair into the map if the key isn't already in the map.\n  // The value is constructed in-place if the key is not in the map, otherwise\n  // it is not moved.\n  template <typename... Ts>\n  std::pair<iterator, bool> try_emplace(KeyT &&Key, Ts &&... Args) {\n    BucketT *TheBucket;\n    if (LookupBucketFor(Key, TheBucket))\n      return std::make_pair(makeIterator(TheBucket,\n                                         shouldReverseIterate<KeyT>()\n                                             ? getBuckets()\n                                             : getBucketsEnd(),\n                                         *this, true),\n                            false); // Already in map.\n\n    // Otherwise, insert the new element.\n    TheBucket =\n        InsertIntoBucket(TheBucket, std::move(Key), std::forward<Ts>(Args)...);\n    return std::make_pair(makeIterator(TheBucket,\n                                       shouldReverseIterate<KeyT>()\n                                           ? getBuckets()\n                                           : getBucketsEnd(),\n                                       *this, true),\n                          true);\n  }\n\n  // Inserts key,value pair into the map if the key isn't already in the map.\n  // The value is constructed in-place if the key is not in the map, otherwise\n  // it is not moved.\n  template <typename... Ts>\n  std::pair<iterator, bool> try_emplace(const KeyT &Key, Ts &&... Args) {\n    BucketT *TheBucket;\n    if (LookupBucketFor(Key, TheBucket))\n      return std::make_pair(makeIterator(TheBucket,\n                                         shouldReverseIterate<KeyT>()\n                                             ? getBuckets()\n                                             : getBucketsEnd(),\n                                         *this, true),\n                            false); // Already in map.\n\n    // Otherwise, insert the new element.\n    TheBucket = InsertIntoBucket(TheBucket, Key, std::forward<Ts>(Args)...);\n    return std::make_pair(makeIterator(TheBucket,\n                                       shouldReverseIterate<KeyT>()\n                                           ? getBuckets()\n                                           : getBucketsEnd(),\n                                       *this, true),\n                          true);\n  }\n\n  /// Alternate version of insert() which allows a different, and possibly\n  /// less expensive, key type.\n  /// The DenseMapInfo is responsible for supplying methods\n  /// getHashValue(LookupKeyT) and isEqual(LookupKeyT, KeyT) for each key\n  /// type used.\n  template <typename LookupKeyT>\n  std::pair<iterator, bool> insert_as(std::pair<KeyT, ValueT> &&KV,\n                                      const LookupKeyT &Val) {\n    BucketT *TheBucket;\n    if (LookupBucketFor(Val, TheBucket))\n      return std::make_pair(makeIterator(TheBucket,\n                                         shouldReverseIterate<KeyT>()\n                                             ? getBuckets()\n                                             : getBucketsEnd(),\n                                         *this, true),\n                            false); // Already in map.\n\n    // Otherwise, insert the new element.\n    TheBucket = InsertIntoBucketWithLookup(TheBucket, std::move(KV.first),\n                                           std::move(KV.second), Val);\n    return std::make_pair(makeIterator(TheBucket,\n                                       shouldReverseIterate<KeyT>()\n                                           ? getBuckets()\n                                           : getBucketsEnd(),\n                                       *this, true),\n                          true);\n  }\n\n  /// insert - Range insertion of pairs.\n  template<typename InputIt>\n  void insert(InputIt I, InputIt E) {\n    for (; I != E; ++I)\n      insert(*I);\n  }\n\n  bool erase(const KeyT &Val) {\n    BucketT *TheBucket;\n    if (!LookupBucketFor(Val, TheBucket))\n      return false; // not in map.\n\n    TheBucket->getSecond().~ValueT();\n    TheBucket->getFirst() = getTombstoneKey();\n    decrementNumEntries();\n    incrementNumTombstones();\n    return true;\n  }\n  void erase(iterator I) {\n    BucketT *TheBucket = &*I;\n    TheBucket->getSecond().~ValueT();\n    TheBucket->getFirst() = getTombstoneKey();\n    decrementNumEntries();\n    incrementNumTombstones();\n  }\n\n  value_type& FindAndConstruct(const KeyT &Key) {\n    BucketT *TheBucket;\n    if (LookupBucketFor(Key, TheBucket))\n      return *TheBucket;\n\n    return *InsertIntoBucket(TheBucket, Key);\n  }\n\n  ValueT &operator[](const KeyT &Key) {\n    return FindAndConstruct(Key).second;\n  }\n\n  value_type& FindAndConstruct(KeyT &&Key) {\n    BucketT *TheBucket;\n    if (LookupBucketFor(Key, TheBucket))\n      return *TheBucket;\n\n    return *InsertIntoBucket(TheBucket, std::move(Key));\n  }\n\n  ValueT &operator[](KeyT &&Key) {\n    return FindAndConstruct(std::move(Key)).second;\n  }\n\n  /// isPointerIntoBucketsArray - Return true if the specified pointer points\n  /// somewhere into the DenseMap's array of buckets (i.e. either to a key or\n  /// value in the DenseMap).\n  bool isPointerIntoBucketsArray(const void *Ptr) const {\n    return Ptr >= getBuckets() && Ptr < getBucketsEnd();\n  }\n\n  /// getPointerIntoBucketsArray() - Return an opaque pointer into the buckets\n  /// array.  In conjunction with the previous method, this can be used to\n  /// determine whether an insertion caused the DenseMap to reallocate.\n  const void *getPointerIntoBucketsArray() const { return getBuckets(); }\n\nprotected:\n  DenseMapBase() = default;\n\n  void destroyAll() {\n    if (getNumBuckets() == 0) // Nothing to do.\n      return;\n\n    const KeyT EmptyKey = getEmptyKey(), TombstoneKey = getTombstoneKey();\n    for (BucketT *P = getBuckets(), *E = getBucketsEnd(); P != E; ++P) {\n      if (!KeyInfoT::isEqual(P->getFirst(), EmptyKey) &&\n          !KeyInfoT::isEqual(P->getFirst(), TombstoneKey))\n        P->getSecond().~ValueT();\n      P->getFirst().~KeyT();\n    }\n  }\n\n  void initEmpty() {\n    setNumEntries(0);\n    setNumTombstones(0);\n\n    assert((getNumBuckets() & (getNumBuckets()-1)) == 0 &&\n           \"# initial buckets must be a power of two!\");\n    const KeyT EmptyKey = getEmptyKey();\n    for (BucketT *B = getBuckets(), *E = getBucketsEnd(); B != E; ++B)\n      ::new (&B->getFirst()) KeyT(EmptyKey);\n  }\n\n  /// Returns the number of buckets to allocate to ensure that the DenseMap can\n  /// accommodate \\p NumEntries without need to grow().\n  unsigned getMinBucketToReserveForEntries(unsigned NumEntries) {\n    // Ensure that \"NumEntries * 4 < NumBuckets * 3\"\n    if (NumEntries == 0)\n      return 0;\n    // +1 is required because of the strict equality.\n    // For example if NumEntries is 48, we need to return 401.\n    return NextPowerOf2(NumEntries * 4 / 3 + 1);\n  }\n\n  void moveFromOldBuckets(BucketT *OldBucketsBegin, BucketT *OldBucketsEnd) {\n    initEmpty();\n\n    // Insert all the old elements.\n    const KeyT EmptyKey = getEmptyKey();\n    const KeyT TombstoneKey = getTombstoneKey();\n    for (BucketT *B = OldBucketsBegin, *E = OldBucketsEnd; B != E; ++B) {\n      if (!KeyInfoT::isEqual(B->getFirst(), EmptyKey) &&\n          !KeyInfoT::isEqual(B->getFirst(), TombstoneKey)) {\n        // Insert the key/value into the new table.\n        BucketT *DestBucket;\n        bool FoundVal = LookupBucketFor(B->getFirst(), DestBucket);\n        (void)FoundVal; // silence warning.\n        assert(!FoundVal && \"Key already in new map?\");\n        DestBucket->getFirst() = std::move(B->getFirst());\n        ::new (&DestBucket->getSecond()) ValueT(std::move(B->getSecond()));\n        incrementNumEntries();\n\n        // Free the value.\n        B->getSecond().~ValueT();\n      }\n      B->getFirst().~KeyT();\n    }\n  }\n\n  template <typename OtherBaseT>\n  void copyFrom(\n      const DenseMapBase<OtherBaseT, KeyT, ValueT, KeyInfoT, BucketT> &other) {\n    assert(&other != this);\n    assert(getNumBuckets() == other.getNumBuckets());\n\n    setNumEntries(other.getNumEntries());\n    setNumTombstones(other.getNumTombstones());\n\n    if (std::is_trivially_copyable<KeyT>::value &&\n        std::is_trivially_copyable<ValueT>::value)\n      memcpy(reinterpret_cast<void *>(getBuckets()), other.getBuckets(),\n             getNumBuckets() * sizeof(BucketT));\n    else\n      for (size_t i = 0; i < getNumBuckets(); ++i) {\n        ::new (&getBuckets()[i].getFirst())\n            KeyT(other.getBuckets()[i].getFirst());\n        if (!KeyInfoT::isEqual(getBuckets()[i].getFirst(), getEmptyKey()) &&\n            !KeyInfoT::isEqual(getBuckets()[i].getFirst(), getTombstoneKey()))\n          ::new (&getBuckets()[i].getSecond())\n              ValueT(other.getBuckets()[i].getSecond());\n      }\n  }\n\n  static unsigned getHashValue(const KeyT &Val) {\n    return KeyInfoT::getHashValue(Val);\n  }\n\n  template<typename LookupKeyT>\n  static unsigned getHashValue(const LookupKeyT &Val) {\n    return KeyInfoT::getHashValue(Val);\n  }\n\n  static const KeyT getEmptyKey() {\n    static_assert(std::is_base_of<DenseMapBase, DerivedT>::value,\n                  \"Must pass the derived type to this template!\");\n    return KeyInfoT::getEmptyKey();\n  }\n\n  static const KeyT getTombstoneKey() {\n    return KeyInfoT::getTombstoneKey();\n  }\n\nprivate:\n  iterator makeIterator(BucketT *P, BucketT *E,\n                        DebugEpochBase &Epoch,\n                        bool NoAdvance=false) {\n    if (shouldReverseIterate<KeyT>()) {\n      BucketT *B = P == getBucketsEnd() ? getBuckets() : P + 1;\n      return iterator(B, E, Epoch, NoAdvance);\n    }\n    return iterator(P, E, Epoch, NoAdvance);\n  }\n\n  const_iterator makeConstIterator(const BucketT *P, const BucketT *E,\n                                   const DebugEpochBase &Epoch,\n                                   const bool NoAdvance=false) const {\n    if (shouldReverseIterate<KeyT>()) {\n      const BucketT *B = P == getBucketsEnd() ? getBuckets() : P + 1;\n      return const_iterator(B, E, Epoch, NoAdvance);\n    }\n    return const_iterator(P, E, Epoch, NoAdvance);\n  }\n\n  unsigned getNumEntries() const {\n    return static_cast<const DerivedT *>(this)->getNumEntries();\n  }\n\n  void setNumEntries(unsigned Num) {\n    static_cast<DerivedT *>(this)->setNumEntries(Num);\n  }\n\n  void incrementNumEntries() {\n    setNumEntries(getNumEntries() + 1);\n  }\n\n  void decrementNumEntries() {\n    setNumEntries(getNumEntries() - 1);\n  }\n\n  unsigned getNumTombstones() const {\n    return static_cast<const DerivedT *>(this)->getNumTombstones();\n  }\n\n  void setNumTombstones(unsigned Num) {\n    static_cast<DerivedT *>(this)->setNumTombstones(Num);\n  }\n\n  void incrementNumTombstones() {\n    setNumTombstones(getNumTombstones() + 1);\n  }\n\n  void decrementNumTombstones() {\n    setNumTombstones(getNumTombstones() - 1);\n  }\n\n  const BucketT *getBuckets() const {\n    return static_cast<const DerivedT *>(this)->getBuckets();\n  }\n\n  BucketT *getBuckets() {\n    return static_cast<DerivedT *>(this)->getBuckets();\n  }\n\n  unsigned getNumBuckets() const {\n    return static_cast<const DerivedT *>(this)->getNumBuckets();\n  }\n\n  BucketT *getBucketsEnd() {\n    return getBuckets() + getNumBuckets();\n  }\n\n  const BucketT *getBucketsEnd() const {\n    return getBuckets() + getNumBuckets();\n  }\n\n  void grow(unsigned AtLeast) {\n    static_cast<DerivedT *>(this)->grow(AtLeast);\n  }\n\n  void shrink_and_clear() {\n    static_cast<DerivedT *>(this)->shrink_and_clear();\n  }\n\n  template <typename KeyArg, typename... ValueArgs>\n  BucketT *InsertIntoBucket(BucketT *TheBucket, KeyArg &&Key,\n                            ValueArgs &&... Values) {\n    TheBucket = InsertIntoBucketImpl(Key, Key, TheBucket);\n\n    TheBucket->getFirst() = std::forward<KeyArg>(Key);\n    ::new (&TheBucket->getSecond()) ValueT(std::forward<ValueArgs>(Values)...);\n    return TheBucket;\n  }\n\n  template <typename LookupKeyT>\n  BucketT *InsertIntoBucketWithLookup(BucketT *TheBucket, KeyT &&Key,\n                                      ValueT &&Value, LookupKeyT &Lookup) {\n    TheBucket = InsertIntoBucketImpl(Key, Lookup, TheBucket);\n\n    TheBucket->getFirst() = std::move(Key);\n    ::new (&TheBucket->getSecond()) ValueT(std::move(Value));\n    return TheBucket;\n  }\n\n  template <typename LookupKeyT>\n  BucketT *InsertIntoBucketImpl(const KeyT &Key, const LookupKeyT &Lookup,\n                                BucketT *TheBucket) {\n    incrementEpoch();\n\n    // If the load of the hash table is more than 3/4, or if fewer than 1/8 of\n    // the buckets are empty (meaning that many are filled with tombstones),\n    // grow the table.\n    //\n    // The later case is tricky.  For example, if we had one empty bucket with\n    // tons of tombstones, failing lookups (e.g. for insertion) would have to\n    // probe almost the entire table until it found the empty bucket.  If the\n    // table completely filled with tombstones, no lookup would ever succeed,\n    // causing infinite loops in lookup.\n    unsigned NewNumEntries = getNumEntries() + 1;\n    unsigned NumBuckets = getNumBuckets();\n    if (LLVM_UNLIKELY(NewNumEntries * 4 >= NumBuckets * 3)) {\n      this->grow(NumBuckets * 2);\n      LookupBucketFor(Lookup, TheBucket);\n      NumBuckets = getNumBuckets();\n    } else if (LLVM_UNLIKELY(NumBuckets-(NewNumEntries+getNumTombstones()) <=\n                             NumBuckets/8)) {\n      this->grow(NumBuckets);\n      LookupBucketFor(Lookup, TheBucket);\n    }\n    assert(TheBucket);\n\n    // Only update the state after we've grown our bucket space appropriately\n    // so that when growing buckets we have self-consistent entry count.\n    incrementNumEntries();\n\n    // If we are writing over a tombstone, remember this.\n    const KeyT EmptyKey = getEmptyKey();\n    if (!KeyInfoT::isEqual(TheBucket->getFirst(), EmptyKey))\n      decrementNumTombstones();\n\n    return TheBucket;\n  }\n\n  /// LookupBucketFor - Lookup the appropriate bucket for Val, returning it in\n  /// FoundBucket.  If the bucket contains the key and a value, this returns\n  /// true, otherwise it returns a bucket with an empty marker or tombstone and\n  /// returns false.\n  template<typename LookupKeyT>\n  bool LookupBucketFor(const LookupKeyT &Val,\n                       const BucketT *&FoundBucket) const {\n    const BucketT *BucketsPtr = getBuckets();\n    const unsigned NumBuckets = getNumBuckets();\n\n    if (NumBuckets == 0) {\n      FoundBucket = nullptr;\n      return false;\n    }\n\n    // FoundTombstone - Keep track of whether we find a tombstone while probing.\n    const BucketT *FoundTombstone = nullptr;\n    const KeyT EmptyKey = getEmptyKey();\n    const KeyT TombstoneKey = getTombstoneKey();\n    assert(!KeyInfoT::isEqual(Val, EmptyKey) &&\n           !KeyInfoT::isEqual(Val, TombstoneKey) &&\n           \"Empty/Tombstone value shouldn't be inserted into map!\");\n\n    unsigned BucketNo = getHashValue(Val) & (NumBuckets-1);\n    unsigned ProbeAmt = 1;\n    while (true) {\n      const BucketT *ThisBucket = BucketsPtr + BucketNo;\n      // Found Val's bucket?  If so, return it.\n      if (LLVM_LIKELY(KeyInfoT::isEqual(Val, ThisBucket->getFirst()))) {\n        FoundBucket = ThisBucket;\n        return true;\n      }\n\n      // If we found an empty bucket, the key doesn't exist in the set.\n      // Insert it and return the default value.\n      if (LLVM_LIKELY(KeyInfoT::isEqual(ThisBucket->getFirst(), EmptyKey))) {\n        // If we've already seen a tombstone while probing, fill it in instead\n        // of the empty bucket we eventually probed to.\n        FoundBucket = FoundTombstone ? FoundTombstone : ThisBucket;\n        return false;\n      }\n\n      // If this is a tombstone, remember it.  If Val ends up not in the map, we\n      // prefer to return it than something that would require more probing.\n      if (KeyInfoT::isEqual(ThisBucket->getFirst(), TombstoneKey) &&\n          !FoundTombstone)\n        FoundTombstone = ThisBucket;  // Remember the first tombstone found.\n\n      // Otherwise, it's a hash collision or a tombstone, continue quadratic\n      // probing.\n      BucketNo += ProbeAmt++;\n      BucketNo &= (NumBuckets-1);\n    }\n  }\n\n  template <typename LookupKeyT>\n  bool LookupBucketFor(const LookupKeyT &Val, BucketT *&FoundBucket) {\n    const BucketT *ConstFoundBucket;\n    bool Result = const_cast<const DenseMapBase *>(this)\n      ->LookupBucketFor(Val, ConstFoundBucket);\n    FoundBucket = const_cast<BucketT *>(ConstFoundBucket);\n    return Result;\n  }\n\npublic:\n  /// Return the approximate size (in bytes) of the actual map.\n  /// This is just the raw memory used by DenseMap.\n  /// If entries are pointers to objects, the size of the referenced objects\n  /// are not included.\n  size_t getMemorySize() const {\n    return getNumBuckets() * sizeof(BucketT);\n  }\n};\n\n/// Equality comparison for DenseMap.\n///\n/// Iterates over elements of LHS confirming that each (key, value) pair in LHS\n/// is also in RHS, and that no additional pairs are in RHS.\n/// Equivalent to N calls to RHS.find and N value comparisons. Amortized\n/// complexity is linear, worst case is O(N^2) (if every hash collides).\ntemplate <typename DerivedT, typename KeyT, typename ValueT, typename KeyInfoT,\n          typename BucketT>\nbool operator==(\n    const DenseMapBase<DerivedT, KeyT, ValueT, KeyInfoT, BucketT> &LHS,\n    const DenseMapBase<DerivedT, KeyT, ValueT, KeyInfoT, BucketT> &RHS) {\n  if (LHS.size() != RHS.size())\n    return false;\n\n  for (auto &KV : LHS) {\n    auto I = RHS.find(KV.first);\n    if (I == RHS.end() || I->second != KV.second)\n      return false;\n  }\n\n  return true;\n}\n\n/// Inequality comparison for DenseMap.\n///\n/// Equivalent to !(LHS == RHS). See operator== for performance notes.\ntemplate <typename DerivedT, typename KeyT, typename ValueT, typename KeyInfoT,\n          typename BucketT>\nbool operator!=(\n    const DenseMapBase<DerivedT, KeyT, ValueT, KeyInfoT, BucketT> &LHS,\n    const DenseMapBase<DerivedT, KeyT, ValueT, KeyInfoT, BucketT> &RHS) {\n  return !(LHS == RHS);\n}\n\ntemplate <typename KeyT, typename ValueT,\n          typename KeyInfoT = DenseMapInfo<KeyT>,\n          typename BucketT = llvm::detail::DenseMapPair<KeyT, ValueT>>\nclass DenseMap : public DenseMapBase<DenseMap<KeyT, ValueT, KeyInfoT, BucketT>,\n                                     KeyT, ValueT, KeyInfoT, BucketT> {\n  friend class DenseMapBase<DenseMap, KeyT, ValueT, KeyInfoT, BucketT>;\n\n  // Lift some types from the dependent base class into this class for\n  // simplicity of referring to them.\n  using BaseT = DenseMapBase<DenseMap, KeyT, ValueT, KeyInfoT, BucketT>;\n\n  BucketT *Buckets;\n  unsigned NumEntries;\n  unsigned NumTombstones;\n  unsigned NumBuckets;\n\npublic:\n  /// Create a DenseMap with an optional \\p InitialReserve that guarantee that\n  /// this number of elements can be inserted in the map without grow()\n  explicit DenseMap(unsigned InitialReserve = 0) { init(InitialReserve); }\n\n  DenseMap(const DenseMap &other) : BaseT() {\n    init(0);\n    copyFrom(other);\n  }\n\n  DenseMap(DenseMap &&other) : BaseT() {\n    init(0);\n    swap(other);\n  }\n\n  template<typename InputIt>\n  DenseMap(const InputIt &I, const InputIt &E) {\n    init(std::distance(I, E));\n    this->insert(I, E);\n  }\n\n  DenseMap(std::initializer_list<typename BaseT::value_type> Vals) {\n    init(Vals.size());\n    this->insert(Vals.begin(), Vals.end());\n  }\n\n  ~DenseMap() {\n    this->destroyAll();\n    deallocate_buffer(Buckets, sizeof(BucketT) * NumBuckets, alignof(BucketT));\n  }\n\n  void swap(DenseMap& RHS) {\n    this->incrementEpoch();\n    RHS.incrementEpoch();\n    std::swap(Buckets, RHS.Buckets);\n    std::swap(NumEntries, RHS.NumEntries);\n    std::swap(NumTombstones, RHS.NumTombstones);\n    std::swap(NumBuckets, RHS.NumBuckets);\n  }\n\n  DenseMap& operator=(const DenseMap& other) {\n    if (&other != this)\n      copyFrom(other);\n    return *this;\n  }\n\n  DenseMap& operator=(DenseMap &&other) {\n    this->destroyAll();\n    deallocate_buffer(Buckets, sizeof(BucketT) * NumBuckets, alignof(BucketT));\n    init(0);\n    swap(other);\n    return *this;\n  }\n\n  void copyFrom(const DenseMap& other) {\n    this->destroyAll();\n    deallocate_buffer(Buckets, sizeof(BucketT) * NumBuckets, alignof(BucketT));\n    if (allocateBuckets(other.NumBuckets)) {\n      this->BaseT::copyFrom(other);\n    } else {\n      NumEntries = 0;\n      NumTombstones = 0;\n    }\n  }\n\n  void init(unsigned InitNumEntries) {\n    auto InitBuckets = BaseT::getMinBucketToReserveForEntries(InitNumEntries);\n    if (allocateBuckets(InitBuckets)) {\n      this->BaseT::initEmpty();\n    } else {\n      NumEntries = 0;\n      NumTombstones = 0;\n    }\n  }\n\n  void grow(unsigned AtLeast) {\n    unsigned OldNumBuckets = NumBuckets;\n    BucketT *OldBuckets = Buckets;\n\n    allocateBuckets(std::max<unsigned>(64, static_cast<unsigned>(NextPowerOf2(AtLeast-1))));\n    assert(Buckets);\n    if (!OldBuckets) {\n      this->BaseT::initEmpty();\n      return;\n    }\n\n    this->moveFromOldBuckets(OldBuckets, OldBuckets+OldNumBuckets);\n\n    // Free the old table.\n    deallocate_buffer(OldBuckets, sizeof(BucketT) * OldNumBuckets,\n                      alignof(BucketT));\n  }\n\n  void shrink_and_clear() {\n    unsigned OldNumBuckets = NumBuckets;\n    unsigned OldNumEntries = NumEntries;\n    this->destroyAll();\n\n    // Reduce the number of buckets.\n    unsigned NewNumBuckets = 0;\n    if (OldNumEntries)\n      NewNumBuckets = std::max(64, 1 << (Log2_32_Ceil(OldNumEntries) + 1));\n    if (NewNumBuckets == NumBuckets) {\n      this->BaseT::initEmpty();\n      return;\n    }\n\n    deallocate_buffer(Buckets, sizeof(BucketT) * OldNumBuckets,\n                      alignof(BucketT));\n    init(NewNumBuckets);\n  }\n\nprivate:\n  unsigned getNumEntries() const {\n    return NumEntries;\n  }\n\n  void setNumEntries(unsigned Num) {\n    NumEntries = Num;\n  }\n\n  unsigned getNumTombstones() const {\n    return NumTombstones;\n  }\n\n  void setNumTombstones(unsigned Num) {\n    NumTombstones = Num;\n  }\n\n  BucketT *getBuckets() const {\n    return Buckets;\n  }\n\n  unsigned getNumBuckets() const {\n    return NumBuckets;\n  }\n\n  bool allocateBuckets(unsigned Num) {\n    NumBuckets = Num;\n    if (NumBuckets == 0) {\n      Buckets = nullptr;\n      return false;\n    }\n\n    Buckets = static_cast<BucketT *>(\n        allocate_buffer(sizeof(BucketT) * NumBuckets, alignof(BucketT)));\n    return true;\n  }\n};\n\ntemplate <typename KeyT, typename ValueT, unsigned InlineBuckets = 4,\n          typename KeyInfoT = DenseMapInfo<KeyT>,\n          typename BucketT = llvm::detail::DenseMapPair<KeyT, ValueT>>\nclass SmallDenseMap\n    : public DenseMapBase<\n          SmallDenseMap<KeyT, ValueT, InlineBuckets, KeyInfoT, BucketT>, KeyT,\n          ValueT, KeyInfoT, BucketT> {\n  friend class DenseMapBase<SmallDenseMap, KeyT, ValueT, KeyInfoT, BucketT>;\n\n  // Lift some types from the dependent base class into this class for\n  // simplicity of referring to them.\n  using BaseT = DenseMapBase<SmallDenseMap, KeyT, ValueT, KeyInfoT, BucketT>;\n\n  static_assert(isPowerOf2_64(InlineBuckets),\n                \"InlineBuckets must be a power of 2.\");\n\n  unsigned Small : 1;\n  unsigned NumEntries : 31;\n  unsigned NumTombstones;\n\n  struct LargeRep {\n    BucketT *Buckets;\n    unsigned NumBuckets;\n  };\n\n  /// A \"union\" of an inline bucket array and the struct representing\n  /// a large bucket. This union will be discriminated by the 'Small' bit.\n  AlignedCharArrayUnion<BucketT[InlineBuckets], LargeRep> storage;\n\npublic:\n  explicit SmallDenseMap(unsigned NumInitBuckets = 0) {\n    init(NumInitBuckets);\n  }\n\n  SmallDenseMap(const SmallDenseMap &other) : BaseT() {\n    init(0);\n    copyFrom(other);\n  }\n\n  SmallDenseMap(SmallDenseMap &&other) : BaseT() {\n    init(0);\n    swap(other);\n  }\n\n  template<typename InputIt>\n  SmallDenseMap(const InputIt &I, const InputIt &E) {\n    init(NextPowerOf2(std::distance(I, E)));\n    this->insert(I, E);\n  }\n\n  ~SmallDenseMap() {\n    this->destroyAll();\n    deallocateBuckets();\n  }\n\n  void swap(SmallDenseMap& RHS) {\n    unsigned TmpNumEntries = RHS.NumEntries;\n    RHS.NumEntries = NumEntries;\n    NumEntries = TmpNumEntries;\n    std::swap(NumTombstones, RHS.NumTombstones);\n\n    const KeyT EmptyKey = this->getEmptyKey();\n    const KeyT TombstoneKey = this->getTombstoneKey();\n    if (Small && RHS.Small) {\n      // If we're swapping inline bucket arrays, we have to cope with some of\n      // the tricky bits of DenseMap's storage system: the buckets are not\n      // fully initialized. Thus we swap every key, but we may have\n      // a one-directional move of the value.\n      for (unsigned i = 0, e = InlineBuckets; i != e; ++i) {\n        BucketT *LHSB = &getInlineBuckets()[i],\n                *RHSB = &RHS.getInlineBuckets()[i];\n        bool hasLHSValue = (!KeyInfoT::isEqual(LHSB->getFirst(), EmptyKey) &&\n                            !KeyInfoT::isEqual(LHSB->getFirst(), TombstoneKey));\n        bool hasRHSValue = (!KeyInfoT::isEqual(RHSB->getFirst(), EmptyKey) &&\n                            !KeyInfoT::isEqual(RHSB->getFirst(), TombstoneKey));\n        if (hasLHSValue && hasRHSValue) {\n          // Swap together if we can...\n          std::swap(*LHSB, *RHSB);\n          continue;\n        }\n        // Swap separately and handle any asymmetry.\n        std::swap(LHSB->getFirst(), RHSB->getFirst());\n        if (hasLHSValue) {\n          ::new (&RHSB->getSecond()) ValueT(std::move(LHSB->getSecond()));\n          LHSB->getSecond().~ValueT();\n        } else if (hasRHSValue) {\n          ::new (&LHSB->getSecond()) ValueT(std::move(RHSB->getSecond()));\n          RHSB->getSecond().~ValueT();\n        }\n      }\n      return;\n    }\n    if (!Small && !RHS.Small) {\n      std::swap(getLargeRep()->Buckets, RHS.getLargeRep()->Buckets);\n      std::swap(getLargeRep()->NumBuckets, RHS.getLargeRep()->NumBuckets);\n      return;\n    }\n\n    SmallDenseMap &SmallSide = Small ? *this : RHS;\n    SmallDenseMap &LargeSide = Small ? RHS : *this;\n\n    // First stash the large side's rep and move the small side across.\n    LargeRep TmpRep = std::move(*LargeSide.getLargeRep());\n    LargeSide.getLargeRep()->~LargeRep();\n    LargeSide.Small = true;\n    // This is similar to the standard move-from-old-buckets, but the bucket\n    // count hasn't actually rotated in this case. So we have to carefully\n    // move construct the keys and values into their new locations, but there\n    // is no need to re-hash things.\n    for (unsigned i = 0, e = InlineBuckets; i != e; ++i) {\n      BucketT *NewB = &LargeSide.getInlineBuckets()[i],\n              *OldB = &SmallSide.getInlineBuckets()[i];\n      ::new (&NewB->getFirst()) KeyT(std::move(OldB->getFirst()));\n      OldB->getFirst().~KeyT();\n      if (!KeyInfoT::isEqual(NewB->getFirst(), EmptyKey) &&\n          !KeyInfoT::isEqual(NewB->getFirst(), TombstoneKey)) {\n        ::new (&NewB->getSecond()) ValueT(std::move(OldB->getSecond()));\n        OldB->getSecond().~ValueT();\n      }\n    }\n\n    // The hard part of moving the small buckets across is done, just move\n    // the TmpRep into its new home.\n    SmallSide.Small = false;\n    new (SmallSide.getLargeRep()) LargeRep(std::move(TmpRep));\n  }\n\n  SmallDenseMap& operator=(const SmallDenseMap& other) {\n    if (&other != this)\n      copyFrom(other);\n    return *this;\n  }\n\n  SmallDenseMap& operator=(SmallDenseMap &&other) {\n    this->destroyAll();\n    deallocateBuckets();\n    init(0);\n    swap(other);\n    return *this;\n  }\n\n  void copyFrom(const SmallDenseMap& other) {\n    this->destroyAll();\n    deallocateBuckets();\n    Small = true;\n    if (other.getNumBuckets() > InlineBuckets) {\n      Small = false;\n      new (getLargeRep()) LargeRep(allocateBuckets(other.getNumBuckets()));\n    }\n    this->BaseT::copyFrom(other);\n  }\n\n  void init(unsigned InitBuckets) {\n    Small = true;\n    if (InitBuckets > InlineBuckets) {\n      Small = false;\n      new (getLargeRep()) LargeRep(allocateBuckets(InitBuckets));\n    }\n    this->BaseT::initEmpty();\n  }\n\n  void grow(unsigned AtLeast) {\n    if (AtLeast > InlineBuckets)\n      AtLeast = std::max<unsigned>(64, NextPowerOf2(AtLeast-1));\n\n    if (Small) {\n      // First move the inline buckets into a temporary storage.\n      AlignedCharArrayUnion<BucketT[InlineBuckets]> TmpStorage;\n      BucketT *TmpBegin = reinterpret_cast<BucketT *>(&TmpStorage);\n      BucketT *TmpEnd = TmpBegin;\n\n      // Loop over the buckets, moving non-empty, non-tombstones into the\n      // temporary storage. Have the loop move the TmpEnd forward as it goes.\n      const KeyT EmptyKey = this->getEmptyKey();\n      const KeyT TombstoneKey = this->getTombstoneKey();\n      for (BucketT *P = getBuckets(), *E = P + InlineBuckets; P != E; ++P) {\n        if (!KeyInfoT::isEqual(P->getFirst(), EmptyKey) &&\n            !KeyInfoT::isEqual(P->getFirst(), TombstoneKey)) {\n          assert(size_t(TmpEnd - TmpBegin) < InlineBuckets &&\n                 \"Too many inline buckets!\");\n          ::new (&TmpEnd->getFirst()) KeyT(std::move(P->getFirst()));\n          ::new (&TmpEnd->getSecond()) ValueT(std::move(P->getSecond()));\n          ++TmpEnd;\n          P->getSecond().~ValueT();\n        }\n        P->getFirst().~KeyT();\n      }\n\n      // AtLeast == InlineBuckets can happen if there are many tombstones,\n      // and grow() is used to remove them. Usually we always switch to the\n      // large rep here.\n      if (AtLeast > InlineBuckets) {\n        Small = false;\n        new (getLargeRep()) LargeRep(allocateBuckets(AtLeast));\n      }\n      this->moveFromOldBuckets(TmpBegin, TmpEnd);\n      return;\n    }\n\n    LargeRep OldRep = std::move(*getLargeRep());\n    getLargeRep()->~LargeRep();\n    if (AtLeast <= InlineBuckets) {\n      Small = true;\n    } else {\n      new (getLargeRep()) LargeRep(allocateBuckets(AtLeast));\n    }\n\n    this->moveFromOldBuckets(OldRep.Buckets, OldRep.Buckets+OldRep.NumBuckets);\n\n    // Free the old table.\n    deallocate_buffer(OldRep.Buckets, sizeof(BucketT) * OldRep.NumBuckets,\n                      alignof(BucketT));\n  }\n\n  void shrink_and_clear() {\n    unsigned OldSize = this->size();\n    this->destroyAll();\n\n    // Reduce the number of buckets.\n    unsigned NewNumBuckets = 0;\n    if (OldSize) {\n      NewNumBuckets = 1 << (Log2_32_Ceil(OldSize) + 1);\n      if (NewNumBuckets > InlineBuckets && NewNumBuckets < 64u)\n        NewNumBuckets = 64;\n    }\n    if ((Small && NewNumBuckets <= InlineBuckets) ||\n        (!Small && NewNumBuckets == getLargeRep()->NumBuckets)) {\n      this->BaseT::initEmpty();\n      return;\n    }\n\n    deallocateBuckets();\n    init(NewNumBuckets);\n  }\n\nprivate:\n  unsigned getNumEntries() const {\n    return NumEntries;\n  }\n\n  void setNumEntries(unsigned Num) {\n    // NumEntries is hardcoded to be 31 bits wide.\n    assert(Num < (1U << 31) && \"Cannot support more than 1<<31 entries\");\n    NumEntries = Num;\n  }\n\n  unsigned getNumTombstones() const {\n    return NumTombstones;\n  }\n\n  void setNumTombstones(unsigned Num) {\n    NumTombstones = Num;\n  }\n\n  const BucketT *getInlineBuckets() const {\n    assert(Small);\n    // Note that this cast does not violate aliasing rules as we assert that\n    // the memory's dynamic type is the small, inline bucket buffer, and the\n    // 'storage' is a POD containing a char buffer.\n    return reinterpret_cast<const BucketT *>(&storage);\n  }\n\n  BucketT *getInlineBuckets() {\n    return const_cast<BucketT *>(\n      const_cast<const SmallDenseMap *>(this)->getInlineBuckets());\n  }\n\n  const LargeRep *getLargeRep() const {\n    assert(!Small);\n    // Note, same rule about aliasing as with getInlineBuckets.\n    return reinterpret_cast<const LargeRep *>(&storage);\n  }\n\n  LargeRep *getLargeRep() {\n    return const_cast<LargeRep *>(\n      const_cast<const SmallDenseMap *>(this)->getLargeRep());\n  }\n\n  const BucketT *getBuckets() const {\n    return Small ? getInlineBuckets() : getLargeRep()->Buckets;\n  }\n\n  BucketT *getBuckets() {\n    return const_cast<BucketT *>(\n      const_cast<const SmallDenseMap *>(this)->getBuckets());\n  }\n\n  unsigned getNumBuckets() const {\n    return Small ? InlineBuckets : getLargeRep()->NumBuckets;\n  }\n\n  void deallocateBuckets() {\n    if (Small)\n      return;\n\n    deallocate_buffer(getLargeRep()->Buckets,\n                      sizeof(BucketT) * getLargeRep()->NumBuckets,\n                      alignof(BucketT));\n    getLargeRep()->~LargeRep();\n  }\n\n  LargeRep allocateBuckets(unsigned Num) {\n    assert(Num > InlineBuckets && \"Must allocate more buckets than are inline\");\n    LargeRep Rep = {static_cast<BucketT *>(allocate_buffer(\n                        sizeof(BucketT) * Num, alignof(BucketT))),\n                    Num};\n    return Rep;\n  }\n};\n\ntemplate <typename KeyT, typename ValueT, typename KeyInfoT, typename Bucket,\n          bool IsConst>\nclass DenseMapIterator : DebugEpochBase::HandleBase {\n  friend class DenseMapIterator<KeyT, ValueT, KeyInfoT, Bucket, true>;\n  friend class DenseMapIterator<KeyT, ValueT, KeyInfoT, Bucket, false>;\n\npublic:\n  using difference_type = ptrdiff_t;\n  using value_type =\n      typename std::conditional<IsConst, const Bucket, Bucket>::type;\n  using pointer = value_type *;\n  using reference = value_type &;\n  using iterator_category = std::forward_iterator_tag;\n\nprivate:\n  pointer Ptr = nullptr;\n  pointer End = nullptr;\n\npublic:\n  DenseMapIterator() = default;\n\n  DenseMapIterator(pointer Pos, pointer E, const DebugEpochBase &Epoch,\n                   bool NoAdvance = false)\n      : DebugEpochBase::HandleBase(&Epoch), Ptr(Pos), End(E) {\n    assert(isHandleInSync() && \"invalid construction!\");\n\n    if (NoAdvance) return;\n    if (shouldReverseIterate<KeyT>()) {\n      RetreatPastEmptyBuckets();\n      return;\n    }\n    AdvancePastEmptyBuckets();\n  }\n\n  // Converting ctor from non-const iterators to const iterators. SFINAE'd out\n  // for const iterator destinations so it doesn't end up as a user defined copy\n  // constructor.\n  template <bool IsConstSrc,\n            typename = std::enable_if_t<!IsConstSrc && IsConst>>\n  DenseMapIterator(\n      const DenseMapIterator<KeyT, ValueT, KeyInfoT, Bucket, IsConstSrc> &I)\n      : DebugEpochBase::HandleBase(I), Ptr(I.Ptr), End(I.End) {}\n\n  reference operator*() const {\n    assert(isHandleInSync() && \"invalid iterator access!\");\n    assert(Ptr != End && \"dereferencing end() iterator\");\n    if (shouldReverseIterate<KeyT>())\n      return Ptr[-1];\n    return *Ptr;\n  }\n  pointer operator->() const {\n    assert(isHandleInSync() && \"invalid iterator access!\");\n    assert(Ptr != End && \"dereferencing end() iterator\");\n    if (shouldReverseIterate<KeyT>())\n      return &(Ptr[-1]);\n    return Ptr;\n  }\n\n  friend bool operator==(const DenseMapIterator &LHS,\n                         const DenseMapIterator &RHS) {\n    assert((!LHS.Ptr || LHS.isHandleInSync()) && \"handle not in sync!\");\n    assert((!RHS.Ptr || RHS.isHandleInSync()) && \"handle not in sync!\");\n    assert(LHS.getEpochAddress() == RHS.getEpochAddress() &&\n           \"comparing incomparable iterators!\");\n    return LHS.Ptr == RHS.Ptr;\n  }\n\n  friend bool operator!=(const DenseMapIterator &LHS,\n                         const DenseMapIterator &RHS) {\n    return !(LHS == RHS);\n  }\n\n  inline DenseMapIterator& operator++() {  // Preincrement\n    assert(isHandleInSync() && \"invalid iterator access!\");\n    assert(Ptr != End && \"incrementing end() iterator\");\n    if (shouldReverseIterate<KeyT>()) {\n      --Ptr;\n      RetreatPastEmptyBuckets();\n      return *this;\n    }\n    ++Ptr;\n    AdvancePastEmptyBuckets();\n    return *this;\n  }\n  DenseMapIterator operator++(int) {  // Postincrement\n    assert(isHandleInSync() && \"invalid iterator access!\");\n    DenseMapIterator tmp = *this; ++*this; return tmp;\n  }\n\nprivate:\n  void AdvancePastEmptyBuckets() {\n    assert(Ptr <= End);\n    const KeyT Empty = KeyInfoT::getEmptyKey();\n    const KeyT Tombstone = KeyInfoT::getTombstoneKey();\n\n    while (Ptr != End && (KeyInfoT::isEqual(Ptr->getFirst(), Empty) ||\n                          KeyInfoT::isEqual(Ptr->getFirst(), Tombstone)))\n      ++Ptr;\n  }\n\n  void RetreatPastEmptyBuckets() {\n    assert(Ptr >= End);\n    const KeyT Empty = KeyInfoT::getEmptyKey();\n    const KeyT Tombstone = KeyInfoT::getTombstoneKey();\n\n    while (Ptr != End && (KeyInfoT::isEqual(Ptr[-1].getFirst(), Empty) ||\n                          KeyInfoT::isEqual(Ptr[-1].getFirst(), Tombstone)))\n      --Ptr;\n  }\n};\n\ntemplate <typename KeyT, typename ValueT, typename KeyInfoT>\ninline size_t capacity_in_bytes(const DenseMap<KeyT, ValueT, KeyInfoT> &X) {\n  return X.getMemorySize();\n}\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_DENSEMAP_H\n"}, "5": {"id": 5, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/DenseSet.h", "content": "//===- llvm/ADT/DenseSet.h - Dense probed hash table ------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the DenseSet and SmallDenseSet classes.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_DENSESET_H\n#define LLVM_ADT_DENSESET_H\n\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include \"llvm/Support/type_traits.h\"\n#include <algorithm>\n#include <cstddef>\n#include <initializer_list>\n#include <iterator>\n#include <utility>\n\nnamespace llvm {\n\nnamespace detail {\n\nstruct DenseSetEmpty {};\n\n// Use the empty base class trick so we can create a DenseMap where the buckets\n// contain only a single item.\ntemplate <typename KeyT> class DenseSetPair : public DenseSetEmpty {\n  KeyT key;\n\npublic:\n  KeyT &getFirst() { return key; }\n  const KeyT &getFirst() const { return key; }\n  DenseSetEmpty &getSecond() { return *this; }\n  const DenseSetEmpty &getSecond() const { return *this; }\n};\n\n/// Base class for DenseSet and DenseSmallSet.\n///\n/// MapTy should be either\n///\n///   DenseMap<ValueT, detail::DenseSetEmpty, ValueInfoT,\n///            detail::DenseSetPair<ValueT>>\n///\n/// or the equivalent SmallDenseMap type.  ValueInfoT must implement the\n/// DenseMapInfo \"concept\".\ntemplate <typename ValueT, typename MapTy, typename ValueInfoT>\nclass DenseSetImpl {\n  static_assert(sizeof(typename MapTy::value_type) == sizeof(ValueT),\n                \"DenseMap buckets unexpectedly large!\");\n  MapTy TheMap;\n\n  template <typename T>\n  using const_arg_type_t = typename const_pointer_or_const_ref<T>::type;\n\npublic:\n  using key_type = ValueT;\n  using value_type = ValueT;\n  using size_type = unsigned;\n\n  explicit DenseSetImpl(unsigned InitialReserve = 0) : TheMap(InitialReserve) {}\n\n  template <typename InputIt>\n  DenseSetImpl(const InputIt &I, const InputIt &E)\n      : DenseSetImpl(PowerOf2Ceil(std::distance(I, E))) {\n    insert(I, E);\n  }\n\n  DenseSetImpl(std::initializer_list<ValueT> Elems)\n      : DenseSetImpl(PowerOf2Ceil(Elems.size())) {\n    insert(Elems.begin(), Elems.end());\n  }\n\n  bool empty() const { return TheMap.empty(); }\n  size_type size() const { return TheMap.size(); }\n  size_t getMemorySize() const { return TheMap.getMemorySize(); }\n\n  /// Grow the DenseSet so that it has at least Size buckets. Will not shrink\n  /// the Size of the set.\n  void resize(size_t Size) { TheMap.resize(Size); }\n\n  /// Grow the DenseSet so that it can contain at least \\p NumEntries items\n  /// before resizing again.\n  void reserve(size_t Size) { TheMap.reserve(Size); }\n\n  void clear() {\n    TheMap.clear();\n  }\n\n  /// Return 1 if the specified key is in the set, 0 otherwise.\n  size_type count(const_arg_type_t<ValueT> V) const {\n    return TheMap.count(V);\n  }\n\n  bool erase(const ValueT &V) {\n    return TheMap.erase(V);\n  }\n\n  void swap(DenseSetImpl &RHS) { TheMap.swap(RHS.TheMap); }\n\n  // Iterators.\n\n  class ConstIterator;\n\n  class Iterator {\n    typename MapTy::iterator I;\n    friend class DenseSetImpl;\n    friend class ConstIterator;\n\n  public:\n    using difference_type = typename MapTy::iterator::difference_type;\n    using value_type = ValueT;\n    using pointer = value_type *;\n    using reference = value_type &;\n    using iterator_category = std::forward_iterator_tag;\n\n    Iterator() = default;\n    Iterator(const typename MapTy::iterator &i) : I(i) {}\n\n    ValueT &operator*() { return I->getFirst(); }\n    const ValueT &operator*() const { return I->getFirst(); }\n    ValueT *operator->() { return &I->getFirst(); }\n    const ValueT *operator->() const { return &I->getFirst(); }\n\n    Iterator& operator++() { ++I; return *this; }\n    Iterator operator++(int) { auto T = *this; ++I; return T; }\n    friend bool operator==(const Iterator &X, const Iterator &Y) {\n      return X.I == Y.I;\n    }\n    friend bool operator!=(const Iterator &X, const Iterator &Y) {\n      return X.I != Y.I;\n    }\n  };\n\n  class ConstIterator {\n    typename MapTy::const_iterator I;\n    friend class DenseSetImpl;\n    friend class Iterator;\n\n  public:\n    using difference_type = typename MapTy::const_iterator::difference_type;\n    using value_type = ValueT;\n    using pointer = const value_type *;\n    using reference = const value_type &;\n    using iterator_category = std::forward_iterator_tag;\n\n    ConstIterator() = default;\n    ConstIterator(const Iterator &B) : I(B.I) {}\n    ConstIterator(const typename MapTy::const_iterator &i) : I(i) {}\n\n    const ValueT &operator*() const { return I->getFirst(); }\n    const ValueT *operator->() const { return &I->getFirst(); }\n\n    ConstIterator& operator++() { ++I; return *this; }\n    ConstIterator operator++(int) { auto T = *this; ++I; return T; }\n    friend bool operator==(const ConstIterator &X, const ConstIterator &Y) {\n      return X.I == Y.I;\n    }\n    friend bool operator!=(const ConstIterator &X, const ConstIterator &Y) {\n      return X.I != Y.I;\n    }\n  };\n\n  using iterator = Iterator;\n  using const_iterator = ConstIterator;\n\n  iterator begin() { return Iterator(TheMap.begin()); }\n  iterator end() { return Iterator(TheMap.end()); }\n\n  const_iterator begin() const { return ConstIterator(TheMap.begin()); }\n  const_iterator end() const { return ConstIterator(TheMap.end()); }\n\n  iterator find(const_arg_type_t<ValueT> V) { return Iterator(TheMap.find(V)); }\n  const_iterator find(const_arg_type_t<ValueT> V) const {\n    return ConstIterator(TheMap.find(V));\n  }\n\n  /// Check if the set contains the given element.\n  bool contains(const_arg_type_t<ValueT> V) const {\n    return TheMap.find(V) != TheMap.end();\n  }\n\n  /// Alternative version of find() which allows a different, and possibly less\n  /// expensive, key type.\n  /// The DenseMapInfo is responsible for supplying methods\n  /// getHashValue(LookupKeyT) and isEqual(LookupKeyT, KeyT) for each key type\n  /// used.\n  template <class LookupKeyT>\n  iterator find_as(const LookupKeyT &Val) {\n    return Iterator(TheMap.find_as(Val));\n  }\n  template <class LookupKeyT>\n  const_iterator find_as(const LookupKeyT &Val) const {\n    return ConstIterator(TheMap.find_as(Val));\n  }\n\n  void erase(Iterator I) { return TheMap.erase(I.I); }\n  void erase(ConstIterator CI) { return TheMap.erase(CI.I); }\n\n  std::pair<iterator, bool> insert(const ValueT &V) {\n    detail::DenseSetEmpty Empty;\n    return TheMap.try_emplace(V, Empty);\n  }\n\n  std::pair<iterator, bool> insert(ValueT &&V) {\n    detail::DenseSetEmpty Empty;\n    return TheMap.try_emplace(std::move(V), Empty);\n  }\n\n  /// Alternative version of insert that uses a different (and possibly less\n  /// expensive) key type.\n  template <typename LookupKeyT>\n  std::pair<iterator, bool> insert_as(const ValueT &V,\n                                      const LookupKeyT &LookupKey) {\n    return TheMap.insert_as({V, detail::DenseSetEmpty()}, LookupKey);\n  }\n  template <typename LookupKeyT>\n  std::pair<iterator, bool> insert_as(ValueT &&V, const LookupKeyT &LookupKey) {\n    return TheMap.insert_as({std::move(V), detail::DenseSetEmpty()}, LookupKey);\n  }\n\n  // Range insertion of values.\n  template<typename InputIt>\n  void insert(InputIt I, InputIt E) {\n    for (; I != E; ++I)\n      insert(*I);\n  }\n};\n\n/// Equality comparison for DenseSet.\n///\n/// Iterates over elements of LHS confirming that each element is also a member\n/// of RHS, and that RHS contains no additional values.\n/// Equivalent to N calls to RHS.count. Amortized complexity is linear, worst\n/// case is O(N^2) (if every hash collides).\ntemplate <typename ValueT, typename MapTy, typename ValueInfoT>\nbool operator==(const DenseSetImpl<ValueT, MapTy, ValueInfoT> &LHS,\n                const DenseSetImpl<ValueT, MapTy, ValueInfoT> &RHS) {\n  if (LHS.size() != RHS.size())\n    return false;\n\n  for (auto &E : LHS)\n    if (!RHS.count(E))\n      return false;\n\n  return true;\n}\n\n/// Inequality comparison for DenseSet.\n///\n/// Equivalent to !(LHS == RHS). See operator== for performance notes.\ntemplate <typename ValueT, typename MapTy, typename ValueInfoT>\nbool operator!=(const DenseSetImpl<ValueT, MapTy, ValueInfoT> &LHS,\n                const DenseSetImpl<ValueT, MapTy, ValueInfoT> &RHS) {\n  return !(LHS == RHS);\n}\n\n} // end namespace detail\n\n/// Implements a dense probed hash-table based set.\ntemplate <typename ValueT, typename ValueInfoT = DenseMapInfo<ValueT>>\nclass DenseSet : public detail::DenseSetImpl<\n                     ValueT, DenseMap<ValueT, detail::DenseSetEmpty, ValueInfoT,\n                                      detail::DenseSetPair<ValueT>>,\n                     ValueInfoT> {\n  using BaseT =\n      detail::DenseSetImpl<ValueT,\n                           DenseMap<ValueT, detail::DenseSetEmpty, ValueInfoT,\n                                    detail::DenseSetPair<ValueT>>,\n                           ValueInfoT>;\n\npublic:\n  using BaseT::BaseT;\n};\n\n/// Implements a dense probed hash-table based set with some number of buckets\n/// stored inline.\ntemplate <typename ValueT, unsigned InlineBuckets = 4,\n          typename ValueInfoT = DenseMapInfo<ValueT>>\nclass SmallDenseSet\n    : public detail::DenseSetImpl<\n          ValueT, SmallDenseMap<ValueT, detail::DenseSetEmpty, InlineBuckets,\n                                ValueInfoT, detail::DenseSetPair<ValueT>>,\n          ValueInfoT> {\n  using BaseT = detail::DenseSetImpl<\n      ValueT, SmallDenseMap<ValueT, detail::DenseSetEmpty, InlineBuckets,\n                            ValueInfoT, detail::DenseSetPair<ValueT>>,\n      ValueInfoT>;\n\npublic:\n  using BaseT::BaseT;\n};\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_DENSESET_H\n"}, "11": {"id": 11, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/STLExtras.h", "content": "//===- llvm/ADT/STLExtras.h - Useful STL related functions ------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file contains some templates that are useful if you are working with the\n// STL at all.\n//\n// No library is required when using these functions.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_STLEXTRAS_H\n#define LLVM_ADT_STLEXTRAS_H\n\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Config/abi-breaking.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <cstdlib>\n#include <functional>\n#include <initializer_list>\n#include <iterator>\n#include <limits>\n#include <memory>\n#include <tuple>\n#include <type_traits>\n#include <utility>\n\n#ifdef EXPENSIVE_CHECKS\n#include <random> // for std::mt19937\n#endif\n\nnamespace llvm {\n\n// Only used by compiler if both template types are the same.  Useful when\n// using SFINAE to test for the existence of member functions.\ntemplate <typename T, T> struct SameType;\n\nnamespace detail {\n\ntemplate <typename RangeT>\nusing IterOfRange = decltype(std::begin(std::declval<RangeT &>()));\n\ntemplate <typename RangeT>\nusing ValueOfRange = typename std::remove_reference<decltype(\n    *std::begin(std::declval<RangeT &>()))>::type;\n\n} // end namespace detail\n\n//===----------------------------------------------------------------------===//\n//     Extra additions to <type_traits>\n//===----------------------------------------------------------------------===//\n\ntemplate <typename T>\nstruct negation : std::integral_constant<bool, !bool(T::value)> {};\n\ntemplate <typename...> struct conjunction : std::true_type {};\ntemplate <typename B1> struct conjunction<B1> : B1 {};\ntemplate <typename B1, typename... Bn>\nstruct conjunction<B1, Bn...>\n    : std::conditional<bool(B1::value), conjunction<Bn...>, B1>::type {};\n\ntemplate <typename T> struct make_const_ptr {\n  using type =\n      typename std::add_pointer<typename std::add_const<T>::type>::type;\n};\n\ntemplate <typename T> struct make_const_ref {\n  using type = typename std::add_lvalue_reference<\n      typename std::add_const<T>::type>::type;\n};\n\n/// Utilities for detecting if a given trait holds for some set of arguments\n/// 'Args'. For example, the given trait could be used to detect if a given type\n/// has a copy assignment operator:\n///   template<class T>\n///   using has_copy_assign_t = decltype(std::declval<T&>()\n///                                                 = std::declval<const T&>());\n///   bool fooHasCopyAssign = is_detected<has_copy_assign_t, FooClass>::value;\nnamespace detail {\ntemplate <typename...> using void_t = void;\ntemplate <class, template <class...> class Op, class... Args> struct detector {\n  using value_t = std::false_type;\n};\ntemplate <template <class...> class Op, class... Args>\nstruct detector<void_t<Op<Args...>>, Op, Args...> {\n  using value_t = std::true_type;\n};\n} // end namespace detail\n\ntemplate <template <class...> class Op, class... Args>\nusing is_detected = typename detail::detector<void, Op, Args...>::value_t;\n\n/// Check if a Callable type can be invoked with the given set of arg types.\nnamespace detail {\ntemplate <typename Callable, typename... Args>\nusing is_invocable =\n    decltype(std::declval<Callable &>()(std::declval<Args>()...));\n} // namespace detail\n\ntemplate <typename Callable, typename... Args>\nusing is_invocable = is_detected<detail::is_invocable, Callable, Args...>;\n\n/// This class provides various trait information about a callable object.\n///   * To access the number of arguments: Traits::num_args\n///   * To access the type of an argument: Traits::arg_t<Index>\n///   * To access the type of the result:  Traits::result_t\ntemplate <typename T, bool isClass = std::is_class<T>::value>\nstruct function_traits : public function_traits<decltype(&T::operator())> {};\n\n/// Overload for class function types.\ntemplate <typename ClassType, typename ReturnType, typename... Args>\nstruct function_traits<ReturnType (ClassType::*)(Args...) const, false> {\n  /// The number of arguments to this function.\n  enum { num_args = sizeof...(Args) };\n\n  /// The result type of this function.\n  using result_t = ReturnType;\n\n  /// The type of an argument to this function.\n  template <size_t Index>\n  using arg_t = typename std::tuple_element<Index, std::tuple<Args...>>::type;\n};\n/// Overload for class function types.\ntemplate <typename ClassType, typename ReturnType, typename... Args>\nstruct function_traits<ReturnType (ClassType::*)(Args...), false>\n    : function_traits<ReturnType (ClassType::*)(Args...) const> {};\n/// Overload for non-class function types.\ntemplate <typename ReturnType, typename... Args>\nstruct function_traits<ReturnType (*)(Args...), false> {\n  /// The number of arguments to this function.\n  enum { num_args = sizeof...(Args) };\n\n  /// The result type of this function.\n  using result_t = ReturnType;\n\n  /// The type of an argument to this function.\n  template <size_t i>\n  using arg_t = typename std::tuple_element<i, std::tuple<Args...>>::type;\n};\n/// Overload for non-class function type references.\ntemplate <typename ReturnType, typename... Args>\nstruct function_traits<ReturnType (&)(Args...), false>\n    : public function_traits<ReturnType (*)(Args...)> {};\n\n//===----------------------------------------------------------------------===//\n//     Extra additions to <functional>\n//===----------------------------------------------------------------------===//\n\ntemplate <class Ty> struct identity {\n  using argument_type = Ty;\n\n  Ty &operator()(Ty &self) const {\n    return self;\n  }\n  const Ty &operator()(const Ty &self) const {\n    return self;\n  }\n};\n\n/// An efficient, type-erasing, non-owning reference to a callable. This is\n/// intended for use as the type of a function parameter that is not used\n/// after the function in question returns.\n///\n/// This class does not own the callable, so it is not in general safe to store\n/// a function_ref.\ntemplate<typename Fn> class function_ref;\n\ntemplate<typename Ret, typename ...Params>\nclass function_ref<Ret(Params...)> {\n  Ret (*callback)(intptr_t callable, Params ...params) = nullptr;\n  intptr_t callable;\n\n  template<typename Callable>\n  static Ret callback_fn(intptr_t callable, Params ...params) {\n    return (*reinterpret_cast<Callable*>(callable))(\n        std::forward<Params>(params)...);\n  }\n\npublic:\n  function_ref() = default;\n  function_ref(std::nullptr_t) {}\n\n  template <typename Callable>\n  function_ref(\n      Callable &&callable,\n      // This is not the copy-constructor.\n      std::enable_if_t<\n          !std::is_same<std::remove_cv_t<std::remove_reference_t<Callable>>,\n                        function_ref>::value> * = nullptr,\n      // Functor must be callable and return a suitable type.\n      std::enable_if_t<std::is_void<Ret>::value ||\n                       std::is_convertible<decltype(std::declval<Callable>()(\n                                               std::declval<Params>()...)),\n                                           Ret>::value> * = nullptr)\n      : callback(callback_fn<typename std::remove_reference<Callable>::type>),\n        callable(reinterpret_cast<intptr_t>(&callable)) {}\n\n  Ret operator()(Params ...params) const {\n    return callback(callable, std::forward<Params>(params)...);\n  }\n\n  explicit operator bool() const { return callback; }\n};\n\n//===----------------------------------------------------------------------===//\n//     Extra additions to <iterator>\n//===----------------------------------------------------------------------===//\n\nnamespace adl_detail {\n\nusing std::begin;\n\ntemplate <typename ContainerTy>\ndecltype(auto) adl_begin(ContainerTy &&container) {\n  return begin(std::forward<ContainerTy>(container));\n}\n\nusing std::end;\n\ntemplate <typename ContainerTy>\ndecltype(auto) adl_end(ContainerTy &&container) {\n  return end(std::forward<ContainerTy>(container));\n}\n\nusing std::swap;\n\ntemplate <typename T>\nvoid adl_swap(T &&lhs, T &&rhs) noexcept(noexcept(swap(std::declval<T>(),\n                                                       std::declval<T>()))) {\n  swap(std::forward<T>(lhs), std::forward<T>(rhs));\n}\n\n} // end namespace adl_detail\n\ntemplate <typename ContainerTy>\ndecltype(auto) adl_begin(ContainerTy &&container) {\n  return adl_detail::adl_begin(std::forward<ContainerTy>(container));\n}\n\ntemplate <typename ContainerTy>\ndecltype(auto) adl_end(ContainerTy &&container) {\n  return adl_detail::adl_end(std::forward<ContainerTy>(container));\n}\n\ntemplate <typename T>\nvoid adl_swap(T &&lhs, T &&rhs) noexcept(\n    noexcept(adl_detail::adl_swap(std::declval<T>(), std::declval<T>()))) {\n  adl_detail::adl_swap(std::forward<T>(lhs), std::forward<T>(rhs));\n}\n\n/// Test whether \\p RangeOrContainer is empty. Similar to C++17 std::empty.\ntemplate <typename T>\nconstexpr bool empty(const T &RangeOrContainer) {\n  return adl_begin(RangeOrContainer) == adl_end(RangeOrContainer);\n}\n\n/// Returns true if the given container only contains a single element.\ntemplate <typename ContainerTy> bool hasSingleElement(ContainerTy &&C) {\n  auto B = std::begin(C), E = std::end(C);\n  return B != E && std::next(B) == E;\n}\n\n/// Return a range covering \\p RangeOrContainer with the first N elements\n/// excluded.\ntemplate <typename T> auto drop_begin(T &&RangeOrContainer, size_t N = 1) {\n  return make_range(std::next(adl_begin(RangeOrContainer), N),\n                    adl_end(RangeOrContainer));\n}\n\n// mapped_iterator - This is a simple iterator adapter that causes a function to\n// be applied whenever operator* is invoked on the iterator.\n\ntemplate <typename ItTy, typename FuncTy,\n          typename FuncReturnTy =\n            decltype(std::declval<FuncTy>()(*std::declval<ItTy>()))>\nclass mapped_iterator\n    : public iterator_adaptor_base<\n             mapped_iterator<ItTy, FuncTy>, ItTy,\n             typename std::iterator_traits<ItTy>::iterator_category,\n             typename std::remove_reference<FuncReturnTy>::type> {\npublic:\n  mapped_iterator(ItTy U, FuncTy F)\n    : mapped_iterator::iterator_adaptor_base(std::move(U)), F(std::move(F)) {}\n\n  ItTy getCurrent() { return this->I; }\n\n  FuncReturnTy operator*() const { return F(*this->I); }\n\nprivate:\n  FuncTy F;\n};\n\n// map_iterator - Provide a convenient way to create mapped_iterators, just like\n// make_pair is useful for creating pairs...\ntemplate <class ItTy, class FuncTy>\ninline mapped_iterator<ItTy, FuncTy> map_iterator(ItTy I, FuncTy F) {\n  return mapped_iterator<ItTy, FuncTy>(std::move(I), std::move(F));\n}\n\ntemplate <class ContainerTy, class FuncTy>\nauto map_range(ContainerTy &&C, FuncTy F) {\n  return make_range(map_iterator(C.begin(), F), map_iterator(C.end(), F));\n}\n\n/// Helper to determine if type T has a member called rbegin().\ntemplate <typename Ty> class has_rbegin_impl {\n  using yes = char[1];\n  using no = char[2];\n\n  template <typename Inner>\n  static yes& test(Inner *I, decltype(I->rbegin()) * = nullptr);\n\n  template <typename>\n  static no& test(...);\n\npublic:\n  static const bool value = sizeof(test<Ty>(nullptr)) == sizeof(yes);\n};\n\n/// Metafunction to determine if T& or T has a member called rbegin().\ntemplate <typename Ty>\nstruct has_rbegin : has_rbegin_impl<typename std::remove_reference<Ty>::type> {\n};\n\n// Returns an iterator_range over the given container which iterates in reverse.\n// Note that the container must have rbegin()/rend() methods for this to work.\ntemplate <typename ContainerTy>\nauto reverse(ContainerTy &&C,\n             std::enable_if_t<has_rbegin<ContainerTy>::value> * = nullptr) {\n  return make_range(C.rbegin(), C.rend());\n}\n\n// Returns a std::reverse_iterator wrapped around the given iterator.\ntemplate <typename IteratorTy>\nstd::reverse_iterator<IteratorTy> make_reverse_iterator(IteratorTy It) {\n  return std::reverse_iterator<IteratorTy>(It);\n}\n\n// Returns an iterator_range over the given container which iterates in reverse.\n// Note that the container must have begin()/end() methods which return\n// bidirectional iterators for this to work.\ntemplate <typename ContainerTy>\nauto reverse(ContainerTy &&C,\n             std::enable_if_t<!has_rbegin<ContainerTy>::value> * = nullptr) {\n  return make_range(llvm::make_reverse_iterator(std::end(C)),\n                    llvm::make_reverse_iterator(std::begin(C)));\n}\n\n/// An iterator adaptor that filters the elements of given inner iterators.\n///\n/// The predicate parameter should be a callable object that accepts the wrapped\n/// iterator's reference type and returns a bool. When incrementing or\n/// decrementing the iterator, it will call the predicate on each element and\n/// skip any where it returns false.\n///\n/// \\code\n///   int A[] = { 1, 2, 3, 4 };\n///   auto R = make_filter_range(A, [](int N) { return N % 2 == 1; });\n///   // R contains { 1, 3 }.\n/// \\endcode\n///\n/// Note: filter_iterator_base implements support for forward iteration.\n/// filter_iterator_impl exists to provide support for bidirectional iteration,\n/// conditional on whether the wrapped iterator supports it.\ntemplate <typename WrappedIteratorT, typename PredicateT, typename IterTag>\nclass filter_iterator_base\n    : public iterator_adaptor_base<\n          filter_iterator_base<WrappedIteratorT, PredicateT, IterTag>,\n          WrappedIteratorT,\n          typename std::common_type<\n              IterTag, typename std::iterator_traits<\n                           WrappedIteratorT>::iterator_category>::type> {\n  using BaseT = iterator_adaptor_base<\n      filter_iterator_base<WrappedIteratorT, PredicateT, IterTag>,\n      WrappedIteratorT,\n      typename std::common_type<\n          IterTag, typename std::iterator_traits<\n                       WrappedIteratorT>::iterator_category>::type>;\n\nprotected:\n  WrappedIteratorT End;\n  PredicateT Pred;\n\n  void findNextValid() {\n    while (this->I != End && !Pred(*this->I))\n      BaseT::operator++();\n  }\n\n  // Construct the iterator. The begin iterator needs to know where the end\n  // is, so that it can properly stop when it gets there. The end iterator only\n  // needs the predicate to support bidirectional iteration.\n  filter_iterator_base(WrappedIteratorT Begin, WrappedIteratorT End,\n                       PredicateT Pred)\n      : BaseT(Begin), End(End), Pred(Pred) {\n    findNextValid();\n  }\n\npublic:\n  using BaseT::operator++;\n\n  filter_iterator_base &operator++() {\n    BaseT::operator++();\n    findNextValid();\n    return *this;\n  }\n};\n\n/// Specialization of filter_iterator_base for forward iteration only.\ntemplate <typename WrappedIteratorT, typename PredicateT,\n          typename IterTag = std::forward_iterator_tag>\nclass filter_iterator_impl\n    : public filter_iterator_base<WrappedIteratorT, PredicateT, IterTag> {\n  using BaseT = filter_iterator_base<WrappedIteratorT, PredicateT, IterTag>;\n\npublic:\n  filter_iterator_impl(WrappedIteratorT Begin, WrappedIteratorT End,\n                       PredicateT Pred)\n      : BaseT(Begin, End, Pred) {}\n};\n\n/// Specialization of filter_iterator_base for bidirectional iteration.\ntemplate <typename WrappedIteratorT, typename PredicateT>\nclass filter_iterator_impl<WrappedIteratorT, PredicateT,\n                           std::bidirectional_iterator_tag>\n    : public filter_iterator_base<WrappedIteratorT, PredicateT,\n                                  std::bidirectional_iterator_tag> {\n  using BaseT = filter_iterator_base<WrappedIteratorT, PredicateT,\n                                     std::bidirectional_iterator_tag>;\n  void findPrevValid() {\n    while (!this->Pred(*this->I))\n      BaseT::operator--();\n  }\n\npublic:\n  using BaseT::operator--;\n\n  filter_iterator_impl(WrappedIteratorT Begin, WrappedIteratorT End,\n                       PredicateT Pred)\n      : BaseT(Begin, End, Pred) {}\n\n  filter_iterator_impl &operator--() {\n    BaseT::operator--();\n    findPrevValid();\n    return *this;\n  }\n};\n\nnamespace detail {\n\ntemplate <bool is_bidirectional> struct fwd_or_bidi_tag_impl {\n  using type = std::forward_iterator_tag;\n};\n\ntemplate <> struct fwd_or_bidi_tag_impl<true> {\n  using type = std::bidirectional_iterator_tag;\n};\n\n/// Helper which sets its type member to forward_iterator_tag if the category\n/// of \\p IterT does not derive from bidirectional_iterator_tag, and to\n/// bidirectional_iterator_tag otherwise.\ntemplate <typename IterT> struct fwd_or_bidi_tag {\n  using type = typename fwd_or_bidi_tag_impl<std::is_base_of<\n      std::bidirectional_iterator_tag,\n      typename std::iterator_traits<IterT>::iterator_category>::value>::type;\n};\n\n} // namespace detail\n\n/// Defines filter_iterator to a suitable specialization of\n/// filter_iterator_impl, based on the underlying iterator's category.\ntemplate <typename WrappedIteratorT, typename PredicateT>\nusing filter_iterator = filter_iterator_impl<\n    WrappedIteratorT, PredicateT,\n    typename detail::fwd_or_bidi_tag<WrappedIteratorT>::type>;\n\n/// Convenience function that takes a range of elements and a predicate,\n/// and return a new filter_iterator range.\n///\n/// FIXME: Currently if RangeT && is a rvalue reference to a temporary, the\n/// lifetime of that temporary is not kept by the returned range object, and the\n/// temporary is going to be dropped on the floor after the make_iterator_range\n/// full expression that contains this function call.\ntemplate <typename RangeT, typename PredicateT>\niterator_range<filter_iterator<detail::IterOfRange<RangeT>, PredicateT>>\nmake_filter_range(RangeT &&Range, PredicateT Pred) {\n  using FilterIteratorT =\n      filter_iterator<detail::IterOfRange<RangeT>, PredicateT>;\n  return make_range(\n      FilterIteratorT(std::begin(std::forward<RangeT>(Range)),\n                      std::end(std::forward<RangeT>(Range)), Pred),\n      FilterIteratorT(std::end(std::forward<RangeT>(Range)),\n                      std::end(std::forward<RangeT>(Range)), Pred));\n}\n\n/// A pseudo-iterator adaptor that is designed to implement \"early increment\"\n/// style loops.\n///\n/// This is *not a normal iterator* and should almost never be used directly. It\n/// is intended primarily to be used with range based for loops and some range\n/// algorithms.\n///\n/// The iterator isn't quite an `OutputIterator` or an `InputIterator` but\n/// somewhere between them. The constraints of these iterators are:\n///\n/// - On construction or after being incremented, it is comparable and\n///   dereferencable. It is *not* incrementable.\n/// - After being dereferenced, it is neither comparable nor dereferencable, it\n///   is only incrementable.\n///\n/// This means you can only dereference the iterator once, and you can only\n/// increment it once between dereferences.\ntemplate <typename WrappedIteratorT>\nclass early_inc_iterator_impl\n    : public iterator_adaptor_base<early_inc_iterator_impl<WrappedIteratorT>,\n                                   WrappedIteratorT, std::input_iterator_tag> {\n  using BaseT =\n      iterator_adaptor_base<early_inc_iterator_impl<WrappedIteratorT>,\n                            WrappedIteratorT, std::input_iterator_tag>;\n\n  using PointerT = typename std::iterator_traits<WrappedIteratorT>::pointer;\n\nprotected:\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n  bool IsEarlyIncremented = false;\n#endif\n\npublic:\n  early_inc_iterator_impl(WrappedIteratorT I) : BaseT(I) {}\n\n  using BaseT::operator*;\n  decltype(*std::declval<WrappedIteratorT>()) operator*() {\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n    assert(!IsEarlyIncremented && \"Cannot dereference twice!\");\n    IsEarlyIncremented = true;\n#endif\n    return *(this->I)++;\n  }\n\n  using BaseT::operator++;\n  early_inc_iterator_impl &operator++() {\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n    assert(IsEarlyIncremented && \"Cannot increment before dereferencing!\");\n    IsEarlyIncremented = false;\n#endif\n    return *this;\n  }\n\n  friend bool operator==(const early_inc_iterator_impl &LHS,\n                         const early_inc_iterator_impl &RHS) {\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n    assert(!LHS.IsEarlyIncremented && \"Cannot compare after dereferencing!\");\n#endif\n    return (const BaseT &)LHS == (const BaseT &)RHS;\n  }\n};\n\n/// Make a range that does early increment to allow mutation of the underlying\n/// range without disrupting iteration.\n///\n/// The underlying iterator will be incremented immediately after it is\n/// dereferenced, allowing deletion of the current node or insertion of nodes to\n/// not disrupt iteration provided they do not invalidate the *next* iterator --\n/// the current iterator can be invalidated.\n///\n/// This requires a very exact pattern of use that is only really suitable to\n/// range based for loops and other range algorithms that explicitly guarantee\n/// to dereference exactly once each element, and to increment exactly once each\n/// element.\ntemplate <typename RangeT>\niterator_range<early_inc_iterator_impl<detail::IterOfRange<RangeT>>>\nmake_early_inc_range(RangeT &&Range) {\n  using EarlyIncIteratorT =\n      early_inc_iterator_impl<detail::IterOfRange<RangeT>>;\n  return make_range(EarlyIncIteratorT(std::begin(std::forward<RangeT>(Range))),\n                    EarlyIncIteratorT(std::end(std::forward<RangeT>(Range))));\n}\n\n// forward declarations required by zip_shortest/zip_first/zip_longest\ntemplate <typename R, typename UnaryPredicate>\nbool all_of(R &&range, UnaryPredicate P);\ntemplate <typename R, typename UnaryPredicate>\nbool any_of(R &&range, UnaryPredicate P);\n\nnamespace detail {\n\nusing std::declval;\n\n// We have to alias this since inlining the actual type at the usage site\n// in the parameter list of iterator_facade_base<> below ICEs MSVC 2017.\ntemplate<typename... Iters> struct ZipTupleType {\n  using type = std::tuple<decltype(*declval<Iters>())...>;\n};\n\ntemplate <typename ZipType, typename... Iters>\nusing zip_traits = iterator_facade_base<\n    ZipType, typename std::common_type<std::bidirectional_iterator_tag,\n                                       typename std::iterator_traits<\n                                           Iters>::iterator_category...>::type,\n    // ^ TODO: Implement random access methods.\n    typename ZipTupleType<Iters...>::type,\n    typename std::iterator_traits<typename std::tuple_element<\n        0, std::tuple<Iters...>>::type>::difference_type,\n    // ^ FIXME: This follows boost::make_zip_iterator's assumption that all\n    // inner iterators have the same difference_type. It would fail if, for\n    // instance, the second field's difference_type were non-numeric while the\n    // first is.\n    typename ZipTupleType<Iters...>::type *,\n    typename ZipTupleType<Iters...>::type>;\n\ntemplate <typename ZipType, typename... Iters>\nstruct zip_common : public zip_traits<ZipType, Iters...> {\n  using Base = zip_traits<ZipType, Iters...>;\n  using value_type = typename Base::value_type;\n\n  std::tuple<Iters...> iterators;\n\nprotected:\n  template <size_t... Ns> value_type deref(std::index_sequence<Ns...>) const {\n    return value_type(*std::get<Ns>(iterators)...);\n  }\n\n  template <size_t... Ns>\n  decltype(iterators) tup_inc(std::index_sequence<Ns...>) const {\n    return std::tuple<Iters...>(std::next(std::get<Ns>(iterators))...);\n  }\n\n  template <size_t... Ns>\n  decltype(iterators) tup_dec(std::index_sequence<Ns...>) const {\n    return std::tuple<Iters...>(std::prev(std::get<Ns>(iterators))...);\n  }\n\npublic:\n  zip_common(Iters &&... ts) : iterators(std::forward<Iters>(ts)...) {}\n\n  value_type operator*() { return deref(std::index_sequence_for<Iters...>{}); }\n\n  const value_type operator*() const {\n    return deref(std::index_sequence_for<Iters...>{});\n  }\n\n  ZipType &operator++() {\n    iterators = tup_inc(std::index_sequence_for<Iters...>{});\n    return *reinterpret_cast<ZipType *>(this);\n  }\n\n  ZipType &operator--() {\n    static_assert(Base::IsBidirectional,\n                  \"All inner iterators must be at least bidirectional.\");\n    iterators = tup_dec(std::index_sequence_for<Iters...>{});\n    return *reinterpret_cast<ZipType *>(this);\n  }\n};\n\ntemplate <typename... Iters>\nstruct zip_first : public zip_common<zip_first<Iters...>, Iters...> {\n  using Base = zip_common<zip_first<Iters...>, Iters...>;\n\n  bool operator==(const zip_first<Iters...> &other) const {\n    return std::get<0>(this->iterators) == std::get<0>(other.iterators);\n  }\n\n  zip_first(Iters &&... ts) : Base(std::forward<Iters>(ts)...) {}\n};\n\ntemplate <typename... Iters>\nclass zip_shortest : public zip_common<zip_shortest<Iters...>, Iters...> {\n  template <size_t... Ns>\n  bool test(const zip_shortest<Iters...> &other,\n            std::index_sequence<Ns...>) const {\n    return all_of(std::initializer_list<bool>{std::get<Ns>(this->iterators) !=\n                                              std::get<Ns>(other.iterators)...},\n                  identity<bool>{});\n  }\n\npublic:\n  using Base = zip_common<zip_shortest<Iters...>, Iters...>;\n\n  zip_shortest(Iters &&... ts) : Base(std::forward<Iters>(ts)...) {}\n\n  bool operator==(const zip_shortest<Iters...> &other) const {\n    return !test(other, std::index_sequence_for<Iters...>{});\n  }\n};\n\ntemplate <template <typename...> class ItType, typename... Args> class zippy {\npublic:\n  using iterator = ItType<decltype(std::begin(std::declval<Args>()))...>;\n  using iterator_category = typename iterator::iterator_category;\n  using value_type = typename iterator::value_type;\n  using difference_type = typename iterator::difference_type;\n  using pointer = typename iterator::pointer;\n  using reference = typename iterator::reference;\n\nprivate:\n  std::tuple<Args...> ts;\n\n  template <size_t... Ns>\n  iterator begin_impl(std::index_sequence<Ns...>) const {\n    return iterator(std::begin(std::get<Ns>(ts))...);\n  }\n  template <size_t... Ns> iterator end_impl(std::index_sequence<Ns...>) const {\n    return iterator(std::end(std::get<Ns>(ts))...);\n  }\n\npublic:\n  zippy(Args &&... ts_) : ts(std::forward<Args>(ts_)...) {}\n\n  iterator begin() const {\n    return begin_impl(std::index_sequence_for<Args...>{});\n  }\n  iterator end() const { return end_impl(std::index_sequence_for<Args...>{}); }\n};\n\n} // end namespace detail\n\n/// zip iterator for two or more iteratable types.\ntemplate <typename T, typename U, typename... Args>\ndetail::zippy<detail::zip_shortest, T, U, Args...> zip(T &&t, U &&u,\n                                                       Args &&... args) {\n  return detail::zippy<detail::zip_shortest, T, U, Args...>(\n      std::forward<T>(t), std::forward<U>(u), std::forward<Args>(args)...);\n}\n\n/// zip iterator that, for the sake of efficiency, assumes the first iteratee to\n/// be the shortest.\ntemplate <typename T, typename U, typename... Args>\ndetail::zippy<detail::zip_first, T, U, Args...> zip_first(T &&t, U &&u,\n                                                          Args &&... args) {\n  return detail::zippy<detail::zip_first, T, U, Args...>(\n      std::forward<T>(t), std::forward<U>(u), std::forward<Args>(args)...);\n}\n\nnamespace detail {\ntemplate <typename Iter>\nIter next_or_end(const Iter &I, const Iter &End) {\n  if (I == End)\n    return End;\n  return std::next(I);\n}\n\ntemplate <typename Iter>\nauto deref_or_none(const Iter &I, const Iter &End) -> llvm::Optional<\n    std::remove_const_t<std::remove_reference_t<decltype(*I)>>> {\n  if (I == End)\n    return None;\n  return *I;\n}\n\ntemplate <typename Iter> struct ZipLongestItemType {\n  using type =\n      llvm::Optional<typename std::remove_const<typename std::remove_reference<\n          decltype(*std::declval<Iter>())>::type>::type>;\n};\n\ntemplate <typename... Iters> struct ZipLongestTupleType {\n  using type = std::tuple<typename ZipLongestItemType<Iters>::type...>;\n};\n\ntemplate <typename... Iters>\nclass zip_longest_iterator\n    : public iterator_facade_base<\n          zip_longest_iterator<Iters...>,\n          typename std::common_type<\n              std::forward_iterator_tag,\n              typename std::iterator_traits<Iters>::iterator_category...>::type,\n          typename ZipLongestTupleType<Iters...>::type,\n          typename std::iterator_traits<typename std::tuple_element<\n              0, std::tuple<Iters...>>::type>::difference_type,\n          typename ZipLongestTupleType<Iters...>::type *,\n          typename ZipLongestTupleType<Iters...>::type> {\npublic:\n  using value_type = typename ZipLongestTupleType<Iters...>::type;\n\nprivate:\n  std::tuple<Iters...> iterators;\n  std::tuple<Iters...> end_iterators;\n\n  template <size_t... Ns>\n  bool test(const zip_longest_iterator<Iters...> &other,\n            std::index_sequence<Ns...>) const {\n    return llvm::any_of(\n        std::initializer_list<bool>{std::get<Ns>(this->iterators) !=\n                                    std::get<Ns>(other.iterators)...},\n        identity<bool>{});\n  }\n\n  template <size_t... Ns> value_type deref(std::index_sequence<Ns...>) const {\n    return value_type(\n        deref_or_none(std::get<Ns>(iterators), std::get<Ns>(end_iterators))...);\n  }\n\n  template <size_t... Ns>\n  decltype(iterators) tup_inc(std::index_sequence<Ns...>) const {\n    return std::tuple<Iters...>(\n        next_or_end(std::get<Ns>(iterators), std::get<Ns>(end_iterators))...);\n  }\n\npublic:\n  zip_longest_iterator(std::pair<Iters &&, Iters &&>... ts)\n      : iterators(std::forward<Iters>(ts.first)...),\n        end_iterators(std::forward<Iters>(ts.second)...) {}\n\n  value_type operator*() { return deref(std::index_sequence_for<Iters...>{}); }\n\n  value_type operator*() const {\n    return deref(std::index_sequence_for<Iters...>{});\n  }\n\n  zip_longest_iterator<Iters...> &operator++() {\n    iterators = tup_inc(std::index_sequence_for<Iters...>{});\n    return *this;\n  }\n\n  bool operator==(const zip_longest_iterator<Iters...> &other) const {\n    return !test(other, std::index_sequence_for<Iters...>{});\n  }\n};\n\ntemplate <typename... Args> class zip_longest_range {\npublic:\n  using iterator =\n      zip_longest_iterator<decltype(adl_begin(std::declval<Args>()))...>;\n  using iterator_category = typename iterator::iterator_category;\n  using value_type = typename iterator::value_type;\n  using difference_type = typename iterator::difference_type;\n  using pointer = typename iterator::pointer;\n  using reference = typename iterator::reference;\n\nprivate:\n  std::tuple<Args...> ts;\n\n  template <size_t... Ns>\n  iterator begin_impl(std::index_sequence<Ns...>) const {\n    return iterator(std::make_pair(adl_begin(std::get<Ns>(ts)),\n                                   adl_end(std::get<Ns>(ts)))...);\n  }\n\n  template <size_t... Ns> iterator end_impl(std::index_sequence<Ns...>) const {\n    return iterator(std::make_pair(adl_end(std::get<Ns>(ts)),\n                                   adl_end(std::get<Ns>(ts)))...);\n  }\n\npublic:\n  zip_longest_range(Args &&... ts_) : ts(std::forward<Args>(ts_)...) {}\n\n  iterator begin() const {\n    return begin_impl(std::index_sequence_for<Args...>{});\n  }\n  iterator end() const { return end_impl(std::index_sequence_for<Args...>{}); }\n};\n} // namespace detail\n\n/// Iterate over two or more iterators at the same time. Iteration continues\n/// until all iterators reach the end. The llvm::Optional only contains a value\n/// if the iterator has not reached the end.\ntemplate <typename T, typename U, typename... Args>\ndetail::zip_longest_range<T, U, Args...> zip_longest(T &&t, U &&u,\n                                                     Args &&... args) {\n  return detail::zip_longest_range<T, U, Args...>(\n      std::forward<T>(t), std::forward<U>(u), std::forward<Args>(args)...);\n}\n\n/// Iterator wrapper that concatenates sequences together.\n///\n/// This can concatenate different iterators, even with different types, into\n/// a single iterator provided the value types of all the concatenated\n/// iterators expose `reference` and `pointer` types that can be converted to\n/// `ValueT &` and `ValueT *` respectively. It doesn't support more\n/// interesting/customized pointer or reference types.\n///\n/// Currently this only supports forward or higher iterator categories as\n/// inputs and always exposes a forward iterator interface.\ntemplate <typename ValueT, typename... IterTs>\nclass concat_iterator\n    : public iterator_facade_base<concat_iterator<ValueT, IterTs...>,\n                                  std::forward_iterator_tag, ValueT> {\n  using BaseT = typename concat_iterator::iterator_facade_base;\n\n  /// We store both the current and end iterators for each concatenated\n  /// sequence in a tuple of pairs.\n  ///\n  /// Note that something like iterator_range seems nice at first here, but the\n  /// range properties are of little benefit and end up getting in the way\n  /// because we need to do mutation on the current iterators.\n  std::tuple<IterTs...> Begins;\n  std::tuple<IterTs...> Ends;\n\n  /// Attempts to increment a specific iterator.\n  ///\n  /// Returns true if it was able to increment the iterator. Returns false if\n  /// the iterator is already at the end iterator.\n  template <size_t Index> bool incrementHelper() {\n    auto &Begin = std::get<Index>(Begins);\n    auto &End = std::get<Index>(Ends);\n    if (Begin == End)\n      return false;\n\n    ++Begin;\n    return true;\n  }\n\n  /// Increments the first non-end iterator.\n  ///\n  /// It is an error to call this with all iterators at the end.\n  template <size_t... Ns> void increment(std::index_sequence<Ns...>) {\n    // Build a sequence of functions to increment each iterator if possible.\n    bool (concat_iterator::*IncrementHelperFns[])() = {\n        &concat_iterator::incrementHelper<Ns>...};\n\n    // Loop over them, and stop as soon as we succeed at incrementing one.\n    for (auto &IncrementHelperFn : IncrementHelperFns)\n      if ((this->*IncrementHelperFn)())\n        return;\n\n    llvm_unreachable(\"Attempted to increment an end concat iterator!\");\n  }\n\n  /// Returns null if the specified iterator is at the end. Otherwise,\n  /// dereferences the iterator and returns the address of the resulting\n  /// reference.\n  template <size_t Index> ValueT *getHelper() const {\n    auto &Begin = std::get<Index>(Begins);\n    auto &End = std::get<Index>(Ends);\n    if (Begin == End)\n      return nullptr;\n\n    return &*Begin;\n  }\n\n  /// Finds the first non-end iterator, dereferences, and returns the resulting\n  /// reference.\n  ///\n  /// It is an error to call this with all iterators at the end.\n  template <size_t... Ns> ValueT &get(std::index_sequence<Ns...>) const {\n    // Build a sequence of functions to get from iterator if possible.\n    ValueT *(concat_iterator::*GetHelperFns[])() const = {\n        &concat_iterator::getHelper<Ns>...};\n\n    // Loop over them, and return the first result we find.\n    for (auto &GetHelperFn : GetHelperFns)\n      if (ValueT *P = (this->*GetHelperFn)())\n        return *P;\n\n    llvm_unreachable(\"Attempted to get a pointer from an end concat iterator!\");\n  }\n\npublic:\n  /// Constructs an iterator from a sequence of ranges.\n  ///\n  /// We need the full range to know how to switch between each of the\n  /// iterators.\n  template <typename... RangeTs>\n  explicit concat_iterator(RangeTs &&... Ranges)\n      : Begins(std::begin(Ranges)...), Ends(std::end(Ranges)...) {}\n\n  using BaseT::operator++;\n\n  concat_iterator &operator++() {\n    increment(std::index_sequence_for<IterTs...>());\n    return *this;\n  }\n\n  ValueT &operator*() const {\n    return get(std::index_sequence_for<IterTs...>());\n  }\n\n  bool operator==(const concat_iterator &RHS) const {\n    return Begins == RHS.Begins && Ends == RHS.Ends;\n  }\n};\n\nnamespace detail {\n\n/// Helper to store a sequence of ranges being concatenated and access them.\n///\n/// This is designed to facilitate providing actual storage when temporaries\n/// are passed into the constructor such that we can use it as part of range\n/// based for loops.\ntemplate <typename ValueT, typename... RangeTs> class concat_range {\npublic:\n  using iterator =\n      concat_iterator<ValueT,\n                      decltype(std::begin(std::declval<RangeTs &>()))...>;\n\nprivate:\n  std::tuple<RangeTs...> Ranges;\n\n  template <size_t... Ns> iterator begin_impl(std::index_sequence<Ns...>) {\n    return iterator(std::get<Ns>(Ranges)...);\n  }\n  template <size_t... Ns> iterator end_impl(std::index_sequence<Ns...>) {\n    return iterator(make_range(std::end(std::get<Ns>(Ranges)),\n                               std::end(std::get<Ns>(Ranges)))...);\n  }\n\npublic:\n  concat_range(RangeTs &&... Ranges)\n      : Ranges(std::forward<RangeTs>(Ranges)...) {}\n\n  iterator begin() { return begin_impl(std::index_sequence_for<RangeTs...>{}); }\n  iterator end() { return end_impl(std::index_sequence_for<RangeTs...>{}); }\n};\n\n} // end namespace detail\n\n/// Concatenated range across two or more ranges.\n///\n/// The desired value type must be explicitly specified.\ntemplate <typename ValueT, typename... RangeTs>\ndetail::concat_range<ValueT, RangeTs...> concat(RangeTs &&... Ranges) {\n  static_assert(sizeof...(RangeTs) > 1,\n                \"Need more than one range to concatenate!\");\n  return detail::concat_range<ValueT, RangeTs...>(\n      std::forward<RangeTs>(Ranges)...);\n}\n\n/// A utility class used to implement an iterator that contains some base object\n/// and an index. The iterator moves the index but keeps the base constant.\ntemplate <typename DerivedT, typename BaseT, typename T,\n          typename PointerT = T *, typename ReferenceT = T &>\nclass indexed_accessor_iterator\n    : public llvm::iterator_facade_base<DerivedT,\n                                        std::random_access_iterator_tag, T,\n                                        std::ptrdiff_t, PointerT, ReferenceT> {\npublic:\n  ptrdiff_t operator-(const indexed_accessor_iterator &rhs) const {\n    assert(base == rhs.base && \"incompatible iterators\");\n    return index - rhs.index;\n  }\n  bool operator==(const indexed_accessor_iterator &rhs) const {\n    return base == rhs.base && index == rhs.index;\n  }\n  bool operator<(const indexed_accessor_iterator &rhs) const {\n    assert(base == rhs.base && \"incompatible iterators\");\n    return index < rhs.index;\n  }\n\n  DerivedT &operator+=(ptrdiff_t offset) {\n    this->index += offset;\n    return static_cast<DerivedT &>(*this);\n  }\n  DerivedT &operator-=(ptrdiff_t offset) {\n    this->index -= offset;\n    return static_cast<DerivedT &>(*this);\n  }\n\n  /// Returns the current index of the iterator.\n  ptrdiff_t getIndex() const { return index; }\n\n  /// Returns the current base of the iterator.\n  const BaseT &getBase() const { return base; }\n\nprotected:\n  indexed_accessor_iterator(BaseT base, ptrdiff_t index)\n      : base(base), index(index) {}\n  BaseT base;\n  ptrdiff_t index;\n};\n\nnamespace detail {\n/// The class represents the base of a range of indexed_accessor_iterators. It\n/// provides support for many different range functionalities, e.g.\n/// drop_front/slice/etc.. Derived range classes must implement the following\n/// static methods:\n///   * ReferenceT dereference_iterator(const BaseT &base, ptrdiff_t index)\n///     - Dereference an iterator pointing to the base object at the given\n///       index.\n///   * BaseT offset_base(const BaseT &base, ptrdiff_t index)\n///     - Return a new base that is offset from the provide base by 'index'\n///       elements.\ntemplate <typename DerivedT, typename BaseT, typename T,\n          typename PointerT = T *, typename ReferenceT = T &>\nclass indexed_accessor_range_base {\npublic:\n  using RangeBaseT =\n      indexed_accessor_range_base<DerivedT, BaseT, T, PointerT, ReferenceT>;\n\n  /// An iterator element of this range.\n  class iterator : public indexed_accessor_iterator<iterator, BaseT, T,\n                                                    PointerT, ReferenceT> {\n  public:\n    // Index into this iterator, invoking a static method on the derived type.\n    ReferenceT operator*() const {\n      return DerivedT::dereference_iterator(this->getBase(), this->getIndex());\n    }\n\n  private:\n    iterator(BaseT owner, ptrdiff_t curIndex)\n        : indexed_accessor_iterator<iterator, BaseT, T, PointerT, ReferenceT>(\n              owner, curIndex) {}\n\n    /// Allow access to the constructor.\n    friend indexed_accessor_range_base<DerivedT, BaseT, T, PointerT,\n                                       ReferenceT>;\n  };\n\n  indexed_accessor_range_base(iterator begin, iterator end)\n      : base(offset_base(begin.getBase(), begin.getIndex())),\n        count(end.getIndex() - begin.getIndex()) {}\n  indexed_accessor_range_base(const iterator_range<iterator> &range)\n      : indexed_accessor_range_base(range.begin(), range.end()) {}\n  indexed_accessor_range_base(BaseT base, ptrdiff_t count)\n      : base(base), count(count) {}\n\n  iterator begin() const { return iterator(base, 0); }\n  iterator end() const { return iterator(base, count); }\n  ReferenceT operator[](size_t Index) const {\n    assert(Index < size() && \"invalid index for value range\");\n    return DerivedT::dereference_iterator(base, static_cast<ptrdiff_t>(Index));\n  }\n  ReferenceT front() const {\n    assert(!empty() && \"expected non-empty range\");\n    return (*this)[0];\n  }\n  ReferenceT back() const {\n    assert(!empty() && \"expected non-empty range\");\n    return (*this)[size() - 1];\n  }\n\n  /// Compare this range with another.\n  template <typename OtherT> bool operator==(const OtherT &other) const {\n    return size() ==\n               static_cast<size_t>(std::distance(other.begin(), other.end())) &&\n           std::equal(begin(), end(), other.begin());\n  }\n  template <typename OtherT> bool operator!=(const OtherT &other) const {\n    return !(*this == other);\n  }\n\n  /// Return the size of this range.\n  size_t size() const { return count; }\n\n  /// Return if the range is empty.\n  bool empty() const { return size() == 0; }\n\n  /// Drop the first N elements, and keep M elements.\n  DerivedT slice(size_t n, size_t m) const {\n    assert(n + m <= size() && \"invalid size specifiers\");\n    return DerivedT(offset_base(base, n), m);\n  }\n\n  /// Drop the first n elements.\n  DerivedT drop_front(size_t n = 1) const {\n    assert(size() >= n && \"Dropping more elements than exist\");\n    return slice(n, size() - n);\n  }\n  /// Drop the last n elements.\n  DerivedT drop_back(size_t n = 1) const {\n    assert(size() >= n && \"Dropping more elements than exist\");\n    return DerivedT(base, size() - n);\n  }\n\n  /// Take the first n elements.\n  DerivedT take_front(size_t n = 1) const {\n    return n < size() ? drop_back(size() - n)\n                      : static_cast<const DerivedT &>(*this);\n  }\n\n  /// Take the last n elements.\n  DerivedT take_back(size_t n = 1) const {\n    return n < size() ? drop_front(size() - n)\n                      : static_cast<const DerivedT &>(*this);\n  }\n\n  /// Allow conversion to any type accepting an iterator_range.\n  template <typename RangeT, typename = std::enable_if_t<std::is_constructible<\n                                 RangeT, iterator_range<iterator>>::value>>\n  operator RangeT() const {\n    return RangeT(iterator_range<iterator>(*this));\n  }\n\n  /// Returns the base of this range.\n  const BaseT &getBase() const { return base; }\n\nprivate:\n  /// Offset the given base by the given amount.\n  static BaseT offset_base(const BaseT &base, size_t n) {\n    return n == 0 ? base : DerivedT::offset_base(base, n);\n  }\n\nprotected:\n  indexed_accessor_range_base(const indexed_accessor_range_base &) = default;\n  indexed_accessor_range_base(indexed_accessor_range_base &&) = default;\n  indexed_accessor_range_base &\n  operator=(const indexed_accessor_range_base &) = default;\n\n  /// The base that owns the provided range of values.\n  BaseT base;\n  /// The size from the owning range.\n  ptrdiff_t count;\n};\n} // end namespace detail\n\n/// This class provides an implementation of a range of\n/// indexed_accessor_iterators where the base is not indexable. Ranges with\n/// bases that are offsetable should derive from indexed_accessor_range_base\n/// instead. Derived range classes are expected to implement the following\n/// static method:\n///   * ReferenceT dereference(const BaseT &base, ptrdiff_t index)\n///     - Dereference an iterator pointing to a parent base at the given index.\ntemplate <typename DerivedT, typename BaseT, typename T,\n          typename PointerT = T *, typename ReferenceT = T &>\nclass indexed_accessor_range\n    : public detail::indexed_accessor_range_base<\n          DerivedT, std::pair<BaseT, ptrdiff_t>, T, PointerT, ReferenceT> {\npublic:\n  indexed_accessor_range(BaseT base, ptrdiff_t startIndex, ptrdiff_t count)\n      : detail::indexed_accessor_range_base<\n            DerivedT, std::pair<BaseT, ptrdiff_t>, T, PointerT, ReferenceT>(\n            std::make_pair(base, startIndex), count) {}\n  using detail::indexed_accessor_range_base<\n      DerivedT, std::pair<BaseT, ptrdiff_t>, T, PointerT,\n      ReferenceT>::indexed_accessor_range_base;\n\n  /// Returns the current base of the range.\n  const BaseT &getBase() const { return this->base.first; }\n\n  /// Returns the current start index of the range.\n  ptrdiff_t getStartIndex() const { return this->base.second; }\n\n  /// See `detail::indexed_accessor_range_base` for details.\n  static std::pair<BaseT, ptrdiff_t>\n  offset_base(const std::pair<BaseT, ptrdiff_t> &base, ptrdiff_t index) {\n    // We encode the internal base as a pair of the derived base and a start\n    // index into the derived base.\n    return std::make_pair(base.first, base.second + index);\n  }\n  /// See `detail::indexed_accessor_range_base` for details.\n  static ReferenceT\n  dereference_iterator(const std::pair<BaseT, ptrdiff_t> &base,\n                       ptrdiff_t index) {\n    return DerivedT::dereference(base.first, base.second + index);\n  }\n};\n\n/// Given a container of pairs, return a range over the first elements.\ntemplate <typename ContainerTy> auto make_first_range(ContainerTy &&c) {\n  return llvm::map_range(\n      std::forward<ContainerTy>(c),\n      [](decltype((*std::begin(c))) elt) -> decltype((elt.first)) {\n        return elt.first;\n      });\n}\n\n/// Given a container of pairs, return a range over the second elements.\ntemplate <typename ContainerTy> auto make_second_range(ContainerTy &&c) {\n  return llvm::map_range(\n      std::forward<ContainerTy>(c),\n      [](decltype((*std::begin(c))) elt) -> decltype((elt.second)) {\n        return elt.second;\n      });\n}\n\n//===----------------------------------------------------------------------===//\n//     Extra additions to <utility>\n//===----------------------------------------------------------------------===//\n\n/// Function object to check whether the first component of a std::pair\n/// compares less than the first component of another std::pair.\nstruct less_first {\n  template <typename T> bool operator()(const T &lhs, const T &rhs) const {\n    return lhs.first < rhs.first;\n  }\n};\n\n/// Function object to check whether the second component of a std::pair\n/// compares less than the second component of another std::pair.\nstruct less_second {\n  template <typename T> bool operator()(const T &lhs, const T &rhs) const {\n    return lhs.second < rhs.second;\n  }\n};\n\n/// \\brief Function object to apply a binary function to the first component of\n/// a std::pair.\ntemplate<typename FuncTy>\nstruct on_first {\n  FuncTy func;\n\n  template <typename T>\n  decltype(auto) operator()(const T &lhs, const T &rhs) const {\n    return func(lhs.first, rhs.first);\n  }\n};\n\n/// Utility type to build an inheritance chain that makes it easy to rank\n/// overload candidates.\ntemplate <int N> struct rank : rank<N - 1> {};\ntemplate <> struct rank<0> {};\n\n/// traits class for checking whether type T is one of any of the given\n/// types in the variadic list.\ntemplate <typename T, typename... Ts> struct is_one_of {\n  static const bool value = false;\n};\n\ntemplate <typename T, typename U, typename... Ts>\nstruct is_one_of<T, U, Ts...> {\n  static const bool value =\n      std::is_same<T, U>::value || is_one_of<T, Ts...>::value;\n};\n\n/// traits class for checking whether type T is a base class for all\n///  the given types in the variadic list.\ntemplate <typename T, typename... Ts> struct are_base_of {\n  static const bool value = true;\n};\n\ntemplate <typename T, typename U, typename... Ts>\nstruct are_base_of<T, U, Ts...> {\n  static const bool value =\n      std::is_base_of<T, U>::value && are_base_of<T, Ts...>::value;\n};\n\n//===----------------------------------------------------------------------===//\n//     Extra additions for arrays\n//===----------------------------------------------------------------------===//\n\n// We have a copy here so that LLVM behaves the same when using different\n// standard libraries.\ntemplate <class Iterator, class RNG>\nvoid shuffle(Iterator first, Iterator last, RNG &&g) {\n  // It would be better to use a std::uniform_int_distribution,\n  // but that would be stdlib dependent.\n  typedef\n      typename std::iterator_traits<Iterator>::difference_type difference_type;\n  for (auto size = last - first; size > 1; ++first, (void)--size) {\n    difference_type offset = g() % size;\n    // Avoid self-assignment due to incorrect assertions in libstdc++\n    // containers (https://gcc.gnu.org/bugzilla/show_bug.cgi?id=85828).\n    if (offset != difference_type(0))\n      std::iter_swap(first, first + offset);\n  }\n}\n\n/// Find the length of an array.\ntemplate <class T, std::size_t N>\nconstexpr inline size_t array_lengthof(T (&)[N]) {\n  return N;\n}\n\n/// Adapt std::less<T> for array_pod_sort.\ntemplate<typename T>\ninline int array_pod_sort_comparator(const void *P1, const void *P2) {\n  if (std::less<T>()(*reinterpret_cast<const T*>(P1),\n                     *reinterpret_cast<const T*>(P2)))\n    return -1;\n  if (std::less<T>()(*reinterpret_cast<const T*>(P2),\n                     *reinterpret_cast<const T*>(P1)))\n    return 1;\n  return 0;\n}\n\n/// get_array_pod_sort_comparator - This is an internal helper function used to\n/// get type deduction of T right.\ntemplate<typename T>\ninline int (*get_array_pod_sort_comparator(const T &))\n             (const void*, const void*) {\n  return array_pod_sort_comparator<T>;\n}\n\n#ifdef EXPENSIVE_CHECKS\nnamespace detail {\n\ninline unsigned presortShuffleEntropy() {\n  static unsigned Result(std::random_device{}());\n  return Result;\n}\n\ntemplate <class IteratorTy>\ninline void presortShuffle(IteratorTy Start, IteratorTy End) {\n  std::mt19937 Generator(presortShuffleEntropy());\n  llvm::shuffle(Start, End, Generator);\n}\n\n} // end namespace detail\n#endif\n\n/// array_pod_sort - This sorts an array with the specified start and end\n/// extent.  This is just like std::sort, except that it calls qsort instead of\n/// using an inlined template.  qsort is slightly slower than std::sort, but\n/// most sorts are not performance critical in LLVM and std::sort has to be\n/// template instantiated for each type, leading to significant measured code\n/// bloat.  This function should generally be used instead of std::sort where\n/// possible.\n///\n/// This function assumes that you have simple POD-like types that can be\n/// compared with std::less and can be moved with memcpy.  If this isn't true,\n/// you should use std::sort.\n///\n/// NOTE: If qsort_r were portable, we could allow a custom comparator and\n/// default to std::less.\ntemplate<class IteratorTy>\ninline void array_pod_sort(IteratorTy Start, IteratorTy End) {\n  // Don't inefficiently call qsort with one element or trigger undefined\n  // behavior with an empty sequence.\n  auto NElts = End - Start;\n  if (NElts <= 1) return;\n#ifdef EXPENSIVE_CHECKS\n  detail::presortShuffle<IteratorTy>(Start, End);\n#endif\n  qsort(&*Start, NElts, sizeof(*Start), get_array_pod_sort_comparator(*Start));\n}\n\ntemplate <class IteratorTy>\ninline void array_pod_sort(\n    IteratorTy Start, IteratorTy End,\n    int (*Compare)(\n        const typename std::iterator_traits<IteratorTy>::value_type *,\n        const typename std::iterator_traits<IteratorTy>::value_type *)) {\n  // Don't inefficiently call qsort with one element or trigger undefined\n  // behavior with an empty sequence.\n  auto NElts = End - Start;\n  if (NElts <= 1) return;\n#ifdef EXPENSIVE_CHECKS\n  detail::presortShuffle<IteratorTy>(Start, End);\n#endif\n  qsort(&*Start, NElts, sizeof(*Start),\n        reinterpret_cast<int (*)(const void *, const void *)>(Compare));\n}\n\nnamespace detail {\ntemplate <typename T>\n// We can use qsort if the iterator type is a pointer and the underlying value\n// is trivially copyable.\nusing sort_trivially_copyable = conjunction<\n    std::is_pointer<T>,\n    std::is_trivially_copyable<typename std::iterator_traits<T>::value_type>>;\n} // namespace detail\n\n// Provide wrappers to std::sort which shuffle the elements before sorting\n// to help uncover non-deterministic behavior (PR35135).\ntemplate <typename IteratorTy,\n          std::enable_if_t<!detail::sort_trivially_copyable<IteratorTy>::value,\n                           int> = 0>\ninline void sort(IteratorTy Start, IteratorTy End) {\n#ifdef EXPENSIVE_CHECKS\n  detail::presortShuffle<IteratorTy>(Start, End);\n#endif\n  std::sort(Start, End);\n}\n\n// Forward trivially copyable types to array_pod_sort. This avoids a large\n// amount of code bloat for a minor performance hit.\ntemplate <typename IteratorTy,\n          std::enable_if_t<detail::sort_trivially_copyable<IteratorTy>::value,\n                           int> = 0>\ninline void sort(IteratorTy Start, IteratorTy End) {\n  array_pod_sort(Start, End);\n}\n\ntemplate <typename Container> inline void sort(Container &&C) {\n  llvm::sort(adl_begin(C), adl_end(C));\n}\n\ntemplate <typename IteratorTy, typename Compare>\ninline void sort(IteratorTy Start, IteratorTy End, Compare Comp) {\n#ifdef EXPENSIVE_CHECKS\n  detail::presortShuffle<IteratorTy>(Start, End);\n#endif\n  std::sort(Start, End, Comp);\n}\n\ntemplate <typename Container, typename Compare>\ninline void sort(Container &&C, Compare Comp) {\n  llvm::sort(adl_begin(C), adl_end(C), Comp);\n}\n\n//===----------------------------------------------------------------------===//\n//     Extra additions to <algorithm>\n//===----------------------------------------------------------------------===//\n\n/// Get the size of a range. This is a wrapper function around std::distance\n/// which is only enabled when the operation is O(1).\ntemplate <typename R>\nauto size(R &&Range,\n          std::enable_if_t<\n              std::is_base_of<std::random_access_iterator_tag,\n                              typename std::iterator_traits<decltype(\n                                  Range.begin())>::iterator_category>::value,\n              void> * = nullptr) {\n  return std::distance(Range.begin(), Range.end());\n}\n\n/// Provide wrappers to std::for_each which take ranges instead of having to\n/// pass begin/end explicitly.\ntemplate <typename R, typename UnaryFunction>\nUnaryFunction for_each(R &&Range, UnaryFunction F) {\n  return std::for_each(adl_begin(Range), adl_end(Range), F);\n}\n\n/// Provide wrappers to std::all_of which take ranges instead of having to pass\n/// begin/end explicitly.\ntemplate <typename R, typename UnaryPredicate>\nbool all_of(R &&Range, UnaryPredicate P) {\n  return std::all_of(adl_begin(Range), adl_end(Range), P);\n}\n\n/// Provide wrappers to std::any_of which take ranges instead of having to pass\n/// begin/end explicitly.\ntemplate <typename R, typename UnaryPredicate>\nbool any_of(R &&Range, UnaryPredicate P) {\n  return std::any_of(adl_begin(Range), adl_end(Range), P);\n}\n\n/// Provide wrappers to std::none_of which take ranges instead of having to pass\n/// begin/end explicitly.\ntemplate <typename R, typename UnaryPredicate>\nbool none_of(R &&Range, UnaryPredicate P) {\n  return std::none_of(adl_begin(Range), adl_end(Range), P);\n}\n\n/// Provide wrappers to std::find which take ranges instead of having to pass\n/// begin/end explicitly.\ntemplate <typename R, typename T> auto find(R &&Range, const T &Val) {\n  return std::find(adl_begin(Range), adl_end(Range), Val);\n}\n\n/// Provide wrappers to std::find_if which take ranges instead of having to pass\n/// begin/end explicitly.\ntemplate <typename R, typename UnaryPredicate>\nauto find_if(R &&Range, UnaryPredicate P) {\n  return std::find_if(adl_begin(Range), adl_end(Range), P);\n}\n\ntemplate <typename R, typename UnaryPredicate>\nauto find_if_not(R &&Range, UnaryPredicate P) {\n  return std::find_if_not(adl_begin(Range), adl_end(Range), P);\n}\n\n/// Provide wrappers to std::remove_if which take ranges instead of having to\n/// pass begin/end explicitly.\ntemplate <typename R, typename UnaryPredicate>\nauto remove_if(R &&Range, UnaryPredicate P) {\n  return std::remove_if(adl_begin(Range), adl_end(Range), P);\n}\n\n/// Provide wrappers to std::copy_if which take ranges instead of having to\n/// pass begin/end explicitly.\ntemplate <typename R, typename OutputIt, typename UnaryPredicate>\nOutputIt copy_if(R &&Range, OutputIt Out, UnaryPredicate P) {\n  return std::copy_if(adl_begin(Range), adl_end(Range), Out, P);\n}\n\ntemplate <typename R, typename OutputIt>\nOutputIt copy(R &&Range, OutputIt Out) {\n  return std::copy(adl_begin(Range), adl_end(Range), Out);\n}\n\n/// Provide wrappers to std::move which take ranges instead of having to\n/// pass begin/end explicitly.\ntemplate <typename R, typename OutputIt>\nOutputIt move(R &&Range, OutputIt Out) {\n  return std::move(adl_begin(Range), adl_end(Range), Out);\n}\n\n/// Wrapper function around std::find to detect if an element exists\n/// in a container.\ntemplate <typename R, typename E>\nbool is_contained(R &&Range, const E &Element) {\n  return std::find(adl_begin(Range), adl_end(Range), Element) != adl_end(Range);\n}\n\n/// Wrapper function around std::is_sorted to check if elements in a range \\p R\n/// are sorted with respect to a comparator \\p C.\ntemplate <typename R, typename Compare> bool is_sorted(R &&Range, Compare C) {\n  return std::is_sorted(adl_begin(Range), adl_end(Range), C);\n}\n\n/// Wrapper function around std::is_sorted to check if elements in a range \\p R\n/// are sorted in non-descending order.\ntemplate <typename R> bool is_sorted(R &&Range) {\n  return std::is_sorted(adl_begin(Range), adl_end(Range));\n}\n\n/// Wrapper function around std::count to count the number of times an element\n/// \\p Element occurs in the given range \\p Range.\ntemplate <typename R, typename E> auto count(R &&Range, const E &Element) {\n  return std::count(adl_begin(Range), adl_end(Range), Element);\n}\n\n/// Wrapper function around std::count_if to count the number of times an\n/// element satisfying a given predicate occurs in a range.\ntemplate <typename R, typename UnaryPredicate>\nauto count_if(R &&Range, UnaryPredicate P) {\n  return std::count_if(adl_begin(Range), adl_end(Range), P);\n}\n\n/// Wrapper function around std::transform to apply a function to a range and\n/// store the result elsewhere.\ntemplate <typename R, typename OutputIt, typename UnaryFunction>\nOutputIt transform(R &&Range, OutputIt d_first, UnaryFunction F) {\n  return std::transform(adl_begin(Range), adl_end(Range), d_first, F);\n}\n\n/// Provide wrappers to std::partition which take ranges instead of having to\n/// pass begin/end explicitly.\ntemplate <typename R, typename UnaryPredicate>\nauto partition(R &&Range, UnaryPredicate P) {\n  return std::partition(adl_begin(Range), adl_end(Range), P);\n}\n\n/// Provide wrappers to std::lower_bound which take ranges instead of having to\n/// pass begin/end explicitly.\ntemplate <typename R, typename T> auto lower_bound(R &&Range, T &&Value) {\n  return std::lower_bound(adl_begin(Range), adl_end(Range),\n                          std::forward<T>(Value));\n}\n\ntemplate <typename R, typename T, typename Compare>\nauto lower_bound(R &&Range, T &&Value, Compare C) {\n  return std::lower_bound(adl_begin(Range), adl_end(Range),\n                          std::forward<T>(Value), C);\n}\n\n/// Provide wrappers to std::upper_bound which take ranges instead of having to\n/// pass begin/end explicitly.\ntemplate <typename R, typename T> auto upper_bound(R &&Range, T &&Value) {\n  return std::upper_bound(adl_begin(Range), adl_end(Range),\n                          std::forward<T>(Value));\n}\n\ntemplate <typename R, typename T, typename Compare>\nauto upper_bound(R &&Range, T &&Value, Compare C) {\n  return std::upper_bound(adl_begin(Range), adl_end(Range),\n                          std::forward<T>(Value), C);\n}\n\ntemplate <typename R>\nvoid stable_sort(R &&Range) {\n  std::stable_sort(adl_begin(Range), adl_end(Range));\n}\n\ntemplate <typename R, typename Compare>\nvoid stable_sort(R &&Range, Compare C) {\n  std::stable_sort(adl_begin(Range), adl_end(Range), C);\n}\n\n/// Binary search for the first iterator in a range where a predicate is false.\n/// Requires that C is always true below some limit, and always false above it.\ntemplate <typename R, typename Predicate,\n          typename Val = decltype(*adl_begin(std::declval<R>()))>\nauto partition_point(R &&Range, Predicate P) {\n  return std::partition_point(adl_begin(Range), adl_end(Range), P);\n}\n\n/// Wrapper function around std::equal to detect if all elements\n/// in a container are same.\ntemplate <typename R>\nbool is_splat(R &&Range) {\n  size_t range_size = size(Range);\n  return range_size != 0 && (range_size == 1 ||\n         std::equal(adl_begin(Range) + 1, adl_end(Range), adl_begin(Range)));\n}\n\n/// Provide a container algorithm similar to C++ Library Fundamentals v2's\n/// `erase_if` which is equivalent to:\n///\n///   C.erase(remove_if(C, pred), C.end());\n///\n/// This version works for any container with an erase method call accepting\n/// two iterators.\ntemplate <typename Container, typename UnaryPredicate>\nvoid erase_if(Container &C, UnaryPredicate P) {\n  C.erase(remove_if(C, P), C.end());\n}\n\n/// Wrapper function to remove a value from a container:\n///\n/// C.erase(remove(C.begin(), C.end(), V), C.end());\ntemplate <typename Container, typename ValueType>\nvoid erase_value(Container &C, ValueType V) {\n  C.erase(std::remove(C.begin(), C.end(), V), C.end());\n}\n\n/// Wrapper function to append a range to a container.\n///\n/// C.insert(C.end(), R.begin(), R.end());\ntemplate <typename Container, typename Range>\ninline void append_range(Container &C, Range &&R) {\n  C.insert(C.end(), R.begin(), R.end());\n}\n\n/// Given a sequence container Cont, replace the range [ContIt, ContEnd) with\n/// the range [ValIt, ValEnd) (which is not from the same container).\ntemplate<typename Container, typename RandomAccessIterator>\nvoid replace(Container &Cont, typename Container::iterator ContIt,\n             typename Container::iterator ContEnd, RandomAccessIterator ValIt,\n             RandomAccessIterator ValEnd) {\n  while (true) {\n    if (ValIt == ValEnd) {\n      Cont.erase(ContIt, ContEnd);\n      return;\n    } else if (ContIt == ContEnd) {\n      Cont.insert(ContIt, ValIt, ValEnd);\n      return;\n    }\n    *ContIt++ = *ValIt++;\n  }\n}\n\n/// Given a sequence container Cont, replace the range [ContIt, ContEnd) with\n/// the range R.\ntemplate<typename Container, typename Range = std::initializer_list<\n                                 typename Container::value_type>>\nvoid replace(Container &Cont, typename Container::iterator ContIt,\n             typename Container::iterator ContEnd, Range R) {\n  replace(Cont, ContIt, ContEnd, R.begin(), R.end());\n}\n\n/// An STL-style algorithm similar to std::for_each that applies a second\n/// functor between every pair of elements.\n///\n/// This provides the control flow logic to, for example, print a\n/// comma-separated list:\n/// \\code\n///   interleave(names.begin(), names.end(),\n///              [&](StringRef name) { os << name; },\n///              [&] { os << \", \"; });\n/// \\endcode\ntemplate <typename ForwardIterator, typename UnaryFunctor,\n          typename NullaryFunctor,\n          typename = typename std::enable_if<\n              !std::is_constructible<StringRef, UnaryFunctor>::value &&\n              !std::is_constructible<StringRef, NullaryFunctor>::value>::type>\ninline void interleave(ForwardIterator begin, ForwardIterator end,\n                       UnaryFunctor each_fn, NullaryFunctor between_fn) {\n  if (begin == end)\n    return;\n  each_fn(*begin);\n  ++begin;\n  for (; begin != end; ++begin) {\n    between_fn();\n    each_fn(*begin);\n  }\n}\n\ntemplate <typename Container, typename UnaryFunctor, typename NullaryFunctor,\n          typename = typename std::enable_if<\n              !std::is_constructible<StringRef, UnaryFunctor>::value &&\n              !std::is_constructible<StringRef, NullaryFunctor>::value>::type>\ninline void interleave(const Container &c, UnaryFunctor each_fn,\n                       NullaryFunctor between_fn) {\n  interleave(c.begin(), c.end(), each_fn, between_fn);\n}\n\n/// Overload of interleave for the common case of string separator.\ntemplate <typename Container, typename UnaryFunctor, typename StreamT,\n          typename T = detail::ValueOfRange<Container>>\ninline void interleave(const Container &c, StreamT &os, UnaryFunctor each_fn,\n                       const StringRef &separator) {\n  interleave(c.begin(), c.end(), each_fn, [&] { os << separator; });\n}\ntemplate <typename Container, typename StreamT,\n          typename T = detail::ValueOfRange<Container>>\ninline void interleave(const Container &c, StreamT &os,\n                       const StringRef &separator) {\n  interleave(\n      c, os, [&](const T &a) { os << a; }, separator);\n}\n\ntemplate <typename Container, typename UnaryFunctor, typename StreamT,\n          typename T = detail::ValueOfRange<Container>>\ninline void interleaveComma(const Container &c, StreamT &os,\n                            UnaryFunctor each_fn) {\n  interleave(c, os, each_fn, \", \");\n}\ntemplate <typename Container, typename StreamT,\n          typename T = detail::ValueOfRange<Container>>\ninline void interleaveComma(const Container &c, StreamT &os) {\n  interleaveComma(c, os, [&](const T &a) { os << a; });\n}\n\n//===----------------------------------------------------------------------===//\n//     Extra additions to <memory>\n//===----------------------------------------------------------------------===//\n\nstruct FreeDeleter {\n  void operator()(void* v) {\n    ::free(v);\n  }\n};\n\ntemplate<typename First, typename Second>\nstruct pair_hash {\n  size_t operator()(const std::pair<First, Second> &P) const {\n    return std::hash<First>()(P.first) * 31 + std::hash<Second>()(P.second);\n  }\n};\n\n/// Binary functor that adapts to any other binary functor after dereferencing\n/// operands.\ntemplate <typename T> struct deref {\n  T func;\n\n  // Could be further improved to cope with non-derivable functors and\n  // non-binary functors (should be a variadic template member function\n  // operator()).\n  template <typename A, typename B> auto operator()(A &lhs, B &rhs) const {\n    assert(lhs);\n    assert(rhs);\n    return func(*lhs, *rhs);\n  }\n};\n\nnamespace detail {\n\ntemplate <typename R> class enumerator_iter;\n\ntemplate <typename R> struct result_pair {\n  using value_reference =\n      typename std::iterator_traits<IterOfRange<R>>::reference;\n\n  friend class enumerator_iter<R>;\n\n  result_pair() = default;\n  result_pair(std::size_t Index, IterOfRange<R> Iter)\n      : Index(Index), Iter(Iter) {}\n\n  result_pair(const result_pair<R> &Other)\n      : Index(Other.Index), Iter(Other.Iter) {}\n  result_pair &operator=(const result_pair &Other) {\n    Index = Other.Index;\n    Iter = Other.Iter;\n    return *this;\n  }\n\n  std::size_t index() const { return Index; }\n  const value_reference value() const { return *Iter; }\n  value_reference value() { return *Iter; }\n\nprivate:\n  std::size_t Index = std::numeric_limits<std::size_t>::max();\n  IterOfRange<R> Iter;\n};\n\ntemplate <typename R>\nclass enumerator_iter\n    : public iterator_facade_base<\n          enumerator_iter<R>, std::forward_iterator_tag, result_pair<R>,\n          typename std::iterator_traits<IterOfRange<R>>::difference_type,\n          typename std::iterator_traits<IterOfRange<R>>::pointer,\n          typename std::iterator_traits<IterOfRange<R>>::reference> {\n  using result_type = result_pair<R>;\n\npublic:\n  explicit enumerator_iter(IterOfRange<R> EndIter)\n      : Result(std::numeric_limits<size_t>::max(), EndIter) {}\n\n  enumerator_iter(std::size_t Index, IterOfRange<R> Iter)\n      : Result(Index, Iter) {}\n\n  result_type &operator*() { return Result; }\n  const result_type &operator*() const { return Result; }\n\n  enumerator_iter &operator++() {\n    assert(Result.Index != std::numeric_limits<size_t>::max());\n    ++Result.Iter;\n    ++Result.Index;\n    return *this;\n  }\n\n  bool operator==(const enumerator_iter &RHS) const {\n    // Don't compare indices here, only iterators.  It's possible for an end\n    // iterator to have different indices depending on whether it was created\n    // by calling std::end() versus incrementing a valid iterator.\n    return Result.Iter == RHS.Result.Iter;\n  }\n\n  enumerator_iter(const enumerator_iter &Other) : Result(Other.Result) {}\n  enumerator_iter &operator=(const enumerator_iter &Other) {\n    Result = Other.Result;\n    return *this;\n  }\n\nprivate:\n  result_type Result;\n};\n\ntemplate <typename R> class enumerator {\npublic:\n  explicit enumerator(R &&Range) : TheRange(std::forward<R>(Range)) {}\n\n  enumerator_iter<R> begin() {\n    return enumerator_iter<R>(0, std::begin(TheRange));\n  }\n\n  enumerator_iter<R> end() {\n    return enumerator_iter<R>(std::end(TheRange));\n  }\n\nprivate:\n  R TheRange;\n};\n\n} // end namespace detail\n\n/// Given an input range, returns a new range whose values are are pair (A,B)\n/// such that A is the 0-based index of the item in the sequence, and B is\n/// the value from the original sequence.  Example:\n///\n/// std::vector<char> Items = {'A', 'B', 'C', 'D'};\n/// for (auto X : enumerate(Items)) {\n///   printf(\"Item %d - %c\\n\", X.index(), X.value());\n/// }\n///\n/// Output:\n///   Item 0 - A\n///   Item 1 - B\n///   Item 2 - C\n///   Item 3 - D\n///\ntemplate <typename R> detail::enumerator<R> enumerate(R &&TheRange) {\n  return detail::enumerator<R>(std::forward<R>(TheRange));\n}\n\nnamespace detail {\n\ntemplate <typename F, typename Tuple, std::size_t... I>\ndecltype(auto) apply_tuple_impl(F &&f, Tuple &&t, std::index_sequence<I...>) {\n  return std::forward<F>(f)(std::get<I>(std::forward<Tuple>(t))...);\n}\n\n} // end namespace detail\n\n/// Given an input tuple (a1, a2, ..., an), pass the arguments of the\n/// tuple variadically to f as if by calling f(a1, a2, ..., an) and\n/// return the result.\ntemplate <typename F, typename Tuple>\ndecltype(auto) apply_tuple(F &&f, Tuple &&t) {\n  using Indices = std::make_index_sequence<\n      std::tuple_size<typename std::decay<Tuple>::type>::value>;\n\n  return detail::apply_tuple_impl(std::forward<F>(f), std::forward<Tuple>(t),\n                                  Indices{});\n}\n\n/// Return true if the sequence [Begin, End) has exactly N items. Runs in O(N)\n/// time. Not meant for use with random-access iterators.\n/// Can optionally take a predicate to filter lazily some items.\ntemplate <typename IterTy,\n          typename Pred = bool (*)(const decltype(*std::declval<IterTy>()) &)>\nbool hasNItems(\n    IterTy &&Begin, IterTy &&End, unsigned N,\n    Pred &&ShouldBeCounted =\n        [](const decltype(*std::declval<IterTy>()) &) { return true; },\n    std::enable_if_t<\n        !std::is_base_of<std::random_access_iterator_tag,\n                         typename std::iterator_traits<std::remove_reference_t<\n                             decltype(Begin)>>::iterator_category>::value,\n        void> * = nullptr) {\n  for (; N; ++Begin) {\n    if (Begin == End)\n      return false; // Too few.\n    N -= ShouldBeCounted(*Begin);\n  }\n  for (; Begin != End; ++Begin)\n    if (ShouldBeCounted(*Begin))\n      return false; // Too many.\n  return true;\n}\n\n/// Return true if the sequence [Begin, End) has N or more items. Runs in O(N)\n/// time. Not meant for use with random-access iterators.\n/// Can optionally take a predicate to lazily filter some items.\ntemplate <typename IterTy,\n          typename Pred = bool (*)(const decltype(*std::declval<IterTy>()) &)>\nbool hasNItemsOrMore(\n    IterTy &&Begin, IterTy &&End, unsigned N,\n    Pred &&ShouldBeCounted =\n        [](const decltype(*std::declval<IterTy>()) &) { return true; },\n    std::enable_if_t<\n        !std::is_base_of<std::random_access_iterator_tag,\n                         typename std::iterator_traits<std::remove_reference_t<\n                             decltype(Begin)>>::iterator_category>::value,\n        void> * = nullptr) {\n  for (; N; ++Begin) {\n    if (Begin == End)\n      return false; // Too few.\n    N -= ShouldBeCounted(*Begin);\n  }\n  return true;\n}\n\n/// Returns true if the sequence [Begin, End) has N or less items. Can\n/// optionally take a predicate to lazily filter some items.\ntemplate <typename IterTy,\n          typename Pred = bool (*)(const decltype(*std::declval<IterTy>()) &)>\nbool hasNItemsOrLess(\n    IterTy &&Begin, IterTy &&End, unsigned N,\n    Pred &&ShouldBeCounted = [](const decltype(*std::declval<IterTy>()) &) {\n      return true;\n    }) {\n  assert(N != std::numeric_limits<unsigned>::max());\n  return !hasNItemsOrMore(Begin, End, N + 1, ShouldBeCounted);\n}\n\n/// Returns true if the given container has exactly N items\ntemplate <typename ContainerTy> bool hasNItems(ContainerTy &&C, unsigned N) {\n  return hasNItems(std::begin(C), std::end(C), N);\n}\n\n/// Returns true if the given container has N or more items\ntemplate <typename ContainerTy>\nbool hasNItemsOrMore(ContainerTy &&C, unsigned N) {\n  return hasNItemsOrMore(std::begin(C), std::end(C), N);\n}\n\n/// Returns true if the given container has N or less items\ntemplate <typename ContainerTy>\nbool hasNItemsOrLess(ContainerTy &&C, unsigned N) {\n  return hasNItemsOrLess(std::begin(C), std::end(C), N);\n}\n\n/// Returns a raw pointer that represents the same address as the argument.\n///\n/// This implementation can be removed once we move to C++20 where it's defined\n/// as std::to_address().\n///\n/// The std::pointer_traits<>::to_address(p) variations of these overloads has\n/// not been implemented.\ntemplate <class Ptr> auto to_address(const Ptr &P) { return P.operator->(); }\ntemplate <class T> constexpr T *to_address(T *P) { return P; }\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_STLEXTRAS_H\n"}, "12": {"id": 12, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SetVector.h", "content": "//===- llvm/ADT/SetVector.h - Set with insert order iteration ---*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file implements a set that has insertion order iteration\n// characteristics. This is useful for keeping a set of things that need to be\n// visited later but in a deterministic order (insertion order). The interface\n// is purposefully minimal.\n//\n// This file defines SetVector and SmallSetVector, which performs no allocations\n// if the SetVector has less than a certain number of elements.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_SETVECTOR_H\n#define LLVM_ADT_SETVECTOR_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseSet.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/Support/Compiler.h\"\n#include <algorithm>\n#include <cassert>\n#include <iterator>\n#include <vector>\n\nnamespace llvm {\n\n/// A vector that has set insertion semantics.\n///\n/// This adapter class provides a way to keep a set of things that also has the\n/// property of a deterministic iteration order. The order of iteration is the\n/// order of insertion.\ntemplate <typename T, typename Vector = std::vector<T>,\n          typename Set = DenseSet<T>>\nclass SetVector {\npublic:\n  using value_type = T;\n  using key_type = T;\n  using reference = T&;\n  using const_reference = const T&;\n  using set_type = Set;\n  using vector_type = Vector;\n  using iterator = typename vector_type::const_iterator;\n  using const_iterator = typename vector_type::const_iterator;\n  using reverse_iterator = typename vector_type::const_reverse_iterator;\n  using const_reverse_iterator = typename vector_type::const_reverse_iterator;\n  using size_type = typename vector_type::size_type;\n\n  /// Construct an empty SetVector\n  SetVector() = default;\n\n  /// Initialize a SetVector with a range of elements\n  template<typename It>\n  SetVector(It Start, It End) {\n    insert(Start, End);\n  }\n\n  ArrayRef<T> getArrayRef() const { return vector_; }\n\n  /// Clear the SetVector and return the underlying vector.\n  Vector takeVector() {\n    set_.clear();\n    return std::move(vector_);\n  }\n\n  /// Determine if the SetVector is empty or not.\n  bool empty() const {\n    return vector_.empty();\n  }\n\n  /// Determine the number of elements in the SetVector.\n  size_type size() const {\n    return vector_.size();\n  }\n\n  /// Get an iterator to the beginning of the SetVector.\n  iterator begin() {\n    return vector_.begin();\n  }\n\n  /// Get a const_iterator to the beginning of the SetVector.\n  const_iterator begin() const {\n    return vector_.begin();\n  }\n\n  /// Get an iterator to the end of the SetVector.\n  iterator end() {\n    return vector_.end();\n  }\n\n  /// Get a const_iterator to the end of the SetVector.\n  const_iterator end() const {\n    return vector_.end();\n  }\n\n  /// Get an reverse_iterator to the end of the SetVector.\n  reverse_iterator rbegin() {\n    return vector_.rbegin();\n  }\n\n  /// Get a const_reverse_iterator to the end of the SetVector.\n  const_reverse_iterator rbegin() const {\n    return vector_.rbegin();\n  }\n\n  /// Get a reverse_iterator to the beginning of the SetVector.\n  reverse_iterator rend() {\n    return vector_.rend();\n  }\n\n  /// Get a const_reverse_iterator to the beginning of the SetVector.\n  const_reverse_iterator rend() const {\n    return vector_.rend();\n  }\n\n  /// Return the first element of the SetVector.\n  const T &front() const {\n    assert(!empty() && \"Cannot call front() on empty SetVector!\");\n    return vector_.front();\n  }\n\n  /// Return the last element of the SetVector.\n  const T &back() const {\n    assert(!empty() && \"Cannot call back() on empty SetVector!\");\n    return vector_.back();\n  }\n\n  /// Index into the SetVector.\n  const_reference operator[](size_type n) const {\n    assert(n < vector_.size() && \"SetVector access out of range!\");\n    return vector_[n];\n  }\n\n  /// Insert a new element into the SetVector.\n  /// \\returns true if the element was inserted into the SetVector.\n  bool insert(const value_type &X) {\n    bool result = set_.insert(X).second;\n    if (result)\n      vector_.push_back(X);\n    return result;\n  }\n\n  /// Insert a range of elements into the SetVector.\n  template<typename It>\n  void insert(It Start, It End) {\n    for (; Start != End; ++Start)\n      if (set_.insert(*Start).second)\n        vector_.push_back(*Start);\n  }\n\n  /// Remove an item from the set vector.\n  bool remove(const value_type& X) {\n    if (set_.erase(X)) {\n      typename vector_type::iterator I = find(vector_, X);\n      assert(I != vector_.end() && \"Corrupted SetVector instances!\");\n      vector_.erase(I);\n      return true;\n    }\n    return false;\n  }\n\n  /// Erase a single element from the set vector.\n  /// \\returns an iterator pointing to the next element that followed the\n  /// element erased. This is the end of the SetVector if the last element is\n  /// erased.\n  iterator erase(iterator I) {\n    const key_type &V = *I;\n    assert(set_.count(V) && \"Corrupted SetVector instances!\");\n    set_.erase(V);\n\n    // FIXME: No need to use the non-const iterator when built with\n    // std::vector.erase(const_iterator) as defined in C++11. This is for\n    // compatibility with non-standard libstdc++ up to 4.8 (fixed in 4.9).\n    auto NI = vector_.begin();\n    std::advance(NI, std::distance<iterator>(NI, I));\n\n    return vector_.erase(NI);\n  }\n\n  /// Remove items from the set vector based on a predicate function.\n  ///\n  /// This is intended to be equivalent to the following code, if we could\n  /// write it:\n  ///\n  /// \\code\n  ///   V.erase(remove_if(V, P), V.end());\n  /// \\endcode\n  ///\n  /// However, SetVector doesn't expose non-const iterators, making any\n  /// algorithm like remove_if impossible to use.\n  ///\n  /// \\returns true if any element is removed.\n  template <typename UnaryPredicate>\n  bool remove_if(UnaryPredicate P) {\n    typename vector_type::iterator I =\n        llvm::remove_if(vector_, TestAndEraseFromSet<UnaryPredicate>(P, set_));\n    if (I == vector_.end())\n      return false;\n    vector_.erase(I, vector_.end());\n    return true;\n  }\n\n  /// Check if the SetVector contains the given key.\n  bool contains(const key_type &key) const {\n    return set_.find(key) != set_.end();\n  }\n\n  /// Count the number of elements of a given key in the SetVector.\n  /// \\returns 0 if the element is not in the SetVector, 1 if it is.\n  size_type count(const key_type &key) const {\n    return set_.count(key);\n  }\n\n  /// Completely clear the SetVector\n  void clear() {\n    set_.clear();\n    vector_.clear();\n  }\n\n  /// Remove the last element of the SetVector.\n  void pop_back() {\n    assert(!empty() && \"Cannot remove an element from an empty SetVector!\");\n    set_.erase(back());\n    vector_.pop_back();\n  }\n\n  LLVM_NODISCARD T pop_back_val() {\n    T Ret = back();\n    pop_back();\n    return Ret;\n  }\n\n  bool operator==(const SetVector &that) const {\n    return vector_ == that.vector_;\n  }\n\n  bool operator!=(const SetVector &that) const {\n    return vector_ != that.vector_;\n  }\n\n  /// Compute This := This u S, return whether 'This' changed.\n  /// TODO: We should be able to use set_union from SetOperations.h, but\n  ///       SetVector interface is inconsistent with DenseSet.\n  template <class STy>\n  bool set_union(const STy &S) {\n    bool Changed = false;\n\n    for (typename STy::const_iterator SI = S.begin(), SE = S.end(); SI != SE;\n         ++SI)\n      if (insert(*SI))\n        Changed = true;\n\n    return Changed;\n  }\n\n  /// Compute This := This - B\n  /// TODO: We should be able to use set_subtract from SetOperations.h, but\n  ///       SetVector interface is inconsistent with DenseSet.\n  template <class STy>\n  void set_subtract(const STy &S) {\n    for (typename STy::const_iterator SI = S.begin(), SE = S.end(); SI != SE;\n         ++SI)\n      remove(*SI);\n  }\n\n  void swap(SetVector<T, Vector, Set> &RHS) {\n    set_.swap(RHS.set_);\n    vector_.swap(RHS.vector_);\n  }\n\nprivate:\n  /// A wrapper predicate designed for use with std::remove_if.\n  ///\n  /// This predicate wraps a predicate suitable for use with std::remove_if to\n  /// call set_.erase(x) on each element which is slated for removal.\n  template <typename UnaryPredicate>\n  class TestAndEraseFromSet {\n    UnaryPredicate P;\n    set_type &set_;\n\n  public:\n    TestAndEraseFromSet(UnaryPredicate P, set_type &set_)\n        : P(std::move(P)), set_(set_) {}\n\n    template <typename ArgumentT>\n    bool operator()(const ArgumentT &Arg) {\n      if (P(Arg)) {\n        set_.erase(Arg);\n        return true;\n      }\n      return false;\n    }\n  };\n\n  set_type set_;         ///< The set.\n  vector_type vector_;   ///< The vector.\n};\n\n/// A SetVector that performs no allocations if smaller than\n/// a certain size.\ntemplate <typename T, unsigned N>\nclass SmallSetVector\n    : public SetVector<T, SmallVector<T, N>, SmallDenseSet<T, N>> {\npublic:\n  SmallSetVector() = default;\n\n  /// Initialize a SmallSetVector with a range of elements\n  template<typename It>\n  SmallSetVector(It Start, It End) {\n    this->insert(Start, End);\n  }\n};\n\n} // end namespace llvm\n\nnamespace std {\n\n/// Implement std::swap in terms of SetVector swap.\ntemplate<typename T, typename V, typename S>\ninline void\nswap(llvm::SetVector<T, V, S> &LHS, llvm::SetVector<T, V, S> &RHS) {\n  LHS.swap(RHS);\n}\n\n/// Implement std::swap in terms of SmallSetVector swap.\ntemplate<typename T, unsigned N>\ninline void\nswap(llvm::SmallSetVector<T, N> &LHS, llvm::SmallSetVector<T, N> &RHS) {\n  LHS.swap(RHS);\n}\n\n} // end namespace std\n\n#endif // LLVM_ADT_SETVECTOR_H\n"}, "29": {"id": 29, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/TableGen/SetTheory.h", "content": "//===- SetTheory.h - Generate ordered sets from DAG expressions -*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file implements the SetTheory class that computes ordered sets of\n// Records from DAG expressions.  Operators for standard set operations are\n// predefined, and it is possible to add special purpose set operators as well.\n//\n// The user may define named sets as Records of predefined classes. Set\n// expanders can be added to a SetTheory instance to teach it how to find the\n// elements of such a named set.\n//\n// These are the predefined operators. The argument lists can be individual\n// elements (defs), other sets (defs of expandable classes), lists, or DAG\n// expressions that are evaluated recursively.\n//\n// - (add S1, S2 ...) Union sets. This is also how sets are created from element\n//   lists.\n//\n// - (sub S1, S2, ...) Set difference. Every element in S1 except for the\n//   elements in S2, ...\n//\n// - (and S1, S2) Set intersection. Every element in S1 that is also in S2.\n//\n// - (shl S, N) Shift left. Remove the first N elements from S.\n//\n// - (trunc S, N) Truncate. The first N elements of S.\n//\n// - (rotl S, N) Rotate left. Same as (add (shl S, N), (trunc S, N)).\n//\n// - (rotr S, N) Rotate right.\n//\n// - (decimate S, N) Decimate S by picking every N'th element, starting with\n//   the first one. For instance, (decimate S, 2) returns the even elements of\n//   S.\n//\n// - (sequence \"Format\", From, To) Generate a sequence of defs with printf.\n//   For instance, (sequence \"R%u\", 0, 3) -> [ R0, R1, R2, R3 ]\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_TABLEGEN_SETTHEORY_H\n#define LLVM_TABLEGEN_SETTHEORY_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/SetVector.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/SMLoc.h\"\n#include <map>\n#include <memory>\n#include <vector>\n\nnamespace llvm {\n\nclass DagInit;\nclass Init;\nclass Record;\n\nclass SetTheory {\npublic:\n  using RecVec = std::vector<Record *>;\n  using RecSet = SmallSetVector<Record *, 16>;\n\n  /// Operator - A callback representing a DAG operator.\n  class Operator {\n    virtual void anchor();\n\n  public:\n    virtual ~Operator() = default;\n\n    /// apply - Apply this operator to Expr's arguments and insert the result\n    /// in Elts.\n    virtual void apply(SetTheory&, DagInit *Expr, RecSet &Elts,\n                       ArrayRef<SMLoc> Loc) = 0;\n  };\n\n  /// Expander - A callback function that can transform a Record representing a\n  /// set into a fully expanded list of elements. Expanders provide a way for\n  /// users to define named sets that can be used in DAG expressions.\n  class Expander {\n    virtual void anchor();\n\n  public:\n    virtual ~Expander() = default;\n\n    virtual void expand(SetTheory&, Record*, RecSet &Elts) = 0;\n  };\n\nprivate:\n  // Map set defs to their fully expanded contents. This serves as a memoization\n  // cache and it makes it possible to return const references on queries.\n  using ExpandMap = std::map<Record *, RecVec>;\n  ExpandMap Expansions;\n\n  // Known DAG operators by name.\n  StringMap<std::unique_ptr<Operator>> Operators;\n\n  // Typed expanders by class name.\n  StringMap<std::unique_ptr<Expander>> Expanders;\n\npublic:\n  /// Create a SetTheory instance with only the standard operators.\n  SetTheory();\n\n  /// addExpander - Add an expander for Records with the named super class.\n  void addExpander(StringRef ClassName, std::unique_ptr<Expander>);\n\n  /// addFieldExpander - Add an expander for ClassName that simply evaluates\n  /// FieldName in the Record to get the set elements.  That is all that is\n  /// needed for a class like:\n  ///\n  ///   class Set<dag d> {\n  ///     dag Elts = d;\n  ///   }\n  ///\n  void addFieldExpander(StringRef ClassName, StringRef FieldName);\n\n  /// addOperator - Add a DAG operator.\n  void addOperator(StringRef Name, std::unique_ptr<Operator>);\n\n  /// evaluate - Evaluate Expr and append the resulting set to Elts.\n  void evaluate(Init *Expr, RecSet &Elts, ArrayRef<SMLoc> Loc);\n\n  /// evaluate - Evaluate a sequence of Inits and append to Elts.\n  template<typename Iter>\n  void evaluate(Iter begin, Iter end, RecSet &Elts, ArrayRef<SMLoc> Loc) {\n    while (begin != end)\n      evaluate(*begin++, Elts, Loc);\n  }\n\n  /// expand - Expand a record into a set of elements if possible.  Return a\n  /// pointer to the expanded elements, or NULL if Set cannot be expanded\n  /// further.\n  const RecVec *expand(Record *Set);\n};\n\n} // end namespace llvm\n\n#endif // LLVM_TABLEGEN_SETTHEORY_H\n"}}, "reports": [{"events": [{"location": {"col": 7, "file": 0, "line": 118}, "message": "default constructor 'TypeSpec' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/utils/TableGen/NeonEmitter.cpp", "reportHash": "b839b12ad8d0968ea26bb438cd9013de", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 0, "line": 118}, "message": "destructor '~TypeSpec' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/utils/TableGen/NeonEmitter.cpp", "reportHash": "4c65cc3966722aa4f44c7b5368e8741b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 0, "line": 118}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/utils/TableGen/NeonEmitter.cpp", "reportHash": "426fc192c3f45e356388fba11bb139bc", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 0, "line": 118}, "message": "move constructor 'TypeSpec' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/utils/TableGen/NeonEmitter.cpp", "reportHash": "d9543b7f0e0820b02a969f4dc85b23ef", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 0, "line": 141}, "message": "destructor '~Type' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/utils/TableGen/NeonEmitter.cpp", "reportHash": "a58c8a4bdbdc87e7fd011ca64afc4567", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 0, "line": 141}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/utils/TableGen/NeonEmitter.cpp", "reportHash": "26ce0373585c0281478a661e60647924", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 0, "line": 141}, "message": "move constructor 'Type' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/utils/TableGen/NeonEmitter.cpp", "reportHash": "8332ccd5df35640df1b3764fcf221876", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 0, "line": 290}, "message": "destructor '~Variable' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/utils/TableGen/NeonEmitter.cpp", "reportHash": "a2376b192b33056a824e81a357312742", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 0, "line": 290}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/utils/TableGen/NeonEmitter.cpp", "reportHash": "2b62a6a10487f0754c309a246b460f26", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 24, "file": 0, "line": 421}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/utils/TableGen/NeonEmitter.cpp", "reportHash": "742cfdc7b4d3602bafe4c26ef4a9fff7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 24, "file": 0, "line": 421}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/utils/TableGen/NeonEmitter.cpp", "reportHash": "2d07420590511ae7f54bac1ffe50251a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 0, "line": 541}, "message": "destructor '~NeonEmitter' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/utils/TableGen/NeonEmitter.cpp", "reportHash": "9017185b716034d33d047d639a034079", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 50, "file": 0, "line": 1274}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/utils/TableGen/NeonEmitter.cpp", "reportHash": "e07cc64f215eb1497ee8d3f5f55e1741", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 50, "file": 0, "line": 1274}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/utils/TableGen/NeonEmitter.cpp", "reportHash": "6e72b68bb01da732079d4b25f7f3cab8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 0, "line": 1564}, "message": "default constructor 'LowHalf' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/utils/TableGen/NeonEmitter.cpp", "reportHash": "f5f84661a0104969db17b7a51909bd40", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 0, "line": 1564}, "message": "destructor '~LowHalf' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/utils/TableGen/NeonEmitter.cpp", "reportHash": "1c9cd7f42e1ed77f741fec2d52d8db02", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 0, "line": 1574}, "message": "default constructor 'HighHalf' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/utils/TableGen/NeonEmitter.cpp", "reportHash": "e0daa3a43fdfbaf8c17b078291e935a2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 0, "line": 1574}, "message": "destructor '~HighHalf' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/utils/TableGen/NeonEmitter.cpp", "reportHash": "07045677301966582989bf3baa9afdbb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 0, "line": 1584}, "message": "destructor '~Rev' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/utils/TableGen/NeonEmitter.cpp", "reportHash": "f95e28938c05adec2c2f7141ca9daa9f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 0, "line": 1609}, "message": "destructor '~MaskExpander' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/utils/TableGen/NeonEmitter.cpp", "reportHash": "8495b7ab238f7da8d9fc48f59e443deb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 49, "file": 0, "line": 1920}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/utils/TableGen/NeonEmitter.cpp", "reportHash": "ece8eb9741bb71a8ec104dd940ffa6ea", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 49, "file": 0, "line": 1920}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/utils/TableGen/NeonEmitter.cpp", "reportHash": "c6568d0532c930997e59f390dd68e1c0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 0, "line": 2027}, "message": "destructor '~OverloadInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/utils/TableGen/NeonEmitter.cpp", "reportHash": "544ce921c81bc932485151d9dd2fe4a3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 0, "line": 2027}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/utils/TableGen/NeonEmitter.cpp", "reportHash": "e293ffd48f5e988009dd076b327571bc", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 0, "line": 2027}, "message": "move constructor 'OverloadInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/utils/TableGen/NeonEmitter.cpp", "reportHash": "82326cab2d547df030d9f2267a396e1d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 4, "line": 897}, "message": "destructor '~LargeRep' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/DenseMap.h", "reportHash": "4727e280796388a0331172b6ccb54235", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 4, "line": 897}, "message": "move constructor 'LargeRep' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/DenseMap.h", "reportHash": "6f746dd279dcdfadb9a1cbca4cddff22", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 5, "line": 286}, "message": "destructor '~SmallDenseSet' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/DenseSet.h", "reportHash": "72ca2cc856b89b6d792aa223405a1c3f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 30, "file": 11, "line": 1803}, "message": "default constructor 'deref' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/STLExtras.h", "reportHash": "e612334d55393cdde49b5290116625d2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 30, "file": 11, "line": 1803}, "message": "destructor '~deref' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/STLExtras.h", "reportHash": "38717d5e511abffd7df623722b346e47", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 30, "file": 11, "line": 1803}, "message": "move constructor 'deref' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/STLExtras.h", "reportHash": "3e49b97bf1e9376cd85bf7748d089f21", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 12, "line": 307}, "message": "destructor '~SmallSetVector' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SetVector.h", "reportHash": "30395f0bd2e2fe0110baae28e00aafe7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 29, "line": 64}, "message": "destructor '~SetTheory' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/TableGen/SetTheory.h", "reportHash": "a7c506a47bcd5b1db1ad676be3b29bf7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 29, "line": 70}, "message": "default constructor 'Operator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/TableGen/SetTheory.h", "reportHash": "c1933df5b77f07e76ed06e9972c0b8f1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 29, "line": 85}, "message": "default constructor 'Expander' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/TableGen/SetTheory.h", "reportHash": "2d66ac15ca74572ccdfad5bfa2445bf8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
