<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"20": {"id": 20, "path": "/home/vsts/work/1/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp", "content": "//=== RecordLayoutBuilder.cpp - Helper class for building record layouts ---==//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/ASTDiagnostic.h\"\n#include \"clang/AST/Attr.h\"\n#include \"clang/AST/CXXInheritance.h\"\n#include \"clang/AST/Decl.h\"\n#include \"clang/AST/DeclCXX.h\"\n#include \"clang/AST/DeclObjC.h\"\n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/VTableBuilder.h\"\n#include \"clang/AST/RecordLayout.h\"\n#include \"clang/Basic/TargetInfo.h\"\n#include \"llvm/ADT/SmallSet.h\"\n#include \"llvm/Support/Format.h\"\n#include \"llvm/Support/MathExtras.h\"\n\nusing namespace clang;\n\nnamespace {\n\n/// BaseSubobjectInfo - Represents a single base subobject in a complete class.\n/// For a class hierarchy like\n///\n/// class A { };\n/// class B : A { };\n/// class C : A, B { };\n///\n/// The BaseSubobjectInfo graph for C will have three BaseSubobjectInfo\n/// instances, one for B and two for A.\n///\n/// If a base is virtual, it will only have one BaseSubobjectInfo allocated.\nstruct BaseSubobjectInfo {\n  /// Class - The class for this base info.\n  const CXXRecordDecl *Class;\n\n  /// IsVirtual - Whether the BaseInfo represents a virtual base or not.\n  bool IsVirtual;\n\n  /// Bases - Information about the base subobjects.\n  SmallVector<BaseSubobjectInfo*, 4> Bases;\n\n  /// PrimaryVirtualBaseInfo - Holds the base info for the primary virtual base\n  /// of this base info (if one exists).\n  BaseSubobjectInfo *PrimaryVirtualBaseInfo;\n\n  // FIXME: Document.\n  const BaseSubobjectInfo *Derived;\n};\n\n/// Externally provided layout. Typically used when the AST source, such\n/// as DWARF, lacks all the information that was available at compile time, such\n/// as alignment attributes on fields and pragmas in effect.\nstruct ExternalLayout {\n  ExternalLayout() : Size(0), Align(0) {}\n\n  /// Overall record size in bits.\n  uint64_t Size;\n\n  /// Overall record alignment in bits.\n  uint64_t Align;\n\n  /// Record field offsets in bits.\n  llvm::DenseMap<const FieldDecl *, uint64_t> FieldOffsets;\n\n  /// Direct, non-virtual base offsets.\n  llvm::DenseMap<const CXXRecordDecl *, CharUnits> BaseOffsets;\n\n  /// Virtual base offsets.\n  llvm::DenseMap<const CXXRecordDecl *, CharUnits> VirtualBaseOffsets;\n\n  /// Get the offset of the given field. The external source must provide\n  /// entries for all fields in the record.\n  uint64_t getExternalFieldOffset(const FieldDecl *FD) {\n    assert(FieldOffsets.count(FD) &&\n           \"Field does not have an external offset\");\n    return FieldOffsets[FD];\n  }\n\n  bool getExternalNVBaseOffset(const CXXRecordDecl *RD, CharUnits &BaseOffset) {\n    auto Known = BaseOffsets.find(RD);\n    if (Known == BaseOffsets.end())\n      return false;\n    BaseOffset = Known->second;\n    return true;\n  }\n\n  bool getExternalVBaseOffset(const CXXRecordDecl *RD, CharUnits &BaseOffset) {\n    auto Known = VirtualBaseOffsets.find(RD);\n    if (Known == VirtualBaseOffsets.end())\n      return false;\n    BaseOffset = Known->second;\n    return true;\n  }\n};\n\n/// EmptySubobjectMap - Keeps track of which empty subobjects exist at different\n/// offsets while laying out a C++ class.\nclass EmptySubobjectMap {\n  const ASTContext &Context;\n  uint64_t CharWidth;\n\n  /// Class - The class whose empty entries we're keeping track of.\n  const CXXRecordDecl *Class;\n\n  /// EmptyClassOffsets - A map from offsets to empty record decls.\n  typedef llvm::TinyPtrVector<const CXXRecordDecl *> ClassVectorTy;\n  typedef llvm::DenseMap<CharUnits, ClassVectorTy> EmptyClassOffsetsMapTy;\n  EmptyClassOffsetsMapTy EmptyClassOffsets;\n\n  /// MaxEmptyClassOffset - The highest offset known to contain an empty\n  /// base subobject.\n  CharUnits MaxEmptyClassOffset;\n\n  /// ComputeEmptySubobjectSizes - Compute the size of the largest base or\n  /// member subobject that is empty.\n  void ComputeEmptySubobjectSizes();\n\n  void AddSubobjectAtOffset(const CXXRecordDecl *RD, CharUnits Offset);\n\n  void UpdateEmptyBaseSubobjects(const BaseSubobjectInfo *Info,\n                                 CharUnits Offset, bool PlacingEmptyBase);\n\n  void UpdateEmptyFieldSubobjects(const CXXRecordDecl *RD,\n                                  const CXXRecordDecl *Class, CharUnits Offset,\n                                  bool PlacingOverlappingField);\n  void UpdateEmptyFieldSubobjects(const FieldDecl *FD, CharUnits Offset,\n                                  bool PlacingOverlappingField);\n\n  /// AnyEmptySubobjectsBeyondOffset - Returns whether there are any empty\n  /// subobjects beyond the given offset.\n  bool AnyEmptySubobjectsBeyondOffset(CharUnits Offset) const {\n    return Offset <= MaxEmptyClassOffset;\n  }\n\n  CharUnits\n  getFieldOffset(const ASTRecordLayout &Layout, unsigned FieldNo) const {\n    uint64_t FieldOffset = Layout.getFieldOffset(FieldNo);\n    assert(FieldOffset % CharWidth == 0 &&\n           \"Field offset not at char boundary!\");\n\n    return Context.toCharUnitsFromBits(FieldOffset);\n  }\n\nprotected:\n  bool CanPlaceSubobjectAtOffset(const CXXRecordDecl *RD,\n                                 CharUnits Offset) const;\n\n  bool CanPlaceBaseSubobjectAtOffset(const BaseSubobjectInfo *Info,\n                                     CharUnits Offset);\n\n  bool CanPlaceFieldSubobjectAtOffset(const CXXRecordDecl *RD,\n                                      const CXXRecordDecl *Class,\n                                      CharUnits Offset) const;\n  bool CanPlaceFieldSubobjectAtOffset(const FieldDecl *FD,\n                                      CharUnits Offset) const;\n\npublic:\n  /// This holds the size of the largest empty subobject (either a base\n  /// or a member). Will be zero if the record being built doesn't contain\n  /// any empty classes.\n  CharUnits SizeOfLargestEmptySubobject;\n\n  EmptySubobjectMap(const ASTContext &Context, const CXXRecordDecl *Class)\n  : Context(Context), CharWidth(Context.getCharWidth()), Class(Class) {\n      ComputeEmptySubobjectSizes();\n  }\n\n  /// CanPlaceBaseAtOffset - Return whether the given base class can be placed\n  /// at the given offset.\n  /// Returns false if placing the record will result in two components\n  /// (direct or indirect) of the same type having the same offset.\n  bool CanPlaceBaseAtOffset(const BaseSubobjectInfo *Info,\n                            CharUnits Offset);\n\n  /// CanPlaceFieldAtOffset - Return whether a field can be placed at the given\n  /// offset.\n  bool CanPlaceFieldAtOffset(const FieldDecl *FD, CharUnits Offset);\n};\n\nvoid EmptySubobjectMap::ComputeEmptySubobjectSizes() {\n  // Check the bases.\n  for (const CXXBaseSpecifier &Base : Class->bases()) {\n    const CXXRecordDecl *BaseDecl = Base.getType()->getAsCXXRecordDecl();\n\n    CharUnits EmptySize;\n    const ASTRecordLayout &Layout = Context.getASTRecordLayout(BaseDecl);\n    if (BaseDecl->isEmpty()) {\n      // If the class decl is empty, get its size.\n      EmptySize = Layout.getSize();\n    } else {\n      // Otherwise, we get the largest empty subobject for the decl.\n      EmptySize = Layout.getSizeOfLargestEmptySubobject();\n    }\n\n    if (EmptySize > SizeOfLargestEmptySubobject)\n      SizeOfLargestEmptySubobject = EmptySize;\n  }\n\n  // Check the fields.\n  for (const FieldDecl *FD : Class->fields()) {\n    const RecordType *RT =\n        Context.getBaseElementType(FD->getType())->getAs<RecordType>();\n\n    // We only care about record types.\n    if (!RT)\n      continue;\n\n    CharUnits EmptySize;\n    const CXXRecordDecl *MemberDecl = RT->getAsCXXRecordDecl();\n    const ASTRecordLayout &Layout = Context.getASTRecordLayout(MemberDecl);\n    if (MemberDecl->isEmpty()) {\n      // If the class decl is empty, get its size.\n      EmptySize = Layout.getSize();\n    } else {\n      // Otherwise, we get the largest empty subobject for the decl.\n      EmptySize = Layout.getSizeOfLargestEmptySubobject();\n    }\n\n    if (EmptySize > SizeOfLargestEmptySubobject)\n      SizeOfLargestEmptySubobject = EmptySize;\n  }\n}\n\nbool\nEmptySubobjectMap::CanPlaceSubobjectAtOffset(const CXXRecordDecl *RD,\n                                             CharUnits Offset) const {\n  // We only need to check empty bases.\n  if (!RD->isEmpty())\n    return true;\n\n  EmptyClassOffsetsMapTy::const_iterator I = EmptyClassOffsets.find(Offset);\n  if (I == EmptyClassOffsets.end())\n    return true;\n\n  const ClassVectorTy &Classes = I->second;\n  if (llvm::find(Classes, RD) == Classes.end())\n    return true;\n\n  // There is already an empty class of the same type at this offset.\n  return false;\n}\n\nvoid EmptySubobjectMap::AddSubobjectAtOffset(const CXXRecordDecl *RD,\n                                             CharUnits Offset) {\n  // We only care about empty bases.\n  if (!RD->isEmpty())\n    return;\n\n  // If we have empty structures inside a union, we can assign both\n  // the same offset. Just avoid pushing them twice in the list.\n  ClassVectorTy &Classes = EmptyClassOffsets[Offset];\n  if (llvm::is_contained(Classes, RD))\n    return;\n\n  Classes.push_back(RD);\n\n  // Update the empty class offset.\n  if (Offset > MaxEmptyClassOffset)\n    MaxEmptyClassOffset = Offset;\n}\n\nbool\nEmptySubobjectMap::CanPlaceBaseSubobjectAtOffset(const BaseSubobjectInfo *Info,\n                                                 CharUnits Offset) {\n  // We don't have to keep looking past the maximum offset that's known to\n  // contain an empty class.\n  if (!AnyEmptySubobjectsBeyondOffset(Offset))\n    return true;\n\n  if (!CanPlaceSubobjectAtOffset(Info->Class, Offset))\n    return false;\n\n  // Traverse all non-virtual bases.\n  const ASTRecordLayout &Layout = Context.getASTRecordLayout(Info->Class);\n  for (const BaseSubobjectInfo *Base : Info->Bases) {\n    if (Base->IsVirtual)\n      continue;\n\n    CharUnits BaseOffset = Offset + Layout.getBaseClassOffset(Base->Class);\n\n    if (!CanPlaceBaseSubobjectAtOffset(Base, BaseOffset))\n      return false;\n  }\n\n  if (Info->PrimaryVirtualBaseInfo) {\n    BaseSubobjectInfo *PrimaryVirtualBaseInfo = Info->PrimaryVirtualBaseInfo;\n\n    if (Info == PrimaryVirtualBaseInfo->Derived) {\n      if (!CanPlaceBaseSubobjectAtOffset(PrimaryVirtualBaseInfo, Offset))\n        return false;\n    }\n  }\n\n  // Traverse all member variables.\n  unsigned FieldNo = 0;\n  for (CXXRecordDecl::field_iterator I = Info->Class->field_begin(),\n       E = Info->Class->field_end(); I != E; ++I, ++FieldNo) {\n    if (I->isBitField())\n      continue;\n\n    CharUnits FieldOffset = Offset + getFieldOffset(Layout, FieldNo);\n    if (!CanPlaceFieldSubobjectAtOffset(*I, FieldOffset))\n      return false;\n  }\n\n  return true;\n}\n\nvoid EmptySubobjectMap::UpdateEmptyBaseSubobjects(const BaseSubobjectInfo *Info,\n                                                  CharUnits Offset,\n                                                  bool PlacingEmptyBase) {\n  if (!PlacingEmptyBase && Offset >= SizeOfLargestEmptySubobject) {\n    // We know that the only empty subobjects that can conflict with empty\n    // subobject of non-empty bases, are empty bases that can be placed at\n    // offset zero. Because of this, we only need to keep track of empty base\n    // subobjects with offsets less than the size of the largest empty\n    // subobject for our class.\n    return;\n  }\n\n  AddSubobjectAtOffset(Info->Class, Offset);\n\n  // Traverse all non-virtual bases.\n  const ASTRecordLayout &Layout = Context.getASTRecordLayout(Info->Class);\n  for (const BaseSubobjectInfo *Base : Info->Bases) {\n    if (Base->IsVirtual)\n      continue;\n\n    CharUnits BaseOffset = Offset + Layout.getBaseClassOffset(Base->Class);\n    UpdateEmptyBaseSubobjects(Base, BaseOffset, PlacingEmptyBase);\n  }\n\n  if (Info->PrimaryVirtualBaseInfo) {\n    BaseSubobjectInfo *PrimaryVirtualBaseInfo = Info->PrimaryVirtualBaseInfo;\n\n    if (Info == PrimaryVirtualBaseInfo->Derived)\n      UpdateEmptyBaseSubobjects(PrimaryVirtualBaseInfo, Offset,\n                                PlacingEmptyBase);\n  }\n\n  // Traverse all member variables.\n  unsigned FieldNo = 0;\n  for (CXXRecordDecl::field_iterator I = Info->Class->field_begin(),\n       E = Info->Class->field_end(); I != E; ++I, ++FieldNo) {\n    if (I->isBitField())\n      continue;\n\n    CharUnits FieldOffset = Offset + getFieldOffset(Layout, FieldNo);\n    UpdateEmptyFieldSubobjects(*I, FieldOffset, PlacingEmptyBase);\n  }\n}\n\nbool EmptySubobjectMap::CanPlaceBaseAtOffset(const BaseSubobjectInfo *Info,\n                                             CharUnits Offset) {\n  // If we know this class doesn't have any empty subobjects we don't need to\n  // bother checking.\n  if (SizeOfLargestEmptySubobject.isZero())\n    return true;\n\n  if (!CanPlaceBaseSubobjectAtOffset(Info, Offset))\n    return false;\n\n  // We are able to place the base at this offset. Make sure to update the\n  // empty base subobject map.\n  UpdateEmptyBaseSubobjects(Info, Offset, Info->Class->isEmpty());\n  return true;\n}\n\nbool\nEmptySubobjectMap::CanPlaceFieldSubobjectAtOffset(const CXXRecordDecl *RD,\n                                                  const CXXRecordDecl *Class,\n                                                  CharUnits Offset) const {\n  // We don't have to keep looking past the maximum offset that's known to\n  // contain an empty class.\n  if (!AnyEmptySubobjectsBeyondOffset(Offset))\n    return true;\n\n  if (!CanPlaceSubobjectAtOffset(RD, Offset))\n    return false;\n\n  const ASTRecordLayout &Layout = Context.getASTRecordLayout(RD);\n\n  // Traverse all non-virtual bases.\n  for (const CXXBaseSpecifier &Base : RD->bases()) {\n    if (Base.isVirtual())\n      continue;\n\n    const CXXRecordDecl *BaseDecl = Base.getType()->getAsCXXRecordDecl();\n\n    CharUnits BaseOffset = Offset + Layout.getBaseClassOffset(BaseDecl);\n    if (!CanPlaceFieldSubobjectAtOffset(BaseDecl, Class, BaseOffset))\n      return false;\n  }\n\n  if (RD == Class) {\n    // This is the most derived class, traverse virtual bases as well.\n    for (const CXXBaseSpecifier &Base : RD->vbases()) {\n      const CXXRecordDecl *VBaseDecl = Base.getType()->getAsCXXRecordDecl();\n\n      CharUnits VBaseOffset = Offset + Layout.getVBaseClassOffset(VBaseDecl);\n      if (!CanPlaceFieldSubobjectAtOffset(VBaseDecl, Class, VBaseOffset))\n        return false;\n    }\n  }\n\n  // Traverse all member variables.\n  unsigned FieldNo = 0;\n  for (CXXRecordDecl::field_iterator I = RD->field_begin(), E = RD->field_end();\n       I != E; ++I, ++FieldNo) {\n    if (I->isBitField())\n      continue;\n\n    CharUnits FieldOffset = Offset + getFieldOffset(Layout, FieldNo);\n\n    if (!CanPlaceFieldSubobjectAtOffset(*I, FieldOffset))\n      return false;\n  }\n\n  return true;\n}\n\nbool\nEmptySubobjectMap::CanPlaceFieldSubobjectAtOffset(const FieldDecl *FD,\n                                                  CharUnits Offset) const {\n  // We don't have to keep looking past the maximum offset that's known to\n  // contain an empty class.\n  if (!AnyEmptySubobjectsBeyondOffset(Offset))\n    return true;\n\n  QualType T = FD->getType();\n  if (const CXXRecordDecl *RD = T->getAsCXXRecordDecl())\n    return CanPlaceFieldSubobjectAtOffset(RD, RD, Offset);\n\n  // If we have an array type we need to look at every element.\n  if (const ConstantArrayType *AT = Context.getAsConstantArrayType(T)) {\n    QualType ElemTy = Context.getBaseElementType(AT);\n    const RecordType *RT = ElemTy->getAs<RecordType>();\n    if (!RT)\n      return true;\n\n    const CXXRecordDecl *RD = RT->getAsCXXRecordDecl();\n    const ASTRecordLayout &Layout = Context.getASTRecordLayout(RD);\n\n    uint64_t NumElements = Context.getConstantArrayElementCount(AT);\n    CharUnits ElementOffset = Offset;\n    for (uint64_t I = 0; I != NumElements; ++I) {\n      // We don't have to keep looking past the maximum offset that's known to\n      // contain an empty class.\n      if (!AnyEmptySubobjectsBeyondOffset(ElementOffset))\n        return true;\n\n      if (!CanPlaceFieldSubobjectAtOffset(RD, RD, ElementOffset))\n        return false;\n\n      ElementOffset += Layout.getSize();\n    }\n  }\n\n  return true;\n}\n\nbool\nEmptySubobjectMap::CanPlaceFieldAtOffset(const FieldDecl *FD,\n                                         CharUnits Offset) {\n  if (!CanPlaceFieldSubobjectAtOffset(FD, Offset))\n    return false;\n\n  // We are able to place the member variable at this offset.\n  // Make sure to update the empty field subobject map.\n  UpdateEmptyFieldSubobjects(FD, Offset, FD->hasAttr<NoUniqueAddressAttr>());\n  return true;\n}\n\nvoid EmptySubobjectMap::UpdateEmptyFieldSubobjects(\n    const CXXRecordDecl *RD, const CXXRecordDecl *Class, CharUnits Offset,\n    bool PlacingOverlappingField) {\n  // We know that the only empty subobjects that can conflict with empty\n  // field subobjects are subobjects of empty bases and potentially-overlapping\n  // fields that can be placed at offset zero. Because of this, we only need to\n  // keep track of empty field subobjects with offsets less than the size of\n  // the largest empty subobject for our class.\n  //\n  // (Proof: we will only consider placing a subobject at offset zero or at\n  // >= the current dsize. The only cases where the earlier subobject can be\n  // placed beyond the end of dsize is if it's an empty base or a\n  // potentially-overlapping field.)\n  if (!PlacingOverlappingField && Offset >= SizeOfLargestEmptySubobject)\n    return;\n\n  AddSubobjectAtOffset(RD, Offset);\n\n  const ASTRecordLayout &Layout = Context.getASTRecordLayout(RD);\n\n  // Traverse all non-virtual bases.\n  for (const CXXBaseSpecifier &Base : RD->bases()) {\n    if (Base.isVirtual())\n      continue;\n\n    const CXXRecordDecl *BaseDecl = Base.getType()->getAsCXXRecordDecl();\n\n    CharUnits BaseOffset = Offset + Layout.getBaseClassOffset(BaseDecl);\n    UpdateEmptyFieldSubobjects(BaseDecl, Class, BaseOffset,\n                               PlacingOverlappingField);\n  }\n\n  if (RD == Class) {\n    // This is the most derived class, traverse virtual bases as well.\n    for (const CXXBaseSpecifier &Base : RD->vbases()) {\n      const CXXRecordDecl *VBaseDecl = Base.getType()->getAsCXXRecordDecl();\n\n      CharUnits VBaseOffset = Offset + Layout.getVBaseClassOffset(VBaseDecl);\n      UpdateEmptyFieldSubobjects(VBaseDecl, Class, VBaseOffset,\n                                 PlacingOverlappingField);\n    }\n  }\n\n  // Traverse all member variables.\n  unsigned FieldNo = 0;\n  for (CXXRecordDecl::field_iterator I = RD->field_begin(), E = RD->field_end();\n       I != E; ++I, ++FieldNo) {\n    if (I->isBitField())\n      continue;\n\n    CharUnits FieldOffset = Offset + getFieldOffset(Layout, FieldNo);\n\n    UpdateEmptyFieldSubobjects(*I, FieldOffset, PlacingOverlappingField);\n  }\n}\n\nvoid EmptySubobjectMap::UpdateEmptyFieldSubobjects(\n    const FieldDecl *FD, CharUnits Offset, bool PlacingOverlappingField) {\n  QualType T = FD->getType();\n  if (const CXXRecordDecl *RD = T->getAsCXXRecordDecl()) {\n    UpdateEmptyFieldSubobjects(RD, RD, Offset, PlacingOverlappingField);\n    return;\n  }\n\n  // If we have an array type we need to update every element.\n  if (const ConstantArrayType *AT = Context.getAsConstantArrayType(T)) {\n    QualType ElemTy = Context.getBaseElementType(AT);\n    const RecordType *RT = ElemTy->getAs<RecordType>();\n    if (!RT)\n      return;\n\n    const CXXRecordDecl *RD = RT->getAsCXXRecordDecl();\n    const ASTRecordLayout &Layout = Context.getASTRecordLayout(RD);\n\n    uint64_t NumElements = Context.getConstantArrayElementCount(AT);\n    CharUnits ElementOffset = Offset;\n\n    for (uint64_t I = 0; I != NumElements; ++I) {\n      // We know that the only empty subobjects that can conflict with empty\n      // field subobjects are subobjects of empty bases that can be placed at\n      // offset zero. Because of this, we only need to keep track of empty field\n      // subobjects with offsets less than the size of the largest empty\n      // subobject for our class.\n      if (!PlacingOverlappingField &&\n          ElementOffset >= SizeOfLargestEmptySubobject)\n        return;\n\n      UpdateEmptyFieldSubobjects(RD, RD, ElementOffset,\n                                 PlacingOverlappingField);\n      ElementOffset += Layout.getSize();\n    }\n  }\n}\n\ntypedef llvm::SmallPtrSet<const CXXRecordDecl*, 4> ClassSetTy;\n\nclass ItaniumRecordLayoutBuilder {\nprotected:\n  // FIXME: Remove this and make the appropriate fields public.\n  friend class clang::ASTContext;\n\n  const ASTContext &Context;\n\n  EmptySubobjectMap *EmptySubobjects;\n\n  /// Size - The current size of the record layout.\n  uint64_t Size;\n\n  /// Alignment - The current alignment of the record layout.\n  CharUnits Alignment;\n\n  /// PreferredAlignment - The preferred alignment of the record layout.\n  CharUnits PreferredAlignment;\n\n  /// The alignment if attribute packed is not used.\n  CharUnits UnpackedAlignment;\n\n  /// \\brief The maximum of the alignments of top-level members.\n  CharUnits UnadjustedAlignment;\n\n  SmallVector<uint64_t, 16> FieldOffsets;\n\n  /// Whether the external AST source has provided a layout for this\n  /// record.\n  unsigned UseExternalLayout : 1;\n\n  /// Whether we need to infer alignment, even when we have an\n  /// externally-provided layout.\n  unsigned InferAlignment : 1;\n\n  /// Packed - Whether the record is packed or not.\n  unsigned Packed : 1;\n\n  unsigned IsUnion : 1;\n\n  unsigned IsMac68kAlign : 1;\n\n  unsigned IsNaturalAlign : 1;\n\n  unsigned IsMsStruct : 1;\n\n  /// UnfilledBitsInLastUnit - If the last field laid out was a bitfield,\n  /// this contains the number of bits in the last unit that can be used for\n  /// an adjacent bitfield if necessary.  The unit in question is usually\n  /// a byte, but larger units are used if IsMsStruct.\n  unsigned char UnfilledBitsInLastUnit;\n\n  /// LastBitfieldStorageUnitSize - If IsMsStruct, represents the size of the\n  /// storage unit of the previous field if it was a bitfield.\n  unsigned char LastBitfieldStorageUnitSize;\n\n  /// MaxFieldAlignment - The maximum allowed field alignment. This is set by\n  /// #pragma pack.\n  CharUnits MaxFieldAlignment;\n\n  /// DataSize - The data size of the record being laid out.\n  uint64_t DataSize;\n\n  CharUnits NonVirtualSize;\n  CharUnits NonVirtualAlignment;\n  CharUnits PreferredNVAlignment;\n\n  /// If we've laid out a field but not included its tail padding in Size yet,\n  /// this is the size up to the end of that field.\n  CharUnits PaddedFieldSize;\n\n  /// PrimaryBase - the primary base class (if one exists) of the class\n  /// we're laying out.\n  const CXXRecordDecl *PrimaryBase;\n\n  /// PrimaryBaseIsVirtual - Whether the primary base of the class we're laying\n  /// out is virtual.\n  bool PrimaryBaseIsVirtual;\n\n  /// HasOwnVFPtr - Whether the class provides its own vtable/vftbl\n  /// pointer, as opposed to inheriting one from a primary base class.\n  bool HasOwnVFPtr;\n\n  /// the flag of field offset changing due to packed attribute.\n  bool HasPackedField;\n\n  /// HandledFirstNonOverlappingEmptyField - An auxiliary field used for AIX.\n  /// When there are OverlappingEmptyFields existing in the aggregate, the\n  /// flag shows if the following first non-empty or empty-but-non-overlapping\n  /// field has been handled, if any.\n  bool HandledFirstNonOverlappingEmptyField;\n\n  typedef llvm::DenseMap<const CXXRecordDecl *, CharUnits> BaseOffsetsMapTy;\n\n  /// Bases - base classes and their offsets in the record.\n  BaseOffsetsMapTy Bases;\n\n  // VBases - virtual base classes and their offsets in the record.\n  ASTRecordLayout::VBaseOffsetsMapTy VBases;\n\n  /// IndirectPrimaryBases - Virtual base classes, direct or indirect, that are\n  /// primary base classes for some other direct or indirect base class.\n  CXXIndirectPrimaryBaseSet IndirectPrimaryBases;\n\n  /// FirstNearlyEmptyVBase - The first nearly empty virtual base class in\n  /// inheritance graph order. Used for determining the primary base class.\n  const CXXRecordDecl *FirstNearlyEmptyVBase;\n\n  /// VisitedVirtualBases - A set of all the visited virtual bases, used to\n  /// avoid visiting virtual bases more than once.\n  llvm::SmallPtrSet<const CXXRecordDecl *, 4> VisitedVirtualBases;\n\n  /// Valid if UseExternalLayout is true.\n  ExternalLayout External;\n\n  ItaniumRecordLayoutBuilder(const ASTContext &Context,\n                             EmptySubobjectMap *EmptySubobjects)\n      : Context(Context), EmptySubobjects(EmptySubobjects), Size(0),\n        Alignment(CharUnits::One()), PreferredAlignment(CharUnits::One()),\n        UnpackedAlignment(CharUnits::One()),\n        UnadjustedAlignment(CharUnits::One()), UseExternalLayout(false),\n        InferAlignment(false), Packed(false), IsUnion(false),\n        IsMac68kAlign(false),\n        IsNaturalAlign(!Context.getTargetInfo().getTriple().isOSAIX()),\n        IsMsStruct(false), UnfilledBitsInLastUnit(0),\n        LastBitfieldStorageUnitSize(0), MaxFieldAlignment(CharUnits::Zero()),\n        DataSize(0), NonVirtualSize(CharUnits::Zero()),\n        NonVirtualAlignment(CharUnits::One()),\n        PreferredNVAlignment(CharUnits::One()),\n        PaddedFieldSize(CharUnits::Zero()), PrimaryBase(nullptr),\n        PrimaryBaseIsVirtual(false), HasOwnVFPtr(false), HasPackedField(false),\n        HandledFirstNonOverlappingEmptyField(false),\n        FirstNearlyEmptyVBase(nullptr) {}\n\n  void Layout(const RecordDecl *D);\n  void Layout(const CXXRecordDecl *D);\n  void Layout(const ObjCInterfaceDecl *D);\n\n  void LayoutFields(const RecordDecl *D);\n  void LayoutField(const FieldDecl *D, bool InsertExtraPadding);\n  void LayoutWideBitField(uint64_t FieldSize, uint64_t StorageUnitSize,\n                          bool FieldPacked, const FieldDecl *D);\n  void LayoutBitField(const FieldDecl *D);\n\n  TargetCXXABI getCXXABI() const {\n    return Context.getTargetInfo().getCXXABI();\n  }\n\n  /// BaseSubobjectInfoAllocator - Allocator for BaseSubobjectInfo objects.\n  llvm::SpecificBumpPtrAllocator<BaseSubobjectInfo> BaseSubobjectInfoAllocator;\n\n  typedef llvm::DenseMap<const CXXRecordDecl *, BaseSubobjectInfo *>\n    BaseSubobjectInfoMapTy;\n\n  /// VirtualBaseInfo - Map from all the (direct or indirect) virtual bases\n  /// of the class we're laying out to their base subobject info.\n  BaseSubobjectInfoMapTy VirtualBaseInfo;\n\n  /// NonVirtualBaseInfo - Map from all the direct non-virtual bases of the\n  /// class we're laying out to their base subobject info.\n  BaseSubobjectInfoMapTy NonVirtualBaseInfo;\n\n  /// ComputeBaseSubobjectInfo - Compute the base subobject information for the\n  /// bases of the given class.\n  void ComputeBaseSubobjectInfo(const CXXRecordDecl *RD);\n\n  /// ComputeBaseSubobjectInfo - Compute the base subobject information for a\n  /// single class and all of its base classes.\n  BaseSubobjectInfo *ComputeBaseSubobjectInfo(const CXXRecordDecl *RD,\n                                              bool IsVirtual,\n                                              BaseSubobjectInfo *Derived);\n\n  /// DeterminePrimaryBase - Determine the primary base of the given class.\n  void DeterminePrimaryBase(const CXXRecordDecl *RD);\n\n  void SelectPrimaryVBase(const CXXRecordDecl *RD);\n\n  void EnsureVTablePointerAlignment(CharUnits UnpackedBaseAlign);\n\n  /// LayoutNonVirtualBases - Determines the primary base class (if any) and\n  /// lays it out. Will then proceed to lay out all non-virtual base clasess.\n  void LayoutNonVirtualBases(const CXXRecordDecl *RD);\n\n  /// LayoutNonVirtualBase - Lays out a single non-virtual base.\n  void LayoutNonVirtualBase(const BaseSubobjectInfo *Base);\n\n  void AddPrimaryVirtualBaseOffsets(const BaseSubobjectInfo *Info,\n                                    CharUnits Offset);\n\n  /// LayoutVirtualBases - Lays out all the virtual bases.\n  void LayoutVirtualBases(const CXXRecordDecl *RD,\n                          const CXXRecordDecl *MostDerivedClass);\n\n  /// LayoutVirtualBase - Lays out a single virtual base.\n  void LayoutVirtualBase(const BaseSubobjectInfo *Base);\n\n  /// LayoutBase - Will lay out a base and return the offset where it was\n  /// placed, in chars.\n  CharUnits LayoutBase(const BaseSubobjectInfo *Base);\n\n  /// InitializeLayout - Initialize record layout for the given record decl.\n  void InitializeLayout(const Decl *D);\n\n  /// FinishLayout - Finalize record layout. Adjust record size based on the\n  /// alignment.\n  void FinishLayout(const NamedDecl *D);\n\n  void UpdateAlignment(CharUnits NewAlignment, CharUnits UnpackedNewAlignment,\n                       CharUnits PreferredAlignment);\n  void UpdateAlignment(CharUnits NewAlignment, CharUnits UnpackedNewAlignment) {\n    UpdateAlignment(NewAlignment, UnpackedNewAlignment, NewAlignment);\n  }\n  void UpdateAlignment(CharUnits NewAlignment) {\n    UpdateAlignment(NewAlignment, NewAlignment, NewAlignment);\n  }\n\n  /// Retrieve the externally-supplied field offset for the given\n  /// field.\n  ///\n  /// \\param Field The field whose offset is being queried.\n  /// \\param ComputedOffset The offset that we've computed for this field.\n  uint64_t updateExternalFieldOffset(const FieldDecl *Field,\n                                     uint64_t ComputedOffset);\n\n  void CheckFieldPadding(uint64_t Offset, uint64_t UnpaddedOffset,\n                          uint64_t UnpackedOffset, unsigned UnpackedAlign,\n                          bool isPacked, const FieldDecl *D);\n\n  DiagnosticBuilder Diag(SourceLocation Loc, unsigned DiagID);\n\n  CharUnits getSize() const {\n    assert(Size % Context.getCharWidth() == 0);\n    return Context.toCharUnitsFromBits(Size);\n  }\n  uint64_t getSizeInBits() const { return Size; }\n\n  void setSize(CharUnits NewSize) { Size = Context.toBits(NewSize); }\n  void setSize(uint64_t NewSize) { Size = NewSize; }\n\n  CharUnits getAligment() const { return Alignment; }\n\n  CharUnits getDataSize() const {\n    assert(DataSize % Context.getCharWidth() == 0);\n    return Context.toCharUnitsFromBits(DataSize);\n  }\n  uint64_t getDataSizeInBits() const { return DataSize; }\n\n  void setDataSize(CharUnits NewSize) { DataSize = Context.toBits(NewSize); }\n  void setDataSize(uint64_t NewSize) { DataSize = NewSize; }\n\n  ItaniumRecordLayoutBuilder(const ItaniumRecordLayoutBuilder &) = delete;\n  void operator=(const ItaniumRecordLayoutBuilder &) = delete;\n};\n} // end anonymous namespace\n\nvoid ItaniumRecordLayoutBuilder::SelectPrimaryVBase(const CXXRecordDecl *RD) {\n  for (const auto &I : RD->bases()) {\n    assert(!I.getType()->isDependentType() &&\n           \"Cannot layout class with dependent bases.\");\n\n    const CXXRecordDecl *Base = I.getType()->getAsCXXRecordDecl();\n\n    // Check if this is a nearly empty virtual base.\n    if (I.isVirtual() && Context.isNearlyEmpty(Base)) {\n      // If it's not an indirect primary base, then we've found our primary\n      // base.\n      if (!IndirectPrimaryBases.count(Base)) {\n        PrimaryBase = Base;\n        PrimaryBaseIsVirtual = true;\n        return;\n      }\n\n      // Is this the first nearly empty virtual base?\n      if (!FirstNearlyEmptyVBase)\n        FirstNearlyEmptyVBase = Base;\n    }\n\n    SelectPrimaryVBase(Base);\n    if (PrimaryBase)\n      return;\n  }\n}\n\n/// DeterminePrimaryBase - Determine the primary base of the given class.\nvoid ItaniumRecordLayoutBuilder::DeterminePrimaryBase(const CXXRecordDecl *RD) {\n  // If the class isn't dynamic, it won't have a primary base.\n  if (!RD->isDynamicClass())\n    return;\n\n  // Compute all the primary virtual bases for all of our direct and\n  // indirect bases, and record all their primary virtual base classes.\n  RD->getIndirectPrimaryBases(IndirectPrimaryBases);\n\n  // If the record has a dynamic base class, attempt to choose a primary base\n  // class. It is the first (in direct base class order) non-virtual dynamic\n  // base class, if one exists.\n  for (const auto &I : RD->bases()) {\n    // Ignore virtual bases.\n    if (I.isVirtual())\n      continue;\n\n    const CXXRecordDecl *Base = I.getType()->getAsCXXRecordDecl();\n\n    if (Base->isDynamicClass()) {\n      // We found it.\n      PrimaryBase = Base;\n      PrimaryBaseIsVirtual = false;\n      return;\n    }\n  }\n\n  // Under the Itanium ABI, if there is no non-virtual primary base class,\n  // try to compute the primary virtual base.  The primary virtual base is\n  // the first nearly empty virtual base that is not an indirect primary\n  // virtual base class, if one exists.\n  if (RD->getNumVBases() != 0) {\n    SelectPrimaryVBase(RD);\n    if (PrimaryBase)\n      return;\n  }\n\n  // Otherwise, it is the first indirect primary base class, if one exists.\n  if (FirstNearlyEmptyVBase) {\n    PrimaryBase = FirstNearlyEmptyVBase;\n    PrimaryBaseIsVirtual = true;\n    return;\n  }\n\n  assert(!PrimaryBase && \"Should not get here with a primary base!\");\n}\n\nBaseSubobjectInfo *ItaniumRecordLayoutBuilder::ComputeBaseSubobjectInfo(\n    const CXXRecordDecl *RD, bool IsVirtual, BaseSubobjectInfo *Derived) {\n  BaseSubobjectInfo *Info;\n\n  if (IsVirtual) {\n    // Check if we already have info about this virtual base.\n    BaseSubobjectInfo *&InfoSlot = VirtualBaseInfo[RD];\n    if (InfoSlot) {\n      assert(InfoSlot->Class == RD && \"Wrong class for virtual base info!\");\n      return InfoSlot;\n    }\n\n    // We don't, create it.\n    InfoSlot = new (BaseSubobjectInfoAllocator.Allocate()) BaseSubobjectInfo;\n    Info = InfoSlot;\n  } else {\n    Info = new (BaseSubobjectInfoAllocator.Allocate()) BaseSubobjectInfo;\n  }\n\n  Info->Class = RD;\n  Info->IsVirtual = IsVirtual;\n  Info->Derived = nullptr;\n  Info->PrimaryVirtualBaseInfo = nullptr;\n\n  const CXXRecordDecl *PrimaryVirtualBase = nullptr;\n  BaseSubobjectInfo *PrimaryVirtualBaseInfo = nullptr;\n\n  // Check if this base has a primary virtual base.\n  if (RD->getNumVBases()) {\n    const ASTRecordLayout &Layout = Context.getASTRecordLayout(RD);\n    if (Layout.isPrimaryBaseVirtual()) {\n      // This base does have a primary virtual base.\n      PrimaryVirtualBase = Layout.getPrimaryBase();\n      assert(PrimaryVirtualBase && \"Didn't have a primary virtual base!\");\n\n      // Now check if we have base subobject info about this primary base.\n      PrimaryVirtualBaseInfo = VirtualBaseInfo.lookup(PrimaryVirtualBase);\n\n      if (PrimaryVirtualBaseInfo) {\n        if (PrimaryVirtualBaseInfo->Derived) {\n          // We did have info about this primary base, and it turns out that it\n          // has already been claimed as a primary virtual base for another\n          // base.\n          PrimaryVirtualBase = nullptr;\n        } else {\n          // We can claim this base as our primary base.\n          Info->PrimaryVirtualBaseInfo = PrimaryVirtualBaseInfo;\n          PrimaryVirtualBaseInfo->Derived = Info;\n        }\n      }\n    }\n  }\n\n  // Now go through all direct bases.\n  for (const auto &I : RD->bases()) {\n    bool IsVirtual = I.isVirtual();\n\n    const CXXRecordDecl *BaseDecl = I.getType()->getAsCXXRecordDecl();\n\n    Info->Bases.push_back(ComputeBaseSubobjectInfo(BaseDecl, IsVirtual, Info));\n  }\n\n  if (PrimaryVirtualBase && !PrimaryVirtualBaseInfo) {\n    // Traversing the bases must have created the base info for our primary\n    // virtual base.\n    PrimaryVirtualBaseInfo = VirtualBaseInfo.lookup(PrimaryVirtualBase);\n    assert(PrimaryVirtualBaseInfo &&\n           \"Did not create a primary virtual base!\");\n\n    // Claim the primary virtual base as our primary virtual base.\n    Info->PrimaryVirtualBaseInfo = PrimaryVirtualBaseInfo;\n    PrimaryVirtualBaseInfo->Derived = Info;\n  }\n\n  return Info;\n}\n\nvoid ItaniumRecordLayoutBuilder::ComputeBaseSubobjectInfo(\n    const CXXRecordDecl *RD) {\n  for (const auto &I : RD->bases()) {\n    bool IsVirtual = I.isVirtual();\n\n    const CXXRecordDecl *BaseDecl = I.getType()->getAsCXXRecordDecl();\n\n    // Compute the base subobject info for this base.\n    BaseSubobjectInfo *Info = ComputeBaseSubobjectInfo(BaseDecl, IsVirtual,\n                                                       nullptr);\n\n    if (IsVirtual) {\n      // ComputeBaseInfo has already added this base for us.\n      assert(VirtualBaseInfo.count(BaseDecl) &&\n             \"Did not add virtual base!\");\n    } else {\n      // Add the base info to the map of non-virtual bases.\n      assert(!NonVirtualBaseInfo.count(BaseDecl) &&\n             \"Non-virtual base already exists!\");\n      NonVirtualBaseInfo.insert(std::make_pair(BaseDecl, Info));\n    }\n  }\n}\n\nvoid ItaniumRecordLayoutBuilder::EnsureVTablePointerAlignment(\n    CharUnits UnpackedBaseAlign) {\n  CharUnits BaseAlign = Packed ? CharUnits::One() : UnpackedBaseAlign;\n\n  // The maximum field alignment overrides base align.\n  if (!MaxFieldAlignment.isZero()) {\n    BaseAlign = std::min(BaseAlign, MaxFieldAlignment);\n    UnpackedBaseAlign = std::min(UnpackedBaseAlign, MaxFieldAlignment);\n  }\n\n  // Round up the current record size to pointer alignment.\n  setSize(getSize().alignTo(BaseAlign));\n\n  // Update the alignment.\n  UpdateAlignment(BaseAlign, UnpackedBaseAlign, BaseAlign);\n}\n\nvoid ItaniumRecordLayoutBuilder::LayoutNonVirtualBases(\n    const CXXRecordDecl *RD) {\n  // Then, determine the primary base class.\n  DeterminePrimaryBase(RD);\n\n  // Compute base subobject info.\n  ComputeBaseSubobjectInfo(RD);\n\n  // If we have a primary base class, lay it out.\n  if (PrimaryBase) {\n    if (PrimaryBaseIsVirtual) {\n      // If the primary virtual base was a primary virtual base of some other\n      // base class we'll have to steal it.\n      BaseSubobjectInfo *PrimaryBaseInfo = VirtualBaseInfo.lookup(PrimaryBase);\n      PrimaryBaseInfo->Derived = nullptr;\n\n      // We have a virtual primary base, insert it as an indirect primary base.\n      IndirectPrimaryBases.insert(PrimaryBase);\n\n      assert(!VisitedVirtualBases.count(PrimaryBase) &&\n             \"vbase already visited!\");\n      VisitedVirtualBases.insert(PrimaryBase);\n\n      LayoutVirtualBase(PrimaryBaseInfo);\n    } else {\n      BaseSubobjectInfo *PrimaryBaseInfo =\n        NonVirtualBaseInfo.lookup(PrimaryBase);\n      assert(PrimaryBaseInfo &&\n             \"Did not find base info for non-virtual primary base!\");\n\n      LayoutNonVirtualBase(PrimaryBaseInfo);\n    }\n\n  // If this class needs a vtable/vf-table and didn't get one from a\n  // primary base, add it in now.\n  } else if (RD->isDynamicClass()) {\n    assert(DataSize == 0 && \"Vtable pointer must be at offset zero!\");\n    CharUnits PtrWidth =\n      Context.toCharUnitsFromBits(Context.getTargetInfo().getPointerWidth(0));\n    CharUnits PtrAlign =\n      Context.toCharUnitsFromBits(Context.getTargetInfo().getPointerAlign(0));\n    EnsureVTablePointerAlignment(PtrAlign);\n    HasOwnVFPtr = true;\n\n    assert(!IsUnion && \"Unions cannot be dynamic classes.\");\n    HandledFirstNonOverlappingEmptyField = true;\n\n    setSize(getSize() + PtrWidth);\n    setDataSize(getSize());\n  }\n\n  // Now lay out the non-virtual bases.\n  for (const auto &I : RD->bases()) {\n\n    // Ignore virtual bases.\n    if (I.isVirtual())\n      continue;\n\n    const CXXRecordDecl *BaseDecl = I.getType()->getAsCXXRecordDecl();\n\n    // Skip the primary base, because we've already laid it out.  The\n    // !PrimaryBaseIsVirtual check is required because we might have a\n    // non-virtual base of the same type as a primary virtual base.\n    if (BaseDecl == PrimaryBase && !PrimaryBaseIsVirtual)\n      continue;\n\n    // Lay out the base.\n    BaseSubobjectInfo *BaseInfo = NonVirtualBaseInfo.lookup(BaseDecl);\n    assert(BaseInfo && \"Did not find base info for non-virtual base!\");\n\n    LayoutNonVirtualBase(BaseInfo);\n  }\n}\n\nvoid ItaniumRecordLayoutBuilder::LayoutNonVirtualBase(\n    const BaseSubobjectInfo *Base) {\n  // Layout the base.\n  CharUnits Offset = LayoutBase(Base);\n\n  // Add its base class offset.\n  assert(!Bases.count(Base->Class) && \"base offset already exists!\");\n  Bases.insert(std::make_pair(Base->Class, Offset));\n\n  AddPrimaryVirtualBaseOffsets(Base, Offset);\n}\n\nvoid ItaniumRecordLayoutBuilder::AddPrimaryVirtualBaseOffsets(\n    const BaseSubobjectInfo *Info, CharUnits Offset) {\n  // This base isn't interesting, it has no virtual bases.\n  if (!Info->Class->getNumVBases())\n    return;\n\n  // First, check if we have a virtual primary base to add offsets for.\n  if (Info->PrimaryVirtualBaseInfo) {\n    assert(Info->PrimaryVirtualBaseInfo->IsVirtual &&\n           \"Primary virtual base is not virtual!\");\n    if (Info->PrimaryVirtualBaseInfo->Derived == Info) {\n      // Add the offset.\n      assert(!VBases.count(Info->PrimaryVirtualBaseInfo->Class) &&\n             \"primary vbase offset already exists!\");\n      VBases.insert(std::make_pair(Info->PrimaryVirtualBaseInfo->Class,\n                                   ASTRecordLayout::VBaseInfo(Offset, false)));\n\n      // Traverse the primary virtual base.\n      AddPrimaryVirtualBaseOffsets(Info->PrimaryVirtualBaseInfo, Offset);\n    }\n  }\n\n  // Now go through all direct non-virtual bases.\n  const ASTRecordLayout &Layout = Context.getASTRecordLayout(Info->Class);\n  for (const BaseSubobjectInfo *Base : Info->Bases) {\n    if (Base->IsVirtual)\n      continue;\n\n    CharUnits BaseOffset = Offset + Layout.getBaseClassOffset(Base->Class);\n    AddPrimaryVirtualBaseOffsets(Base, BaseOffset);\n  }\n}\n\nvoid ItaniumRecordLayoutBuilder::LayoutVirtualBases(\n    const CXXRecordDecl *RD, const CXXRecordDecl *MostDerivedClass) {\n  const CXXRecordDecl *PrimaryBase;\n  bool PrimaryBaseIsVirtual;\n\n  if (MostDerivedClass == RD) {\n    PrimaryBase = this->PrimaryBase;\n    PrimaryBaseIsVirtual = this->PrimaryBaseIsVirtual;\n  } else {\n    const ASTRecordLayout &Layout = Context.getASTRecordLayout(RD);\n    PrimaryBase = Layout.getPrimaryBase();\n    PrimaryBaseIsVirtual = Layout.isPrimaryBaseVirtual();\n  }\n\n  for (const CXXBaseSpecifier &Base : RD->bases()) {\n    assert(!Base.getType()->isDependentType() &&\n           \"Cannot layout class with dependent bases.\");\n\n    const CXXRecordDecl *BaseDecl = Base.getType()->getAsCXXRecordDecl();\n\n    if (Base.isVirtual()) {\n      if (PrimaryBase != BaseDecl || !PrimaryBaseIsVirtual) {\n        bool IndirectPrimaryBase = IndirectPrimaryBases.count(BaseDecl);\n\n        // Only lay out the virtual base if it's not an indirect primary base.\n        if (!IndirectPrimaryBase) {\n          // Only visit virtual bases once.\n          if (!VisitedVirtualBases.insert(BaseDecl).second)\n            continue;\n\n          const BaseSubobjectInfo *BaseInfo = VirtualBaseInfo.lookup(BaseDecl);\n          assert(BaseInfo && \"Did not find virtual base info!\");\n          LayoutVirtualBase(BaseInfo);\n        }\n      }\n    }\n\n    if (!BaseDecl->getNumVBases()) {\n      // This base isn't interesting since it doesn't have any virtual bases.\n      continue;\n    }\n\n    LayoutVirtualBases(BaseDecl, MostDerivedClass);\n  }\n}\n\nvoid ItaniumRecordLayoutBuilder::LayoutVirtualBase(\n    const BaseSubobjectInfo *Base) {\n  assert(!Base->Derived && \"Trying to lay out a primary virtual base!\");\n\n  // Layout the base.\n  CharUnits Offset = LayoutBase(Base);\n\n  // Add its base class offset.\n  assert(!VBases.count(Base->Class) && \"vbase offset already exists!\");\n  VBases.insert(std::make_pair(Base->Class,\n                       ASTRecordLayout::VBaseInfo(Offset, false)));\n\n  AddPrimaryVirtualBaseOffsets(Base, Offset);\n}\n\nCharUnits\nItaniumRecordLayoutBuilder::LayoutBase(const BaseSubobjectInfo *Base) {\n  assert(!IsUnion && \"Unions cannot have base classes.\");\n\n  const ASTRecordLayout &Layout = Context.getASTRecordLayout(Base->Class);\n  CharUnits Offset;\n\n  // Query the external layout to see if it provides an offset.\n  bool HasExternalLayout = false;\n  if (UseExternalLayout) {\n    if (Base->IsVirtual)\n      HasExternalLayout = External.getExternalVBaseOffset(Base->Class, Offset);\n    else\n      HasExternalLayout = External.getExternalNVBaseOffset(Base->Class, Offset);\n  }\n\n  auto getBaseOrPreferredBaseAlignFromUnpacked = [&](CharUnits UnpackedAlign) {\n    // Clang <= 6 incorrectly applied the 'packed' attribute to base classes.\n    // Per GCC's documentation, it only applies to non-static data members.\n    return (Packed && ((Context.getLangOpts().getClangABICompat() <=\n                        LangOptions::ClangABI::Ver6) ||\n                       Context.getTargetInfo().getTriple().isPS4() ||\n                       Context.getTargetInfo().getTriple().isOSAIX()))\n               ? CharUnits::One()\n               : UnpackedAlign;\n  };\n\n  CharUnits UnpackedBaseAlign = Layout.getNonVirtualAlignment();\n  CharUnits UnpackedPreferredBaseAlign = Layout.getPreferredNVAlignment();\n  CharUnits BaseAlign =\n      getBaseOrPreferredBaseAlignFromUnpacked(UnpackedBaseAlign);\n  CharUnits PreferredBaseAlign =\n      getBaseOrPreferredBaseAlignFromUnpacked(UnpackedPreferredBaseAlign);\n\n  const bool DefaultsToAIXPowerAlignment =\n      Context.getTargetInfo().defaultsToAIXPowerAlignment();\n  if (DefaultsToAIXPowerAlignment) {\n    // AIX `power` alignment does not apply the preferred alignment for\n    // non-union classes if the source of the alignment (the current base in\n    // this context) follows introduction of the first subobject with\n    // exclusively allocated space or zero-extent array.\n    if (!Base->Class->isEmpty() && !HandledFirstNonOverlappingEmptyField) {\n      // By handling a base class that is not empty, we're handling the\n      // \"first (inherited) member\".\n      HandledFirstNonOverlappingEmptyField = true;\n    } else if (!IsNaturalAlign) {\n      UnpackedPreferredBaseAlign = UnpackedBaseAlign;\n      PreferredBaseAlign = BaseAlign;\n    }\n  }\n\n  CharUnits UnpackedAlignTo = !DefaultsToAIXPowerAlignment\n                                  ? UnpackedBaseAlign\n                                  : UnpackedPreferredBaseAlign;\n  // If we have an empty base class, try to place it at offset 0.\n  if (Base->Class->isEmpty() &&\n      (!HasExternalLayout || Offset == CharUnits::Zero()) &&\n      EmptySubobjects->CanPlaceBaseAtOffset(Base, CharUnits::Zero())) {\n    setSize(std::max(getSize(), Layout.getSize()));\n    UpdateAlignment(BaseAlign, UnpackedAlignTo, PreferredBaseAlign);\n\n    return CharUnits::Zero();\n  }\n\n  // The maximum field alignment overrides the base align/(AIX-only) preferred\n  // base align.\n  if (!MaxFieldAlignment.isZero()) {\n    BaseAlign = std::min(BaseAlign, MaxFieldAlignment);\n    PreferredBaseAlign = std::min(PreferredBaseAlign, MaxFieldAlignment);\n    UnpackedAlignTo = std::min(UnpackedAlignTo, MaxFieldAlignment);\n  }\n\n  CharUnits AlignTo =\n      !DefaultsToAIXPowerAlignment ? BaseAlign : PreferredBaseAlign;\n  if (!HasExternalLayout) {\n    // Round up the current record size to the base's alignment boundary.\n    Offset = getDataSize().alignTo(AlignTo);\n\n    // Try to place the base.\n    while (!EmptySubobjects->CanPlaceBaseAtOffset(Base, Offset))\n      Offset += AlignTo;\n  } else {\n    bool Allowed = EmptySubobjects->CanPlaceBaseAtOffset(Base, Offset);\n    (void)Allowed;\n    assert(Allowed && \"Base subobject externally placed at overlapping offset\");\n\n    if (InferAlignment && Offset < getDataSize().alignTo(AlignTo)) {\n      // The externally-supplied base offset is before the base offset we\n      // computed. Assume that the structure is packed.\n      Alignment = CharUnits::One();\n      InferAlignment = false;\n    }\n  }\n\n  if (!Base->Class->isEmpty()) {\n    // Update the data size.\n    setDataSize(Offset + Layout.getNonVirtualSize());\n\n    setSize(std::max(getSize(), getDataSize()));\n  } else\n    setSize(std::max(getSize(), Offset + Layout.getSize()));\n\n  // Remember max struct/class alignment.\n  UpdateAlignment(BaseAlign, UnpackedAlignTo, PreferredBaseAlign);\n\n  return Offset;\n}\n\nvoid ItaniumRecordLayoutBuilder::InitializeLayout(const Decl *D) {\n  if (const RecordDecl *RD = dyn_cast<RecordDecl>(D)) {\n    IsUnion = RD->isUnion();\n    IsMsStruct = RD->isMsStruct(Context);\n  }\n\n  Packed = D->hasAttr<PackedAttr>();\n\n  // Honor the default struct packing maximum alignment flag.\n  if (unsigned DefaultMaxFieldAlignment = Context.getLangOpts().PackStruct) {\n    MaxFieldAlignment = CharUnits::fromQuantity(DefaultMaxFieldAlignment);\n  }\n\n  // mac68k alignment supersedes maximum field alignment and attribute aligned,\n  // and forces all structures to have 2-byte alignment. The IBM docs on it\n  // allude to additional (more complicated) semantics, especially with regard\n  // to bit-fields, but gcc appears not to follow that.\n  if (D->hasAttr<AlignMac68kAttr>()) {\n    assert(\n        !D->hasAttr<AlignNaturalAttr>() &&\n        \"Having both mac68k and natural alignment on a decl is not allowed.\");\n    IsMac68kAlign = true;\n    MaxFieldAlignment = CharUnits::fromQuantity(2);\n    Alignment = CharUnits::fromQuantity(2);\n    PreferredAlignment = CharUnits::fromQuantity(2);\n  } else {\n    if (D->hasAttr<AlignNaturalAttr>())\n      IsNaturalAlign = true;\n\n    if (const MaxFieldAlignmentAttr *MFAA = D->getAttr<MaxFieldAlignmentAttr>())\n      MaxFieldAlignment = Context.toCharUnitsFromBits(MFAA->getAlignment());\n\n    if (unsigned MaxAlign = D->getMaxAlignment())\n      UpdateAlignment(Context.toCharUnitsFromBits(MaxAlign));\n  }\n\n  HandledFirstNonOverlappingEmptyField =\n      !Context.getTargetInfo().defaultsToAIXPowerAlignment() || IsNaturalAlign;\n\n  // If there is an external AST source, ask it for the various offsets.\n  if (const RecordDecl *RD = dyn_cast<RecordDecl>(D))\n    if (ExternalASTSource *Source = Context.getExternalSource()) {\n      UseExternalLayout = Source->layoutRecordType(\n          RD, External.Size, External.Align, External.FieldOffsets,\n          External.BaseOffsets, External.VirtualBaseOffsets);\n\n      // Update based on external alignment.\n      if (UseExternalLayout) {\n        if (External.Align > 0) {\n          Alignment = Context.toCharUnitsFromBits(External.Align);\n          PreferredAlignment = Context.toCharUnitsFromBits(External.Align);\n        } else {\n          // The external source didn't have alignment information; infer it.\n          InferAlignment = true;\n        }\n      }\n    }\n}\n\nvoid ItaniumRecordLayoutBuilder::Layout(const RecordDecl *D) {\n  InitializeLayout(D);\n  LayoutFields(D);\n\n  // Finally, round the size of the total struct up to the alignment of the\n  // struct itself.\n  FinishLayout(D);\n}\n\nvoid ItaniumRecordLayoutBuilder::Layout(const CXXRecordDecl *RD) {\n  InitializeLayout(RD);\n\n  // Lay out the vtable and the non-virtual bases.\n  LayoutNonVirtualBases(RD);\n\n  LayoutFields(RD);\n\n  NonVirtualSize = Context.toCharUnitsFromBits(\n      llvm::alignTo(getSizeInBits(), Context.getTargetInfo().getCharAlign()));\n  NonVirtualAlignment = Alignment;\n  PreferredNVAlignment = PreferredAlignment;\n\n  // Lay out the virtual bases and add the primary virtual base offsets.\n  LayoutVirtualBases(RD, RD);\n\n  // Finally, round the size of the total struct up to the alignment\n  // of the struct itself.\n  FinishLayout(RD);\n\n#ifndef NDEBUG\n  // Check that we have base offsets for all bases.\n  for (const CXXBaseSpecifier &Base : RD->bases()) {\n    if (Base.isVirtual())\n      continue;\n\n    const CXXRecordDecl *BaseDecl = Base.getType()->getAsCXXRecordDecl();\n\n    assert(Bases.count(BaseDecl) && \"Did not find base offset!\");\n  }\n\n  // And all virtual bases.\n  for (const CXXBaseSpecifier &Base : RD->vbases()) {\n    const CXXRecordDecl *BaseDecl = Base.getType()->getAsCXXRecordDecl();\n\n    assert(VBases.count(BaseDecl) && \"Did not find base offset!\");\n  }\n#endif\n}\n\nvoid ItaniumRecordLayoutBuilder::Layout(const ObjCInterfaceDecl *D) {\n  if (ObjCInterfaceDecl *SD = D->getSuperClass()) {\n    const ASTRecordLayout &SL = Context.getASTObjCInterfaceLayout(SD);\n\n    UpdateAlignment(SL.getAlignment());\n\n    // We start laying out ivars not at the end of the superclass\n    // structure, but at the next byte following the last field.\n    setDataSize(SL.getDataSize());\n    setSize(getDataSize());\n  }\n\n  InitializeLayout(D);\n  // Layout each ivar sequentially.\n  for (const ObjCIvarDecl *IVD = D->all_declared_ivar_begin(); IVD;\n       IVD = IVD->getNextIvar())\n    LayoutField(IVD, false);\n\n  // Finally, round the size of the total struct up to the alignment of the\n  // struct itself.\n  FinishLayout(D);\n}\n\nvoid ItaniumRecordLayoutBuilder::LayoutFields(const RecordDecl *D) {\n  // Layout each field, for now, just sequentially, respecting alignment.  In\n  // the future, this will need to be tweakable by targets.\n  bool InsertExtraPadding = D->mayInsertExtraPadding(/*EmitRemark=*/true);\n  bool HasFlexibleArrayMember = D->hasFlexibleArrayMember();\n  for (auto I = D->field_begin(), End = D->field_end(); I != End; ++I) {\n    auto Next(I);\n    ++Next;\n    LayoutField(*I,\n                InsertExtraPadding && (Next != End || !HasFlexibleArrayMember));\n  }\n}\n\n// Rounds the specified size to have it a multiple of the char size.\nstatic uint64_t\nroundUpSizeToCharAlignment(uint64_t Size,\n                           const ASTContext &Context) {\n  uint64_t CharAlignment = Context.getTargetInfo().getCharAlign();\n  return llvm::alignTo(Size, CharAlignment);\n}\n\nvoid ItaniumRecordLayoutBuilder::LayoutWideBitField(uint64_t FieldSize,\n                                                    uint64_t StorageUnitSize,\n                                                    bool FieldPacked,\n                                                    const FieldDecl *D) {\n  assert(Context.getLangOpts().CPlusPlus &&\n         \"Can only have wide bit-fields in C++!\");\n\n  // Itanium C++ ABI 2.4:\n  //   If sizeof(T)*8 < n, let T' be the largest integral POD type with\n  //   sizeof(T')*8 <= n.\n\n  QualType IntegralPODTypes[] = {\n    Context.UnsignedCharTy, Context.UnsignedShortTy, Context.UnsignedIntTy,\n    Context.UnsignedLongTy, Context.UnsignedLongLongTy\n  };\n\n  QualType Type;\n  for (const QualType &QT : IntegralPODTypes) {\n    uint64_t Size = Context.getTypeSize(QT);\n\n    if (Size > FieldSize)\n      break;\n\n    Type = QT;\n  }\n  assert(!Type.isNull() && \"Did not find a type!\");\n\n  CharUnits TypeAlign = Context.getTypeAlignInChars(Type);\n\n  // We're not going to use any of the unfilled bits in the last byte.\n  UnfilledBitsInLastUnit = 0;\n  LastBitfieldStorageUnitSize = 0;\n\n  uint64_t FieldOffset;\n  uint64_t UnpaddedFieldOffset = getDataSizeInBits() - UnfilledBitsInLastUnit;\n\n  if (IsUnion) {\n    uint64_t RoundedFieldSize = roundUpSizeToCharAlignment(FieldSize,\n                                                           Context);\n    setDataSize(std::max(getDataSizeInBits(), RoundedFieldSize));\n    FieldOffset = 0;\n  } else {\n    // The bitfield is allocated starting at the next offset aligned\n    // appropriately for T', with length n bits.\n    FieldOffset = llvm::alignTo(getDataSizeInBits(), Context.toBits(TypeAlign));\n\n    uint64_t NewSizeInBits = FieldOffset + FieldSize;\n\n    setDataSize(\n        llvm::alignTo(NewSizeInBits, Context.getTargetInfo().getCharAlign()));\n    UnfilledBitsInLastUnit = getDataSizeInBits() - NewSizeInBits;\n  }\n\n  // Place this field at the current location.\n  FieldOffsets.push_back(FieldOffset);\n\n  CheckFieldPadding(FieldOffset, UnpaddedFieldOffset, FieldOffset,\n                    Context.toBits(TypeAlign), FieldPacked, D);\n\n  // Update the size.\n  setSize(std::max(getSizeInBits(), getDataSizeInBits()));\n\n  // Remember max struct/class alignment.\n  UpdateAlignment(TypeAlign);\n}\n\nvoid ItaniumRecordLayoutBuilder::LayoutBitField(const FieldDecl *D) {\n  bool FieldPacked = Packed || D->hasAttr<PackedAttr>();\n  uint64_t FieldSize = D->getBitWidthValue(Context);\n  TypeInfo FieldInfo = Context.getTypeInfo(D->getType());\n  uint64_t StorageUnitSize = FieldInfo.Width;\n  unsigned FieldAlign = FieldInfo.Align;\n\n  // UnfilledBitsInLastUnit is the difference between the end of the\n  // last allocated bitfield (i.e. the first bit offset available for\n  // bitfields) and the end of the current data size in bits (i.e. the\n  // first bit offset available for non-bitfields).  The current data\n  // size in bits is always a multiple of the char size; additionally,\n  // for ms_struct records it's also a multiple of the\n  // LastBitfieldStorageUnitSize (if set).\n\n  // The struct-layout algorithm is dictated by the platform ABI,\n  // which in principle could use almost any rules it likes.  In\n  // practice, UNIXy targets tend to inherit the algorithm described\n  // in the System V generic ABI.  The basic bitfield layout rule in\n  // System V is to place bitfields at the next available bit offset\n  // where the entire bitfield would fit in an aligned storage unit of\n  // the declared type; it's okay if an earlier or later non-bitfield\n  // is allocated in the same storage unit.  However, some targets\n  // (those that !useBitFieldTypeAlignment(), e.g. ARM APCS) don't\n  // require this storage unit to be aligned, and therefore always put\n  // the bitfield at the next available bit offset.\n\n  // ms_struct basically requests a complete replacement of the\n  // platform ABI's struct-layout algorithm, with the high-level goal\n  // of duplicating MSVC's layout.  For non-bitfields, this follows\n  // the standard algorithm.  The basic bitfield layout rule is to\n  // allocate an entire unit of the bitfield's declared type\n  // (e.g. 'unsigned long'), then parcel it up among successive\n  // bitfields whose declared types have the same size, making a new\n  // unit as soon as the last can no longer store the whole value.\n  // Since it completely replaces the platform ABI's algorithm,\n  // settings like !useBitFieldTypeAlignment() do not apply.\n\n  // A zero-width bitfield forces the use of a new storage unit for\n  // later bitfields.  In general, this occurs by rounding up the\n  // current size of the struct as if the algorithm were about to\n  // place a non-bitfield of the field's formal type.  Usually this\n  // does not change the alignment of the struct itself, but it does\n  // on some targets (those that useZeroLengthBitfieldAlignment(),\n  // e.g. ARM).  In ms_struct layout, zero-width bitfields are\n  // ignored unless they follow a non-zero-width bitfield.\n\n  // A field alignment restriction (e.g. from #pragma pack) or\n  // specification (e.g. from __attribute__((aligned))) changes the\n  // formal alignment of the field.  For System V, this alters the\n  // required alignment of the notional storage unit that must contain\n  // the bitfield.  For ms_struct, this only affects the placement of\n  // new storage units.  In both cases, the effect of #pragma pack is\n  // ignored on zero-width bitfields.\n\n  // On System V, a packed field (e.g. from #pragma pack or\n  // __attribute__((packed))) always uses the next available bit\n  // offset.\n\n  // In an ms_struct struct, the alignment of a fundamental type is\n  // always equal to its size.  This is necessary in order to mimic\n  // the i386 alignment rules on targets which might not fully align\n  // all types (e.g. Darwin PPC32, where alignof(long long) == 4).\n\n  // First, some simple bookkeeping to perform for ms_struct structs.\n  if (IsMsStruct) {\n    // The field alignment for integer types is always the size.\n    FieldAlign = StorageUnitSize;\n\n    // If the previous field was not a bitfield, or was a bitfield\n    // with a different storage unit size, or if this field doesn't fit into\n    // the current storage unit, we're done with that storage unit.\n    if (LastBitfieldStorageUnitSize != StorageUnitSize ||\n        UnfilledBitsInLastUnit < FieldSize) {\n      // Also, ignore zero-length bitfields after non-bitfields.\n      if (!LastBitfieldStorageUnitSize && !FieldSize)\n        FieldAlign = 1;\n\n      UnfilledBitsInLastUnit = 0;\n      LastBitfieldStorageUnitSize = 0;\n    }\n  }\n\n  // If the field is wider than its declared type, it follows\n  // different rules in all cases.\n  if (FieldSize > StorageUnitSize) {\n    LayoutWideBitField(FieldSize, StorageUnitSize, FieldPacked, D);\n    return;\n  }\n\n  // Compute the next available bit offset.\n  uint64_t FieldOffset =\n    IsUnion ? 0 : (getDataSizeInBits() - UnfilledBitsInLastUnit);\n\n  // Handle targets that don't honor bitfield type alignment.\n  if (!IsMsStruct && !Context.getTargetInfo().useBitFieldTypeAlignment()) {\n    // Some such targets do honor it on zero-width bitfields.\n    if (FieldSize == 0 &&\n        Context.getTargetInfo().useZeroLengthBitfieldAlignment()) {\n      // The alignment to round up to is the max of the field's natural\n      // alignment and a target-specific fixed value (sometimes zero).\n      unsigned ZeroLengthBitfieldBoundary =\n        Context.getTargetInfo().getZeroLengthBitfieldBoundary();\n      FieldAlign = std::max(FieldAlign, ZeroLengthBitfieldBoundary);\n\n    // If that doesn't apply, just ignore the field alignment.\n    } else {\n      FieldAlign = 1;\n    }\n  }\n\n  // Remember the alignment we would have used if the field were not packed.\n  unsigned UnpackedFieldAlign = FieldAlign;\n\n  // Ignore the field alignment if the field is packed unless it has zero-size.\n  if (!IsMsStruct && FieldPacked && FieldSize != 0)\n    FieldAlign = 1;\n\n  // But, if there's an 'aligned' attribute on the field, honor that.\n  unsigned ExplicitFieldAlign = D->getMaxAlignment();\n  if (ExplicitFieldAlign) {\n    FieldAlign = std::max(FieldAlign, ExplicitFieldAlign);\n    UnpackedFieldAlign = std::max(UnpackedFieldAlign, ExplicitFieldAlign);\n  }\n\n  // But, if there's a #pragma pack in play, that takes precedent over\n  // even the 'aligned' attribute, for non-zero-width bitfields.\n  unsigned MaxFieldAlignmentInBits = Context.toBits(MaxFieldAlignment);\n  if (!MaxFieldAlignment.isZero() && FieldSize) {\n    UnpackedFieldAlign = std::min(UnpackedFieldAlign, MaxFieldAlignmentInBits);\n    if (FieldPacked)\n      FieldAlign = UnpackedFieldAlign;\n    else\n      FieldAlign = std::min(FieldAlign, MaxFieldAlignmentInBits);\n  }\n\n  // But, ms_struct just ignores all of that in unions, even explicit\n  // alignment attributes.\n  if (IsMsStruct && IsUnion) {\n    FieldAlign = UnpackedFieldAlign = 1;\n  }\n\n  // For purposes of diagnostics, we're going to simultaneously\n  // compute the field offsets that we would have used if we weren't\n  // adding any alignment padding or if the field weren't packed.\n  uint64_t UnpaddedFieldOffset = FieldOffset;\n  uint64_t UnpackedFieldOffset = FieldOffset;\n\n  // Check if we need to add padding to fit the bitfield within an\n  // allocation unit with the right size and alignment.  The rules are\n  // somewhat different here for ms_struct structs.\n  if (IsMsStruct) {\n    // If it's not a zero-width bitfield, and we can fit the bitfield\n    // into the active storage unit (and we haven't already decided to\n    // start a new storage unit), just do so, regardless of any other\n    // other consideration.  Otherwise, round up to the right alignment.\n    if (FieldSize == 0 || FieldSize > UnfilledBitsInLastUnit) {\n      FieldOffset = llvm::alignTo(FieldOffset, FieldAlign);\n      UnpackedFieldOffset =\n          llvm::alignTo(UnpackedFieldOffset, UnpackedFieldAlign);\n      UnfilledBitsInLastUnit = 0;\n    }\n\n  } else {\n    // #pragma pack, with any value, suppresses the insertion of padding.\n    bool AllowPadding = MaxFieldAlignment.isZero();\n\n    // Compute the real offset.\n    if (FieldSize == 0 ||\n        (AllowPadding &&\n         (FieldOffset & (FieldAlign - 1)) + FieldSize > StorageUnitSize)) {\n      FieldOffset = llvm::alignTo(FieldOffset, FieldAlign);\n    } else if (ExplicitFieldAlign &&\n               (MaxFieldAlignmentInBits == 0 ||\n                ExplicitFieldAlign <= MaxFieldAlignmentInBits) &&\n               Context.getTargetInfo().useExplicitBitFieldAlignment()) {\n      // TODO: figure it out what needs to be done on targets that don't honor\n      // bit-field type alignment like ARM APCS ABI.\n      FieldOffset = llvm::alignTo(FieldOffset, ExplicitFieldAlign);\n    }\n\n    // Repeat the computation for diagnostic purposes.\n    if (FieldSize == 0 ||\n        (AllowPadding &&\n         (UnpackedFieldOffset & (UnpackedFieldAlign - 1)) + FieldSize >\n             StorageUnitSize))\n      UnpackedFieldOffset =\n          llvm::alignTo(UnpackedFieldOffset, UnpackedFieldAlign);\n    else if (ExplicitFieldAlign &&\n             (MaxFieldAlignmentInBits == 0 ||\n              ExplicitFieldAlign <= MaxFieldAlignmentInBits) &&\n             Context.getTargetInfo().useExplicitBitFieldAlignment())\n      UnpackedFieldOffset =\n          llvm::alignTo(UnpackedFieldOffset, ExplicitFieldAlign);\n  }\n\n  // If we're using external layout, give the external layout a chance\n  // to override this information.\n  if (UseExternalLayout)\n    FieldOffset = updateExternalFieldOffset(D, FieldOffset);\n\n  // Okay, place the bitfield at the calculated offset.\n  FieldOffsets.push_back(FieldOffset);\n\n  // Bookkeeping:\n\n  // Anonymous members don't affect the overall record alignment,\n  // except on targets where they do.\n  if (!IsMsStruct &&\n      !Context.getTargetInfo().useZeroLengthBitfieldAlignment() &&\n      !D->getIdentifier())\n    FieldAlign = UnpackedFieldAlign = 1;\n\n  // Diagnose differences in layout due to padding or packing.\n  if (!UseExternalLayout)\n    CheckFieldPadding(FieldOffset, UnpaddedFieldOffset, UnpackedFieldOffset,\n                      UnpackedFieldAlign, FieldPacked, D);\n\n  // Update DataSize to include the last byte containing (part of) the bitfield.\n\n  // For unions, this is just a max operation, as usual.\n  if (IsUnion) {\n    // For ms_struct, allocate the entire storage unit --- unless this\n    // is a zero-width bitfield, in which case just use a size of 1.\n    uint64_t RoundedFieldSize;\n    if (IsMsStruct) {\n      RoundedFieldSize = (FieldSize ? StorageUnitSize\n                                    : Context.getTargetInfo().getCharWidth());\n\n      // Otherwise, allocate just the number of bytes required to store\n      // the bitfield.\n    } else {\n      RoundedFieldSize = roundUpSizeToCharAlignment(FieldSize, Context);\n    }\n    setDataSize(std::max(getDataSizeInBits(), RoundedFieldSize));\n\n  // For non-zero-width bitfields in ms_struct structs, allocate a new\n  // storage unit if necessary.\n  } else if (IsMsStruct && FieldSize) {\n    // We should have cleared UnfilledBitsInLastUnit in every case\n    // where we changed storage units.\n    if (!UnfilledBitsInLastUnit) {\n      setDataSize(FieldOffset + StorageUnitSize);\n      UnfilledBitsInLastUnit = StorageUnitSize;\n    }\n    UnfilledBitsInLastUnit -= FieldSize;\n    LastBitfieldStorageUnitSize = StorageUnitSize;\n\n    // Otherwise, bump the data size up to include the bitfield,\n    // including padding up to char alignment, and then remember how\n    // bits we didn't use.\n  } else {\n    uint64_t NewSizeInBits = FieldOffset + FieldSize;\n    uint64_t CharAlignment = Context.getTargetInfo().getCharAlign();\n    setDataSize(llvm::alignTo(NewSizeInBits, CharAlignment));\n    UnfilledBitsInLastUnit = getDataSizeInBits() - NewSizeInBits;\n\n    // The only time we can get here for an ms_struct is if this is a\n    // zero-width bitfield, which doesn't count as anything for the\n    // purposes of unfilled bits.\n    LastBitfieldStorageUnitSize = 0;\n  }\n\n  // Update the size.\n  setSize(std::max(getSizeInBits(), getDataSizeInBits()));\n\n  // Remember max struct/class alignment.\n  UnadjustedAlignment =\n      std::max(UnadjustedAlignment, Context.toCharUnitsFromBits(FieldAlign));\n  UpdateAlignment(Context.toCharUnitsFromBits(FieldAlign),\n                  Context.toCharUnitsFromBits(UnpackedFieldAlign));\n}\n\nvoid ItaniumRecordLayoutBuilder::LayoutField(const FieldDecl *D,\n                                             bool InsertExtraPadding) {\n  auto *FieldClass = D->getType()->getAsCXXRecordDecl();\n  bool PotentiallyOverlapping = D->hasAttr<NoUniqueAddressAttr>() && FieldClass;\n  bool IsOverlappingEmptyField =\n      PotentiallyOverlapping && FieldClass->isEmpty();\n\n  CharUnits FieldOffset =\n      (IsUnion || IsOverlappingEmptyField) ? CharUnits::Zero() : getDataSize();\n\n  const bool DefaultsToAIXPowerAlignment =\n      Context.getTargetInfo().defaultsToAIXPowerAlignment();\n  bool FoundFirstNonOverlappingEmptyFieldForAIX = false;\n  if (DefaultsToAIXPowerAlignment && !HandledFirstNonOverlappingEmptyField) {\n    assert(FieldOffset == CharUnits::Zero() &&\n           \"The first non-overlapping empty field should have been handled.\");\n\n    if (!IsOverlappingEmptyField) {\n      FoundFirstNonOverlappingEmptyFieldForAIX = true;\n\n      // We're going to handle the \"first member\" based on\n      // `FoundFirstNonOverlappingEmptyFieldForAIX` during the current\n      // invocation of this function; record it as handled for future\n      // invocations (except for unions, because the current field does not\n      // represent all \"firsts\").\n      HandledFirstNonOverlappingEmptyField = !IsUnion;\n    }\n  }\n\n  if (D->isBitField()) {\n    LayoutBitField(D);\n    return;\n  }\n\n  uint64_t UnpaddedFieldOffset = getDataSizeInBits() - UnfilledBitsInLastUnit;\n  // Reset the unfilled bits.\n  UnfilledBitsInLastUnit = 0;\n  LastBitfieldStorageUnitSize = 0;\n\n  bool FieldPacked = Packed || D->hasAttr<PackedAttr>();\n\n  bool AlignIsRequired = false;\n  CharUnits FieldSize;\n  CharUnits FieldAlign;\n  // The amount of this class's dsize occupied by the field.\n  // This is equal to FieldSize unless we're permitted to pack\n  // into the field's tail padding.\n  CharUnits EffectiveFieldSize;\n\n  auto setDeclInfo = [&](bool IsIncompleteArrayType) {\n    auto TI = Context.getTypeInfoInChars(D->getType());\n    FieldAlign = TI.Align;\n    // Flexible array members don't have any size, but they have to be\n    // aligned appropriately for their element type.\n    EffectiveFieldSize = FieldSize =\n        IsIncompleteArrayType ? CharUnits::Zero() : TI.Width;\n    AlignIsRequired = TI.AlignIsRequired;\n  };\n\n  if (D->getType()->isIncompleteArrayType()) {\n    setDeclInfo(true /* IsIncompleteArrayType */);\n  } else if (const ReferenceType *RT = D->getType()->getAs<ReferenceType>()) {\n    unsigned AS = Context.getTargetAddressSpace(RT->getPointeeType());\n    EffectiveFieldSize = FieldSize = Context.toCharUnitsFromBits(\n        Context.getTargetInfo().getPointerWidth(AS));\n    FieldAlign = Context.toCharUnitsFromBits(\n        Context.getTargetInfo().getPointerAlign(AS));\n  } else {\n    setDeclInfo(false /* IsIncompleteArrayType */);\n\n    // A potentially-overlapping field occupies its dsize or nvsize, whichever\n    // is larger.\n    if (PotentiallyOverlapping) {\n      const ASTRecordLayout &Layout = Context.getASTRecordLayout(FieldClass);\n      EffectiveFieldSize =\n          std::max(Layout.getNonVirtualSize(), Layout.getDataSize());\n    }\n\n    if (IsMsStruct) {\n      // If MS bitfield layout is required, figure out what type is being\n      // laid out and align the field to the width of that type.\n\n      // Resolve all typedefs down to their base type and round up the field\n      // alignment if necessary.\n      QualType T = Context.getBaseElementType(D->getType());\n      if (const BuiltinType *BTy = T->getAs<BuiltinType>()) {\n        CharUnits TypeSize = Context.getTypeSizeInChars(BTy);\n\n        if (!llvm::isPowerOf2_64(TypeSize.getQuantity())) {\n          assert(\n              !Context.getTargetInfo().getTriple().isWindowsMSVCEnvironment() &&\n              \"Non PowerOf2 size in MSVC mode\");\n          // Base types with sizes that aren't a power of two don't work\n          // with the layout rules for MS structs. This isn't an issue in\n          // MSVC itself since there are no such base data types there.\n          // On e.g. x86_32 mingw and linux, long double is 12 bytes though.\n          // Any structs involving that data type obviously can't be ABI\n          // compatible with MSVC regardless of how it is laid out.\n\n          // Since ms_struct can be mass enabled (via a pragma or via the\n          // -mms-bitfields command line parameter), this can trigger for\n          // structs that don't actually need MSVC compatibility, so we\n          // need to be able to sidestep the ms_struct layout for these types.\n\n          // Since the combination of -mms-bitfields together with structs\n          // like max_align_t (which contains a long double) for mingw is\n          // quite comon (and GCC handles it silently), just handle it\n          // silently there. For other targets that have ms_struct enabled\n          // (most probably via a pragma or attribute), trigger a diagnostic\n          // that defaults to an error.\n          if (!Context.getTargetInfo().getTriple().isWindowsGNUEnvironment())\n            Diag(D->getLocation(), diag::warn_npot_ms_struct);\n        }\n        if (TypeSize > FieldAlign &&\n            llvm::isPowerOf2_64(TypeSize.getQuantity()))\n          FieldAlign = TypeSize;\n      }\n    }\n  }\n\n  // The AIX `power` alignment rules apply the natural alignment of the\n  // \"first member\" if it is of a floating-point data type (or is an aggregate\n  // whose recursively \"first\" member or element is such a type). The alignment\n  // associated with these types for subsequent members use an alignment value\n  // where the floating-point data type is considered to have 4-byte alignment.\n  //\n  // For the purposes of the foregoing: vtable pointers, non-empty base classes,\n  // and zero-width bit-fields count as prior members; members of empty class\n  // types marked `no_unique_address` are not considered to be prior members.\n  CharUnits PreferredAlign = FieldAlign;\n  if (DefaultsToAIXPowerAlignment && !AlignIsRequired &&\n      (FoundFirstNonOverlappingEmptyFieldForAIX || IsNaturalAlign)) {\n    auto performBuiltinTypeAlignmentUpgrade = [&](const BuiltinType *BTy) {\n      if (BTy->getKind() == BuiltinType::Double ||\n          BTy->getKind() == BuiltinType::LongDouble) {\n        assert(PreferredAlign == CharUnits::fromQuantity(4) &&\n               \"No need to upgrade the alignment value.\");\n        PreferredAlign = CharUnits::fromQuantity(8);\n      }\n    };\n\n    const Type *Ty = D->getType()->getBaseElementTypeUnsafe();\n    if (const ComplexType *CTy = Ty->getAs<ComplexType>()) {\n      performBuiltinTypeAlignmentUpgrade(CTy->getElementType()->castAs<BuiltinType>());\n    } else if (const BuiltinType *BTy = Ty->getAs<BuiltinType>()) {\n      performBuiltinTypeAlignmentUpgrade(BTy);\n    } else if (const RecordType *RT = Ty->getAs<RecordType>()) {\n      const RecordDecl *RD = RT->getDecl();\n      assert(RD && \"Expected non-null RecordDecl.\");\n      const ASTRecordLayout &FieldRecord = Context.getASTRecordLayout(RD);\n      PreferredAlign = FieldRecord.getPreferredAlignment();\n    }\n  }\n\n  // The align if the field is not packed. This is to check if the attribute\n  // was unnecessary (-Wpacked).\n  CharUnits UnpackedFieldAlign =\n      !DefaultsToAIXPowerAlignment ? FieldAlign : PreferredAlign;\n  CharUnits UnpackedFieldOffset = FieldOffset;\n\n  if (FieldPacked) {\n    FieldAlign = CharUnits::One();\n    PreferredAlign = CharUnits::One();\n  }\n  CharUnits MaxAlignmentInChars =\n      Context.toCharUnitsFromBits(D->getMaxAlignment());\n  FieldAlign = std::max(FieldAlign, MaxAlignmentInChars);\n  PreferredAlign = std::max(PreferredAlign, MaxAlignmentInChars);\n  UnpackedFieldAlign = std::max(UnpackedFieldAlign, MaxAlignmentInChars);\n\n  // The maximum field alignment overrides the aligned attribute.\n  if (!MaxFieldAlignment.isZero()) {\n    FieldAlign = std::min(FieldAlign, MaxFieldAlignment);\n    PreferredAlign = std::min(PreferredAlign, MaxFieldAlignment);\n    UnpackedFieldAlign = std::min(UnpackedFieldAlign, MaxFieldAlignment);\n  }\n\n  CharUnits AlignTo =\n      !DefaultsToAIXPowerAlignment ? FieldAlign : PreferredAlign;\n  // Round up the current record size to the field's alignment boundary.\n  FieldOffset = FieldOffset.alignTo(AlignTo);\n  UnpackedFieldOffset = UnpackedFieldOffset.alignTo(UnpackedFieldAlign);\n\n  if (UseExternalLayout) {\n    FieldOffset = Context.toCharUnitsFromBits(\n        updateExternalFieldOffset(D, Context.toBits(FieldOffset)));\n\n    if (!IsUnion && EmptySubobjects) {\n      // Record the fact that we're placing a field at this offset.\n      bool Allowed = EmptySubobjects->CanPlaceFieldAtOffset(D, FieldOffset);\n      (void)Allowed;\n      assert(Allowed && \"Externally-placed field cannot be placed here\");\n    }\n  } else {\n    if (!IsUnion && EmptySubobjects) {\n      // Check if we can place the field at this offset.\n      while (!EmptySubobjects->CanPlaceFieldAtOffset(D, FieldOffset)) {\n        // We couldn't place the field at the offset. Try again at a new offset.\n        // We try offset 0 (for an empty field) and then dsize(C) onwards.\n        if (FieldOffset == CharUnits::Zero() &&\n            getDataSize() != CharUnits::Zero())\n          FieldOffset = getDataSize().alignTo(AlignTo);\n        else\n          FieldOffset += AlignTo;\n      }\n    }\n  }\n\n  // Place this field at the current location.\n  FieldOffsets.push_back(Context.toBits(FieldOffset));\n\n  if (!UseExternalLayout)\n    CheckFieldPadding(Context.toBits(FieldOffset), UnpaddedFieldOffset,\n                      Context.toBits(UnpackedFieldOffset),\n                      Context.toBits(UnpackedFieldAlign), FieldPacked, D);\n\n  if (InsertExtraPadding) {\n    CharUnits ASanAlignment = CharUnits::fromQuantity(8);\n    CharUnits ExtraSizeForAsan = ASanAlignment;\n    if (FieldSize % ASanAlignment)\n      ExtraSizeForAsan +=\n          ASanAlignment - CharUnits::fromQuantity(FieldSize % ASanAlignment);\n    EffectiveFieldSize = FieldSize = FieldSize + ExtraSizeForAsan;\n  }\n\n  // Reserve space for this field.\n  if (!IsOverlappingEmptyField) {\n    uint64_t EffectiveFieldSizeInBits = Context.toBits(EffectiveFieldSize);\n    if (IsUnion)\n      setDataSize(std::max(getDataSizeInBits(), EffectiveFieldSizeInBits));\n    else\n      setDataSize(FieldOffset + EffectiveFieldSize);\n\n    PaddedFieldSize = std::max(PaddedFieldSize, FieldOffset + FieldSize);\n    setSize(std::max(getSizeInBits(), getDataSizeInBits()));\n  } else {\n    setSize(std::max(getSizeInBits(),\n                     (uint64_t)Context.toBits(FieldOffset + FieldSize)));\n  }\n\n  // Remember max struct/class ABI-specified alignment.\n  UnadjustedAlignment = std::max(UnadjustedAlignment, FieldAlign);\n  UpdateAlignment(FieldAlign, UnpackedFieldAlign, PreferredAlign);\n}\n\nvoid ItaniumRecordLayoutBuilder::FinishLayout(const NamedDecl *D) {\n  // In C++, records cannot be of size 0.\n  if (Context.getLangOpts().CPlusPlus && getSizeInBits() == 0) {\n    if (const CXXRecordDecl *RD = dyn_cast<CXXRecordDecl>(D)) {\n      // Compatibility with gcc requires a class (pod or non-pod)\n      // which is not empty but of size 0; such as having fields of\n      // array of zero-length, remains of Size 0\n      if (RD->isEmpty())\n        setSize(CharUnits::One());\n    }\n    else\n      setSize(CharUnits::One());\n  }\n\n  // If we have any remaining field tail padding, include that in the overall\n  // size.\n  setSize(std::max(getSizeInBits(), (uint64_t)Context.toBits(PaddedFieldSize)));\n\n  // Finally, round the size of the record up to the alignment of the\n  // record itself.\n  uint64_t UnpaddedSize = getSizeInBits() - UnfilledBitsInLastUnit;\n  uint64_t UnpackedSizeInBits =\n      llvm::alignTo(getSizeInBits(), Context.toBits(UnpackedAlignment));\n\n  uint64_t RoundedSize = llvm::alignTo(\n      getSizeInBits(),\n      Context.toBits(!Context.getTargetInfo().defaultsToAIXPowerAlignment()\n                         ? Alignment\n                         : PreferredAlignment));\n\n  if (UseExternalLayout) {\n    // If we're inferring alignment, and the external size is smaller than\n    // our size after we've rounded up to alignment, conservatively set the\n    // alignment to 1.\n    if (InferAlignment && External.Size < RoundedSize) {\n      Alignment = CharUnits::One();\n      PreferredAlignment = CharUnits::One();\n      InferAlignment = false;\n    }\n    setSize(External.Size);\n    return;\n  }\n\n  // Set the size to the final size.\n  setSize(RoundedSize);\n\n  unsigned CharBitNum = Context.getTargetInfo().getCharWidth();\n  if (const RecordDecl *RD = dyn_cast<RecordDecl>(D)) {\n    // Warn if padding was introduced to the struct/class/union.\n    if (getSizeInBits() > UnpaddedSize) {\n      unsigned PadSize = getSizeInBits() - UnpaddedSize;\n      bool InBits = true;\n      if (PadSize % CharBitNum == 0) {\n        PadSize = PadSize / CharBitNum;\n        InBits = false;\n      }\n      Diag(RD->getLocation(), diag::warn_padded_struct_size)\n          << Context.getTypeDeclType(RD)\n          << PadSize\n          << (InBits ? 1 : 0); // (byte|bit)\n    }\n\n    // Warn if we packed it unnecessarily, when the unpacked alignment is not\n    // greater than the one after packing, the size in bits doesn't change and\n    // the offset of each field is identical.\n    if (Packed && UnpackedAlignment <= Alignment &&\n        UnpackedSizeInBits == getSizeInBits() && !HasPackedField)\n      Diag(D->getLocation(), diag::warn_unnecessary_packed)\n          << Context.getTypeDeclType(RD);\n  }\n}\n\nvoid ItaniumRecordLayoutBuilder::UpdateAlignment(\n    CharUnits NewAlignment, CharUnits UnpackedNewAlignment,\n    CharUnits PreferredNewAlignment) {\n  // The alignment is not modified when using 'mac68k' alignment or when\n  // we have an externally-supplied layout that also provides overall alignment.\n  if (IsMac68kAlign || (UseExternalLayout && !InferAlignment))\n    return;\n\n  if (NewAlignment > Alignment) {\n    assert(llvm::isPowerOf2_64(NewAlignment.getQuantity()) &&\n           \"Alignment not a power of 2\");\n    Alignment = NewAlignment;\n  }\n\n  if (UnpackedNewAlignment > UnpackedAlignment) {\n    assert(llvm::isPowerOf2_64(UnpackedNewAlignment.getQuantity()) &&\n           \"Alignment not a power of 2\");\n    UnpackedAlignment = UnpackedNewAlignment;\n  }\n\n  if (PreferredNewAlignment > PreferredAlignment) {\n    assert(llvm::isPowerOf2_64(PreferredNewAlignment.getQuantity()) &&\n           \"Alignment not a power of 2\");\n    PreferredAlignment = PreferredNewAlignment;\n  }\n}\n\nuint64_t\nItaniumRecordLayoutBuilder::updateExternalFieldOffset(const FieldDecl *Field,\n                                                      uint64_t ComputedOffset) {\n  uint64_t ExternalFieldOffset = External.getExternalFieldOffset(Field);\n\n  if (InferAlignment && ExternalFieldOffset < ComputedOffset) {\n    // The externally-supplied field offset is before the field offset we\n    // computed. Assume that the structure is packed.\n    Alignment = CharUnits::One();\n    PreferredAlignment = CharUnits::One();\n    InferAlignment = false;\n  }\n\n  // Use the externally-supplied field offset.\n  return ExternalFieldOffset;\n}\n\n/// Get diagnostic %select index for tag kind for\n/// field padding diagnostic message.\n/// WARNING: Indexes apply to particular diagnostics only!\n///\n/// \\returns diagnostic %select index.\nstatic unsigned getPaddingDiagFromTagKind(TagTypeKind Tag) {\n  switch (Tag) {\n  case TTK_Struct: return 0;\n  case TTK_Interface: return 1;\n  case TTK_Class: return 2;\n  default: llvm_unreachable(\"Invalid tag kind for field padding diagnostic!\");\n  }\n}\n\nvoid ItaniumRecordLayoutBuilder::CheckFieldPadding(\n    uint64_t Offset, uint64_t UnpaddedOffset, uint64_t UnpackedOffset,\n    unsigned UnpackedAlign, bool isPacked, const FieldDecl *D) {\n  // We let objc ivars without warning, objc interfaces generally are not used\n  // for padding tricks.\n  if (isa<ObjCIvarDecl>(D))\n    return;\n\n  // Don't warn about structs created without a SourceLocation.  This can\n  // be done by clients of the AST, such as codegen.\n  if (D->getLocation().isInvalid())\n    return;\n\n  unsigned CharBitNum = Context.getTargetInfo().getCharWidth();\n\n  // Warn if padding was introduced to the struct/class.\n  if (!IsUnion && Offset > UnpaddedOffset) {\n    unsigned PadSize = Offset - UnpaddedOffset;\n    bool InBits = true;\n    if (PadSize % CharBitNum == 0) {\n      PadSize = PadSize / CharBitNum;\n      InBits = false;\n    }\n    if (D->getIdentifier())\n      Diag(D->getLocation(), diag::warn_padded_struct_field)\n          << getPaddingDiagFromTagKind(D->getParent()->getTagKind())\n          << Context.getTypeDeclType(D->getParent())\n          << PadSize\n          << (InBits ? 1 : 0) // (byte|bit)\n          << D->getIdentifier();\n    else\n      Diag(D->getLocation(), diag::warn_padded_struct_anon_field)\n          << getPaddingDiagFromTagKind(D->getParent()->getTagKind())\n          << Context.getTypeDeclType(D->getParent())\n          << PadSize\n          << (InBits ? 1 : 0); // (byte|bit)\n }\n if (isPacked && Offset != UnpackedOffset) {\n   HasPackedField = true;\n }\n}\n\nstatic const CXXMethodDecl *computeKeyFunction(ASTContext &Context,\n                                               const CXXRecordDecl *RD) {\n  // If a class isn't polymorphic it doesn't have a key function.\n  if (!RD->isPolymorphic())\n    return nullptr;\n\n  // A class that is not externally visible doesn't have a key function. (Or\n  // at least, there's no point to assigning a key function to such a class;\n  // this doesn't affect the ABI.)\n  if (!RD->isExternallyVisible())\n    return nullptr;\n\n  // Template instantiations don't have key functions per Itanium C++ ABI 5.2.6.\n  // Same behavior as GCC.\n  TemplateSpecializationKind TSK = RD->getTemplateSpecializationKind();\n  if (TSK == TSK_ImplicitInstantiation ||\n      TSK == TSK_ExplicitInstantiationDeclaration ||\n      TSK == TSK_ExplicitInstantiationDefinition)\n    return nullptr;\n\n  bool allowInlineFunctions =\n    Context.getTargetInfo().getCXXABI().canKeyFunctionBeInline();\n\n  for (const CXXMethodDecl *MD : RD->methods()) {\n    if (!MD->isVirtual())\n      continue;\n\n    if (MD->isPure())\n      continue;\n\n    // Ignore implicit member functions, they are always marked as inline, but\n    // they don't have a body until they're defined.\n    if (MD->isImplicit())\n      continue;\n\n    if (MD->isInlineSpecified() || MD->isConstexpr())\n      continue;\n\n    if (MD->hasInlineBody())\n      continue;\n\n    // Ignore inline deleted or defaulted functions.\n    if (!MD->isUserProvided())\n      continue;\n\n    // In certain ABIs, ignore functions with out-of-line inline definitions.\n    if (!allowInlineFunctions) {\n      const FunctionDecl *Def;\n      if (MD->hasBody(Def) && Def->isInlineSpecified())\n        continue;\n    }\n\n    if (Context.getLangOpts().CUDA) {\n      // While compiler may see key method in this TU, during CUDA\n      // compilation we should ignore methods that are not accessible\n      // on this side of compilation.\n      if (Context.getLangOpts().CUDAIsDevice) {\n        // In device mode ignore methods without __device__ attribute.\n        if (!MD->hasAttr<CUDADeviceAttr>())\n          continue;\n      } else {\n        // In host mode ignore __device__-only methods.\n        if (!MD->hasAttr<CUDAHostAttr>() && MD->hasAttr<CUDADeviceAttr>())\n          continue;\n      }\n    }\n\n    // If the key function is dllimport but the class isn't, then the class has\n    // no key function. The DLL that exports the key function won't export the\n    // vtable in this case.\n    if (MD->hasAttr<DLLImportAttr>() && !RD->hasAttr<DLLImportAttr>())\n      return nullptr;\n\n    // We found it.\n    return MD;\n  }\n\n  return nullptr;\n}\n\nDiagnosticBuilder ItaniumRecordLayoutBuilder::Diag(SourceLocation Loc,\n                                                   unsigned DiagID) {\n  return Context.getDiagnostics().Report(Loc, DiagID);\n}\n\n/// Does the target C++ ABI require us to skip over the tail-padding\n/// of the given class (considering it as a base class) when allocating\n/// objects?\nstatic bool mustSkipTailPadding(TargetCXXABI ABI, const CXXRecordDecl *RD) {\n  switch (ABI.getTailPaddingUseRules()) {\n  case TargetCXXABI::AlwaysUseTailPadding:\n    return false;\n\n  case TargetCXXABI::UseTailPaddingUnlessPOD03:\n    // FIXME: To the extent that this is meant to cover the Itanium ABI\n    // rules, we should implement the restrictions about over-sized\n    // bitfields:\n    //\n    // http://itanium-cxx-abi.github.io/cxx-abi/abi.html#POD :\n    //   In general, a type is considered a POD for the purposes of\n    //   layout if it is a POD type (in the sense of ISO C++\n    //   [basic.types]). However, a POD-struct or POD-union (in the\n    //   sense of ISO C++ [class]) with a bitfield member whose\n    //   declared width is wider than the declared type of the\n    //   bitfield is not a POD for the purpose of layout.  Similarly,\n    //   an array type is not a POD for the purpose of layout if the\n    //   element type of the array is not a POD for the purpose of\n    //   layout.\n    //\n    //   Where references to the ISO C++ are made in this paragraph,\n    //   the Technical Corrigendum 1 version of the standard is\n    //   intended.\n    return RD->isPOD();\n\n  case TargetCXXABI::UseTailPaddingUnlessPOD11:\n    // This is equivalent to RD->getTypeForDecl().isCXX11PODType(),\n    // but with a lot of abstraction penalty stripped off.  This does\n    // assume that these properties are set correctly even in C++98\n    // mode; fortunately, that is true because we want to assign\n    // consistently semantics to the type-traits intrinsics (or at\n    // least as many of them as possible).\n    return RD->isTrivial() && RD->isCXX11StandardLayout();\n  }\n\n  llvm_unreachable(\"bad tail-padding use kind\");\n}\n\nstatic bool isMsLayout(const ASTContext &Context) {\n  return Context.getTargetInfo().getCXXABI().isMicrosoft();\n}\n\n// This section contains an implementation of struct layout that is, up to the\n// included tests, compatible with cl.exe (2013).  The layout produced is\n// significantly different than those produced by the Itanium ABI.  Here we note\n// the most important differences.\n//\n// * The alignment of bitfields in unions is ignored when computing the\n//   alignment of the union.\n// * The existence of zero-width bitfield that occurs after anything other than\n//   a non-zero length bitfield is ignored.\n// * There is no explicit primary base for the purposes of layout.  All bases\n//   with vfptrs are laid out first, followed by all bases without vfptrs.\n// * The Itanium equivalent vtable pointers are split into a vfptr (virtual\n//   function pointer) and a vbptr (virtual base pointer).  They can each be\n//   shared with a, non-virtual bases. These bases need not be the same.  vfptrs\n//   always occur at offset 0.  vbptrs can occur at an arbitrary offset and are\n//   placed after the lexicographically last non-virtual base.  This placement\n//   is always before fields but can be in the middle of the non-virtual bases\n//   due to the two-pass layout scheme for non-virtual-bases.\n// * Virtual bases sometimes require a 'vtordisp' field that is laid out before\n//   the virtual base and is used in conjunction with virtual overrides during\n//   construction and destruction.  This is always a 4 byte value and is used as\n//   an alternative to constructor vtables.\n// * vtordisps are allocated in a block of memory with size and alignment equal\n//   to the alignment of the completed structure (before applying __declspec(\n//   align())).  The vtordisp always occur at the end of the allocation block,\n//   immediately prior to the virtual base.\n// * vfptrs are injected after all bases and fields have been laid out.  In\n//   order to guarantee proper alignment of all fields, the vfptr injection\n//   pushes all bases and fields back by the alignment imposed by those bases\n//   and fields.  This can potentially add a significant amount of padding.\n//   vfptrs are always injected at offset 0.\n// * vbptrs are injected after all bases and fields have been laid out.  In\n//   order to guarantee proper alignment of all fields, the vfptr injection\n//   pushes all bases and fields back by the alignment imposed by those bases\n//   and fields.  This can potentially add a significant amount of padding.\n//   vbptrs are injected immediately after the last non-virtual base as\n//   lexicographically ordered in the code.  If this site isn't pointer aligned\n//   the vbptr is placed at the next properly aligned location.  Enough padding\n//   is added to guarantee a fit.\n// * The last zero sized non-virtual base can be placed at the end of the\n//   struct (potentially aliasing another object), or may alias with the first\n//   field, even if they are of the same type.\n// * The last zero size virtual base may be placed at the end of the struct\n//   potentially aliasing another object.\n// * The ABI attempts to avoid aliasing of zero sized bases by adding padding\n//   between bases or vbases with specific properties.  The criteria for\n//   additional padding between two bases is that the first base is zero sized\n//   or ends with a zero sized subobject and the second base is zero sized or\n//   trails with a zero sized base or field (sharing of vfptrs can reorder the\n//   layout of the so the leading base is not always the first one declared).\n//   This rule does take into account fields that are not records, so padding\n//   will occur even if the last field is, e.g. an int. The padding added for\n//   bases is 1 byte.  The padding added between vbases depends on the alignment\n//   of the object but is at least 4 bytes (in both 32 and 64 bit modes).\n// * There is no concept of non-virtual alignment, non-virtual alignment and\n//   alignment are always identical.\n// * There is a distinction between alignment and required alignment.\n//   __declspec(align) changes the required alignment of a struct.  This\n//   alignment is _always_ obeyed, even in the presence of #pragma pack. A\n//   record inherits required alignment from all of its fields and bases.\n// * __declspec(align) on bitfields has the effect of changing the bitfield's\n//   alignment instead of its required alignment.  This is the only known way\n//   to make the alignment of a struct bigger than 8.  Interestingly enough\n//   this alignment is also immune to the effects of #pragma pack and can be\n//   used to create structures with large alignment under #pragma pack.\n//   However, because it does not impact required alignment, such a structure,\n//   when used as a field or base, will not be aligned if #pragma pack is\n//   still active at the time of use.\n//\n// Known incompatibilities:\n// * all: #pragma pack between fields in a record\n// * 2010 and back: If the last field in a record is a bitfield, every object\n//   laid out after the record will have extra padding inserted before it.  The\n//   extra padding will have size equal to the size of the storage class of the\n//   bitfield.  0 sized bitfields don't exhibit this behavior and the extra\n//   padding can be avoided by adding a 0 sized bitfield after the non-zero-\n//   sized bitfield.\n// * 2012 and back: In 64-bit mode, if the alignment of a record is 16 or\n//   greater due to __declspec(align()) then a second layout phase occurs after\n//   The locations of the vf and vb pointers are known.  This layout phase\n//   suffers from the \"last field is a bitfield\" bug in 2010 and results in\n//   _every_ field getting padding put in front of it, potentially including the\n//   vfptr, leaving the vfprt at a non-zero location which results in a fault if\n//   anything tries to read the vftbl.  The second layout phase also treats\n//   bitfields as separate entities and gives them each storage rather than\n//   packing them.  Additionally, because this phase appears to perform a\n//   (an unstable) sort on the members before laying them out and because merged\n//   bitfields have the same address, the bitfields end up in whatever order\n//   the sort left them in, a behavior we could never hope to replicate.\n\nnamespace {\nstruct MicrosoftRecordLayoutBuilder {\n  struct ElementInfo {\n    CharUnits Size;\n    CharUnits Alignment;\n  };\n  typedef llvm::DenseMap<const CXXRecordDecl *, CharUnits> BaseOffsetsMapTy;\n  MicrosoftRecordLayoutBuilder(const ASTContext &Context) : Context(Context) {}\nprivate:\n  MicrosoftRecordLayoutBuilder(const MicrosoftRecordLayoutBuilder &) = delete;\n  void operator=(const MicrosoftRecordLayoutBuilder &) = delete;\npublic:\n  void layout(const RecordDecl *RD);\n  void cxxLayout(const CXXRecordDecl *RD);\n  /// Initializes size and alignment and honors some flags.\n  void initializeLayout(const RecordDecl *RD);\n  /// Initialized C++ layout, compute alignment and virtual alignment and\n  /// existence of vfptrs and vbptrs.  Alignment is needed before the vfptr is\n  /// laid out.\n  void initializeCXXLayout(const CXXRecordDecl *RD);\n  void layoutNonVirtualBases(const CXXRecordDecl *RD);\n  void layoutNonVirtualBase(const CXXRecordDecl *RD,\n                            const CXXRecordDecl *BaseDecl,\n                            const ASTRecordLayout &BaseLayout,\n                            const ASTRecordLayout *&PreviousBaseLayout);\n  void injectVFPtr(const CXXRecordDecl *RD);\n  void injectVBPtr(const CXXRecordDecl *RD);\n  /// Lays out the fields of the record.  Also rounds size up to\n  /// alignment.\n  void layoutFields(const RecordDecl *RD);\n  void layoutField(const FieldDecl *FD);\n  void layoutBitField(const FieldDecl *FD);\n  /// Lays out a single zero-width bit-field in the record and handles\n  /// special cases associated with zero-width bit-fields.\n  void layoutZeroWidthBitField(const FieldDecl *FD);\n  void layoutVirtualBases(const CXXRecordDecl *RD);\n  void finalizeLayout(const RecordDecl *RD);\n  /// Gets the size and alignment of a base taking pragma pack and\n  /// __declspec(align) into account.\n  ElementInfo getAdjustedElementInfo(const ASTRecordLayout &Layout);\n  /// Gets the size and alignment of a field taking pragma  pack and\n  /// __declspec(align) into account.  It also updates RequiredAlignment as a\n  /// side effect because it is most convenient to do so here.\n  ElementInfo getAdjustedElementInfo(const FieldDecl *FD);\n  /// Places a field at an offset in CharUnits.\n  void placeFieldAtOffset(CharUnits FieldOffset) {\n    FieldOffsets.push_back(Context.toBits(FieldOffset));\n  }\n  /// Places a bitfield at a bit offset.\n  void placeFieldAtBitOffset(uint64_t FieldOffset) {\n    FieldOffsets.push_back(FieldOffset);\n  }\n  /// Compute the set of virtual bases for which vtordisps are required.\n  void computeVtorDispSet(\n      llvm::SmallPtrSetImpl<const CXXRecordDecl *> &HasVtorDispSet,\n      const CXXRecordDecl *RD) const;\n  const ASTContext &Context;\n  /// The size of the record being laid out.\n  CharUnits Size;\n  /// The non-virtual size of the record layout.\n  CharUnits NonVirtualSize;\n  /// The data size of the record layout.\n  CharUnits DataSize;\n  /// The current alignment of the record layout.\n  CharUnits Alignment;\n  /// The maximum allowed field alignment. This is set by #pragma pack.\n  CharUnits MaxFieldAlignment;\n  /// The alignment that this record must obey.  This is imposed by\n  /// __declspec(align()) on the record itself or one of its fields or bases.\n  CharUnits RequiredAlignment;\n  /// The size of the allocation of the currently active bitfield.\n  /// This value isn't meaningful unless LastFieldIsNonZeroWidthBitfield\n  /// is true.\n  CharUnits CurrentBitfieldSize;\n  /// Offset to the virtual base table pointer (if one exists).\n  CharUnits VBPtrOffset;\n  /// Minimum record size possible.\n  CharUnits MinEmptyStructSize;\n  /// The size and alignment info of a pointer.\n  ElementInfo PointerInfo;\n  /// The primary base class (if one exists).\n  const CXXRecordDecl *PrimaryBase;\n  /// The class we share our vb-pointer with.\n  const CXXRecordDecl *SharedVBPtrBase;\n  /// The collection of field offsets.\n  SmallVector<uint64_t, 16> FieldOffsets;\n  /// Base classes and their offsets in the record.\n  BaseOffsetsMapTy Bases;\n  /// virtual base classes and their offsets in the record.\n  ASTRecordLayout::VBaseOffsetsMapTy VBases;\n  /// The number of remaining bits in our last bitfield allocation.\n  /// This value isn't meaningful unless LastFieldIsNonZeroWidthBitfield is\n  /// true.\n  unsigned RemainingBitsInField;\n  bool IsUnion : 1;\n  /// True if the last field laid out was a bitfield and was not 0\n  /// width.\n  bool LastFieldIsNonZeroWidthBitfield : 1;\n  /// True if the class has its own vftable pointer.\n  bool HasOwnVFPtr : 1;\n  /// True if the class has a vbtable pointer.\n  bool HasVBPtr : 1;\n  /// True if the last sub-object within the type is zero sized or the\n  /// object itself is zero sized.  This *does not* count members that are not\n  /// records.  Only used for MS-ABI.\n  bool EndsWithZeroSizedObject : 1;\n  /// True if this class is zero sized or first base is zero sized or\n  /// has this property.  Only used for MS-ABI.\n  bool LeadsWithZeroSizedBase : 1;\n\n  /// True if the external AST source provided a layout for this record.\n  bool UseExternalLayout : 1;\n\n  /// The layout provided by the external AST source. Only active if\n  /// UseExternalLayout is true.\n  ExternalLayout External;\n};\n} // namespace\n\nMicrosoftRecordLayoutBuilder::ElementInfo\nMicrosoftRecordLayoutBuilder::getAdjustedElementInfo(\n    const ASTRecordLayout &Layout) {\n  ElementInfo Info;\n  Info.Alignment = Layout.getAlignment();\n  // Respect pragma pack.\n  if (!MaxFieldAlignment.isZero())\n    Info.Alignment = std::min(Info.Alignment, MaxFieldAlignment);\n  // Track zero-sized subobjects here where it's already available.\n  EndsWithZeroSizedObject = Layout.endsWithZeroSizedObject();\n  // Respect required alignment, this is necessary because we may have adjusted\n  // the alignment in the case of pragam pack.  Note that the required alignment\n  // doesn't actually apply to the struct alignment at this point.\n  Alignment = std::max(Alignment, Info.Alignment);\n  RequiredAlignment = std::max(RequiredAlignment, Layout.getRequiredAlignment());\n  Info.Alignment = std::max(Info.Alignment, Layout.getRequiredAlignment());\n  Info.Size = Layout.getNonVirtualSize();\n  return Info;\n}\n\nMicrosoftRecordLayoutBuilder::ElementInfo\nMicrosoftRecordLayoutBuilder::getAdjustedElementInfo(\n    const FieldDecl *FD) {\n  // Get the alignment of the field type's natural alignment, ignore any\n  // alignment attributes.\n  auto TInfo =\n      Context.getTypeInfoInChars(FD->getType()->getUnqualifiedDesugaredType());\n  ElementInfo Info{TInfo.Width, TInfo.Align};\n  // Respect align attributes on the field.\n  CharUnits FieldRequiredAlignment =\n      Context.toCharUnitsFromBits(FD->getMaxAlignment());\n  // Respect align attributes on the type.\n  if (Context.isAlignmentRequired(FD->getType()))\n    FieldRequiredAlignment = std::max(\n        Context.getTypeAlignInChars(FD->getType()), FieldRequiredAlignment);\n  // Respect attributes applied to subobjects of the field.\n  if (FD->isBitField())\n    // For some reason __declspec align impacts alignment rather than required\n    // alignment when it is applied to bitfields.\n    Info.Alignment = std::max(Info.Alignment, FieldRequiredAlignment);\n  else {\n    if (auto RT =\n            FD->getType()->getBaseElementTypeUnsafe()->getAs<RecordType>()) {\n      auto const &Layout = Context.getASTRecordLayout(RT->getDecl());\n      EndsWithZeroSizedObject = Layout.endsWithZeroSizedObject();\n      FieldRequiredAlignment = std::max(FieldRequiredAlignment,\n                                        Layout.getRequiredAlignment());\n    }\n    // Capture required alignment as a side-effect.\n    RequiredAlignment = std::max(RequiredAlignment, FieldRequiredAlignment);\n  }\n  // Respect pragma pack, attribute pack and declspec align\n  if (!MaxFieldAlignment.isZero())\n    Info.Alignment = std::min(Info.Alignment, MaxFieldAlignment);\n  if (FD->hasAttr<PackedAttr>())\n    Info.Alignment = CharUnits::One();\n  Info.Alignment = std::max(Info.Alignment, FieldRequiredAlignment);\n  return Info;\n}\n\nvoid MicrosoftRecordLayoutBuilder::layout(const RecordDecl *RD) {\n  // For C record layout, zero-sized records always have size 4.\n  MinEmptyStructSize = CharUnits::fromQuantity(4);\n  initializeLayout(RD);\n  layoutFields(RD);\n  DataSize = Size = Size.alignTo(Alignment);\n  RequiredAlignment = std::max(\n      RequiredAlignment, Context.toCharUnitsFromBits(RD->getMaxAlignment()));\n  finalizeLayout(RD);\n}\n\nvoid MicrosoftRecordLayoutBuilder::cxxLayout(const CXXRecordDecl *RD) {\n  // The C++ standard says that empty structs have size 1.\n  MinEmptyStructSize = CharUnits::One();\n  initializeLayout(RD);\n  initializeCXXLayout(RD);\n  layoutNonVirtualBases(RD);\n  layoutFields(RD);\n  injectVBPtr(RD);\n  injectVFPtr(RD);\n  if (HasOwnVFPtr || (HasVBPtr && !SharedVBPtrBase))\n    Alignment = std::max(Alignment, PointerInfo.Alignment);\n  auto RoundingAlignment = Alignment;\n  if (!MaxFieldAlignment.isZero())\n    RoundingAlignment = std::min(RoundingAlignment, MaxFieldAlignment);\n  if (!UseExternalLayout)\n    Size = Size.alignTo(RoundingAlignment);\n  NonVirtualSize = Size;\n  RequiredAlignment = std::max(\n      RequiredAlignment, Context.toCharUnitsFromBits(RD->getMaxAlignment()));\n  layoutVirtualBases(RD);\n  finalizeLayout(RD);\n}\n\nvoid MicrosoftRecordLayoutBuilder::initializeLayout(const RecordDecl *RD) {\n  IsUnion = RD->isUnion();\n  Size = CharUnits::Zero();\n  Alignment = CharUnits::One();\n  // In 64-bit mode we always perform an alignment step after laying out vbases.\n  // In 32-bit mode we do not.  The check to see if we need to perform alignment\n  // checks the RequiredAlignment field and performs alignment if it isn't 0.\n  RequiredAlignment = Context.getTargetInfo().getTriple().isArch64Bit()\n                          ? CharUnits::One()\n                          : CharUnits::Zero();\n  // Compute the maximum field alignment.\n  MaxFieldAlignment = CharUnits::Zero();\n  // Honor the default struct packing maximum alignment flag.\n  if (unsigned DefaultMaxFieldAlignment = Context.getLangOpts().PackStruct)\n      MaxFieldAlignment = CharUnits::fromQuantity(DefaultMaxFieldAlignment);\n  // Honor the packing attribute.  The MS-ABI ignores pragma pack if its larger\n  // than the pointer size.\n  if (const MaxFieldAlignmentAttr *MFAA = RD->getAttr<MaxFieldAlignmentAttr>()){\n    unsigned PackedAlignment = MFAA->getAlignment();\n    if (PackedAlignment <= Context.getTargetInfo().getPointerWidth(0))\n      MaxFieldAlignment = Context.toCharUnitsFromBits(PackedAlignment);\n  }\n  // Packed attribute forces max field alignment to be 1.\n  if (RD->hasAttr<PackedAttr>())\n    MaxFieldAlignment = CharUnits::One();\n\n  // Try to respect the external layout if present.\n  UseExternalLayout = false;\n  if (ExternalASTSource *Source = Context.getExternalSource())\n    UseExternalLayout = Source->layoutRecordType(\n        RD, External.Size, External.Align, External.FieldOffsets,\n        External.BaseOffsets, External.VirtualBaseOffsets);\n}\n\nvoid\nMicrosoftRecordLayoutBuilder::initializeCXXLayout(const CXXRecordDecl *RD) {\n  EndsWithZeroSizedObject = false;\n  LeadsWithZeroSizedBase = false;\n  HasOwnVFPtr = false;\n  HasVBPtr = false;\n  PrimaryBase = nullptr;\n  SharedVBPtrBase = nullptr;\n  // Calculate pointer size and alignment.  These are used for vfptr and vbprt\n  // injection.\n  PointerInfo.Size =\n      Context.toCharUnitsFromBits(Context.getTargetInfo().getPointerWidth(0));\n  PointerInfo.Alignment =\n      Context.toCharUnitsFromBits(Context.getTargetInfo().getPointerAlign(0));\n  // Respect pragma pack.\n  if (!MaxFieldAlignment.isZero())\n    PointerInfo.Alignment = std::min(PointerInfo.Alignment, MaxFieldAlignment);\n}\n\nvoid\nMicrosoftRecordLayoutBuilder::layoutNonVirtualBases(const CXXRecordDecl *RD) {\n  // The MS-ABI lays out all bases that contain leading vfptrs before it lays\n  // out any bases that do not contain vfptrs.  We implement this as two passes\n  // over the bases.  This approach guarantees that the primary base is laid out\n  // first.  We use these passes to calculate some additional aggregated\n  // information about the bases, such as required alignment and the presence of\n  // zero sized members.\n  const ASTRecordLayout *PreviousBaseLayout = nullptr;\n  bool HasPolymorphicBaseClass = false;\n  // Iterate through the bases and lay out the non-virtual ones.\n  for (const CXXBaseSpecifier &Base : RD->bases()) {\n    const CXXRecordDecl *BaseDecl = Base.getType()->getAsCXXRecordDecl();\n    HasPolymorphicBaseClass |= BaseDecl->isPolymorphic();\n    const ASTRecordLayout &BaseLayout = Context.getASTRecordLayout(BaseDecl);\n    // Mark and skip virtual bases.\n    if (Base.isVirtual()) {\n      HasVBPtr = true;\n      continue;\n    }\n    // Check for a base to share a VBPtr with.\n    if (!SharedVBPtrBase && BaseLayout.hasVBPtr()) {\n      SharedVBPtrBase = BaseDecl;\n      HasVBPtr = true;\n    }\n    // Only lay out bases with extendable VFPtrs on the first pass.\n    if (!BaseLayout.hasExtendableVFPtr())\n      continue;\n    // If we don't have a primary base, this one qualifies.\n    if (!PrimaryBase) {\n      PrimaryBase = BaseDecl;\n      LeadsWithZeroSizedBase = BaseLayout.leadsWithZeroSizedBase();\n    }\n    // Lay out the base.\n    layoutNonVirtualBase(RD, BaseDecl, BaseLayout, PreviousBaseLayout);\n  }\n  // Figure out if we need a fresh VFPtr for this class.\n  if (RD->isPolymorphic()) {\n    if (!HasPolymorphicBaseClass)\n      // This class introduces polymorphism, so we need a vftable to store the\n      // RTTI information.\n      HasOwnVFPtr = true;\n    else if (!PrimaryBase) {\n      // We have a polymorphic base class but can't extend its vftable. Add a\n      // new vfptr if we would use any vftable slots.\n      for (CXXMethodDecl *M : RD->methods()) {\n        if (MicrosoftVTableContext::hasVtableSlot(M) &&\n            M->size_overridden_methods() == 0) {\n          HasOwnVFPtr = true;\n          break;\n        }\n      }\n    }\n  }\n  // If we don't have a primary base then we have a leading object that could\n  // itself lead with a zero-sized object, something we track.\n  bool CheckLeadingLayout = !PrimaryBase;\n  // Iterate through the bases and lay out the non-virtual ones.\n  for (const CXXBaseSpecifier &Base : RD->bases()) {\n    if (Base.isVirtual())\n      continue;\n    const CXXRecordDecl *BaseDecl = Base.getType()->getAsCXXRecordDecl();\n    const ASTRecordLayout &BaseLayout = Context.getASTRecordLayout(BaseDecl);\n    // Only lay out bases without extendable VFPtrs on the second pass.\n    if (BaseLayout.hasExtendableVFPtr()) {\n      VBPtrOffset = Bases[BaseDecl] + BaseLayout.getNonVirtualSize();\n      continue;\n    }\n    // If this is the first layout, check to see if it leads with a zero sized\n    // object.  If it does, so do we.\n    if (CheckLeadingLayout) {\n      CheckLeadingLayout = false;\n      LeadsWithZeroSizedBase = BaseLayout.leadsWithZeroSizedBase();\n    }\n    // Lay out the base.\n    layoutNonVirtualBase(RD, BaseDecl, BaseLayout, PreviousBaseLayout);\n    VBPtrOffset = Bases[BaseDecl] + BaseLayout.getNonVirtualSize();\n  }\n  // Set our VBPtroffset if we know it at this point.\n  if (!HasVBPtr)\n    VBPtrOffset = CharUnits::fromQuantity(-1);\n  else if (SharedVBPtrBase) {\n    const ASTRecordLayout &Layout = Context.getASTRecordLayout(SharedVBPtrBase);\n    VBPtrOffset = Bases[SharedVBPtrBase] + Layout.getVBPtrOffset();\n  }\n}\n\nstatic bool recordUsesEBO(const RecordDecl *RD) {\n  if (!isa<CXXRecordDecl>(RD))\n    return false;\n  if (RD->hasAttr<EmptyBasesAttr>())\n    return true;\n  if (auto *LVA = RD->getAttr<LayoutVersionAttr>())\n    // TODO: Double check with the next version of MSVC.\n    if (LVA->getVersion() <= LangOptions::MSVC2015)\n      return false;\n  // TODO: Some later version of MSVC will change the default behavior of the\n  // compiler to enable EBO by default.  When this happens, we will need an\n  // additional isCompatibleWithMSVC check.\n  return false;\n}\n\nvoid MicrosoftRecordLayoutBuilder::layoutNonVirtualBase(\n    const CXXRecordDecl *RD,\n    const CXXRecordDecl *BaseDecl,\n    const ASTRecordLayout &BaseLayout,\n    const ASTRecordLayout *&PreviousBaseLayout) {\n  // Insert padding between two bases if the left first one is zero sized or\n  // contains a zero sized subobject and the right is zero sized or one leads\n  // with a zero sized base.\n  bool MDCUsesEBO = recordUsesEBO(RD);\n  if (PreviousBaseLayout && PreviousBaseLayout->endsWithZeroSizedObject() &&\n      BaseLayout.leadsWithZeroSizedBase() && !MDCUsesEBO)\n    Size++;\n  ElementInfo Info = getAdjustedElementInfo(BaseLayout);\n  CharUnits BaseOffset;\n\n  // Respect the external AST source base offset, if present.\n  bool FoundBase = false;\n  if (UseExternalLayout) {\n    FoundBase = External.getExternalNVBaseOffset(BaseDecl, BaseOffset);\n    if (FoundBase) {\n      assert(BaseOffset >= Size && \"base offset already allocated\");\n      Size = BaseOffset;\n    }\n  }\n\n  if (!FoundBase) {\n    if (MDCUsesEBO && BaseDecl->isEmpty()) {\n      assert(BaseLayout.getNonVirtualSize() == CharUnits::Zero());\n      BaseOffset = CharUnits::Zero();\n    } else {\n      // Otherwise, lay the base out at the end of the MDC.\n      BaseOffset = Size = Size.alignTo(Info.Alignment);\n    }\n  }\n  Bases.insert(std::make_pair(BaseDecl, BaseOffset));\n  Size += BaseLayout.getNonVirtualSize();\n  PreviousBaseLayout = &BaseLayout;\n}\n\nvoid MicrosoftRecordLayoutBuilder::layoutFields(const RecordDecl *RD) {\n  LastFieldIsNonZeroWidthBitfield = false;\n  for (const FieldDecl *Field : RD->fields())\n    layoutField(Field);\n}\n\nvoid MicrosoftRecordLayoutBuilder::layoutField(const FieldDecl *FD) {\n  if (FD->isBitField()) {\n    layoutBitField(FD);\n    return;\n  }\n  LastFieldIsNonZeroWidthBitfield = false;\n  ElementInfo Info = getAdjustedElementInfo(FD);\n  Alignment = std::max(Alignment, Info.Alignment);\n  CharUnits FieldOffset;\n  if (UseExternalLayout)\n    FieldOffset =\n        Context.toCharUnitsFromBits(External.getExternalFieldOffset(FD));\n  else if (IsUnion)\n    FieldOffset = CharUnits::Zero();\n  else\n    FieldOffset = Size.alignTo(Info.Alignment);\n  placeFieldAtOffset(FieldOffset);\n  Size = std::max(Size, FieldOffset + Info.Size);\n}\n\nvoid MicrosoftRecordLayoutBuilder::layoutBitField(const FieldDecl *FD) {\n  unsigned Width = FD->getBitWidthValue(Context);\n  if (Width == 0) {\n    layoutZeroWidthBitField(FD);\n    return;\n  }\n  ElementInfo Info = getAdjustedElementInfo(FD);\n  // Clamp the bitfield to a containable size for the sake of being able\n  // to lay them out.  Sema will throw an error.\n  if (Width > Context.toBits(Info.Size))\n    Width = Context.toBits(Info.Size);\n  // Check to see if this bitfield fits into an existing allocation.  Note:\n  // MSVC refuses to pack bitfields of formal types with different sizes\n  // into the same allocation.\n  if (!UseExternalLayout && !IsUnion && LastFieldIsNonZeroWidthBitfield &&\n      CurrentBitfieldSize == Info.Size && Width <= RemainingBitsInField) {\n    placeFieldAtBitOffset(Context.toBits(Size) - RemainingBitsInField);\n    RemainingBitsInField -= Width;\n    return;\n  }\n  LastFieldIsNonZeroWidthBitfield = true;\n  CurrentBitfieldSize = Info.Size;\n  if (UseExternalLayout) {\n    auto FieldBitOffset = External.getExternalFieldOffset(FD);\n    placeFieldAtBitOffset(FieldBitOffset);\n    auto NewSize = Context.toCharUnitsFromBits(\n        llvm::alignDown(FieldBitOffset, Context.toBits(Info.Alignment)) +\n        Context.toBits(Info.Size));\n    Size = std::max(Size, NewSize);\n    Alignment = std::max(Alignment, Info.Alignment);\n  } else if (IsUnion) {\n    placeFieldAtOffset(CharUnits::Zero());\n    Size = std::max(Size, Info.Size);\n    // TODO: Add a Sema warning that MS ignores bitfield alignment in unions.\n  } else {\n    // Allocate a new block of memory and place the bitfield in it.\n    CharUnits FieldOffset = Size.alignTo(Info.Alignment);\n    placeFieldAtOffset(FieldOffset);\n    Size = FieldOffset + Info.Size;\n    Alignment = std::max(Alignment, Info.Alignment);\n    RemainingBitsInField = Context.toBits(Info.Size) - Width;\n  }\n}\n\nvoid\nMicrosoftRecordLayoutBuilder::layoutZeroWidthBitField(const FieldDecl *FD) {\n  // Zero-width bitfields are ignored unless they follow a non-zero-width\n  // bitfield.\n  if (!LastFieldIsNonZeroWidthBitfield) {\n    placeFieldAtOffset(IsUnion ? CharUnits::Zero() : Size);\n    // TODO: Add a Sema warning that MS ignores alignment for zero\n    // sized bitfields that occur after zero-size bitfields or non-bitfields.\n    return;\n  }\n  LastFieldIsNonZeroWidthBitfield = false;\n  ElementInfo Info = getAdjustedElementInfo(FD);\n  if (IsUnion) {\n    placeFieldAtOffset(CharUnits::Zero());\n    Size = std::max(Size, Info.Size);\n    // TODO: Add a Sema warning that MS ignores bitfield alignment in unions.\n  } else {\n    // Round up the current record size to the field's alignment boundary.\n    CharUnits FieldOffset = Size.alignTo(Info.Alignment);\n    placeFieldAtOffset(FieldOffset);\n    Size = FieldOffset;\n    Alignment = std::max(Alignment, Info.Alignment);\n  }\n}\n\nvoid MicrosoftRecordLayoutBuilder::injectVBPtr(const CXXRecordDecl *RD) {\n  if (!HasVBPtr || SharedVBPtrBase)\n    return;\n  // Inject the VBPointer at the injection site.\n  CharUnits InjectionSite = VBPtrOffset;\n  // But before we do, make sure it's properly aligned.\n  VBPtrOffset = VBPtrOffset.alignTo(PointerInfo.Alignment);\n  // Determine where the first field should be laid out after the vbptr.\n  CharUnits FieldStart = VBPtrOffset + PointerInfo.Size;\n  // Shift everything after the vbptr down, unless we're using an external\n  // layout.\n  if (UseExternalLayout) {\n    // It is possible that there were no fields or bases located after vbptr,\n    // so the size was not adjusted before.\n    if (Size < FieldStart)\n      Size = FieldStart;\n    return;\n  }\n  // Make sure that the amount we push the fields back by is a multiple of the\n  // alignment.\n  CharUnits Offset = (FieldStart - InjectionSite)\n                         .alignTo(std::max(RequiredAlignment, Alignment));\n  Size += Offset;\n  for (uint64_t &FieldOffset : FieldOffsets)\n    FieldOffset += Context.toBits(Offset);\n  for (BaseOffsetsMapTy::value_type &Base : Bases)\n    if (Base.second >= InjectionSite)\n      Base.second += Offset;\n}\n\nvoid MicrosoftRecordLayoutBuilder::injectVFPtr(const CXXRecordDecl *RD) {\n  if (!HasOwnVFPtr)\n    return;\n  // Make sure that the amount we push the struct back by is a multiple of the\n  // alignment.\n  CharUnits Offset =\n      PointerInfo.Size.alignTo(std::max(RequiredAlignment, Alignment));\n  // Push back the vbptr, but increase the size of the object and push back\n  // regular fields by the offset only if not using external record layout.\n  if (HasVBPtr)\n    VBPtrOffset += Offset;\n\n  if (UseExternalLayout) {\n    // The class may have no bases or fields, but still have a vfptr\n    // (e.g. it's an interface class). The size was not correctly set before\n    // in this case.\n    if (FieldOffsets.empty() && Bases.empty())\n      Size += Offset;\n    return;\n  }\n\n  Size += Offset;\n\n  // If we're using an external layout, the fields offsets have already\n  // accounted for this adjustment.\n  for (uint64_t &FieldOffset : FieldOffsets)\n    FieldOffset += Context.toBits(Offset);\n  for (BaseOffsetsMapTy::value_type &Base : Bases)\n    Base.second += Offset;\n}\n\nvoid MicrosoftRecordLayoutBuilder::layoutVirtualBases(const CXXRecordDecl *RD) {\n  if (!HasVBPtr)\n    return;\n  // Vtordisps are always 4 bytes (even in 64-bit mode)\n  CharUnits VtorDispSize = CharUnits::fromQuantity(4);\n  CharUnits VtorDispAlignment = VtorDispSize;\n  // vtordisps respect pragma pack.\n  if (!MaxFieldAlignment.isZero())\n    VtorDispAlignment = std::min(VtorDispAlignment, MaxFieldAlignment);\n  // The alignment of the vtordisp is at least the required alignment of the\n  // entire record.  This requirement may be present to support vtordisp\n  // injection.\n  for (const CXXBaseSpecifier &VBase : RD->vbases()) {\n    const CXXRecordDecl *BaseDecl = VBase.getType()->getAsCXXRecordDecl();\n    const ASTRecordLayout &BaseLayout = Context.getASTRecordLayout(BaseDecl);\n    RequiredAlignment =\n        std::max(RequiredAlignment, BaseLayout.getRequiredAlignment());\n  }\n  VtorDispAlignment = std::max(VtorDispAlignment, RequiredAlignment);\n  // Compute the vtordisp set.\n  llvm::SmallPtrSet<const CXXRecordDecl *, 2> HasVtorDispSet;\n  computeVtorDispSet(HasVtorDispSet, RD);\n  // Iterate through the virtual bases and lay them out.\n  const ASTRecordLayout *PreviousBaseLayout = nullptr;\n  for (const CXXBaseSpecifier &VBase : RD->vbases()) {\n    const CXXRecordDecl *BaseDecl = VBase.getType()->getAsCXXRecordDecl();\n    const ASTRecordLayout &BaseLayout = Context.getASTRecordLayout(BaseDecl);\n    bool HasVtordisp = HasVtorDispSet.count(BaseDecl) > 0;\n    // Insert padding between two bases if the left first one is zero sized or\n    // contains a zero sized subobject and the right is zero sized or one leads\n    // with a zero sized base.  The padding between virtual bases is 4\n    // bytes (in both 32 and 64 bits modes) and always involves rounding up to\n    // the required alignment, we don't know why.\n    if ((PreviousBaseLayout && PreviousBaseLayout->endsWithZeroSizedObject() &&\n         BaseLayout.leadsWithZeroSizedBase() && !recordUsesEBO(RD)) ||\n        HasVtordisp) {\n      Size = Size.alignTo(VtorDispAlignment) + VtorDispSize;\n      Alignment = std::max(VtorDispAlignment, Alignment);\n    }\n    // Insert the virtual base.\n    ElementInfo Info = getAdjustedElementInfo(BaseLayout);\n    CharUnits BaseOffset;\n\n    // Respect the external AST source base offset, if present.\n    if (UseExternalLayout) {\n      if (!External.getExternalVBaseOffset(BaseDecl, BaseOffset))\n        BaseOffset = Size;\n    } else\n      BaseOffset = Size.alignTo(Info.Alignment);\n\n    assert(BaseOffset >= Size && \"base offset already allocated\");\n\n    VBases.insert(std::make_pair(BaseDecl,\n        ASTRecordLayout::VBaseInfo(BaseOffset, HasVtordisp)));\n    Size = BaseOffset + BaseLayout.getNonVirtualSize();\n    PreviousBaseLayout = &BaseLayout;\n  }\n}\n\nvoid MicrosoftRecordLayoutBuilder::finalizeLayout(const RecordDecl *RD) {\n  // Respect required alignment.  Note that in 32-bit mode Required alignment\n  // may be 0 and cause size not to be updated.\n  DataSize = Size;\n  if (!RequiredAlignment.isZero()) {\n    Alignment = std::max(Alignment, RequiredAlignment);\n    auto RoundingAlignment = Alignment;\n    if (!MaxFieldAlignment.isZero())\n      RoundingAlignment = std::min(RoundingAlignment, MaxFieldAlignment);\n    RoundingAlignment = std::max(RoundingAlignment, RequiredAlignment);\n    Size = Size.alignTo(RoundingAlignment);\n  }\n  if (Size.isZero()) {\n    if (!recordUsesEBO(RD) || !cast<CXXRecordDecl>(RD)->isEmpty()) {\n      EndsWithZeroSizedObject = true;\n      LeadsWithZeroSizedBase = true;\n    }\n    // Zero-sized structures have size equal to their alignment if a\n    // __declspec(align) came into play.\n    if (RequiredAlignment >= MinEmptyStructSize)\n      Size = Alignment;\n    else\n      Size = MinEmptyStructSize;\n  }\n\n  if (UseExternalLayout) {\n    Size = Context.toCharUnitsFromBits(External.Size);\n    if (External.Align)\n      Alignment = Context.toCharUnitsFromBits(External.Align);\n  }\n}\n\n// Recursively walks the non-virtual bases of a class and determines if any of\n// them are in the bases with overridden methods set.\nstatic bool\nRequiresVtordisp(const llvm::SmallPtrSetImpl<const CXXRecordDecl *> &\n                     BasesWithOverriddenMethods,\n                 const CXXRecordDecl *RD) {\n  if (BasesWithOverriddenMethods.count(RD))\n    return true;\n  // If any of a virtual bases non-virtual bases (recursively) requires a\n  // vtordisp than so does this virtual base.\n  for (const CXXBaseSpecifier &Base : RD->bases())\n    if (!Base.isVirtual() &&\n        RequiresVtordisp(BasesWithOverriddenMethods,\n                         Base.getType()->getAsCXXRecordDecl()))\n      return true;\n  return false;\n}\n\nvoid MicrosoftRecordLayoutBuilder::computeVtorDispSet(\n    llvm::SmallPtrSetImpl<const CXXRecordDecl *> &HasVtordispSet,\n    const CXXRecordDecl *RD) const {\n  // /vd2 or #pragma vtordisp(2): Always use vtordisps for virtual bases with\n  // vftables.\n  if (RD->getMSVtorDispMode() == MSVtorDispMode::ForVFTable) {\n    for (const CXXBaseSpecifier &Base : RD->vbases()) {\n      const CXXRecordDecl *BaseDecl = Base.getType()->getAsCXXRecordDecl();\n      const ASTRecordLayout &Layout = Context.getASTRecordLayout(BaseDecl);\n      if (Layout.hasExtendableVFPtr())\n        HasVtordispSet.insert(BaseDecl);\n    }\n    return;\n  }\n\n  // If any of our bases need a vtordisp for this type, so do we.  Check our\n  // direct bases for vtordisp requirements.\n  for (const CXXBaseSpecifier &Base : RD->bases()) {\n    const CXXRecordDecl *BaseDecl = Base.getType()->getAsCXXRecordDecl();\n    const ASTRecordLayout &Layout = Context.getASTRecordLayout(BaseDecl);\n    for (const auto &bi : Layout.getVBaseOffsetsMap())\n      if (bi.second.hasVtorDisp())\n        HasVtordispSet.insert(bi.first);\n  }\n  // We don't introduce any additional vtordisps if either:\n  // * A user declared constructor or destructor aren't declared.\n  // * #pragma vtordisp(0) or the /vd0 flag are in use.\n  if ((!RD->hasUserDeclaredConstructor() && !RD->hasUserDeclaredDestructor()) ||\n      RD->getMSVtorDispMode() == MSVtorDispMode::Never)\n    return;\n  // /vd1 or #pragma vtordisp(1): Try to guess based on whether we think it's\n  // possible for a partially constructed object with virtual base overrides to\n  // escape a non-trivial constructor.\n  assert(RD->getMSVtorDispMode() == MSVtorDispMode::ForVBaseOverride);\n  // Compute a set of base classes which define methods we override.  A virtual\n  // base in this set will require a vtordisp.  A virtual base that transitively\n  // contains one of these bases as a non-virtual base will also require a\n  // vtordisp.\n  llvm::SmallPtrSet<const CXXMethodDecl *, 8> Work;\n  llvm::SmallPtrSet<const CXXRecordDecl *, 2> BasesWithOverriddenMethods;\n  // Seed the working set with our non-destructor, non-pure virtual methods.\n  for (const CXXMethodDecl *MD : RD->methods())\n    if (MicrosoftVTableContext::hasVtableSlot(MD) &&\n        !isa<CXXDestructorDecl>(MD) && !MD->isPure())\n      Work.insert(MD);\n  while (!Work.empty()) {\n    const CXXMethodDecl *MD = *Work.begin();\n    auto MethodRange = MD->overridden_methods();\n    // If a virtual method has no-overrides it lives in its parent's vtable.\n    if (MethodRange.begin() == MethodRange.end())\n      BasesWithOverriddenMethods.insert(MD->getParent());\n    else\n      Work.insert(MethodRange.begin(), MethodRange.end());\n    // We've finished processing this element, remove it from the working set.\n    Work.erase(MD);\n  }\n  // For each of our virtual bases, check if it is in the set of overridden\n  // bases or if it transitively contains a non-virtual base that is.\n  for (const CXXBaseSpecifier &Base : RD->vbases()) {\n    const CXXRecordDecl *BaseDecl = Base.getType()->getAsCXXRecordDecl();\n    if (!HasVtordispSet.count(BaseDecl) &&\n        RequiresVtordisp(BasesWithOverriddenMethods, BaseDecl))\n      HasVtordispSet.insert(BaseDecl);\n  }\n}\n\n/// getASTRecordLayout - Get or compute information about the layout of the\n/// specified record (struct/union/class), which indicates its size and field\n/// position information.\nconst ASTRecordLayout &\nASTContext::getASTRecordLayout(const RecordDecl *D) const {\n  // These asserts test different things.  A record has a definition\n  // as soon as we begin to parse the definition.  That definition is\n  // not a complete definition (which is what isDefinition() tests)\n  // until we *finish* parsing the definition.\n\n  if (D->hasExternalLexicalStorage() && !D->getDefinition())\n    getExternalSource()->CompleteType(const_cast<RecordDecl*>(D));\n\n  D = D->getDefinition();\n  assert(D && \"Cannot get layout of forward declarations!\");\n  assert(!D->isInvalidDecl() && \"Cannot get layout of invalid decl!\");\n  assert(D->isCompleteDefinition() && \"Cannot layout type before complete!\");\n\n  // Look up this layout, if already laid out, return what we have.\n  // Note that we can't save a reference to the entry because this function\n  // is recursive.\n  const ASTRecordLayout *Entry = ASTRecordLayouts[D];\n  if (Entry) return *Entry;\n\n  const ASTRecordLayout *NewEntry = nullptr;\n\n  if (isMsLayout(*this)) {\n    MicrosoftRecordLayoutBuilder Builder(*this);\n    if (const auto *RD = dyn_cast<CXXRecordDecl>(D)) {\n      Builder.cxxLayout(RD);\n      NewEntry = new (*this) ASTRecordLayout(\n          *this, Builder.Size, Builder.Alignment, Builder.Alignment,\n          Builder.Alignment, Builder.RequiredAlignment, Builder.HasOwnVFPtr,\n          Builder.HasOwnVFPtr || Builder.PrimaryBase, Builder.VBPtrOffset,\n          Builder.DataSize, Builder.FieldOffsets, Builder.NonVirtualSize,\n          Builder.Alignment, Builder.Alignment, CharUnits::Zero(),\n          Builder.PrimaryBase, false, Builder.SharedVBPtrBase,\n          Builder.EndsWithZeroSizedObject, Builder.LeadsWithZeroSizedBase,\n          Builder.Bases, Builder.VBases);\n    } else {\n      Builder.layout(D);\n      NewEntry = new (*this) ASTRecordLayout(\n          *this, Builder.Size, Builder.Alignment, Builder.Alignment,\n          Builder.Alignment, Builder.RequiredAlignment, Builder.Size,\n          Builder.FieldOffsets);\n    }\n  } else {\n    if (const auto *RD = dyn_cast<CXXRecordDecl>(D)) {\n      EmptySubobjectMap EmptySubobjects(*this, RD);\n      ItaniumRecordLayoutBuilder Builder(*this, &EmptySubobjects);\n      Builder.Layout(RD);\n\n      // In certain situations, we are allowed to lay out objects in the\n      // tail-padding of base classes.  This is ABI-dependent.\n      // FIXME: this should be stored in the record layout.\n      bool skipTailPadding =\n          mustSkipTailPadding(getTargetInfo().getCXXABI(), RD);\n\n      // FIXME: This should be done in FinalizeLayout.\n      CharUnits DataSize =\n          skipTailPadding ? Builder.getSize() : Builder.getDataSize();\n      CharUnits NonVirtualSize =\n          skipTailPadding ? DataSize : Builder.NonVirtualSize;\n      NewEntry = new (*this) ASTRecordLayout(\n          *this, Builder.getSize(), Builder.Alignment,\n          Builder.PreferredAlignment, Builder.UnadjustedAlignment,\n          /*RequiredAlignment : used by MS-ABI)*/\n          Builder.Alignment, Builder.HasOwnVFPtr, RD->isDynamicClass(),\n          CharUnits::fromQuantity(-1), DataSize, Builder.FieldOffsets,\n          NonVirtualSize, Builder.NonVirtualAlignment,\n          Builder.PreferredNVAlignment,\n          EmptySubobjects.SizeOfLargestEmptySubobject, Builder.PrimaryBase,\n          Builder.PrimaryBaseIsVirtual, nullptr, false, false, Builder.Bases,\n          Builder.VBases);\n    } else {\n      ItaniumRecordLayoutBuilder Builder(*this, /*EmptySubobjects=*/nullptr);\n      Builder.Layout(D);\n\n      NewEntry = new (*this) ASTRecordLayout(\n          *this, Builder.getSize(), Builder.Alignment,\n          Builder.PreferredAlignment, Builder.UnadjustedAlignment,\n          /*RequiredAlignment : used by MS-ABI)*/\n          Builder.Alignment, Builder.getSize(), Builder.FieldOffsets);\n    }\n  }\n\n  ASTRecordLayouts[D] = NewEntry;\n\n  if (getLangOpts().DumpRecordLayouts) {\n    llvm::outs() << \"\\n*** Dumping AST Record Layout\\n\";\n    DumpRecordLayout(D, llvm::outs(), getLangOpts().DumpRecordLayoutsSimple);\n  }\n\n  return *NewEntry;\n}\n\nconst CXXMethodDecl *ASTContext::getCurrentKeyFunction(const CXXRecordDecl *RD) {\n  if (!getTargetInfo().getCXXABI().hasKeyFunctions())\n    return nullptr;\n\n  assert(RD->getDefinition() && \"Cannot get key function for forward decl!\");\n  RD = RD->getDefinition();\n\n  // Beware:\n  //  1) computing the key function might trigger deserialization, which might\n  //     invalidate iterators into KeyFunctions\n  //  2) 'get' on the LazyDeclPtr might also trigger deserialization and\n  //     invalidate the LazyDeclPtr within the map itself\n  LazyDeclPtr Entry = KeyFunctions[RD];\n  const Decl *Result =\n      Entry ? Entry.get(getExternalSource()) : computeKeyFunction(*this, RD);\n\n  // Store it back if it changed.\n  if (Entry.isOffset() || Entry.isValid() != bool(Result))\n    KeyFunctions[RD] = const_cast<Decl*>(Result);\n\n  return cast_or_null<CXXMethodDecl>(Result);\n}\n\nvoid ASTContext::setNonKeyFunction(const CXXMethodDecl *Method) {\n  assert(Method == Method->getFirstDecl() &&\n         \"not working with method declaration from class definition\");\n\n  // Look up the cache entry.  Since we're working with the first\n  // declaration, its parent must be the class definition, which is\n  // the correct key for the KeyFunctions hash.\n  const auto &Map = KeyFunctions;\n  auto I = Map.find(Method->getParent());\n\n  // If it's not cached, there's nothing to do.\n  if (I == Map.end()) return;\n\n  // If it is cached, check whether it's the target method, and if so,\n  // remove it from the cache. Note, the call to 'get' might invalidate\n  // the iterator and the LazyDeclPtr object within the map.\n  LazyDeclPtr Ptr = I->second;\n  if (Ptr.get(getExternalSource()) == Method) {\n    // FIXME: remember that we did this for module / chained PCH state?\n    KeyFunctions.erase(Method->getParent());\n  }\n}\n\nstatic uint64_t getFieldOffset(const ASTContext &C, const FieldDecl *FD) {\n  const ASTRecordLayout &Layout = C.getASTRecordLayout(FD->getParent());\n  return Layout.getFieldOffset(FD->getFieldIndex());\n}\n\nuint64_t ASTContext::getFieldOffset(const ValueDecl *VD) const {\n  uint64_t OffsetInBits;\n  if (const FieldDecl *FD = dyn_cast<FieldDecl>(VD)) {\n    OffsetInBits = ::getFieldOffset(*this, FD);\n  } else {\n    const IndirectFieldDecl *IFD = cast<IndirectFieldDecl>(VD);\n\n    OffsetInBits = 0;\n    for (const NamedDecl *ND : IFD->chain())\n      OffsetInBits += ::getFieldOffset(*this, cast<FieldDecl>(ND));\n  }\n\n  return OffsetInBits;\n}\n\nuint64_t ASTContext::lookupFieldBitOffset(const ObjCInterfaceDecl *OID,\n                                          const ObjCImplementationDecl *ID,\n                                          const ObjCIvarDecl *Ivar) const {\n  const ObjCInterfaceDecl *Container = Ivar->getContainingInterface();\n\n  // FIXME: We should eliminate the need to have ObjCImplementationDecl passed\n  // in here; it should never be necessary because that should be the lexical\n  // decl context for the ivar.\n\n  // If we know have an implementation (and the ivar is in it) then\n  // look up in the implementation layout.\n  const ASTRecordLayout *RL;\n  if (ID && declaresSameEntity(ID->getClassInterface(), Container))\n    RL = &getASTObjCImplementationLayout(ID);\n  else\n    RL = &getASTObjCInterfaceLayout(Container);\n\n  // Compute field index.\n  //\n  // FIXME: The index here is closely tied to how ASTContext::getObjCLayout is\n  // implemented. This should be fixed to get the information from the layout\n  // directly.\n  unsigned Index = 0;\n\n  for (const ObjCIvarDecl *IVD = Container->all_declared_ivar_begin();\n       IVD; IVD = IVD->getNextIvar()) {\n    if (Ivar == IVD)\n      break;\n    ++Index;\n  }\n  assert(Index < RL->getFieldCount() && \"Ivar is not inside record layout!\");\n\n  return RL->getFieldOffset(Index);\n}\n\n/// getObjCLayout - Get or compute information about the layout of the\n/// given interface.\n///\n/// \\param Impl - If given, also include the layout of the interface's\n/// implementation. This may differ by including synthesized ivars.\nconst ASTRecordLayout &\nASTContext::getObjCLayout(const ObjCInterfaceDecl *D,\n                          const ObjCImplementationDecl *Impl) const {\n  // Retrieve the definition\n  if (D->hasExternalLexicalStorage() && !D->getDefinition())\n    getExternalSource()->CompleteType(const_cast<ObjCInterfaceDecl*>(D));\n  D = D->getDefinition();\n  assert(D && !D->isInvalidDecl() && D->isThisDeclarationADefinition() &&\n         \"Invalid interface decl!\");\n\n  // Look up this layout, if already laid out, return what we have.\n  const ObjCContainerDecl *Key =\n    Impl ? (const ObjCContainerDecl*) Impl : (const ObjCContainerDecl*) D;\n  if (const ASTRecordLayout *Entry = ObjCLayouts[Key])\n    return *Entry;\n\n  // Add in synthesized ivar count if laying out an implementation.\n  if (Impl) {\n    unsigned SynthCount = CountNonClassIvars(D);\n    // If there aren't any synthesized ivars then reuse the interface\n    // entry. Note we can't cache this because we simply free all\n    // entries later; however we shouldn't look up implementations\n    // frequently.\n    if (SynthCount == 0)\n      return getObjCLayout(D, nullptr);\n  }\n\n  ItaniumRecordLayoutBuilder Builder(*this, /*EmptySubobjects=*/nullptr);\n  Builder.Layout(D);\n\n  const ASTRecordLayout *NewEntry = new (*this) ASTRecordLayout(\n      *this, Builder.getSize(), Builder.Alignment, Builder.PreferredAlignment,\n      Builder.UnadjustedAlignment,\n      /*RequiredAlignment : used by MS-ABI)*/\n      Builder.Alignment, Builder.getDataSize(), Builder.FieldOffsets);\n\n  ObjCLayouts[Key] = NewEntry;\n\n  return *NewEntry;\n}\n\nstatic void PrintOffset(raw_ostream &OS,\n                        CharUnits Offset, unsigned IndentLevel) {\n  OS << llvm::format(\"%10\" PRId64 \" | \", (int64_t)Offset.getQuantity());\n  OS.indent(IndentLevel * 2);\n}\n\nstatic void PrintBitFieldOffset(raw_ostream &OS, CharUnits Offset,\n                                unsigned Begin, unsigned Width,\n                                unsigned IndentLevel) {\n  llvm::SmallString<10> Buffer;\n  {\n    llvm::raw_svector_ostream BufferOS(Buffer);\n    BufferOS << Offset.getQuantity() << ':';\n    if (Width == 0) {\n      BufferOS << '-';\n    } else {\n      BufferOS << Begin << '-' << (Begin + Width - 1);\n    }\n  }\n\n  OS << llvm::right_justify(Buffer, 10) << \" | \";\n  OS.indent(IndentLevel * 2);\n}\n\nstatic void PrintIndentNoOffset(raw_ostream &OS, unsigned IndentLevel) {\n  OS << \"           | \";\n  OS.indent(IndentLevel * 2);\n}\n\nstatic void DumpRecordLayout(raw_ostream &OS, const RecordDecl *RD,\n                             const ASTContext &C,\n                             CharUnits Offset,\n                             unsigned IndentLevel,\n                             const char* Description,\n                             bool PrintSizeInfo,\n                             bool IncludeVirtualBases) {\n  const ASTRecordLayout &Layout = C.getASTRecordLayout(RD);\n  auto CXXRD = dyn_cast<CXXRecordDecl>(RD);\n\n  PrintOffset(OS, Offset, IndentLevel);\n  OS << C.getTypeDeclType(const_cast<RecordDecl*>(RD)).getAsString();\n  if (Description)\n    OS << ' ' << Description;\n  if (CXXRD && CXXRD->isEmpty())\n    OS << \" (empty)\";\n  OS << '\\n';\n\n  IndentLevel++;\n\n  // Dump bases.\n  if (CXXRD) {\n    const CXXRecordDecl *PrimaryBase = Layout.getPrimaryBase();\n    bool HasOwnVFPtr = Layout.hasOwnVFPtr();\n    bool HasOwnVBPtr = Layout.hasOwnVBPtr();\n\n    // Vtable pointer.\n    if (CXXRD->isDynamicClass() && !PrimaryBase && !isMsLayout(C)) {\n      PrintOffset(OS, Offset, IndentLevel);\n      OS << '(' << *RD << \" vtable pointer)\\n\";\n    } else if (HasOwnVFPtr) {\n      PrintOffset(OS, Offset, IndentLevel);\n      // vfptr (for Microsoft C++ ABI)\n      OS << '(' << *RD << \" vftable pointer)\\n\";\n    }\n\n    // Collect nvbases.\n    SmallVector<const CXXRecordDecl *, 4> Bases;\n    for (const CXXBaseSpecifier &Base : CXXRD->bases()) {\n      assert(!Base.getType()->isDependentType() &&\n             \"Cannot layout class with dependent bases.\");\n      if (!Base.isVirtual())\n        Bases.push_back(Base.getType()->getAsCXXRecordDecl());\n    }\n\n    // Sort nvbases by offset.\n    llvm::stable_sort(\n        Bases, [&](const CXXRecordDecl *L, const CXXRecordDecl *R) {\n          return Layout.getBaseClassOffset(L) < Layout.getBaseClassOffset(R);\n        });\n\n    // Dump (non-virtual) bases\n    for (const CXXRecordDecl *Base : Bases) {\n      CharUnits BaseOffset = Offset + Layout.getBaseClassOffset(Base);\n      DumpRecordLayout(OS, Base, C, BaseOffset, IndentLevel,\n                       Base == PrimaryBase ? \"(primary base)\" : \"(base)\",\n                       /*PrintSizeInfo=*/false,\n                       /*IncludeVirtualBases=*/false);\n    }\n\n    // vbptr (for Microsoft C++ ABI)\n    if (HasOwnVBPtr) {\n      PrintOffset(OS, Offset + Layout.getVBPtrOffset(), IndentLevel);\n      OS << '(' << *RD << \" vbtable pointer)\\n\";\n    }\n  }\n\n  // Dump fields.\n  uint64_t FieldNo = 0;\n  for (RecordDecl::field_iterator I = RD->field_begin(),\n         E = RD->field_end(); I != E; ++I, ++FieldNo) {\n    const FieldDecl &Field = **I;\n    uint64_t LocalFieldOffsetInBits = Layout.getFieldOffset(FieldNo);\n    CharUnits FieldOffset =\n      Offset + C.toCharUnitsFromBits(LocalFieldOffsetInBits);\n\n    // Recursively dump fields of record type.\n    if (auto RT = Field.getType()->getAs<RecordType>()) {\n      DumpRecordLayout(OS, RT->getDecl(), C, FieldOffset, IndentLevel,\n                       Field.getName().data(),\n                       /*PrintSizeInfo=*/false,\n                       /*IncludeVirtualBases=*/true);\n      continue;\n    }\n\n    if (Field.isBitField()) {\n      uint64_t LocalFieldByteOffsetInBits = C.toBits(FieldOffset - Offset);\n      unsigned Begin = LocalFieldOffsetInBits - LocalFieldByteOffsetInBits;\n      unsigned Width = Field.getBitWidthValue(C);\n      PrintBitFieldOffset(OS, FieldOffset, Begin, Width, IndentLevel);\n    } else {\n      PrintOffset(OS, FieldOffset, IndentLevel);\n    }\n    OS << Field.getType().getAsString() << ' ' << Field << '\\n';\n  }\n\n  // Dump virtual bases.\n  if (CXXRD && IncludeVirtualBases) {\n    const ASTRecordLayout::VBaseOffsetsMapTy &VtorDisps =\n      Layout.getVBaseOffsetsMap();\n\n    for (const CXXBaseSpecifier &Base : CXXRD->vbases()) {\n      assert(Base.isVirtual() && \"Found non-virtual class!\");\n      const CXXRecordDecl *VBase = Base.getType()->getAsCXXRecordDecl();\n\n      CharUnits VBaseOffset = Offset + Layout.getVBaseClassOffset(VBase);\n\n      if (VtorDisps.find(VBase)->second.hasVtorDisp()) {\n        PrintOffset(OS, VBaseOffset - CharUnits::fromQuantity(4), IndentLevel);\n        OS << \"(vtordisp for vbase \" << *VBase << \")\\n\";\n      }\n\n      DumpRecordLayout(OS, VBase, C, VBaseOffset, IndentLevel,\n                       VBase == Layout.getPrimaryBase() ?\n                         \"(primary virtual base)\" : \"(virtual base)\",\n                       /*PrintSizeInfo=*/false,\n                       /*IncludeVirtualBases=*/false);\n    }\n  }\n\n  if (!PrintSizeInfo) return;\n\n  PrintIndentNoOffset(OS, IndentLevel - 1);\n  OS << \"[sizeof=\" << Layout.getSize().getQuantity();\n  if (CXXRD && !isMsLayout(C))\n    OS << \", dsize=\" << Layout.getDataSize().getQuantity();\n  OS << \", align=\" << Layout.getAlignment().getQuantity();\n  if (C.getTargetInfo().defaultsToAIXPowerAlignment())\n    OS << \", preferredalign=\" << Layout.getPreferredAlignment().getQuantity();\n\n  if (CXXRD) {\n    OS << \",\\n\";\n    PrintIndentNoOffset(OS, IndentLevel - 1);\n    OS << \" nvsize=\" << Layout.getNonVirtualSize().getQuantity();\n    OS << \", nvalign=\" << Layout.getNonVirtualAlignment().getQuantity();\n    if (C.getTargetInfo().defaultsToAIXPowerAlignment())\n      OS << \", preferrednvalign=\"\n         << Layout.getPreferredNVAlignment().getQuantity();\n  }\n  OS << \"]\\n\";\n}\n\nvoid ASTContext::DumpRecordLayout(const RecordDecl *RD, raw_ostream &OS,\n                                  bool Simple) const {\n  if (!Simple) {\n    ::DumpRecordLayout(OS, RD, *this, CharUnits(), 0, nullptr,\n                       /*PrintSizeInfo*/ true,\n                       /*IncludeVirtualBases=*/true);\n    return;\n  }\n\n  // The \"simple\" format is designed to be parsed by the\n  // layout-override testing code.  There shouldn't be any external\n  // uses of this format --- when LLDB overrides a layout, it sets up\n  // the data structures directly --- so feel free to adjust this as\n  // you like as long as you also update the rudimentary parser for it\n  // in libFrontend.\n\n  const ASTRecordLayout &Info = getASTRecordLayout(RD);\n  OS << \"Type: \" << getTypeDeclType(RD).getAsString() << \"\\n\";\n  OS << \"\\nLayout: \";\n  OS << \"<ASTRecordLayout\\n\";\n  OS << \"  Size:\" << toBits(Info.getSize()) << \"\\n\";\n  if (!isMsLayout(*this))\n    OS << \"  DataSize:\" << toBits(Info.getDataSize()) << \"\\n\";\n  OS << \"  Alignment:\" << toBits(Info.getAlignment()) << \"\\n\";\n  if (Target->defaultsToAIXPowerAlignment())\n    OS << \"  PreferredAlignment:\" << toBits(Info.getPreferredAlignment())\n       << \"\\n\";\n  OS << \"  FieldOffsets: [\";\n  for (unsigned i = 0, e = Info.getFieldCount(); i != e; ++i) {\n    if (i)\n      OS << \", \";\n    OS << Info.getFieldOffset(i);\n  }\n  OS << \"]>\\n\";\n}\n"}}, "reports": [{"events": [{"location": {"col": 50, "file": 20, "line": 1221}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp", "reportHash": "6af56b216cd179ed955de0408f0bdd52", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 50, "file": 20, "line": 1221}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp", "reportHash": "3e066eadcff9d0d5ed69ba038218da1a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 22, "file": 20, "line": 1853}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp", "reportHash": "4300a17427aa8c25c4b377455e98075b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 22, "file": 20, "line": 1853}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp", "reportHash": "32d3fca8251462b1e29a5ec7bbfd88ab", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 47, "file": 20, "line": 1936}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp", "reportHash": "595bd54af7d100156f1649e31f444e52", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 47, "file": 20, "line": 1936}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp", "reportHash": "ed4c74910942b26a315709fff585e4ae", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 20, "line": 2444}, "message": "default constructor 'ElementInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp", "reportHash": "79b5c8fbd5f35198eb067be81ca4620c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 20, "line": 2444}, "message": "move constructor 'ElementInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp", "reportHash": "4e856802b9add5ea8defe4e31d6cefd9", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
