<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"30": {"id": 30, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h", "content": "//===- llvm/CodeGen/SelectionDAG.h - InstSelection DAG ----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file declares the SelectionDAG class, and transitively defines the\n// SDNode class and subclasses.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CODEGEN_SELECTIONDAG_H\n#define LLVM_CODEGEN_SELECTIONDAG_H\n\n#include \"llvm/ADT/APFloat.h\"\n#include \"llvm/ADT/APInt.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/DenseSet.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/SetVector.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/ilist.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/CodeGen/DAGCombine.h\"\n#include \"llvm/CodeGen/ISDOpcodes.h\"\n#include \"llvm/CodeGen/MachineFunction.h\"\n#include \"llvm/CodeGen/MachineMemOperand.h\"\n#include \"llvm/CodeGen/SelectionDAGNodes.h\"\n#include \"llvm/CodeGen/ValueTypes.h\"\n#include \"llvm/IR/DebugLoc.h\"\n#include \"llvm/IR/Instructions.h\"\n#include \"llvm/IR/Metadata.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/ArrayRecycler.h\"\n#include \"llvm/Support/AtomicOrdering.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/CodeGen.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/MachineValueType.h\"\n#include \"llvm/Support/RecyclingAllocator.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstdint>\n#include <functional>\n#include <map>\n#include <string>\n#include <tuple>\n#include <utility>\n#include <vector>\n\nnamespace llvm {\n\nclass AAResults;\nclass BlockAddress;\nclass BlockFrequencyInfo;\nclass Constant;\nclass ConstantFP;\nclass ConstantInt;\nclass DataLayout;\nstruct fltSemantics;\nclass FunctionLoweringInfo;\nclass GlobalValue;\nstruct KnownBits;\nclass LegacyDivergenceAnalysis;\nclass LLVMContext;\nclass MachineBasicBlock;\nclass MachineConstantPoolValue;\nclass MCSymbol;\nclass OptimizationRemarkEmitter;\nclass ProfileSummaryInfo;\nclass SDDbgValue;\nclass SDDbgOperand;\nclass SDDbgLabel;\nclass SelectionDAG;\nclass SelectionDAGTargetInfo;\nclass TargetLibraryInfo;\nclass TargetLowering;\nclass TargetMachine;\nclass TargetSubtargetInfo;\nclass Value;\n\nclass SDVTListNode : public FoldingSetNode {\n  friend struct FoldingSetTrait<SDVTListNode>;\n\n  /// A reference to an Interned FoldingSetNodeID for this node.\n  /// The Allocator in SelectionDAG holds the data.\n  /// SDVTList contains all types which are frequently accessed in SelectionDAG.\n  /// The size of this list is not expected to be big so it won't introduce\n  /// a memory penalty.\n  FoldingSetNodeIDRef FastID;\n  const EVT *VTs;\n  unsigned int NumVTs;\n  /// The hash value for SDVTList is fixed, so cache it to avoid\n  /// hash calculation.\n  unsigned HashValue;\n\npublic:\n  SDVTListNode(const FoldingSetNodeIDRef ID, const EVT *VT, unsigned int Num) :\n      FastID(ID), VTs(VT), NumVTs(Num) {\n    HashValue = ID.ComputeHash();\n  }\n\n  SDVTList getSDVTList() {\n    SDVTList result = {VTs, NumVTs};\n    return result;\n  }\n};\n\n/// Specialize FoldingSetTrait for SDVTListNode\n/// to avoid computing temp FoldingSetNodeID and hash value.\ntemplate<> struct FoldingSetTrait<SDVTListNode> : DefaultFoldingSetTrait<SDVTListNode> {\n  static void Profile(const SDVTListNode &X, FoldingSetNodeID& ID) {\n    ID = X.FastID;\n  }\n\n  static bool Equals(const SDVTListNode &X, const FoldingSetNodeID &ID,\n                     unsigned IDHash, FoldingSetNodeID &TempID) {\n    if (X.HashValue != IDHash)\n      return false;\n    return ID == X.FastID;\n  }\n\n  static unsigned ComputeHash(const SDVTListNode &X, FoldingSetNodeID &TempID) {\n    return X.HashValue;\n  }\n};\n\ntemplate <> struct ilist_alloc_traits<SDNode> {\n  static void deleteNode(SDNode *) {\n    llvm_unreachable(\"ilist_traits<SDNode> shouldn't see a deleteNode call!\");\n  }\n};\n\n/// Keeps track of dbg_value information through SDISel.  We do\n/// not build SDNodes for these so as not to perturb the generated code;\n/// instead the info is kept off to the side in this structure. Each SDNode may\n/// have one or more associated dbg_value entries. This information is kept in\n/// DbgValMap.\n/// Byval parameters are handled separately because they don't use alloca's,\n/// which busts the normal mechanism.  There is good reason for handling all\n/// parameters separately:  they may not have code generated for them, they\n/// should always go at the beginning of the function regardless of other code\n/// motion, and debug info for them is potentially useful even if the parameter\n/// is unused.  Right now only byval parameters are handled separately.\nclass SDDbgInfo {\n  BumpPtrAllocator Alloc;\n  SmallVector<SDDbgValue*, 32> DbgValues;\n  SmallVector<SDDbgValue*, 32> ByvalParmDbgValues;\n  SmallVector<SDDbgLabel*, 4> DbgLabels;\n  using DbgValMapType = DenseMap<const SDNode *, SmallVector<SDDbgValue *, 2>>;\n  DbgValMapType DbgValMap;\n\npublic:\n  SDDbgInfo() = default;\n  SDDbgInfo(const SDDbgInfo &) = delete;\n  SDDbgInfo &operator=(const SDDbgInfo &) = delete;\n\n  void add(SDDbgValue *V, bool isParameter);\n\n  void add(SDDbgLabel *L) { DbgLabels.push_back(L); }\n\n  /// Invalidate all DbgValues attached to the node and remove\n  /// it from the Node-to-DbgValues map.\n  void erase(const SDNode *Node);\n\n  void clear() {\n    DbgValMap.clear();\n    DbgValues.clear();\n    ByvalParmDbgValues.clear();\n    DbgLabels.clear();\n    Alloc.Reset();\n  }\n\n  BumpPtrAllocator &getAlloc() { return Alloc; }\n\n  bool empty() const {\n    return DbgValues.empty() && ByvalParmDbgValues.empty() && DbgLabels.empty();\n  }\n\n  ArrayRef<SDDbgValue*> getSDDbgValues(const SDNode *Node) const {\n    auto I = DbgValMap.find(Node);\n    if (I != DbgValMap.end())\n      return I->second;\n    return ArrayRef<SDDbgValue*>();\n  }\n\n  using DbgIterator = SmallVectorImpl<SDDbgValue*>::iterator;\n  using DbgLabelIterator = SmallVectorImpl<SDDbgLabel*>::iterator;\n\n  DbgIterator DbgBegin() { return DbgValues.begin(); }\n  DbgIterator DbgEnd()   { return DbgValues.end(); }\n  DbgIterator ByvalParmDbgBegin() { return ByvalParmDbgValues.begin(); }\n  DbgIterator ByvalParmDbgEnd()   { return ByvalParmDbgValues.end(); }\n  DbgLabelIterator DbgLabelBegin() { return DbgLabels.begin(); }\n  DbgLabelIterator DbgLabelEnd()   { return DbgLabels.end(); }\n};\n\nvoid checkForCycles(const SelectionDAG *DAG, bool force = false);\n\n/// This is used to represent a portion of an LLVM function in a low-level\n/// Data Dependence DAG representation suitable for instruction selection.\n/// This DAG is constructed as the first step of instruction selection in order\n/// to allow implementation of machine specific optimizations\n/// and code simplifications.\n///\n/// The representation used by the SelectionDAG is a target-independent\n/// representation, which has some similarities to the GCC RTL representation,\n/// but is significantly more simple, powerful, and is a graph form instead of a\n/// linear form.\n///\nclass SelectionDAG {\n  const TargetMachine &TM;\n  const SelectionDAGTargetInfo *TSI = nullptr;\n  const TargetLowering *TLI = nullptr;\n  const TargetLibraryInfo *LibInfo = nullptr;\n  MachineFunction *MF;\n  Pass *SDAGISelPass = nullptr;\n  LLVMContext *Context;\n  CodeGenOpt::Level OptLevel;\n\n  LegacyDivergenceAnalysis * DA = nullptr;\n  FunctionLoweringInfo * FLI = nullptr;\n\n  /// The function-level optimization remark emitter.  Used to emit remarks\n  /// whenever manipulating the DAG.\n  OptimizationRemarkEmitter *ORE;\n\n  ProfileSummaryInfo *PSI = nullptr;\n  BlockFrequencyInfo *BFI = nullptr;\n\n  /// The starting token.\n  SDNode EntryNode;\n\n  /// The root of the entire DAG.\n  SDValue Root;\n\n  /// A linked list of nodes in the current DAG.\n  ilist<SDNode> AllNodes;\n\n  /// The AllocatorType for allocating SDNodes. We use\n  /// pool allocation with recycling.\n  using NodeAllocatorType = RecyclingAllocator<BumpPtrAllocator, SDNode,\n                                               sizeof(LargestSDNode),\n                                               alignof(MostAlignedSDNode)>;\n\n  /// Pool allocation for nodes.\n  NodeAllocatorType NodeAllocator;\n\n  /// This structure is used to memoize nodes, automatically performing\n  /// CSE with existing nodes when a duplicate is requested.\n  FoldingSet<SDNode> CSEMap;\n\n  /// Pool allocation for machine-opcode SDNode operands.\n  BumpPtrAllocator OperandAllocator;\n  ArrayRecycler<SDUse> OperandRecycler;\n\n  /// Pool allocation for misc. objects that are created once per SelectionDAG.\n  BumpPtrAllocator Allocator;\n\n  /// Tracks dbg_value and dbg_label information through SDISel.\n  SDDbgInfo *DbgInfo;\n\n  using CallSiteInfo = MachineFunction::CallSiteInfo;\n  using CallSiteInfoImpl = MachineFunction::CallSiteInfoImpl;\n\n  struct CallSiteDbgInfo {\n    CallSiteInfo CSInfo;\n    MDNode *HeapAllocSite = nullptr;\n    bool NoMerge = false;\n  };\n\n  DenseMap<const SDNode *, CallSiteDbgInfo> SDCallSiteDbgInfo;\n\n  uint16_t NextPersistentId = 0;\n\npublic:\n  /// Clients of various APIs that cause global effects on\n  /// the DAG can optionally implement this interface.  This allows the clients\n  /// to handle the various sorts of updates that happen.\n  ///\n  /// A DAGUpdateListener automatically registers itself with DAG when it is\n  /// constructed, and removes itself when destroyed in RAII fashion.\n  struct DAGUpdateListener {\n    DAGUpdateListener *const Next;\n    SelectionDAG &DAG;\n\n    explicit DAGUpdateListener(SelectionDAG &D)\n      : Next(D.UpdateListeners), DAG(D) {\n      DAG.UpdateListeners = this;\n    }\n\n    virtual ~DAGUpdateListener() {\n      assert(DAG.UpdateListeners == this &&\n             \"DAGUpdateListeners must be destroyed in LIFO order\");\n      DAG.UpdateListeners = Next;\n    }\n\n    /// The node N that was deleted and, if E is not null, an\n    /// equivalent node E that replaced it.\n    virtual void NodeDeleted(SDNode *N, SDNode *E);\n\n    /// The node N that was updated.\n    virtual void NodeUpdated(SDNode *N);\n\n    /// The node N that was inserted.\n    virtual void NodeInserted(SDNode *N);\n  };\n\n  struct DAGNodeDeletedListener : public DAGUpdateListener {\n    std::function<void(SDNode *, SDNode *)> Callback;\n\n    DAGNodeDeletedListener(SelectionDAG &DAG,\n                           std::function<void(SDNode *, SDNode *)> Callback)\n        : DAGUpdateListener(DAG), Callback(std::move(Callback)) {}\n\n    void NodeDeleted(SDNode *N, SDNode *E) override { Callback(N, E); }\n\n   private:\n    virtual void anchor();\n  };\n\n  /// Help to insert SDNodeFlags automatically in transforming. Use\n  /// RAII to save and resume flags in current scope.\n  class FlagInserter {\n    SelectionDAG &DAG;\n    SDNodeFlags Flags;\n    FlagInserter *LastInserter;\n\n  public:\n    FlagInserter(SelectionDAG &SDAG, SDNodeFlags Flags)\n        : DAG(SDAG), Flags(Flags),\n          LastInserter(SDAG.getFlagInserter()) {\n      SDAG.setFlagInserter(this);\n    }\n    FlagInserter(SelectionDAG &SDAG, SDNode *N)\n        : FlagInserter(SDAG, N->getFlags()) {}\n\n    FlagInserter(const FlagInserter &) = delete;\n    FlagInserter &operator=(const FlagInserter &) = delete;\n    ~FlagInserter() { DAG.setFlagInserter(LastInserter); }\n\n    SDNodeFlags getFlags() const { return Flags; }\n  };\n\n  /// When true, additional steps are taken to\n  /// ensure that getConstant() and similar functions return DAG nodes that\n  /// have legal types. This is important after type legalization since\n  /// any illegally typed nodes generated after this point will not experience\n  /// type legalization.\n  bool NewNodesMustHaveLegalTypes = false;\n\nprivate:\n  /// DAGUpdateListener is a friend so it can manipulate the listener stack.\n  friend struct DAGUpdateListener;\n\n  /// Linked list of registered DAGUpdateListener instances.\n  /// This stack is maintained by DAGUpdateListener RAII.\n  DAGUpdateListener *UpdateListeners = nullptr;\n\n  /// Implementation of setSubgraphColor.\n  /// Return whether we had to truncate the search.\n  bool setSubgraphColorHelper(SDNode *N, const char *Color,\n                              DenseSet<SDNode *> &visited,\n                              int level, bool &printed);\n\n  template <typename SDNodeT, typename... ArgTypes>\n  SDNodeT *newSDNode(ArgTypes &&... Args) {\n    return new (NodeAllocator.template Allocate<SDNodeT>())\n        SDNodeT(std::forward<ArgTypes>(Args)...);\n  }\n\n  /// Build a synthetic SDNodeT with the given args and extract its subclass\n  /// data as an integer (e.g. for use in a folding set).\n  ///\n  /// The args to this function are the same as the args to SDNodeT's\n  /// constructor, except the second arg (assumed to be a const DebugLoc&) is\n  /// omitted.\n  template <typename SDNodeT, typename... ArgTypes>\n  static uint16_t getSyntheticNodeSubclassData(unsigned IROrder,\n                                               ArgTypes &&... Args) {\n    // The compiler can reduce this expression to a constant iff we pass an\n    // empty DebugLoc.  Thankfully, the debug location doesn't have any bearing\n    // on the subclass data.\n    return SDNodeT(IROrder, DebugLoc(), std::forward<ArgTypes>(Args)...)\n        .getRawSubclassData();\n  }\n\n  template <typename SDNodeTy>\n  static uint16_t getSyntheticNodeSubclassData(unsigned Opc, unsigned Order,\n                                                SDVTList VTs, EVT MemoryVT,\n                                                MachineMemOperand *MMO) {\n    return SDNodeTy(Opc, Order, DebugLoc(), VTs, MemoryVT, MMO)\n         .getRawSubclassData();\n  }\n\n  void createOperands(SDNode *Node, ArrayRef<SDValue> Vals);\n\n  void removeOperands(SDNode *Node) {\n    if (!Node->OperandList)\n      return;\n    OperandRecycler.deallocate(\n        ArrayRecycler<SDUse>::Capacity::get(Node->NumOperands),\n        Node->OperandList);\n    Node->NumOperands = 0;\n    Node->OperandList = nullptr;\n  }\n  void CreateTopologicalOrder(std::vector<SDNode*>& Order);\n\npublic:\n  // Maximum depth for recursive analysis such as computeKnownBits, etc.\n  static constexpr unsigned MaxRecursionDepth = 6;\n\n  explicit SelectionDAG(const TargetMachine &TM, CodeGenOpt::Level);\n  SelectionDAG(const SelectionDAG &) = delete;\n  SelectionDAG &operator=(const SelectionDAG &) = delete;\n  ~SelectionDAG();\n\n  /// Prepare this SelectionDAG to process code in the given MachineFunction.\n  void init(MachineFunction &NewMF, OptimizationRemarkEmitter &NewORE,\n            Pass *PassPtr, const TargetLibraryInfo *LibraryInfo,\n            LegacyDivergenceAnalysis * Divergence,\n            ProfileSummaryInfo *PSIin, BlockFrequencyInfo *BFIin);\n\n  void setFunctionLoweringInfo(FunctionLoweringInfo * FuncInfo) {\n    FLI = FuncInfo;\n  }\n\n  /// Clear state and free memory necessary to make this\n  /// SelectionDAG ready to process a new block.\n  void clear();\n\n  MachineFunction &getMachineFunction() const { return *MF; }\n  const Pass *getPass() const { return SDAGISelPass; }\n\n  const DataLayout &getDataLayout() const { return MF->getDataLayout(); }\n  const TargetMachine &getTarget() const { return TM; }\n  const TargetSubtargetInfo &getSubtarget() const { return MF->getSubtarget(); }\n  const TargetLowering &getTargetLoweringInfo() const { return *TLI; }\n  const TargetLibraryInfo &getLibInfo() const { return *LibInfo; }\n  const SelectionDAGTargetInfo &getSelectionDAGInfo() const { return *TSI; }\n  const LegacyDivergenceAnalysis *getDivergenceAnalysis() const { return DA; }\n  LLVMContext *getContext() const { return Context; }\n  OptimizationRemarkEmitter &getORE() const { return *ORE; }\n  ProfileSummaryInfo *getPSI() const { return PSI; }\n  BlockFrequencyInfo *getBFI() const { return BFI; }\n\n  FlagInserter *getFlagInserter() { return Inserter; }\n  void setFlagInserter(FlagInserter *FI) { Inserter = FI; }\n\n  /// Just dump dot graph to a user-provided path and title.\n  /// This doesn't open the dot viewer program and\n  /// helps visualization when outside debugging session.\n  /// FileName expects absolute path. If provided\n  /// without any path separators then the file\n  /// will be created in the current directory.\n  /// Error will be emitted if the path is insane.\n#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)\n  LLVM_DUMP_METHOD void dumpDotGraph(const Twine &FileName, const Twine &Title);\n#endif\n\n  /// Pop up a GraphViz/gv window with the DAG rendered using 'dot'.\n  void viewGraph(const std::string &Title);\n  void viewGraph();\n\n#ifndef NDEBUG\n  std::map<const SDNode *, std::string> NodeGraphAttrs;\n#endif\n\n  /// Clear all previously defined node graph attributes.\n  /// Intended to be used from a debugging tool (eg. gdb).\n  void clearGraphAttrs();\n\n  /// Set graph attributes for a node. (eg. \"color=red\".)\n  void setGraphAttrs(const SDNode *N, const char *Attrs);\n\n  /// Get graph attributes for a node. (eg. \"color=red\".)\n  /// Used from getNodeAttributes.\n  std::string getGraphAttrs(const SDNode *N) const;\n\n  /// Convenience for setting node color attribute.\n  void setGraphColor(const SDNode *N, const char *Color);\n\n  /// Convenience for setting subgraph color attribute.\n  void setSubgraphColor(SDNode *N, const char *Color);\n\n  using allnodes_const_iterator = ilist<SDNode>::const_iterator;\n\n  allnodes_const_iterator allnodes_begin() const { return AllNodes.begin(); }\n  allnodes_const_iterator allnodes_end() const { return AllNodes.end(); }\n\n  using allnodes_iterator = ilist<SDNode>::iterator;\n\n  allnodes_iterator allnodes_begin() { return AllNodes.begin(); }\n  allnodes_iterator allnodes_end() { return AllNodes.end(); }\n\n  ilist<SDNode>::size_type allnodes_size() const {\n    return AllNodes.size();\n  }\n\n  iterator_range<allnodes_iterator> allnodes() {\n    return make_range(allnodes_begin(), allnodes_end());\n  }\n  iterator_range<allnodes_const_iterator> allnodes() const {\n    return make_range(allnodes_begin(), allnodes_end());\n  }\n\n  /// Return the root tag of the SelectionDAG.\n  const SDValue &getRoot() const { return Root; }\n\n  /// Return the token chain corresponding to the entry of the function.\n  SDValue getEntryNode() const {\n    return SDValue(const_cast<SDNode *>(&EntryNode), 0);\n  }\n\n  /// Set the current root tag of the SelectionDAG.\n  ///\n  const SDValue &setRoot(SDValue N) {\n    assert((!N.getNode() || N.getValueType() == MVT::Other) &&\n           \"DAG root value is not a chain!\");\n    if (N.getNode())\n      checkForCycles(N.getNode(), this);\n    Root = N;\n    if (N.getNode())\n      checkForCycles(this);\n    return Root;\n  }\n\n#ifndef NDEBUG\n  void VerifyDAGDiverence();\n#endif\n\n  /// This iterates over the nodes in the SelectionDAG, folding\n  /// certain types of nodes together, or eliminating superfluous nodes.  The\n  /// Level argument controls whether Combine is allowed to produce nodes and\n  /// types that are illegal on the target.\n  void Combine(CombineLevel Level, AAResults *AA,\n               CodeGenOpt::Level OptLevel);\n\n  /// This transforms the SelectionDAG into a SelectionDAG that\n  /// only uses types natively supported by the target.\n  /// Returns \"true\" if it made any changes.\n  ///\n  /// Note that this is an involved process that may invalidate pointers into\n  /// the graph.\n  bool LegalizeTypes();\n\n  /// This transforms the SelectionDAG into a SelectionDAG that is\n  /// compatible with the target instruction selector, as indicated by the\n  /// TargetLowering object.\n  ///\n  /// Note that this is an involved process that may invalidate pointers into\n  /// the graph.\n  void Legalize();\n\n  /// Transforms a SelectionDAG node and any operands to it into a node\n  /// that is compatible with the target instruction selector, as indicated by\n  /// the TargetLowering object.\n  ///\n  /// \\returns true if \\c N is a valid, legal node after calling this.\n  ///\n  /// This essentially runs a single recursive walk of the \\c Legalize process\n  /// over the given node (and its operands). This can be used to incrementally\n  /// legalize the DAG. All of the nodes which are directly replaced,\n  /// potentially including N, are added to the output parameter \\c\n  /// UpdatedNodes so that the delta to the DAG can be understood by the\n  /// caller.\n  ///\n  /// When this returns false, N has been legalized in a way that make the\n  /// pointer passed in no longer valid. It may have even been deleted from the\n  /// DAG, and so it shouldn't be used further. When this returns true, the\n  /// N passed in is a legal node, and can be immediately processed as such.\n  /// This may still have done some work on the DAG, and will still populate\n  /// UpdatedNodes with any new nodes replacing those originally in the DAG.\n  bool LegalizeOp(SDNode *N, SmallSetVector<SDNode *, 16> &UpdatedNodes);\n\n  /// This transforms the SelectionDAG into a SelectionDAG\n  /// that only uses vector math operations supported by the target.  This is\n  /// necessary as a separate step from Legalize because unrolling a vector\n  /// operation can introduce illegal types, which requires running\n  /// LegalizeTypes again.\n  ///\n  /// This returns true if it made any changes; in that case, LegalizeTypes\n  /// is called again before Legalize.\n  ///\n  /// Note that this is an involved process that may invalidate pointers into\n  /// the graph.\n  bool LegalizeVectors();\n\n  /// This method deletes all unreachable nodes in the SelectionDAG.\n  void RemoveDeadNodes();\n\n  /// Remove the specified node from the system.  This node must\n  /// have no referrers.\n  void DeleteNode(SDNode *N);\n\n  /// Return an SDVTList that represents the list of values specified.\n  SDVTList getVTList(EVT VT);\n  SDVTList getVTList(EVT VT1, EVT VT2);\n  SDVTList getVTList(EVT VT1, EVT VT2, EVT VT3);\n  SDVTList getVTList(EVT VT1, EVT VT2, EVT VT3, EVT VT4);\n  SDVTList getVTList(ArrayRef<EVT> VTs);\n\n  //===--------------------------------------------------------------------===//\n  // Node creation methods.\n\n  /// Create a ConstantSDNode wrapping a constant value.\n  /// If VT is a vector type, the constant is splatted into a BUILD_VECTOR.\n  ///\n  /// If only legal types can be produced, this does the necessary\n  /// transformations (e.g., if the vector element type is illegal).\n  /// @{\n  SDValue getConstant(uint64_t Val, const SDLoc &DL, EVT VT,\n                      bool isTarget = false, bool isOpaque = false);\n  SDValue getConstant(const APInt &Val, const SDLoc &DL, EVT VT,\n                      bool isTarget = false, bool isOpaque = false);\n\n  SDValue getAllOnesConstant(const SDLoc &DL, EVT VT, bool IsTarget = false,\n                             bool IsOpaque = false) {\n    return getConstant(APInt::getAllOnesValue(VT.getScalarSizeInBits()), DL,\n                       VT, IsTarget, IsOpaque);\n  }\n\n  SDValue getConstant(const ConstantInt &Val, const SDLoc &DL, EVT VT,\n                      bool isTarget = false, bool isOpaque = false);\n  SDValue getIntPtrConstant(uint64_t Val, const SDLoc &DL,\n                            bool isTarget = false);\n  SDValue getShiftAmountConstant(uint64_t Val, EVT VT, const SDLoc &DL,\n                                 bool LegalTypes = true);\n  SDValue getVectorIdxConstant(uint64_t Val, const SDLoc &DL,\n                               bool isTarget = false);\n\n  SDValue getTargetConstant(uint64_t Val, const SDLoc &DL, EVT VT,\n                            bool isOpaque = false) {\n    return getConstant(Val, DL, VT, true, isOpaque);\n  }\n  SDValue getTargetConstant(const APInt &Val, const SDLoc &DL, EVT VT,\n                            bool isOpaque = false) {\n    return getConstant(Val, DL, VT, true, isOpaque);\n  }\n  SDValue getTargetConstant(const ConstantInt &Val, const SDLoc &DL, EVT VT,\n                            bool isOpaque = false) {\n    return getConstant(Val, DL, VT, true, isOpaque);\n  }\n\n  /// Create a true or false constant of type \\p VT using the target's\n  /// BooleanContent for type \\p OpVT.\n  SDValue getBoolConstant(bool V, const SDLoc &DL, EVT VT, EVT OpVT);\n  /// @}\n\n  /// Create a ConstantFPSDNode wrapping a constant value.\n  /// If VT is a vector type, the constant is splatted into a BUILD_VECTOR.\n  ///\n  /// If only legal types can be produced, this does the necessary\n  /// transformations (e.g., if the vector element type is illegal).\n  /// The forms that take a double should only be used for simple constants\n  /// that can be exactly represented in VT.  No checks are made.\n  /// @{\n  SDValue getConstantFP(double Val, const SDLoc &DL, EVT VT,\n                        bool isTarget = false);\n  SDValue getConstantFP(const APFloat &Val, const SDLoc &DL, EVT VT,\n                        bool isTarget = false);\n  SDValue getConstantFP(const ConstantFP &V, const SDLoc &DL, EVT VT,\n                        bool isTarget = false);\n  SDValue getTargetConstantFP(double Val, const SDLoc &DL, EVT VT) {\n    return getConstantFP(Val, DL, VT, true);\n  }\n  SDValue getTargetConstantFP(const APFloat &Val, const SDLoc &DL, EVT VT) {\n    return getConstantFP(Val, DL, VT, true);\n  }\n  SDValue getTargetConstantFP(const ConstantFP &Val, const SDLoc &DL, EVT VT) {\n    return getConstantFP(Val, DL, VT, true);\n  }\n  /// @}\n\n  SDValue getGlobalAddress(const GlobalValue *GV, const SDLoc &DL, EVT VT,\n                           int64_t offset = 0, bool isTargetGA = false,\n                           unsigned TargetFlags = 0);\n  SDValue getTargetGlobalAddress(const GlobalValue *GV, const SDLoc &DL, EVT VT,\n                                 int64_t offset = 0, unsigned TargetFlags = 0) {\n    return getGlobalAddress(GV, DL, VT, offset, true, TargetFlags);\n  }\n  SDValue getFrameIndex(int FI, EVT VT, bool isTarget = false);\n  SDValue getTargetFrameIndex(int FI, EVT VT) {\n    return getFrameIndex(FI, VT, true);\n  }\n  SDValue getJumpTable(int JTI, EVT VT, bool isTarget = false,\n                       unsigned TargetFlags = 0);\n  SDValue getTargetJumpTable(int JTI, EVT VT, unsigned TargetFlags = 0) {\n    return getJumpTable(JTI, VT, true, TargetFlags);\n  }\n  SDValue getConstantPool(const Constant *C, EVT VT, MaybeAlign Align = None,\n                          int Offs = 0, bool isT = false,\n                          unsigned TargetFlags = 0);\n  SDValue getTargetConstantPool(const Constant *C, EVT VT,\n                                MaybeAlign Align = None, int Offset = 0,\n                                unsigned TargetFlags = 0) {\n    return getConstantPool(C, VT, Align, Offset, true, TargetFlags);\n  }\n  SDValue getConstantPool(MachineConstantPoolValue *C, EVT VT,\n                          MaybeAlign Align = None, int Offs = 0,\n                          bool isT = false, unsigned TargetFlags = 0);\n  SDValue getTargetConstantPool(MachineConstantPoolValue *C, EVT VT,\n                                MaybeAlign Align = None, int Offset = 0,\n                                unsigned TargetFlags = 0) {\n    return getConstantPool(C, VT, Align, Offset, true, TargetFlags);\n  }\n  SDValue getTargetIndex(int Index, EVT VT, int64_t Offset = 0,\n                         unsigned TargetFlags = 0);\n  // When generating a branch to a BB, we don't in general know enough\n  // to provide debug info for the BB at that time, so keep this one around.\n  SDValue getBasicBlock(MachineBasicBlock *MBB);\n  SDValue getExternalSymbol(const char *Sym, EVT VT);\n  SDValue getTargetExternalSymbol(const char *Sym, EVT VT,\n                                  unsigned TargetFlags = 0);\n  SDValue getMCSymbol(MCSymbol *Sym, EVT VT);\n\n  SDValue getValueType(EVT);\n  SDValue getRegister(unsigned Reg, EVT VT);\n  SDValue getRegisterMask(const uint32_t *RegMask);\n  SDValue getEHLabel(const SDLoc &dl, SDValue Root, MCSymbol *Label);\n  SDValue getLabelNode(unsigned Opcode, const SDLoc &dl, SDValue Root,\n                       MCSymbol *Label);\n  SDValue getBlockAddress(const BlockAddress *BA, EVT VT, int64_t Offset = 0,\n                          bool isTarget = false, unsigned TargetFlags = 0);\n  SDValue getTargetBlockAddress(const BlockAddress *BA, EVT VT,\n                                int64_t Offset = 0, unsigned TargetFlags = 0) {\n    return getBlockAddress(BA, VT, Offset, true, TargetFlags);\n  }\n\n  SDValue getCopyToReg(SDValue Chain, const SDLoc &dl, unsigned Reg,\n                       SDValue N) {\n    return getNode(ISD::CopyToReg, dl, MVT::Other, Chain,\n                   getRegister(Reg, N.getValueType()), N);\n  }\n\n  // This version of the getCopyToReg method takes an extra operand, which\n  // indicates that there is potentially an incoming glue value (if Glue is not\n  // null) and that there should be a glue result.\n  SDValue getCopyToReg(SDValue Chain, const SDLoc &dl, unsigned Reg, SDValue N,\n                       SDValue Glue) {\n    SDVTList VTs = getVTList(MVT::Other, MVT::Glue);\n    SDValue Ops[] = { Chain, getRegister(Reg, N.getValueType()), N, Glue };\n    return getNode(ISD::CopyToReg, dl, VTs,\n                   makeArrayRef(Ops, Glue.getNode() ? 4 : 3));\n  }\n\n  // Similar to last getCopyToReg() except parameter Reg is a SDValue\n  SDValue getCopyToReg(SDValue Chain, const SDLoc &dl, SDValue Reg, SDValue N,\n                       SDValue Glue) {\n    SDVTList VTs = getVTList(MVT::Other, MVT::Glue);\n    SDValue Ops[] = { Chain, Reg, N, Glue };\n    return getNode(ISD::CopyToReg, dl, VTs,\n                   makeArrayRef(Ops, Glue.getNode() ? 4 : 3));\n  }\n\n  SDValue getCopyFromReg(SDValue Chain, const SDLoc &dl, unsigned Reg, EVT VT) {\n    SDVTList VTs = getVTList(VT, MVT::Other);\n    SDValue Ops[] = { Chain, getRegister(Reg, VT) };\n    return getNode(ISD::CopyFromReg, dl, VTs, Ops);\n  }\n\n  // This version of the getCopyFromReg method takes an extra operand, which\n  // indicates that there is potentially an incoming glue value (if Glue is not\n  // null) and that there should be a glue result.\n  SDValue getCopyFromReg(SDValue Chain, const SDLoc &dl, unsigned Reg, EVT VT,\n                         SDValue Glue) {\n    SDVTList VTs = getVTList(VT, MVT::Other, MVT::Glue);\n    SDValue Ops[] = { Chain, getRegister(Reg, VT), Glue };\n    return getNode(ISD::CopyFromReg, dl, VTs,\n                   makeArrayRef(Ops, Glue.getNode() ? 3 : 2));\n  }\n\n  SDValue getCondCode(ISD::CondCode Cond);\n\n  /// Return an ISD::VECTOR_SHUFFLE node. The number of elements in VT,\n  /// which must be a vector type, must match the number of mask elements\n  /// NumElts. An integer mask element equal to -1 is treated as undefined.\n  SDValue getVectorShuffle(EVT VT, const SDLoc &dl, SDValue N1, SDValue N2,\n                           ArrayRef<int> Mask);\n\n  /// Return an ISD::BUILD_VECTOR node. The number of elements in VT,\n  /// which must be a vector type, must match the number of operands in Ops.\n  /// The operands must have the same type as (or, for integers, a type wider\n  /// than) VT's element type.\n  SDValue getBuildVector(EVT VT, const SDLoc &DL, ArrayRef<SDValue> Ops) {\n    // VerifySDNode (via InsertNode) checks BUILD_VECTOR later.\n    return getNode(ISD::BUILD_VECTOR, DL, VT, Ops);\n  }\n\n  /// Return an ISD::BUILD_VECTOR node. The number of elements in VT,\n  /// which must be a vector type, must match the number of operands in Ops.\n  /// The operands must have the same type as (or, for integers, a type wider\n  /// than) VT's element type.\n  SDValue getBuildVector(EVT VT, const SDLoc &DL, ArrayRef<SDUse> Ops) {\n    // VerifySDNode (via InsertNode) checks BUILD_VECTOR later.\n    return getNode(ISD::BUILD_VECTOR, DL, VT, Ops);\n  }\n\n  /// Return a splat ISD::BUILD_VECTOR node, consisting of Op splatted to all\n  /// elements. VT must be a vector type. Op's type must be the same as (or,\n  /// for integers, a type wider than) VT's element type.\n  SDValue getSplatBuildVector(EVT VT, const SDLoc &DL, SDValue Op) {\n    // VerifySDNode (via InsertNode) checks BUILD_VECTOR later.\n    if (Op.getOpcode() == ISD::UNDEF) {\n      assert((VT.getVectorElementType() == Op.getValueType() ||\n              (VT.isInteger() &&\n               VT.getVectorElementType().bitsLE(Op.getValueType()))) &&\n             \"A splatted value must have a width equal or (for integers) \"\n             \"greater than the vector element type!\");\n      return getNode(ISD::UNDEF, SDLoc(), VT);\n    }\n\n    SmallVector<SDValue, 16> Ops(VT.getVectorNumElements(), Op);\n    return getNode(ISD::BUILD_VECTOR, DL, VT, Ops);\n  }\n\n  // Return a splat ISD::SPLAT_VECTOR node, consisting of Op splatted to all\n  // elements.\n  SDValue getSplatVector(EVT VT, const SDLoc &DL, SDValue Op) {\n    if (Op.getOpcode() == ISD::UNDEF) {\n      assert((VT.getVectorElementType() == Op.getValueType() ||\n              (VT.isInteger() &&\n               VT.getVectorElementType().bitsLE(Op.getValueType()))) &&\n             \"A splatted value must have a width equal or (for integers) \"\n             \"greater than the vector element type!\");\n      return getNode(ISD::UNDEF, SDLoc(), VT);\n    }\n    return getNode(ISD::SPLAT_VECTOR, DL, VT, Op);\n  }\n\n  /// Returns an ISD::VECTOR_SHUFFLE node semantically equivalent to\n  /// the shuffle node in input but with swapped operands.\n  ///\n  /// Example: shuffle A, B, <0,5,2,7> -> shuffle B, A, <4,1,6,3>\n  SDValue getCommutedVectorShuffle(const ShuffleVectorSDNode &SV);\n\n  /// Convert Op, which must be of float type, to the\n  /// float type VT, by either extending or rounding (by truncation).\n  SDValue getFPExtendOrRound(SDValue Op, const SDLoc &DL, EVT VT);\n\n  /// Convert Op, which must be a STRICT operation of float type, to the\n  /// float type VT, by either extending or rounding (by truncation).\n  std::pair<SDValue, SDValue>\n  getStrictFPExtendOrRound(SDValue Op, SDValue Chain, const SDLoc &DL, EVT VT);\n\n  /// Convert Op, which must be of integer type, to the\n  /// integer type VT, by either any-extending or truncating it.\n  SDValue getAnyExtOrTrunc(SDValue Op, const SDLoc &DL, EVT VT);\n\n  /// Convert Op, which must be of integer type, to the\n  /// integer type VT, by either sign-extending or truncating it.\n  SDValue getSExtOrTrunc(SDValue Op, const SDLoc &DL, EVT VT);\n\n  /// Convert Op, which must be of integer type, to the\n  /// integer type VT, by either zero-extending or truncating it.\n  SDValue getZExtOrTrunc(SDValue Op, const SDLoc &DL, EVT VT);\n\n  /// Return the expression required to zero extend the Op\n  /// value assuming it was the smaller SrcTy value.\n  SDValue getZeroExtendInReg(SDValue Op, const SDLoc &DL, EVT VT);\n\n  /// Convert Op, which must be of integer type, to the integer type VT, by\n  /// either truncating it or performing either zero or sign extension as\n  /// appropriate extension for the pointer's semantics.\n  SDValue getPtrExtOrTrunc(SDValue Op, const SDLoc &DL, EVT VT);\n\n  /// Return the expression required to extend the Op as a pointer value\n  /// assuming it was the smaller SrcTy value. This may be either a zero extend\n  /// or a sign extend.\n  SDValue getPtrExtendInReg(SDValue Op, const SDLoc &DL, EVT VT);\n\n  /// Convert Op, which must be of integer type, to the integer type VT,\n  /// by using an extension appropriate for the target's\n  /// BooleanContent for type OpVT or truncating it.\n  SDValue getBoolExtOrTrunc(SDValue Op, const SDLoc &SL, EVT VT, EVT OpVT);\n\n  /// Create a bitwise NOT operation as (XOR Val, -1).\n  SDValue getNOT(const SDLoc &DL, SDValue Val, EVT VT);\n\n  /// Create a logical NOT operation as (XOR Val, BooleanOne).\n  SDValue getLogicalNOT(const SDLoc &DL, SDValue Val, EVT VT);\n\n  /// Returns sum of the base pointer and offset.\n  /// Unlike getObjectPtrOffset this does not set NoUnsignedWrap by default.\n  SDValue getMemBasePlusOffset(SDValue Base, TypeSize Offset, const SDLoc &DL,\n                               const SDNodeFlags Flags = SDNodeFlags());\n  SDValue getMemBasePlusOffset(SDValue Base, SDValue Offset, const SDLoc &DL,\n                               const SDNodeFlags Flags = SDNodeFlags());\n\n  /// Create an add instruction with appropriate flags when used for\n  /// addressing some offset of an object. i.e. if a load is split into multiple\n  /// components, create an add nuw from the base pointer to the offset.\n  SDValue getObjectPtrOffset(const SDLoc &SL, SDValue Ptr, TypeSize Offset) {\n    SDNodeFlags Flags;\n    Flags.setNoUnsignedWrap(true);\n    return getMemBasePlusOffset(Ptr, Offset, SL, Flags);\n  }\n\n  SDValue getObjectPtrOffset(const SDLoc &SL, SDValue Ptr, SDValue Offset) {\n    // The object itself can't wrap around the address space, so it shouldn't be\n    // possible for the adds of the offsets to the split parts to overflow.\n    SDNodeFlags Flags;\n    Flags.setNoUnsignedWrap(true);\n    return getMemBasePlusOffset(Ptr, Offset, SL, Flags);\n  }\n\n  /// Return a new CALLSEQ_START node, that starts new call frame, in which\n  /// InSize bytes are set up inside CALLSEQ_START..CALLSEQ_END sequence and\n  /// OutSize specifies part of the frame set up prior to the sequence.\n  SDValue getCALLSEQ_START(SDValue Chain, uint64_t InSize, uint64_t OutSize,\n                           const SDLoc &DL) {\n    SDVTList VTs = getVTList(MVT::Other, MVT::Glue);\n    SDValue Ops[] = { Chain,\n                      getIntPtrConstant(InSize, DL, true),\n                      getIntPtrConstant(OutSize, DL, true) };\n    return getNode(ISD::CALLSEQ_START, DL, VTs, Ops);\n  }\n\n  /// Return a new CALLSEQ_END node, which always must have a\n  /// glue result (to ensure it's not CSE'd).\n  /// CALLSEQ_END does not have a useful SDLoc.\n  SDValue getCALLSEQ_END(SDValue Chain, SDValue Op1, SDValue Op2,\n                         SDValue InGlue, const SDLoc &DL) {\n    SDVTList NodeTys = getVTList(MVT::Other, MVT::Glue);\n    SmallVector<SDValue, 4> Ops;\n    Ops.push_back(Chain);\n    Ops.push_back(Op1);\n    Ops.push_back(Op2);\n    if (InGlue.getNode())\n      Ops.push_back(InGlue);\n    return getNode(ISD::CALLSEQ_END, DL, NodeTys, Ops);\n  }\n\n  /// Return true if the result of this operation is always undefined.\n  bool isUndef(unsigned Opcode, ArrayRef<SDValue> Ops);\n\n  /// Return an UNDEF node. UNDEF does not have a useful SDLoc.\n  SDValue getUNDEF(EVT VT) {\n    return getNode(ISD::UNDEF, SDLoc(), VT);\n  }\n\n  /// Return a node that represents the runtime scaling 'MulImm * RuntimeVL'.\n  SDValue getVScale(const SDLoc &DL, EVT VT, APInt MulImm) {\n    assert(MulImm.getMinSignedBits() <= VT.getSizeInBits() &&\n           \"Immediate does not fit VT\");\n    return getNode(ISD::VSCALE, DL, VT,\n                   getConstant(MulImm.sextOrTrunc(VT.getSizeInBits()), DL, VT));\n  }\n\n  /// Return a GLOBAL_OFFSET_TABLE node. This does not have a useful SDLoc.\n  SDValue getGLOBAL_OFFSET_TABLE(EVT VT) {\n    return getNode(ISD::GLOBAL_OFFSET_TABLE, SDLoc(), VT);\n  }\n\n  /// Gets or creates the specified node.\n  ///\n  SDValue getNode(unsigned Opcode, const SDLoc &DL, EVT VT,\n                  ArrayRef<SDUse> Ops);\n  SDValue getNode(unsigned Opcode, const SDLoc &DL, EVT VT,\n                  ArrayRef<SDValue> Ops, const SDNodeFlags Flags);\n  SDValue getNode(unsigned Opcode, const SDLoc &DL, ArrayRef<EVT> ResultTys,\n                  ArrayRef<SDValue> Ops);\n  SDValue getNode(unsigned Opcode, const SDLoc &DL, SDVTList VTList,\n                  ArrayRef<SDValue> Ops, const SDNodeFlags Flags);\n\n  // Use flags from current flag inserter.\n  SDValue getNode(unsigned Opcode, const SDLoc &DL, EVT VT,\n                  ArrayRef<SDValue> Ops);\n  SDValue getNode(unsigned Opcode, const SDLoc &DL, SDVTList VTList,\n                  ArrayRef<SDValue> Ops);\n  SDValue getNode(unsigned Opcode, const SDLoc &DL, EVT VT, SDValue Operand);\n  SDValue getNode(unsigned Opcode, const SDLoc &DL, EVT VT, SDValue N1,\n                  SDValue N2);\n  SDValue getNode(unsigned Opcode, const SDLoc &DL, EVT VT, SDValue N1,\n                  SDValue N2, SDValue N3);\n\n  // Specialize based on number of operands.\n  SDValue getNode(unsigned Opcode, const SDLoc &DL, EVT VT);\n  SDValue getNode(unsigned Opcode, const SDLoc &DL, EVT VT, SDValue Operand,\n                  const SDNodeFlags Flags);\n  SDValue getNode(unsigned Opcode, const SDLoc &DL, EVT VT, SDValue N1,\n                  SDValue N2, const SDNodeFlags Flags);\n  SDValue getNode(unsigned Opcode, const SDLoc &DL, EVT VT, SDValue N1,\n                  SDValue N2, SDValue N3, const SDNodeFlags Flags);\n  SDValue getNode(unsigned Opcode, const SDLoc &DL, EVT VT, SDValue N1,\n                  SDValue N2, SDValue N3, SDValue N4);\n  SDValue getNode(unsigned Opcode, const SDLoc &DL, EVT VT, SDValue N1,\n                  SDValue N2, SDValue N3, SDValue N4, SDValue N5);\n\n  // Specialize again based on number of operands for nodes with a VTList\n  // rather than a single VT.\n  SDValue getNode(unsigned Opcode, const SDLoc &DL, SDVTList VTList);\n  SDValue getNode(unsigned Opcode, const SDLoc &DL, SDVTList VTList, SDValue N);\n  SDValue getNode(unsigned Opcode, const SDLoc &DL, SDVTList VTList, SDValue N1,\n                  SDValue N2);\n  SDValue getNode(unsigned Opcode, const SDLoc &DL, SDVTList VTList, SDValue N1,\n                  SDValue N2, SDValue N3);\n  SDValue getNode(unsigned Opcode, const SDLoc &DL, SDVTList VTList, SDValue N1,\n                  SDValue N2, SDValue N3, SDValue N4);\n  SDValue getNode(unsigned Opcode, const SDLoc &DL, SDVTList VTList, SDValue N1,\n                  SDValue N2, SDValue N3, SDValue N4, SDValue N5);\n\n  /// Compute a TokenFactor to force all the incoming stack arguments to be\n  /// loaded from the stack. This is used in tail call lowering to protect\n  /// stack arguments from being clobbered.\n  SDValue getStackArgumentTokenFactor(SDValue Chain);\n\n  LLVM_ATTRIBUTE_DEPRECATED(SDValue getMemcpy(SDValue Chain, const SDLoc &dl,\n                                              SDValue Dst, SDValue Src,\n                                              SDValue Size, unsigned Align,\n                                              bool isVol, bool AlwaysInline,\n                                              bool isTailCall,\n                                              MachinePointerInfo DstPtrInfo,\n                                              MachinePointerInfo SrcPtrInfo),\n                            \"Use the version that takes Align instead\") {\n    return getMemcpy(Chain, dl, Dst, Src, Size, llvm::Align(Align), isVol,\n                     AlwaysInline, isTailCall, DstPtrInfo, SrcPtrInfo);\n  }\n\n  SDValue getMemcpy(SDValue Chain, const SDLoc &dl, SDValue Dst, SDValue Src,\n                    SDValue Size, Align Alignment, bool isVol,\n                    bool AlwaysInline, bool isTailCall,\n                    MachinePointerInfo DstPtrInfo,\n                    MachinePointerInfo SrcPtrInfo);\n\n  LLVM_ATTRIBUTE_DEPRECATED(SDValue getMemmove(SDValue Chain, const SDLoc &dl,\n                                               SDValue Dst, SDValue Src,\n                                               SDValue Size, unsigned Align,\n                                               bool isVol, bool isTailCall,\n                                               MachinePointerInfo DstPtrInfo,\n                                               MachinePointerInfo SrcPtrInfo),\n                            \"Use the version that takes Align instead\") {\n    return getMemmove(Chain, dl, Dst, Src, Size, llvm::Align(Align), isVol,\n                      isTailCall, DstPtrInfo, SrcPtrInfo);\n  }\n  SDValue getMemmove(SDValue Chain, const SDLoc &dl, SDValue Dst, SDValue Src,\n                     SDValue Size, Align Alignment, bool isVol, bool isTailCall,\n                     MachinePointerInfo DstPtrInfo,\n                     MachinePointerInfo SrcPtrInfo);\n\n  LLVM_ATTRIBUTE_DEPRECATED(SDValue getMemset(SDValue Chain, const SDLoc &dl,\n                                              SDValue Dst, SDValue Src,\n                                              SDValue Size, unsigned Align,\n                                              bool isVol, bool isTailCall,\n                                              MachinePointerInfo DstPtrInfo),\n                            \"Use the version that takes Align instead\") {\n    return getMemset(Chain, dl, Dst, Src, Size, llvm::Align(Align), isVol,\n                     isTailCall, DstPtrInfo);\n  }\n  SDValue getMemset(SDValue Chain, const SDLoc &dl, SDValue Dst, SDValue Src,\n                    SDValue Size, Align Alignment, bool isVol, bool isTailCall,\n                    MachinePointerInfo DstPtrInfo);\n\n  SDValue getAtomicMemcpy(SDValue Chain, const SDLoc &dl, SDValue Dst,\n                          unsigned DstAlign, SDValue Src, unsigned SrcAlign,\n                          SDValue Size, Type *SizeTy, unsigned ElemSz,\n                          bool isTailCall, MachinePointerInfo DstPtrInfo,\n                          MachinePointerInfo SrcPtrInfo);\n\n  SDValue getAtomicMemmove(SDValue Chain, const SDLoc &dl, SDValue Dst,\n                           unsigned DstAlign, SDValue Src, unsigned SrcAlign,\n                           SDValue Size, Type *SizeTy, unsigned ElemSz,\n                           bool isTailCall, MachinePointerInfo DstPtrInfo,\n                           MachinePointerInfo SrcPtrInfo);\n\n  SDValue getAtomicMemset(SDValue Chain, const SDLoc &dl, SDValue Dst,\n                          unsigned DstAlign, SDValue Value, SDValue Size,\n                          Type *SizeTy, unsigned ElemSz, bool isTailCall,\n                          MachinePointerInfo DstPtrInfo);\n\n  /// Helper function to make it easier to build SetCC's if you just have an\n  /// ISD::CondCode instead of an SDValue.\n  SDValue getSetCC(const SDLoc &DL, EVT VT, SDValue LHS, SDValue RHS,\n                   ISD::CondCode Cond, SDValue Chain = SDValue(),\n                   bool IsSignaling = false) {\n    assert(LHS.getValueType().isVector() == RHS.getValueType().isVector() &&\n           \"Cannot compare scalars to vectors\");\n    assert(LHS.getValueType().isVector() == VT.isVector() &&\n           \"Cannot compare scalars to vectors\");\n    assert(Cond != ISD::SETCC_INVALID &&\n           \"Cannot create a setCC of an invalid node.\");\n    if (Chain)\n      return getNode(IsSignaling ? ISD::STRICT_FSETCCS : ISD::STRICT_FSETCC, DL,\n                     {VT, MVT::Other}, {Chain, LHS, RHS, getCondCode(Cond)});\n    return getNode(ISD::SETCC, DL, VT, LHS, RHS, getCondCode(Cond));\n  }\n\n  /// Helper function to make it easier to build Select's if you just have\n  /// operands and don't want to check for vector.\n  SDValue getSelect(const SDLoc &DL, EVT VT, SDValue Cond, SDValue LHS,\n                    SDValue RHS) {\n    assert(LHS.getValueType() == RHS.getValueType() &&\n           \"Cannot use select on differing types\");\n    assert(VT.isVector() == LHS.getValueType().isVector() &&\n           \"Cannot mix vectors and scalars\");\n    auto Opcode = Cond.getValueType().isVector() ? ISD::VSELECT : ISD::SELECT;\n    return getNode(Opcode, DL, VT, Cond, LHS, RHS);\n  }\n\n  /// Helper function to make it easier to build SelectCC's if you just have an\n  /// ISD::CondCode instead of an SDValue.\n  SDValue getSelectCC(const SDLoc &DL, SDValue LHS, SDValue RHS, SDValue True,\n                      SDValue False, ISD::CondCode Cond) {\n    return getNode(ISD::SELECT_CC, DL, True.getValueType(), LHS, RHS, True,\n                   False, getCondCode(Cond));\n  }\n\n  /// Try to simplify a select/vselect into 1 of its operands or a constant.\n  SDValue simplifySelect(SDValue Cond, SDValue TVal, SDValue FVal);\n\n  /// Try to simplify a shift into 1 of its operands or a constant.\n  SDValue simplifyShift(SDValue X, SDValue Y);\n\n  /// Try to simplify a floating-point binary operation into 1 of its operands\n  /// or a constant.\n  SDValue simplifyFPBinop(unsigned Opcode, SDValue X, SDValue Y,\n                          SDNodeFlags Flags);\n\n  /// VAArg produces a result and token chain, and takes a pointer\n  /// and a source value as input.\n  SDValue getVAArg(EVT VT, const SDLoc &dl, SDValue Chain, SDValue Ptr,\n                   SDValue SV, unsigned Align);\n\n  /// Gets a node for an atomic cmpxchg op. There are two\n  /// valid Opcodes. ISD::ATOMIC_CMO_SWAP produces the value loaded and a\n  /// chain result. ISD::ATOMIC_CMP_SWAP_WITH_SUCCESS produces the value loaded,\n  /// a success flag (initially i1), and a chain.\n  SDValue getAtomicCmpSwap(unsigned Opcode, const SDLoc &dl, EVT MemVT,\n                           SDVTList VTs, SDValue Chain, SDValue Ptr,\n                           SDValue Cmp, SDValue Swp, MachineMemOperand *MMO);\n\n  /// Gets a node for an atomic op, produces result (if relevant)\n  /// and chain and takes 2 operands.\n  SDValue getAtomic(unsigned Opcode, const SDLoc &dl, EVT MemVT, SDValue Chain,\n                    SDValue Ptr, SDValue Val, MachineMemOperand *MMO);\n\n  /// Gets a node for an atomic op, produces result and chain and\n  /// takes 1 operand.\n  SDValue getAtomic(unsigned Opcode, const SDLoc &dl, EVT MemVT, EVT VT,\n                    SDValue Chain, SDValue Ptr, MachineMemOperand *MMO);\n\n  /// Gets a node for an atomic op, produces result and chain and takes N\n  /// operands.\n  SDValue getAtomic(unsigned Opcode, const SDLoc &dl, EVT MemVT,\n                    SDVTList VTList, ArrayRef<SDValue> Ops,\n                    MachineMemOperand *MMO);\n\n  /// Creates a MemIntrinsicNode that may produce a\n  /// result and takes a list of operands. Opcode may be INTRINSIC_VOID,\n  /// INTRINSIC_W_CHAIN, or a target-specific opcode with a value not\n  /// less than FIRST_TARGET_MEMORY_OPCODE.\n  SDValue getMemIntrinsicNode(\n      unsigned Opcode, const SDLoc &dl, SDVTList VTList, ArrayRef<SDValue> Ops,\n      EVT MemVT, MachinePointerInfo PtrInfo, Align Alignment,\n      MachineMemOperand::Flags Flags = MachineMemOperand::MOLoad |\n                                       MachineMemOperand::MOStore,\n      uint64_t Size = 0, const AAMDNodes &AAInfo = AAMDNodes());\n\n  inline SDValue getMemIntrinsicNode(\n      unsigned Opcode, const SDLoc &dl, SDVTList VTList, ArrayRef<SDValue> Ops,\n      EVT MemVT, MachinePointerInfo PtrInfo, MaybeAlign Alignment = None,\n      MachineMemOperand::Flags Flags = MachineMemOperand::MOLoad |\n                                       MachineMemOperand::MOStore,\n      uint64_t Size = 0, const AAMDNodes &AAInfo = AAMDNodes()) {\n    // Ensure that codegen never sees alignment 0\n    return getMemIntrinsicNode(Opcode, dl, VTList, Ops, MemVT, PtrInfo,\n                               Alignment.getValueOr(getEVTAlign(MemVT)), Flags,\n                               Size, AAInfo);\n  }\n\n  LLVM_ATTRIBUTE_DEPRECATED(\n      inline SDValue getMemIntrinsicNode(\n          unsigned Opcode, const SDLoc &dl, SDVTList VTList,\n          ArrayRef<SDValue> Ops, EVT MemVT, MachinePointerInfo PtrInfo,\n          unsigned Alignment,\n          MachineMemOperand::Flags Flags = MachineMemOperand::MOLoad |\n                                           MachineMemOperand::MOStore,\n          uint64_t Size = 0, const AAMDNodes &AAInfo = AAMDNodes()),\n      \"\") {\n    return getMemIntrinsicNode(Opcode, dl, VTList, Ops, MemVT, PtrInfo,\n                               MaybeAlign(Alignment), Flags, Size, AAInfo);\n  }\n\n  SDValue getMemIntrinsicNode(unsigned Opcode, const SDLoc &dl, SDVTList VTList,\n                              ArrayRef<SDValue> Ops, EVT MemVT,\n                              MachineMemOperand *MMO);\n\n  /// Creates a LifetimeSDNode that starts (`IsStart==true`) or ends\n  /// (`IsStart==false`) the lifetime of the portion of `FrameIndex` between\n  /// offsets `Offset` and `Offset + Size`.\n  SDValue getLifetimeNode(bool IsStart, const SDLoc &dl, SDValue Chain,\n                          int FrameIndex, int64_t Size, int64_t Offset = -1);\n\n  /// Creates a PseudoProbeSDNode with function GUID `Guid` and\n  /// the index of the block `Index` it is probing, as well as the attributes\n  /// `attr` of the probe.\n  SDValue getPseudoProbeNode(const SDLoc &Dl, SDValue Chain, uint64_t Guid,\n                             uint64_t Index, uint32_t Attr);\n\n  /// Create a MERGE_VALUES node from the given operands.\n  SDValue getMergeValues(ArrayRef<SDValue> Ops, const SDLoc &dl);\n\n  /// Loads are not normal binary operators: their result type is not\n  /// determined by their operands, and they produce a value AND a token chain.\n  ///\n  /// This function will set the MOLoad flag on MMOFlags, but you can set it if\n  /// you want.  The MOStore flag must not be set.\n  SDValue getLoad(EVT VT, const SDLoc &dl, SDValue Chain, SDValue Ptr,\n                  MachinePointerInfo PtrInfo,\n                  MaybeAlign Alignment = MaybeAlign(),\n                  MachineMemOperand::Flags MMOFlags = MachineMemOperand::MONone,\n                  const AAMDNodes &AAInfo = AAMDNodes(),\n                  const MDNode *Ranges = nullptr);\n  /// FIXME: Remove once transition to Align is over.\n  inline SDValue\n  getLoad(EVT VT, const SDLoc &dl, SDValue Chain, SDValue Ptr,\n          MachinePointerInfo PtrInfo, unsigned Alignment,\n          MachineMemOperand::Flags MMOFlags = MachineMemOperand::MONone,\n          const AAMDNodes &AAInfo = AAMDNodes(),\n          const MDNode *Ranges = nullptr) {\n    return getLoad(VT, dl, Chain, Ptr, PtrInfo, MaybeAlign(Alignment), MMOFlags,\n                   AAInfo, Ranges);\n  }\n  SDValue getLoad(EVT VT, const SDLoc &dl, SDValue Chain, SDValue Ptr,\n                  MachineMemOperand *MMO);\n  SDValue\n  getExtLoad(ISD::LoadExtType ExtType, const SDLoc &dl, EVT VT, SDValue Chain,\n             SDValue Ptr, MachinePointerInfo PtrInfo, EVT MemVT,\n             MaybeAlign Alignment = MaybeAlign(),\n             MachineMemOperand::Flags MMOFlags = MachineMemOperand::MONone,\n             const AAMDNodes &AAInfo = AAMDNodes());\n  /// FIXME: Remove once transition to Align is over.\n  inline SDValue\n  getExtLoad(ISD::LoadExtType ExtType, const SDLoc &dl, EVT VT, SDValue Chain,\n             SDValue Ptr, MachinePointerInfo PtrInfo, EVT MemVT,\n             unsigned Alignment,\n             MachineMemOperand::Flags MMOFlags = MachineMemOperand::MONone,\n             const AAMDNodes &AAInfo = AAMDNodes()) {\n    return getExtLoad(ExtType, dl, VT, Chain, Ptr, PtrInfo, MemVT,\n                      MaybeAlign(Alignment), MMOFlags, AAInfo);\n  }\n  SDValue getExtLoad(ISD::LoadExtType ExtType, const SDLoc &dl, EVT VT,\n                     SDValue Chain, SDValue Ptr, EVT MemVT,\n                     MachineMemOperand *MMO);\n  SDValue getIndexedLoad(SDValue OrigLoad, const SDLoc &dl, SDValue Base,\n                         SDValue Offset, ISD::MemIndexedMode AM);\n  SDValue getLoad(ISD::MemIndexedMode AM, ISD::LoadExtType ExtType, EVT VT,\n                  const SDLoc &dl, SDValue Chain, SDValue Ptr, SDValue Offset,\n                  MachinePointerInfo PtrInfo, EVT MemVT, Align Alignment,\n                  MachineMemOperand::Flags MMOFlags = MachineMemOperand::MONone,\n                  const AAMDNodes &AAInfo = AAMDNodes(),\n                  const MDNode *Ranges = nullptr);\n  inline SDValue getLoad(\n      ISD::MemIndexedMode AM, ISD::LoadExtType ExtType, EVT VT, const SDLoc &dl,\n      SDValue Chain, SDValue Ptr, SDValue Offset, MachinePointerInfo PtrInfo,\n      EVT MemVT, MaybeAlign Alignment = MaybeAlign(),\n      MachineMemOperand::Flags MMOFlags = MachineMemOperand::MONone,\n      const AAMDNodes &AAInfo = AAMDNodes(), const MDNode *Ranges = nullptr) {\n    // Ensures that codegen never sees a None Alignment.\n    return getLoad(AM, ExtType, VT, dl, Chain, Ptr, Offset, PtrInfo, MemVT,\n                   Alignment.getValueOr(getEVTAlign(MemVT)), MMOFlags, AAInfo,\n                   Ranges);\n  }\n  /// FIXME: Remove once transition to Align is over.\n  inline SDValue\n  getLoad(ISD::MemIndexedMode AM, ISD::LoadExtType ExtType, EVT VT,\n          const SDLoc &dl, SDValue Chain, SDValue Ptr, SDValue Offset,\n          MachinePointerInfo PtrInfo, EVT MemVT, unsigned Alignment,\n          MachineMemOperand::Flags MMOFlags = MachineMemOperand::MONone,\n          const AAMDNodes &AAInfo = AAMDNodes(),\n          const MDNode *Ranges = nullptr) {\n    return getLoad(AM, ExtType, VT, dl, Chain, Ptr, Offset, PtrInfo, MemVT,\n                   MaybeAlign(Alignment), MMOFlags, AAInfo, Ranges);\n  }\n  SDValue getLoad(ISD::MemIndexedMode AM, ISD::LoadExtType ExtType, EVT VT,\n                  const SDLoc &dl, SDValue Chain, SDValue Ptr, SDValue Offset,\n                  EVT MemVT, MachineMemOperand *MMO);\n\n  /// Helper function to build ISD::STORE nodes.\n  ///\n  /// This function will set the MOStore flag on MMOFlags, but you can set it if\n  /// you want.  The MOLoad and MOInvariant flags must not be set.\n\n  SDValue\n  getStore(SDValue Chain, const SDLoc &dl, SDValue Val, SDValue Ptr,\n           MachinePointerInfo PtrInfo, Align Alignment,\n           MachineMemOperand::Flags MMOFlags = MachineMemOperand::MONone,\n           const AAMDNodes &AAInfo = AAMDNodes());\n  inline SDValue\n  getStore(SDValue Chain, const SDLoc &dl, SDValue Val, SDValue Ptr,\n           MachinePointerInfo PtrInfo, MaybeAlign Alignment = MaybeAlign(),\n           MachineMemOperand::Flags MMOFlags = MachineMemOperand::MONone,\n           const AAMDNodes &AAInfo = AAMDNodes()) {\n    return getStore(Chain, dl, Val, Ptr, PtrInfo,\n                    Alignment.getValueOr(getEVTAlign(Val.getValueType())),\n                    MMOFlags, AAInfo);\n  }\n  /// FIXME: Remove once transition to Align is over.\n  inline SDValue\n  getStore(SDValue Chain, const SDLoc &dl, SDValue Val, SDValue Ptr,\n           MachinePointerInfo PtrInfo, unsigned Alignment,\n           MachineMemOperand::Flags MMOFlags = MachineMemOperand::MONone,\n           const AAMDNodes &AAInfo = AAMDNodes()) {\n    return getStore(Chain, dl, Val, Ptr, PtrInfo, MaybeAlign(Alignment),\n                    MMOFlags, AAInfo);\n  }\n  SDValue getStore(SDValue Chain, const SDLoc &dl, SDValue Val, SDValue Ptr,\n                   MachineMemOperand *MMO);\n  SDValue\n  getTruncStore(SDValue Chain, const SDLoc &dl, SDValue Val, SDValue Ptr,\n                MachinePointerInfo PtrInfo, EVT SVT, Align Alignment,\n                MachineMemOperand::Flags MMOFlags = MachineMemOperand::MONone,\n                const AAMDNodes &AAInfo = AAMDNodes());\n  inline SDValue\n  getTruncStore(SDValue Chain, const SDLoc &dl, SDValue Val, SDValue Ptr,\n                MachinePointerInfo PtrInfo, EVT SVT,\n                MaybeAlign Alignment = MaybeAlign(),\n                MachineMemOperand::Flags MMOFlags = MachineMemOperand::MONone,\n                const AAMDNodes &AAInfo = AAMDNodes()) {\n    return getTruncStore(Chain, dl, Val, Ptr, PtrInfo, SVT,\n                         Alignment.getValueOr(getEVTAlign(SVT)), MMOFlags,\n                         AAInfo);\n  }\n  /// FIXME: Remove once transition to Align is over.\n  inline SDValue\n  getTruncStore(SDValue Chain, const SDLoc &dl, SDValue Val, SDValue Ptr,\n                MachinePointerInfo PtrInfo, EVT SVT, unsigned Alignment,\n                MachineMemOperand::Flags MMOFlags = MachineMemOperand::MONone,\n                const AAMDNodes &AAInfo = AAMDNodes()) {\n    return getTruncStore(Chain, dl, Val, Ptr, PtrInfo, SVT,\n                         MaybeAlign(Alignment), MMOFlags, AAInfo);\n  }\n  SDValue getTruncStore(SDValue Chain, const SDLoc &dl, SDValue Val,\n                        SDValue Ptr, EVT SVT, MachineMemOperand *MMO);\n  SDValue getIndexedStore(SDValue OrigStore, const SDLoc &dl, SDValue Base,\n                          SDValue Offset, ISD::MemIndexedMode AM);\n\n  SDValue getMaskedLoad(EVT VT, const SDLoc &dl, SDValue Chain, SDValue Base,\n                        SDValue Offset, SDValue Mask, SDValue Src0, EVT MemVT,\n                        MachineMemOperand *MMO, ISD::MemIndexedMode AM,\n                        ISD::LoadExtType, bool IsExpanding = false);\n  SDValue getIndexedMaskedLoad(SDValue OrigLoad, const SDLoc &dl, SDValue Base,\n                               SDValue Offset, ISD::MemIndexedMode AM);\n  SDValue getMaskedStore(SDValue Chain, const SDLoc &dl, SDValue Val,\n                         SDValue Base, SDValue Offset, SDValue Mask, EVT MemVT,\n                         MachineMemOperand *MMO, ISD::MemIndexedMode AM,\n                         bool IsTruncating = false, bool IsCompressing = false);\n  SDValue getIndexedMaskedStore(SDValue OrigStore, const SDLoc &dl,\n                                SDValue Base, SDValue Offset,\n                                ISD::MemIndexedMode AM);\n  SDValue getMaskedGather(SDVTList VTs, EVT VT, const SDLoc &dl,\n                          ArrayRef<SDValue> Ops, MachineMemOperand *MMO,\n                          ISD::MemIndexType IndexType, ISD::LoadExtType ExtTy);\n  SDValue getMaskedScatter(SDVTList VTs, EVT VT, const SDLoc &dl,\n                           ArrayRef<SDValue> Ops, MachineMemOperand *MMO,\n                           ISD::MemIndexType IndexType,\n                           bool IsTruncating = false);\n\n  /// Construct a node to track a Value* through the backend.\n  SDValue getSrcValue(const Value *v);\n\n  /// Return an MDNodeSDNode which holds an MDNode.\n  SDValue getMDNode(const MDNode *MD);\n\n  /// Return a bitcast using the SDLoc of the value operand, and casting to the\n  /// provided type. Use getNode to set a custom SDLoc.\n  SDValue getBitcast(EVT VT, SDValue V);\n\n  /// Return an AddrSpaceCastSDNode.\n  SDValue getAddrSpaceCast(const SDLoc &dl, EVT VT, SDValue Ptr, unsigned SrcAS,\n                           unsigned DestAS);\n\n  /// Return a freeze using the SDLoc of the value operand.\n  SDValue getFreeze(SDValue V);\n\n  /// Return an AssertAlignSDNode.\n  SDValue getAssertAlign(const SDLoc &DL, SDValue V, Align A);\n\n  /// Return the specified value casted to\n  /// the target's desired shift amount type.\n  SDValue getShiftAmountOperand(EVT LHSTy, SDValue Op);\n\n  /// Expand the specified \\c ISD::VAARG node as the Legalize pass would.\n  SDValue expandVAArg(SDNode *Node);\n\n  /// Expand the specified \\c ISD::VACOPY node as the Legalize pass would.\n  SDValue expandVACopy(SDNode *Node);\n\n  /// Returs an GlobalAddress of the function from the current module with\n  /// name matching the given ExternalSymbol. Additionally can provide the\n  /// matched function.\n  /// Panics the function doesn't exists.\n  SDValue getSymbolFunctionGlobalAddress(SDValue Op,\n                                         Function **TargetFunction = nullptr);\n\n  /// *Mutate* the specified node in-place to have the\n  /// specified operands.  If the resultant node already exists in the DAG,\n  /// this does not modify the specified node, instead it returns the node that\n  /// already exists.  If the resultant node does not exist in the DAG, the\n  /// input node is returned.  As a degenerate case, if you specify the same\n  /// input operands as the node already has, the input node is returned.\n  SDNode *UpdateNodeOperands(SDNode *N, SDValue Op);\n  SDNode *UpdateNodeOperands(SDNode *N, SDValue Op1, SDValue Op2);\n  SDNode *UpdateNodeOperands(SDNode *N, SDValue Op1, SDValue Op2,\n                               SDValue Op3);\n  SDNode *UpdateNodeOperands(SDNode *N, SDValue Op1, SDValue Op2,\n                               SDValue Op3, SDValue Op4);\n  SDNode *UpdateNodeOperands(SDNode *N, SDValue Op1, SDValue Op2,\n                               SDValue Op3, SDValue Op4, SDValue Op5);\n  SDNode *UpdateNodeOperands(SDNode *N, ArrayRef<SDValue> Ops);\n\n  /// Creates a new TokenFactor containing \\p Vals. If \\p Vals contains 64k\n  /// values or more, move values into new TokenFactors in 64k-1 blocks, until\n  /// the final TokenFactor has less than 64k operands.\n  SDValue getTokenFactor(const SDLoc &DL, SmallVectorImpl<SDValue> &Vals);\n\n  /// *Mutate* the specified machine node's memory references to the provided\n  /// list.\n  void setNodeMemRefs(MachineSDNode *N,\n                      ArrayRef<MachineMemOperand *> NewMemRefs);\n\n  // Calculate divergence of node \\p N based on its operands.\n  bool calculateDivergence(SDNode *N);\n\n  // Propagates the change in divergence to users\n  void updateDivergence(SDNode * N);\n\n  /// These are used for target selectors to *mutate* the\n  /// specified node to have the specified return type, Target opcode, and\n  /// operands.  Note that target opcodes are stored as\n  /// ~TargetOpcode in the node opcode field.  The resultant node is returned.\n  SDNode *SelectNodeTo(SDNode *N, unsigned MachineOpc, EVT VT);\n  SDNode *SelectNodeTo(SDNode *N, unsigned MachineOpc, EVT VT, SDValue Op1);\n  SDNode *SelectNodeTo(SDNode *N, unsigned MachineOpc, EVT VT,\n                       SDValue Op1, SDValue Op2);\n  SDNode *SelectNodeTo(SDNode *N, unsigned MachineOpc, EVT VT,\n                       SDValue Op1, SDValue Op2, SDValue Op3);\n  SDNode *SelectNodeTo(SDNode *N, unsigned MachineOpc, EVT VT,\n                       ArrayRef<SDValue> Ops);\n  SDNode *SelectNodeTo(SDNode *N, unsigned MachineOpc, EVT VT1, EVT VT2);\n  SDNode *SelectNodeTo(SDNode *N, unsigned MachineOpc, EVT VT1,\n                       EVT VT2, ArrayRef<SDValue> Ops);\n  SDNode *SelectNodeTo(SDNode *N, unsigned MachineOpc, EVT VT1,\n                       EVT VT2, EVT VT3, ArrayRef<SDValue> Ops);\n  SDNode *SelectNodeTo(SDNode *N, unsigned MachineOpc, EVT VT1,\n                       EVT VT2, SDValue Op1, SDValue Op2);\n  SDNode *SelectNodeTo(SDNode *N, unsigned MachineOpc, SDVTList VTs,\n                       ArrayRef<SDValue> Ops);\n\n  /// This *mutates* the specified node to have the specified\n  /// return type, opcode, and operands.\n  SDNode *MorphNodeTo(SDNode *N, unsigned Opc, SDVTList VTs,\n                      ArrayRef<SDValue> Ops);\n\n  /// Mutate the specified strict FP node to its non-strict equivalent,\n  /// unlinking the node from its chain and dropping the metadata arguments.\n  /// The node must be a strict FP node.\n  SDNode *mutateStrictFPToFP(SDNode *Node);\n\n  /// These are used for target selectors to create a new node\n  /// with specified return type(s), MachineInstr opcode, and operands.\n  ///\n  /// Note that getMachineNode returns the resultant node.  If there is already\n  /// a node of the specified opcode and operands, it returns that node instead\n  /// of the current one.\n  MachineSDNode *getMachineNode(unsigned Opcode, const SDLoc &dl, EVT VT);\n  MachineSDNode *getMachineNode(unsigned Opcode, const SDLoc &dl, EVT VT,\n                                SDValue Op1);\n  MachineSDNode *getMachineNode(unsigned Opcode, const SDLoc &dl, EVT VT,\n                                SDValue Op1, SDValue Op2);\n  MachineSDNode *getMachineNode(unsigned Opcode, const SDLoc &dl, EVT VT,\n                                SDValue Op1, SDValue Op2, SDValue Op3);\n  MachineSDNode *getMachineNode(unsigned Opcode, const SDLoc &dl, EVT VT,\n                                ArrayRef<SDValue> Ops);\n  MachineSDNode *getMachineNode(unsigned Opcode, const SDLoc &dl, EVT VT1,\n                                EVT VT2, SDValue Op1, SDValue Op2);\n  MachineSDNode *getMachineNode(unsigned Opcode, const SDLoc &dl, EVT VT1,\n                                EVT VT2, SDValue Op1, SDValue Op2, SDValue Op3);\n  MachineSDNode *getMachineNode(unsigned Opcode, const SDLoc &dl, EVT VT1,\n                                EVT VT2, ArrayRef<SDValue> Ops);\n  MachineSDNode *getMachineNode(unsigned Opcode, const SDLoc &dl, EVT VT1,\n                                EVT VT2, EVT VT3, SDValue Op1, SDValue Op2);\n  MachineSDNode *getMachineNode(unsigned Opcode, const SDLoc &dl, EVT VT1,\n                                EVT VT2, EVT VT3, SDValue Op1, SDValue Op2,\n                                SDValue Op3);\n  MachineSDNode *getMachineNode(unsigned Opcode, const SDLoc &dl, EVT VT1,\n                                EVT VT2, EVT VT3, ArrayRef<SDValue> Ops);\n  MachineSDNode *getMachineNode(unsigned Opcode, const SDLoc &dl,\n                                ArrayRef<EVT> ResultTys, ArrayRef<SDValue> Ops);\n  MachineSDNode *getMachineNode(unsigned Opcode, const SDLoc &dl, SDVTList VTs,\n                                ArrayRef<SDValue> Ops);\n\n  /// A convenience function for creating TargetInstrInfo::EXTRACT_SUBREG nodes.\n  SDValue getTargetExtractSubreg(int SRIdx, const SDLoc &DL, EVT VT,\n                                 SDValue Operand);\n\n  /// A convenience function for creating TargetInstrInfo::INSERT_SUBREG nodes.\n  SDValue getTargetInsertSubreg(int SRIdx, const SDLoc &DL, EVT VT,\n                                SDValue Operand, SDValue Subreg);\n\n  /// Get the specified node if it's already available, or else return NULL.\n  SDNode *getNodeIfExists(unsigned Opcode, SDVTList VTList,\n                          ArrayRef<SDValue> Ops, const SDNodeFlags Flags);\n  SDNode *getNodeIfExists(unsigned Opcode, SDVTList VTList,\n                          ArrayRef<SDValue> Ops);\n\n  /// Check if a node exists without modifying its flags.\n  bool doesNodeExist(unsigned Opcode, SDVTList VTList, ArrayRef<SDValue> Ops);\n\n  /// Creates a SDDbgValue node.\n  SDDbgValue *getDbgValue(DIVariable *Var, DIExpression *Expr, SDNode *N,\n                          unsigned R, bool IsIndirect, const DebugLoc &DL,\n                          unsigned O);\n\n  /// Creates a constant SDDbgValue node.\n  SDDbgValue *getConstantDbgValue(DIVariable *Var, DIExpression *Expr,\n                                  const Value *C, const DebugLoc &DL,\n                                  unsigned O);\n\n  /// Creates a FrameIndex SDDbgValue node.\n  SDDbgValue *getFrameIndexDbgValue(DIVariable *Var, DIExpression *Expr,\n                                    unsigned FI, bool IsIndirect,\n                                    const DebugLoc &DL, unsigned O);\n\n  /// Creates a FrameIndex SDDbgValue node.\n  SDDbgValue *getFrameIndexDbgValue(DIVariable *Var, DIExpression *Expr,\n                                    unsigned FI,\n                                    ArrayRef<SDNode *> Dependencies,\n                                    bool IsIndirect, const DebugLoc &DL,\n                                    unsigned O);\n\n  /// Creates a VReg SDDbgValue node.\n  SDDbgValue *getVRegDbgValue(DIVariable *Var, DIExpression *Expr,\n                              unsigned VReg, bool IsIndirect,\n                              const DebugLoc &DL, unsigned O);\n\n  /// Creates a SDDbgValue node from a list of locations.\n  SDDbgValue *getDbgValueList(DIVariable *Var, DIExpression *Expr,\n                              ArrayRef<SDDbgOperand> Locs,\n                              ArrayRef<SDNode *> Dependencies, bool IsIndirect,\n                              const DebugLoc &DL, unsigned O, bool IsVariadic);\n\n  /// Creates a SDDbgLabel node.\n  SDDbgLabel *getDbgLabel(DILabel *Label, const DebugLoc &DL, unsigned O);\n\n  /// Transfer debug values from one node to another, while optionally\n  /// generating fragment expressions for split-up values. If \\p InvalidateDbg\n  /// is set, debug values are invalidated after they are transferred.\n  void transferDbgValues(SDValue From, SDValue To, unsigned OffsetInBits = 0,\n                         unsigned SizeInBits = 0, bool InvalidateDbg = true);\n\n  /// Remove the specified node from the system. If any of its\n  /// operands then becomes dead, remove them as well. Inform UpdateListener\n  /// for each node deleted.\n  void RemoveDeadNode(SDNode *N);\n\n  /// This method deletes the unreachable nodes in the\n  /// given list, and any nodes that become unreachable as a result.\n  void RemoveDeadNodes(SmallVectorImpl<SDNode *> &DeadNodes);\n\n  /// Modify anything using 'From' to use 'To' instead.\n  /// This can cause recursive merging of nodes in the DAG.  Use the first\n  /// version if 'From' is known to have a single result, use the second\n  /// if you have two nodes with identical results (or if 'To' has a superset\n  /// of the results of 'From'), use the third otherwise.\n  ///\n  /// These methods all take an optional UpdateListener, which (if not null) is\n  /// informed about nodes that are deleted and modified due to recursive\n  /// changes in the dag.\n  ///\n  /// These functions only replace all existing uses. It's possible that as\n  /// these replacements are being performed, CSE may cause the From node\n  /// to be given new uses. These new uses of From are left in place, and\n  /// not automatically transferred to To.\n  ///\n  void ReplaceAllUsesWith(SDValue From, SDValue To);\n  void ReplaceAllUsesWith(SDNode *From, SDNode *To);\n  void ReplaceAllUsesWith(SDNode *From, const SDValue *To);\n\n  /// Replace any uses of From with To, leaving\n  /// uses of other values produced by From.getNode() alone.\n  void ReplaceAllUsesOfValueWith(SDValue From, SDValue To);\n\n  /// Like ReplaceAllUsesOfValueWith, but for multiple values at once.\n  /// This correctly handles the case where\n  /// there is an overlap between the From values and the To values.\n  void ReplaceAllUsesOfValuesWith(const SDValue *From, const SDValue *To,\n                                  unsigned Num);\n\n  /// If an existing load has uses of its chain, create a token factor node with\n  /// that chain and the new memory node's chain and update users of the old\n  /// chain to the token factor. This ensures that the new memory node will have\n  /// the same relative memory dependency position as the old load. Returns the\n  /// new merged load chain.\n  SDValue makeEquivalentMemoryOrdering(SDValue OldChain, SDValue NewMemOpChain);\n\n  /// If an existing load has uses of its chain, create a token factor node with\n  /// that chain and the new memory node's chain and update users of the old\n  /// chain to the token factor. This ensures that the new memory node will have\n  /// the same relative memory dependency position as the old load. Returns the\n  /// new merged load chain.\n  SDValue makeEquivalentMemoryOrdering(LoadSDNode *OldLoad, SDValue NewMemOp);\n\n  /// Topological-sort the AllNodes list and a\n  /// assign a unique node id for each node in the DAG based on their\n  /// topological order. Returns the number of nodes.\n  unsigned AssignTopologicalOrder();\n\n  /// Move node N in the AllNodes list to be immediately\n  /// before the given iterator Position. This may be used to update the\n  /// topological ordering when the list of nodes is modified.\n  void RepositionNode(allnodes_iterator Position, SDNode *N) {\n    AllNodes.insert(Position, AllNodes.remove(N));\n  }\n\n  /// Returns an APFloat semantics tag appropriate for the given type. If VT is\n  /// a vector type, the element semantics are returned.\n  static const fltSemantics &EVTToAPFloatSemantics(EVT VT) {\n    switch (VT.getScalarType().getSimpleVT().SimpleTy) {\n    default: llvm_unreachable(\"Unknown FP format\");\n    case MVT::f16:     return APFloat::IEEEhalf();\n    case MVT::bf16:    return APFloat::BFloat();\n    case MVT::f32:     return APFloat::IEEEsingle();\n    case MVT::f64:     return APFloat::IEEEdouble();\n    case MVT::f80:     return APFloat::x87DoubleExtended();\n    case MVT::f128:    return APFloat::IEEEquad();\n    case MVT::ppcf128: return APFloat::PPCDoubleDouble();\n    }\n  }\n\n  /// Add a dbg_value SDNode. If SD is non-null that means the\n  /// value is produced by SD.\n  void AddDbgValue(SDDbgValue *DB, bool isParameter);\n\n  /// Add a dbg_label SDNode.\n  void AddDbgLabel(SDDbgLabel *DB);\n\n  /// Get the debug values which reference the given SDNode.\n  ArrayRef<SDDbgValue*> GetDbgValues(const SDNode* SD) const {\n    return DbgInfo->getSDDbgValues(SD);\n  }\n\npublic:\n  /// Return true if there are any SDDbgValue nodes associated\n  /// with this SelectionDAG.\n  bool hasDebugValues() const { return !DbgInfo->empty(); }\n\n  SDDbgInfo::DbgIterator DbgBegin() const { return DbgInfo->DbgBegin(); }\n  SDDbgInfo::DbgIterator DbgEnd() const  { return DbgInfo->DbgEnd(); }\n\n  SDDbgInfo::DbgIterator ByvalParmDbgBegin() const {\n    return DbgInfo->ByvalParmDbgBegin();\n  }\n  SDDbgInfo::DbgIterator ByvalParmDbgEnd() const {\n    return DbgInfo->ByvalParmDbgEnd();\n  }\n\n  SDDbgInfo::DbgLabelIterator DbgLabelBegin() const {\n    return DbgInfo->DbgLabelBegin();\n  }\n  SDDbgInfo::DbgLabelIterator DbgLabelEnd() const {\n    return DbgInfo->DbgLabelEnd();\n  }\n\n  /// To be invoked on an SDNode that is slated to be erased. This\n  /// function mirrors \\c llvm::salvageDebugInfo.\n  void salvageDebugInfo(SDNode &N);\n\n  void dump() const;\n\n  /// In most cases this function returns the ABI alignment for a given type,\n  /// except for illegal vector types where the alignment exceeds that of the\n  /// stack. In such cases we attempt to break the vector down to a legal type\n  /// and return the ABI alignment for that instead.\n  Align getReducedAlign(EVT VT, bool UseABI);\n\n  /// Create a stack temporary based on the size in bytes and the alignment\n  SDValue CreateStackTemporary(TypeSize Bytes, Align Alignment);\n\n  /// Create a stack temporary, suitable for holding the specified value type.\n  /// If minAlign is specified, the slot size will have at least that alignment.\n  SDValue CreateStackTemporary(EVT VT, unsigned minAlign = 1);\n\n  /// Create a stack temporary suitable for holding either of the specified\n  /// value types.\n  SDValue CreateStackTemporary(EVT VT1, EVT VT2);\n\n  SDValue FoldSymbolOffset(unsigned Opcode, EVT VT,\n                           const GlobalAddressSDNode *GA,\n                           const SDNode *N2);\n\n  SDValue FoldConstantArithmetic(unsigned Opcode, const SDLoc &DL, EVT VT,\n                                 ArrayRef<SDValue> Ops);\n\n  SDValue FoldConstantVectorArithmetic(unsigned Opcode, const SDLoc &DL, EVT VT,\n                                       ArrayRef<SDValue> Ops,\n                                       const SDNodeFlags Flags = SDNodeFlags());\n\n  /// Fold floating-point operations with 2 operands when both operands are\n  /// constants and/or undefined.\n  SDValue foldConstantFPMath(unsigned Opcode, const SDLoc &DL, EVT VT,\n                             SDValue N1, SDValue N2);\n\n  /// Constant fold a setcc to true or false.\n  SDValue FoldSetCC(EVT VT, SDValue N1, SDValue N2, ISD::CondCode Cond,\n                    const SDLoc &dl);\n\n  /// See if the specified operand can be simplified with the knowledge that\n  /// only the bits specified by DemandedBits are used.  If so, return the\n  /// simpler operand, otherwise return a null SDValue.\n  ///\n  /// (This exists alongside SimplifyDemandedBits because GetDemandedBits can\n  /// simplify nodes with multiple uses more aggressively.)\n  SDValue GetDemandedBits(SDValue V, const APInt &DemandedBits);\n\n  /// See if the specified operand can be simplified with the knowledge that\n  /// only the bits specified by DemandedBits are used in the elements specified\n  /// by DemandedElts.  If so, return the simpler operand, otherwise return a\n  /// null SDValue.\n  ///\n  /// (This exists alongside SimplifyDemandedBits because GetDemandedBits can\n  /// simplify nodes with multiple uses more aggressively.)\n  SDValue GetDemandedBits(SDValue V, const APInt &DemandedBits,\n                          const APInt &DemandedElts);\n\n  /// Return true if the sign bit of Op is known to be zero.\n  /// We use this predicate to simplify operations downstream.\n  bool SignBitIsZero(SDValue Op, unsigned Depth = 0) const;\n\n  /// Return true if 'Op & Mask' is known to be zero.  We\n  /// use this predicate to simplify operations downstream.  Op and Mask are\n  /// known to be the same type.\n  bool MaskedValueIsZero(SDValue Op, const APInt &Mask,\n                         unsigned Depth = 0) const;\n\n  /// Return true if 'Op & Mask' is known to be zero in DemandedElts.  We\n  /// use this predicate to simplify operations downstream.  Op and Mask are\n  /// known to be the same type.\n  bool MaskedValueIsZero(SDValue Op, const APInt &Mask,\n                         const APInt &DemandedElts, unsigned Depth = 0) const;\n\n  /// Return true if '(Op & Mask) == Mask'.\n  /// Op and Mask are known to be the same type.\n  bool MaskedValueIsAllOnes(SDValue Op, const APInt &Mask,\n                            unsigned Depth = 0) const;\n\n  /// Determine which bits of Op are known to be either zero or one and return\n  /// them in Known. For vectors, the known bits are those that are shared by\n  /// every vector element.\n  /// Targets can implement the computeKnownBitsForTargetNode method in the\n  /// TargetLowering class to allow target nodes to be understood.\n  KnownBits computeKnownBits(SDValue Op, unsigned Depth = 0) const;\n\n  /// Determine which bits of Op are known to be either zero or one and return\n  /// them in Known. The DemandedElts argument allows us to only collect the\n  /// known bits that are shared by the requested vector elements.\n  /// Targets can implement the computeKnownBitsForTargetNode method in the\n  /// TargetLowering class to allow target nodes to be understood.\n  KnownBits computeKnownBits(SDValue Op, const APInt &DemandedElts,\n                             unsigned Depth = 0) const;\n\n  /// Used to represent the possible overflow behavior of an operation.\n  /// Never: the operation cannot overflow.\n  /// Always: the operation will always overflow.\n  /// Sometime: the operation may or may not overflow.\n  enum OverflowKind {\n    OFK_Never,\n    OFK_Sometime,\n    OFK_Always,\n  };\n\n  /// Determine if the result of the addition of 2 node can overflow.\n  OverflowKind computeOverflowKind(SDValue N0, SDValue N1) const;\n\n  /// Test if the given value is known to have exactly one bit set. This differs\n  /// from computeKnownBits in that it doesn't necessarily determine which bit\n  /// is set.\n  bool isKnownToBeAPowerOfTwo(SDValue Val) const;\n\n  /// Return the number of times the sign bit of the register is replicated into\n  /// the other bits. We know that at least 1 bit is always equal to the sign\n  /// bit (itself), but other cases can give us information. For example,\n  /// immediately after an \"SRA X, 2\", we know that the top 3 bits are all equal\n  /// to each other, so we return 3. Targets can implement the\n  /// ComputeNumSignBitsForTarget method in the TargetLowering class to allow\n  /// target nodes to be understood.\n  unsigned ComputeNumSignBits(SDValue Op, unsigned Depth = 0) const;\n\n  /// Return the number of times the sign bit of the register is replicated into\n  /// the other bits. We know that at least 1 bit is always equal to the sign\n  /// bit (itself), but other cases can give us information. For example,\n  /// immediately after an \"SRA X, 2\", we know that the top 3 bits are all equal\n  /// to each other, so we return 3. The DemandedElts argument allows\n  /// us to only collect the minimum sign bits of the requested vector elements.\n  /// Targets can implement the ComputeNumSignBitsForTarget method in the\n  /// TargetLowering class to allow target nodes to be understood.\n  unsigned ComputeNumSignBits(SDValue Op, const APInt &DemandedElts,\n                              unsigned Depth = 0) const;\n\n  /// Return true if the specified operand is an ISD::ADD with a ConstantSDNode\n  /// on the right-hand side, or if it is an ISD::OR with a ConstantSDNode that\n  /// is guaranteed to have the same semantics as an ADD. This handles the\n  /// equivalence:\n  ///     X|Cst == X+Cst iff X&Cst = 0.\n  bool isBaseWithConstantOffset(SDValue Op) const;\n\n  /// Test whether the given SDValue is known to never be NaN. If \\p SNaN is\n  /// true, returns if \\p Op is known to never be a signaling NaN (it may still\n  /// be a qNaN).\n  bool isKnownNeverNaN(SDValue Op, bool SNaN = false, unsigned Depth = 0) const;\n\n  /// \\returns true if \\p Op is known to never be a signaling NaN.\n  bool isKnownNeverSNaN(SDValue Op, unsigned Depth = 0) const {\n    return isKnownNeverNaN(Op, true, Depth);\n  }\n\n  /// Test whether the given floating point SDValue is known to never be\n  /// positive or negative zero.\n  bool isKnownNeverZeroFloat(SDValue Op) const;\n\n  /// Test whether the given SDValue is known to contain non-zero value(s).\n  bool isKnownNeverZero(SDValue Op) const;\n\n  /// Test whether two SDValues are known to compare equal. This\n  /// is true if they are the same value, or if one is negative zero and the\n  /// other positive zero.\n  bool isEqualTo(SDValue A, SDValue B) const;\n\n  /// Return true if A and B have no common bits set. As an example, this can\n  /// allow an 'add' to be transformed into an 'or'.\n  bool haveNoCommonBitsSet(SDValue A, SDValue B) const;\n\n  /// Test whether \\p V has a splatted value for all the demanded elements.\n  ///\n  /// On success \\p UndefElts will indicate the elements that have UNDEF\n  /// values instead of the splat value, this is only guaranteed to be correct\n  /// for \\p DemandedElts.\n  ///\n  /// NOTE: The function will return true for a demanded splat of UNDEF values.\n  bool isSplatValue(SDValue V, const APInt &DemandedElts, APInt &UndefElts,\n                    unsigned Depth = 0);\n\n  /// Test whether \\p V has a splatted value.\n  bool isSplatValue(SDValue V, bool AllowUndefs = false);\n\n  /// If V is a splatted value, return the source vector and its splat index.\n  SDValue getSplatSourceVector(SDValue V, int &SplatIndex);\n\n  /// If V is a splat vector, return its scalar source operand by extracting\n  /// that element from the source vector.\n  SDValue getSplatValue(SDValue V);\n\n  /// If a SHL/SRA/SRL node \\p V has a constant or splat constant shift amount\n  /// that is less than the element bit-width of the shift node, return it.\n  const APInt *getValidShiftAmountConstant(SDValue V,\n                                           const APInt &DemandedElts) const;\n\n  /// If a SHL/SRA/SRL node \\p V has constant shift amounts that are all less\n  /// than the element bit-width of the shift node, return the minimum value.\n  const APInt *\n  getValidMinimumShiftAmountConstant(SDValue V,\n                                     const APInt &DemandedElts) const;\n\n  /// If a SHL/SRA/SRL node \\p V has constant shift amounts that are all less\n  /// than the element bit-width of the shift node, return the maximum value.\n  const APInt *\n  getValidMaximumShiftAmountConstant(SDValue V,\n                                     const APInt &DemandedElts) const;\n\n  /// Match a binop + shuffle pyramid that represents a horizontal reduction\n  /// over the elements of a vector starting from the EXTRACT_VECTOR_ELT node /p\n  /// Extract. The reduction must use one of the opcodes listed in /p\n  /// CandidateBinOps and on success /p BinOp will contain the matching opcode.\n  /// Returns the vector that is being reduced on, or SDValue() if a reduction\n  /// was not matched. If \\p AllowPartials is set then in the case of a\n  /// reduction pattern that only matches the first few stages, the extracted\n  /// subvector of the start of the reduction is returned.\n  SDValue matchBinOpReduction(SDNode *Extract, ISD::NodeType &BinOp,\n                              ArrayRef<ISD::NodeType> CandidateBinOps,\n                              bool AllowPartials = false);\n\n  /// Utility function used by legalize and lowering to\n  /// \"unroll\" a vector operation by splitting out the scalars and operating\n  /// on each element individually.  If the ResNE is 0, fully unroll the vector\n  /// op. If ResNE is less than the width of the vector op, unroll up to ResNE.\n  /// If the  ResNE is greater than the width of the vector op, unroll the\n  /// vector op and fill the end of the resulting vector with UNDEFS.\n  SDValue UnrollVectorOp(SDNode *N, unsigned ResNE = 0);\n\n  /// Like UnrollVectorOp(), but for the [US](ADD|SUB|MUL)O family of opcodes.\n  /// This is a separate function because those opcodes have two results.\n  std::pair<SDValue, SDValue> UnrollVectorOverflowOp(SDNode *N,\n                                                     unsigned ResNE = 0);\n\n  /// Return true if loads are next to each other and can be\n  /// merged. Check that both are nonvolatile and if LD is loading\n  /// 'Bytes' bytes from a location that is 'Dist' units away from the\n  /// location that the 'Base' load is loading from.\n  bool areNonVolatileConsecutiveLoads(LoadSDNode *LD, LoadSDNode *Base,\n                                      unsigned Bytes, int Dist) const;\n\n  /// Infer alignment of a load / store address. Return None if it cannot be\n  /// inferred.\n  MaybeAlign InferPtrAlign(SDValue Ptr) const;\n\n  LLVM_ATTRIBUTE_DEPRECATED(inline unsigned InferPtrAlignment(SDValue Ptr)\n                                const,\n                            \"Use InferPtrAlign instead\") {\n    if (auto A = InferPtrAlign(Ptr))\n      return A->value();\n    return 0;\n  }\n\n  /// Compute the VTs needed for the low/hi parts of a type\n  /// which is split (or expanded) into two not necessarily identical pieces.\n  std::pair<EVT, EVT> GetSplitDestVTs(const EVT &VT) const;\n\n  /// Compute the VTs needed for the low/hi parts of a type, dependent on an\n  /// enveloping VT that has been split into two identical pieces. Sets the\n  /// HisIsEmpty flag when hi type has zero storage size.\n  std::pair<EVT, EVT> GetDependentSplitDestVTs(const EVT &VT, const EVT &EnvVT,\n                                               bool *HiIsEmpty) const;\n\n  /// Split the vector with EXTRACT_SUBVECTOR using the provides\n  /// VTs and return the low/high part.\n  std::pair<SDValue, SDValue> SplitVector(const SDValue &N, const SDLoc &DL,\n                                          const EVT &LoVT, const EVT &HiVT);\n\n  /// Split the vector with EXTRACT_SUBVECTOR and return the low/high part.\n  std::pair<SDValue, SDValue> SplitVector(const SDValue &N, const SDLoc &DL) {\n    EVT LoVT, HiVT;\n    std::tie(LoVT, HiVT) = GetSplitDestVTs(N.getValueType());\n    return SplitVector(N, DL, LoVT, HiVT);\n  }\n\n  /// Split the node's operand with EXTRACT_SUBVECTOR and\n  /// return the low/high part.\n  std::pair<SDValue, SDValue> SplitVectorOperand(const SDNode *N, unsigned OpNo)\n  {\n    return SplitVector(N->getOperand(OpNo), SDLoc(N));\n  }\n\n  /// Widen the vector up to the next power of two using INSERT_SUBVECTOR.\n  SDValue WidenVector(const SDValue &N, const SDLoc &DL);\n\n  /// Append the extracted elements from Start to Count out of the vector Op in\n  /// Args. If Count is 0, all of the elements will be extracted. The extracted\n  /// elements will have type EVT if it is provided, and otherwise their type\n  /// will be Op's element type.\n  void ExtractVectorElements(SDValue Op, SmallVectorImpl<SDValue> &Args,\n                             unsigned Start = 0, unsigned Count = 0,\n                             EVT EltVT = EVT());\n\n  /// Compute the default alignment value for the given type.\n  Align getEVTAlign(EVT MemoryVT) const;\n  /// Compute the default alignment value for the given type.\n  /// FIXME: Remove once transition to Align is over.\n  inline unsigned getEVTAlignment(EVT MemoryVT) const {\n    return getEVTAlign(MemoryVT).value();\n  }\n\n  /// Test whether the given value is a constant int or similar node.\n  SDNode *isConstantIntBuildVectorOrConstantInt(SDValue N) const;\n\n  /// Test whether the given value is a constant FP or similar node.\n  SDNode *isConstantFPBuildVectorOrConstantFP(SDValue N) const ;\n\n  /// \\returns true if \\p N is any kind of constant or build_vector of\n  /// constants, int or float. If a vector, it may not necessarily be a splat.\n  inline bool isConstantValueOfAnyType(SDValue N) const {\n    return isConstantIntBuildVectorOrConstantInt(N) ||\n           isConstantFPBuildVectorOrConstantFP(N);\n  }\n\n  void addCallSiteInfo(const SDNode *CallNode, CallSiteInfoImpl &&CallInfo) {\n    SDCallSiteDbgInfo[CallNode].CSInfo = std::move(CallInfo);\n  }\n\n  CallSiteInfo getSDCallSiteInfo(const SDNode *CallNode) {\n    auto I = SDCallSiteDbgInfo.find(CallNode);\n    if (I != SDCallSiteDbgInfo.end())\n      return std::move(I->second).CSInfo;\n    return CallSiteInfo();\n  }\n\n  void addHeapAllocSite(const SDNode *Node, MDNode *MD) {\n    SDCallSiteDbgInfo[Node].HeapAllocSite = MD;\n  }\n\n  /// Return the HeapAllocSite type associated with the SDNode, if it exists.\n  MDNode *getHeapAllocSite(const SDNode *Node) {\n    auto It = SDCallSiteDbgInfo.find(Node);\n    if (It == SDCallSiteDbgInfo.end())\n      return nullptr;\n    return It->second.HeapAllocSite;\n  }\n\n  void addNoMergeSiteInfo(const SDNode *Node, bool NoMerge) {\n    if (NoMerge)\n      SDCallSiteDbgInfo[Node].NoMerge = NoMerge;\n  }\n\n  bool getNoMergeSiteInfo(const SDNode *Node) {\n    auto I = SDCallSiteDbgInfo.find(Node);\n    if (I == SDCallSiteDbgInfo.end())\n      return false;\n    return I->second.NoMerge;\n  }\n\n  /// Return the current function's default denormal handling kind for the given\n  /// floating point type.\n  DenormalMode getDenormalMode(EVT VT) const {\n    return MF->getDenormalMode(EVTToAPFloatSemantics(VT));\n  }\n\n  bool shouldOptForSize() const;\n\n  /// Get the (commutative) neutral element for the given opcode, if it exists.\n  SDValue getNeutralElement(unsigned Opcode, const SDLoc &DL, EVT VT,\n                            SDNodeFlags Flags);\n\nprivate:\n  void InsertNode(SDNode *N);\n  bool RemoveNodeFromCSEMaps(SDNode *N);\n  void AddModifiedNodeToCSEMaps(SDNode *N);\n  SDNode *FindModifiedNodeSlot(SDNode *N, SDValue Op, void *&InsertPos);\n  SDNode *FindModifiedNodeSlot(SDNode *N, SDValue Op1, SDValue Op2,\n                               void *&InsertPos);\n  SDNode *FindModifiedNodeSlot(SDNode *N, ArrayRef<SDValue> Ops,\n                               void *&InsertPos);\n  SDNode *UpdateSDLocOnMergeSDNode(SDNode *N, const SDLoc &loc);\n\n  void DeleteNodeNotInCSEMaps(SDNode *N);\n  void DeallocateNode(SDNode *N);\n\n  void allnodes_clear();\n\n  /// Look up the node specified by ID in CSEMap.  If it exists, return it.  If\n  /// not, return the insertion token that will make insertion faster.  This\n  /// overload is for nodes other than Constant or ConstantFP, use the other one\n  /// for those.\n  SDNode *FindNodeOrInsertPos(const FoldingSetNodeID &ID, void *&InsertPos);\n\n  /// Look up the node specified by ID in CSEMap.  If it exists, return it.  If\n  /// not, return the insertion token that will make insertion faster.  Performs\n  /// additional processing for constant nodes.\n  SDNode *FindNodeOrInsertPos(const FoldingSetNodeID &ID, const SDLoc &DL,\n                              void *&InsertPos);\n\n  /// List of non-single value types.\n  FoldingSet<SDVTListNode> VTListMap;\n\n  /// Maps to auto-CSE operations.\n  std::vector<CondCodeSDNode*> CondCodeNodes;\n\n  std::vector<SDNode*> ValueTypeNodes;\n  std::map<EVT, SDNode*, EVT::compareRawBits> ExtendedValueTypeNodes;\n  StringMap<SDNode*> ExternalSymbols;\n\n  std::map<std::pair<std::string, unsigned>, SDNode *> TargetExternalSymbols;\n  DenseMap<MCSymbol *, SDNode *> MCSymbols;\n\n  FlagInserter *Inserter = nullptr;\n};\n\ntemplate <> struct GraphTraits<SelectionDAG*> : public GraphTraits<SDNode*> {\n  using nodes_iterator = pointer_iterator<SelectionDAG::allnodes_iterator>;\n\n  static nodes_iterator nodes_begin(SelectionDAG *G) {\n    return nodes_iterator(G->allnodes_begin());\n  }\n\n  static nodes_iterator nodes_end(SelectionDAG *G) {\n    return nodes_iterator(G->allnodes_end());\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_CODEGEN_SELECTIONDAG_H\n"}, "31": {"id": 31, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h", "content": "//===- llvm/CodeGen/SelectionDAGNodes.h - SelectionDAG Nodes ----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file declares the SDNode class and derived classes, which are used to\n// represent the nodes and operations present in a SelectionDAG.  These nodes\n// and operations are machine code level operations, with some similarities to\n// the GCC RTL representation.\n//\n// Clients should include the SelectionDAG.h file instead of this file directly.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CODEGEN_SELECTIONDAGNODES_H\n#define LLVM_CODEGEN_SELECTIONDAGNODES_H\n\n#include \"llvm/ADT/APFloat.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/BitVector.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/GraphTraits.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/ilist_node.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/CodeGen/ISDOpcodes.h\"\n#include \"llvm/CodeGen/MachineMemOperand.h\"\n#include \"llvm/CodeGen/Register.h\"\n#include \"llvm/CodeGen/ValueTypes.h\"\n#include \"llvm/IR/Constants.h\"\n#include \"llvm/IR/DebugLoc.h\"\n#include \"llvm/IR/Instruction.h\"\n#include \"llvm/IR/Instructions.h\"\n#include \"llvm/IR/Metadata.h\"\n#include \"llvm/IR/Operator.h\"\n#include \"llvm/Support/AlignOf.h\"\n#include \"llvm/Support/AtomicOrdering.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/MachineValueType.h\"\n#include \"llvm/Support/TypeSize.h\"\n#include <algorithm>\n#include <cassert>\n#include <climits>\n#include <cstddef>\n#include <cstdint>\n#include <cstring>\n#include <iterator>\n#include <string>\n#include <tuple>\n\nnamespace llvm {\n\nclass APInt;\nclass Constant;\ntemplate <typename T> struct DenseMapInfo;\nclass GlobalValue;\nclass MachineBasicBlock;\nclass MachineConstantPoolValue;\nclass MCSymbol;\nclass raw_ostream;\nclass SDNode;\nclass SelectionDAG;\nclass Type;\nclass Value;\n\nvoid checkForCycles(const SDNode *N, const SelectionDAG *DAG = nullptr,\n                    bool force = false);\n\n/// This represents a list of ValueType's that has been intern'd by\n/// a SelectionDAG.  Instances of this simple value class are returned by\n/// SelectionDAG::getVTList(...).\n///\nstruct SDVTList {\n  const EVT *VTs;\n  unsigned int NumVTs;\n};\n\nnamespace ISD {\n\n  /// Node predicates\n\n/// If N is a BUILD_VECTOR or SPLAT_VECTOR node whose elements are all the\n/// same constant or undefined, return true and return the constant value in\n/// \\p SplatValue.\nbool isConstantSplatVector(const SDNode *N, APInt &SplatValue);\n\n/// Return true if the specified node is a BUILD_VECTOR or SPLAT_VECTOR where\n/// all of the elements are ~0 or undef. If \\p BuildVectorOnly is set to\n/// true, it only checks BUILD_VECTOR.\nbool isConstantSplatVectorAllOnes(const SDNode *N,\n                                  bool BuildVectorOnly = false);\n\n/// Return true if the specified node is a BUILD_VECTOR or SPLAT_VECTOR where\n/// all of the elements are 0 or undef. If \\p BuildVectorOnly is set to true, it\n/// only checks BUILD_VECTOR.\nbool isConstantSplatVectorAllZeros(const SDNode *N,\n                                   bool BuildVectorOnly = false);\n\n/// Return true if the specified node is a BUILD_VECTOR where all of the\n/// elements are ~0 or undef.\nbool isBuildVectorAllOnes(const SDNode *N);\n\n/// Return true if the specified node is a BUILD_VECTOR where all of the\n/// elements are 0 or undef.\nbool isBuildVectorAllZeros(const SDNode *N);\n\n/// Return true if the specified node is a BUILD_VECTOR node of all\n/// ConstantSDNode or undef.\nbool isBuildVectorOfConstantSDNodes(const SDNode *N);\n\n/// Return true if the specified node is a BUILD_VECTOR node of all\n/// ConstantFPSDNode or undef.\nbool isBuildVectorOfConstantFPSDNodes(const SDNode *N);\n\n/// Return true if the node has at least one operand and all operands of the\n/// specified node are ISD::UNDEF.\nbool allOperandsUndef(const SDNode *N);\n\n} // end namespace ISD\n\n//===----------------------------------------------------------------------===//\n/// Unlike LLVM values, Selection DAG nodes may return multiple\n/// values as the result of a computation.  Many nodes return multiple values,\n/// from loads (which define a token and a return value) to ADDC (which returns\n/// a result and a carry value), to calls (which may return an arbitrary number\n/// of values).\n///\n/// As such, each use of a SelectionDAG computation must indicate the node that\n/// computes it as well as which return value to use from that node.  This pair\n/// of information is represented with the SDValue value type.\n///\nclass SDValue {\n  friend struct DenseMapInfo<SDValue>;\n\n  SDNode *Node = nullptr; // The node defining the value we are using.\n  unsigned ResNo = 0;     // Which return value of the node we are using.\n\npublic:\n  SDValue() = default;\n  SDValue(SDNode *node, unsigned resno);\n\n  /// get the index which selects a specific result in the SDNode\n  unsigned getResNo() const { return ResNo; }\n\n  /// get the SDNode which holds the desired result\n  SDNode *getNode() const { return Node; }\n\n  /// set the SDNode\n  void setNode(SDNode *N) { Node = N; }\n\n  inline SDNode *operator->() const { return Node; }\n\n  bool operator==(const SDValue &O) const {\n    return Node == O.Node && ResNo == O.ResNo;\n  }\n  bool operator!=(const SDValue &O) const {\n    return !operator==(O);\n  }\n  bool operator<(const SDValue &O) const {\n    return std::tie(Node, ResNo) < std::tie(O.Node, O.ResNo);\n  }\n  explicit operator bool() const {\n    return Node != nullptr;\n  }\n\n  SDValue getValue(unsigned R) const {\n    return SDValue(Node, R);\n  }\n\n  /// Return true if this node is an operand of N.\n  bool isOperandOf(const SDNode *N) const;\n\n  /// Return the ValueType of the referenced return value.\n  inline EVT getValueType() const;\n\n  /// Return the simple ValueType of the referenced return value.\n  MVT getSimpleValueType() const {\n    return getValueType().getSimpleVT();\n  }\n\n  /// Returns the size of the value in bits.\n  ///\n  /// If the value type is a scalable vector type, the scalable property will\n  /// be set and the runtime size will be a positive integer multiple of the\n  /// base size.\n  TypeSize getValueSizeInBits() const {\n    return getValueType().getSizeInBits();\n  }\n\n  uint64_t getScalarValueSizeInBits() const {\n    return getValueType().getScalarType().getFixedSizeInBits();\n  }\n\n  // Forwarding methods - These forward to the corresponding methods in SDNode.\n  inline unsigned getOpcode() const;\n  inline unsigned getNumOperands() const;\n  inline const SDValue &getOperand(unsigned i) const;\n  inline uint64_t getConstantOperandVal(unsigned i) const;\n  inline const APInt &getConstantOperandAPInt(unsigned i) const;\n  inline bool isTargetMemoryOpcode() const;\n  inline bool isTargetOpcode() const;\n  inline bool isMachineOpcode() const;\n  inline bool isUndef() const;\n  inline unsigned getMachineOpcode() const;\n  inline const DebugLoc &getDebugLoc() const;\n  inline void dump() const;\n  inline void dump(const SelectionDAG *G) const;\n  inline void dumpr() const;\n  inline void dumpr(const SelectionDAG *G) const;\n\n  /// Return true if this operand (which must be a chain) reaches the\n  /// specified operand without crossing any side-effecting instructions.\n  /// In practice, this looks through token factors and non-volatile loads.\n  /// In order to remain efficient, this only\n  /// looks a couple of nodes in, it does not do an exhaustive search.\n  bool reachesChainWithoutSideEffects(SDValue Dest,\n                                      unsigned Depth = 2) const;\n\n  /// Return true if there are no nodes using value ResNo of Node.\n  inline bool use_empty() const;\n\n  /// Return true if there is exactly one node using value ResNo of Node.\n  inline bool hasOneUse() const;\n};\n\ntemplate<> struct DenseMapInfo<SDValue> {\n  static inline SDValue getEmptyKey() {\n    SDValue V;\n    V.ResNo = -1U;\n    return V;\n  }\n\n  static inline SDValue getTombstoneKey() {\n    SDValue V;\n    V.ResNo = -2U;\n    return V;\n  }\n\n  static unsigned getHashValue(const SDValue &Val) {\n    return ((unsigned)((uintptr_t)Val.getNode() >> 4) ^\n            (unsigned)((uintptr_t)Val.getNode() >> 9)) + Val.getResNo();\n  }\n\n  static bool isEqual(const SDValue &LHS, const SDValue &RHS) {\n    return LHS == RHS;\n  }\n};\n\n/// Allow casting operators to work directly on\n/// SDValues as if they were SDNode*'s.\ntemplate<> struct simplify_type<SDValue> {\n  using SimpleType = SDNode *;\n\n  static SimpleType getSimplifiedValue(SDValue &Val) {\n    return Val.getNode();\n  }\n};\ntemplate<> struct simplify_type<const SDValue> {\n  using SimpleType = /*const*/ SDNode *;\n\n  static SimpleType getSimplifiedValue(const SDValue &Val) {\n    return Val.getNode();\n  }\n};\n\n/// Represents a use of a SDNode. This class holds an SDValue,\n/// which records the SDNode being used and the result number, a\n/// pointer to the SDNode using the value, and Next and Prev pointers,\n/// which link together all the uses of an SDNode.\n///\nclass SDUse {\n  /// Val - The value being used.\n  SDValue Val;\n  /// User - The user of this value.\n  SDNode *User = nullptr;\n  /// Prev, Next - Pointers to the uses list of the SDNode referred by\n  /// this operand.\n  SDUse **Prev = nullptr;\n  SDUse *Next = nullptr;\n\npublic:\n  SDUse() = default;\n  SDUse(const SDUse &U) = delete;\n  SDUse &operator=(const SDUse &) = delete;\n\n  /// Normally SDUse will just implicitly convert to an SDValue that it holds.\n  operator const SDValue&() const { return Val; }\n\n  /// If implicit conversion to SDValue doesn't work, the get() method returns\n  /// the SDValue.\n  const SDValue &get() const { return Val; }\n\n  /// This returns the SDNode that contains this Use.\n  SDNode *getUser() { return User; }\n\n  /// Get the next SDUse in the use list.\n  SDUse *getNext() const { return Next; }\n\n  /// Convenience function for get().getNode().\n  SDNode *getNode() const { return Val.getNode(); }\n  /// Convenience function for get().getResNo().\n  unsigned getResNo() const { return Val.getResNo(); }\n  /// Convenience function for get().getValueType().\n  EVT getValueType() const { return Val.getValueType(); }\n\n  /// Convenience function for get().operator==\n  bool operator==(const SDValue &V) const {\n    return Val == V;\n  }\n\n  /// Convenience function for get().operator!=\n  bool operator!=(const SDValue &V) const {\n    return Val != V;\n  }\n\n  /// Convenience function for get().operator<\n  bool operator<(const SDValue &V) const {\n    return Val < V;\n  }\n\nprivate:\n  friend class SelectionDAG;\n  friend class SDNode;\n  // TODO: unfriend HandleSDNode once we fix its operand handling.\n  friend class HandleSDNode;\n\n  void setUser(SDNode *p) { User = p; }\n\n  /// Remove this use from its existing use list, assign it the\n  /// given value, and add it to the new value's node's use list.\n  inline void set(const SDValue &V);\n  /// Like set, but only supports initializing a newly-allocated\n  /// SDUse with a non-null value.\n  inline void setInitial(const SDValue &V);\n  /// Like set, but only sets the Node portion of the value,\n  /// leaving the ResNo portion unmodified.\n  inline void setNode(SDNode *N);\n\n  void addToList(SDUse **List) {\n    Next = *List;\n    if (Next) Next->Prev = &Next;\n    Prev = List;\n    *List = this;\n  }\n\n  void removeFromList() {\n    *Prev = Next;\n    if (Next) Next->Prev = Prev;\n  }\n};\n\n/// simplify_type specializations - Allow casting operators to work directly on\n/// SDValues as if they were SDNode*'s.\ntemplate<> struct simplify_type<SDUse> {\n  using SimpleType = SDNode *;\n\n  static SimpleType getSimplifiedValue(SDUse &Val) {\n    return Val.getNode();\n  }\n};\n\n/// These are IR-level optimization flags that may be propagated to SDNodes.\n/// TODO: This data structure should be shared by the IR optimizer and the\n/// the backend.\nstruct SDNodeFlags {\nprivate:\n  bool NoUnsignedWrap : 1;\n  bool NoSignedWrap : 1;\n  bool Exact : 1;\n  bool NoNaNs : 1;\n  bool NoInfs : 1;\n  bool NoSignedZeros : 1;\n  bool AllowReciprocal : 1;\n  bool AllowContract : 1;\n  bool ApproximateFuncs : 1;\n  bool AllowReassociation : 1;\n\n  // We assume instructions do not raise floating-point exceptions by default,\n  // and only those marked explicitly may do so.  We could choose to represent\n  // this via a positive \"FPExcept\" flags like on the MI level, but having a\n  // negative \"NoFPExcept\" flag here (that defaults to true) makes the flag\n  // intersection logic more straightforward.\n  bool NoFPExcept : 1;\n\npublic:\n  /// Default constructor turns off all optimization flags.\n  SDNodeFlags()\n      : NoUnsignedWrap(false), NoSignedWrap(false), Exact(false), NoNaNs(false),\n        NoInfs(false), NoSignedZeros(false), AllowReciprocal(false),\n        AllowContract(false), ApproximateFuncs(false),\n        AllowReassociation(false), NoFPExcept(false) {}\n\n  /// Propagate the fast-math-flags from an IR FPMathOperator.\n  void copyFMF(const FPMathOperator &FPMO) {\n    setNoNaNs(FPMO.hasNoNaNs());\n    setNoInfs(FPMO.hasNoInfs());\n    setNoSignedZeros(FPMO.hasNoSignedZeros());\n    setAllowReciprocal(FPMO.hasAllowReciprocal());\n    setAllowContract(FPMO.hasAllowContract());\n    setApproximateFuncs(FPMO.hasApproxFunc());\n    setAllowReassociation(FPMO.hasAllowReassoc());\n  }\n\n  // These are mutators for each flag.\n  void setNoUnsignedWrap(bool b) { NoUnsignedWrap = b; }\n  void setNoSignedWrap(bool b) { NoSignedWrap = b; }\n  void setExact(bool b) { Exact = b; }\n  void setNoNaNs(bool b) { NoNaNs = b; }\n  void setNoInfs(bool b) { NoInfs = b; }\n  void setNoSignedZeros(bool b) { NoSignedZeros = b; }\n  void setAllowReciprocal(bool b) { AllowReciprocal = b; }\n  void setAllowContract(bool b) { AllowContract = b; }\n  void setApproximateFuncs(bool b) { ApproximateFuncs = b; }\n  void setAllowReassociation(bool b) { AllowReassociation = b; }\n  void setNoFPExcept(bool b) { NoFPExcept = b; }\n\n  // These are accessors for each flag.\n  bool hasNoUnsignedWrap() const { return NoUnsignedWrap; }\n  bool hasNoSignedWrap() const { return NoSignedWrap; }\n  bool hasExact() const { return Exact; }\n  bool hasNoNaNs() const { return NoNaNs; }\n  bool hasNoInfs() const { return NoInfs; }\n  bool hasNoSignedZeros() const { return NoSignedZeros; }\n  bool hasAllowReciprocal() const { return AllowReciprocal; }\n  bool hasAllowContract() const { return AllowContract; }\n  bool hasApproximateFuncs() const { return ApproximateFuncs; }\n  bool hasAllowReassociation() const { return AllowReassociation; }\n  bool hasNoFPExcept() const { return NoFPExcept; }\n\n  /// Clear any flags in this flag set that aren't also set in Flags. All\n  /// flags will be cleared if Flags are undefined.\n  void intersectWith(const SDNodeFlags Flags) {\n    NoUnsignedWrap &= Flags.NoUnsignedWrap;\n    NoSignedWrap &= Flags.NoSignedWrap;\n    Exact &= Flags.Exact;\n    NoNaNs &= Flags.NoNaNs;\n    NoInfs &= Flags.NoInfs;\n    NoSignedZeros &= Flags.NoSignedZeros;\n    AllowReciprocal &= Flags.AllowReciprocal;\n    AllowContract &= Flags.AllowContract;\n    ApproximateFuncs &= Flags.ApproximateFuncs;\n    AllowReassociation &= Flags.AllowReassociation;\n    NoFPExcept &= Flags.NoFPExcept;\n  }\n};\n\n/// Represents one node in the SelectionDAG.\n///\nclass SDNode : public FoldingSetNode, public ilist_node<SDNode> {\nprivate:\n  /// The operation that this node performs.\n  int16_t NodeType;\n\nprotected:\n  // We define a set of mini-helper classes to help us interpret the bits in our\n  // SubclassData.  These are designed to fit within a uint16_t so they pack\n  // with NodeType.\n\n#if defined(_AIX) && (!defined(__GNUC__) || defined(__ibmxl__))\n// Except for GCC; by default, AIX compilers store bit-fields in 4-byte words\n// and give the `pack` pragma push semantics.\n#define BEGIN_TWO_BYTE_PACK() _Pragma(\"pack(2)\")\n#define END_TWO_BYTE_PACK() _Pragma(\"pack(pop)\")\n#else\n#define BEGIN_TWO_BYTE_PACK()\n#define END_TWO_BYTE_PACK()\n#endif\n\nBEGIN_TWO_BYTE_PACK()\n  class SDNodeBitfields {\n    friend class SDNode;\n    friend class MemIntrinsicSDNode;\n    friend class MemSDNode;\n    friend class SelectionDAG;\n\n    uint16_t HasDebugValue : 1;\n    uint16_t IsMemIntrinsic : 1;\n    uint16_t IsDivergent : 1;\n  };\n  enum { NumSDNodeBits = 3 };\n\n  class ConstantSDNodeBitfields {\n    friend class ConstantSDNode;\n\n    uint16_t : NumSDNodeBits;\n\n    uint16_t IsOpaque : 1;\n  };\n\n  class MemSDNodeBitfields {\n    friend class MemSDNode;\n    friend class MemIntrinsicSDNode;\n    friend class AtomicSDNode;\n\n    uint16_t : NumSDNodeBits;\n\n    uint16_t IsVolatile : 1;\n    uint16_t IsNonTemporal : 1;\n    uint16_t IsDereferenceable : 1;\n    uint16_t IsInvariant : 1;\n  };\n  enum { NumMemSDNodeBits = NumSDNodeBits + 4 };\n\n  class LSBaseSDNodeBitfields {\n    friend class LSBaseSDNode;\n    friend class MaskedLoadStoreSDNode;\n    friend class MaskedGatherScatterSDNode;\n\n    uint16_t : NumMemSDNodeBits;\n\n    // This storage is shared between disparate class hierarchies to hold an\n    // enumeration specific to the class hierarchy in use.\n    //   LSBaseSDNode => enum ISD::MemIndexedMode\n    //   MaskedLoadStoreBaseSDNode => enum ISD::MemIndexedMode\n    //   MaskedGatherScatterSDNode => enum ISD::MemIndexType\n    uint16_t AddressingMode : 3;\n  };\n  enum { NumLSBaseSDNodeBits = NumMemSDNodeBits + 3 };\n\n  class LoadSDNodeBitfields {\n    friend class LoadSDNode;\n    friend class MaskedLoadSDNode;\n    friend class MaskedGatherSDNode;\n\n    uint16_t : NumLSBaseSDNodeBits;\n\n    uint16_t ExtTy : 2; // enum ISD::LoadExtType\n    uint16_t IsExpanding : 1;\n  };\n\n  class StoreSDNodeBitfields {\n    friend class StoreSDNode;\n    friend class MaskedStoreSDNode;\n    friend class MaskedScatterSDNode;\n\n    uint16_t : NumLSBaseSDNodeBits;\n\n    uint16_t IsTruncating : 1;\n    uint16_t IsCompressing : 1;\n  };\n\n  union {\n    char RawSDNodeBits[sizeof(uint16_t)];\n    SDNodeBitfields SDNodeBits;\n    ConstantSDNodeBitfields ConstantSDNodeBits;\n    MemSDNodeBitfields MemSDNodeBits;\n    LSBaseSDNodeBitfields LSBaseSDNodeBits;\n    LoadSDNodeBitfields LoadSDNodeBits;\n    StoreSDNodeBitfields StoreSDNodeBits;\n  };\nEND_TWO_BYTE_PACK()\n#undef BEGIN_TWO_BYTE_PACK\n#undef END_TWO_BYTE_PACK\n\n  // RawSDNodeBits must cover the entirety of the union.  This means that all of\n  // the union's members must have size <= RawSDNodeBits.  We write the RHS as\n  // \"2\" instead of sizeof(RawSDNodeBits) because MSVC can't handle the latter.\n  static_assert(sizeof(SDNodeBitfields) <= 2, \"field too wide\");\n  static_assert(sizeof(ConstantSDNodeBitfields) <= 2, \"field too wide\");\n  static_assert(sizeof(MemSDNodeBitfields) <= 2, \"field too wide\");\n  static_assert(sizeof(LSBaseSDNodeBitfields) <= 2, \"field too wide\");\n  static_assert(sizeof(LoadSDNodeBitfields) <= 2, \"field too wide\");\n  static_assert(sizeof(StoreSDNodeBitfields) <= 2, \"field too wide\");\n\nprivate:\n  friend class SelectionDAG;\n  // TODO: unfriend HandleSDNode once we fix its operand handling.\n  friend class HandleSDNode;\n\n  /// Unique id per SDNode in the DAG.\n  int NodeId = -1;\n\n  /// The values that are used by this operation.\n  SDUse *OperandList = nullptr;\n\n  /// The types of the values this node defines.  SDNode's may\n  /// define multiple values simultaneously.\n  const EVT *ValueList;\n\n  /// List of uses for this SDNode.\n  SDUse *UseList = nullptr;\n\n  /// The number of entries in the Operand/Value list.\n  unsigned short NumOperands = 0;\n  unsigned short NumValues;\n\n  // The ordering of the SDNodes. It roughly corresponds to the ordering of the\n  // original LLVM instructions.\n  // This is used for turning off scheduling, because we'll forgo\n  // the normal scheduling algorithms and output the instructions according to\n  // this ordering.\n  unsigned IROrder;\n\n  /// Source line information.\n  DebugLoc debugLoc;\n\n  /// Return a pointer to the specified value type.\n  static const EVT *getValueTypeList(EVT VT);\n\n  SDNodeFlags Flags;\n\npublic:\n  /// Unique and persistent id per SDNode in the DAG.\n  /// Used for debug printing.\n  uint16_t PersistentId;\n\n  //===--------------------------------------------------------------------===//\n  //  Accessors\n  //\n\n  /// Return the SelectionDAG opcode value for this node. For\n  /// pre-isel nodes (those for which isMachineOpcode returns false), these\n  /// are the opcode values in the ISD and <target>ISD namespaces. For\n  /// post-isel opcodes, see getMachineOpcode.\n  unsigned getOpcode()  const { return (unsigned short)NodeType; }\n\n  /// Test if this node has a target-specific opcode (in the\n  /// \\<target\\>ISD namespace).\n  bool isTargetOpcode() const { return NodeType >= ISD::BUILTIN_OP_END; }\n\n  /// Test if this node has a target-specific opcode that may raise\n  /// FP exceptions (in the \\<target\\>ISD namespace and greater than\n  /// FIRST_TARGET_STRICTFP_OPCODE).  Note that all target memory\n  /// opcode are currently automatically considered to possibly raise\n  /// FP exceptions as well.\n  bool isTargetStrictFPOpcode() const {\n    return NodeType >= ISD::FIRST_TARGET_STRICTFP_OPCODE;\n  }\n\n  /// Test if this node has a target-specific\n  /// memory-referencing opcode (in the \\<target\\>ISD namespace and\n  /// greater than FIRST_TARGET_MEMORY_OPCODE).\n  bool isTargetMemoryOpcode() const {\n    return NodeType >= ISD::FIRST_TARGET_MEMORY_OPCODE;\n  }\n\n  /// Return true if the type of the node type undefined.\n  bool isUndef() const { return NodeType == ISD::UNDEF; }\n\n  /// Test if this node is a memory intrinsic (with valid pointer information).\n  /// INTRINSIC_W_CHAIN and INTRINSIC_VOID nodes are sometimes created for\n  /// non-memory intrinsics (with chains) that are not really instances of\n  /// MemSDNode. For such nodes, we need some extra state to determine the\n  /// proper classof relationship.\n  bool isMemIntrinsic() const {\n    return (NodeType == ISD::INTRINSIC_W_CHAIN ||\n            NodeType == ISD::INTRINSIC_VOID) &&\n           SDNodeBits.IsMemIntrinsic;\n  }\n\n  /// Test if this node is a strict floating point pseudo-op.\n  bool isStrictFPOpcode() {\n    switch (NodeType) {\n      default:\n        return false;\n      case ISD::STRICT_FP16_TO_FP:\n      case ISD::STRICT_FP_TO_FP16:\n#define DAG_INSTRUCTION(NAME, NARG, ROUND_MODE, INTRINSIC, DAGN)               \\\n      case ISD::STRICT_##DAGN:\n#include \"llvm/IR/ConstrainedOps.def\"\n        return true;\n    }\n  }\n\n  /// Test if this node has a post-isel opcode, directly\n  /// corresponding to a MachineInstr opcode.\n  bool isMachineOpcode() const { return NodeType < 0; }\n\n  /// This may only be called if isMachineOpcode returns\n  /// true. It returns the MachineInstr opcode value that the node's opcode\n  /// corresponds to.\n  unsigned getMachineOpcode() const {\n    assert(isMachineOpcode() && \"Not a MachineInstr opcode!\");\n    return ~NodeType;\n  }\n\n  bool getHasDebugValue() const { return SDNodeBits.HasDebugValue; }\n  void setHasDebugValue(bool b) { SDNodeBits.HasDebugValue = b; }\n\n  bool isDivergent() const { return SDNodeBits.IsDivergent; }\n\n  /// Return true if there are no uses of this node.\n  bool use_empty() const { return UseList == nullptr; }\n\n  /// Return true if there is exactly one use of this node.\n  bool hasOneUse() const { return hasSingleElement(uses()); }\n\n  /// Return the number of uses of this node. This method takes\n  /// time proportional to the number of uses.\n  size_t use_size() const { return std::distance(use_begin(), use_end()); }\n\n  /// Return the unique node id.\n  int getNodeId() const { return NodeId; }\n\n  /// Set unique node id.\n  void setNodeId(int Id) { NodeId = Id; }\n\n  /// Return the node ordering.\n  unsigned getIROrder() const { return IROrder; }\n\n  /// Set the node ordering.\n  void setIROrder(unsigned Order) { IROrder = Order; }\n\n  /// Return the source location info.\n  const DebugLoc &getDebugLoc() const { return debugLoc; }\n\n  /// Set source location info.  Try to avoid this, putting\n  /// it in the constructor is preferable.\n  void setDebugLoc(DebugLoc dl) { debugLoc = std::move(dl); }\n\n  /// This class provides iterator support for SDUse\n  /// operands that use a specific SDNode.\n  class use_iterator\n    : public std::iterator<std::forward_iterator_tag, SDUse, ptrdiff_t> {\n    friend class SDNode;\n\n    SDUse *Op = nullptr;\n\n    explicit use_iterator(SDUse *op) : Op(op) {}\n\n  public:\n    using reference = std::iterator<std::forward_iterator_tag,\n                                    SDUse, ptrdiff_t>::reference;\n    using pointer = std::iterator<std::forward_iterator_tag,\n                                  SDUse, ptrdiff_t>::pointer;\n\n    use_iterator() = default;\n    use_iterator(const use_iterator &I) : Op(I.Op) {}\n\n    bool operator==(const use_iterator &x) const {\n      return Op == x.Op;\n    }\n    bool operator!=(const use_iterator &x) const {\n      return !operator==(x);\n    }\n\n    /// Return true if this iterator is at the end of uses list.\n    bool atEnd() const { return Op == nullptr; }\n\n    // Iterator traversal: forward iteration only.\n    use_iterator &operator++() {          // Preincrement\n      assert(Op && \"Cannot increment end iterator!\");\n      Op = Op->getNext();\n      return *this;\n    }\n\n    use_iterator operator++(int) {        // Postincrement\n      use_iterator tmp = *this; ++*this; return tmp;\n    }\n\n    /// Retrieve a pointer to the current user node.\n    SDNode *operator*() const {\n      assert(Op && \"Cannot dereference end iterator!\");\n      return Op->getUser();\n    }\n\n    SDNode *operator->() const { return operator*(); }\n\n    SDUse &getUse() const { return *Op; }\n\n    /// Retrieve the operand # of this use in its user.\n    unsigned getOperandNo() const {\n      assert(Op && \"Cannot dereference end iterator!\");\n      return (unsigned)(Op - Op->getUser()->OperandList);\n    }\n  };\n\n  /// Provide iteration support to walk over all uses of an SDNode.\n  use_iterator use_begin() const {\n    return use_iterator(UseList);\n  }\n\n  static use_iterator use_end() { return use_iterator(nullptr); }\n\n  inline iterator_range<use_iterator> uses() {\n    return make_range(use_begin(), use_end());\n  }\n  inline iterator_range<use_iterator> uses() const {\n    return make_range(use_begin(), use_end());\n  }\n\n  /// Return true if there are exactly NUSES uses of the indicated value.\n  /// This method ignores uses of other values defined by this operation.\n  bool hasNUsesOfValue(unsigned NUses, unsigned Value) const;\n\n  /// Return true if there are any use of the indicated value.\n  /// This method ignores uses of other values defined by this operation.\n  bool hasAnyUseOfValue(unsigned Value) const;\n\n  /// Return true if this node is the only use of N.\n  bool isOnlyUserOf(const SDNode *N) const;\n\n  /// Return true if this node is an operand of N.\n  bool isOperandOf(const SDNode *N) const;\n\n  /// Return true if this node is a predecessor of N.\n  /// NOTE: Implemented on top of hasPredecessor and every bit as\n  /// expensive. Use carefully.\n  bool isPredecessorOf(const SDNode *N) const {\n    return N->hasPredecessor(this);\n  }\n\n  /// Return true if N is a predecessor of this node.\n  /// N is either an operand of this node, or can be reached by recursively\n  /// traversing up the operands.\n  /// NOTE: This is an expensive method. Use it carefully.\n  bool hasPredecessor(const SDNode *N) const;\n\n  /// Returns true if N is a predecessor of any node in Worklist. This\n  /// helper keeps Visited and Worklist sets externally to allow unions\n  /// searches to be performed in parallel, caching of results across\n  /// queries and incremental addition to Worklist. Stops early if N is\n  /// found but will resume. Remember to clear Visited and Worklists\n  /// if DAG changes. MaxSteps gives a maximum number of nodes to visit before\n  /// giving up. The TopologicalPrune flag signals that positive NodeIds are\n  /// topologically ordered (Operands have strictly smaller node id) and search\n  /// can be pruned leveraging this.\n  static bool hasPredecessorHelper(const SDNode *N,\n                                   SmallPtrSetImpl<const SDNode *> &Visited,\n                                   SmallVectorImpl<const SDNode *> &Worklist,\n                                   unsigned int MaxSteps = 0,\n                                   bool TopologicalPrune = false) {\n    SmallVector<const SDNode *, 8> DeferredNodes;\n    if (Visited.count(N))\n      return true;\n\n    // Node Id's are assigned in three places: As a topological\n    // ordering (> 0), during legalization (results in values set to\n    // 0), new nodes (set to -1). If N has a topolgical id then we\n    // know that all nodes with ids smaller than it cannot be\n    // successors and we need not check them. Filter out all node\n    // that can't be matches. We add them to the worklist before exit\n    // in case of multiple calls. Note that during selection the topological id\n    // may be violated if a node's predecessor is selected before it. We mark\n    // this at selection negating the id of unselected successors and\n    // restricting topological pruning to positive ids.\n\n    int NId = N->getNodeId();\n    // If we Invalidated the Id, reconstruct original NId.\n    if (NId < -1)\n      NId = -(NId + 1);\n\n    bool Found = false;\n    while (!Worklist.empty()) {\n      const SDNode *M = Worklist.pop_back_val();\n      int MId = M->getNodeId();\n      if (TopologicalPrune && M->getOpcode() != ISD::TokenFactor && (NId > 0) &&\n          (MId > 0) && (MId < NId)) {\n        DeferredNodes.push_back(M);\n        continue;\n      }\n      for (const SDValue &OpV : M->op_values()) {\n        SDNode *Op = OpV.getNode();\n        if (Visited.insert(Op).second)\n          Worklist.push_back(Op);\n        if (Op == N)\n          Found = true;\n      }\n      if (Found)\n        break;\n      if (MaxSteps != 0 && Visited.size() >= MaxSteps)\n        break;\n    }\n    // Push deferred nodes back on worklist.\n    Worklist.append(DeferredNodes.begin(), DeferredNodes.end());\n    // If we bailed early, conservatively return found.\n    if (MaxSteps != 0 && Visited.size() >= MaxSteps)\n      return true;\n    return Found;\n  }\n\n  /// Return true if all the users of N are contained in Nodes.\n  /// NOTE: Requires at least one match, but doesn't require them all.\n  static bool areOnlyUsersOf(ArrayRef<const SDNode *> Nodes, const SDNode *N);\n\n  /// Return the number of values used by this operation.\n  unsigned getNumOperands() const { return NumOperands; }\n\n  /// Return the maximum number of operands that a SDNode can hold.\n  static constexpr size_t getMaxNumOperands() {\n    return std::numeric_limits<decltype(SDNode::NumOperands)>::max();\n  }\n\n  /// Helper method returns the integer value of a ConstantSDNode operand.\n  inline uint64_t getConstantOperandVal(unsigned Num) const;\n\n  /// Helper method returns the APInt of a ConstantSDNode operand.\n  inline const APInt &getConstantOperandAPInt(unsigned Num) const;\n\n  const SDValue &getOperand(unsigned Num) const {\n    assert(Num < NumOperands && \"Invalid child # of SDNode!\");\n    return OperandList[Num];\n  }\n\n  using op_iterator = SDUse *;\n\n  op_iterator op_begin() const { return OperandList; }\n  op_iterator op_end() const { return OperandList+NumOperands; }\n  ArrayRef<SDUse> ops() const { return makeArrayRef(op_begin(), op_end()); }\n\n  /// Iterator for directly iterating over the operand SDValue's.\n  struct value_op_iterator\n      : iterator_adaptor_base<value_op_iterator, op_iterator,\n                              std::random_access_iterator_tag, SDValue,\n                              ptrdiff_t, value_op_iterator *,\n                              value_op_iterator *> {\n    explicit value_op_iterator(SDUse *U = nullptr)\n      : iterator_adaptor_base(U) {}\n\n    const SDValue &operator*() const { return I->get(); }\n  };\n\n  iterator_range<value_op_iterator> op_values() const {\n    return make_range(value_op_iterator(op_begin()),\n                      value_op_iterator(op_end()));\n  }\n\n  SDVTList getVTList() const {\n    SDVTList X = { ValueList, NumValues };\n    return X;\n  }\n\n  /// If this node has a glue operand, return the node\n  /// to which the glue operand points. Otherwise return NULL.\n  SDNode *getGluedNode() const {\n    if (getNumOperands() != 0 &&\n        getOperand(getNumOperands()-1).getValueType() == MVT::Glue)\n      return getOperand(getNumOperands()-1).getNode();\n    return nullptr;\n  }\n\n  /// If this node has a glue value with a user, return\n  /// the user (there is at most one). Otherwise return NULL.\n  SDNode *getGluedUser() const {\n    for (use_iterator UI = use_begin(), UE = use_end(); UI != UE; ++UI)\n      if (UI.getUse().get().getValueType() == MVT::Glue)\n        return *UI;\n    return nullptr;\n  }\n\n  SDNodeFlags getFlags() const { return Flags; }\n  void setFlags(SDNodeFlags NewFlags) { Flags = NewFlags; }\n\n  /// Clear any flags in this node that aren't also set in Flags.\n  /// If Flags is not in a defined state then this has no effect.\n  void intersectFlagsWith(const SDNodeFlags Flags);\n\n  /// Return the number of values defined/returned by this operator.\n  unsigned getNumValues() const { return NumValues; }\n\n  /// Return the type of a specified result.\n  EVT getValueType(unsigned ResNo) const {\n    assert(ResNo < NumValues && \"Illegal result number!\");\n    return ValueList[ResNo];\n  }\n\n  /// Return the type of a specified result as a simple type.\n  MVT getSimpleValueType(unsigned ResNo) const {\n    return getValueType(ResNo).getSimpleVT();\n  }\n\n  /// Returns MVT::getSizeInBits(getValueType(ResNo)).\n  ///\n  /// If the value type is a scalable vector type, the scalable property will\n  /// be set and the runtime size will be a positive integer multiple of the\n  /// base size.\n  TypeSize getValueSizeInBits(unsigned ResNo) const {\n    return getValueType(ResNo).getSizeInBits();\n  }\n\n  using value_iterator = const EVT *;\n\n  value_iterator value_begin() const { return ValueList; }\n  value_iterator value_end() const { return ValueList+NumValues; }\n  iterator_range<value_iterator> values() const {\n    return llvm::make_range(value_begin(), value_end());\n  }\n\n  /// Return the opcode of this operation for printing.\n  std::string getOperationName(const SelectionDAG *G = nullptr) const;\n  static const char* getIndexedModeName(ISD::MemIndexedMode AM);\n  void print_types(raw_ostream &OS, const SelectionDAG *G) const;\n  void print_details(raw_ostream &OS, const SelectionDAG *G) const;\n  void print(raw_ostream &OS, const SelectionDAG *G = nullptr) const;\n  void printr(raw_ostream &OS, const SelectionDAG *G = nullptr) const;\n\n  /// Print a SelectionDAG node and all children down to\n  /// the leaves.  The given SelectionDAG allows target-specific nodes\n  /// to be printed in human-readable form.  Unlike printr, this will\n  /// print the whole DAG, including children that appear multiple\n  /// times.\n  ///\n  void printrFull(raw_ostream &O, const SelectionDAG *G = nullptr) const;\n\n  /// Print a SelectionDAG node and children up to\n  /// depth \"depth.\"  The given SelectionDAG allows target-specific\n  /// nodes to be printed in human-readable form.  Unlike printr, this\n  /// will print children that appear multiple times wherever they are\n  /// used.\n  ///\n  void printrWithDepth(raw_ostream &O, const SelectionDAG *G = nullptr,\n                       unsigned depth = 100) const;\n\n  /// Dump this node, for debugging.\n  void dump() const;\n\n  /// Dump (recursively) this node and its use-def subgraph.\n  void dumpr() const;\n\n  /// Dump this node, for debugging.\n  /// The given SelectionDAG allows target-specific nodes to be printed\n  /// in human-readable form.\n  void dump(const SelectionDAG *G) const;\n\n  /// Dump (recursively) this node and its use-def subgraph.\n  /// The given SelectionDAG allows target-specific nodes to be printed\n  /// in human-readable form.\n  void dumpr(const SelectionDAG *G) const;\n\n  /// printrFull to dbgs().  The given SelectionDAG allows\n  /// target-specific nodes to be printed in human-readable form.\n  /// Unlike dumpr, this will print the whole DAG, including children\n  /// that appear multiple times.\n  void dumprFull(const SelectionDAG *G = nullptr) const;\n\n  /// printrWithDepth to dbgs().  The given\n  /// SelectionDAG allows target-specific nodes to be printed in\n  /// human-readable form.  Unlike dumpr, this will print children\n  /// that appear multiple times wherever they are used.\n  ///\n  void dumprWithDepth(const SelectionDAG *G = nullptr,\n                      unsigned depth = 100) const;\n\n  /// Gather unique data for the node.\n  void Profile(FoldingSetNodeID &ID) const;\n\n  /// This method should only be used by the SDUse class.\n  void addUse(SDUse &U) { U.addToList(&UseList); }\n\nprotected:\n  static SDVTList getSDVTList(EVT VT) {\n    SDVTList Ret = { getValueTypeList(VT), 1 };\n    return Ret;\n  }\n\n  /// Create an SDNode.\n  ///\n  /// SDNodes are created without any operands, and never own the operand\n  /// storage. To add operands, see SelectionDAG::createOperands.\n  SDNode(unsigned Opc, unsigned Order, DebugLoc dl, SDVTList VTs)\n      : NodeType(Opc), ValueList(VTs.VTs), NumValues(VTs.NumVTs),\n        IROrder(Order), debugLoc(std::move(dl)) {\n    memset(&RawSDNodeBits, 0, sizeof(RawSDNodeBits));\n    assert(debugLoc.hasTrivialDestructor() && \"Expected trivial destructor\");\n    assert(NumValues == VTs.NumVTs &&\n           \"NumValues wasn't wide enough for its operands!\");\n  }\n\n  /// Release the operands and set this node to have zero operands.\n  void DropOperands();\n};\n\n/// Wrapper class for IR location info (IR ordering and DebugLoc) to be passed\n/// into SDNode creation functions.\n/// When an SDNode is created from the DAGBuilder, the DebugLoc is extracted\n/// from the original Instruction, and IROrder is the ordinal position of\n/// the instruction.\n/// When an SDNode is created after the DAG is being built, both DebugLoc and\n/// the IROrder are propagated from the original SDNode.\n/// So SDLoc class provides two constructors besides the default one, one to\n/// be used by the DAGBuilder, the other to be used by others.\nclass SDLoc {\nprivate:\n  DebugLoc DL;\n  int IROrder = 0;\n\npublic:\n  SDLoc() = default;\n  SDLoc(const SDNode *N) : DL(N->getDebugLoc()), IROrder(N->getIROrder()) {}\n  SDLoc(const SDValue V) : SDLoc(V.getNode()) {}\n  SDLoc(const Instruction *I, int Order) : IROrder(Order) {\n    assert(Order >= 0 && \"bad IROrder\");\n    if (I)\n      DL = I->getDebugLoc();\n  }\n\n  unsigned getIROrder() const { return IROrder; }\n  const DebugLoc &getDebugLoc() const { return DL; }\n};\n\n// Define inline functions from the SDValue class.\n\ninline SDValue::SDValue(SDNode *node, unsigned resno)\n    : Node(node), ResNo(resno) {\n  // Explicitly check for !ResNo to avoid use-after-free, because there are\n  // callers that use SDValue(N, 0) with a deleted N to indicate successful\n  // combines.\n  assert((!Node || !ResNo || ResNo < Node->getNumValues()) &&\n         \"Invalid result number for the given node!\");\n  assert(ResNo < -2U && \"Cannot use result numbers reserved for DenseMaps.\");\n}\n\ninline unsigned SDValue::getOpcode() const {\n  return Node->getOpcode();\n}\n\ninline EVT SDValue::getValueType() const {\n  return Node->getValueType(ResNo);\n}\n\ninline unsigned SDValue::getNumOperands() const {\n  return Node->getNumOperands();\n}\n\ninline const SDValue &SDValue::getOperand(unsigned i) const {\n  return Node->getOperand(i);\n}\n\ninline uint64_t SDValue::getConstantOperandVal(unsigned i) const {\n  return Node->getConstantOperandVal(i);\n}\n\ninline const APInt &SDValue::getConstantOperandAPInt(unsigned i) const {\n  return Node->getConstantOperandAPInt(i);\n}\n\ninline bool SDValue::isTargetOpcode() const {\n  return Node->isTargetOpcode();\n}\n\ninline bool SDValue::isTargetMemoryOpcode() const {\n  return Node->isTargetMemoryOpcode();\n}\n\ninline bool SDValue::isMachineOpcode() const {\n  return Node->isMachineOpcode();\n}\n\ninline unsigned SDValue::getMachineOpcode() const {\n  return Node->getMachineOpcode();\n}\n\ninline bool SDValue::isUndef() const {\n  return Node->isUndef();\n}\n\ninline bool SDValue::use_empty() const {\n  return !Node->hasAnyUseOfValue(ResNo);\n}\n\ninline bool SDValue::hasOneUse() const {\n  return Node->hasNUsesOfValue(1, ResNo);\n}\n\ninline const DebugLoc &SDValue::getDebugLoc() const {\n  return Node->getDebugLoc();\n}\n\ninline void SDValue::dump() const {\n  return Node->dump();\n}\n\ninline void SDValue::dump(const SelectionDAG *G) const {\n  return Node->dump(G);\n}\n\ninline void SDValue::dumpr() const {\n  return Node->dumpr();\n}\n\ninline void SDValue::dumpr(const SelectionDAG *G) const {\n  return Node->dumpr(G);\n}\n\n// Define inline functions from the SDUse class.\n\ninline void SDUse::set(const SDValue &V) {\n  if (Val.getNode()) removeFromList();\n  Val = V;\n  if (V.getNode()) V.getNode()->addUse(*this);\n}\n\ninline void SDUse::setInitial(const SDValue &V) {\n  Val = V;\n  V.getNode()->addUse(*this);\n}\n\ninline void SDUse::setNode(SDNode *N) {\n  if (Val.getNode()) removeFromList();\n  Val.setNode(N);\n  if (N) N->addUse(*this);\n}\n\n/// This class is used to form a handle around another node that\n/// is persistent and is updated across invocations of replaceAllUsesWith on its\n/// operand.  This node should be directly created by end-users and not added to\n/// the AllNodes list.\nclass HandleSDNode : public SDNode {\n  SDUse Op;\n\npublic:\n  explicit HandleSDNode(SDValue X)\n    : SDNode(ISD::HANDLENODE, 0, DebugLoc(), getSDVTList(MVT::Other)) {\n    // HandleSDNodes are never inserted into the DAG, so they won't be\n    // auto-numbered. Use ID 65535 as a sentinel.\n    PersistentId = 0xffff;\n\n    // Manually set up the operand list. This node type is special in that it's\n    // always stack allocated and SelectionDAG does not manage its operands.\n    // TODO: This should either (a) not be in the SDNode hierarchy, or (b) not\n    // be so special.\n    Op.setUser(this);\n    Op.setInitial(X);\n    NumOperands = 1;\n    OperandList = &Op;\n  }\n  ~HandleSDNode();\n\n  const SDValue &getValue() const { return Op; }\n};\n\nclass AddrSpaceCastSDNode : public SDNode {\nprivate:\n  unsigned SrcAddrSpace;\n  unsigned DestAddrSpace;\n\npublic:\n  AddrSpaceCastSDNode(unsigned Order, const DebugLoc &dl, EVT VT,\n                      unsigned SrcAS, unsigned DestAS);\n\n  unsigned getSrcAddressSpace() const { return SrcAddrSpace; }\n  unsigned getDestAddressSpace() const { return DestAddrSpace; }\n\n  static bool classof(const SDNode *N) {\n    return N->getOpcode() == ISD::ADDRSPACECAST;\n  }\n};\n\n/// This is an abstract virtual class for memory operations.\nclass MemSDNode : public SDNode {\nprivate:\n  // VT of in-memory value.\n  EVT MemoryVT;\n\nprotected:\n  /// Memory reference information.\n  MachineMemOperand *MMO;\n\npublic:\n  MemSDNode(unsigned Opc, unsigned Order, const DebugLoc &dl, SDVTList VTs,\n            EVT memvt, MachineMemOperand *MMO);\n\n  bool readMem() const { return MMO->isLoad(); }\n  bool writeMem() const { return MMO->isStore(); }\n\n  /// Returns alignment and volatility of the memory access\n  Align getOriginalAlign() const { return MMO->getBaseAlign(); }\n  Align getAlign() const { return MMO->getAlign(); }\n  LLVM_ATTRIBUTE_DEPRECATED(unsigned getOriginalAlignment() const,\n                            \"Use getOriginalAlign() instead\") {\n    return MMO->getBaseAlign().value();\n  }\n  // FIXME: Remove once transition to getAlign is over.\n  unsigned getAlignment() const { return MMO->getAlign().value(); }\n\n  /// Return the SubclassData value, without HasDebugValue. This contains an\n  /// encoding of the volatile flag, as well as bits used by subclasses. This\n  /// function should only be used to compute a FoldingSetNodeID value.\n  /// The HasDebugValue bit is masked out because CSE map needs to match\n  /// nodes with debug info with nodes without debug info. Same is about\n  /// isDivergent bit.\n  unsigned getRawSubclassData() const {\n    uint16_t Data;\n    union {\n      char RawSDNodeBits[sizeof(uint16_t)];\n      SDNodeBitfields SDNodeBits;\n    };\n    memcpy(&RawSDNodeBits, &this->RawSDNodeBits, sizeof(this->RawSDNodeBits));\n    SDNodeBits.HasDebugValue = 0;\n    SDNodeBits.IsDivergent = false;\n    memcpy(&Data, &RawSDNodeBits, sizeof(RawSDNodeBits));\n    return Data;\n  }\n\n  bool isVolatile() const { return MemSDNodeBits.IsVolatile; }\n  bool isNonTemporal() const { return MemSDNodeBits.IsNonTemporal; }\n  bool isDereferenceable() const { return MemSDNodeBits.IsDereferenceable; }\n  bool isInvariant() const { return MemSDNodeBits.IsInvariant; }\n\n  // Returns the offset from the location of the access.\n  int64_t getSrcValueOffset() const { return MMO->getOffset(); }\n\n  /// Returns the AA info that describes the dereference.\n  AAMDNodes getAAInfo() const { return MMO->getAAInfo(); }\n\n  /// Returns the Ranges that describes the dereference.\n  const MDNode *getRanges() const { return MMO->getRanges(); }\n\n  /// Returns the synchronization scope ID for this memory operation.\n  SyncScope::ID getSyncScopeID() const { return MMO->getSyncScopeID(); }\n\n  /// Return the atomic ordering requirements for this memory operation. For\n  /// cmpxchg atomic operations, return the atomic ordering requirements when\n  /// store occurs.\n  AtomicOrdering getOrdering() const { return MMO->getOrdering(); }\n\n  /// Return true if the memory operation ordering is Unordered or higher.\n  bool isAtomic() const { return MMO->isAtomic(); }\n\n  /// Returns true if the memory operation doesn't imply any ordering\n  /// constraints on surrounding memory operations beyond the normal memory\n  /// aliasing rules.\n  bool isUnordered() const { return MMO->isUnordered(); }\n\n  /// Returns true if the memory operation is neither atomic or volatile.\n  bool isSimple() const { return !isAtomic() && !isVolatile(); }\n\n  /// Return the type of the in-memory value.\n  EVT getMemoryVT() const { return MemoryVT; }\n\n  /// Return a MachineMemOperand object describing the memory\n  /// reference performed by operation.\n  MachineMemOperand *getMemOperand() const { return MMO; }\n\n  const MachinePointerInfo &getPointerInfo() const {\n    return MMO->getPointerInfo();\n  }\n\n  /// Return the address space for the associated pointer\n  unsigned getAddressSpace() const {\n    return getPointerInfo().getAddrSpace();\n  }\n\n  /// Update this MemSDNode's MachineMemOperand information\n  /// to reflect the alignment of NewMMO, if it has a greater alignment.\n  /// This must only be used when the new alignment applies to all users of\n  /// this MachineMemOperand.\n  void refineAlignment(const MachineMemOperand *NewMMO) {\n    MMO->refineAlignment(NewMMO);\n  }\n\n  const SDValue &getChain() const { return getOperand(0); }\n\n  const SDValue &getBasePtr() const {\n    switch (getOpcode()) {\n    case ISD::STORE:\n    case ISD::MSTORE:\n      return getOperand(2);\n    case ISD::MGATHER:\n    case ISD::MSCATTER:\n      return getOperand(3);\n    default:\n      return getOperand(1);\n    }\n  }\n\n  // Methods to support isa and dyn_cast\n  static bool classof(const SDNode *N) {\n    // For some targets, we lower some target intrinsics to a MemIntrinsicNode\n    // with either an intrinsic or a target opcode.\n    return N->getOpcode() == ISD::LOAD                ||\n           N->getOpcode() == ISD::STORE               ||\n           N->getOpcode() == ISD::PREFETCH            ||\n           N->getOpcode() == ISD::ATOMIC_CMP_SWAP     ||\n           N->getOpcode() == ISD::ATOMIC_CMP_SWAP_WITH_SUCCESS ||\n           N->getOpcode() == ISD::ATOMIC_SWAP         ||\n           N->getOpcode() == ISD::ATOMIC_LOAD_ADD     ||\n           N->getOpcode() == ISD::ATOMIC_LOAD_SUB     ||\n           N->getOpcode() == ISD::ATOMIC_LOAD_AND     ||\n           N->getOpcode() == ISD::ATOMIC_LOAD_CLR     ||\n           N->getOpcode() == ISD::ATOMIC_LOAD_OR      ||\n           N->getOpcode() == ISD::ATOMIC_LOAD_XOR     ||\n           N->getOpcode() == ISD::ATOMIC_LOAD_NAND    ||\n           N->getOpcode() == ISD::ATOMIC_LOAD_MIN     ||\n           N->getOpcode() == ISD::ATOMIC_LOAD_MAX     ||\n           N->getOpcode() == ISD::ATOMIC_LOAD_UMIN    ||\n           N->getOpcode() == ISD::ATOMIC_LOAD_UMAX    ||\n           N->getOpcode() == ISD::ATOMIC_LOAD_FADD    ||\n           N->getOpcode() == ISD::ATOMIC_LOAD_FSUB    ||\n           N->getOpcode() == ISD::ATOMIC_LOAD         ||\n           N->getOpcode() == ISD::ATOMIC_STORE        ||\n           N->getOpcode() == ISD::MLOAD               ||\n           N->getOpcode() == ISD::MSTORE              ||\n           N->getOpcode() == ISD::MGATHER             ||\n           N->getOpcode() == ISD::MSCATTER            ||\n           N->isMemIntrinsic()                        ||\n           N->isTargetMemoryOpcode();\n  }\n};\n\n/// This is an SDNode representing atomic operations.\nclass AtomicSDNode : public MemSDNode {\npublic:\n  AtomicSDNode(unsigned Opc, unsigned Order, const DebugLoc &dl, SDVTList VTL,\n               EVT MemVT, MachineMemOperand *MMO)\n    : MemSDNode(Opc, Order, dl, VTL, MemVT, MMO) {\n    assert(((Opc != ISD::ATOMIC_LOAD && Opc != ISD::ATOMIC_STORE) ||\n            MMO->isAtomic()) && \"then why are we using an AtomicSDNode?\");\n  }\n\n  const SDValue &getBasePtr() const { return getOperand(1); }\n  const SDValue &getVal() const { return getOperand(2); }\n\n  /// Returns true if this SDNode represents cmpxchg atomic operation, false\n  /// otherwise.\n  bool isCompareAndSwap() const {\n    unsigned Op = getOpcode();\n    return Op == ISD::ATOMIC_CMP_SWAP ||\n           Op == ISD::ATOMIC_CMP_SWAP_WITH_SUCCESS;\n  }\n\n  /// For cmpxchg atomic operations, return the atomic ordering requirements\n  /// when store does not occur.\n  AtomicOrdering getFailureOrdering() const {\n    assert(isCompareAndSwap() && \"Must be cmpxchg operation\");\n    return MMO->getFailureOrdering();\n  }\n\n  // Methods to support isa and dyn_cast\n  static bool classof(const SDNode *N) {\n    return N->getOpcode() == ISD::ATOMIC_CMP_SWAP     ||\n           N->getOpcode() == ISD::ATOMIC_CMP_SWAP_WITH_SUCCESS ||\n           N->getOpcode() == ISD::ATOMIC_SWAP         ||\n           N->getOpcode() == ISD::ATOMIC_LOAD_ADD     ||\n           N->getOpcode() == ISD::ATOMIC_LOAD_SUB     ||\n           N->getOpcode() == ISD::ATOMIC_LOAD_AND     ||\n           N->getOpcode() == ISD::ATOMIC_LOAD_CLR     ||\n           N->getOpcode() == ISD::ATOMIC_LOAD_OR      ||\n           N->getOpcode() == ISD::ATOMIC_LOAD_XOR     ||\n           N->getOpcode() == ISD::ATOMIC_LOAD_NAND    ||\n           N->getOpcode() == ISD::ATOMIC_LOAD_MIN     ||\n           N->getOpcode() == ISD::ATOMIC_LOAD_MAX     ||\n           N->getOpcode() == ISD::ATOMIC_LOAD_UMIN    ||\n           N->getOpcode() == ISD::ATOMIC_LOAD_UMAX    ||\n           N->getOpcode() == ISD::ATOMIC_LOAD_FADD    ||\n           N->getOpcode() == ISD::ATOMIC_LOAD_FSUB    ||\n           N->getOpcode() == ISD::ATOMIC_LOAD         ||\n           N->getOpcode() == ISD::ATOMIC_STORE;\n  }\n};\n\n/// This SDNode is used for target intrinsics that touch\n/// memory and need an associated MachineMemOperand. Its opcode may be\n/// INTRINSIC_VOID, INTRINSIC_W_CHAIN, PREFETCH, or a target-specific opcode\n/// with a value not less than FIRST_TARGET_MEMORY_OPCODE.\nclass MemIntrinsicSDNode : public MemSDNode {\npublic:\n  MemIntrinsicSDNode(unsigned Opc, unsigned Order, const DebugLoc &dl,\n                     SDVTList VTs, EVT MemoryVT, MachineMemOperand *MMO)\n      : MemSDNode(Opc, Order, dl, VTs, MemoryVT, MMO) {\n    SDNodeBits.IsMemIntrinsic = true;\n  }\n\n  // Methods to support isa and dyn_cast\n  static bool classof(const SDNode *N) {\n    // We lower some target intrinsics to their target opcode\n    // early a node with a target opcode can be of this class\n    return N->isMemIntrinsic()             ||\n           N->getOpcode() == ISD::PREFETCH ||\n           N->isTargetMemoryOpcode();\n  }\n};\n\n/// This SDNode is used to implement the code generator\n/// support for the llvm IR shufflevector instruction.  It combines elements\n/// from two input vectors into a new input vector, with the selection and\n/// ordering of elements determined by an array of integers, referred to as\n/// the shuffle mask.  For input vectors of width N, mask indices of 0..N-1\n/// refer to elements from the LHS input, and indices from N to 2N-1 the RHS.\n/// An index of -1 is treated as undef, such that the code generator may put\n/// any value in the corresponding element of the result.\nclass ShuffleVectorSDNode : public SDNode {\n  // The memory for Mask is owned by the SelectionDAG's OperandAllocator, and\n  // is freed when the SelectionDAG object is destroyed.\n  const int *Mask;\n\nprotected:\n  friend class SelectionDAG;\n\n  ShuffleVectorSDNode(EVT VT, unsigned Order, const DebugLoc &dl, const int *M)\n      : SDNode(ISD::VECTOR_SHUFFLE, Order, dl, getSDVTList(VT)), Mask(M) {}\n\npublic:\n  ArrayRef<int> getMask() const {\n    EVT VT = getValueType(0);\n    return makeArrayRef(Mask, VT.getVectorNumElements());\n  }\n\n  int getMaskElt(unsigned Idx) const {\n    assert(Idx < getValueType(0).getVectorNumElements() && \"Idx out of range!\");\n    return Mask[Idx];\n  }\n\n  bool isSplat() const { return isSplatMask(Mask, getValueType(0)); }\n\n  int getSplatIndex() const {\n    assert(isSplat() && \"Cannot get splat index for non-splat!\");\n    EVT VT = getValueType(0);\n    for (unsigned i = 0, e = VT.getVectorNumElements(); i != e; ++i)\n      if (Mask[i] >= 0)\n        return Mask[i];\n\n    // We can choose any index value here and be correct because all elements\n    // are undefined. Return 0 for better potential for callers to simplify.\n    return 0;\n  }\n\n  static bool isSplatMask(const int *Mask, EVT VT);\n\n  /// Change values in a shuffle permute mask assuming\n  /// the two vector operands have swapped position.\n  static void commuteMask(MutableArrayRef<int> Mask) {\n    unsigned NumElems = Mask.size();\n    for (unsigned i = 0; i != NumElems; ++i) {\n      int idx = Mask[i];\n      if (idx < 0)\n        continue;\n      else if (idx < (int)NumElems)\n        Mask[i] = idx + NumElems;\n      else\n        Mask[i] = idx - NumElems;\n    }\n  }\n\n  static bool classof(const SDNode *N) {\n    return N->getOpcode() == ISD::VECTOR_SHUFFLE;\n  }\n};\n\nclass ConstantSDNode : public SDNode {\n  friend class SelectionDAG;\n\n  const ConstantInt *Value;\n\n  ConstantSDNode(bool isTarget, bool isOpaque, const ConstantInt *val, EVT VT)\n      : SDNode(isTarget ? ISD::TargetConstant : ISD::Constant, 0, DebugLoc(),\n               getSDVTList(VT)),\n        Value(val) {\n    ConstantSDNodeBits.IsOpaque = isOpaque;\n  }\n\npublic:\n  const ConstantInt *getConstantIntValue() const { return Value; }\n  const APInt &getAPIntValue() const { return Value->getValue(); }\n  uint64_t getZExtValue() const { return Value->getZExtValue(); }\n  int64_t getSExtValue() const { return Value->getSExtValue(); }\n  uint64_t getLimitedValue(uint64_t Limit = UINT64_MAX) {\n    return Value->getLimitedValue(Limit);\n  }\n  MaybeAlign getMaybeAlignValue() const { return Value->getMaybeAlignValue(); }\n  Align getAlignValue() const { return Value->getAlignValue(); }\n\n  bool isOne() const { return Value->isOne(); }\n  bool isNullValue() const { return Value->isZero(); }\n  bool isAllOnesValue() const { return Value->isMinusOne(); }\n\n  bool isOpaque() const { return ConstantSDNodeBits.IsOpaque; }\n\n  static bool classof(const SDNode *N) {\n    return N->getOpcode() == ISD::Constant ||\n           N->getOpcode() == ISD::TargetConstant;\n  }\n};\n\nuint64_t SDNode::getConstantOperandVal(unsigned Num) const {\n  return cast<ConstantSDNode>(getOperand(Num))->getZExtValue();\n}\n\nconst APInt &SDNode::getConstantOperandAPInt(unsigned Num) const {\n  return cast<ConstantSDNode>(getOperand(Num))->getAPIntValue();\n}\n\nclass ConstantFPSDNode : public SDNode {\n  friend class SelectionDAG;\n\n  const ConstantFP *Value;\n\n  ConstantFPSDNode(bool isTarget, const ConstantFP *val, EVT VT)\n      : SDNode(isTarget ? ISD::TargetConstantFP : ISD::ConstantFP, 0,\n               DebugLoc(), getSDVTList(VT)),\n        Value(val) {}\n\npublic:\n  const APFloat& getValueAPF() const { return Value->getValueAPF(); }\n  const ConstantFP *getConstantFPValue() const { return Value; }\n\n  /// Return true if the value is positive or negative zero.\n  bool isZero() const { return Value->isZero(); }\n\n  /// Return true if the value is a NaN.\n  bool isNaN() const { return Value->isNaN(); }\n\n  /// Return true if the value is an infinity\n  bool isInfinity() const { return Value->isInfinity(); }\n\n  /// Return true if the value is negative.\n  bool isNegative() const { return Value->isNegative(); }\n\n  /// We don't rely on operator== working on double values, as\n  /// it returns true for things that are clearly not equal, like -0.0 and 0.0.\n  /// As such, this method can be used to do an exact bit-for-bit comparison of\n  /// two floating point values.\n\n  /// We leave the version with the double argument here because it's just so\n  /// convenient to write \"2.0\" and the like.  Without this function we'd\n  /// have to duplicate its logic everywhere it's called.\n  bool isExactlyValue(double V) const {\n    return Value->getValueAPF().isExactlyValue(V);\n  }\n  bool isExactlyValue(const APFloat& V) const;\n\n  static bool isValueValidForType(EVT VT, const APFloat& Val);\n\n  static bool classof(const SDNode *N) {\n    return N->getOpcode() == ISD::ConstantFP ||\n           N->getOpcode() == ISD::TargetConstantFP;\n  }\n};\n\n/// Returns true if \\p V is a constant integer zero.\nbool isNullConstant(SDValue V);\n\n/// Returns true if \\p V is an FP constant with a value of positive zero.\nbool isNullFPConstant(SDValue V);\n\n/// Returns true if \\p V is an integer constant with all bits set.\nbool isAllOnesConstant(SDValue V);\n\n/// Returns true if \\p V is a constant integer one.\nbool isOneConstant(SDValue V);\n\n/// Return the non-bitcasted source operand of \\p V if it exists.\n/// If \\p V is not a bitcasted value, it is returned as-is.\nSDValue peekThroughBitcasts(SDValue V);\n\n/// Return the non-bitcasted and one-use source operand of \\p V if it exists.\n/// If \\p V is not a bitcasted one-use value, it is returned as-is.\nSDValue peekThroughOneUseBitcasts(SDValue V);\n\n/// Return the non-extracted vector source operand of \\p V if it exists.\n/// If \\p V is not an extracted subvector, it is returned as-is.\nSDValue peekThroughExtractSubvectors(SDValue V);\n\n/// Returns true if \\p V is a bitwise not operation. Assumes that an all ones\n/// constant is canonicalized to be operand 1.\nbool isBitwiseNot(SDValue V, bool AllowUndefs = false);\n\n/// Returns the SDNode if it is a constant splat BuildVector or constant int.\nConstantSDNode *isConstOrConstSplat(SDValue N, bool AllowUndefs = false,\n                                    bool AllowTruncation = false);\n\n/// Returns the SDNode if it is a demanded constant splat BuildVector or\n/// constant int.\nConstantSDNode *isConstOrConstSplat(SDValue N, const APInt &DemandedElts,\n                                    bool AllowUndefs = false,\n                                    bool AllowTruncation = false);\n\n/// Returns the SDNode if it is a constant splat BuildVector or constant float.\nConstantFPSDNode *isConstOrConstSplatFP(SDValue N, bool AllowUndefs = false);\n\n/// Returns the SDNode if it is a demanded constant splat BuildVector or\n/// constant float.\nConstantFPSDNode *isConstOrConstSplatFP(SDValue N, const APInt &DemandedElts,\n                                        bool AllowUndefs = false);\n\n/// Return true if the value is a constant 0 integer or a splatted vector of\n/// a constant 0 integer (with no undefs by default).\n/// Build vector implicit truncation is not an issue for null values.\nbool isNullOrNullSplat(SDValue V, bool AllowUndefs = false);\n\n/// Return true if the value is a constant 1 integer or a splatted vector of a\n/// constant 1 integer (with no undefs).\n/// Does not permit build vector implicit truncation.\nbool isOneOrOneSplat(SDValue V, bool AllowUndefs = false);\n\n/// Return true if the value is a constant -1 integer or a splatted vector of a\n/// constant -1 integer (with no undefs).\n/// Does not permit build vector implicit truncation.\nbool isAllOnesOrAllOnesSplat(SDValue V, bool AllowUndefs = false);\n\nclass GlobalAddressSDNode : public SDNode {\n  friend class SelectionDAG;\n\n  const GlobalValue *TheGlobal;\n  int64_t Offset;\n  unsigned TargetFlags;\n\n  GlobalAddressSDNode(unsigned Opc, unsigned Order, const DebugLoc &DL,\n                      const GlobalValue *GA, EVT VT, int64_t o,\n                      unsigned TF);\n\npublic:\n  const GlobalValue *getGlobal() const { return TheGlobal; }\n  int64_t getOffset() const { return Offset; }\n  unsigned getTargetFlags() const { return TargetFlags; }\n  // Return the address space this GlobalAddress belongs to.\n  unsigned getAddressSpace() const;\n\n  static bool classof(const SDNode *N) {\n    return N->getOpcode() == ISD::GlobalAddress ||\n           N->getOpcode() == ISD::TargetGlobalAddress ||\n           N->getOpcode() == ISD::GlobalTLSAddress ||\n           N->getOpcode() == ISD::TargetGlobalTLSAddress;\n  }\n};\n\nclass FrameIndexSDNode : public SDNode {\n  friend class SelectionDAG;\n\n  int FI;\n\n  FrameIndexSDNode(int fi, EVT VT, bool isTarg)\n    : SDNode(isTarg ? ISD::TargetFrameIndex : ISD::FrameIndex,\n      0, DebugLoc(), getSDVTList(VT)), FI(fi) {\n  }\n\npublic:\n  int getIndex() const { return FI; }\n\n  static bool classof(const SDNode *N) {\n    return N->getOpcode() == ISD::FrameIndex ||\n           N->getOpcode() == ISD::TargetFrameIndex;\n  }\n};\n\n/// This SDNode is used for LIFETIME_START/LIFETIME_END values, which indicate\n/// the offet and size that are started/ended in the underlying FrameIndex.\nclass LifetimeSDNode : public SDNode {\n  friend class SelectionDAG;\n  int64_t Size;\n  int64_t Offset; // -1 if offset is unknown.\n\n  LifetimeSDNode(unsigned Opcode, unsigned Order, const DebugLoc &dl,\n                 SDVTList VTs, int64_t Size, int64_t Offset)\n      : SDNode(Opcode, Order, dl, VTs), Size(Size), Offset(Offset) {}\npublic:\n  int64_t getFrameIndex() const {\n    return cast<FrameIndexSDNode>(getOperand(1))->getIndex();\n  }\n\n  bool hasOffset() const { return Offset >= 0; }\n  int64_t getOffset() const {\n    assert(hasOffset() && \"offset is unknown\");\n    return Offset;\n  }\n  int64_t getSize() const {\n    assert(hasOffset() && \"offset is unknown\");\n    return Size;\n  }\n\n  // Methods to support isa and dyn_cast\n  static bool classof(const SDNode *N) {\n    return N->getOpcode() == ISD::LIFETIME_START ||\n           N->getOpcode() == ISD::LIFETIME_END;\n  }\n};\n\n/// This SDNode is used for PSEUDO_PROBE values, which are the function guid and\n/// the index of the basic block being probed. A pseudo probe serves as a place\n/// holder and will be removed at the end of compilation. It does not have any\n/// operand because we do not want the instruction selection to deal with any.\nclass PseudoProbeSDNode : public SDNode {\n  friend class SelectionDAG;\n  uint64_t Guid;\n  uint64_t Index;\n  uint32_t Attributes;\n\n  PseudoProbeSDNode(unsigned Opcode, unsigned Order, const DebugLoc &Dl,\n                    SDVTList VTs, uint64_t Guid, uint64_t Index, uint32_t Attr)\n      : SDNode(Opcode, Order, Dl, VTs), Guid(Guid), Index(Index),\n        Attributes(Attr) {}\n\npublic:\n  uint64_t getGuid() const { return Guid; }\n  uint64_t getIndex() const { return Index; }\n  uint32_t getAttributes() const { return Attributes; }\n\n  // Methods to support isa and dyn_cast\n  static bool classof(const SDNode *N) {\n    return N->getOpcode() == ISD::PSEUDO_PROBE;\n  }\n};\n\nclass JumpTableSDNode : public SDNode {\n  friend class SelectionDAG;\n\n  int JTI;\n  unsigned TargetFlags;\n\n  JumpTableSDNode(int jti, EVT VT, bool isTarg, unsigned TF)\n    : SDNode(isTarg ? ISD::TargetJumpTable : ISD::JumpTable,\n      0, DebugLoc(), getSDVTList(VT)), JTI(jti), TargetFlags(TF) {\n  }\n\npublic:\n  int getIndex() const { return JTI; }\n  unsigned getTargetFlags() const { return TargetFlags; }\n\n  static bool classof(const SDNode *N) {\n    return N->getOpcode() == ISD::JumpTable ||\n           N->getOpcode() == ISD::TargetJumpTable;\n  }\n};\n\nclass ConstantPoolSDNode : public SDNode {\n  friend class SelectionDAG;\n\n  union {\n    const Constant *ConstVal;\n    MachineConstantPoolValue *MachineCPVal;\n  } Val;\n  int Offset;  // It's a MachineConstantPoolValue if top bit is set.\n  Align Alignment; // Minimum alignment requirement of CP.\n  unsigned TargetFlags;\n\n  ConstantPoolSDNode(bool isTarget, const Constant *c, EVT VT, int o,\n                     Align Alignment, unsigned TF)\n      : SDNode(isTarget ? ISD::TargetConstantPool : ISD::ConstantPool, 0,\n               DebugLoc(), getSDVTList(VT)),\n        Offset(o), Alignment(Alignment), TargetFlags(TF) {\n    assert(Offset >= 0 && \"Offset is too large\");\n    Val.ConstVal = c;\n  }\n\n  ConstantPoolSDNode(bool isTarget, MachineConstantPoolValue *v, EVT VT, int o,\n                     Align Alignment, unsigned TF)\n      : SDNode(isTarget ? ISD::TargetConstantPool : ISD::ConstantPool, 0,\n               DebugLoc(), getSDVTList(VT)),\n        Offset(o), Alignment(Alignment), TargetFlags(TF) {\n    assert(Offset >= 0 && \"Offset is too large\");\n    Val.MachineCPVal = v;\n    Offset |= 1 << (sizeof(unsigned)*CHAR_BIT-1);\n  }\n\npublic:\n  bool isMachineConstantPoolEntry() const {\n    return Offset < 0;\n  }\n\n  const Constant *getConstVal() const {\n    assert(!isMachineConstantPoolEntry() && \"Wrong constantpool type\");\n    return Val.ConstVal;\n  }\n\n  MachineConstantPoolValue *getMachineCPVal() const {\n    assert(isMachineConstantPoolEntry() && \"Wrong constantpool type\");\n    return Val.MachineCPVal;\n  }\n\n  int getOffset() const {\n    return Offset & ~(1 << (sizeof(unsigned)*CHAR_BIT-1));\n  }\n\n  // Return the alignment of this constant pool object, which is either 0 (for\n  // default alignment) or the desired value.\n  Align getAlign() const { return Alignment; }\n  unsigned getTargetFlags() const { return TargetFlags; }\n\n  Type *getType() const;\n\n  static bool classof(const SDNode *N) {\n    return N->getOpcode() == ISD::ConstantPool ||\n           N->getOpcode() == ISD::TargetConstantPool;\n  }\n};\n\n/// Completely target-dependent object reference.\nclass TargetIndexSDNode : public SDNode {\n  friend class SelectionDAG;\n\n  unsigned TargetFlags;\n  int Index;\n  int64_t Offset;\n\npublic:\n  TargetIndexSDNode(int Idx, EVT VT, int64_t Ofs, unsigned TF)\n      : SDNode(ISD::TargetIndex, 0, DebugLoc(), getSDVTList(VT)),\n        TargetFlags(TF), Index(Idx), Offset(Ofs) {}\n\n  unsigned getTargetFlags() const { return TargetFlags; }\n  int getIndex() const { return Index; }\n  int64_t getOffset() const { return Offset; }\n\n  static bool classof(const SDNode *N) {\n    return N->getOpcode() == ISD::TargetIndex;\n  }\n};\n\nclass BasicBlockSDNode : public SDNode {\n  friend class SelectionDAG;\n\n  MachineBasicBlock *MBB;\n\n  /// Debug info is meaningful and potentially useful here, but we create\n  /// blocks out of order when they're jumped to, which makes it a bit\n  /// harder.  Let's see if we need it first.\n  explicit BasicBlockSDNode(MachineBasicBlock *mbb)\n    : SDNode(ISD::BasicBlock, 0, DebugLoc(), getSDVTList(MVT::Other)), MBB(mbb)\n  {}\n\npublic:\n  MachineBasicBlock *getBasicBlock() const { return MBB; }\n\n  static bool classof(const SDNode *N) {\n    return N->getOpcode() == ISD::BasicBlock;\n  }\n};\n\n/// A \"pseudo-class\" with methods for operating on BUILD_VECTORs.\nclass BuildVectorSDNode : public SDNode {\npublic:\n  // These are constructed as SDNodes and then cast to BuildVectorSDNodes.\n  explicit BuildVectorSDNode() = delete;\n\n  /// Check if this is a constant splat, and if so, find the\n  /// smallest element size that splats the vector.  If MinSplatBits is\n  /// nonzero, the element size must be at least that large.  Note that the\n  /// splat element may be the entire vector (i.e., a one element vector).\n  /// Returns the splat element value in SplatValue.  Any undefined bits in\n  /// that value are zero, and the corresponding bits in the SplatUndef mask\n  /// are set.  The SplatBitSize value is set to the splat element size in\n  /// bits.  HasAnyUndefs is set to true if any bits in the vector are\n  /// undefined.  isBigEndian describes the endianness of the target.\n  bool isConstantSplat(APInt &SplatValue, APInt &SplatUndef,\n                       unsigned &SplatBitSize, bool &HasAnyUndefs,\n                       unsigned MinSplatBits = 0,\n                       bool isBigEndian = false) const;\n\n  /// Returns the demanded splatted value or a null value if this is not a\n  /// splat.\n  ///\n  /// The DemandedElts mask indicates the elements that must be in the splat.\n  /// If passed a non-null UndefElements bitvector, it will resize it to match\n  /// the vector width and set the bits where elements are undef.\n  SDValue getSplatValue(const APInt &DemandedElts,\n                        BitVector *UndefElements = nullptr) const;\n\n  /// Returns the splatted value or a null value if this is not a splat.\n  ///\n  /// If passed a non-null UndefElements bitvector, it will resize it to match\n  /// the vector width and set the bits where elements are undef.\n  SDValue getSplatValue(BitVector *UndefElements = nullptr) const;\n\n  /// Find the shortest repeating sequence of values in the build vector.\n  ///\n  /// e.g. { u, X, u, X, u, u, X, u } -> { X }\n  ///      { X, Y, u, Y, u, u, X, u } -> { X, Y }\n  ///\n  /// Currently this must be a power-of-2 build vector.\n  /// The DemandedElts mask indicates the elements that must be present,\n  /// undemanded elements in Sequence may be null (SDValue()). If passed a\n  /// non-null UndefElements bitvector, it will resize it to match the original\n  /// vector width and set the bits where elements are undef. If result is\n  /// false, Sequence will be empty.\n  bool getRepeatedSequence(const APInt &DemandedElts,\n                           SmallVectorImpl<SDValue> &Sequence,\n                           BitVector *UndefElements = nullptr) const;\n\n  /// Find the shortest repeating sequence of values in the build vector.\n  ///\n  /// e.g. { u, X, u, X, u, u, X, u } -> { X }\n  ///      { X, Y, u, Y, u, u, X, u } -> { X, Y }\n  ///\n  /// Currently this must be a power-of-2 build vector.\n  /// If passed a non-null UndefElements bitvector, it will resize it to match\n  /// the original vector width and set the bits where elements are undef.\n  /// If result is false, Sequence will be empty.\n  bool getRepeatedSequence(SmallVectorImpl<SDValue> &Sequence,\n                           BitVector *UndefElements = nullptr) const;\n\n  /// Returns the demanded splatted constant or null if this is not a constant\n  /// splat.\n  ///\n  /// The DemandedElts mask indicates the elements that must be in the splat.\n  /// If passed a non-null UndefElements bitvector, it will resize it to match\n  /// the vector width and set the bits where elements are undef.\n  ConstantSDNode *\n  getConstantSplatNode(const APInt &DemandedElts,\n                       BitVector *UndefElements = nullptr) const;\n\n  /// Returns the splatted constant or null if this is not a constant\n  /// splat.\n  ///\n  /// If passed a non-null UndefElements bitvector, it will resize it to match\n  /// the vector width and set the bits where elements are undef.\n  ConstantSDNode *\n  getConstantSplatNode(BitVector *UndefElements = nullptr) const;\n\n  /// Returns the demanded splatted constant FP or null if this is not a\n  /// constant FP splat.\n  ///\n  /// The DemandedElts mask indicates the elements that must be in the splat.\n  /// If passed a non-null UndefElements bitvector, it will resize it to match\n  /// the vector width and set the bits where elements are undef.\n  ConstantFPSDNode *\n  getConstantFPSplatNode(const APInt &DemandedElts,\n                         BitVector *UndefElements = nullptr) const;\n\n  /// Returns the splatted constant FP or null if this is not a constant\n  /// FP splat.\n  ///\n  /// If passed a non-null UndefElements bitvector, it will resize it to match\n  /// the vector width and set the bits where elements are undef.\n  ConstantFPSDNode *\n  getConstantFPSplatNode(BitVector *UndefElements = nullptr) const;\n\n  /// If this is a constant FP splat and the splatted constant FP is an\n  /// exact power or 2, return the log base 2 integer value.  Otherwise,\n  /// return -1.\n  ///\n  /// The BitWidth specifies the necessary bit precision.\n  int32_t getConstantFPSplatPow2ToLog2Int(BitVector *UndefElements,\n                                          uint32_t BitWidth) const;\n\n  bool isConstant() const;\n\n  static bool classof(const SDNode *N) {\n    return N->getOpcode() == ISD::BUILD_VECTOR;\n  }\n};\n\n/// An SDNode that holds an arbitrary LLVM IR Value. This is\n/// used when the SelectionDAG needs to make a simple reference to something\n/// in the LLVM IR representation.\n///\nclass SrcValueSDNode : public SDNode {\n  friend class SelectionDAG;\n\n  const Value *V;\n\n  /// Create a SrcValue for a general value.\n  explicit SrcValueSDNode(const Value *v)\n    : SDNode(ISD::SRCVALUE, 0, DebugLoc(), getSDVTList(MVT::Other)), V(v) {}\n\npublic:\n  /// Return the contained Value.\n  const Value *getValue() const { return V; }\n\n  static bool classof(const SDNode *N) {\n    return N->getOpcode() == ISD::SRCVALUE;\n  }\n};\n\nclass MDNodeSDNode : public SDNode {\n  friend class SelectionDAG;\n\n  const MDNode *MD;\n\n  explicit MDNodeSDNode(const MDNode *md)\n  : SDNode(ISD::MDNODE_SDNODE, 0, DebugLoc(), getSDVTList(MVT::Other)), MD(md)\n  {}\n\npublic:\n  const MDNode *getMD() const { return MD; }\n\n  static bool classof(const SDNode *N) {\n    return N->getOpcode() == ISD::MDNODE_SDNODE;\n  }\n};\n\nclass RegisterSDNode : public SDNode {\n  friend class SelectionDAG;\n\n  Register Reg;\n\n  RegisterSDNode(Register reg, EVT VT)\n    : SDNode(ISD::Register, 0, DebugLoc(), getSDVTList(VT)), Reg(reg) {}\n\npublic:\n  Register getReg() const { return Reg; }\n\n  static bool classof(const SDNode *N) {\n    return N->getOpcode() == ISD::Register;\n  }\n};\n\nclass RegisterMaskSDNode : public SDNode {\n  friend class SelectionDAG;\n\n  // The memory for RegMask is not owned by the node.\n  const uint32_t *RegMask;\n\n  RegisterMaskSDNode(const uint32_t *mask)\n    : SDNode(ISD::RegisterMask, 0, DebugLoc(), getSDVTList(MVT::Untyped)),\n      RegMask(mask) {}\n\npublic:\n  const uint32_t *getRegMask() const { return RegMask; }\n\n  static bool classof(const SDNode *N) {\n    return N->getOpcode() == ISD::RegisterMask;\n  }\n};\n\nclass BlockAddressSDNode : public SDNode {\n  friend class SelectionDAG;\n\n  const BlockAddress *BA;\n  int64_t Offset;\n  unsigned TargetFlags;\n\n  BlockAddressSDNode(unsigned NodeTy, EVT VT, const BlockAddress *ba,\n                     int64_t o, unsigned Flags)\n    : SDNode(NodeTy, 0, DebugLoc(), getSDVTList(VT)),\n             BA(ba), Offset(o), TargetFlags(Flags) {}\n\npublic:\n  const BlockAddress *getBlockAddress() const { return BA; }\n  int64_t getOffset() const { return Offset; }\n  unsigned getTargetFlags() const { return TargetFlags; }\n\n  static bool classof(const SDNode *N) {\n    return N->getOpcode() == ISD::BlockAddress ||\n           N->getOpcode() == ISD::TargetBlockAddress;\n  }\n};\n\nclass LabelSDNode : public SDNode {\n  friend class SelectionDAG;\n\n  MCSymbol *Label;\n\n  LabelSDNode(unsigned Opcode, unsigned Order, const DebugLoc &dl, MCSymbol *L)\n      : SDNode(Opcode, Order, dl, getSDVTList(MVT::Other)), Label(L) {\n    assert(LabelSDNode::classof(this) && \"not a label opcode\");\n  }\n\npublic:\n  MCSymbol *getLabel() const { return Label; }\n\n  static bool classof(const SDNode *N) {\n    return N->getOpcode() == ISD::EH_LABEL ||\n           N->getOpcode() == ISD::ANNOTATION_LABEL;\n  }\n};\n\nclass ExternalSymbolSDNode : public SDNode {\n  friend class SelectionDAG;\n\n  const char *Symbol;\n  unsigned TargetFlags;\n\n  ExternalSymbolSDNode(bool isTarget, const char *Sym, unsigned TF, EVT VT)\n      : SDNode(isTarget ? ISD::TargetExternalSymbol : ISD::ExternalSymbol, 0,\n               DebugLoc(), getSDVTList(VT)),\n        Symbol(Sym), TargetFlags(TF) {}\n\npublic:\n  const char *getSymbol() const { return Symbol; }\n  unsigned getTargetFlags() const { return TargetFlags; }\n\n  static bool classof(const SDNode *N) {\n    return N->getOpcode() == ISD::ExternalSymbol ||\n           N->getOpcode() == ISD::TargetExternalSymbol;\n  }\n};\n\nclass MCSymbolSDNode : public SDNode {\n  friend class SelectionDAG;\n\n  MCSymbol *Symbol;\n\n  MCSymbolSDNode(MCSymbol *Symbol, EVT VT)\n      : SDNode(ISD::MCSymbol, 0, DebugLoc(), getSDVTList(VT)), Symbol(Symbol) {}\n\npublic:\n  MCSymbol *getMCSymbol() const { return Symbol; }\n\n  static bool classof(const SDNode *N) {\n    return N->getOpcode() == ISD::MCSymbol;\n  }\n};\n\nclass CondCodeSDNode : public SDNode {\n  friend class SelectionDAG;\n\n  ISD::CondCode Condition;\n\n  explicit CondCodeSDNode(ISD::CondCode Cond)\n    : SDNode(ISD::CONDCODE, 0, DebugLoc(), getSDVTList(MVT::Other)),\n      Condition(Cond) {}\n\npublic:\n  ISD::CondCode get() const { return Condition; }\n\n  static bool classof(const SDNode *N) {\n    return N->getOpcode() == ISD::CONDCODE;\n  }\n};\n\n/// This class is used to represent EVT's, which are used\n/// to parameterize some operations.\nclass VTSDNode : public SDNode {\n  friend class SelectionDAG;\n\n  EVT ValueType;\n\n  explicit VTSDNode(EVT VT)\n    : SDNode(ISD::VALUETYPE, 0, DebugLoc(), getSDVTList(MVT::Other)),\n      ValueType(VT) {}\n\npublic:\n  EVT getVT() const { return ValueType; }\n\n  static bool classof(const SDNode *N) {\n    return N->getOpcode() == ISD::VALUETYPE;\n  }\n};\n\n/// Base class for LoadSDNode and StoreSDNode\nclass LSBaseSDNode : public MemSDNode {\npublic:\n  LSBaseSDNode(ISD::NodeType NodeTy, unsigned Order, const DebugLoc &dl,\n               SDVTList VTs, ISD::MemIndexedMode AM, EVT MemVT,\n               MachineMemOperand *MMO)\n      : MemSDNode(NodeTy, Order, dl, VTs, MemVT, MMO) {\n    LSBaseSDNodeBits.AddressingMode = AM;\n    assert(getAddressingMode() == AM && \"Value truncated\");\n  }\n\n  const SDValue &getOffset() const {\n    return getOperand(getOpcode() == ISD::LOAD ? 2 : 3);\n  }\n\n  /// Return the addressing mode for this load or store:\n  /// unindexed, pre-inc, pre-dec, post-inc, or post-dec.\n  ISD::MemIndexedMode getAddressingMode() const {\n    return static_cast<ISD::MemIndexedMode>(LSBaseSDNodeBits.AddressingMode);\n  }\n\n  /// Return true if this is a pre/post inc/dec load/store.\n  bool isIndexed() const { return getAddressingMode() != ISD::UNINDEXED; }\n\n  /// Return true if this is NOT a pre/post inc/dec load/store.\n  bool isUnindexed() const { return getAddressingMode() == ISD::UNINDEXED; }\n\n  static bool classof(const SDNode *N) {\n    return N->getOpcode() == ISD::LOAD ||\n           N->getOpcode() == ISD::STORE;\n  }\n};\n\n/// This class is used to represent ISD::LOAD nodes.\nclass LoadSDNode : public LSBaseSDNode {\n  friend class SelectionDAG;\n\n  LoadSDNode(unsigned Order, const DebugLoc &dl, SDVTList VTs,\n             ISD::MemIndexedMode AM, ISD::LoadExtType ETy, EVT MemVT,\n             MachineMemOperand *MMO)\n      : LSBaseSDNode(ISD::LOAD, Order, dl, VTs, AM, MemVT, MMO) {\n    LoadSDNodeBits.ExtTy = ETy;\n    assert(readMem() && \"Load MachineMemOperand is not a load!\");\n    assert(!writeMem() && \"Load MachineMemOperand is a store!\");\n  }\n\npublic:\n  /// Return whether this is a plain node,\n  /// or one of the varieties of value-extending loads.\n  ISD::LoadExtType getExtensionType() const {\n    return static_cast<ISD::LoadExtType>(LoadSDNodeBits.ExtTy);\n  }\n\n  const SDValue &getBasePtr() const { return getOperand(1); }\n  const SDValue &getOffset() const { return getOperand(2); }\n\n  static bool classof(const SDNode *N) {\n    return N->getOpcode() == ISD::LOAD;\n  }\n};\n\n/// This class is used to represent ISD::STORE nodes.\nclass StoreSDNode : public LSBaseSDNode {\n  friend class SelectionDAG;\n\n  StoreSDNode(unsigned Order, const DebugLoc &dl, SDVTList VTs,\n              ISD::MemIndexedMode AM, bool isTrunc, EVT MemVT,\n              MachineMemOperand *MMO)\n      : LSBaseSDNode(ISD::STORE, Order, dl, VTs, AM, MemVT, MMO) {\n    StoreSDNodeBits.IsTruncating = isTrunc;\n    assert(!readMem() && \"Store MachineMemOperand is a load!\");\n    assert(writeMem() && \"Store MachineMemOperand is not a store!\");\n  }\n\npublic:\n  /// Return true if the op does a truncation before store.\n  /// For integers this is the same as doing a TRUNCATE and storing the result.\n  /// For floats, it is the same as doing an FP_ROUND and storing the result.\n  bool isTruncatingStore() const { return StoreSDNodeBits.IsTruncating; }\n  void setTruncatingStore(bool Truncating) {\n    StoreSDNodeBits.IsTruncating = Truncating;\n  }\n\n  const SDValue &getValue() const { return getOperand(1); }\n  const SDValue &getBasePtr() const { return getOperand(2); }\n  const SDValue &getOffset() const { return getOperand(3); }\n\n  static bool classof(const SDNode *N) {\n    return N->getOpcode() == ISD::STORE;\n  }\n};\n\n/// This base class is used to represent MLOAD and MSTORE nodes\nclass MaskedLoadStoreSDNode : public MemSDNode {\npublic:\n  friend class SelectionDAG;\n\n  MaskedLoadStoreSDNode(ISD::NodeType NodeTy, unsigned Order,\n                        const DebugLoc &dl, SDVTList VTs,\n                        ISD::MemIndexedMode AM, EVT MemVT,\n                        MachineMemOperand *MMO)\n      : MemSDNode(NodeTy, Order, dl, VTs, MemVT, MMO) {\n    LSBaseSDNodeBits.AddressingMode = AM;\n    assert(getAddressingMode() == AM && \"Value truncated\");\n  }\n\n  // MaskedLoadSDNode (Chain, ptr, offset, mask, passthru)\n  // MaskedStoreSDNode (Chain, data, ptr, offset, mask)\n  // Mask is a vector of i1 elements\n  const SDValue &getOffset() const {\n    return getOperand(getOpcode() == ISD::MLOAD ? 2 : 3);\n  }\n  const SDValue &getMask() const {\n    return getOperand(getOpcode() == ISD::MLOAD ? 3 : 4);\n  }\n\n  /// Return the addressing mode for this load or store:\n  /// unindexed, pre-inc, pre-dec, post-inc, or post-dec.\n  ISD::MemIndexedMode getAddressingMode() const {\n    return static_cast<ISD::MemIndexedMode>(LSBaseSDNodeBits.AddressingMode);\n  }\n\n  /// Return true if this is a pre/post inc/dec load/store.\n  bool isIndexed() const { return getAddressingMode() != ISD::UNINDEXED; }\n\n  /// Return true if this is NOT a pre/post inc/dec load/store.\n  bool isUnindexed() const { return getAddressingMode() == ISD::UNINDEXED; }\n\n  static bool classof(const SDNode *N) {\n    return N->getOpcode() == ISD::MLOAD ||\n           N->getOpcode() == ISD::MSTORE;\n  }\n};\n\n/// This class is used to represent an MLOAD node\nclass MaskedLoadSDNode : public MaskedLoadStoreSDNode {\npublic:\n  friend class SelectionDAG;\n\n  MaskedLoadSDNode(unsigned Order, const DebugLoc &dl, SDVTList VTs,\n                   ISD::MemIndexedMode AM, ISD::LoadExtType ETy,\n                   bool IsExpanding, EVT MemVT, MachineMemOperand *MMO)\n      : MaskedLoadStoreSDNode(ISD::MLOAD, Order, dl, VTs, AM, MemVT, MMO) {\n    LoadSDNodeBits.ExtTy = ETy;\n    LoadSDNodeBits.IsExpanding = IsExpanding;\n  }\n\n  ISD::LoadExtType getExtensionType() const {\n    return static_cast<ISD::LoadExtType>(LoadSDNodeBits.ExtTy);\n  }\n\n  const SDValue &getBasePtr() const { return getOperand(1); }\n  const SDValue &getOffset() const { return getOperand(2); }\n  const SDValue &getMask() const { return getOperand(3); }\n  const SDValue &getPassThru() const { return getOperand(4); }\n\n  static bool classof(const SDNode *N) {\n    return N->getOpcode() == ISD::MLOAD;\n  }\n\n  bool isExpandingLoad() const { return LoadSDNodeBits.IsExpanding; }\n};\n\n/// This class is used to represent an MSTORE node\nclass MaskedStoreSDNode : public MaskedLoadStoreSDNode {\npublic:\n  friend class SelectionDAG;\n\n  MaskedStoreSDNode(unsigned Order, const DebugLoc &dl, SDVTList VTs,\n                    ISD::MemIndexedMode AM, bool isTrunc, bool isCompressing,\n                    EVT MemVT, MachineMemOperand *MMO)\n      : MaskedLoadStoreSDNode(ISD::MSTORE, Order, dl, VTs, AM, MemVT, MMO) {\n    StoreSDNodeBits.IsTruncating = isTrunc;\n    StoreSDNodeBits.IsCompressing = isCompressing;\n  }\n\n  /// Return true if the op does a truncation before store.\n  /// For integers this is the same as doing a TRUNCATE and storing the result.\n  /// For floats, it is the same as doing an FP_ROUND and storing the result.\n  bool isTruncatingStore() const { return StoreSDNodeBits.IsTruncating; }\n\n  /// Returns true if the op does a compression to the vector before storing.\n  /// The node contiguously stores the active elements (integers or floats)\n  /// in src (those with their respective bit set in writemask k) to unaligned\n  /// memory at base_addr.\n  bool isCompressingStore() const { return StoreSDNodeBits.IsCompressing; }\n\n  const SDValue &getValue() const { return getOperand(1); }\n  const SDValue &getBasePtr() const { return getOperand(2); }\n  const SDValue &getOffset() const { return getOperand(3); }\n  const SDValue &getMask() const { return getOperand(4); }\n\n  static bool classof(const SDNode *N) {\n    return N->getOpcode() == ISD::MSTORE;\n  }\n};\n\n/// This is a base class used to represent\n/// MGATHER and MSCATTER nodes\n///\nclass MaskedGatherScatterSDNode : public MemSDNode {\npublic:\n  friend class SelectionDAG;\n\n  MaskedGatherScatterSDNode(ISD::NodeType NodeTy, unsigned Order,\n                            const DebugLoc &dl, SDVTList VTs, EVT MemVT,\n                            MachineMemOperand *MMO, ISD::MemIndexType IndexType)\n      : MemSDNode(NodeTy, Order, dl, VTs, MemVT, MMO) {\n    LSBaseSDNodeBits.AddressingMode = IndexType;\n    assert(getIndexType() == IndexType && \"Value truncated\");\n  }\n\n  /// How is Index applied to BasePtr when computing addresses.\n  ISD::MemIndexType getIndexType() const {\n    return static_cast<ISD::MemIndexType>(LSBaseSDNodeBits.AddressingMode);\n  }\n  void setIndexType(ISD::MemIndexType IndexType) {\n    LSBaseSDNodeBits.AddressingMode = IndexType;\n  }\n  bool isIndexScaled() const {\n    return (getIndexType() == ISD::SIGNED_SCALED) ||\n           (getIndexType() == ISD::UNSIGNED_SCALED);\n  }\n  bool isIndexSigned() const {\n    return (getIndexType() == ISD::SIGNED_SCALED) ||\n           (getIndexType() == ISD::SIGNED_UNSCALED);\n  }\n\n  // In the both nodes address is Op1, mask is Op2:\n  // MaskedGatherSDNode  (Chain, passthru, mask, base, index, scale)\n  // MaskedScatterSDNode (Chain, value, mask, base, index, scale)\n  // Mask is a vector of i1 elements\n  const SDValue &getBasePtr() const { return getOperand(3); }\n  const SDValue &getIndex()   const { return getOperand(4); }\n  const SDValue &getMask()    const { return getOperand(2); }\n  const SDValue &getScale()   const { return getOperand(5); }\n\n  static bool classof(const SDNode *N) {\n    return N->getOpcode() == ISD::MGATHER ||\n           N->getOpcode() == ISD::MSCATTER;\n  }\n};\n\n/// This class is used to represent an MGATHER node\n///\nclass MaskedGatherSDNode : public MaskedGatherScatterSDNode {\npublic:\n  friend class SelectionDAG;\n\n  MaskedGatherSDNode(unsigned Order, const DebugLoc &dl, SDVTList VTs,\n                     EVT MemVT, MachineMemOperand *MMO,\n                     ISD::MemIndexType IndexType, ISD::LoadExtType ETy)\n      : MaskedGatherScatterSDNode(ISD::MGATHER, Order, dl, VTs, MemVT, MMO,\n                                  IndexType) {\n    LoadSDNodeBits.ExtTy = ETy;\n  }\n\n  const SDValue &getPassThru() const { return getOperand(1); }\n\n  ISD::LoadExtType getExtensionType() const {\n    return ISD::LoadExtType(LoadSDNodeBits.ExtTy);\n  }\n\n  static bool classof(const SDNode *N) {\n    return N->getOpcode() == ISD::MGATHER;\n  }\n};\n\n/// This class is used to represent an MSCATTER node\n///\nclass MaskedScatterSDNode : public MaskedGatherScatterSDNode {\npublic:\n  friend class SelectionDAG;\n\n  MaskedScatterSDNode(unsigned Order, const DebugLoc &dl, SDVTList VTs,\n                      EVT MemVT, MachineMemOperand *MMO,\n                      ISD::MemIndexType IndexType, bool IsTrunc)\n      : MaskedGatherScatterSDNode(ISD::MSCATTER, Order, dl, VTs, MemVT, MMO,\n                                  IndexType) {\n    StoreSDNodeBits.IsTruncating = IsTrunc;\n  }\n\n  /// Return true if the op does a truncation before store.\n  /// For integers this is the same as doing a TRUNCATE and storing the result.\n  /// For floats, it is the same as doing an FP_ROUND and storing the result.\n  bool isTruncatingStore() const { return StoreSDNodeBits.IsTruncating; }\n\n  const SDValue &getValue() const { return getOperand(1); }\n\n  static bool classof(const SDNode *N) {\n    return N->getOpcode() == ISD::MSCATTER;\n  }\n};\n\n/// An SDNode that represents everything that will be needed\n/// to construct a MachineInstr. These nodes are created during the\n/// instruction selection proper phase.\n///\n/// Note that the only supported way to set the `memoperands` is by calling the\n/// `SelectionDAG::setNodeMemRefs` function as the memory management happens\n/// inside the DAG rather than in the node.\nclass MachineSDNode : public SDNode {\nprivate:\n  friend class SelectionDAG;\n\n  MachineSDNode(unsigned Opc, unsigned Order, const DebugLoc &DL, SDVTList VTs)\n      : SDNode(Opc, Order, DL, VTs) {}\n\n  // We use a pointer union between a single `MachineMemOperand` pointer and\n  // a pointer to an array of `MachineMemOperand` pointers. This is null when\n  // the number of these is zero, the single pointer variant used when the\n  // number is one, and the array is used for larger numbers.\n  //\n  // The array is allocated via the `SelectionDAG`'s allocator and so will\n  // always live until the DAG is cleaned up and doesn't require ownership here.\n  //\n  // We can't use something simpler like `TinyPtrVector` here because `SDNode`\n  // subclasses aren't managed in a conforming C++ manner. See the comments on\n  // `SelectionDAG::MorphNodeTo` which details what all goes on, but the\n  // constraint here is that these don't manage memory with their constructor or\n  // destructor and can be initialized to a good state even if they start off\n  // uninitialized.\n  PointerUnion<MachineMemOperand *, MachineMemOperand **> MemRefs = {};\n\n  // Note that this could be folded into the above `MemRefs` member if doing so\n  // is advantageous at some point. We don't need to store this in most cases.\n  // However, at the moment this doesn't appear to make the allocation any\n  // smaller and makes the code somewhat simpler to read.\n  int NumMemRefs = 0;\n\npublic:\n  using mmo_iterator = ArrayRef<MachineMemOperand *>::const_iterator;\n\n  ArrayRef<MachineMemOperand *> memoperands() const {\n    // Special case the common cases.\n    if (NumMemRefs == 0)\n      return {};\n    if (NumMemRefs == 1)\n      return makeArrayRef(MemRefs.getAddrOfPtr1(), 1);\n\n    // Otherwise we have an actual array.\n    return makeArrayRef(MemRefs.get<MachineMemOperand **>(), NumMemRefs);\n  }\n  mmo_iterator memoperands_begin() const { return memoperands().begin(); }\n  mmo_iterator memoperands_end() const { return memoperands().end(); }\n  bool memoperands_empty() const { return memoperands().empty(); }\n\n  /// Clear out the memory reference descriptor list.\n  void clearMemRefs() {\n    MemRefs = nullptr;\n    NumMemRefs = 0;\n  }\n\n  static bool classof(const SDNode *N) {\n    return N->isMachineOpcode();\n  }\n};\n\n/// An SDNode that records if a register contains a value that is guaranteed to\n/// be aligned accordingly.\nclass AssertAlignSDNode : public SDNode {\n  Align Alignment;\n\npublic:\n  AssertAlignSDNode(unsigned Order, const DebugLoc &DL, EVT VT, Align A)\n      : SDNode(ISD::AssertAlign, Order, DL, getSDVTList(VT)), Alignment(A) {}\n\n  Align getAlign() const { return Alignment; }\n\n  static bool classof(const SDNode *N) {\n    return N->getOpcode() == ISD::AssertAlign;\n  }\n};\n\nclass SDNodeIterator : public std::iterator<std::forward_iterator_tag,\n                                            SDNode, ptrdiff_t> {\n  const SDNode *Node;\n  unsigned Operand;\n\n  SDNodeIterator(const SDNode *N, unsigned Op) : Node(N), Operand(Op) {}\n\npublic:\n  bool operator==(const SDNodeIterator& x) const {\n    return Operand == x.Operand;\n  }\n  bool operator!=(const SDNodeIterator& x) const { return !operator==(x); }\n\n  pointer operator*() const {\n    return Node->getOperand(Operand).getNode();\n  }\n  pointer operator->() const { return operator*(); }\n\n  SDNodeIterator& operator++() {                // Preincrement\n    ++Operand;\n    return *this;\n  }\n  SDNodeIterator operator++(int) { // Postincrement\n    SDNodeIterator tmp = *this; ++*this; return tmp;\n  }\n  size_t operator-(SDNodeIterator Other) const {\n    assert(Node == Other.Node &&\n           \"Cannot compare iterators of two different nodes!\");\n    return Operand - Other.Operand;\n  }\n\n  static SDNodeIterator begin(const SDNode *N) { return SDNodeIterator(N, 0); }\n  static SDNodeIterator end  (const SDNode *N) {\n    return SDNodeIterator(N, N->getNumOperands());\n  }\n\n  unsigned getOperand() const { return Operand; }\n  const SDNode *getNode() const { return Node; }\n};\n\ntemplate <> struct GraphTraits<SDNode*> {\n  using NodeRef = SDNode *;\n  using ChildIteratorType = SDNodeIterator;\n\n  static NodeRef getEntryNode(SDNode *N) { return N; }\n\n  static ChildIteratorType child_begin(NodeRef N) {\n    return SDNodeIterator::begin(N);\n  }\n\n  static ChildIteratorType child_end(NodeRef N) {\n    return SDNodeIterator::end(N);\n  }\n};\n\n/// A representation of the largest SDNode, for use in sizeof().\n///\n/// This needs to be a union because the largest node differs on 32 bit systems\n/// with 4 and 8 byte pointer alignment, respectively.\nusing LargestSDNode = AlignedCharArrayUnion<AtomicSDNode, TargetIndexSDNode,\n                                            BlockAddressSDNode,\n                                            GlobalAddressSDNode,\n                                            PseudoProbeSDNode>;\n\n/// The SDNode class with the greatest alignment requirement.\nusing MostAlignedSDNode = GlobalAddressSDNode;\n\nnamespace ISD {\n\n  /// Returns true if the specified node is a non-extending and unindexed load.\n  inline bool isNormalLoad(const SDNode *N) {\n    const LoadSDNode *Ld = dyn_cast<LoadSDNode>(N);\n    return Ld && Ld->getExtensionType() == ISD::NON_EXTLOAD &&\n      Ld->getAddressingMode() == ISD::UNINDEXED;\n  }\n\n  /// Returns true if the specified node is a non-extending load.\n  inline bool isNON_EXTLoad(const SDNode *N) {\n    return isa<LoadSDNode>(N) &&\n      cast<LoadSDNode>(N)->getExtensionType() == ISD::NON_EXTLOAD;\n  }\n\n  /// Returns true if the specified node is a EXTLOAD.\n  inline bool isEXTLoad(const SDNode *N) {\n    return isa<LoadSDNode>(N) &&\n      cast<LoadSDNode>(N)->getExtensionType() == ISD::EXTLOAD;\n  }\n\n  /// Returns true if the specified node is a SEXTLOAD.\n  inline bool isSEXTLoad(const SDNode *N) {\n    return isa<LoadSDNode>(N) &&\n      cast<LoadSDNode>(N)->getExtensionType() == ISD::SEXTLOAD;\n  }\n\n  /// Returns true if the specified node is a ZEXTLOAD.\n  inline bool isZEXTLoad(const SDNode *N) {\n    return isa<LoadSDNode>(N) &&\n      cast<LoadSDNode>(N)->getExtensionType() == ISD::ZEXTLOAD;\n  }\n\n  /// Returns true if the specified node is an unindexed load.\n  inline bool isUNINDEXEDLoad(const SDNode *N) {\n    return isa<LoadSDNode>(N) &&\n      cast<LoadSDNode>(N)->getAddressingMode() == ISD::UNINDEXED;\n  }\n\n  /// Returns true if the specified node is a non-truncating\n  /// and unindexed store.\n  inline bool isNormalStore(const SDNode *N) {\n    const StoreSDNode *St = dyn_cast<StoreSDNode>(N);\n    return St && !St->isTruncatingStore() &&\n      St->getAddressingMode() == ISD::UNINDEXED;\n  }\n\n  /// Returns true if the specified node is a non-truncating store.\n  inline bool isNON_TRUNCStore(const SDNode *N) {\n    return isa<StoreSDNode>(N) && !cast<StoreSDNode>(N)->isTruncatingStore();\n  }\n\n  /// Returns true if the specified node is a truncating store.\n  inline bool isTRUNCStore(const SDNode *N) {\n    return isa<StoreSDNode>(N) && cast<StoreSDNode>(N)->isTruncatingStore();\n  }\n\n  /// Returns true if the specified node is an unindexed store.\n  inline bool isUNINDEXEDStore(const SDNode *N) {\n    return isa<StoreSDNode>(N) &&\n      cast<StoreSDNode>(N)->getAddressingMode() == ISD::UNINDEXED;\n  }\n\n  /// Attempt to match a unary predicate against a scalar/splat constant or\n  /// every element of a constant BUILD_VECTOR.\n  /// If AllowUndef is true, then UNDEF elements will pass nullptr to Match.\n  bool matchUnaryPredicate(SDValue Op,\n                           std::function<bool(ConstantSDNode *)> Match,\n                           bool AllowUndefs = false);\n\n  /// Attempt to match a binary predicate against a pair of scalar/splat\n  /// constants or every element of a pair of constant BUILD_VECTORs.\n  /// If AllowUndef is true, then UNDEF elements will pass nullptr to Match.\n  /// If AllowTypeMismatch is true then RetType + ArgTypes don't need to match.\n  bool matchBinaryPredicate(\n      SDValue LHS, SDValue RHS,\n      std::function<bool(ConstantSDNode *, ConstantSDNode *)> Match,\n      bool AllowUndefs = false, bool AllowTypeMismatch = false);\n\n  /// Returns true if the specified value is the overflow result from one\n  /// of the overflow intrinsic nodes.\n  inline bool isOverflowIntrOpRes(SDValue Op) {\n    unsigned Opc = Op.getOpcode();\n    return (Op.getResNo() == 1 &&\n            (Opc == ISD::SADDO || Opc == ISD::UADDO || Opc == ISD::SSUBO ||\n             Opc == ISD::USUBO || Opc == ISD::SMULO || Opc == ISD::UMULO));\n  }\n\n} // end namespace ISD\n\n} // end namespace llvm\n\n#endif // LLVM_CODEGEN_SELECTIONDAGNODES_H\n"}, "84": {"id": 84, "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp", "content": "//===- SelectionDAG.cpp - Implement the SelectionDAG data structures ------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This implements the SelectionDAG class.\n//\n//===----------------------------------------------------------------------===//\n\n#include \"llvm/CodeGen/SelectionDAG.h\"\n#include \"SDNodeDbgValue.h\"\n#include \"llvm/ADT/APFloat.h\"\n#include \"llvm/ADT/APInt.h\"\n#include \"llvm/ADT/APSInt.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/BitVector.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/Triple.h\"\n#include \"llvm/ADT/Twine.h\"\n#include \"llvm/Analysis/BlockFrequencyInfo.h\"\n#include \"llvm/Analysis/MemoryLocation.h\"\n#include \"llvm/Analysis/ProfileSummaryInfo.h\"\n#include \"llvm/Analysis/ValueTracking.h\"\n#include \"llvm/CodeGen/FunctionLoweringInfo.h\"\n#include \"llvm/CodeGen/ISDOpcodes.h\"\n#include \"llvm/CodeGen/MachineBasicBlock.h\"\n#include \"llvm/CodeGen/MachineConstantPool.h\"\n#include \"llvm/CodeGen/MachineFrameInfo.h\"\n#include \"llvm/CodeGen/MachineFunction.h\"\n#include \"llvm/CodeGen/MachineMemOperand.h\"\n#include \"llvm/CodeGen/RuntimeLibcalls.h\"\n#include \"llvm/CodeGen/SelectionDAGAddressAnalysis.h\"\n#include \"llvm/CodeGen/SelectionDAGNodes.h\"\n#include \"llvm/CodeGen/SelectionDAGTargetInfo.h\"\n#include \"llvm/CodeGen/TargetFrameLowering.h\"\n#include \"llvm/CodeGen/TargetLowering.h\"\n#include \"llvm/CodeGen/TargetRegisterInfo.h\"\n#include \"llvm/CodeGen/TargetSubtargetInfo.h\"\n#include \"llvm/CodeGen/ValueTypes.h\"\n#include \"llvm/IR/Constant.h\"\n#include \"llvm/IR/Constants.h\"\n#include \"llvm/IR/DataLayout.h\"\n#include \"llvm/IR/DebugInfoMetadata.h\"\n#include \"llvm/IR/DebugLoc.h\"\n#include \"llvm/IR/DerivedTypes.h\"\n#include \"llvm/IR/Function.h\"\n#include \"llvm/IR/GlobalValue.h\"\n#include \"llvm/IR/Metadata.h\"\n#include \"llvm/IR/Type.h\"\n#include \"llvm/IR/Value.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/CodeGen.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/Debug.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/KnownBits.h\"\n#include \"llvm/Support/MachineValueType.h\"\n#include \"llvm/Support/ManagedStatic.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include \"llvm/Support/Mutex.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include \"llvm/Target/TargetMachine.h\"\n#include \"llvm/Target/TargetOptions.h\"\n#include \"llvm/Transforms/Utils/SizeOpts.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstdint>\n#include <cstdlib>\n#include <limits>\n#include <set>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace llvm;\n\n/// makeVTList - Return an instance of the SDVTList struct initialized with the\n/// specified members.\nstatic SDVTList makeVTList(const EVT *VTs, unsigned NumVTs) {\n  SDVTList Res = {VTs, NumVTs};\n  return Res;\n}\n\n// Default null implementations of the callbacks.\nvoid SelectionDAG::DAGUpdateListener::NodeDeleted(SDNode*, SDNode*) {}\nvoid SelectionDAG::DAGUpdateListener::NodeUpdated(SDNode*) {}\nvoid SelectionDAG::DAGUpdateListener::NodeInserted(SDNode *) {}\n\nvoid SelectionDAG::DAGNodeDeletedListener::anchor() {}\n\n#define DEBUG_TYPE \"selectiondag\"\n\nstatic cl::opt<bool> EnableMemCpyDAGOpt(\"enable-memcpy-dag-opt\",\n       cl::Hidden, cl::init(true),\n       cl::desc(\"Gang up loads and stores generated by inlining of memcpy\"));\n\nstatic cl::opt<int> MaxLdStGlue(\"ldstmemcpy-glue-max\",\n       cl::desc(\"Number limit for gluing ld/st of memcpy.\"),\n       cl::Hidden, cl::init(0));\n\nstatic void NewSDValueDbgMsg(SDValue V, StringRef Msg, SelectionDAG *G) {\n  LLVM_DEBUG(dbgs() << Msg; V.getNode()->dump(G););\n}\n\n//===----------------------------------------------------------------------===//\n//                              ConstantFPSDNode Class\n//===----------------------------------------------------------------------===//\n\n/// isExactlyValue - We don't rely on operator== working on double values, as\n/// it returns true for things that are clearly not equal, like -0.0 and 0.0.\n/// As such, this method can be used to do an exact bit-for-bit comparison of\n/// two floating point values.\nbool ConstantFPSDNode::isExactlyValue(const APFloat& V) const {\n  return getValueAPF().bitwiseIsEqual(V);\n}\n\nbool ConstantFPSDNode::isValueValidForType(EVT VT,\n                                           const APFloat& Val) {\n  assert(VT.isFloatingPoint() && \"Can only convert between FP types\");\n\n  // convert modifies in place, so make a copy.\n  APFloat Val2 = APFloat(Val);\n  bool losesInfo;\n  (void) Val2.convert(SelectionDAG::EVTToAPFloatSemantics(VT),\n                      APFloat::rmNearestTiesToEven,\n                      &losesInfo);\n  return !losesInfo;\n}\n\n//===----------------------------------------------------------------------===//\n//                              ISD Namespace\n//===----------------------------------------------------------------------===//\n\nbool ISD::isConstantSplatVector(const SDNode *N, APInt &SplatVal) {\n  if (N->getOpcode() == ISD::SPLAT_VECTOR) {\n    unsigned EltSize =\n        N->getValueType(0).getVectorElementType().getSizeInBits();\n    if (auto *Op0 = dyn_cast<ConstantSDNode>(N->getOperand(0))) {\n      SplatVal = Op0->getAPIntValue().truncOrSelf(EltSize);\n      return true;\n    }\n  }\n\n  auto *BV = dyn_cast<BuildVectorSDNode>(N);\n  if (!BV)\n    return false;\n\n  APInt SplatUndef;\n  unsigned SplatBitSize;\n  bool HasUndefs;\n  unsigned EltSize = N->getValueType(0).getVectorElementType().getSizeInBits();\n  return BV->isConstantSplat(SplatVal, SplatUndef, SplatBitSize, HasUndefs,\n                             EltSize) &&\n         EltSize == SplatBitSize;\n}\n\n// FIXME: AllOnes and AllZeros duplicate a lot of code. Could these be\n// specializations of the more general isConstantSplatVector()?\n\nbool ISD::isConstantSplatVectorAllOnes(const SDNode *N, bool BuildVectorOnly) {\n  // Look through a bit convert.\n  while (N->getOpcode() == ISD::BITCAST)\n    N = N->getOperand(0).getNode();\n\n  if (!BuildVectorOnly && N->getOpcode() == ISD::SPLAT_VECTOR) {\n    APInt SplatVal;\n    return isConstantSplatVector(N, SplatVal) && SplatVal.isAllOnesValue();\n  }\n\n  if (N->getOpcode() != ISD::BUILD_VECTOR) return false;\n\n  unsigned i = 0, e = N->getNumOperands();\n\n  // Skip over all of the undef values.\n  while (i != e && N->getOperand(i).isUndef())\n    ++i;\n\n  // Do not accept an all-undef vector.\n  if (i == e) return false;\n\n  // Do not accept build_vectors that aren't all constants or which have non-~0\n  // elements. We have to be a bit careful here, as the type of the constant\n  // may not be the same as the type of the vector elements due to type\n  // legalization (the elements are promoted to a legal type for the target and\n  // a vector of a type may be legal when the base element type is not).\n  // We only want to check enough bits to cover the vector elements, because\n  // we care if the resultant vector is all ones, not whether the individual\n  // constants are.\n  SDValue NotZero = N->getOperand(i);\n  unsigned EltSize = N->getValueType(0).getScalarSizeInBits();\n  if (ConstantSDNode *CN = dyn_cast<ConstantSDNode>(NotZero)) {\n    if (CN->getAPIntValue().countTrailingOnes() < EltSize)\n      return false;\n  } else if (ConstantFPSDNode *CFPN = dyn_cast<ConstantFPSDNode>(NotZero)) {\n    if (CFPN->getValueAPF().bitcastToAPInt().countTrailingOnes() < EltSize)\n      return false;\n  } else\n    return false;\n\n  // Okay, we have at least one ~0 value, check to see if the rest match or are\n  // undefs. Even with the above element type twiddling, this should be OK, as\n  // the same type legalization should have applied to all the elements.\n  for (++i; i != e; ++i)\n    if (N->getOperand(i) != NotZero && !N->getOperand(i).isUndef())\n      return false;\n  return true;\n}\n\nbool ISD::isConstantSplatVectorAllZeros(const SDNode *N, bool BuildVectorOnly) {\n  // Look through a bit convert.\n  while (N->getOpcode() == ISD::BITCAST)\n    N = N->getOperand(0).getNode();\n\n  if (!BuildVectorOnly && N->getOpcode() == ISD::SPLAT_VECTOR) {\n    APInt SplatVal;\n    return isConstantSplatVector(N, SplatVal) && SplatVal.isNullValue();\n  }\n\n  if (N->getOpcode() != ISD::BUILD_VECTOR) return false;\n\n  bool IsAllUndef = true;\n  for (const SDValue &Op : N->op_values()) {\n    if (Op.isUndef())\n      continue;\n    IsAllUndef = false;\n    // Do not accept build_vectors that aren't all constants or which have non-0\n    // elements. We have to be a bit careful here, as the type of the constant\n    // may not be the same as the type of the vector elements due to type\n    // legalization (the elements are promoted to a legal type for the target\n    // and a vector of a type may be legal when the base element type is not).\n    // We only want to check enough bits to cover the vector elements, because\n    // we care if the resultant vector is all zeros, not whether the individual\n    // constants are.\n    unsigned EltSize = N->getValueType(0).getScalarSizeInBits();\n    if (ConstantSDNode *CN = dyn_cast<ConstantSDNode>(Op)) {\n      if (CN->getAPIntValue().countTrailingZeros() < EltSize)\n        return false;\n    } else if (ConstantFPSDNode *CFPN = dyn_cast<ConstantFPSDNode>(Op)) {\n      if (CFPN->getValueAPF().bitcastToAPInt().countTrailingZeros() < EltSize)\n        return false;\n    } else\n      return false;\n  }\n\n  // Do not accept an all-undef vector.\n  if (IsAllUndef)\n    return false;\n  return true;\n}\n\nbool ISD::isBuildVectorAllOnes(const SDNode *N) {\n  return isConstantSplatVectorAllOnes(N, /*BuildVectorOnly*/ true);\n}\n\nbool ISD::isBuildVectorAllZeros(const SDNode *N) {\n  return isConstantSplatVectorAllZeros(N, /*BuildVectorOnly*/ true);\n}\n\nbool ISD::isBuildVectorOfConstantSDNodes(const SDNode *N) {\n  if (N->getOpcode() != ISD::BUILD_VECTOR)\n    return false;\n\n  for (const SDValue &Op : N->op_values()) {\n    if (Op.isUndef())\n      continue;\n    if (!isa<ConstantSDNode>(Op))\n      return false;\n  }\n  return true;\n}\n\nbool ISD::isBuildVectorOfConstantFPSDNodes(const SDNode *N) {\n  if (N->getOpcode() != ISD::BUILD_VECTOR)\n    return false;\n\n  for (const SDValue &Op : N->op_values()) {\n    if (Op.isUndef())\n      continue;\n    if (!isa<ConstantFPSDNode>(Op))\n      return false;\n  }\n  return true;\n}\n\nbool ISD::allOperandsUndef(const SDNode *N) {\n  // Return false if the node has no operands.\n  // This is \"logically inconsistent\" with the definition of \"all\" but\n  // is probably the desired behavior.\n  if (N->getNumOperands() == 0)\n    return false;\n  return all_of(N->op_values(), [](SDValue Op) { return Op.isUndef(); });\n}\n\nbool ISD::matchUnaryPredicate(SDValue Op,\n                              std::function<bool(ConstantSDNode *)> Match,\n                              bool AllowUndefs) {\n  // FIXME: Add support for scalar UNDEF cases?\n  if (auto *Cst = dyn_cast<ConstantSDNode>(Op))\n    return Match(Cst);\n\n  // FIXME: Add support for vector UNDEF cases?\n  if (ISD::BUILD_VECTOR != Op.getOpcode() &&\n      ISD::SPLAT_VECTOR != Op.getOpcode())\n    return false;\n\n  EVT SVT = Op.getValueType().getScalarType();\n  for (unsigned i = 0, e = Op.getNumOperands(); i != e; ++i) {\n    if (AllowUndefs && Op.getOperand(i).isUndef()) {\n      if (!Match(nullptr))\n        return false;\n      continue;\n    }\n\n    auto *Cst = dyn_cast<ConstantSDNode>(Op.getOperand(i));\n    if (!Cst || Cst->getValueType(0) != SVT || !Match(Cst))\n      return false;\n  }\n  return true;\n}\n\nbool ISD::matchBinaryPredicate(\n    SDValue LHS, SDValue RHS,\n    std::function<bool(ConstantSDNode *, ConstantSDNode *)> Match,\n    bool AllowUndefs, bool AllowTypeMismatch) {\n  if (!AllowTypeMismatch && LHS.getValueType() != RHS.getValueType())\n    return false;\n\n  // TODO: Add support for scalar UNDEF cases?\n  if (auto *LHSCst = dyn_cast<ConstantSDNode>(LHS))\n    if (auto *RHSCst = dyn_cast<ConstantSDNode>(RHS))\n      return Match(LHSCst, RHSCst);\n\n  // TODO: Add support for vector UNDEF cases?\n  if (ISD::BUILD_VECTOR != LHS.getOpcode() ||\n      ISD::BUILD_VECTOR != RHS.getOpcode())\n    return false;\n\n  EVT SVT = LHS.getValueType().getScalarType();\n  for (unsigned i = 0, e = LHS.getNumOperands(); i != e; ++i) {\n    SDValue LHSOp = LHS.getOperand(i);\n    SDValue RHSOp = RHS.getOperand(i);\n    bool LHSUndef = AllowUndefs && LHSOp.isUndef();\n    bool RHSUndef = AllowUndefs && RHSOp.isUndef();\n    auto *LHSCst = dyn_cast<ConstantSDNode>(LHSOp);\n    auto *RHSCst = dyn_cast<ConstantSDNode>(RHSOp);\n    if ((!LHSCst && !LHSUndef) || (!RHSCst && !RHSUndef))\n      return false;\n    if (!AllowTypeMismatch && (LHSOp.getValueType() != SVT ||\n                               LHSOp.getValueType() != RHSOp.getValueType()))\n      return false;\n    if (!Match(LHSCst, RHSCst))\n      return false;\n  }\n  return true;\n}\n\nISD::NodeType ISD::getVecReduceBaseOpcode(unsigned VecReduceOpcode) {\n  switch (VecReduceOpcode) {\n  default:\n    llvm_unreachable(\"Expected VECREDUCE opcode\");\n  case ISD::VECREDUCE_FADD:\n  case ISD::VECREDUCE_SEQ_FADD:\n    return ISD::FADD;\n  case ISD::VECREDUCE_FMUL:\n  case ISD::VECREDUCE_SEQ_FMUL:\n    return ISD::FMUL;\n  case ISD::VECREDUCE_ADD:\n    return ISD::ADD;\n  case ISD::VECREDUCE_MUL:\n    return ISD::MUL;\n  case ISD::VECREDUCE_AND:\n    return ISD::AND;\n  case ISD::VECREDUCE_OR:\n    return ISD::OR;\n  case ISD::VECREDUCE_XOR:\n    return ISD::XOR;\n  case ISD::VECREDUCE_SMAX:\n    return ISD::SMAX;\n  case ISD::VECREDUCE_SMIN:\n    return ISD::SMIN;\n  case ISD::VECREDUCE_UMAX:\n    return ISD::UMAX;\n  case ISD::VECREDUCE_UMIN:\n    return ISD::UMIN;\n  case ISD::VECREDUCE_FMAX:\n    return ISD::FMAXNUM;\n  case ISD::VECREDUCE_FMIN:\n    return ISD::FMINNUM;\n  }\n}\n\nbool ISD::isVPOpcode(unsigned Opcode) {\n  switch (Opcode) {\n  default:\n    return false;\n#define BEGIN_REGISTER_VP_SDNODE(SDOPC, ...)                                   \\\n  case ISD::SDOPC:                                                             \\\n    return true;\n#include \"llvm/IR/VPIntrinsics.def\"\n  }\n}\n\n/// The operand position of the vector mask.\nOptional<unsigned> ISD::getVPMaskIdx(unsigned Opcode) {\n  switch (Opcode) {\n  default:\n    return None;\n#define BEGIN_REGISTER_VP_SDNODE(SDOPC, LEGALPOS, TDNAME, MASKPOS, ...)        \\\n  case ISD::SDOPC:                                                             \\\n    return MASKPOS;\n#include \"llvm/IR/VPIntrinsics.def\"\n  }\n}\n\n/// The operand position of the explicit vector length parameter.\nOptional<unsigned> ISD::getVPExplicitVectorLengthIdx(unsigned Opcode) {\n  switch (Opcode) {\n  default:\n    return None;\n#define BEGIN_REGISTER_VP_SDNODE(SDOPC, LEGALPOS, TDNAME, MASKPOS, EVLPOS)     \\\n  case ISD::SDOPC:                                                             \\\n    return EVLPOS;\n#include \"llvm/IR/VPIntrinsics.def\"\n  }\n}\n\nISD::NodeType ISD::getExtForLoadExtType(bool IsFP, ISD::LoadExtType ExtType) {\n  switch (ExtType) {\n  case ISD::EXTLOAD:\n    return IsFP ? ISD::FP_EXTEND : ISD::ANY_EXTEND;\n  case ISD::SEXTLOAD:\n    return ISD::SIGN_EXTEND;\n  case ISD::ZEXTLOAD:\n    return ISD::ZERO_EXTEND;\n  default:\n    break;\n  }\n\n  llvm_unreachable(\"Invalid LoadExtType\");\n}\n\nISD::CondCode ISD::getSetCCSwappedOperands(ISD::CondCode Operation) {\n  // To perform this operation, we just need to swap the L and G bits of the\n  // operation.\n  unsigned OldL = (Operation >> 2) & 1;\n  unsigned OldG = (Operation >> 1) & 1;\n  return ISD::CondCode((Operation & ~6) |  // Keep the N, U, E bits\n                       (OldL << 1) |       // New G bit\n                       (OldG << 2));       // New L bit.\n}\n\nstatic ISD::CondCode getSetCCInverseImpl(ISD::CondCode Op, bool isIntegerLike) {\n  unsigned Operation = Op;\n  if (isIntegerLike)\n    Operation ^= 7;   // Flip L, G, E bits, but not U.\n  else\n    Operation ^= 15;  // Flip all of the condition bits.\n\n  if (Operation > ISD::SETTRUE2)\n    Operation &= ~8;  // Don't let N and U bits get set.\n\n  return ISD::CondCode(Operation);\n}\n\nISD::CondCode ISD::getSetCCInverse(ISD::CondCode Op, EVT Type) {\n  return getSetCCInverseImpl(Op, Type.isInteger());\n}\n\nISD::CondCode ISD::GlobalISel::getSetCCInverse(ISD::CondCode Op,\n                                               bool isIntegerLike) {\n  return getSetCCInverseImpl(Op, isIntegerLike);\n}\n\n/// For an integer comparison, return 1 if the comparison is a signed operation\n/// and 2 if the result is an unsigned comparison. Return zero if the operation\n/// does not depend on the sign of the input (setne and seteq).\nstatic int isSignedOp(ISD::CondCode Opcode) {\n  switch (Opcode) {\n  default: llvm_unreachable(\"Illegal integer setcc operation!\");\n  case ISD::SETEQ:\n  case ISD::SETNE: return 0;\n  case ISD::SETLT:\n  case ISD::SETLE:\n  case ISD::SETGT:\n  case ISD::SETGE: return 1;\n  case ISD::SETULT:\n  case ISD::SETULE:\n  case ISD::SETUGT:\n  case ISD::SETUGE: return 2;\n  }\n}\n\nISD::CondCode ISD::getSetCCOrOperation(ISD::CondCode Op1, ISD::CondCode Op2,\n                                       EVT Type) {\n  bool IsInteger = Type.isInteger();\n  if (IsInteger && (isSignedOp(Op1) | isSignedOp(Op2)) == 3)\n    // Cannot fold a signed integer setcc with an unsigned integer setcc.\n    return ISD::SETCC_INVALID;\n\n  unsigned Op = Op1 | Op2;  // Combine all of the condition bits.\n\n  // If the N and U bits get set, then the resultant comparison DOES suddenly\n  // care about orderedness, and it is true when ordered.\n  if (Op > ISD::SETTRUE2)\n    Op &= ~16;     // Clear the U bit if the N bit is set.\n\n  // Canonicalize illegal integer setcc's.\n  if (IsInteger && Op == ISD::SETUNE)  // e.g. SETUGT | SETULT\n    Op = ISD::SETNE;\n\n  return ISD::CondCode(Op);\n}\n\nISD::CondCode ISD::getSetCCAndOperation(ISD::CondCode Op1, ISD::CondCode Op2,\n                                        EVT Type) {\n  bool IsInteger = Type.isInteger();\n  if (IsInteger && (isSignedOp(Op1) | isSignedOp(Op2)) == 3)\n    // Cannot fold a signed setcc with an unsigned setcc.\n    return ISD::SETCC_INVALID;\n\n  // Combine all of the condition bits.\n  ISD::CondCode Result = ISD::CondCode(Op1 & Op2);\n\n  // Canonicalize illegal integer setcc's.\n  if (IsInteger) {\n    switch (Result) {\n    default: break;\n    case ISD::SETUO : Result = ISD::SETFALSE; break;  // SETUGT & SETULT\n    case ISD::SETOEQ:                                 // SETEQ  & SETU[LG]E\n    case ISD::SETUEQ: Result = ISD::SETEQ   ; break;  // SETUGE & SETULE\n    case ISD::SETOLT: Result = ISD::SETULT  ; break;  // SETULT & SETNE\n    case ISD::SETOGT: Result = ISD::SETUGT  ; break;  // SETUGT & SETNE\n    }\n  }\n\n  return Result;\n}\n\n//===----------------------------------------------------------------------===//\n//                           SDNode Profile Support\n//===----------------------------------------------------------------------===//\n\n/// AddNodeIDOpcode - Add the node opcode to the NodeID data.\nstatic void AddNodeIDOpcode(FoldingSetNodeID &ID, unsigned OpC)  {\n  ID.AddInteger(OpC);\n}\n\n/// AddNodeIDValueTypes - Value type lists are intern'd so we can represent them\n/// solely with their pointer.\nstatic void AddNodeIDValueTypes(FoldingSetNodeID &ID, SDVTList VTList) {\n  ID.AddPointer(VTList.VTs);\n}\n\n/// AddNodeIDOperands - Various routines for adding operands to the NodeID data.\nstatic void AddNodeIDOperands(FoldingSetNodeID &ID,\n                              ArrayRef<SDValue> Ops) {\n  for (auto& Op : Ops) {\n    ID.AddPointer(Op.getNode());\n    ID.AddInteger(Op.getResNo());\n  }\n}\n\n/// AddNodeIDOperands - Various routines for adding operands to the NodeID data.\nstatic void AddNodeIDOperands(FoldingSetNodeID &ID,\n                              ArrayRef<SDUse> Ops) {\n  for (auto& Op : Ops) {\n    ID.AddPointer(Op.getNode());\n    ID.AddInteger(Op.getResNo());\n  }\n}\n\nstatic void AddNodeIDNode(FoldingSetNodeID &ID, unsigned short OpC,\n                          SDVTList VTList, ArrayRef<SDValue> OpList) {\n  AddNodeIDOpcode(ID, OpC);\n  AddNodeIDValueTypes(ID, VTList);\n  AddNodeIDOperands(ID, OpList);\n}\n\n/// If this is an SDNode with special info, add this info to the NodeID data.\nstatic void AddNodeIDCustom(FoldingSetNodeID &ID, const SDNode *N) {\n  switch (N->getOpcode()) {\n  case ISD::TargetExternalSymbol:\n  case ISD::ExternalSymbol:\n  case ISD::MCSymbol:\n    llvm_unreachable(\"Should only be used on nodes with operands\");\n  default: break;  // Normal nodes don't need extra info.\n  case ISD::TargetConstant:\n  case ISD::Constant: {\n    const ConstantSDNode *C = cast<ConstantSDNode>(N);\n    ID.AddPointer(C->getConstantIntValue());\n    ID.AddBoolean(C->isOpaque());\n    break;\n  }\n  case ISD::TargetConstantFP:\n  case ISD::ConstantFP:\n    ID.AddPointer(cast<ConstantFPSDNode>(N)->getConstantFPValue());\n    break;\n  case ISD::TargetGlobalAddress:\n  case ISD::GlobalAddress:\n  case ISD::TargetGlobalTLSAddress:\n  case ISD::GlobalTLSAddress: {\n    const GlobalAddressSDNode *GA = cast<GlobalAddressSDNode>(N);\n    ID.AddPointer(GA->getGlobal());\n    ID.AddInteger(GA->getOffset());\n    ID.AddInteger(GA->getTargetFlags());\n    break;\n  }\n  case ISD::BasicBlock:\n    ID.AddPointer(cast<BasicBlockSDNode>(N)->getBasicBlock());\n    break;\n  case ISD::Register:\n    ID.AddInteger(cast<RegisterSDNode>(N)->getReg());\n    break;\n  case ISD::RegisterMask:\n    ID.AddPointer(cast<RegisterMaskSDNode>(N)->getRegMask());\n    break;\n  case ISD::SRCVALUE:\n    ID.AddPointer(cast<SrcValueSDNode>(N)->getValue());\n    break;\n  case ISD::FrameIndex:\n  case ISD::TargetFrameIndex:\n    ID.AddInteger(cast<FrameIndexSDNode>(N)->getIndex());\n    break;\n  case ISD::LIFETIME_START:\n  case ISD::LIFETIME_END:\n    if (cast<LifetimeSDNode>(N)->hasOffset()) {\n      ID.AddInteger(cast<LifetimeSDNode>(N)->getSize());\n      ID.AddInteger(cast<LifetimeSDNode>(N)->getOffset());\n    }\n    break;\n  case ISD::PSEUDO_PROBE:\n    ID.AddInteger(cast<PseudoProbeSDNode>(N)->getGuid());\n    ID.AddInteger(cast<PseudoProbeSDNode>(N)->getIndex());\n    ID.AddInteger(cast<PseudoProbeSDNode>(N)->getAttributes());\n    break;\n  case ISD::JumpTable:\n  case ISD::TargetJumpTable:\n    ID.AddInteger(cast<JumpTableSDNode>(N)->getIndex());\n    ID.AddInteger(cast<JumpTableSDNode>(N)->getTargetFlags());\n    break;\n  case ISD::ConstantPool:\n  case ISD::TargetConstantPool: {\n    const ConstantPoolSDNode *CP = cast<ConstantPoolSDNode>(N);\n    ID.AddInteger(CP->getAlign().value());\n    ID.AddInteger(CP->getOffset());\n    if (CP->isMachineConstantPoolEntry())\n      CP->getMachineCPVal()->addSelectionDAGCSEId(ID);\n    else\n      ID.AddPointer(CP->getConstVal());\n    ID.AddInteger(CP->getTargetFlags());\n    break;\n  }\n  case ISD::TargetIndex: {\n    const TargetIndexSDNode *TI = cast<TargetIndexSDNode>(N);\n    ID.AddInteger(TI->getIndex());\n    ID.AddInteger(TI->getOffset());\n    ID.AddInteger(TI->getTargetFlags());\n    break;\n  }\n  case ISD::LOAD: {\n    const LoadSDNode *LD = cast<LoadSDNode>(N);\n    ID.AddInteger(LD->getMemoryVT().getRawBits());\n    ID.AddInteger(LD->getRawSubclassData());\n    ID.AddInteger(LD->getPointerInfo().getAddrSpace());\n    break;\n  }\n  case ISD::STORE: {\n    const StoreSDNode *ST = cast<StoreSDNode>(N);\n    ID.AddInteger(ST->getMemoryVT().getRawBits());\n    ID.AddInteger(ST->getRawSubclassData());\n    ID.AddInteger(ST->getPointerInfo().getAddrSpace());\n    break;\n  }\n  case ISD::MLOAD: {\n    const MaskedLoadSDNode *MLD = cast<MaskedLoadSDNode>(N);\n    ID.AddInteger(MLD->getMemoryVT().getRawBits());\n    ID.AddInteger(MLD->getRawSubclassData());\n    ID.AddInteger(MLD->getPointerInfo().getAddrSpace());\n    break;\n  }\n  case ISD::MSTORE: {\n    const MaskedStoreSDNode *MST = cast<MaskedStoreSDNode>(N);\n    ID.AddInteger(MST->getMemoryVT().getRawBits());\n    ID.AddInteger(MST->getRawSubclassData());\n    ID.AddInteger(MST->getPointerInfo().getAddrSpace());\n    break;\n  }\n  case ISD::MGATHER: {\n    const MaskedGatherSDNode *MG = cast<MaskedGatherSDNode>(N);\n    ID.AddInteger(MG->getMemoryVT().getRawBits());\n    ID.AddInteger(MG->getRawSubclassData());\n    ID.AddInteger(MG->getPointerInfo().getAddrSpace());\n    break;\n  }\n  case ISD::MSCATTER: {\n    const MaskedScatterSDNode *MS = cast<MaskedScatterSDNode>(N);\n    ID.AddInteger(MS->getMemoryVT().getRawBits());\n    ID.AddInteger(MS->getRawSubclassData());\n    ID.AddInteger(MS->getPointerInfo().getAddrSpace());\n    break;\n  }\n  case ISD::ATOMIC_CMP_SWAP:\n  case ISD::ATOMIC_CMP_SWAP_WITH_SUCCESS:\n  case ISD::ATOMIC_SWAP:\n  case ISD::ATOMIC_LOAD_ADD:\n  case ISD::ATOMIC_LOAD_SUB:\n  case ISD::ATOMIC_LOAD_AND:\n  case ISD::ATOMIC_LOAD_CLR:\n  case ISD::ATOMIC_LOAD_OR:\n  case ISD::ATOMIC_LOAD_XOR:\n  case ISD::ATOMIC_LOAD_NAND:\n  case ISD::ATOMIC_LOAD_MIN:\n  case ISD::ATOMIC_LOAD_MAX:\n  case ISD::ATOMIC_LOAD_UMIN:\n  case ISD::ATOMIC_LOAD_UMAX:\n  case ISD::ATOMIC_LOAD:\n  case ISD::ATOMIC_STORE: {\n    const AtomicSDNode *AT = cast<AtomicSDNode>(N);\n    ID.AddInteger(AT->getMemoryVT().getRawBits());\n    ID.AddInteger(AT->getRawSubclassData());\n    ID.AddInteger(AT->getPointerInfo().getAddrSpace());\n    break;\n  }\n  case ISD::PREFETCH: {\n    const MemSDNode *PF = cast<MemSDNode>(N);\n    ID.AddInteger(PF->getPointerInfo().getAddrSpace());\n    break;\n  }\n  case ISD::VECTOR_SHUFFLE: {\n    const ShuffleVectorSDNode *SVN = cast<ShuffleVectorSDNode>(N);\n    for (unsigned i = 0, e = N->getValueType(0).getVectorNumElements();\n         i != e; ++i)\n      ID.AddInteger(SVN->getMaskElt(i));\n    break;\n  }\n  case ISD::TargetBlockAddress:\n  case ISD::BlockAddress: {\n    const BlockAddressSDNode *BA = cast<BlockAddressSDNode>(N);\n    ID.AddPointer(BA->getBlockAddress());\n    ID.AddInteger(BA->getOffset());\n    ID.AddInteger(BA->getTargetFlags());\n    break;\n  }\n  } // end switch (N->getOpcode())\n\n  // Target specific memory nodes could also have address spaces to check.\n  if (N->isTargetMemoryOpcode())\n    ID.AddInteger(cast<MemSDNode>(N)->getPointerInfo().getAddrSpace());\n}\n\n/// AddNodeIDNode - Generic routine for adding a nodes info to the NodeID\n/// data.\nstatic void AddNodeIDNode(FoldingSetNodeID &ID, const SDNode *N) {\n  AddNodeIDOpcode(ID, N->getOpcode());\n  // Add the return value info.\n  AddNodeIDValueTypes(ID, N->getVTList());\n  // Add the operand info.\n  AddNodeIDOperands(ID, N->ops());\n\n  // Handle SDNode leafs with special info.\n  AddNodeIDCustom(ID, N);\n}\n\n//===----------------------------------------------------------------------===//\n//                              SelectionDAG Class\n//===----------------------------------------------------------------------===//\n\n/// doNotCSE - Return true if CSE should not be performed for this node.\nstatic bool doNotCSE(SDNode *N) {\n  if (N->getValueType(0) == MVT::Glue)\n    return true; // Never CSE anything that produces a flag.\n\n  switch (N->getOpcode()) {\n  default: break;\n  case ISD::HANDLENODE:\n  case ISD::EH_LABEL:\n    return true;   // Never CSE these nodes.\n  }\n\n  // Check that remaining values produced are not flags.\n  for (unsigned i = 1, e = N->getNumValues(); i != e; ++i)\n    if (N->getValueType(i) == MVT::Glue)\n      return true; // Never CSE anything that produces a flag.\n\n  return false;\n}\n\n/// RemoveDeadNodes - This method deletes all unreachable nodes in the\n/// SelectionDAG.\nvoid SelectionDAG::RemoveDeadNodes() {\n  // Create a dummy node (which is not added to allnodes), that adds a reference\n  // to the root node, preventing it from being deleted.\n  HandleSDNode Dummy(getRoot());\n\n  SmallVector<SDNode*, 128> DeadNodes;\n\n  // Add all obviously-dead nodes to the DeadNodes worklist.\n  for (SDNode &Node : allnodes())\n    if (Node.use_empty())\n      DeadNodes.push_back(&Node);\n\n  RemoveDeadNodes(DeadNodes);\n\n  // If the root changed (e.g. it was a dead load, update the root).\n  setRoot(Dummy.getValue());\n}\n\n/// RemoveDeadNodes - This method deletes the unreachable nodes in the\n/// given list, and any nodes that become unreachable as a result.\nvoid SelectionDAG::RemoveDeadNodes(SmallVectorImpl<SDNode *> &DeadNodes) {\n\n  // Process the worklist, deleting the nodes and adding their uses to the\n  // worklist.\n  while (!DeadNodes.empty()) {\n    SDNode *N = DeadNodes.pop_back_val();\n    // Skip to next node if we've already managed to delete the node. This could\n    // happen if replacing a node causes a node previously added to the node to\n    // be deleted.\n    if (N->getOpcode() == ISD::DELETED_NODE)\n      continue;\n\n    for (DAGUpdateListener *DUL = UpdateListeners; DUL; DUL = DUL->Next)\n      DUL->NodeDeleted(N, nullptr);\n\n    // Take the node out of the appropriate CSE map.\n    RemoveNodeFromCSEMaps(N);\n\n    // Next, brutally remove the operand list.  This is safe to do, as there are\n    // no cycles in the graph.\n    for (SDNode::op_iterator I = N->op_begin(), E = N->op_end(); I != E; ) {\n      SDUse &Use = *I++;\n      SDNode *Operand = Use.getNode();\n      Use.set(SDValue());\n\n      // Now that we removed this operand, see if there are no uses of it left.\n      if (Operand->use_empty())\n        DeadNodes.push_back(Operand);\n    }\n\n    DeallocateNode(N);\n  }\n}\n\nvoid SelectionDAG::RemoveDeadNode(SDNode *N){\n  SmallVector<SDNode*, 16> DeadNodes(1, N);\n\n  // Create a dummy node that adds a reference to the root node, preventing\n  // it from being deleted.  (This matters if the root is an operand of the\n  // dead node.)\n  HandleSDNode Dummy(getRoot());\n\n  RemoveDeadNodes(DeadNodes);\n}\n\nvoid SelectionDAG::DeleteNode(SDNode *N) {\n  // First take this out of the appropriate CSE map.\n  RemoveNodeFromCSEMaps(N);\n\n  // Finally, remove uses due to operands of this node, remove from the\n  // AllNodes list, and delete the node.\n  DeleteNodeNotInCSEMaps(N);\n}\n\nvoid SelectionDAG::DeleteNodeNotInCSEMaps(SDNode *N) {\n  assert(N->getIterator() != AllNodes.begin() &&\n         \"Cannot delete the entry node!\");\n  assert(N->use_empty() && \"Cannot delete a node that is not dead!\");\n\n  // Drop all of the operands and decrement used node's use counts.\n  N->DropOperands();\n\n  DeallocateNode(N);\n}\n\nvoid SDDbgInfo::add(SDDbgValue *V, bool isParameter) {\n  assert(!(V->isVariadic() && isParameter));\n  if (isParameter)\n    ByvalParmDbgValues.push_back(V);\n  else\n    DbgValues.push_back(V);\n  for (const SDNode *Node : V->getSDNodes())\n    if (Node)\n      DbgValMap[Node].push_back(V);\n}\n\nvoid SDDbgInfo::erase(const SDNode *Node) {\n  DbgValMapType::iterator I = DbgValMap.find(Node);\n  if (I == DbgValMap.end())\n    return;\n  for (auto &Val: I->second)\n    Val->setIsInvalidated();\n  DbgValMap.erase(I);\n}\n\nvoid SelectionDAG::DeallocateNode(SDNode *N) {\n  // If we have operands, deallocate them.\n  removeOperands(N);\n\n  NodeAllocator.Deallocate(AllNodes.remove(N));\n\n  // Set the opcode to DELETED_NODE to help catch bugs when node\n  // memory is reallocated.\n  // FIXME: There are places in SDag that have grown a dependency on the opcode\n  // value in the released node.\n  __asan_unpoison_memory_region(&N->NodeType, sizeof(N->NodeType));\n  N->NodeType = ISD::DELETED_NODE;\n\n  // If any of the SDDbgValue nodes refer to this SDNode, invalidate\n  // them and forget about that node.\n  DbgInfo->erase(N);\n}\n\n#ifndef NDEBUG\n/// VerifySDNode - Sanity check the given SDNode.  Aborts if it is invalid.\nstatic void VerifySDNode(SDNode *N) {\n  switch (N->getOpcode()) {\n  default:\n    break;\n  case ISD::BUILD_PAIR: {\n    EVT VT = N->getValueType(0);\n    assert(N->getNumValues() == 1 && \"Too many results!\");\n    assert(!VT.isVector() && (VT.isInteger() || VT.isFloatingPoint()) &&\n           \"Wrong return type!\");\n    assert(N->getNumOperands() == 2 && \"Wrong number of operands!\");\n    assert(N->getOperand(0).getValueType() == N->getOperand(1).getValueType() &&\n           \"Mismatched operand types!\");\n    assert(N->getOperand(0).getValueType().isInteger() == VT.isInteger() &&\n           \"Wrong operand type!\");\n    assert(VT.getSizeInBits() == 2 * N->getOperand(0).getValueSizeInBits() &&\n           \"Wrong return type size\");\n    break;\n  }\n  case ISD::BUILD_VECTOR: {\n    assert(N->getNumValues() == 1 && \"Too many results!\");\n    assert(N->getValueType(0).isVector() && \"Wrong return type!\");\n    assert(N->getNumOperands() == N->getValueType(0).getVectorNumElements() &&\n           \"Wrong number of operands!\");\n    EVT EltVT = N->getValueType(0).getVectorElementType();\n    for (const SDUse &Op : N->ops()) {\n      assert((Op.getValueType() == EltVT ||\n              (EltVT.isInteger() && Op.getValueType().isInteger() &&\n               EltVT.bitsLE(Op.getValueType()))) &&\n             \"Wrong operand type!\");\n      assert(Op.getValueType() == N->getOperand(0).getValueType() &&\n             \"Operands must all have the same type\");\n    }\n    break;\n  }\n  }\n}\n#endif // NDEBUG\n\n/// Insert a newly allocated node into the DAG.\n///\n/// Handles insertion into the all nodes list and CSE map, as well as\n/// verification and other common operations when a new node is allocated.\nvoid SelectionDAG::InsertNode(SDNode *N) {\n  AllNodes.push_back(N);\n#ifndef NDEBUG\n  N->PersistentId = NextPersistentId++;\n  VerifySDNode(N);\n#endif\n  for (DAGUpdateListener *DUL = UpdateListeners; DUL; DUL = DUL->Next)\n    DUL->NodeInserted(N);\n}\n\n/// RemoveNodeFromCSEMaps - Take the specified node out of the CSE map that\n/// correspond to it.  This is useful when we're about to delete or repurpose\n/// the node.  We don't want future request for structurally identical nodes\n/// to return N anymore.\nbool SelectionDAG::RemoveNodeFromCSEMaps(SDNode *N) {\n  bool Erased = false;\n  switch (N->getOpcode()) {\n  case ISD::HANDLENODE: return false;  // noop.\n  case ISD::CONDCODE:\n    assert(CondCodeNodes[cast<CondCodeSDNode>(N)->get()] &&\n           \"Cond code doesn't exist!\");\n    Erased = CondCodeNodes[cast<CondCodeSDNode>(N)->get()] != nullptr;\n    CondCodeNodes[cast<CondCodeSDNode>(N)->get()] = nullptr;\n    break;\n  case ISD::ExternalSymbol:\n    Erased = ExternalSymbols.erase(cast<ExternalSymbolSDNode>(N)->getSymbol());\n    break;\n  case ISD::TargetExternalSymbol: {\n    ExternalSymbolSDNode *ESN = cast<ExternalSymbolSDNode>(N);\n    Erased = TargetExternalSymbols.erase(std::pair<std::string, unsigned>(\n        ESN->getSymbol(), ESN->getTargetFlags()));\n    break;\n  }\n  case ISD::MCSymbol: {\n    auto *MCSN = cast<MCSymbolSDNode>(N);\n    Erased = MCSymbols.erase(MCSN->getMCSymbol());\n    break;\n  }\n  case ISD::VALUETYPE: {\n    EVT VT = cast<VTSDNode>(N)->getVT();\n    if (VT.isExtended()) {\n      Erased = ExtendedValueTypeNodes.erase(VT);\n    } else {\n      Erased = ValueTypeNodes[VT.getSimpleVT().SimpleTy] != nullptr;\n      ValueTypeNodes[VT.getSimpleVT().SimpleTy] = nullptr;\n    }\n    break;\n  }\n  default:\n    // Remove it from the CSE Map.\n    assert(N->getOpcode() != ISD::DELETED_NODE && \"DELETED_NODE in CSEMap!\");\n    assert(N->getOpcode() != ISD::EntryToken && \"EntryToken in CSEMap!\");\n    Erased = CSEMap.RemoveNode(N);\n    break;\n  }\n#ifndef NDEBUG\n  // Verify that the node was actually in one of the CSE maps, unless it has a\n  // flag result (which cannot be CSE'd) or is one of the special cases that are\n  // not subject to CSE.\n  if (!Erased && N->getValueType(N->getNumValues()-1) != MVT::Glue &&\n      !N->isMachineOpcode() && !doNotCSE(N)) {\n    N->dump(this);\n    dbgs() << \"\\n\";\n    llvm_unreachable(\"Node is not in map!\");\n  }\n#endif\n  return Erased;\n}\n\n/// AddModifiedNodeToCSEMaps - The specified node has been removed from the CSE\n/// maps and modified in place. Add it back to the CSE maps, unless an identical\n/// node already exists, in which case transfer all its users to the existing\n/// node. This transfer can potentially trigger recursive merging.\nvoid\nSelectionDAG::AddModifiedNodeToCSEMaps(SDNode *N) {\n  // For node types that aren't CSE'd, just act as if no identical node\n  // already exists.\n  if (!doNotCSE(N)) {\n    SDNode *Existing = CSEMap.GetOrInsertNode(N);\n    if (Existing != N) {\n      // If there was already an existing matching node, use ReplaceAllUsesWith\n      // to replace the dead one with the existing one.  This can cause\n      // recursive merging of other unrelated nodes down the line.\n      ReplaceAllUsesWith(N, Existing);\n\n      // N is now dead. Inform the listeners and delete it.\n      for (DAGUpdateListener *DUL = UpdateListeners; DUL; DUL = DUL->Next)\n        DUL->NodeDeleted(N, Existing);\n      DeleteNodeNotInCSEMaps(N);\n      return;\n    }\n  }\n\n  // If the node doesn't already exist, we updated it.  Inform listeners.\n  for (DAGUpdateListener *DUL = UpdateListeners; DUL; DUL = DUL->Next)\n    DUL->NodeUpdated(N);\n}\n\n/// FindModifiedNodeSlot - Find a slot for the specified node if its operands\n/// were replaced with those specified.  If this node is never memoized,\n/// return null, otherwise return a pointer to the slot it would take.  If a\n/// node already exists with these operands, the slot will be non-null.\nSDNode *SelectionDAG::FindModifiedNodeSlot(SDNode *N, SDValue Op,\n                                           void *&InsertPos) {\n  if (doNotCSE(N))\n    return nullptr;\n\n  SDValue Ops[] = { Op };\n  FoldingSetNodeID ID;\n  AddNodeIDNode(ID, N->getOpcode(), N->getVTList(), Ops);\n  AddNodeIDCustom(ID, N);\n  SDNode *Node = FindNodeOrInsertPos(ID, SDLoc(N), InsertPos);\n  if (Node)\n    Node->intersectFlagsWith(N->getFlags());\n  return Node;\n}\n\n/// FindModifiedNodeSlot - Find a slot for the specified node if its operands\n/// were replaced with those specified.  If this node is never memoized,\n/// return null, otherwise return a pointer to the slot it would take.  If a\n/// node already exists with these operands, the slot will be non-null.\nSDNode *SelectionDAG::FindModifiedNodeSlot(SDNode *N,\n                                           SDValue Op1, SDValue Op2,\n                                           void *&InsertPos) {\n  if (doNotCSE(N))\n    return nullptr;\n\n  SDValue Ops[] = { Op1, Op2 };\n  FoldingSetNodeID ID;\n  AddNodeIDNode(ID, N->getOpcode(), N->getVTList(), Ops);\n  AddNodeIDCustom(ID, N);\n  SDNode *Node = FindNodeOrInsertPos(ID, SDLoc(N), InsertPos);\n  if (Node)\n    Node->intersectFlagsWith(N->getFlags());\n  return Node;\n}\n\n/// FindModifiedNodeSlot - Find a slot for the specified node if its operands\n/// were replaced with those specified.  If this node is never memoized,\n/// return null, otherwise return a pointer to the slot it would take.  If a\n/// node already exists with these operands, the slot will be non-null.\nSDNode *SelectionDAG::FindModifiedNodeSlot(SDNode *N, ArrayRef<SDValue> Ops,\n                                           void *&InsertPos) {\n  if (doNotCSE(N))\n    return nullptr;\n\n  FoldingSetNodeID ID;\n  AddNodeIDNode(ID, N->getOpcode(), N->getVTList(), Ops);\n  AddNodeIDCustom(ID, N);\n  SDNode *Node = FindNodeOrInsertPos(ID, SDLoc(N), InsertPos);\n  if (Node)\n    Node->intersectFlagsWith(N->getFlags());\n  return Node;\n}\n\nAlign SelectionDAG::getEVTAlign(EVT VT) const {\n  Type *Ty = VT == MVT::iPTR ?\n                   PointerType::get(Type::getInt8Ty(*getContext()), 0) :\n                   VT.getTypeForEVT(*getContext());\n\n  return getDataLayout().getABITypeAlign(Ty);\n}\n\n// EntryNode could meaningfully have debug info if we can find it...\nSelectionDAG::SelectionDAG(const TargetMachine &tm, CodeGenOpt::Level OL)\n    : TM(tm), OptLevel(OL),\n      EntryNode(ISD::EntryToken, 0, DebugLoc(), getVTList(MVT::Other)),\n      Root(getEntryNode()) {\n  InsertNode(&EntryNode);\n  DbgInfo = new SDDbgInfo();\n}\n\nvoid SelectionDAG::init(MachineFunction &NewMF,\n                        OptimizationRemarkEmitter &NewORE,\n                        Pass *PassPtr, const TargetLibraryInfo *LibraryInfo,\n                        LegacyDivergenceAnalysis * Divergence,\n                        ProfileSummaryInfo *PSIin,\n                        BlockFrequencyInfo *BFIin) {\n  MF = &NewMF;\n  SDAGISelPass = PassPtr;\n  ORE = &NewORE;\n  TLI = getSubtarget().getTargetLowering();\n  TSI = getSubtarget().getSelectionDAGInfo();\n  LibInfo = LibraryInfo;\n  Context = &MF->getFunction().getContext();\n  DA = Divergence;\n  PSI = PSIin;\n  BFI = BFIin;\n}\n\nSelectionDAG::~SelectionDAG() {\n  assert(!UpdateListeners && \"Dangling registered DAGUpdateListeners\");\n  allnodes_clear();\n  OperandRecycler.clear(OperandAllocator);\n  delete DbgInfo;\n}\n\nbool SelectionDAG::shouldOptForSize() const {\n  return MF->getFunction().hasOptSize() ||\n      llvm::shouldOptimizeForSize(FLI->MBB->getBasicBlock(), PSI, BFI);\n}\n\nvoid SelectionDAG::allnodes_clear() {\n  assert(&*AllNodes.begin() == &EntryNode);\n  AllNodes.remove(AllNodes.begin());\n  while (!AllNodes.empty())\n    DeallocateNode(&AllNodes.front());\n#ifndef NDEBUG\n  NextPersistentId = 0;\n#endif\n}\n\nSDNode *SelectionDAG::FindNodeOrInsertPos(const FoldingSetNodeID &ID,\n                                          void *&InsertPos) {\n  SDNode *N = CSEMap.FindNodeOrInsertPos(ID, InsertPos);\n  if (N) {\n    switch (N->getOpcode()) {\n    default: break;\n    case ISD::Constant:\n    case ISD::ConstantFP:\n      llvm_unreachable(\"Querying for Constant and ConstantFP nodes requires \"\n                       \"debug location.  Use another overload.\");\n    }\n  }\n  return N;\n}\n\nSDNode *SelectionDAG::FindNodeOrInsertPos(const FoldingSetNodeID &ID,\n                                          const SDLoc &DL, void *&InsertPos) {\n  SDNode *N = CSEMap.FindNodeOrInsertPos(ID, InsertPos);\n  if (N) {\n    switch (N->getOpcode()) {\n    case ISD::Constant:\n    case ISD::ConstantFP:\n      // Erase debug location from the node if the node is used at several\n      // different places. Do not propagate one location to all uses as it\n      // will cause a worse single stepping debugging experience.\n      if (N->getDebugLoc() != DL.getDebugLoc())\n        N->setDebugLoc(DebugLoc());\n      break;\n    default:\n      // When the node's point of use is located earlier in the instruction\n      // sequence than its prior point of use, update its debug info to the\n      // earlier location.\n      if (DL.getIROrder() && DL.getIROrder() < N->getIROrder())\n        N->setDebugLoc(DL.getDebugLoc());\n      break;\n    }\n  }\n  return N;\n}\n\nvoid SelectionDAG::clear() {\n  allnodes_clear();\n  OperandRecycler.clear(OperandAllocator);\n  OperandAllocator.Reset();\n  CSEMap.clear();\n\n  ExtendedValueTypeNodes.clear();\n  ExternalSymbols.clear();\n  TargetExternalSymbols.clear();\n  MCSymbols.clear();\n  SDCallSiteDbgInfo.clear();\n  std::fill(CondCodeNodes.begin(), CondCodeNodes.end(),\n            static_cast<CondCodeSDNode*>(nullptr));\n  std::fill(ValueTypeNodes.begin(), ValueTypeNodes.end(),\n            static_cast<SDNode*>(nullptr));\n\n  EntryNode.UseList = nullptr;\n  InsertNode(&EntryNode);\n  Root = getEntryNode();\n  DbgInfo->clear();\n}\n\nSDValue SelectionDAG::getFPExtendOrRound(SDValue Op, const SDLoc &DL, EVT VT) {\n  return VT.bitsGT(Op.getValueType())\n             ? getNode(ISD::FP_EXTEND, DL, VT, Op)\n             : getNode(ISD::FP_ROUND, DL, VT, Op, getIntPtrConstant(0, DL));\n}\n\nstd::pair<SDValue, SDValue>\nSelectionDAG::getStrictFPExtendOrRound(SDValue Op, SDValue Chain,\n                                       const SDLoc &DL, EVT VT) {\n  assert(!VT.bitsEq(Op.getValueType()) &&\n         \"Strict no-op FP extend/round not allowed.\");\n  SDValue Res =\n      VT.bitsGT(Op.getValueType())\n          ? getNode(ISD::STRICT_FP_EXTEND, DL, {VT, MVT::Other}, {Chain, Op})\n          : getNode(ISD::STRICT_FP_ROUND, DL, {VT, MVT::Other},\n                    {Chain, Op, getIntPtrConstant(0, DL)});\n\n  return std::pair<SDValue, SDValue>(Res, SDValue(Res.getNode(), 1));\n}\n\nSDValue SelectionDAG::getAnyExtOrTrunc(SDValue Op, const SDLoc &DL, EVT VT) {\n  return VT.bitsGT(Op.getValueType()) ?\n    getNode(ISD::ANY_EXTEND, DL, VT, Op) :\n    getNode(ISD::TRUNCATE, DL, VT, Op);\n}\n\nSDValue SelectionDAG::getSExtOrTrunc(SDValue Op, const SDLoc &DL, EVT VT) {\n  return VT.bitsGT(Op.getValueType()) ?\n    getNode(ISD::SIGN_EXTEND, DL, VT, Op) :\n    getNode(ISD::TRUNCATE, DL, VT, Op);\n}\n\nSDValue SelectionDAG::getZExtOrTrunc(SDValue Op, const SDLoc &DL, EVT VT) {\n  return VT.bitsGT(Op.getValueType()) ?\n    getNode(ISD::ZERO_EXTEND, DL, VT, Op) :\n    getNode(ISD::TRUNCATE, DL, VT, Op);\n}\n\nSDValue SelectionDAG::getBoolExtOrTrunc(SDValue Op, const SDLoc &SL, EVT VT,\n                                        EVT OpVT) {\n  if (VT.bitsLE(Op.getValueType()))\n    return getNode(ISD::TRUNCATE, SL, VT, Op);\n\n  TargetLowering::BooleanContent BType = TLI->getBooleanContents(OpVT);\n  return getNode(TLI->getExtendForContent(BType), SL, VT, Op);\n}\n\nSDValue SelectionDAG::getZeroExtendInReg(SDValue Op, const SDLoc &DL, EVT VT) {\n  EVT OpVT = Op.getValueType();\n  assert(VT.isInteger() && OpVT.isInteger() &&\n         \"Cannot getZeroExtendInReg FP types\");\n  assert(VT.isVector() == OpVT.isVector() &&\n         \"getZeroExtendInReg type should be vector iff the operand \"\n         \"type is vector!\");\n  assert((!VT.isVector() ||\n          VT.getVectorElementCount() == OpVT.getVectorElementCount()) &&\n         \"Vector element counts must match in getZeroExtendInReg\");\n  assert(VT.bitsLE(OpVT) && \"Not extending!\");\n  if (OpVT == VT)\n    return Op;\n  APInt Imm = APInt::getLowBitsSet(OpVT.getScalarSizeInBits(),\n                                   VT.getScalarSizeInBits());\n  return getNode(ISD::AND, DL, OpVT, Op, getConstant(Imm, DL, OpVT));\n}\n\nSDValue SelectionDAG::getPtrExtOrTrunc(SDValue Op, const SDLoc &DL, EVT VT) {\n  // Only unsigned pointer semantics are supported right now. In the future this\n  // might delegate to TLI to check pointer signedness.\n  return getZExtOrTrunc(Op, DL, VT);\n}\n\nSDValue SelectionDAG::getPtrExtendInReg(SDValue Op, const SDLoc &DL, EVT VT) {\n  // Only unsigned pointer semantics are supported right now. In the future this\n  // might delegate to TLI to check pointer signedness.\n  return getZeroExtendInReg(Op, DL, VT);\n}\n\n/// getNOT - Create a bitwise NOT operation as (XOR Val, -1).\nSDValue SelectionDAG::getNOT(const SDLoc &DL, SDValue Val, EVT VT) {\n  EVT EltVT = VT.getScalarType();\n  SDValue NegOne =\n    getConstant(APInt::getAllOnesValue(EltVT.getSizeInBits()), DL, VT);\n  return getNode(ISD::XOR, DL, VT, Val, NegOne);\n}\n\nSDValue SelectionDAG::getLogicalNOT(const SDLoc &DL, SDValue Val, EVT VT) {\n  SDValue TrueValue = getBoolConstant(true, DL, VT, VT);\n  return getNode(ISD::XOR, DL, VT, Val, TrueValue);\n}\n\nSDValue SelectionDAG::getBoolConstant(bool V, const SDLoc &DL, EVT VT,\n                                      EVT OpVT) {\n  if (!V)\n    return getConstant(0, DL, VT);\n\n  switch (TLI->getBooleanContents(OpVT)) {\n  case TargetLowering::ZeroOrOneBooleanContent:\n  case TargetLowering::UndefinedBooleanContent:\n    return getConstant(1, DL, VT);\n  case TargetLowering::ZeroOrNegativeOneBooleanContent:\n    return getAllOnesConstant(DL, VT);\n  }\n  llvm_unreachable(\"Unexpected boolean content enum!\");\n}\n\nSDValue SelectionDAG::getConstant(uint64_t Val, const SDLoc &DL, EVT VT,\n                                  bool isT, bool isO) {\n  EVT EltVT = VT.getScalarType();\n  assert((EltVT.getSizeInBits() >= 64 ||\n          (uint64_t)((int64_t)Val >> EltVT.getSizeInBits()) + 1 < 2) &&\n         \"getConstant with a uint64_t value that doesn't fit in the type!\");\n  return getConstant(APInt(EltVT.getSizeInBits(), Val), DL, VT, isT, isO);\n}\n\nSDValue SelectionDAG::getConstant(const APInt &Val, const SDLoc &DL, EVT VT,\n                                  bool isT, bool isO) {\n  return getConstant(*ConstantInt::get(*Context, Val), DL, VT, isT, isO);\n}\n\nSDValue SelectionDAG::getConstant(const ConstantInt &Val, const SDLoc &DL,\n                                  EVT VT, bool isT, bool isO) {\n  assert(VT.isInteger() && \"Cannot create FP integer constant!\");\n\n  EVT EltVT = VT.getScalarType();\n  const ConstantInt *Elt = &Val;\n\n  // In some cases the vector type is legal but the element type is illegal and\n  // needs to be promoted, for example v8i8 on ARM.  In this case, promote the\n  // inserted value (the type does not need to match the vector element type).\n  // Any extra bits introduced will be truncated away.\n  if (VT.isVector() && TLI->getTypeAction(*getContext(), EltVT) ==\n                           TargetLowering::TypePromoteInteger) {\n    EltVT = TLI->getTypeToTransformTo(*getContext(), EltVT);\n    APInt NewVal = Elt->getValue().zextOrTrunc(EltVT.getSizeInBits());\n    Elt = ConstantInt::get(*getContext(), NewVal);\n  }\n  // In other cases the element type is illegal and needs to be expanded, for\n  // example v2i64 on MIPS32. In this case, find the nearest legal type, split\n  // the value into n parts and use a vector type with n-times the elements.\n  // Then bitcast to the type requested.\n  // Legalizing constants too early makes the DAGCombiner's job harder so we\n  // only legalize if the DAG tells us we must produce legal types.\n  else if (NewNodesMustHaveLegalTypes && VT.isVector() &&\n           TLI->getTypeAction(*getContext(), EltVT) ==\n               TargetLowering::TypeExpandInteger) {\n    const APInt &NewVal = Elt->getValue();\n    EVT ViaEltVT = TLI->getTypeToTransformTo(*getContext(), EltVT);\n    unsigned ViaEltSizeInBits = ViaEltVT.getSizeInBits();\n\n    // For scalable vectors, try to use a SPLAT_VECTOR_PARTS node.\n    if (VT.isScalableVector()) {\n      assert(EltVT.getSizeInBits() % ViaEltSizeInBits == 0 &&\n             \"Can only handle an even split!\");\n      unsigned Parts = EltVT.getSizeInBits() / ViaEltSizeInBits;\n\n      SmallVector<SDValue, 2> ScalarParts;\n      for (unsigned i = 0; i != Parts; ++i)\n        ScalarParts.push_back(getConstant(\n            NewVal.lshr(i * ViaEltSizeInBits).trunc(ViaEltSizeInBits), DL,\n            ViaEltVT, isT, isO));\n\n      return getNode(ISD::SPLAT_VECTOR_PARTS, DL, VT, ScalarParts);\n    }\n\n    unsigned ViaVecNumElts = VT.getSizeInBits() / ViaEltSizeInBits;\n    EVT ViaVecVT = EVT::getVectorVT(*getContext(), ViaEltVT, ViaVecNumElts);\n\n    // Check the temporary vector is the correct size. If this fails then\n    // getTypeToTransformTo() probably returned a type whose size (in bits)\n    // isn't a power-of-2 factor of the requested type size.\n    assert(ViaVecVT.getSizeInBits() == VT.getSizeInBits());\n\n    SmallVector<SDValue, 2> EltParts;\n    for (unsigned i = 0; i < ViaVecNumElts / VT.getVectorNumElements(); ++i) {\n      EltParts.push_back(getConstant(\n          NewVal.lshr(i * ViaEltSizeInBits).zextOrTrunc(ViaEltSizeInBits), DL,\n          ViaEltVT, isT, isO));\n    }\n\n    // EltParts is currently in little endian order. If we actually want\n    // big-endian order then reverse it now.\n    if (getDataLayout().isBigEndian())\n      std::reverse(EltParts.begin(), EltParts.end());\n\n    // The elements must be reversed when the element order is different\n    // to the endianness of the elements (because the BITCAST is itself a\n    // vector shuffle in this situation). However, we do not need any code to\n    // perform this reversal because getConstant() is producing a vector\n    // splat.\n    // This situation occurs in MIPS MSA.\n\n    SmallVector<SDValue, 8> Ops;\n    for (unsigned i = 0, e = VT.getVectorNumElements(); i != e; ++i)\n      llvm::append_range(Ops, EltParts);\n\n    SDValue V =\n        getNode(ISD::BITCAST, DL, VT, getBuildVector(ViaVecVT, DL, Ops));\n    return V;\n  }\n\n  assert(Elt->getBitWidth() == EltVT.getSizeInBits() &&\n         \"APInt size does not match type size!\");\n  unsigned Opc = isT ? ISD::TargetConstant : ISD::Constant;\n  FoldingSetNodeID ID;\n  AddNodeIDNode(ID, Opc, getVTList(EltVT), None);\n  ID.AddPointer(Elt);\n  ID.AddBoolean(isO);\n  void *IP = nullptr;\n  SDNode *N = nullptr;\n  if ((N = FindNodeOrInsertPos(ID, DL, IP)))\n    if (!VT.isVector())\n      return SDValue(N, 0);\n\n  if (!N) {\n    N = newSDNode<ConstantSDNode>(isT, isO, Elt, EltVT);\n    CSEMap.InsertNode(N, IP);\n    InsertNode(N);\n    NewSDValueDbgMsg(SDValue(N, 0), \"Creating constant: \", this);\n  }\n\n  SDValue Result(N, 0);\n  if (VT.isScalableVector())\n    Result = getSplatVector(VT, DL, Result);\n  else if (VT.isVector())\n    Result = getSplatBuildVector(VT, DL, Result);\n\n  return Result;\n}\n\nSDValue SelectionDAG::getIntPtrConstant(uint64_t Val, const SDLoc &DL,\n                                        bool isTarget) {\n  return getConstant(Val, DL, TLI->getPointerTy(getDataLayout()), isTarget);\n}\n\nSDValue SelectionDAG::getShiftAmountConstant(uint64_t Val, EVT VT,\n                                             const SDLoc &DL, bool LegalTypes) {\n  assert(VT.isInteger() && \"Shift amount is not an integer type!\");\n  EVT ShiftVT = TLI->getShiftAmountTy(VT, getDataLayout(), LegalTypes);\n  return getConstant(Val, DL, ShiftVT);\n}\n\nSDValue SelectionDAG::getVectorIdxConstant(uint64_t Val, const SDLoc &DL,\n                                           bool isTarget) {\n  return getConstant(Val, DL, TLI->getVectorIdxTy(getDataLayout()), isTarget);\n}\n\nSDValue SelectionDAG::getConstantFP(const APFloat &V, const SDLoc &DL, EVT VT,\n                                    bool isTarget) {\n  return getConstantFP(*ConstantFP::get(*getContext(), V), DL, VT, isTarget);\n}\n\nSDValue SelectionDAG::getConstantFP(const ConstantFP &V, const SDLoc &DL,\n                                    EVT VT, bool isTarget) {\n  assert(VT.isFloatingPoint() && \"Cannot create integer FP constant!\");\n\n  EVT EltVT = VT.getScalarType();\n\n  // Do the map lookup using the actual bit pattern for the floating point\n  // value, so that we don't have problems with 0.0 comparing equal to -0.0, and\n  // we don't have issues with SNANs.\n  unsigned Opc = isTarget ? ISD::TargetConstantFP : ISD::ConstantFP;\n  FoldingSetNodeID ID;\n  AddNodeIDNode(ID, Opc, getVTList(EltVT), None);\n  ID.AddPointer(&V);\n  void *IP = nullptr;\n  SDNode *N = nullptr;\n  if ((N = FindNodeOrInsertPos(ID, DL, IP)))\n    if (!VT.isVector())\n      return SDValue(N, 0);\n\n  if (!N) {\n    N = newSDNode<ConstantFPSDNode>(isTarget, &V, EltVT);\n    CSEMap.InsertNode(N, IP);\n    InsertNode(N);\n  }\n\n  SDValue Result(N, 0);\n  if (VT.isScalableVector())\n    Result = getSplatVector(VT, DL, Result);\n  else if (VT.isVector())\n    Result = getSplatBuildVector(VT, DL, Result);\n  NewSDValueDbgMsg(Result, \"Creating fp constant: \", this);\n  return Result;\n}\n\nSDValue SelectionDAG::getConstantFP(double Val, const SDLoc &DL, EVT VT,\n                                    bool isTarget) {\n  EVT EltVT = VT.getScalarType();\n  if (EltVT == MVT::f32)\n    return getConstantFP(APFloat((float)Val), DL, VT, isTarget);\n  else if (EltVT == MVT::f64)\n    return getConstantFP(APFloat(Val), DL, VT, isTarget);\n  else if (EltVT == MVT::f80 || EltVT == MVT::f128 || EltVT == MVT::ppcf128 ||\n           EltVT == MVT::f16 || EltVT == MVT::bf16) {\n    bool Ignored;\n    APFloat APF = APFloat(Val);\n    APF.convert(EVTToAPFloatSemantics(EltVT), APFloat::rmNearestTiesToEven,\n                &Ignored);\n    return getConstantFP(APF, DL, VT, isTarget);\n  } else\n    llvm_unreachable(\"Unsupported type in getConstantFP\");\n}\n\nSDValue SelectionDAG::getGlobalAddress(const GlobalValue *GV, const SDLoc &DL,\n                                       EVT VT, int64_t Offset, bool isTargetGA,\n                                       unsigned TargetFlags) {\n  assert((TargetFlags == 0 || isTargetGA) &&\n         \"Cannot set target flags on target-independent globals\");\n\n  // Truncate (with sign-extension) the offset value to the pointer size.\n  unsigned BitWidth = getDataLayout().getPointerTypeSizeInBits(GV->getType());\n  if (BitWidth < 64)\n    Offset = SignExtend64(Offset, BitWidth);\n\n  unsigned Opc;\n  if (GV->isThreadLocal())\n    Opc = isTargetGA ? ISD::TargetGlobalTLSAddress : ISD::GlobalTLSAddress;\n  else\n    Opc = isTargetGA ? ISD::TargetGlobalAddress : ISD::GlobalAddress;\n\n  FoldingSetNodeID ID;\n  AddNodeIDNode(ID, Opc, getVTList(VT), None);\n  ID.AddPointer(GV);\n  ID.AddInteger(Offset);\n  ID.AddInteger(TargetFlags);\n  void *IP = nullptr;\n  if (SDNode *E = FindNodeOrInsertPos(ID, DL, IP))\n    return SDValue(E, 0);\n\n  auto *N = newSDNode<GlobalAddressSDNode>(\n      Opc, DL.getIROrder(), DL.getDebugLoc(), GV, VT, Offset, TargetFlags);\n  CSEMap.InsertNode(N, IP);\n    InsertNode(N);\n  return SDValue(N, 0);\n}\n\nSDValue SelectionDAG::getFrameIndex(int FI, EVT VT, bool isTarget) {\n  unsigned Opc = isTarget ? ISD::TargetFrameIndex : ISD::FrameIndex;\n  FoldingSetNodeID ID;\n  AddNodeIDNode(ID, Opc, getVTList(VT), None);\n  ID.AddInteger(FI);\n  void *IP = nullptr;\n  if (SDNode *E = FindNodeOrInsertPos(ID, IP))\n    return SDValue(E, 0);\n\n  auto *N = newSDNode<FrameIndexSDNode>(FI, VT, isTarget);\n  CSEMap.InsertNode(N, IP);\n  InsertNode(N);\n  return SDValue(N, 0);\n}\n\nSDValue SelectionDAG::getJumpTable(int JTI, EVT VT, bool isTarget,\n                                   unsigned TargetFlags) {\n  assert((TargetFlags == 0 || isTarget) &&\n         \"Cannot set target flags on target-independent jump tables\");\n  unsigned Opc = isTarget ? ISD::TargetJumpTable : ISD::JumpTable;\n  FoldingSetNodeID ID;\n  AddNodeIDNode(ID, Opc, getVTList(VT), None);\n  ID.AddInteger(JTI);\n  ID.AddInteger(TargetFlags);\n  void *IP = nullptr;\n  if (SDNode *E = FindNodeOrInsertPos(ID, IP))\n    return SDValue(E, 0);\n\n  auto *N = newSDNode<JumpTableSDNode>(JTI, VT, isTarget, TargetFlags);\n  CSEMap.InsertNode(N, IP);\n  InsertNode(N);\n  return SDValue(N, 0);\n}\n\nSDValue SelectionDAG::getConstantPool(const Constant *C, EVT VT,\n                                      MaybeAlign Alignment, int Offset,\n                                      bool isTarget, unsigned TargetFlags) {\n  assert((TargetFlags == 0 || isTarget) &&\n         \"Cannot set target flags on target-independent globals\");\n  if (!Alignment)\n    Alignment = shouldOptForSize()\n                    ? getDataLayout().getABITypeAlign(C->getType())\n                    : getDataLayout().getPrefTypeAlign(C->getType());\n  unsigned Opc = isTarget ? ISD::TargetConstantPool : ISD::ConstantPool;\n  FoldingSetNodeID ID;\n  AddNodeIDNode(ID, Opc, getVTList(VT), None);\n  ID.AddInteger(Alignment->value());\n  ID.AddInteger(Offset);\n  ID.AddPointer(C);\n  ID.AddInteger(TargetFlags);\n  void *IP = nullptr;\n  if (SDNode *E = FindNodeOrInsertPos(ID, IP))\n    return SDValue(E, 0);\n\n  auto *N = newSDNode<ConstantPoolSDNode>(isTarget, C, VT, Offset, *Alignment,\n                                          TargetFlags);\n  CSEMap.InsertNode(N, IP);\n  InsertNode(N);\n  SDValue V = SDValue(N, 0);\n  NewSDValueDbgMsg(V, \"Creating new constant pool: \", this);\n  return V;\n}\n\nSDValue SelectionDAG::getConstantPool(MachineConstantPoolValue *C, EVT VT,\n                                      MaybeAlign Alignment, int Offset,\n                                      bool isTarget, unsigned TargetFlags) {\n  assert((TargetFlags == 0 || isTarget) &&\n         \"Cannot set target flags on target-independent globals\");\n  if (!Alignment)\n    Alignment = getDataLayout().getPrefTypeAlign(C->getType());\n  unsigned Opc = isTarget ? ISD::TargetConstantPool : ISD::ConstantPool;\n  FoldingSetNodeID ID;\n  AddNodeIDNode(ID, Opc, getVTList(VT), None);\n  ID.AddInteger(Alignment->value());\n  ID.AddInteger(Offset);\n  C->addSelectionDAGCSEId(ID);\n  ID.AddInteger(TargetFlags);\n  void *IP = nullptr;\n  if (SDNode *E = FindNodeOrInsertPos(ID, IP))\n    return SDValue(E, 0);\n\n  auto *N = newSDNode<ConstantPoolSDNode>(isTarget, C, VT, Offset, *Alignment,\n                                          TargetFlags);\n  CSEMap.InsertNode(N, IP);\n  InsertNode(N);\n  return SDValue(N, 0);\n}\n\nSDValue SelectionDAG::getTargetIndex(int Index, EVT VT, int64_t Offset,\n                                     unsigned TargetFlags) {\n  FoldingSetNodeID ID;\n  AddNodeIDNode(ID, ISD::TargetIndex, getVTList(VT), None);\n  ID.AddInteger(Index);\n  ID.AddInteger(Offset);\n  ID.AddInteger(TargetFlags);\n  void *IP = nullptr;\n  if (SDNode *E = FindNodeOrInsertPos(ID, IP))\n    return SDValue(E, 0);\n\n  auto *N = newSDNode<TargetIndexSDNode>(Index, VT, Offset, TargetFlags);\n  CSEMap.InsertNode(N, IP);\n  InsertNode(N);\n  return SDValue(N, 0);\n}\n\nSDValue SelectionDAG::getBasicBlock(MachineBasicBlock *MBB) {\n  FoldingSetNodeID ID;\n  AddNodeIDNode(ID, ISD::BasicBlock, getVTList(MVT::Other), None);\n  ID.AddPointer(MBB);\n  void *IP = nullptr;\n  if (SDNode *E = FindNodeOrInsertPos(ID, IP))\n    return SDValue(E, 0);\n\n  auto *N = newSDNode<BasicBlockSDNode>(MBB);\n  CSEMap.InsertNode(N, IP);\n  InsertNode(N);\n  return SDValue(N, 0);\n}\n\nSDValue SelectionDAG::getValueType(EVT VT) {\n  if (VT.isSimple() && (unsigned)VT.getSimpleVT().SimpleTy >=\n      ValueTypeNodes.size())\n    ValueTypeNodes.resize(VT.getSimpleVT().SimpleTy+1);\n\n  SDNode *&N = VT.isExtended() ?\n    ExtendedValueTypeNodes[VT] : ValueTypeNodes[VT.getSimpleVT().SimpleTy];\n\n  if (N) return SDValue(N, 0);\n  N = newSDNode<VTSDNode>(VT);\n  InsertNode(N);\n  return SDValue(N, 0);\n}\n\nSDValue SelectionDAG::getExternalSymbol(const char *Sym, EVT VT) {\n  SDNode *&N = ExternalSymbols[Sym];\n  if (N) return SDValue(N, 0);\n  N = newSDNode<ExternalSymbolSDNode>(false, Sym, 0, VT);\n  InsertNode(N);\n  return SDValue(N, 0);\n}\n\nSDValue SelectionDAG::getMCSymbol(MCSymbol *Sym, EVT VT) {\n  SDNode *&N = MCSymbols[Sym];\n  if (N)\n    return SDValue(N, 0);\n  N = newSDNode<MCSymbolSDNode>(Sym, VT);\n  InsertNode(N);\n  return SDValue(N, 0);\n}\n\nSDValue SelectionDAG::getTargetExternalSymbol(const char *Sym, EVT VT,\n                                              unsigned TargetFlags) {\n  SDNode *&N =\n      TargetExternalSymbols[std::pair<std::string, unsigned>(Sym, TargetFlags)];\n  if (N) return SDValue(N, 0);\n  N = newSDNode<ExternalSymbolSDNode>(true, Sym, TargetFlags, VT);\n  InsertNode(N);\n  return SDValue(N, 0);\n}\n\nSDValue SelectionDAG::getCondCode(ISD::CondCode Cond) {\n  if ((unsigned)Cond >= CondCodeNodes.size())\n    CondCodeNodes.resize(Cond+1);\n\n  if (!CondCodeNodes[Cond]) {\n    auto *N = newSDNode<CondCodeSDNode>(Cond);\n    CondCodeNodes[Cond] = N;\n    InsertNode(N);\n  }\n\n  return SDValue(CondCodeNodes[Cond], 0);\n}\n\n/// Swaps the values of N1 and N2. Swaps all indices in the shuffle mask M that\n/// point at N1 to point at N2 and indices that point at N2 to point at N1.\nstatic void commuteShuffle(SDValue &N1, SDValue &N2, MutableArrayRef<int> M) {\n  std::swap(N1, N2);\n  ShuffleVectorSDNode::commuteMask(M);\n}\n\nSDValue SelectionDAG::getVectorShuffle(EVT VT, const SDLoc &dl, SDValue N1,\n                                       SDValue N2, ArrayRef<int> Mask) {\n  assert(VT.getVectorNumElements() == Mask.size() &&\n           \"Must have the same number of vector elements as mask elements!\");\n  assert(VT == N1.getValueType() && VT == N2.getValueType() &&\n         \"Invalid VECTOR_SHUFFLE\");\n\n  // Canonicalize shuffle undef, undef -> undef\n  if (N1.isUndef() && N2.isUndef())\n    return getUNDEF(VT);\n\n  // Validate that all indices in Mask are within the range of the elements\n  // input to the shuffle.\n  int NElts = Mask.size();\n  assert(llvm::all_of(Mask,\n                      [&](int M) { return M < (NElts * 2) && M >= -1; }) &&\n         \"Index out of range\");\n\n  // Copy the mask so we can do any needed cleanup.\n  SmallVector<int, 8> MaskVec(Mask.begin(), Mask.end());\n\n  // Canonicalize shuffle v, v -> v, undef\n  if (N1 == N2) {\n    N2 = getUNDEF(VT);\n    for (int i = 0; i != NElts; ++i)\n      if (MaskVec[i] >= NElts) MaskVec[i] -= NElts;\n  }\n\n  // Canonicalize shuffle undef, v -> v, undef.  Commute the shuffle mask.\n  if (N1.isUndef())\n    commuteShuffle(N1, N2, MaskVec);\n\n  if (TLI->hasVectorBlend()) {\n    // If shuffling a splat, try to blend the splat instead. We do this here so\n    // that even when this arises during lowering we don't have to re-handle it.\n    auto BlendSplat = [&](BuildVectorSDNode *BV, int Offset) {\n      BitVector UndefElements;\n      SDValue Splat = BV->getSplatValue(&UndefElements);\n      if (!Splat)\n        return;\n\n      for (int i = 0; i < NElts; ++i) {\n        if (MaskVec[i] < Offset || MaskVec[i] >= (Offset + NElts))\n          continue;\n\n        // If this input comes from undef, mark it as such.\n        if (UndefElements[MaskVec[i] - Offset]) {\n          MaskVec[i] = -1;\n          continue;\n        }\n\n        // If we can blend a non-undef lane, use that instead.\n        if (!UndefElements[i])\n          MaskVec[i] = i + Offset;\n      }\n    };\n    if (auto *N1BV = dyn_cast<BuildVectorSDNode>(N1))\n      BlendSplat(N1BV, 0);\n    if (auto *N2BV = dyn_cast<BuildVectorSDNode>(N2))\n      BlendSplat(N2BV, NElts);\n  }\n\n  // Canonicalize all index into lhs, -> shuffle lhs, undef\n  // Canonicalize all index into rhs, -> shuffle rhs, undef\n  bool AllLHS = true, AllRHS = true;\n  bool N2Undef = N2.isUndef();\n  for (int i = 0; i != NElts; ++i) {\n    if (MaskVec[i] >= NElts) {\n      if (N2Undef)\n        MaskVec[i] = -1;\n      else\n        AllLHS = false;\n    } else if (MaskVec[i] >= 0) {\n      AllRHS = false;\n    }\n  }\n  if (AllLHS && AllRHS)\n    return getUNDEF(VT);\n  if (AllLHS && !N2Undef)\n    N2 = getUNDEF(VT);\n  if (AllRHS) {\n    N1 = getUNDEF(VT);\n    commuteShuffle(N1, N2, MaskVec);\n  }\n  // Reset our undef status after accounting for the mask.\n  N2Undef = N2.isUndef();\n  // Re-check whether both sides ended up undef.\n  if (N1.isUndef() && N2Undef)\n    return getUNDEF(VT);\n\n  // If Identity shuffle return that node.\n  bool Identity = true, AllSame = true;\n  for (int i = 0; i != NElts; ++i) {\n    if (MaskVec[i] >= 0 && MaskVec[i] != i) Identity = false;\n    if (MaskVec[i] != MaskVec[0]) AllSame = false;\n  }\n  if (Identity && NElts)\n    return N1;\n\n  // Shuffling a constant splat doesn't change the result.\n  if (N2Undef) {\n    SDValue V = N1;\n\n    // Look through any bitcasts. We check that these don't change the number\n    // (and size) of elements and just changes their types.\n    while (V.getOpcode() == ISD::BITCAST)\n      V = V->getOperand(0);\n\n    // A splat should always show up as a build vector node.\n    if (auto *BV = dyn_cast<BuildVectorSDNode>(V)) {\n      BitVector UndefElements;\n      SDValue Splat = BV->getSplatValue(&UndefElements);\n      // If this is a splat of an undef, shuffling it is also undef.\n      if (Splat && Splat.isUndef())\n        return getUNDEF(VT);\n\n      bool SameNumElts =\n          V.getValueType().getVectorNumElements() == VT.getVectorNumElements();\n\n      // We only have a splat which can skip shuffles if there is a splatted\n      // value and no undef lanes rearranged by the shuffle.\n      if (Splat && UndefElements.none()) {\n        // Splat of <x, x, ..., x>, return <x, x, ..., x>, provided that the\n        // number of elements match or the value splatted is a zero constant.\n        if (SameNumElts)\n          return N1;\n        if (auto *C = dyn_cast<ConstantSDNode>(Splat))\n          if (C->isNullValue())\n            return N1;\n      }\n\n      // If the shuffle itself creates a splat, build the vector directly.\n      if (AllSame && SameNumElts) {\n        EVT BuildVT = BV->getValueType(0);\n        const SDValue &Splatted = BV->getOperand(MaskVec[0]);\n        SDValue NewBV = getSplatBuildVector(BuildVT, dl, Splatted);\n\n        // We may have jumped through bitcasts, so the type of the\n        // BUILD_VECTOR may not match the type of the shuffle.\n        if (BuildVT != VT)\n          NewBV = getNode(ISD::BITCAST, dl, VT, NewBV);\n        return NewBV;\n      }\n    }\n  }\n\n  FoldingSetNodeID ID;\n  SDValue Ops[2] = { N1, N2 };\n  AddNodeIDNode(ID, ISD::VECTOR_SHUFFLE, getVTList(VT), Ops);\n  for (int i = 0; i != NElts; ++i)\n    ID.AddInteger(MaskVec[i]);\n\n  void* IP = nullptr;\n  if (SDNode *E = FindNodeOrInsertPos(ID, dl, IP))\n    return SDValue(E, 0);\n\n  // Allocate the mask array for the node out of the BumpPtrAllocator, since\n  // SDNode doesn't have access to it.  This memory will be \"leaked\" when\n  // the node is deallocated, but recovered when the NodeAllocator is released.\n  int *MaskAlloc = OperandAllocator.Allocate<int>(NElts);\n  llvm::copy(MaskVec, MaskAlloc);\n\n  auto *N = newSDNode<ShuffleVectorSDNode>(VT, dl.getIROrder(),\n                                           dl.getDebugLoc(), MaskAlloc);\n  createOperands(N, Ops);\n\n  CSEMap.InsertNode(N, IP);\n  InsertNode(N);\n  SDValue V = SDValue(N, 0);\n  NewSDValueDbgMsg(V, \"Creating new node: \", this);\n  return V;\n}\n\nSDValue SelectionDAG::getCommutedVectorShuffle(const ShuffleVectorSDNode &SV) {\n  EVT VT = SV.getValueType(0);\n  SmallVector<int, 8> MaskVec(SV.getMask().begin(), SV.getMask().end());\n  ShuffleVectorSDNode::commuteMask(MaskVec);\n\n  SDValue Op0 = SV.getOperand(0);\n  SDValue Op1 = SV.getOperand(1);\n  return getVectorShuffle(VT, SDLoc(&SV), Op1, Op0, MaskVec);\n}\n\nSDValue SelectionDAG::getRegister(unsigned RegNo, EVT VT) {\n  FoldingSetNodeID ID;\n  AddNodeIDNode(ID, ISD::Register, getVTList(VT), None);\n  ID.AddInteger(RegNo);\n  void *IP = nullptr;\n  if (SDNode *E = FindNodeOrInsertPos(ID, IP))\n    return SDValue(E, 0);\n\n  auto *N = newSDNode<RegisterSDNode>(RegNo, VT);\n  N->SDNodeBits.IsDivergent = TLI->isSDNodeSourceOfDivergence(N, FLI, DA);\n  CSEMap.InsertNode(N, IP);\n  InsertNode(N);\n  return SDValue(N, 0);\n}\n\nSDValue SelectionDAG::getRegisterMask(const uint32_t *RegMask) {\n  FoldingSetNodeID ID;\n  AddNodeIDNode(ID, ISD::RegisterMask, getVTList(MVT::Untyped), None);\n  ID.AddPointer(RegMask);\n  void *IP = nullptr;\n  if (SDNode *E = FindNodeOrInsertPos(ID, IP))\n    return SDValue(E, 0);\n\n  auto *N = newSDNode<RegisterMaskSDNode>(RegMask);\n  CSEMap.InsertNode(N, IP);\n  InsertNode(N);\n  return SDValue(N, 0);\n}\n\nSDValue SelectionDAG::getEHLabel(const SDLoc &dl, SDValue Root,\n                                 MCSymbol *Label) {\n  return getLabelNode(ISD::EH_LABEL, dl, Root, Label);\n}\n\nSDValue SelectionDAG::getLabelNode(unsigned Opcode, const SDLoc &dl,\n                                   SDValue Root, MCSymbol *Label) {\n  FoldingSetNodeID ID;\n  SDValue Ops[] = { Root };\n  AddNodeIDNode(ID, Opcode, getVTList(MVT::Other), Ops);\n  ID.AddPointer(Label);\n  void *IP = nullptr;\n  if (SDNode *E = FindNodeOrInsertPos(ID, IP))\n    return SDValue(E, 0);\n\n  auto *N =\n      newSDNode<LabelSDNode>(Opcode, dl.getIROrder(), dl.getDebugLoc(), Label);\n  createOperands(N, Ops);\n\n  CSEMap.InsertNode(N, IP);\n  InsertNode(N);\n  return SDValue(N, 0);\n}\n\nSDValue SelectionDAG::getBlockAddress(const BlockAddress *BA, EVT VT,\n                                      int64_t Offset, bool isTarget,\n                                      unsigned TargetFlags) {\n  unsigned Opc = isTarget ? ISD::TargetBlockAddress : ISD::BlockAddress;\n\n  FoldingSetNodeID ID;\n  AddNodeIDNode(ID, Opc, getVTList(VT), None);\n  ID.AddPointer(BA);\n  ID.AddInteger(Offset);\n  ID.AddInteger(TargetFlags);\n  void *IP = nullptr;\n  if (SDNode *E = FindNodeOrInsertPos(ID, IP))\n    return SDValue(E, 0);\n\n  auto *N = newSDNode<BlockAddressSDNode>(Opc, VT, BA, Offset, TargetFlags);\n  CSEMap.InsertNode(N, IP);\n  InsertNode(N);\n  return SDValue(N, 0);\n}\n\nSDValue SelectionDAG::getSrcValue(const Value *V) {\n  FoldingSetNodeID ID;\n  AddNodeIDNode(ID, ISD::SRCVALUE, getVTList(MVT::Other), None);\n  ID.AddPointer(V);\n\n  void *IP = nullptr;\n  if (SDNode *E = FindNodeOrInsertPos(ID, IP))\n    return SDValue(E, 0);\n\n  auto *N = newSDNode<SrcValueSDNode>(V);\n  CSEMap.InsertNode(N, IP);\n  InsertNode(N);\n  return SDValue(N, 0);\n}\n\nSDValue SelectionDAG::getMDNode(const MDNode *MD) {\n  FoldingSetNodeID ID;\n  AddNodeIDNode(ID, ISD::MDNODE_SDNODE, getVTList(MVT::Other), None);\n  ID.AddPointer(MD);\n\n  void *IP = nullptr;\n  if (SDNode *E = FindNodeOrInsertPos(ID, IP))\n    return SDValue(E, 0);\n\n  auto *N = newSDNode<MDNodeSDNode>(MD);\n  CSEMap.InsertNode(N, IP);\n  InsertNode(N);\n  return SDValue(N, 0);\n}\n\nSDValue SelectionDAG::getBitcast(EVT VT, SDValue V) {\n  if (VT == V.getValueType())\n    return V;\n\n  return getNode(ISD::BITCAST, SDLoc(V), VT, V);\n}\n\nSDValue SelectionDAG::getAddrSpaceCast(const SDLoc &dl, EVT VT, SDValue Ptr,\n                                       unsigned SrcAS, unsigned DestAS) {\n  SDValue Ops[] = {Ptr};\n  FoldingSetNodeID ID;\n  AddNodeIDNode(ID, ISD::ADDRSPACECAST, getVTList(VT), Ops);\n  ID.AddInteger(SrcAS);\n  ID.AddInteger(DestAS);\n\n  void *IP = nullptr;\n  if (SDNode *E = FindNodeOrInsertPos(ID, dl, IP))\n    return SDValue(E, 0);\n\n  auto *N = newSDNode<AddrSpaceCastSDNode>(dl.getIROrder(), dl.getDebugLoc(),\n                                           VT, SrcAS, DestAS);\n  createOperands(N, Ops);\n\n  CSEMap.InsertNode(N, IP);\n  InsertNode(N);\n  return SDValue(N, 0);\n}\n\nSDValue SelectionDAG::getFreeze(SDValue V) {\n  return getNode(ISD::FREEZE, SDLoc(V), V.getValueType(), V);\n}\n\n/// getShiftAmountOperand - Return the specified value casted to\n/// the target's desired shift amount type.\nSDValue SelectionDAG::getShiftAmountOperand(EVT LHSTy, SDValue Op) {\n  EVT OpTy = Op.getValueType();\n  EVT ShTy = TLI->getShiftAmountTy(LHSTy, getDataLayout());\n  if (OpTy == ShTy || OpTy.isVector()) return Op;\n\n  return getZExtOrTrunc(Op, SDLoc(Op), ShTy);\n}\n\nSDValue SelectionDAG::expandVAArg(SDNode *Node) {\n  SDLoc dl(Node);\n  const TargetLowering &TLI = getTargetLoweringInfo();\n  const Value *V = cast<SrcValueSDNode>(Node->getOperand(2))->getValue();\n  EVT VT = Node->getValueType(0);\n  SDValue Tmp1 = Node->getOperand(0);\n  SDValue Tmp2 = Node->getOperand(1);\n  const MaybeAlign MA(Node->getConstantOperandVal(3));\n\n  SDValue VAListLoad = getLoad(TLI.getPointerTy(getDataLayout()), dl, Tmp1,\n                               Tmp2, MachinePointerInfo(V));\n  SDValue VAList = VAListLoad;\n\n  if (MA && *MA > TLI.getMinStackArgumentAlignment()) {\n    VAList = getNode(ISD::ADD, dl, VAList.getValueType(), VAList,\n                     getConstant(MA->value() - 1, dl, VAList.getValueType()));\n\n    VAList =\n        getNode(ISD::AND, dl, VAList.getValueType(), VAList,\n                getConstant(-(int64_t)MA->value(), dl, VAList.getValueType()));\n  }\n\n  // Increment the pointer, VAList, to the next vaarg\n  Tmp1 = getNode(ISD::ADD, dl, VAList.getValueType(), VAList,\n                 getConstant(getDataLayout().getTypeAllocSize(\n                                               VT.getTypeForEVT(*getContext())),\n                             dl, VAList.getValueType()));\n  // Store the incremented VAList to the legalized pointer\n  Tmp1 =\n      getStore(VAListLoad.getValue(1), dl, Tmp1, Tmp2, MachinePointerInfo(V));\n  // Load the actual argument out of the pointer VAList\n  return getLoad(VT, dl, Tmp1, VAList, MachinePointerInfo());\n}\n\nSDValue SelectionDAG::expandVACopy(SDNode *Node) {\n  SDLoc dl(Node);\n  const TargetLowering &TLI = getTargetLoweringInfo();\n  // This defaults to loading a pointer from the input and storing it to the\n  // output, returning the chain.\n  const Value *VD = cast<SrcValueSDNode>(Node->getOperand(3))->getValue();\n  const Value *VS = cast<SrcValueSDNode>(Node->getOperand(4))->getValue();\n  SDValue Tmp1 =\n      getLoad(TLI.getPointerTy(getDataLayout()), dl, Node->getOperand(0),\n              Node->getOperand(2), MachinePointerInfo(VS));\n  return getStore(Tmp1.getValue(1), dl, Tmp1, Node->getOperand(1),\n                  MachinePointerInfo(VD));\n}\n\nAlign SelectionDAG::getReducedAlign(EVT VT, bool UseABI) {\n  const DataLayout &DL = getDataLayout();\n  Type *Ty = VT.getTypeForEVT(*getContext());\n  Align RedAlign = UseABI ? DL.getABITypeAlign(Ty) : DL.getPrefTypeAlign(Ty);\n\n  if (TLI->isTypeLegal(VT) || !VT.isVector())\n    return RedAlign;\n\n  const TargetFrameLowering *TFI = MF->getSubtarget().getFrameLowering();\n  const Align StackAlign = TFI->getStackAlign();\n\n  // See if we can choose a smaller ABI alignment in cases where it's an\n  // illegal vector type that will get broken down.\n  if (RedAlign > StackAlign) {\n    EVT IntermediateVT;\n    MVT RegisterVT;\n    unsigned NumIntermediates;\n    TLI->getVectorTypeBreakdown(*getContext(), VT, IntermediateVT,\n                                NumIntermediates, RegisterVT);\n    Ty = IntermediateVT.getTypeForEVT(*getContext());\n    Align RedAlign2 = UseABI ? DL.getABITypeAlign(Ty) : DL.getPrefTypeAlign(Ty);\n    if (RedAlign2 < RedAlign)\n      RedAlign = RedAlign2;\n  }\n\n  return RedAlign;\n}\n\nSDValue SelectionDAG::CreateStackTemporary(TypeSize Bytes, Align Alignment) {\n  MachineFrameInfo &MFI = MF->getFrameInfo();\n  const TargetFrameLowering *TFI = MF->getSubtarget().getFrameLowering();\n  int StackID = 0;\n  if (Bytes.isScalable())\n    StackID = TFI->getStackIDForScalableVectors();\n  // The stack id gives an indication of whether the object is scalable or\n  // not, so it's safe to pass in the minimum size here.\n  int FrameIdx = MFI.CreateStackObject(Bytes.getKnownMinSize(), Alignment,\n                                       false, nullptr, StackID);\n  return getFrameIndex(FrameIdx, TLI->getFrameIndexTy(getDataLayout()));\n}\n\nSDValue SelectionDAG::CreateStackTemporary(EVT VT, unsigned minAlign) {\n  Type *Ty = VT.getTypeForEVT(*getContext());\n  Align StackAlign =\n      std::max(getDataLayout().getPrefTypeAlign(Ty), Align(minAlign));\n  return CreateStackTemporary(VT.getStoreSize(), StackAlign);\n}\n\nSDValue SelectionDAG::CreateStackTemporary(EVT VT1, EVT VT2) {\n  TypeSize VT1Size = VT1.getStoreSize();\n  TypeSize VT2Size = VT2.getStoreSize();\n  assert(VT1Size.isScalable() == VT2Size.isScalable() &&\n         \"Don't know how to choose the maximum size when creating a stack \"\n         \"temporary\");\n  TypeSize Bytes =\n      VT1Size.getKnownMinSize() > VT2Size.getKnownMinSize() ? VT1Size : VT2Size;\n\n  Type *Ty1 = VT1.getTypeForEVT(*getContext());\n  Type *Ty2 = VT2.getTypeForEVT(*getContext());\n  const DataLayout &DL = getDataLayout();\n  Align Align = std::max(DL.getPrefTypeAlign(Ty1), DL.getPrefTypeAlign(Ty2));\n  return CreateStackTemporary(Bytes, Align);\n}\n\nSDValue SelectionDAG::FoldSetCC(EVT VT, SDValue N1, SDValue N2,\n                                ISD::CondCode Cond, const SDLoc &dl) {\n  EVT OpVT = N1.getValueType();\n\n  // These setcc operations always fold.\n  switch (Cond) {\n  default: break;\n  case ISD::SETFALSE:\n  case ISD::SETFALSE2: return getBoolConstant(false, dl, VT, OpVT);\n  case ISD::SETTRUE:\n  case ISD::SETTRUE2: return getBoolConstant(true, dl, VT, OpVT);\n\n  case ISD::SETOEQ:\n  case ISD::SETOGT:\n  case ISD::SETOGE:\n  case ISD::SETOLT:\n  case ISD::SETOLE:\n  case ISD::SETONE:\n  case ISD::SETO:\n  case ISD::SETUO:\n  case ISD::SETUEQ:\n  case ISD::SETUNE:\n    assert(!OpVT.isInteger() && \"Illegal setcc for integer!\");\n    break;\n  }\n\n  if (OpVT.isInteger()) {\n    // For EQ and NE, we can always pick a value for the undef to make the\n    // predicate pass or fail, so we can return undef.\n    // Matches behavior in llvm::ConstantFoldCompareInstruction.\n    // icmp eq/ne X, undef -> undef.\n    if ((N1.isUndef() || N2.isUndef()) &&\n        (Cond == ISD::SETEQ || Cond == ISD::SETNE))\n      return getUNDEF(VT);\n\n    // If both operands are undef, we can return undef for int comparison.\n    // icmp undef, undef -> undef.\n    if (N1.isUndef() && N2.isUndef())\n      return getUNDEF(VT);\n\n    // icmp X, X -> true/false\n    // icmp X, undef -> true/false because undef could be X.\n    if (N1 == N2)\n      return getBoolConstant(ISD::isTrueWhenEqual(Cond), dl, VT, OpVT);\n  }\n\n  if (ConstantSDNode *N2C = dyn_cast<ConstantSDNode>(N2)) {\n    const APInt &C2 = N2C->getAPIntValue();\n    if (ConstantSDNode *N1C = dyn_cast<ConstantSDNode>(N1)) {\n      const APInt &C1 = N1C->getAPIntValue();\n\n      switch (Cond) {\n      default: llvm_unreachable(\"Unknown integer setcc!\");\n      case ISD::SETEQ:  return getBoolConstant(C1 == C2, dl, VT, OpVT);\n      case ISD::SETNE:  return getBoolConstant(C1 != C2, dl, VT, OpVT);\n      case ISD::SETULT: return getBoolConstant(C1.ult(C2), dl, VT, OpVT);\n      case ISD::SETUGT: return getBoolConstant(C1.ugt(C2), dl, VT, OpVT);\n      case ISD::SETULE: return getBoolConstant(C1.ule(C2), dl, VT, OpVT);\n      case ISD::SETUGE: return getBoolConstant(C1.uge(C2), dl, VT, OpVT);\n      case ISD::SETLT:  return getBoolConstant(C1.slt(C2), dl, VT, OpVT);\n      case ISD::SETGT:  return getBoolConstant(C1.sgt(C2), dl, VT, OpVT);\n      case ISD::SETLE:  return getBoolConstant(C1.sle(C2), dl, VT, OpVT);\n      case ISD::SETGE:  return getBoolConstant(C1.sge(C2), dl, VT, OpVT);\n      }\n    }\n  }\n\n  auto *N1CFP = dyn_cast<ConstantFPSDNode>(N1);\n  auto *N2CFP = dyn_cast<ConstantFPSDNode>(N2);\n\n  if (N1CFP && N2CFP) {\n    APFloat::cmpResult R = N1CFP->getValueAPF().compare(N2CFP->getValueAPF());\n    switch (Cond) {\n    default: break;\n    case ISD::SETEQ:  if (R==APFloat::cmpUnordered)\n                        return getUNDEF(VT);\n                      LLVM_FALLTHROUGH;\n    case ISD::SETOEQ: return getBoolConstant(R==APFloat::cmpEqual, dl, VT,\n                                             OpVT);\n    case ISD::SETNE:  if (R==APFloat::cmpUnordered)\n                        return getUNDEF(VT);\n                      LLVM_FALLTHROUGH;\n    case ISD::SETONE: return getBoolConstant(R==APFloat::cmpGreaterThan ||\n                                             R==APFloat::cmpLessThan, dl, VT,\n                                             OpVT);\n    case ISD::SETLT:  if (R==APFloat::cmpUnordered)\n                        return getUNDEF(VT);\n                      LLVM_FALLTHROUGH;\n    case ISD::SETOLT: return getBoolConstant(R==APFloat::cmpLessThan, dl, VT,\n                                             OpVT);\n    case ISD::SETGT:  if (R==APFloat::cmpUnordered)\n                        return getUNDEF(VT);\n                      LLVM_FALLTHROUGH;\n    case ISD::SETOGT: return getBoolConstant(R==APFloat::cmpGreaterThan, dl,\n                                             VT, OpVT);\n    case ISD::SETLE:  if (R==APFloat::cmpUnordered)\n                        return getUNDEF(VT);\n                      LLVM_FALLTHROUGH;\n    case ISD::SETOLE: return getBoolConstant(R==APFloat::cmpLessThan ||\n                                             R==APFloat::cmpEqual, dl, VT,\n                                             OpVT);\n    case ISD::SETGE:  if (R==APFloat::cmpUnordered)\n                        return getUNDEF(VT);\n                      LLVM_FALLTHROUGH;\n    case ISD::SETOGE: return getBoolConstant(R==APFloat::cmpGreaterThan ||\n                                         R==APFloat::cmpEqual, dl, VT, OpVT);\n    case ISD::SETO:   return getBoolConstant(R!=APFloat::cmpUnordered, dl, VT,\n                                             OpVT);\n    case ISD::SETUO:  return getBoolConstant(R==APFloat::cmpUnordered, dl, VT,\n                                             OpVT);\n    case ISD::SETUEQ: return getBoolConstant(R==APFloat::cmpUnordered ||\n                                             R==APFloat::cmpEqual, dl, VT,\n                                             OpVT);\n    case ISD::SETUNE: return getBoolConstant(R!=APFloat::cmpEqual, dl, VT,\n                                             OpVT);\n    case ISD::SETULT: return getBoolConstant(R==APFloat::cmpUnordered ||\n                                             R==APFloat::cmpLessThan, dl, VT,\n                                             OpVT);\n    case ISD::SETUGT: return getBoolConstant(R==APFloat::cmpGreaterThan ||\n                                             R==APFloat::cmpUnordered, dl, VT,\n                                             OpVT);\n    case ISD::SETULE: return getBoolConstant(R!=APFloat::cmpGreaterThan, dl,\n                                             VT, OpVT);\n    case ISD::SETUGE: return getBoolConstant(R!=APFloat::cmpLessThan, dl, VT,\n                                             OpVT);\n    }\n  } else if (N1CFP && OpVT.isSimple() && !N2.isUndef()) {\n    // Ensure that the constant occurs on the RHS.\n    ISD::CondCode SwappedCond = ISD::getSetCCSwappedOperands(Cond);\n    if (!TLI->isCondCodeLegal(SwappedCond, OpVT.getSimpleVT()))\n      return SDValue();\n    return getSetCC(dl, VT, N2, N1, SwappedCond);\n  } else if ((N2CFP && N2CFP->getValueAPF().isNaN()) ||\n             (OpVT.isFloatingPoint() && (N1.isUndef() || N2.isUndef()))) {\n    // If an operand is known to be a nan (or undef that could be a nan), we can\n    // fold it.\n    // Choosing NaN for the undef will always make unordered comparison succeed\n    // and ordered comparison fails.\n    // Matches behavior in llvm::ConstantFoldCompareInstruction.\n    switch (ISD::getUnorderedFlavor(Cond)) {\n    default:\n      llvm_unreachable(\"Unknown flavor!\");\n    case 0: // Known false.\n      return getBoolConstant(false, dl, VT, OpVT);\n    case 1: // Known true.\n      return getBoolConstant(true, dl, VT, OpVT);\n    case 2: // Undefined.\n      return getUNDEF(VT);\n    }\n  }\n\n  // Could not fold it.\n  return SDValue();\n}\n\n/// See if the specified operand can be simplified with the knowledge that only\n/// the bits specified by DemandedBits are used.\n/// TODO: really we should be making this into the DAG equivalent of\n/// SimplifyMultipleUseDemandedBits and not generate any new nodes.\nSDValue SelectionDAG::GetDemandedBits(SDValue V, const APInt &DemandedBits) {\n  EVT VT = V.getValueType();\n\n  if (VT.isScalableVector())\n    return SDValue();\n\n  APInt DemandedElts = VT.isVector()\n                           ? APInt::getAllOnesValue(VT.getVectorNumElements())\n                           : APInt(1, 1);\n  return GetDemandedBits(V, DemandedBits, DemandedElts);\n}\n\n/// See if the specified operand can be simplified with the knowledge that only\n/// the bits specified by DemandedBits are used in the elements specified by\n/// DemandedElts.\n/// TODO: really we should be making this into the DAG equivalent of\n/// SimplifyMultipleUseDemandedBits and not generate any new nodes.\nSDValue SelectionDAG::GetDemandedBits(SDValue V, const APInt &DemandedBits,\n                                      const APInt &DemandedElts) {\n  switch (V.getOpcode()) {\n  default:\n    return TLI->SimplifyMultipleUseDemandedBits(V, DemandedBits, DemandedElts,\n                                                *this, 0);\n  case ISD::Constant: {\n    const APInt &CVal = cast<ConstantSDNode>(V)->getAPIntValue();\n    APInt NewVal = CVal & DemandedBits;\n    if (NewVal != CVal)\n      return getConstant(NewVal, SDLoc(V), V.getValueType());\n    break;\n  }\n  case ISD::SRL:\n    // Only look at single-use SRLs.\n    if (!V.getNode()->hasOneUse())\n      break;\n    if (auto *RHSC = dyn_cast<ConstantSDNode>(V.getOperand(1))) {\n      // See if we can recursively simplify the LHS.\n      unsigned Amt = RHSC->getZExtValue();\n\n      // Watch out for shift count overflow though.\n      if (Amt >= DemandedBits.getBitWidth())\n        break;\n      APInt SrcDemandedBits = DemandedBits << Amt;\n      if (SDValue SimplifyLHS =\n              GetDemandedBits(V.getOperand(0), SrcDemandedBits))\n        return getNode(ISD::SRL, SDLoc(V), V.getValueType(), SimplifyLHS,\n                       V.getOperand(1));\n    }\n    break;\n  }\n  return SDValue();\n}\n\n/// SignBitIsZero - Return true if the sign bit of Op is known to be zero.  We\n/// use this predicate to simplify operations downstream.\nbool SelectionDAG::SignBitIsZero(SDValue Op, unsigned Depth) const {\n  unsigned BitWidth = Op.getScalarValueSizeInBits();\n  return MaskedValueIsZero(Op, APInt::getSignMask(BitWidth), Depth);\n}\n\n/// MaskedValueIsZero - Return true if 'V & Mask' is known to be zero.  We use\n/// this predicate to simplify operations downstream.  Mask is known to be zero\n/// for bits that V cannot have.\nbool SelectionDAG::MaskedValueIsZero(SDValue V, const APInt &Mask,\n                                     unsigned Depth) const {\n  return Mask.isSubsetOf(computeKnownBits(V, Depth).Zero);\n}\n\n/// MaskedValueIsZero - Return true if 'V & Mask' is known to be zero in\n/// DemandedElts.  We use this predicate to simplify operations downstream.\n/// Mask is known to be zero for bits that V cannot have.\nbool SelectionDAG::MaskedValueIsZero(SDValue V, const APInt &Mask,\n                                     const APInt &DemandedElts,\n                                     unsigned Depth) const {\n  return Mask.isSubsetOf(computeKnownBits(V, DemandedElts, Depth).Zero);\n}\n\n/// MaskedValueIsAllOnes - Return true if '(Op & Mask) == Mask'.\nbool SelectionDAG::MaskedValueIsAllOnes(SDValue V, const APInt &Mask,\n                                        unsigned Depth) const {\n  return Mask.isSubsetOf(computeKnownBits(V, Depth).One);\n}\n\n/// isSplatValue - Return true if the vector V has the same value\n/// across all DemandedElts. For scalable vectors it does not make\n/// sense to specify which elements are demanded or undefined, therefore\n/// they are simply ignored.\nbool SelectionDAG::isSplatValue(SDValue V, const APInt &DemandedElts,\n                                APInt &UndefElts, unsigned Depth) {\n  EVT VT = V.getValueType();\n  assert(VT.isVector() && \"Vector type expected\");\n\n  if (!VT.isScalableVector() && !DemandedElts)\n    return false; // No demanded elts, better to assume we don't know anything.\n\n  if (Depth >= MaxRecursionDepth)\n    return false; // Limit search depth.\n\n  // Deal with some common cases here that work for both fixed and scalable\n  // vector types.\n  switch (V.getOpcode()) {\n  case ISD::SPLAT_VECTOR:\n    UndefElts = V.getOperand(0).isUndef()\n                    ? APInt::getAllOnesValue(DemandedElts.getBitWidth())\n                    : APInt(DemandedElts.getBitWidth(), 0);\n    return true;\n  case ISD::ADD:\n  case ISD::SUB:\n  case ISD::AND: \n  case ISD::XOR:\n  case ISD::OR: {\n    APInt UndefLHS, UndefRHS;\n    SDValue LHS = V.getOperand(0);\n    SDValue RHS = V.getOperand(1);\n    if (isSplatValue(LHS, DemandedElts, UndefLHS, Depth + 1) &&\n        isSplatValue(RHS, DemandedElts, UndefRHS, Depth + 1)) {\n      UndefElts = UndefLHS | UndefRHS;\n      return true;\n    }\n    break;\n  }\n  case ISD::TRUNCATE:\n  case ISD::SIGN_EXTEND:\n  case ISD::ZERO_EXTEND:\n    return isSplatValue(V.getOperand(0), DemandedElts, UndefElts, Depth + 1);\n  }\n\n  // We don't support other cases than those above for scalable vectors at\n  // the moment.\n  if (VT.isScalableVector())\n    return false;\n\n  unsigned NumElts = VT.getVectorNumElements();\n  assert(NumElts == DemandedElts.getBitWidth() && \"Vector size mismatch\");\n  UndefElts = APInt::getNullValue(NumElts);\n\n  switch (V.getOpcode()) {\n  case ISD::BUILD_VECTOR: {\n    SDValue Scl;\n    for (unsigned i = 0; i != NumElts; ++i) {\n      SDValue Op = V.getOperand(i);\n      if (Op.isUndef()) {\n        UndefElts.setBit(i);\n        continue;\n      }\n      if (!DemandedElts[i])\n        continue;\n      if (Scl && Scl != Op)\n        return false;\n      Scl = Op;\n    }\n    return true;\n  }\n  case ISD::VECTOR_SHUFFLE: {\n    // Check if this is a shuffle node doing a splat.\n    // TODO: Do we need to handle shuffle(splat, undef, mask)?\n    int SplatIndex = -1;\n    ArrayRef<int> Mask = cast<ShuffleVectorSDNode>(V)->getMask();\n    for (int i = 0; i != (int)NumElts; ++i) {\n      int M = Mask[i];\n      if (M < 0) {\n        UndefElts.setBit(i);\n        continue;\n      }\n      if (!DemandedElts[i])\n        continue;\n      if (0 <= SplatIndex && SplatIndex != M)\n        return false;\n      SplatIndex = M;\n    }\n    return true;\n  }\n  case ISD::EXTRACT_SUBVECTOR: {\n    // Offset the demanded elts by the subvector index.\n    SDValue Src = V.getOperand(0);\n    uint64_t Idx = V.getConstantOperandVal(1);\n    unsigned NumSrcElts = Src.getValueType().getVectorNumElements();\n    APInt UndefSrcElts;\n    APInt DemandedSrcElts = DemandedElts.zextOrSelf(NumSrcElts).shl(Idx);\n    if (isSplatValue(Src, DemandedSrcElts, UndefSrcElts, Depth + 1)) {\n      UndefElts = UndefSrcElts.extractBits(NumElts, Idx);\n      return true;\n    }\n    break;\n  }\n  }\n\n  return false;\n}\n\n/// Helper wrapper to main isSplatValue function.\nbool SelectionDAG::isSplatValue(SDValue V, bool AllowUndefs) {\n  EVT VT = V.getValueType();\n  assert(VT.isVector() && \"Vector type expected\");\n\n  APInt UndefElts;\n  APInt DemandedElts;\n\n  // For now we don't support this with scalable vectors.\n  if (!VT.isScalableVector())\n    DemandedElts = APInt::getAllOnesValue(VT.getVectorNumElements());\n  return isSplatValue(V, DemandedElts, UndefElts) &&\n         (AllowUndefs || !UndefElts);\n}\n\nSDValue SelectionDAG::getSplatSourceVector(SDValue V, int &SplatIdx) {\n  V = peekThroughExtractSubvectors(V);\n\n  EVT VT = V.getValueType();\n  unsigned Opcode = V.getOpcode();\n  switch (Opcode) {\n  default: {\n    APInt UndefElts;\n    APInt DemandedElts;\n\n    if (!VT.isScalableVector())\n      DemandedElts = APInt::getAllOnesValue(VT.getVectorNumElements());\n\n    if (isSplatValue(V, DemandedElts, UndefElts)) {\n      if (VT.isScalableVector()) {\n        // DemandedElts and UndefElts are ignored for scalable vectors, since\n        // the only supported cases are SPLAT_VECTOR nodes.\n        SplatIdx = 0;\n      } else {\n        // Handle case where all demanded elements are UNDEF.\n        if (DemandedElts.isSubsetOf(UndefElts)) {\n          SplatIdx = 0;\n          return getUNDEF(VT);\n        }\n        SplatIdx = (UndefElts & DemandedElts).countTrailingOnes();\n      }\n      return V;\n    }\n    break;\n  }\n  case ISD::SPLAT_VECTOR:\n    SplatIdx = 0;\n    return V;\n  case ISD::VECTOR_SHUFFLE: {\n    if (VT.isScalableVector())\n      return SDValue();\n\n    // Check if this is a shuffle node doing a splat.\n    // TODO - remove this and rely purely on SelectionDAG::isSplatValue,\n    // getTargetVShiftNode currently struggles without the splat source.\n    auto *SVN = cast<ShuffleVectorSDNode>(V);\n    if (!SVN->isSplat())\n      break;\n    int Idx = SVN->getSplatIndex();\n    int NumElts = V.getValueType().getVectorNumElements();\n    SplatIdx = Idx % NumElts;\n    return V.getOperand(Idx / NumElts);\n  }\n  }\n\n  return SDValue();\n}\n\nSDValue SelectionDAG::getSplatValue(SDValue V) {\n  int SplatIdx;\n  if (SDValue SrcVector = getSplatSourceVector(V, SplatIdx))\n    return getNode(ISD::EXTRACT_VECTOR_ELT, SDLoc(V),\n                   SrcVector.getValueType().getScalarType(), SrcVector,\n                   getVectorIdxConstant(SplatIdx, SDLoc(V)));\n  return SDValue();\n}\n\nconst APInt *\nSelectionDAG::getValidShiftAmountConstant(SDValue V,\n                                          const APInt &DemandedElts) const {\n  assert((V.getOpcode() == ISD::SHL || V.getOpcode() == ISD::SRL ||\n          V.getOpcode() == ISD::SRA) &&\n         \"Unknown shift node\");\n  unsigned BitWidth = V.getScalarValueSizeInBits();\n  if (ConstantSDNode *SA = isConstOrConstSplat(V.getOperand(1), DemandedElts)) {\n    // Shifting more than the bitwidth is not valid.\n    const APInt &ShAmt = SA->getAPIntValue();\n    if (ShAmt.ult(BitWidth))\n      return &ShAmt;\n  }\n  return nullptr;\n}\n\nconst APInt *SelectionDAG::getValidMinimumShiftAmountConstant(\n    SDValue V, const APInt &DemandedElts) const {\n  assert((V.getOpcode() == ISD::SHL || V.getOpcode() == ISD::SRL ||\n          V.getOpcode() == ISD::SRA) &&\n         \"Unknown shift node\");\n  if (const APInt *ValidAmt = getValidShiftAmountConstant(V, DemandedElts))\n    return ValidAmt;\n  unsigned BitWidth = V.getScalarValueSizeInBits();\n  auto *BV = dyn_cast<BuildVectorSDNode>(V.getOperand(1));\n  if (!BV)\n    return nullptr;\n  const APInt *MinShAmt = nullptr;\n  for (unsigned i = 0, e = BV->getNumOperands(); i != e; ++i) {\n    if (!DemandedElts[i])\n      continue;\n    auto *SA = dyn_cast<ConstantSDNode>(BV->getOperand(i));\n    if (!SA)\n      return nullptr;\n    // Shifting more than the bitwidth is not valid.\n    const APInt &ShAmt = SA->getAPIntValue();\n    if (ShAmt.uge(BitWidth))\n      return nullptr;\n    if (MinShAmt && MinShAmt->ule(ShAmt))\n      continue;\n    MinShAmt = &ShAmt;\n  }\n  return MinShAmt;\n}\n\nconst APInt *SelectionDAG::getValidMaximumShiftAmountConstant(\n    SDValue V, const APInt &DemandedElts) const {\n  assert((V.getOpcode() == ISD::SHL || V.getOpcode() == ISD::SRL ||\n          V.getOpcode() == ISD::SRA) &&\n         \"Unknown shift node\");\n  if (const APInt *ValidAmt = getValidShiftAmountConstant(V, DemandedElts))\n    return ValidAmt;\n  unsigned BitWidth = V.getScalarValueSizeInBits();\n  auto *BV = dyn_cast<BuildVectorSDNode>(V.getOperand(1));\n  if (!BV)\n    return nullptr;\n  const APInt *MaxShAmt = nullptr;\n  for (unsigned i = 0, e = BV->getNumOperands(); i != e; ++i) {\n    if (!DemandedElts[i])\n      continue;\n    auto *SA = dyn_cast<ConstantSDNode>(BV->getOperand(i));\n    if (!SA)\n      return nullptr;\n    // Shifting more than the bitwidth is not valid.\n    const APInt &ShAmt = SA->getAPIntValue();\n    if (ShAmt.uge(BitWidth))\n      return nullptr;\n    if (MaxShAmt && MaxShAmt->uge(ShAmt))\n      continue;\n    MaxShAmt = &ShAmt;\n  }\n  return MaxShAmt;\n}\n\n/// Determine which bits of Op are known to be either zero or one and return\n/// them in Known. For vectors, the known bits are those that are shared by\n/// every vector element.\nKnownBits SelectionDAG::computeKnownBits(SDValue Op, unsigned Depth) const {\n  EVT VT = Op.getValueType();\n\n  // TOOD: Until we have a plan for how to represent demanded elements for\n  // scalable vectors, we can just bail out for now.\n  if (Op.getValueType().isScalableVector()) {\n    unsigned BitWidth = Op.getScalarValueSizeInBits();\n    return KnownBits(BitWidth);\n  }\n\n  APInt DemandedElts = VT.isVector()\n                           ? APInt::getAllOnesValue(VT.getVectorNumElements())\n                           : APInt(1, 1);\n  return computeKnownBits(Op, DemandedElts, Depth);\n}\n\n/// Determine which bits of Op are known to be either zero or one and return\n/// them in Known. The DemandedElts argument allows us to only collect the known\n/// bits that are shared by the requested vector elements.\nKnownBits SelectionDAG::computeKnownBits(SDValue Op, const APInt &DemandedElts,\n                                         unsigned Depth) const {\n  unsigned BitWidth = Op.getScalarValueSizeInBits();\n\n  KnownBits Known(BitWidth);   // Don't know anything.\n\n  // TOOD: Until we have a plan for how to represent demanded elements for\n  // scalable vectors, we can just bail out for now.\n  if (Op.getValueType().isScalableVector())\n    return Known;\n\n  if (auto *C = dyn_cast<ConstantSDNode>(Op)) {\n    // We know all of the bits for a constant!\n    return KnownBits::makeConstant(C->getAPIntValue());\n  }\n  if (auto *C = dyn_cast<ConstantFPSDNode>(Op)) {\n    // We know all of the bits for a constant fp!\n    return KnownBits::makeConstant(C->getValueAPF().bitcastToAPInt());\n  }\n\n  if (Depth >= MaxRecursionDepth)\n    return Known;  // Limit search depth.\n\n  KnownBits Known2;\n  unsigned NumElts = DemandedElts.getBitWidth();\n  assert((!Op.getValueType().isVector() ||\n          NumElts == Op.getValueType().getVectorNumElements()) &&\n         \"Unexpected vector size\");\n\n  if (!DemandedElts)\n    return Known;  // No demanded elts, better to assume we don't know anything.\n\n  unsigned Opcode = Op.getOpcode();\n  switch (Opcode) {\n  case ISD::BUILD_VECTOR:\n    // Collect the known bits that are shared by every demanded vector element.\n    Known.Zero.setAllBits(); Known.One.setAllBits();\n    for (unsigned i = 0, e = Op.getNumOperands(); i != e; ++i) {\n      if (!DemandedElts[i])\n        continue;\n\n      SDValue SrcOp = Op.getOperand(i);\n      Known2 = computeKnownBits(SrcOp, Depth + 1);\n\n      // BUILD_VECTOR can implicitly truncate sources, we must handle this.\n      if (SrcOp.getValueSizeInBits() != BitWidth) {\n        assert(SrcOp.getValueSizeInBits() > BitWidth &&\n               \"Expected BUILD_VECTOR implicit truncation\");\n        Known2 = Known2.trunc(BitWidth);\n      }\n\n      // Known bits are the values that are shared by every demanded element.\n      Known = KnownBits::commonBits(Known, Known2);\n\n      // If we don't know any bits, early out.\n      if (Known.isUnknown())\n        break;\n    }\n    break;\n  case ISD::VECTOR_SHUFFLE: {\n    // Collect the known bits that are shared by every vector element referenced\n    // by the shuffle.\n    APInt DemandedLHS(NumElts, 0), DemandedRHS(NumElts, 0);\n    Known.Zero.setAllBits(); Known.One.setAllBits();\n    const ShuffleVectorSDNode *SVN = cast<ShuffleVectorSDNode>(Op);\n    assert(NumElts == SVN->getMask().size() && \"Unexpected vector size\");\n    for (unsigned i = 0; i != NumElts; ++i) {\n      if (!DemandedElts[i])\n        continue;\n\n      int M = SVN->getMaskElt(i);\n      if (M < 0) {\n        // For UNDEF elements, we don't know anything about the common state of\n        // the shuffle result.\n        Known.resetAll();\n        DemandedLHS.clearAllBits();\n        DemandedRHS.clearAllBits();\n        break;\n      }\n\n      if ((unsigned)M < NumElts)\n        DemandedLHS.setBit((unsigned)M % NumElts);\n      else\n        DemandedRHS.setBit((unsigned)M % NumElts);\n    }\n    // Known bits are the values that are shared by every demanded element.\n    if (!!DemandedLHS) {\n      SDValue LHS = Op.getOperand(0);\n      Known2 = computeKnownBits(LHS, DemandedLHS, Depth + 1);\n      Known = KnownBits::commonBits(Known, Known2);\n    }\n    // If we don't know any bits, early out.\n    if (Known.isUnknown())\n      break;\n    if (!!DemandedRHS) {\n      SDValue RHS = Op.getOperand(1);\n      Known2 = computeKnownBits(RHS, DemandedRHS, Depth + 1);\n      Known = KnownBits::commonBits(Known, Known2);\n    }\n    break;\n  }\n  case ISD::CONCAT_VECTORS: {\n    // Split DemandedElts and test each of the demanded subvectors.\n    Known.Zero.setAllBits(); Known.One.setAllBits();\n    EVT SubVectorVT = Op.getOperand(0).getValueType();\n    unsigned NumSubVectorElts = SubVectorVT.getVectorNumElements();\n    unsigned NumSubVectors = Op.getNumOperands();\n    for (unsigned i = 0; i != NumSubVectors; ++i) {\n      APInt DemandedSub = DemandedElts.lshr(i * NumSubVectorElts);\n      DemandedSub = DemandedSub.trunc(NumSubVectorElts);\n      if (!!DemandedSub) {\n        SDValue Sub = Op.getOperand(i);\n        Known2 = computeKnownBits(Sub, DemandedSub, Depth + 1);\n        Known = KnownBits::commonBits(Known, Known2);\n      }\n      // If we don't know any bits, early out.\n      if (Known.isUnknown())\n        break;\n    }\n    break;\n  }\n  case ISD::INSERT_SUBVECTOR: {\n    // Demand any elements from the subvector and the remainder from the src its\n    // inserted into.\n    SDValue Src = Op.getOperand(0);\n    SDValue Sub = Op.getOperand(1);\n    uint64_t Idx = Op.getConstantOperandVal(2);\n    unsigned NumSubElts = Sub.getValueType().getVectorNumElements();\n    APInt DemandedSubElts = DemandedElts.extractBits(NumSubElts, Idx);\n    APInt DemandedSrcElts = DemandedElts;\n    DemandedSrcElts.insertBits(APInt::getNullValue(NumSubElts), Idx);\n\n    Known.One.setAllBits();\n    Known.Zero.setAllBits();\n    if (!!DemandedSubElts) {\n      Known = computeKnownBits(Sub, DemandedSubElts, Depth + 1);\n      if (Known.isUnknown())\n        break; // early-out.\n    }\n    if (!!DemandedSrcElts) {\n      Known2 = computeKnownBits(Src, DemandedSrcElts, Depth + 1);\n      Known = KnownBits::commonBits(Known, Known2);\n    }\n    break;\n  }\n  case ISD::EXTRACT_SUBVECTOR: {\n    // Offset the demanded elts by the subvector index.\n    SDValue Src = Op.getOperand(0);\n    // Bail until we can represent demanded elements for scalable vectors.\n    if (Src.getValueType().isScalableVector())\n      break;\n    uint64_t Idx = Op.getConstantOperandVal(1);\n    unsigned NumSrcElts = Src.getValueType().getVectorNumElements();\n    APInt DemandedSrcElts = DemandedElts.zextOrSelf(NumSrcElts).shl(Idx);\n    Known = computeKnownBits(Src, DemandedSrcElts, Depth + 1);\n    break;\n  }\n  case ISD::SCALAR_TO_VECTOR: {\n    // We know about scalar_to_vector as much as we know about it source,\n    // which becomes the first element of otherwise unknown vector.\n    if (DemandedElts != 1)\n      break;\n\n    SDValue N0 = Op.getOperand(0);\n    Known = computeKnownBits(N0, Depth + 1);\n    if (N0.getValueSizeInBits() != BitWidth)\n      Known = Known.trunc(BitWidth);\n\n    break;\n  }\n  case ISD::BITCAST: {\n    SDValue N0 = Op.getOperand(0);\n    EVT SubVT = N0.getValueType();\n    unsigned SubBitWidth = SubVT.getScalarSizeInBits();\n\n    // Ignore bitcasts from unsupported types.\n    if (!(SubVT.isInteger() || SubVT.isFloatingPoint()))\n      break;\n\n    // Fast handling of 'identity' bitcasts.\n    if (BitWidth == SubBitWidth) {\n      Known = computeKnownBits(N0, DemandedElts, Depth + 1);\n      break;\n    }\n\n    bool IsLE = getDataLayout().isLittleEndian();\n\n    // Bitcast 'small element' vector to 'large element' scalar/vector.\n    if ((BitWidth % SubBitWidth) == 0) {\n      assert(N0.getValueType().isVector() && \"Expected bitcast from vector\");\n\n      // Collect known bits for the (larger) output by collecting the known\n      // bits from each set of sub elements and shift these into place.\n      // We need to separately call computeKnownBits for each set of\n      // sub elements as the knownbits for each is likely to be different.\n      unsigned SubScale = BitWidth / SubBitWidth;\n      APInt SubDemandedElts(NumElts * SubScale, 0);\n      for (unsigned i = 0; i != NumElts; ++i)\n        if (DemandedElts[i])\n          SubDemandedElts.setBit(i * SubScale);\n\n      for (unsigned i = 0; i != SubScale; ++i) {\n        Known2 = computeKnownBits(N0, SubDemandedElts.shl(i),\n                         Depth + 1);\n        unsigned Shifts = IsLE ? i : SubScale - 1 - i;\n        Known.One |= Known2.One.zext(BitWidth).shl(SubBitWidth * Shifts);\n        Known.Zero |= Known2.Zero.zext(BitWidth).shl(SubBitWidth * Shifts);\n      }\n    }\n\n    // Bitcast 'large element' scalar/vector to 'small element' vector.\n    if ((SubBitWidth % BitWidth) == 0) {\n      assert(Op.getValueType().isVector() && \"Expected bitcast to vector\");\n\n      // Collect known bits for the (smaller) output by collecting the known\n      // bits from the overlapping larger input elements and extracting the\n      // sub sections we actually care about.\n      unsigned SubScale = SubBitWidth / BitWidth;\n      APInt SubDemandedElts(NumElts / SubScale, 0);\n      for (unsigned i = 0; i != NumElts; ++i)\n        if (DemandedElts[i])\n          SubDemandedElts.setBit(i / SubScale);\n\n      Known2 = computeKnownBits(N0, SubDemandedElts, Depth + 1);\n\n      Known.Zero.setAllBits(); Known.One.setAllBits();\n      for (unsigned i = 0; i != NumElts; ++i)\n        if (DemandedElts[i]) {\n          unsigned Shifts = IsLE ? i : NumElts - 1 - i;\n          unsigned Offset = (Shifts % SubScale) * BitWidth;\n          Known.One &= Known2.One.lshr(Offset).trunc(BitWidth);\n          Known.Zero &= Known2.Zero.lshr(Offset).trunc(BitWidth);\n          // If we don't know any bits, early out.\n          if (Known.isUnknown())\n            break;\n        }\n    }\n    break;\n  }\n  case ISD::AND:\n    Known = computeKnownBits(Op.getOperand(1), DemandedElts, Depth + 1);\n    Known2 = computeKnownBits(Op.getOperand(0), DemandedElts, Depth + 1);\n\n    Known &= Known2;\n    break;\n  case ISD::OR:\n    Known = computeKnownBits(Op.getOperand(1), DemandedElts, Depth + 1);\n    Known2 = computeKnownBits(Op.getOperand(0), DemandedElts, Depth + 1);\n\n    Known |= Known2;\n    break;\n  case ISD::XOR:\n    Known = computeKnownBits(Op.getOperand(1), DemandedElts, Depth + 1);\n    Known2 = computeKnownBits(Op.getOperand(0), DemandedElts, Depth + 1);\n\n    Known ^= Known2;\n    break;\n  case ISD::MUL: {\n    Known = computeKnownBits(Op.getOperand(1), DemandedElts, Depth + 1);\n    Known2 = computeKnownBits(Op.getOperand(0), DemandedElts, Depth + 1);\n    Known = KnownBits::computeForMul(Known, Known2);\n    break;\n  }\n  case ISD::UDIV: {\n    Known = computeKnownBits(Op.getOperand(0), DemandedElts, Depth + 1);\n    Known2 = computeKnownBits(Op.getOperand(1), DemandedElts, Depth + 1);\n    Known = KnownBits::udiv(Known, Known2);\n    break;\n  }\n  case ISD::SELECT:\n  case ISD::VSELECT:\n    Known = computeKnownBits(Op.getOperand(2), DemandedElts, Depth+1);\n    // If we don't know any bits, early out.\n    if (Known.isUnknown())\n      break;\n    Known2 = computeKnownBits(Op.getOperand(1), DemandedElts, Depth+1);\n\n    // Only known if known in both the LHS and RHS.\n    Known = KnownBits::commonBits(Known, Known2);\n    break;\n  case ISD::SELECT_CC:\n    Known = computeKnownBits(Op.getOperand(3), DemandedElts, Depth+1);\n    // If we don't know any bits, early out.\n    if (Known.isUnknown())\n      break;\n    Known2 = computeKnownBits(Op.getOperand(2), DemandedElts, Depth+1);\n\n    // Only known if known in both the LHS and RHS.\n    Known = KnownBits::commonBits(Known, Known2);\n    break;\n  case ISD::SMULO:\n  case ISD::UMULO:\n  case ISD::ATOMIC_CMP_SWAP_WITH_SUCCESS:\n    if (Op.getResNo() != 1)\n      break;\n    // The boolean result conforms to getBooleanContents.\n    // If we know the result of a setcc has the top bits zero, use this info.\n    // We know that we have an integer-based boolean since these operations\n    // are only available for integer.\n    if (TLI->getBooleanContents(Op.getValueType().isVector(), false) ==\n            TargetLowering::ZeroOrOneBooleanContent &&\n        BitWidth > 1)\n      Known.Zero.setBitsFrom(1);\n    break;\n  case ISD::SETCC:\n  case ISD::STRICT_FSETCC:\n  case ISD::STRICT_FSETCCS: {\n    unsigned OpNo = Op->isStrictFPOpcode() ? 1 : 0;\n    // If we know the result of a setcc has the top bits zero, use this info.\n    if (TLI->getBooleanContents(Op.getOperand(OpNo).getValueType()) ==\n            TargetLowering::ZeroOrOneBooleanContent &&\n        BitWidth > 1)\n      Known.Zero.setBitsFrom(1);\n    break;\n  }\n  case ISD::SHL:\n    Known = computeKnownBits(Op.getOperand(0), DemandedElts, Depth + 1);\n    Known2 = computeKnownBits(Op.getOperand(1), DemandedElts, Depth + 1);\n    Known = KnownBits::shl(Known, Known2);\n\n    // Minimum shift low bits are known zero.\n    if (const APInt *ShMinAmt =\n            getValidMinimumShiftAmountConstant(Op, DemandedElts))\n      Known.Zero.setLowBits(ShMinAmt->getZExtValue());\n    break;\n  case ISD::SRL:\n    Known = computeKnownBits(Op.getOperand(0), DemandedElts, Depth + 1);\n    Known2 = computeKnownBits(Op.getOperand(1), DemandedElts, Depth + 1);\n    Known = KnownBits::lshr(Known, Known2);\n\n    // Minimum shift high bits are known zero.\n    if (const APInt *ShMinAmt =\n            getValidMinimumShiftAmountConstant(Op, DemandedElts))\n      Known.Zero.setHighBits(ShMinAmt->getZExtValue());\n    break;\n  case ISD::SRA:\n    Known = computeKnownBits(Op.getOperand(0), DemandedElts, Depth + 1);\n    Known2 = computeKnownBits(Op.getOperand(1), DemandedElts, Depth + 1);\n    Known = KnownBits::ashr(Known, Known2);\n    // TODO: Add minimum shift high known sign bits.\n    break;\n  case ISD::FSHL:\n  case ISD::FSHR:\n    if (ConstantSDNode *C = isConstOrConstSplat(Op.getOperand(2), DemandedElts)) {\n      unsigned Amt = C->getAPIntValue().urem(BitWidth);\n\n      // For fshl, 0-shift returns the 1st arg.\n      // For fshr, 0-shift returns the 2nd arg.\n      if (Amt == 0) {\n        Known = computeKnownBits(Op.getOperand(Opcode == ISD::FSHL ? 0 : 1),\n                                 DemandedElts, Depth + 1);\n        break;\n      }\n\n      // fshl: (X << (Z % BW)) | (Y >> (BW - (Z % BW)))\n      // fshr: (X << (BW - (Z % BW))) | (Y >> (Z % BW))\n      Known = computeKnownBits(Op.getOperand(0), DemandedElts, Depth + 1);\n      Known2 = computeKnownBits(Op.getOperand(1), DemandedElts, Depth + 1);\n      if (Opcode == ISD::FSHL) {\n        Known.One <<= Amt;\n        Known.Zero <<= Amt;\n        Known2.One.lshrInPlace(BitWidth - Amt);\n        Known2.Zero.lshrInPlace(BitWidth - Amt);\n      } else {\n        Known.One <<= BitWidth - Amt;\n        Known.Zero <<= BitWidth - Amt;\n        Known2.One.lshrInPlace(Amt);\n        Known2.Zero.lshrInPlace(Amt);\n      }\n      Known.One |= Known2.One;\n      Known.Zero |= Known2.Zero;\n    }\n    break;\n  case ISD::SIGN_EXTEND_INREG: {\n    Known = computeKnownBits(Op.getOperand(0), DemandedElts, Depth + 1);\n    EVT EVT = cast<VTSDNode>(Op.getOperand(1))->getVT();\n    Known = Known.sextInReg(EVT.getScalarSizeInBits());\n    break;\n  }\n  case ISD::CTTZ:\n  case ISD::CTTZ_ZERO_UNDEF: {\n    Known2 = computeKnownBits(Op.getOperand(0), DemandedElts, Depth + 1);\n    // If we have a known 1, its position is our upper bound.\n    unsigned PossibleTZ = Known2.countMaxTrailingZeros();\n    unsigned LowBits = Log2_32(PossibleTZ) + 1;\n    Known.Zero.setBitsFrom(LowBits);\n    break;\n  }\n  case ISD::CTLZ:\n  case ISD::CTLZ_ZERO_UNDEF: {\n    Known2 = computeKnownBits(Op.getOperand(0), DemandedElts, Depth + 1);\n    // If we have a known 1, its position is our upper bound.\n    unsigned PossibleLZ = Known2.countMaxLeadingZeros();\n    unsigned LowBits = Log2_32(PossibleLZ) + 1;\n    Known.Zero.setBitsFrom(LowBits);\n    break;\n  }\n  case ISD::CTPOP: {\n    Known2 = computeKnownBits(Op.getOperand(0), DemandedElts, Depth + 1);\n    // If we know some of the bits are zero, they can't be one.\n    unsigned PossibleOnes = Known2.countMaxPopulation();\n    Known.Zero.setBitsFrom(Log2_32(PossibleOnes) + 1);\n    break;\n  }\n  case ISD::PARITY: {\n    // Parity returns 0 everywhere but the LSB.\n    Known.Zero.setBitsFrom(1);\n    break;\n  }\n  case ISD::LOAD: {\n    LoadSDNode *LD = cast<LoadSDNode>(Op);\n    const Constant *Cst = TLI->getTargetConstantFromLoad(LD);\n    if (ISD::isNON_EXTLoad(LD) && Cst) {\n      // Determine any common known bits from the loaded constant pool value.\n      Type *CstTy = Cst->getType();\n      if ((NumElts * BitWidth) == CstTy->getPrimitiveSizeInBits()) {\n        // If its a vector splat, then we can (quickly) reuse the scalar path.\n        // NOTE: We assume all elements match and none are UNDEF.\n        if (CstTy->isVectorTy()) {\n          if (const Constant *Splat = Cst->getSplatValue()) {\n            Cst = Splat;\n            CstTy = Cst->getType();\n          }\n        }\n        // TODO - do we need to handle different bitwidths?\n        if (CstTy->isVectorTy() && BitWidth == CstTy->getScalarSizeInBits()) {\n          // Iterate across all vector elements finding common known bits.\n          Known.One.setAllBits();\n          Known.Zero.setAllBits();\n          for (unsigned i = 0; i != NumElts; ++i) {\n            if (!DemandedElts[i])\n              continue;\n            if (Constant *Elt = Cst->getAggregateElement(i)) {\n              if (auto *CInt = dyn_cast<ConstantInt>(Elt)) {\n                const APInt &Value = CInt->getValue();\n                Known.One &= Value;\n                Known.Zero &= ~Value;\n                continue;\n              }\n              if (auto *CFP = dyn_cast<ConstantFP>(Elt)) {\n                APInt Value = CFP->getValueAPF().bitcastToAPInt();\n                Known.One &= Value;\n                Known.Zero &= ~Value;\n                continue;\n              }\n            }\n            Known.One.clearAllBits();\n            Known.Zero.clearAllBits();\n            break;\n          }\n        } else if (BitWidth == CstTy->getPrimitiveSizeInBits()) {\n          if (auto *CInt = dyn_cast<ConstantInt>(Cst)) {\n            Known = KnownBits::makeConstant(CInt->getValue());\n          } else if (auto *CFP = dyn_cast<ConstantFP>(Cst)) {\n            Known =\n                KnownBits::makeConstant(CFP->getValueAPF().bitcastToAPInt());\n          }\n        }\n      }\n    } else if (ISD::isZEXTLoad(Op.getNode()) && Op.getResNo() == 0) {\n      // If this is a ZEXTLoad and we are looking at the loaded value.\n      EVT VT = LD->getMemoryVT();\n      unsigned MemBits = VT.getScalarSizeInBits();\n      Known.Zero.setBitsFrom(MemBits);\n    } else if (const MDNode *Ranges = LD->getRanges()) {\n      if (LD->getExtensionType() == ISD::NON_EXTLOAD)\n        computeKnownBitsFromRangeMetadata(*Ranges, Known);\n    }\n    break;\n  }\n  case ISD::ZERO_EXTEND_VECTOR_INREG: {\n    EVT InVT = Op.getOperand(0).getValueType();\n    APInt InDemandedElts = DemandedElts.zextOrSelf(InVT.getVectorNumElements());\n    Known = computeKnownBits(Op.getOperand(0), InDemandedElts, Depth + 1);\n    Known = Known.zext(BitWidth);\n    break;\n  }\n  case ISD::ZERO_EXTEND: {\n    Known = computeKnownBits(Op.getOperand(0), DemandedElts, Depth + 1);\n    Known = Known.zext(BitWidth);\n    break;\n  }\n  case ISD::SIGN_EXTEND_VECTOR_INREG: {\n    EVT InVT = Op.getOperand(0).getValueType();\n    APInt InDemandedElts = DemandedElts.zextOrSelf(InVT.getVectorNumElements());\n    Known = computeKnownBits(Op.getOperand(0), InDemandedElts, Depth + 1);\n    // If the sign bit is known to be zero or one, then sext will extend\n    // it to the top bits, else it will just zext.\n    Known = Known.sext(BitWidth);\n    break;\n  }\n  case ISD::SIGN_EXTEND: {\n    Known = computeKnownBits(Op.getOperand(0), DemandedElts, Depth + 1);\n    // If the sign bit is known to be zero or one, then sext will extend\n    // it to the top bits, else it will just zext.\n    Known = Known.sext(BitWidth);\n    break;\n  }\n  case ISD::ANY_EXTEND_VECTOR_INREG: {\n    EVT InVT = Op.getOperand(0).getValueType();\n    APInt InDemandedElts = DemandedElts.zextOrSelf(InVT.getVectorNumElements());\n    Known = computeKnownBits(Op.getOperand(0), InDemandedElts, Depth + 1);\n    Known = Known.anyext(BitWidth);\n    break;\n  }\n  case ISD::ANY_EXTEND: {\n    Known = computeKnownBits(Op.getOperand(0), DemandedElts, Depth + 1);\n    Known = Known.anyext(BitWidth);\n    break;\n  }\n  case ISD::TRUNCATE: {\n    Known = computeKnownBits(Op.getOperand(0), DemandedElts, Depth + 1);\n    Known = Known.trunc(BitWidth);\n    break;\n  }\n  case ISD::AssertZext: {\n    EVT VT = cast<VTSDNode>(Op.getOperand(1))->getVT();\n    APInt InMask = APInt::getLowBitsSet(BitWidth, VT.getSizeInBits());\n    Known = computeKnownBits(Op.getOperand(0), Depth+1);\n    Known.Zero |= (~InMask);\n    Known.One  &= (~Known.Zero);\n    break;\n  }\n  case ISD::AssertAlign: {\n    unsigned LogOfAlign = Log2(cast<AssertAlignSDNode>(Op)->getAlign());\n    assert(LogOfAlign != 0);\n    // If a node is guaranteed to be aligned, set low zero bits accordingly as\n    // well as clearing one bits.\n    Known.Zero.setLowBits(LogOfAlign);\n    Known.One.clearLowBits(LogOfAlign);\n    break;\n  }\n  case ISD::FGETSIGN:\n    // All bits are zero except the low bit.\n    Known.Zero.setBitsFrom(1);\n    break;\n  case ISD::USUBO:\n  case ISD::SSUBO:\n    if (Op.getResNo() == 1) {\n      // If we know the result of a setcc has the top bits zero, use this info.\n      if (TLI->getBooleanContents(Op.getOperand(0).getValueType()) ==\n              TargetLowering::ZeroOrOneBooleanContent &&\n          BitWidth > 1)\n        Known.Zero.setBitsFrom(1);\n      break;\n    }\n    LLVM_FALLTHROUGH;\n  case ISD::SUB:\n  case ISD::SUBC: {\n    assert(Op.getResNo() == 0 &&\n           \"We only compute knownbits for the difference here.\");\n\n    Known = computeKnownBits(Op.getOperand(0), DemandedElts, Depth + 1);\n    Known2 = computeKnownBits(Op.getOperand(1), DemandedElts, Depth + 1);\n    Known = KnownBits::computeForAddSub(/* Add */ false, /* NSW */ false,\n                                        Known, Known2);\n    break;\n  }\n  case ISD::UADDO:\n  case ISD::SADDO:\n  case ISD::ADDCARRY:\n    if (Op.getResNo() == 1) {\n      // If we know the result of a setcc has the top bits zero, use this info.\n      if (TLI->getBooleanContents(Op.getOperand(0).getValueType()) ==\n              TargetLowering::ZeroOrOneBooleanContent &&\n          BitWidth > 1)\n        Known.Zero.setBitsFrom(1);\n      break;\n    }\n    LLVM_FALLTHROUGH;\n  case ISD::ADD:\n  case ISD::ADDC:\n  case ISD::ADDE: {\n    assert(Op.getResNo() == 0 && \"We only compute knownbits for the sum here.\");\n\n    // With ADDE and ADDCARRY, a carry bit may be added in.\n    KnownBits Carry(1);\n    if (Opcode == ISD::ADDE)\n      // Can't track carry from glue, set carry to unknown.\n      Carry.resetAll();\n    else if (Opcode == ISD::ADDCARRY)\n      // TODO: Compute known bits for the carry operand. Not sure if it is worth\n      // the trouble (how often will we find a known carry bit). And I haven't\n      // tested this very much yet, but something like this might work:\n      //   Carry = computeKnownBits(Op.getOperand(2), DemandedElts, Depth + 1);\n      //   Carry = Carry.zextOrTrunc(1, false);\n      Carry.resetAll();\n    else\n      Carry.setAllZero();\n\n    Known = computeKnownBits(Op.getOperand(0), DemandedElts, Depth + 1);\n    Known2 = computeKnownBits(Op.getOperand(1), DemandedElts, Depth + 1);\n    Known = KnownBits::computeForAddCarry(Known, Known2, Carry);\n    break;\n  }\n  case ISD::SREM: {\n    Known = computeKnownBits(Op.getOperand(0), DemandedElts, Depth + 1);\n    Known2 = computeKnownBits(Op.getOperand(1), DemandedElts, Depth + 1);\n    Known = KnownBits::srem(Known, Known2);\n    break;\n  }\n  case ISD::UREM: {\n    Known = computeKnownBits(Op.getOperand(0), DemandedElts, Depth + 1);\n    Known2 = computeKnownBits(Op.getOperand(1), DemandedElts, Depth + 1);\n    Known = KnownBits::urem(Known, Known2);\n    break;\n  }\n  case ISD::EXTRACT_ELEMENT: {\n    Known = computeKnownBits(Op.getOperand(0), Depth+1);\n    const unsigned Index = Op.getConstantOperandVal(1);\n    const unsigned EltBitWidth = Op.getValueSizeInBits();\n\n    // Remove low part of known bits mask\n    Known.Zero = Known.Zero.getHiBits(Known.getBitWidth() - Index * EltBitWidth);\n    Known.One = Known.One.getHiBits(Known.getBitWidth() - Index * EltBitWidth);\n\n    // Remove high part of known bit mask\n    Known = Known.trunc(EltBitWidth);\n    break;\n  }\n  case ISD::EXTRACT_VECTOR_ELT: {\n    SDValue InVec = Op.getOperand(0);\n    SDValue EltNo = Op.getOperand(1);\n    EVT VecVT = InVec.getValueType();\n    // computeKnownBits not yet implemented for scalable vectors.\n    if (VecVT.isScalableVector())\n      break;\n    const unsigned EltBitWidth = VecVT.getScalarSizeInBits();\n    const unsigned NumSrcElts = VecVT.getVectorNumElements();\n\n    // If BitWidth > EltBitWidth the value is anyext:ed. So we do not know\n    // anything about the extended bits.\n    if (BitWidth > EltBitWidth)\n      Known = Known.trunc(EltBitWidth);\n\n    // If we know the element index, just demand that vector element, else for\n    // an unknown element index, ignore DemandedElts and demand them all.\n    APInt DemandedSrcElts = APInt::getAllOnesValue(NumSrcElts);\n    auto *ConstEltNo = dyn_cast<ConstantSDNode>(EltNo);\n    if (ConstEltNo && ConstEltNo->getAPIntValue().ult(NumSrcElts))\n      DemandedSrcElts =\n          APInt::getOneBitSet(NumSrcElts, ConstEltNo->getZExtValue());\n\n    Known = computeKnownBits(InVec, DemandedSrcElts, Depth + 1);\n    if (BitWidth > EltBitWidth)\n      Known = Known.anyext(BitWidth);\n    break;\n  }\n  case ISD::INSERT_VECTOR_ELT: {\n    // If we know the element index, split the demand between the\n    // source vector and the inserted element, otherwise assume we need\n    // the original demanded vector elements and the value.\n    SDValue InVec = Op.getOperand(0);\n    SDValue InVal = Op.getOperand(1);\n    SDValue EltNo = Op.getOperand(2);\n    bool DemandedVal = true;\n    APInt DemandedVecElts = DemandedElts;\n    auto *CEltNo = dyn_cast<ConstantSDNode>(EltNo);\n    if (CEltNo && CEltNo->getAPIntValue().ult(NumElts)) {\n      unsigned EltIdx = CEltNo->getZExtValue();\n      DemandedVal = !!DemandedElts[EltIdx];\n      DemandedVecElts.clearBit(EltIdx);\n    }\n    Known.One.setAllBits();\n    Known.Zero.setAllBits();\n    if (DemandedVal) {\n      Known2 = computeKnownBits(InVal, Depth + 1);\n      Known = KnownBits::commonBits(Known, Known2.zextOrTrunc(BitWidth));\n    }\n    if (!!DemandedVecElts) {\n      Known2 = computeKnownBits(InVec, DemandedVecElts, Depth + 1);\n      Known = KnownBits::commonBits(Known, Known2);\n    }\n    break;\n  }\n  case ISD::BITREVERSE: {\n    Known2 = computeKnownBits(Op.getOperand(0), DemandedElts, Depth + 1);\n    Known = Known2.reverseBits();\n    break;\n  }\n  case ISD::BSWAP: {\n    Known2 = computeKnownBits(Op.getOperand(0), DemandedElts, Depth + 1);\n    Known = Known2.byteSwap();\n    break;\n  }\n  case ISD::ABS: {\n    Known2 = computeKnownBits(Op.getOperand(0), DemandedElts, Depth + 1);\n    Known = Known2.abs();\n    break;\n  }\n  case ISD::USUBSAT: {\n    // The result of usubsat will never be larger than the LHS.\n    Known2 = computeKnownBits(Op.getOperand(0), DemandedElts, Depth + 1);\n    Known.Zero.setHighBits(Known2.countMinLeadingZeros());\n    break;\n  }\n  case ISD::UMIN: {\n    Known = computeKnownBits(Op.getOperand(0), DemandedElts, Depth + 1);\n    Known2 = computeKnownBits(Op.getOperand(1), DemandedElts, Depth + 1);\n    Known = KnownBits::umin(Known, Known2);\n    break;\n  }\n  case ISD::UMAX: {\n    Known = computeKnownBits(Op.getOperand(0), DemandedElts, Depth + 1);\n    Known2 = computeKnownBits(Op.getOperand(1), DemandedElts, Depth + 1);\n    Known = KnownBits::umax(Known, Known2);\n    break;\n  }\n  case ISD::SMIN:\n  case ISD::SMAX: {\n    // If we have a clamp pattern, we know that the number of sign bits will be\n    // the minimum of the clamp min/max range.\n    bool IsMax = (Opcode == ISD::SMAX);\n    ConstantSDNode *CstLow = nullptr, *CstHigh = nullptr;\n    if ((CstLow = isConstOrConstSplat(Op.getOperand(1), DemandedElts)))\n      if (Op.getOperand(0).getOpcode() == (IsMax ? ISD::SMIN : ISD::SMAX))\n        CstHigh =\n            isConstOrConstSplat(Op.getOperand(0).getOperand(1), DemandedElts);\n    if (CstLow && CstHigh) {\n      if (!IsMax)\n        std::swap(CstLow, CstHigh);\n\n      const APInt &ValueLow = CstLow->getAPIntValue();\n      const APInt &ValueHigh = CstHigh->getAPIntValue();\n      if (ValueLow.sle(ValueHigh)) {\n        unsigned LowSignBits = ValueLow.getNumSignBits();\n        unsigned HighSignBits = ValueHigh.getNumSignBits();\n        unsigned MinSignBits = std::min(LowSignBits, HighSignBits);\n        if (ValueLow.isNegative() && ValueHigh.isNegative()) {\n          Known.One.setHighBits(MinSignBits);\n          break;\n        }\n        if (ValueLow.isNonNegative() && ValueHigh.isNonNegative()) {\n          Known.Zero.setHighBits(MinSignBits);\n          break;\n        }\n      }\n    }\n\n    Known = computeKnownBits(Op.getOperand(0), DemandedElts, Depth + 1);\n    Known2 = computeKnownBits(Op.getOperand(1), DemandedElts, Depth + 1);\n    if (IsMax)\n      Known = KnownBits::smax(Known, Known2);\n    else\n      Known = KnownBits::smin(Known, Known2);\n    break;\n  }\n  case ISD::FrameIndex:\n  case ISD::TargetFrameIndex:\n    TLI->computeKnownBitsForFrameIndex(cast<FrameIndexSDNode>(Op)->getIndex(),\n                                       Known, getMachineFunction());\n    break;\n\n  default:\n    if (Opcode < ISD::BUILTIN_OP_END)\n      break;\n    LLVM_FALLTHROUGH;\n  case ISD::INTRINSIC_WO_CHAIN:\n  case ISD::INTRINSIC_W_CHAIN:\n  case ISD::INTRINSIC_VOID:\n    // Allow the target to implement this method for its nodes.\n    TLI->computeKnownBitsForTargetNode(Op, Known, DemandedElts, *this, Depth);\n    break;\n  }\n\n  assert(!Known.hasConflict() && \"Bits known to be one AND zero?\");\n  return Known;\n}\n\nSelectionDAG::OverflowKind SelectionDAG::computeOverflowKind(SDValue N0,\n                                                             SDValue N1) const {\n  // X + 0 never overflow\n  if (isNullConstant(N1))\n    return OFK_Never;\n\n  KnownBits N1Known = computeKnownBits(N1);\n  if (N1Known.Zero.getBoolValue()) {\n    KnownBits N0Known = computeKnownBits(N0);\n\n    bool overflow;\n    (void)N0Known.getMaxValue().uadd_ov(N1Known.getMaxValue(), overflow);\n    if (!overflow)\n      return OFK_Never;\n  }\n\n  // mulhi + 1 never overflow\n  if (N0.getOpcode() == ISD::UMUL_LOHI && N0.getResNo() == 1 &&\n      (N1Known.getMaxValue() & 0x01) == N1Known.getMaxValue())\n    return OFK_Never;\n\n  if (N1.getOpcode() == ISD::UMUL_LOHI && N1.getResNo() == 1) {\n    KnownBits N0Known = computeKnownBits(N0);\n\n    if ((N0Known.getMaxValue() & 0x01) == N0Known.getMaxValue())\n      return OFK_Never;\n  }\n\n  return OFK_Sometime;\n}\n\nbool SelectionDAG::isKnownToBeAPowerOfTwo(SDValue Val) const {\n  EVT OpVT = Val.getValueType();\n  unsigned BitWidth = OpVT.getScalarSizeInBits();\n\n  // Is the constant a known power of 2?\n  if (ConstantSDNode *Const = dyn_cast<ConstantSDNode>(Val))\n    return Const->getAPIntValue().zextOrTrunc(BitWidth).isPowerOf2();\n\n  // A left-shift of a constant one will have exactly one bit set because\n  // shifting the bit off the end is undefined.\n  if (Val.getOpcode() == ISD::SHL) {\n    auto *C = isConstOrConstSplat(Val.getOperand(0));\n    if (C && C->getAPIntValue() == 1)\n      return true;\n  }\n\n  // Similarly, a logical right-shift of a constant sign-bit will have exactly\n  // one bit set.\n  if (Val.getOpcode() == ISD::SRL) {\n    auto *C = isConstOrConstSplat(Val.getOperand(0));\n    if (C && C->getAPIntValue().isSignMask())\n      return true;\n  }\n\n  // Are all operands of a build vector constant powers of two?\n  if (Val.getOpcode() == ISD::BUILD_VECTOR)\n    if (llvm::all_of(Val->ops(), [BitWidth](SDValue E) {\n          if (ConstantSDNode *C = dyn_cast<ConstantSDNode>(E))\n            return C->getAPIntValue().zextOrTrunc(BitWidth).isPowerOf2();\n          return false;\n        }))\n      return true;\n\n  // More could be done here, though the above checks are enough\n  // to handle some common cases.\n\n  // Fall back to computeKnownBits to catch other known cases.\n  KnownBits Known = computeKnownBits(Val);\n  return (Known.countMaxPopulation() == 1) && (Known.countMinPopulation() == 1);\n}\n\nunsigned SelectionDAG::ComputeNumSignBits(SDValue Op, unsigned Depth) const {\n  EVT VT = Op.getValueType();\n\n  // TODO: Assume we don't know anything for now.\n  if (VT.isScalableVector())\n    return 1;\n\n  APInt DemandedElts = VT.isVector()\n                           ? APInt::getAllOnesValue(VT.getVectorNumElements())\n                           : APInt(1, 1);\n  return ComputeNumSignBits(Op, DemandedElts, Depth);\n}\n\nunsigned SelectionDAG::ComputeNumSignBits(SDValue Op, const APInt &DemandedElts,\n                                          unsigned Depth) const {\n  EVT VT = Op.getValueType();\n  assert((VT.isInteger() || VT.isFloatingPoint()) && \"Invalid VT!\");\n  unsigned VTBits = VT.getScalarSizeInBits();\n  unsigned NumElts = DemandedElts.getBitWidth();\n  unsigned Tmp, Tmp2;\n  unsigned FirstAnswer = 1;\n\n  if (auto *C = dyn_cast<ConstantSDNode>(Op)) {\n    const APInt &Val = C->getAPIntValue();\n    return Val.getNumSignBits();\n  }\n\n  if (Depth >= MaxRecursionDepth)\n    return 1;  // Limit search depth.\n\n  if (!DemandedElts || VT.isScalableVector())\n    return 1;  // No demanded elts, better to assume we don't know anything.\n\n  unsigned Opcode = Op.getOpcode();\n  switch (Opcode) {\n  default: break;\n  case ISD::AssertSext:\n    Tmp = cast<VTSDNode>(Op.getOperand(1))->getVT().getSizeInBits();\n    return VTBits-Tmp+1;\n  case ISD::AssertZext:\n    Tmp = cast<VTSDNode>(Op.getOperand(1))->getVT().getSizeInBits();\n    return VTBits-Tmp;\n\n  case ISD::BUILD_VECTOR:\n    Tmp = VTBits;\n    for (unsigned i = 0, e = Op.getNumOperands(); (i < e) && (Tmp > 1); ++i) {\n      if (!DemandedElts[i])\n        continue;\n\n      SDValue SrcOp = Op.getOperand(i);\n      Tmp2 = ComputeNumSignBits(SrcOp, Depth + 1);\n\n      // BUILD_VECTOR can implicitly truncate sources, we must handle this.\n      if (SrcOp.getValueSizeInBits() != VTBits) {\n        assert(SrcOp.getValueSizeInBits() > VTBits &&\n               \"Expected BUILD_VECTOR implicit truncation\");\n        unsigned ExtraBits = SrcOp.getValueSizeInBits() - VTBits;\n        Tmp2 = (Tmp2 > ExtraBits ? Tmp2 - ExtraBits : 1);\n      }\n      Tmp = std::min(Tmp, Tmp2);\n    }\n    return Tmp;\n\n  case ISD::VECTOR_SHUFFLE: {\n    // Collect the minimum number of sign bits that are shared by every vector\n    // element referenced by the shuffle.\n    APInt DemandedLHS(NumElts, 0), DemandedRHS(NumElts, 0);\n    const ShuffleVectorSDNode *SVN = cast<ShuffleVectorSDNode>(Op);\n    assert(NumElts == SVN->getMask().size() && \"Unexpected vector size\");\n    for (unsigned i = 0; i != NumElts; ++i) {\n      int M = SVN->getMaskElt(i);\n      if (!DemandedElts[i])\n        continue;\n      // For UNDEF elements, we don't know anything about the common state of\n      // the shuffle result.\n      if (M < 0)\n        return 1;\n      if ((unsigned)M < NumElts)\n        DemandedLHS.setBit((unsigned)M % NumElts);\n      else\n        DemandedRHS.setBit((unsigned)M % NumElts);\n    }\n    Tmp = std::numeric_limits<unsigned>::max();\n    if (!!DemandedLHS)\n      Tmp = ComputeNumSignBits(Op.getOperand(0), DemandedLHS, Depth + 1);\n    if (!!DemandedRHS) {\n      Tmp2 = ComputeNumSignBits(Op.getOperand(1), DemandedRHS, Depth + 1);\n      Tmp = std::min(Tmp, Tmp2);\n    }\n    // If we don't know anything, early out and try computeKnownBits fall-back.\n    if (Tmp == 1)\n      break;\n    assert(Tmp <= VTBits && \"Failed to determine minimum sign bits\");\n    return Tmp;\n  }\n\n  case ISD::BITCAST: {\n    SDValue N0 = Op.getOperand(0);\n    EVT SrcVT = N0.getValueType();\n    unsigned SrcBits = SrcVT.getScalarSizeInBits();\n\n    // Ignore bitcasts from unsupported types..\n    if (!(SrcVT.isInteger() || SrcVT.isFloatingPoint()))\n      break;\n\n    // Fast handling of 'identity' bitcasts.\n    if (VTBits == SrcBits)\n      return ComputeNumSignBits(N0, DemandedElts, Depth + 1);\n\n    bool IsLE = getDataLayout().isLittleEndian();\n\n    // Bitcast 'large element' scalar/vector to 'small element' vector.\n    if ((SrcBits % VTBits) == 0) {\n      assert(VT.isVector() && \"Expected bitcast to vector\");\n\n      unsigned Scale = SrcBits / VTBits;\n      APInt SrcDemandedElts(NumElts / Scale, 0);\n      for (unsigned i = 0; i != NumElts; ++i)\n        if (DemandedElts[i])\n          SrcDemandedElts.setBit(i / Scale);\n\n      // Fast case - sign splat can be simply split across the small elements.\n      Tmp = ComputeNumSignBits(N0, SrcDemandedElts, Depth + 1);\n      if (Tmp == SrcBits)\n        return VTBits;\n\n      // Slow case - determine how far the sign extends into each sub-element.\n      Tmp2 = VTBits;\n      for (unsigned i = 0; i != NumElts; ++i)\n        if (DemandedElts[i]) {\n          unsigned SubOffset = i % Scale;\n          SubOffset = (IsLE ? ((Scale - 1) - SubOffset) : SubOffset);\n          SubOffset = SubOffset * VTBits;\n          if (Tmp <= SubOffset)\n            return 1;\n          Tmp2 = std::min(Tmp2, Tmp - SubOffset);\n        }\n      return Tmp2;\n    }\n    break;\n  }\n\n  case ISD::SIGN_EXTEND:\n    Tmp = VTBits - Op.getOperand(0).getScalarValueSizeInBits();\n    return ComputeNumSignBits(Op.getOperand(0), DemandedElts, Depth+1) + Tmp;\n  case ISD::SIGN_EXTEND_INREG:\n    // Max of the input and what this extends.\n    Tmp = cast<VTSDNode>(Op.getOperand(1))->getVT().getScalarSizeInBits();\n    Tmp = VTBits-Tmp+1;\n    Tmp2 = ComputeNumSignBits(Op.getOperand(0), DemandedElts, Depth+1);\n    return std::max(Tmp, Tmp2);\n  case ISD::SIGN_EXTEND_VECTOR_INREG: {\n    SDValue Src = Op.getOperand(0);\n    EVT SrcVT = Src.getValueType();\n    APInt DemandedSrcElts = DemandedElts.zextOrSelf(SrcVT.getVectorNumElements());\n    Tmp = VTBits - SrcVT.getScalarSizeInBits();\n    return ComputeNumSignBits(Src, DemandedSrcElts, Depth+1) + Tmp;\n  }\n  case ISD::SRA:\n    Tmp = ComputeNumSignBits(Op.getOperand(0), DemandedElts, Depth + 1);\n    // SRA X, C -> adds C sign bits.\n    if (const APInt *ShAmt =\n            getValidMinimumShiftAmountConstant(Op, DemandedElts))\n      Tmp = std::min<uint64_t>(Tmp + ShAmt->getZExtValue(), VTBits);\n    return Tmp;\n  case ISD::SHL:\n    if (const APInt *ShAmt =\n            getValidMaximumShiftAmountConstant(Op, DemandedElts)) {\n      // shl destroys sign bits, ensure it doesn't shift out all sign bits.\n      Tmp = ComputeNumSignBits(Op.getOperand(0), DemandedElts, Depth + 1);\n      if (ShAmt->ult(Tmp))\n        return Tmp - ShAmt->getZExtValue();\n    }\n    break;\n  case ISD::AND:\n  case ISD::OR:\n  case ISD::XOR:    // NOT is handled here.\n    // Logical binary ops preserve the number of sign bits at the worst.\n    Tmp = ComputeNumSignBits(Op.getOperand(0), DemandedElts, Depth+1);\n    if (Tmp != 1) {\n      Tmp2 = ComputeNumSignBits(Op.getOperand(1), DemandedElts, Depth+1);\n      FirstAnswer = std::min(Tmp, Tmp2);\n      // We computed what we know about the sign bits as our first\n      // answer. Now proceed to the generic code that uses\n      // computeKnownBits, and pick whichever answer is better.\n    }\n    break;\n\n  case ISD::SELECT:\n  case ISD::VSELECT:\n    Tmp = ComputeNumSignBits(Op.getOperand(1), DemandedElts, Depth+1);\n    if (Tmp == 1) return 1;  // Early out.\n    Tmp2 = ComputeNumSignBits(Op.getOperand(2), DemandedElts, Depth+1);\n    return std::min(Tmp, Tmp2);\n  case ISD::SELECT_CC:\n    Tmp = ComputeNumSignBits(Op.getOperand(2), DemandedElts, Depth+1);\n    if (Tmp == 1) return 1;  // Early out.\n    Tmp2 = ComputeNumSignBits(Op.getOperand(3), DemandedElts, Depth+1);\n    return std::min(Tmp, Tmp2);\n\n  case ISD::SMIN:\n  case ISD::SMAX: {\n    // If we have a clamp pattern, we know that the number of sign bits will be\n    // the minimum of the clamp min/max range.\n    bool IsMax = (Opcode == ISD::SMAX);\n    ConstantSDNode *CstLow = nullptr, *CstHigh = nullptr;\n    if ((CstLow = isConstOrConstSplat(Op.getOperand(1), DemandedElts)))\n      if (Op.getOperand(0).getOpcode() == (IsMax ? ISD::SMIN : ISD::SMAX))\n        CstHigh =\n            isConstOrConstSplat(Op.getOperand(0).getOperand(1), DemandedElts);\n    if (CstLow && CstHigh) {\n      if (!IsMax)\n        std::swap(CstLow, CstHigh);\n      if (CstLow->getAPIntValue().sle(CstHigh->getAPIntValue())) {\n        Tmp = CstLow->getAPIntValue().getNumSignBits();\n        Tmp2 = CstHigh->getAPIntValue().getNumSignBits();\n        return std::min(Tmp, Tmp2);\n      }\n    }\n\n    // Fallback - just get the minimum number of sign bits of the operands.\n    Tmp = ComputeNumSignBits(Op.getOperand(0), DemandedElts, Depth + 1);\n    if (Tmp == 1)\n      return 1;  // Early out.\n    Tmp2 = ComputeNumSignBits(Op.getOperand(1), DemandedElts, Depth + 1);\n    return std::min(Tmp, Tmp2);\n  }\n  case ISD::UMIN:\n  case ISD::UMAX:\n    Tmp = ComputeNumSignBits(Op.getOperand(0), DemandedElts, Depth + 1);\n    if (Tmp == 1)\n      return 1;  // Early out.\n    Tmp2 = ComputeNumSignBits(Op.getOperand(1), DemandedElts, Depth + 1);\n    return std::min(Tmp, Tmp2);\n  case ISD::SADDO:\n  case ISD::UADDO:\n  case ISD::SSUBO:\n  case ISD::USUBO:\n  case ISD::SMULO:\n  case ISD::UMULO:\n    if (Op.getResNo() != 1)\n      break;\n    // The boolean result conforms to getBooleanContents.  Fall through.\n    // If setcc returns 0/-1, all bits are sign bits.\n    // We know that we have an integer-based boolean since these operations\n    // are only available for integer.\n    if (TLI->getBooleanContents(VT.isVector(), false) ==\n        TargetLowering::ZeroOrNegativeOneBooleanContent)\n      return VTBits;\n    break;\n  case ISD::SETCC:\n  case ISD::STRICT_FSETCC:\n  case ISD::STRICT_FSETCCS: {\n    unsigned OpNo = Op->isStrictFPOpcode() ? 1 : 0;\n    // If setcc returns 0/-1, all bits are sign bits.\n    if (TLI->getBooleanContents(Op.getOperand(OpNo).getValueType()) ==\n        TargetLowering::ZeroOrNegativeOneBooleanContent)\n      return VTBits;\n    break;\n  }\n  case ISD::ROTL:\n  case ISD::ROTR:\n    Tmp = ComputeNumSignBits(Op.getOperand(0), DemandedElts, Depth + 1);\n\n    // If we're rotating an 0/-1 value, then it stays an 0/-1 value.\n    if (Tmp == VTBits)\n      return VTBits;\n\n    if (ConstantSDNode *C =\n            isConstOrConstSplat(Op.getOperand(1), DemandedElts)) {\n      unsigned RotAmt = C->getAPIntValue().urem(VTBits);\n\n      // Handle rotate right by N like a rotate left by 32-N.\n      if (Opcode == ISD::ROTR)\n        RotAmt = (VTBits - RotAmt) % VTBits;\n\n      // If we aren't rotating out all of the known-in sign bits, return the\n      // number that are left.  This handles rotl(sext(x), 1) for example.\n      if (Tmp > (RotAmt + 1)) return (Tmp - RotAmt);\n    }\n    break;\n  case ISD::ADD:\n  case ISD::ADDC:\n    // Add can have at most one carry bit.  Thus we know that the output\n    // is, at worst, one more bit than the inputs.\n    Tmp = ComputeNumSignBits(Op.getOperand(0), DemandedElts, Depth + 1);\n    if (Tmp == 1) return 1; // Early out.\n\n    // Special case decrementing a value (ADD X, -1):\n    if (ConstantSDNode *CRHS =\n            isConstOrConstSplat(Op.getOperand(1), DemandedElts))\n      if (CRHS->isAllOnesValue()) {\n        KnownBits Known =\n            computeKnownBits(Op.getOperand(0), DemandedElts, Depth + 1);\n\n        // If the input is known to be 0 or 1, the output is 0/-1, which is all\n        // sign bits set.\n        if ((Known.Zero | 1).isAllOnesValue())\n          return VTBits;\n\n        // If we are subtracting one from a positive number, there is no carry\n        // out of the result.\n        if (Known.isNonNegative())\n          return Tmp;\n      }\n\n    Tmp2 = ComputeNumSignBits(Op.getOperand(1), DemandedElts, Depth + 1);\n    if (Tmp2 == 1) return 1; // Early out.\n    return std::min(Tmp, Tmp2) - 1;\n  case ISD::SUB:\n    Tmp2 = ComputeNumSignBits(Op.getOperand(1), DemandedElts, Depth + 1);\n    if (Tmp2 == 1) return 1; // Early out.\n\n    // Handle NEG.\n    if (ConstantSDNode *CLHS =\n            isConstOrConstSplat(Op.getOperand(0), DemandedElts))\n      if (CLHS->isNullValue()) {\n        KnownBits Known =\n            computeKnownBits(Op.getOperand(1), DemandedElts, Depth + 1);\n        // If the input is known to be 0 or 1, the output is 0/-1, which is all\n        // sign bits set.\n        if ((Known.Zero | 1).isAllOnesValue())\n          return VTBits;\n\n        // If the input is known to be positive (the sign bit is known clear),\n        // the output of the NEG has the same number of sign bits as the input.\n        if (Known.isNonNegative())\n          return Tmp2;\n\n        // Otherwise, we treat this like a SUB.\n      }\n\n    // Sub can have at most one carry bit.  Thus we know that the output\n    // is, at worst, one more bit than the inputs.\n    Tmp = ComputeNumSignBits(Op.getOperand(0), DemandedElts, Depth + 1);\n    if (Tmp == 1) return 1; // Early out.\n    return std::min(Tmp, Tmp2) - 1;\n  case ISD::MUL: {\n    // The output of the Mul can be at most twice the valid bits in the inputs.\n    unsigned SignBitsOp0 = ComputeNumSignBits(Op.getOperand(0), Depth + 1);\n    if (SignBitsOp0 == 1)\n      break;\n    unsigned SignBitsOp1 = ComputeNumSignBits(Op.getOperand(1), Depth + 1);\n    if (SignBitsOp1 == 1)\n      break;\n    unsigned OutValidBits =\n        (VTBits - SignBitsOp0 + 1) + (VTBits - SignBitsOp1 + 1);\n    return OutValidBits > VTBits ? 1 : VTBits - OutValidBits + 1;\n  }\n  case ISD::SREM:\n    // The sign bit is the LHS's sign bit, except when the result of the\n    // remainder is zero. The magnitude of the result should be less than or\n    // equal to the magnitude of the LHS. Therefore, the result should have\n    // at least as many sign bits as the left hand side.\n    return ComputeNumSignBits(Op.getOperand(0), DemandedElts, Depth + 1);\n  case ISD::TRUNCATE: {\n    // Check if the sign bits of source go down as far as the truncated value.\n    unsigned NumSrcBits = Op.getOperand(0).getScalarValueSizeInBits();\n    unsigned NumSrcSignBits = ComputeNumSignBits(Op.getOperand(0), Depth + 1);\n    if (NumSrcSignBits > (NumSrcBits - VTBits))\n      return NumSrcSignBits - (NumSrcBits - VTBits);\n    break;\n  }\n  case ISD::EXTRACT_ELEMENT: {\n    const int KnownSign = ComputeNumSignBits(Op.getOperand(0), Depth+1);\n    const int BitWidth = Op.getValueSizeInBits();\n    const int Items = Op.getOperand(0).getValueSizeInBits() / BitWidth;\n\n    // Get reverse index (starting from 1), Op1 value indexes elements from\n    // little end. Sign starts at big end.\n    const int rIndex = Items - 1 - Op.getConstantOperandVal(1);\n\n    // If the sign portion ends in our element the subtraction gives correct\n    // result. Otherwise it gives either negative or > bitwidth result\n    return std::max(std::min(KnownSign - rIndex * BitWidth, BitWidth), 0);\n  }\n  case ISD::INSERT_VECTOR_ELT: {\n    // If we know the element index, split the demand between the\n    // source vector and the inserted element, otherwise assume we need\n    // the original demanded vector elements and the value.\n    SDValue InVec = Op.getOperand(0);\n    SDValue InVal = Op.getOperand(1);\n    SDValue EltNo = Op.getOperand(2);\n    bool DemandedVal = true;\n    APInt DemandedVecElts = DemandedElts;\n    auto *CEltNo = dyn_cast<ConstantSDNode>(EltNo);\n    if (CEltNo && CEltNo->getAPIntValue().ult(NumElts)) {\n      unsigned EltIdx = CEltNo->getZExtValue();\n      DemandedVal = !!DemandedElts[EltIdx];\n      DemandedVecElts.clearBit(EltIdx);\n    }\n    Tmp = std::numeric_limits<unsigned>::max();\n    if (DemandedVal) {\n      // TODO - handle implicit truncation of inserted elements.\n      if (InVal.getScalarValueSizeInBits() != VTBits)\n        break;\n      Tmp2 = ComputeNumSignBits(InVal, Depth + 1);\n      Tmp = std::min(Tmp, Tmp2);\n    }\n    if (!!DemandedVecElts) {\n      Tmp2 = ComputeNumSignBits(InVec, DemandedVecElts, Depth + 1);\n      Tmp = std::min(Tmp, Tmp2);\n    }\n    assert(Tmp <= VTBits && \"Failed to determine minimum sign bits\");\n    return Tmp;\n  }\n  case ISD::EXTRACT_VECTOR_ELT: {\n    SDValue InVec = Op.getOperand(0);\n    SDValue EltNo = Op.getOperand(1);\n    EVT VecVT = InVec.getValueType();\n    // ComputeNumSignBits not yet implemented for scalable vectors.\n    if (VecVT.isScalableVector())\n      break;\n    const unsigned BitWidth = Op.getValueSizeInBits();\n    const unsigned EltBitWidth = Op.getOperand(0).getScalarValueSizeInBits();\n    const unsigned NumSrcElts = VecVT.getVectorNumElements();\n\n    // If BitWidth > EltBitWidth the value is anyext:ed, and we do not know\n    // anything about sign bits. But if the sizes match we can derive knowledge\n    // about sign bits from the vector operand.\n    if (BitWidth != EltBitWidth)\n      break;\n\n    // If we know the element index, just demand that vector element, else for\n    // an unknown element index, ignore DemandedElts and demand them all.\n    APInt DemandedSrcElts = APInt::getAllOnesValue(NumSrcElts);\n    auto *ConstEltNo = dyn_cast<ConstantSDNode>(EltNo);\n    if (ConstEltNo && ConstEltNo->getAPIntValue().ult(NumSrcElts))\n      DemandedSrcElts =\n          APInt::getOneBitSet(NumSrcElts, ConstEltNo->getZExtValue());\n\n    return ComputeNumSignBits(InVec, DemandedSrcElts, Depth + 1);\n  }\n  case ISD::EXTRACT_SUBVECTOR: {\n    // Offset the demanded elts by the subvector index.\n    SDValue Src = Op.getOperand(0);\n    // Bail until we can represent demanded elements for scalable vectors.\n    if (Src.getValueType().isScalableVector())\n      break;\n    uint64_t Idx = Op.getConstantOperandVal(1);\n    unsigned NumSrcElts = Src.getValueType().getVectorNumElements();\n    APInt DemandedSrcElts = DemandedElts.zextOrSelf(NumSrcElts).shl(Idx);\n    return ComputeNumSignBits(Src, DemandedSrcElts, Depth + 1);\n  }\n  case ISD::CONCAT_VECTORS: {\n    // Determine the minimum number of sign bits across all demanded\n    // elts of the input vectors. Early out if the result is already 1.\n    Tmp = std::numeric_limits<unsigned>::max();\n    EVT SubVectorVT = Op.getOperand(0).getValueType();\n    unsigned NumSubVectorElts = SubVectorVT.getVectorNumElements();\n    unsigned NumSubVectors = Op.getNumOperands();\n    for (unsigned i = 0; (i < NumSubVectors) && (Tmp > 1); ++i) {\n      APInt DemandedSub = DemandedElts.lshr(i * NumSubVectorElts);\n      DemandedSub = DemandedSub.trunc(NumSubVectorElts);\n      if (!DemandedSub)\n        continue;\n      Tmp2 = ComputeNumSignBits(Op.getOperand(i), DemandedSub, Depth + 1);\n      Tmp = std::min(Tmp, Tmp2);\n    }\n    assert(Tmp <= VTBits && \"Failed to determine minimum sign bits\");\n    return Tmp;\n  }\n  case ISD::INSERT_SUBVECTOR: {\n    // Demand any elements from the subvector and the remainder from the src its\n    // inserted into.\n    SDValue Src = Op.getOperand(0);\n    SDValue Sub = Op.getOperand(1);\n    uint64_t Idx = Op.getConstantOperandVal(2);\n    unsigned NumSubElts = Sub.getValueType().getVectorNumElements();\n    APInt DemandedSubElts = DemandedElts.extractBits(NumSubElts, Idx);\n    APInt DemandedSrcElts = DemandedElts;\n    DemandedSrcElts.insertBits(APInt::getNullValue(NumSubElts), Idx);\n\n    Tmp = std::numeric_limits<unsigned>::max();\n    if (!!DemandedSubElts) {\n      Tmp = ComputeNumSignBits(Sub, DemandedSubElts, Depth + 1);\n      if (Tmp == 1)\n        return 1; // early-out\n    }\n    if (!!DemandedSrcElts) {\n      Tmp2 = ComputeNumSignBits(Src, DemandedSrcElts, Depth + 1);\n      Tmp = std::min(Tmp, Tmp2);\n    }\n    assert(Tmp <= VTBits && \"Failed to determine minimum sign bits\");\n    return Tmp;\n  }\n  }\n\n  // If we are looking at the loaded value of the SDNode.\n  if (Op.getResNo() == 0) {\n    // Handle LOADX separately here. EXTLOAD case will fallthrough.\n    if (LoadSDNode *LD = dyn_cast<LoadSDNode>(Op)) {\n      unsigned ExtType = LD->getExtensionType();\n      switch (ExtType) {\n      default: break;\n      case ISD::SEXTLOAD: // e.g. i16->i32 = '17' bits known.\n        Tmp = LD->getMemoryVT().getScalarSizeInBits();\n        return VTBits - Tmp + 1;\n      case ISD::ZEXTLOAD: // e.g. i16->i32 = '16' bits known.\n        Tmp = LD->getMemoryVT().getScalarSizeInBits();\n        return VTBits - Tmp;\n      case ISD::NON_EXTLOAD:\n        if (const Constant *Cst = TLI->getTargetConstantFromLoad(LD)) {\n          // We only need to handle vectors - computeKnownBits should handle\n          // scalar cases.\n          Type *CstTy = Cst->getType();\n          if (CstTy->isVectorTy() &&\n              (NumElts * VTBits) == CstTy->getPrimitiveSizeInBits()) {\n            Tmp = VTBits;\n            for (unsigned i = 0; i != NumElts; ++i) {\n              if (!DemandedElts[i])\n                continue;\n              if (Constant *Elt = Cst->getAggregateElement(i)) {\n                if (auto *CInt = dyn_cast<ConstantInt>(Elt)) {\n                  const APInt &Value = CInt->getValue();\n                  Tmp = std::min(Tmp, Value.getNumSignBits());\n                  continue;\n                }\n                if (auto *CFP = dyn_cast<ConstantFP>(Elt)) {\n                  APInt Value = CFP->getValueAPF().bitcastToAPInt();\n                  Tmp = std::min(Tmp, Value.getNumSignBits());\n                  continue;\n                }\n              }\n              // Unknown type. Conservatively assume no bits match sign bit.\n              return 1;\n            }\n            return Tmp;\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  // Allow the target to implement this method for its nodes.\n  if (Opcode >= ISD::BUILTIN_OP_END ||\n      Opcode == ISD::INTRINSIC_WO_CHAIN ||\n      Opcode == ISD::INTRINSIC_W_CHAIN ||\n      Opcode == ISD::INTRINSIC_VOID) {\n    unsigned NumBits =\n        TLI->ComputeNumSignBitsForTargetNode(Op, DemandedElts, *this, Depth);\n    if (NumBits > 1)\n      FirstAnswer = std::max(FirstAnswer, NumBits);\n  }\n\n  // Finally, if we can prove that the top bits of the result are 0's or 1's,\n  // use this information.\n  KnownBits Known = computeKnownBits(Op, DemandedElts, Depth);\n\n  APInt Mask;\n  if (Known.isNonNegative()) {        // sign bit is 0\n    Mask = Known.Zero;\n  } else if (Known.isNegative()) {  // sign bit is 1;\n    Mask = Known.One;\n  } else {\n    // Nothing known.\n    return FirstAnswer;\n  }\n\n  // Okay, we know that the sign bit in Mask is set.  Use CLO to determine\n  // the number of identical bits in the top of the input value.\n  Mask <<= Mask.getBitWidth()-VTBits;\n  return std::max(FirstAnswer, Mask.countLeadingOnes());\n}\n\nbool SelectionDAG::isBaseWithConstantOffset(SDValue Op) const {\n  if ((Op.getOpcode() != ISD::ADD && Op.getOpcode() != ISD::OR) ||\n      !isa<ConstantSDNode>(Op.getOperand(1)))\n    return false;\n\n  if (Op.getOpcode() == ISD::OR &&\n      !MaskedValueIsZero(Op.getOperand(0), Op.getConstantOperandAPInt(1)))\n    return false;\n\n  return true;\n}\n\nbool SelectionDAG::isKnownNeverNaN(SDValue Op, bool SNaN, unsigned Depth) const {\n  // If we're told that NaNs won't happen, assume they won't.\n  if (getTarget().Options.NoNaNsFPMath || Op->getFlags().hasNoNaNs())\n    return true;\n\n  if (Depth >= MaxRecursionDepth)\n    return false; // Limit search depth.\n\n  // TODO: Handle vectors.\n  // If the value is a constant, we can obviously see if it is a NaN or not.\n  if (const ConstantFPSDNode *C = dyn_cast<ConstantFPSDNode>(Op)) {\n    return !C->getValueAPF().isNaN() ||\n           (SNaN && !C->getValueAPF().isSignaling());\n  }\n\n  unsigned Opcode = Op.getOpcode();\n  switch (Opcode) {\n  case ISD::FADD:\n  case ISD::FSUB:\n  case ISD::FMUL:\n  case ISD::FDIV:\n  case ISD::FREM:\n  case ISD::FSIN:\n  case ISD::FCOS: {\n    if (SNaN)\n      return true;\n    // TODO: Need isKnownNeverInfinity\n    return false;\n  }\n  case ISD::FCANONICALIZE:\n  case ISD::FEXP:\n  case ISD::FEXP2:\n  case ISD::FTRUNC:\n  case ISD::FFLOOR:\n  case ISD::FCEIL:\n  case ISD::FROUND:\n  case ISD::FROUNDEVEN:\n  case ISD::FRINT:\n  case ISD::FNEARBYINT: {\n    if (SNaN)\n      return true;\n    return isKnownNeverNaN(Op.getOperand(0), SNaN, Depth + 1);\n  }\n  case ISD::FABS:\n  case ISD::FNEG:\n  case ISD::FCOPYSIGN: {\n    return isKnownNeverNaN(Op.getOperand(0), SNaN, Depth + 1);\n  }\n  case ISD::SELECT:\n    return isKnownNeverNaN(Op.getOperand(1), SNaN, Depth + 1) &&\n           isKnownNeverNaN(Op.getOperand(2), SNaN, Depth + 1);\n  case ISD::FP_EXTEND:\n  case ISD::FP_ROUND: {\n    if (SNaN)\n      return true;\n    return isKnownNeverNaN(Op.getOperand(0), SNaN, Depth + 1);\n  }\n  case ISD::SINT_TO_FP:\n  case ISD::UINT_TO_FP:\n    return true;\n  case ISD::FMA:\n  case ISD::FMAD: {\n    if (SNaN)\n      return true;\n    return isKnownNeverNaN(Op.getOperand(0), SNaN, Depth + 1) &&\n           isKnownNeverNaN(Op.getOperand(1), SNaN, Depth + 1) &&\n           isKnownNeverNaN(Op.getOperand(2), SNaN, Depth + 1);\n  }\n  case ISD::FSQRT: // Need is known positive\n  case ISD::FLOG:\n  case ISD::FLOG2:\n  case ISD::FLOG10:\n  case ISD::FPOWI:\n  case ISD::FPOW: {\n    if (SNaN)\n      return true;\n    // TODO: Refine on operand\n    return false;\n  }\n  case ISD::FMINNUM:\n  case ISD::FMAXNUM: {\n    // Only one needs to be known not-nan, since it will be returned if the\n    // other ends up being one.\n    return isKnownNeverNaN(Op.getOperand(0), SNaN, Depth + 1) ||\n           isKnownNeverNaN(Op.getOperand(1), SNaN, Depth + 1);\n  }\n  case ISD::FMINNUM_IEEE:\n  case ISD::FMAXNUM_IEEE: {\n    if (SNaN)\n      return true;\n    // This can return a NaN if either operand is an sNaN, or if both operands\n    // are NaN.\n    return (isKnownNeverNaN(Op.getOperand(0), false, Depth + 1) &&\n            isKnownNeverSNaN(Op.getOperand(1), Depth + 1)) ||\n           (isKnownNeverNaN(Op.getOperand(1), false, Depth + 1) &&\n            isKnownNeverSNaN(Op.getOperand(0), Depth + 1));\n  }\n  case ISD::FMINIMUM:\n  case ISD::FMAXIMUM: {\n    // TODO: Does this quiet or return the origina NaN as-is?\n    return isKnownNeverNaN(Op.getOperand(0), SNaN, Depth + 1) &&\n           isKnownNeverNaN(Op.getOperand(1), SNaN, Depth + 1);\n  }\n  case ISD::EXTRACT_VECTOR_ELT: {\n    return isKnownNeverNaN(Op.getOperand(0), SNaN, Depth + 1);\n  }\n  default:\n    if (Opcode >= ISD::BUILTIN_OP_END ||\n        Opcode == ISD::INTRINSIC_WO_CHAIN ||\n        Opcode == ISD::INTRINSIC_W_CHAIN ||\n        Opcode == ISD::INTRINSIC_VOID) {\n      return TLI->isKnownNeverNaNForTargetNode(Op, *this, SNaN, Depth);\n    }\n\n    return false;\n  }\n}\n\nbool SelectionDAG::isKnownNeverZeroFloat(SDValue Op) const {\n  assert(Op.getValueType().isFloatingPoint() &&\n         \"Floating point type expected\");\n\n  // If the value is a constant, we can obviously see if it is a zero or not.\n  // TODO: Add BuildVector support.\n  if (const ConstantFPSDNode *C = dyn_cast<ConstantFPSDNode>(Op))\n    return !C->isZero();\n  return false;\n}\n\nbool SelectionDAG::isKnownNeverZero(SDValue Op) const {\n  assert(!Op.getValueType().isFloatingPoint() &&\n         \"Floating point types unsupported - use isKnownNeverZeroFloat\");\n\n  // If the value is a constant, we can obviously see if it is a zero or not.\n  if (ISD::matchUnaryPredicate(\n          Op, [](ConstantSDNode *C) { return !C->isNullValue(); }))\n    return true;\n\n  // TODO: Recognize more cases here.\n  switch (Op.getOpcode()) {\n  default: break;\n  case ISD::OR:\n    if (isKnownNeverZero(Op.getOperand(1)) ||\n        isKnownNeverZero(Op.getOperand(0)))\n      return true;\n    break;\n  }\n\n  return false;\n}\n\nbool SelectionDAG::isEqualTo(SDValue A, SDValue B) const {\n  // Check the obvious case.\n  if (A == B) return true;\n\n  // For for negative and positive zero.\n  if (const ConstantFPSDNode *CA = dyn_cast<ConstantFPSDNode>(A))\n    if (const ConstantFPSDNode *CB = dyn_cast<ConstantFPSDNode>(B))\n      if (CA->isZero() && CB->isZero()) return true;\n\n  // Otherwise they may not be equal.\n  return false;\n}\n\n// FIXME: unify with llvm::haveNoCommonBitsSet.\n// FIXME: could also handle masked merge pattern (X & ~M) op (Y & M)\nbool SelectionDAG::haveNoCommonBitsSet(SDValue A, SDValue B) const {\n  assert(A.getValueType() == B.getValueType() &&\n         \"Values must have the same type\");\n  return (computeKnownBits(A).Zero | computeKnownBits(B).Zero).isAllOnesValue();\n}\n\nstatic SDValue FoldBUILD_VECTOR(const SDLoc &DL, EVT VT,\n                                ArrayRef<SDValue> Ops,\n                                SelectionDAG &DAG) {\n  int NumOps = Ops.size();\n  assert(NumOps != 0 && \"Can't build an empty vector!\");\n  assert(!VT.isScalableVector() &&\n         \"BUILD_VECTOR cannot be used with scalable types\");\n  assert(VT.getVectorNumElements() == (unsigned)NumOps &&\n         \"Incorrect element count in BUILD_VECTOR!\");\n\n  // BUILD_VECTOR of UNDEFs is UNDEF.\n  if (llvm::all_of(Ops, [](SDValue Op) { return Op.isUndef(); }))\n    return DAG.getUNDEF(VT);\n\n  // BUILD_VECTOR of seq extract/insert from the same vector + type is Identity.\n  SDValue IdentitySrc;\n  bool IsIdentity = true;\n  for (int i = 0; i != NumOps; ++i) {\n    if (Ops[i].getOpcode() != ISD::EXTRACT_VECTOR_ELT ||\n        Ops[i].getOperand(0).getValueType() != VT ||\n        (IdentitySrc && Ops[i].getOperand(0) != IdentitySrc) ||\n        !isa<ConstantSDNode>(Ops[i].getOperand(1)) ||\n        cast<ConstantSDNode>(Ops[i].getOperand(1))->getAPIntValue() != i) {\n      IsIdentity = false;\n      break;\n    }\n    IdentitySrc = Ops[i].getOperand(0);\n  }\n  if (IsIdentity)\n    return IdentitySrc;\n\n  return SDValue();\n}\n\n/// Try to simplify vector concatenation to an input value, undef, or build\n/// vector.\nstatic SDValue foldCONCAT_VECTORS(const SDLoc &DL, EVT VT,\n                                  ArrayRef<SDValue> Ops,\n                                  SelectionDAG &DAG) {\n  assert(!Ops.empty() && \"Can't concatenate an empty list of vectors!\");\n  assert(llvm::all_of(Ops,\n                      [Ops](SDValue Op) {\n                        return Ops[0].getValueType() == Op.getValueType();\n                      }) &&\n         \"Concatenation of vectors with inconsistent value types!\");\n  assert((Ops[0].getValueType().getVectorElementCount() * Ops.size()) ==\n             VT.getVectorElementCount() &&\n         \"Incorrect element count in vector concatenation!\");\n\n  if (Ops.size() == 1)\n    return Ops[0];\n\n  // Concat of UNDEFs is UNDEF.\n  if (llvm::all_of(Ops, [](SDValue Op) { return Op.isUndef(); }))\n    return DAG.getUNDEF(VT);\n\n  // Scan the operands and look for extract operations from a single source\n  // that correspond to insertion at the same location via this concatenation:\n  // concat (extract X, 0*subvec_elts), (extract X, 1*subvec_elts), ...\n  SDValue IdentitySrc;\n  bool IsIdentity = true;\n  for (unsigned i = 0, e = Ops.size(); i != e; ++i) {\n    SDValue Op = Ops[i];\n    unsigned IdentityIndex = i * Op.getValueType().getVectorMinNumElements();\n    if (Op.getOpcode() != ISD::EXTRACT_SUBVECTOR ||\n        Op.getOperand(0).getValueType() != VT ||\n        (IdentitySrc && Op.getOperand(0) != IdentitySrc) ||\n        Op.getConstantOperandVal(1) != IdentityIndex) {\n      IsIdentity = false;\n      break;\n    }\n    assert((!IdentitySrc || IdentitySrc == Op.getOperand(0)) &&\n           \"Unexpected identity source vector for concat of extracts\");\n    IdentitySrc = Op.getOperand(0);\n  }\n  if (IsIdentity) {\n    assert(IdentitySrc && \"Failed to set source vector of extracts\");\n    return IdentitySrc;\n  }\n\n  // The code below this point is only designed to work for fixed width\n  // vectors, so we bail out for now.\n  if (VT.isScalableVector())\n    return SDValue();\n\n  // A CONCAT_VECTOR with all UNDEF/BUILD_VECTOR operands can be\n  // simplified to one big BUILD_VECTOR.\n  // FIXME: Add support for SCALAR_TO_VECTOR as well.\n  EVT SVT = VT.getScalarType();\n  SmallVector<SDValue, 16> Elts;\n  for (SDValue Op : Ops) {\n    EVT OpVT = Op.getValueType();\n    if (Op.isUndef())\n      Elts.append(OpVT.getVectorNumElements(), DAG.getUNDEF(SVT));\n    else if (Op.getOpcode() == ISD::BUILD_VECTOR)\n      Elts.append(Op->op_begin(), Op->op_end());\n    else\n      return SDValue();\n  }\n\n  // BUILD_VECTOR requires all inputs to be of the same type, find the\n  // maximum type and extend them all.\n  for (SDValue Op : Elts)\n    SVT = (SVT.bitsLT(Op.getValueType()) ? Op.getValueType() : SVT);\n\n  if (SVT.bitsGT(VT.getScalarType())) {\n    for (SDValue &Op : Elts) {\n      if (Op.isUndef())\n        Op = DAG.getUNDEF(SVT);\n      else\n        Op = DAG.getTargetLoweringInfo().isZExtFree(Op.getValueType(), SVT)\n                 ? DAG.getZExtOrTrunc(Op, DL, SVT)\n                 : DAG.getSExtOrTrunc(Op, DL, SVT);\n    }\n  }\n\n  SDValue V = DAG.getBuildVector(VT, DL, Elts);\n  NewSDValueDbgMsg(V, \"New node fold concat vectors: \", &DAG);\n  return V;\n}\n\n/// Gets or creates the specified node.\nSDValue SelectionDAG::getNode(unsigned Opcode, const SDLoc &DL, EVT VT) {\n  FoldingSetNodeID ID;\n  AddNodeIDNode(ID, Opcode, getVTList(VT), None);\n  void *IP = nullptr;\n  if (SDNode *E = FindNodeOrInsertPos(ID, DL, IP))\n    return SDValue(E, 0);\n\n  auto *N = newSDNode<SDNode>(Opcode, DL.getIROrder(), DL.getDebugLoc(),\n                              getVTList(VT));\n  CSEMap.InsertNode(N, IP);\n\n  InsertNode(N);\n  SDValue V = SDValue(N, 0);\n  NewSDValueDbgMsg(V, \"Creating new node: \", this);\n  return V;\n}\n\nSDValue SelectionDAG::getNode(unsigned Opcode, const SDLoc &DL, EVT VT,\n                              SDValue Operand) {\n  SDNodeFlags Flags;\n  if (Inserter)\n    Flags = Inserter->getFlags();\n  return getNode(Opcode, DL, VT, Operand, Flags);\n}\n\nSDValue SelectionDAG::getNode(unsigned Opcode, const SDLoc &DL, EVT VT,\n                              SDValue Operand, const SDNodeFlags Flags) {\n  assert(Operand.getOpcode() != ISD::DELETED_NODE &&\n         \"Operand is DELETED_NODE!\");\n  // Constant fold unary operations with an integer constant operand. Even\n  // opaque constant will be folded, because the folding of unary operations\n  // doesn't create new constants with different values. Nevertheless, the\n  // opaque flag is preserved during folding to prevent future folding with\n  // other constants.\n  if (ConstantSDNode *C = dyn_cast<ConstantSDNode>(Operand)) {\n    const APInt &Val = C->getAPIntValue();\n    switch (Opcode) {\n    default: break;\n    case ISD::SIGN_EXTEND:\n      return getConstant(Val.sextOrTrunc(VT.getSizeInBits()), DL, VT,\n                         C->isTargetOpcode(), C->isOpaque());\n    case ISD::TRUNCATE:\n      if (C->isOpaque())\n        break;\n      LLVM_FALLTHROUGH;\n    case ISD::ANY_EXTEND:\n    case ISD::ZERO_EXTEND:\n      return getConstant(Val.zextOrTrunc(VT.getSizeInBits()), DL, VT,\n                         C->isTargetOpcode(), C->isOpaque());\n    case ISD::UINT_TO_FP:\n    case ISD::SINT_TO_FP: {\n      APFloat apf(EVTToAPFloatSemantics(VT),\n                  APInt::getNullValue(VT.getSizeInBits()));\n      (void)apf.convertFromAPInt(Val,\n                                 Opcode==ISD::SINT_TO_FP,\n                                 APFloat::rmNearestTiesToEven);\n      return getConstantFP(apf, DL, VT);\n    }\n    case ISD::BITCAST:\n      if (VT == MVT::f16 && C->getValueType(0) == MVT::i16)\n        return getConstantFP(APFloat(APFloat::IEEEhalf(), Val), DL, VT);\n      if (VT == MVT::f32 && C->getValueType(0) == MVT::i32)\n        return getConstantFP(APFloat(APFloat::IEEEsingle(), Val), DL, VT);\n      if (VT == MVT::f64 && C->getValueType(0) == MVT::i64)\n        return getConstantFP(APFloat(APFloat::IEEEdouble(), Val), DL, VT);\n      if (VT == MVT::f128 && C->getValueType(0) == MVT::i128)\n        return getConstantFP(APFloat(APFloat::IEEEquad(), Val), DL, VT);\n      break;\n    case ISD::ABS:\n      return getConstant(Val.abs(), DL, VT, C->isTargetOpcode(),\n                         C->isOpaque());\n    case ISD::BITREVERSE:\n      return getConstant(Val.reverseBits(), DL, VT, C->isTargetOpcode(),\n                         C->isOpaque());\n    case ISD::BSWAP:\n      return getConstant(Val.byteSwap(), DL, VT, C->isTargetOpcode(),\n                         C->isOpaque());\n    case ISD::CTPOP:\n      return getConstant(Val.countPopulation(), DL, VT, C->isTargetOpcode(),\n                         C->isOpaque());\n    case ISD::CTLZ:\n    case ISD::CTLZ_ZERO_UNDEF:\n      return getConstant(Val.countLeadingZeros(), DL, VT, C->isTargetOpcode(),\n                         C->isOpaque());\n    case ISD::CTTZ:\n    case ISD::CTTZ_ZERO_UNDEF:\n      return getConstant(Val.countTrailingZeros(), DL, VT, C->isTargetOpcode(),\n                         C->isOpaque());\n    case ISD::FP16_TO_FP: {\n      bool Ignored;\n      APFloat FPV(APFloat::IEEEhalf(),\n                  (Val.getBitWidth() == 16) ? Val : Val.trunc(16));\n\n      // This can return overflow, underflow, or inexact; we don't care.\n      // FIXME need to be more flexible about rounding mode.\n      (void)FPV.convert(EVTToAPFloatSemantics(VT),\n                        APFloat::rmNearestTiesToEven, &Ignored);\n      return getConstantFP(FPV, DL, VT);\n    }\n    }\n  }\n\n  // Constant fold unary operations with a floating point constant operand.\n  if (ConstantFPSDNode *C = dyn_cast<ConstantFPSDNode>(Operand)) {\n    APFloat V = C->getValueAPF();    // make copy\n    switch (Opcode) {\n    case ISD::FNEG:\n      V.changeSign();\n      return getConstantFP(V, DL, VT);\n    case ISD::FABS:\n      V.clearSign();\n      return getConstantFP(V, DL, VT);\n    case ISD::FCEIL: {\n      APFloat::opStatus fs = V.roundToIntegral(APFloat::rmTowardPositive);\n      if (fs == APFloat::opOK || fs == APFloat::opInexact)\n        return getConstantFP(V, DL, VT);\n      break;\n    }\n    case ISD::FTRUNC: {\n      APFloat::opStatus fs = V.roundToIntegral(APFloat::rmTowardZero);\n      if (fs == APFloat::opOK || fs == APFloat::opInexact)\n        return getConstantFP(V, DL, VT);\n      break;\n    }\n    case ISD::FFLOOR: {\n      APFloat::opStatus fs = V.roundToIntegral(APFloat::rmTowardNegative);\n      if (fs == APFloat::opOK || fs == APFloat::opInexact)\n        return getConstantFP(V, DL, VT);\n      break;\n    }\n    case ISD::FP_EXTEND: {\n      bool ignored;\n      // This can return overflow, underflow, or inexact; we don't care.\n      // FIXME need to be more flexible about rounding mode.\n      (void)V.convert(EVTToAPFloatSemantics(VT),\n                      APFloat::rmNearestTiesToEven, &ignored);\n      return getConstantFP(V, DL, VT);\n    }\n    case ISD::FP_TO_SINT:\n    case ISD::FP_TO_UINT: {\n      bool ignored;\n      APSInt IntVal(VT.getSizeInBits(), Opcode == ISD::FP_TO_UINT);\n      // FIXME need to be more flexible about rounding mode.\n      APFloat::opStatus s =\n          V.convertToInteger(IntVal, APFloat::rmTowardZero, &ignored);\n      if (s == APFloat::opInvalidOp) // inexact is OK, in fact usual\n        break;\n      return getConstant(IntVal, DL, VT);\n    }\n    case ISD::BITCAST:\n      if (VT == MVT::i16 && C->getValueType(0) == MVT::f16)\n        return getConstant((uint16_t)V.bitcastToAPInt().getZExtValue(), DL, VT);\n      else if (VT == MVT::i32 && C->getValueType(0) == MVT::f32)\n        return getConstant((uint32_t)V.bitcastToAPInt().getZExtValue(), DL, VT);\n      else if (VT == MVT::i64 && C->getValueType(0) == MVT::f64)\n        return getConstant(V.bitcastToAPInt().getZExtValue(), DL, VT);\n      break;\n    case ISD::FP_TO_FP16: {\n      bool Ignored;\n      // This can return overflow, underflow, or inexact; we don't care.\n      // FIXME need to be more flexible about rounding mode.\n      (void)V.convert(APFloat::IEEEhalf(),\n                      APFloat::rmNearestTiesToEven, &Ignored);\n      return getConstant(V.bitcastToAPInt().getZExtValue(), DL, VT);\n    }\n    }\n  }\n\n  // Constant fold unary operations with a vector integer or float operand.\n  if (BuildVectorSDNode *BV = dyn_cast<BuildVectorSDNode>(Operand)) {\n    if (BV->isConstant()) {\n      switch (Opcode) {\n      default:\n        // FIXME: Entirely reasonable to perform folding of other unary\n        // operations here as the need arises.\n        break;\n      case ISD::FNEG:\n      case ISD::FABS:\n      case ISD::FCEIL:\n      case ISD::FTRUNC:\n      case ISD::FFLOOR:\n      case ISD::FP_EXTEND:\n      case ISD::FP_TO_SINT:\n      case ISD::FP_TO_UINT:\n      case ISD::TRUNCATE:\n      case ISD::ANY_EXTEND:\n      case ISD::ZERO_EXTEND:\n      case ISD::SIGN_EXTEND:\n      case ISD::UINT_TO_FP:\n      case ISD::SINT_TO_FP:\n      case ISD::ABS:\n      case ISD::BITREVERSE:\n      case ISD::BSWAP:\n      case ISD::CTLZ:\n      case ISD::CTLZ_ZERO_UNDEF:\n      case ISD::CTTZ:\n      case ISD::CTTZ_ZERO_UNDEF:\n      case ISD::CTPOP: {\n        SDValue Ops = { Operand };\n        if (SDValue Fold = FoldConstantVectorArithmetic(Opcode, DL, VT, Ops))\n          return Fold;\n      }\n      }\n    }\n  }\n\n  unsigned OpOpcode = Operand.getNode()->getOpcode();\n  switch (Opcode) {\n  case ISD::FREEZE:\n    assert(VT == Operand.getValueType() && \"Unexpected VT!\");\n    break;\n  case ISD::TokenFactor:\n  case ISD::MERGE_VALUES:\n  case ISD::CONCAT_VECTORS:\n    return Operand;         // Factor, merge or concat of one node?  No need.\n  case ISD::BUILD_VECTOR: {\n    // Attempt to simplify BUILD_VECTOR.\n    SDValue Ops[] = {Operand};\n    if (SDValue V = FoldBUILD_VECTOR(DL, VT, Ops, *this))\n      return V;\n    break;\n  }\n  case ISD::FP_ROUND: llvm_unreachable(\"Invalid method to make FP_ROUND node\");\n  case ISD::FP_EXTEND:\n    assert(VT.isFloatingPoint() &&\n           Operand.getValueType().isFloatingPoint() && \"Invalid FP cast!\");\n    if (Operand.getValueType() == VT) return Operand;  // noop conversion.\n    assert((!VT.isVector() ||\n            VT.getVectorElementCount() ==\n            Operand.getValueType().getVectorElementCount()) &&\n           \"Vector element count mismatch!\");\n    assert(Operand.getValueType().bitsLT(VT) &&\n           \"Invalid fpext node, dst < src!\");\n    if (Operand.isUndef())\n      return getUNDEF(VT);\n    break;\n  case ISD::FP_TO_SINT:\n  case ISD::FP_TO_UINT:\n    if (Operand.isUndef())\n      return getUNDEF(VT);\n    break;\n  case ISD::SINT_TO_FP:\n  case ISD::UINT_TO_FP:\n    // [us]itofp(undef) = 0, because the result value is bounded.\n    if (Operand.isUndef())\n      return getConstantFP(0.0, DL, VT);\n    break;\n  case ISD::SIGN_EXTEND:\n    assert(VT.isInteger() && Operand.getValueType().isInteger() &&\n           \"Invalid SIGN_EXTEND!\");\n    assert(VT.isVector() == Operand.getValueType().isVector() &&\n           \"SIGN_EXTEND result type type should be vector iff the operand \"\n           \"type is vector!\");\n    if (Operand.getValueType() == VT) return Operand;   // noop extension\n    assert((!VT.isVector() ||\n            VT.getVectorElementCount() ==\n                Operand.getValueType().getVectorElementCount()) &&\n           \"Vector element count mismatch!\");\n    assert(Operand.getValueType().bitsLT(VT) &&\n           \"Invalid sext node, dst < src!\");\n    if (OpOpcode == ISD::SIGN_EXTEND || OpOpcode == ISD::ZERO_EXTEND)\n      return getNode(OpOpcode, DL, VT, Operand.getOperand(0));\n    else if (OpOpcode == ISD::UNDEF)\n      // sext(undef) = 0, because the top bits will all be the same.\n      return getConstant(0, DL, VT);\n    break;\n  case ISD::ZERO_EXTEND:\n    assert(VT.isInteger() && Operand.getValueType().isInteger() &&\n           \"Invalid ZERO_EXTEND!\");\n    assert(VT.isVector() == Operand.getValueType().isVector() &&\n           \"ZERO_EXTEND result type type should be vector iff the operand \"\n           \"type is vector!\");\n    if (Operand.getValueType() == VT) return Operand;   // noop extension\n    assert((!VT.isVector() ||\n            VT.getVectorElementCount() ==\n                Operand.getValueType().getVectorElementCount()) &&\n           \"Vector element count mismatch!\");\n    assert(Operand.getValueType().bitsLT(VT) &&\n           \"Invalid zext node, dst < src!\");\n    if (OpOpcode == ISD::ZERO_EXTEND)   // (zext (zext x)) -> (zext x)\n      return getNode(ISD::ZERO_EXTEND, DL, VT, Operand.getOperand(0));\n    else if (OpOpcode == ISD::UNDEF)\n      // zext(undef) = 0, because the top bits will be zero.\n      return getConstant(0, DL, VT);\n    break;\n  case ISD::ANY_EXTEND:\n    assert(VT.isInteger() && Operand.getValueType().isInteger() &&\n           \"Invalid ANY_EXTEND!\");\n    assert(VT.isVector() == Operand.getValueType().isVector() &&\n           \"ANY_EXTEND result type type should be vector iff the operand \"\n           \"type is vector!\");\n    if (Operand.getValueType() == VT) return Operand;   // noop extension\n    assert((!VT.isVector() ||\n            VT.getVectorElementCount() ==\n                Operand.getValueType().getVectorElementCount()) &&\n           \"Vector element count mismatch!\");\n    assert(Operand.getValueType().bitsLT(VT) &&\n           \"Invalid anyext node, dst < src!\");\n\n    if (OpOpcode == ISD::ZERO_EXTEND || OpOpcode == ISD::SIGN_EXTEND ||\n        OpOpcode == ISD::ANY_EXTEND)\n      // (ext (zext x)) -> (zext x)  and  (ext (sext x)) -> (sext x)\n      return getNode(OpOpcode, DL, VT, Operand.getOperand(0));\n    else if (OpOpcode == ISD::UNDEF)\n      return getUNDEF(VT);\n\n    // (ext (trunc x)) -> x\n    if (OpOpcode == ISD::TRUNCATE) {\n      SDValue OpOp = Operand.getOperand(0);\n      if (OpOp.getValueType() == VT) {\n        transferDbgValues(Operand, OpOp);\n        return OpOp;\n      }\n    }\n    break;\n  case ISD::TRUNCATE:\n    assert(VT.isInteger() && Operand.getValueType().isInteger() &&\n           \"Invalid TRUNCATE!\");\n    assert(VT.isVector() == Operand.getValueType().isVector() &&\n           \"TRUNCATE result type type should be vector iff the operand \"\n           \"type is vector!\");\n    if (Operand.getValueType() == VT) return Operand;   // noop truncate\n    assert((!VT.isVector() ||\n            VT.getVectorElementCount() ==\n                Operand.getValueType().getVectorElementCount()) &&\n           \"Vector element count mismatch!\");\n    assert(Operand.getValueType().bitsGT(VT) &&\n           \"Invalid truncate node, src < dst!\");\n    if (OpOpcode == ISD::TRUNCATE)\n      return getNode(ISD::TRUNCATE, DL, VT, Operand.getOperand(0));\n    if (OpOpcode == ISD::ZERO_EXTEND || OpOpcode == ISD::SIGN_EXTEND ||\n        OpOpcode == ISD::ANY_EXTEND) {\n      // If the source is smaller than the dest, we still need an extend.\n      if (Operand.getOperand(0).getValueType().getScalarType()\n            .bitsLT(VT.getScalarType()))\n        return getNode(OpOpcode, DL, VT, Operand.getOperand(0));\n      if (Operand.getOperand(0).getValueType().bitsGT(VT))\n        return getNode(ISD::TRUNCATE, DL, VT, Operand.getOperand(0));\n      return Operand.getOperand(0);\n    }\n    if (OpOpcode == ISD::UNDEF)\n      return getUNDEF(VT);\n    break;\n  case ISD::ANY_EXTEND_VECTOR_INREG:\n  case ISD::ZERO_EXTEND_VECTOR_INREG:\n  case ISD::SIGN_EXTEND_VECTOR_INREG:\n    assert(VT.isVector() && \"This DAG node is restricted to vector types.\");\n    assert(Operand.getValueType().bitsLE(VT) &&\n           \"The input must be the same size or smaller than the result.\");\n    assert(VT.getVectorNumElements() <\n             Operand.getValueType().getVectorNumElements() &&\n           \"The destination vector type must have fewer lanes than the input.\");\n    break;\n  case ISD::ABS:\n    assert(VT.isInteger() && VT == Operand.getValueType() &&\n           \"Invalid ABS!\");\n    if (OpOpcode == ISD::UNDEF)\n      return getUNDEF(VT);\n    break;\n  case ISD::BSWAP:\n    assert(VT.isInteger() && VT == Operand.getValueType() &&\n           \"Invalid BSWAP!\");\n    assert((VT.getScalarSizeInBits() % 16 == 0) &&\n           \"BSWAP types must be a multiple of 16 bits!\");\n    if (OpOpcode == ISD::UNDEF)\n      return getUNDEF(VT);\n    break;\n  case ISD::BITREVERSE:\n    assert(VT.isInteger() && VT == Operand.getValueType() &&\n           \"Invalid BITREVERSE!\");\n    if (OpOpcode == ISD::UNDEF)\n      return getUNDEF(VT);\n    break;\n  case ISD::BITCAST:\n    // Basic sanity checking.\n    assert(VT.getSizeInBits() == Operand.getValueSizeInBits() &&\n           \"Cannot BITCAST between types of different sizes!\");\n    if (VT == Operand.getValueType()) return Operand;  // noop conversion.\n    if (OpOpcode == ISD::BITCAST)  // bitconv(bitconv(x)) -> bitconv(x)\n      return getNode(ISD::BITCAST, DL, VT, Operand.getOperand(0));\n    if (OpOpcode == ISD::UNDEF)\n      return getUNDEF(VT);\n    break;\n  case ISD::SCALAR_TO_VECTOR:\n    assert(VT.isVector() && !Operand.getValueType().isVector() &&\n           (VT.getVectorElementType() == Operand.getValueType() ||\n            (VT.getVectorElementType().isInteger() &&\n             Operand.getValueType().isInteger() &&\n             VT.getVectorElementType().bitsLE(Operand.getValueType()))) &&\n           \"Illegal SCALAR_TO_VECTOR node!\");\n    if (OpOpcode == ISD::UNDEF)\n      return getUNDEF(VT);\n    // scalar_to_vector(extract_vector_elt V, 0) -> V, top bits are undefined.\n    if (OpOpcode == ISD::EXTRACT_VECTOR_ELT &&\n        isa<ConstantSDNode>(Operand.getOperand(1)) &&\n        Operand.getConstantOperandVal(1) == 0 &&\n        Operand.getOperand(0).getValueType() == VT)\n      return Operand.getOperand(0);\n    break;\n  case ISD::FNEG:\n    // Negation of an unknown bag of bits is still completely undefined.\n    if (OpOpcode == ISD::UNDEF)\n      return getUNDEF(VT);\n\n    if (OpOpcode == ISD::FNEG)  // --X -> X\n      return Operand.getOperand(0);\n    break;\n  case ISD::FABS:\n    if (OpOpcode == ISD::FNEG)  // abs(-X) -> abs(X)\n      return getNode(ISD::FABS, DL, VT, Operand.getOperand(0));\n    break;\n  case ISD::VSCALE:\n    assert(VT == Operand.getValueType() && \"Unexpected VT!\");\n    break;\n  case ISD::CTPOP:\n    if (Operand.getValueType().getScalarType() == MVT::i1)\n      return Operand;\n    break;\n  case ISD::CTLZ:\n  case ISD::CTTZ:\n    if (Operand.getValueType().getScalarType() == MVT::i1)\n      return getNOT(DL, Operand, Operand.getValueType());\n    break;\n  case ISD::VECREDUCE_SMIN:\n  case ISD::VECREDUCE_UMAX:\n    if (Operand.getValueType().getScalarType() == MVT::i1)\n      return getNode(ISD::VECREDUCE_OR, DL, VT, Operand);\n    break;\n  case ISD::VECREDUCE_SMAX:\n  case ISD::VECREDUCE_UMIN:\n    if (Operand.getValueType().getScalarType() == MVT::i1)\n      return getNode(ISD::VECREDUCE_AND, DL, VT, Operand);\n    break;\n  }\n\n  SDNode *N;\n  SDVTList VTs = getVTList(VT);\n  SDValue Ops[] = {Operand};\n  if (VT != MVT::Glue) { // Don't CSE flag producing nodes\n    FoldingSetNodeID ID;\n    AddNodeIDNode(ID, Opcode, VTs, Ops);\n    void *IP = nullptr;\n    if (SDNode *E = FindNodeOrInsertPos(ID, DL, IP)) {\n      E->intersectFlagsWith(Flags);\n      return SDValue(E, 0);\n    }\n\n    N = newSDNode<SDNode>(Opcode, DL.getIROrder(), DL.getDebugLoc(), VTs);\n    N->setFlags(Flags);\n    createOperands(N, Ops);\n    CSEMap.InsertNode(N, IP);\n  } else {\n    N = newSDNode<SDNode>(Opcode, DL.getIROrder(), DL.getDebugLoc(), VTs);\n    createOperands(N, Ops);\n  }\n\n  InsertNode(N);\n  SDValue V = SDValue(N, 0);\n  NewSDValueDbgMsg(V, \"Creating new node: \", this);\n  return V;\n}\n\nstatic llvm::Optional<APInt> FoldValue(unsigned Opcode, const APInt &C1,\n                                       const APInt &C2) {\n  switch (Opcode) {\n  case ISD::ADD:  return C1 + C2;\n  case ISD::SUB:  return C1 - C2;\n  case ISD::MUL:  return C1 * C2;\n  case ISD::AND:  return C1 & C2;\n  case ISD::OR:   return C1 | C2;\n  case ISD::XOR:  return C1 ^ C2;\n  case ISD::SHL:  return C1 << C2;\n  case ISD::SRL:  return C1.lshr(C2);\n  case ISD::SRA:  return C1.ashr(C2);\n  case ISD::ROTL: return C1.rotl(C2);\n  case ISD::ROTR: return C1.rotr(C2);\n  case ISD::SMIN: return C1.sle(C2) ? C1 : C2;\n  case ISD::SMAX: return C1.sge(C2) ? C1 : C2;\n  case ISD::UMIN: return C1.ule(C2) ? C1 : C2;\n  case ISD::UMAX: return C1.uge(C2) ? C1 : C2;\n  case ISD::SADDSAT: return C1.sadd_sat(C2);\n  case ISD::UADDSAT: return C1.uadd_sat(C2);\n  case ISD::SSUBSAT: return C1.ssub_sat(C2);\n  case ISD::USUBSAT: return C1.usub_sat(C2);\n  case ISD::UDIV:\n    if (!C2.getBoolValue())\n      break;\n    return C1.udiv(C2);\n  case ISD::UREM:\n    if (!C2.getBoolValue())\n      break;\n    return C1.urem(C2);\n  case ISD::SDIV:\n    if (!C2.getBoolValue())\n      break;\n    return C1.sdiv(C2);\n  case ISD::SREM:\n    if (!C2.getBoolValue())\n      break;\n    return C1.srem(C2);\n  }\n  return llvm::None;\n}\n\nSDValue SelectionDAG::FoldSymbolOffset(unsigned Opcode, EVT VT,\n                                       const GlobalAddressSDNode *GA,\n                                       const SDNode *N2) {\n  if (GA->getOpcode() != ISD::GlobalAddress)\n    return SDValue();\n  if (!TLI->isOffsetFoldingLegal(GA))\n    return SDValue();\n  auto *C2 = dyn_cast<ConstantSDNode>(N2);\n  if (!C2)\n    return SDValue();\n  int64_t Offset = C2->getSExtValue();\n  switch (Opcode) {\n  case ISD::ADD: break;\n  case ISD::SUB: Offset = -uint64_t(Offset); break;\n  default: return SDValue();\n  }\n  return getGlobalAddress(GA->getGlobal(), SDLoc(C2), VT,\n                          GA->getOffset() + uint64_t(Offset));\n}\n\nbool SelectionDAG::isUndef(unsigned Opcode, ArrayRef<SDValue> Ops) {\n  switch (Opcode) {\n  case ISD::SDIV:\n  case ISD::UDIV:\n  case ISD::SREM:\n  case ISD::UREM: {\n    // If a divisor is zero/undef or any element of a divisor vector is\n    // zero/undef, the whole op is undef.\n    assert(Ops.size() == 2 && \"Div/rem should have 2 operands\");\n    SDValue Divisor = Ops[1];\n    if (Divisor.isUndef() || isNullConstant(Divisor))\n      return true;\n\n    return ISD::isBuildVectorOfConstantSDNodes(Divisor.getNode()) &&\n           llvm::any_of(Divisor->op_values(),\n                        [](SDValue V) { return V.isUndef() ||\n                                        isNullConstant(V); });\n    // TODO: Handle signed overflow.\n  }\n  // TODO: Handle oversized shifts.\n  default:\n    return false;\n  }\n}\n\nSDValue SelectionDAG::FoldConstantArithmetic(unsigned Opcode, const SDLoc &DL,\n                                             EVT VT, ArrayRef<SDValue> Ops) {\n  // If the opcode is a target-specific ISD node, there's nothing we can\n  // do here and the operand rules may not line up with the below, so\n  // bail early.\n  if (Opcode >= ISD::BUILTIN_OP_END)\n    return SDValue();\n\n  // For now, the array Ops should only contain two values.\n  // This enforcement will be removed once this function is merged with\n  // FoldConstantVectorArithmetic\n  if (Ops.size() != 2)\n    return SDValue();\n\n  if (isUndef(Opcode, Ops))\n    return getUNDEF(VT);\n\n  SDNode *N1 = Ops[0].getNode();\n  SDNode *N2 = Ops[1].getNode();\n\n  // Handle the case of two scalars.\n  if (auto *C1 = dyn_cast<ConstantSDNode>(N1)) {\n    if (auto *C2 = dyn_cast<ConstantSDNode>(N2)) {\n      if (C1->isOpaque() || C2->isOpaque())\n        return SDValue();\n\n      Optional<APInt> FoldAttempt =\n          FoldValue(Opcode, C1->getAPIntValue(), C2->getAPIntValue());\n      if (!FoldAttempt)\n        return SDValue();\n\n      SDValue Folded = getConstant(FoldAttempt.getValue(), DL, VT);\n      assert((!Folded || !VT.isVector()) &&\n             \"Can't fold vectors ops with scalar operands\");\n      return Folded;\n    }\n  }\n\n  // fold (add Sym, c) -> Sym+c\n  if (GlobalAddressSDNode *GA = dyn_cast<GlobalAddressSDNode>(N1))\n    return FoldSymbolOffset(Opcode, VT, GA, N2);\n  if (TLI->isCommutativeBinOp(Opcode))\n    if (GlobalAddressSDNode *GA = dyn_cast<GlobalAddressSDNode>(N2))\n      return FoldSymbolOffset(Opcode, VT, GA, N1);\n\n  // TODO: All the folds below are performed lane-by-lane and assume a fixed\n  // vector width, however we should be able to do constant folds involving\n  // splat vector nodes too.\n  if (VT.isScalableVector())\n    return SDValue();\n\n  // For fixed width vectors, extract each constant element and fold them\n  // individually. Either input may be an undef value.\n  auto *BV1 = dyn_cast<BuildVectorSDNode>(N1);\n  if (!BV1 && !N1->isUndef())\n    return SDValue();\n  auto *BV2 = dyn_cast<BuildVectorSDNode>(N2);\n  if (!BV2 && !N2->isUndef())\n    return SDValue();\n  // If both operands are undef, that's handled the same way as scalars.\n  if (!BV1 && !BV2)\n    return SDValue();\n\n  assert((!BV1 || !BV2 || BV1->getNumOperands() == BV2->getNumOperands()) &&\n         \"Vector binop with different number of elements in operands?\");\n\n  EVT SVT = VT.getScalarType();\n  EVT LegalSVT = SVT;\n  if (NewNodesMustHaveLegalTypes && LegalSVT.isInteger()) {\n    LegalSVT = TLI->getTypeToTransformTo(*getContext(), LegalSVT);\n    if (LegalSVT.bitsLT(SVT))\n      return SDValue();\n  }\n  SmallVector<SDValue, 4> Outputs;\n  unsigned NumOps = BV1 ? BV1->getNumOperands() : BV2->getNumOperands();\n  for (unsigned I = 0; I != NumOps; ++I) {\n    SDValue V1 = BV1 ? BV1->getOperand(I) : getUNDEF(SVT);\n    SDValue V2 = BV2 ? BV2->getOperand(I) : getUNDEF(SVT);\n    if (SVT.isInteger()) {\n      if (V1->getValueType(0).bitsGT(SVT))\n        V1 = getNode(ISD::TRUNCATE, DL, SVT, V1);\n      if (V2->getValueType(0).bitsGT(SVT))\n        V2 = getNode(ISD::TRUNCATE, DL, SVT, V2);\n    }\n\n    if (V1->getValueType(0) != SVT || V2->getValueType(0) != SVT)\n      return SDValue();\n\n    // Fold one vector element.\n    SDValue ScalarResult = getNode(Opcode, DL, SVT, V1, V2);\n    if (LegalSVT != SVT)\n      ScalarResult = getNode(ISD::SIGN_EXTEND, DL, LegalSVT, ScalarResult);\n\n    // Scalar folding only succeeded if the result is a constant or UNDEF.\n    if (!ScalarResult.isUndef() && ScalarResult.getOpcode() != ISD::Constant &&\n        ScalarResult.getOpcode() != ISD::ConstantFP)\n      return SDValue();\n    Outputs.push_back(ScalarResult);\n  }\n\n  assert(VT.getVectorNumElements() == Outputs.size() &&\n         \"Vector size mismatch!\");\n\n  // We may have a vector type but a scalar result. Create a splat.\n  Outputs.resize(VT.getVectorNumElements(), Outputs.back());\n\n  // Build a big vector out of the scalar elements we generated.\n  return getBuildVector(VT, SDLoc(), Outputs);\n}\n\n// TODO: Merge with FoldConstantArithmetic\nSDValue SelectionDAG::FoldConstantVectorArithmetic(unsigned Opcode,\n                                                   const SDLoc &DL, EVT VT,\n                                                   ArrayRef<SDValue> Ops,\n                                                   const SDNodeFlags Flags) {\n  // If the opcode is a target-specific ISD node, there's nothing we can\n  // do here and the operand rules may not line up with the below, so\n  // bail early.\n  if (Opcode >= ISD::BUILTIN_OP_END)\n    return SDValue();\n\n  if (isUndef(Opcode, Ops))\n    return getUNDEF(VT);\n\n  // We can only fold vectors - maybe merge with FoldConstantArithmetic someday?\n  if (!VT.isVector())\n    return SDValue();\n\n  // TODO: All the folds below are performed lane-by-lane and assume a fixed\n  // vector width, however we should be able to do constant folds involving\n  // splat vector nodes too.\n  if (VT.isScalableVector())\n    return SDValue();\n\n  // From this point onwards all vectors are assumed to be fixed width.\n  unsigned NumElts = VT.getVectorNumElements();\n\n  auto IsScalarOrSameVectorSize = [&](const SDValue &Op) {\n    return !Op.getValueType().isVector() ||\n           Op.getValueType().getVectorNumElements() == NumElts;\n  };\n\n  auto IsConstantBuildVectorOrUndef = [&](const SDValue &Op) {\n    BuildVectorSDNode *BV = dyn_cast<BuildVectorSDNode>(Op);\n    return (Op.isUndef()) || (Op.getOpcode() == ISD::CONDCODE) ||\n           (BV && BV->isConstant());\n  };\n\n  // All operands must be vector types with the same number of elements as\n  // the result type and must be either UNDEF or a build vector of constant\n  // or UNDEF scalars.\n  if (!llvm::all_of(Ops, IsConstantBuildVectorOrUndef) ||\n      !llvm::all_of(Ops, IsScalarOrSameVectorSize))\n    return SDValue();\n\n  // If we are comparing vectors, then the result needs to be a i1 boolean\n  // that is then sign-extended back to the legal result type.\n  EVT SVT = (Opcode == ISD::SETCC ? MVT::i1 : VT.getScalarType());\n\n  // Find legal integer scalar type for constant promotion and\n  // ensure that its scalar size is at least as large as source.\n  EVT LegalSVT = VT.getScalarType();\n  if (NewNodesMustHaveLegalTypes && LegalSVT.isInteger()) {\n    LegalSVT = TLI->getTypeToTransformTo(*getContext(), LegalSVT);\n    if (LegalSVT.bitsLT(VT.getScalarType()))\n      return SDValue();\n  }\n\n  // Constant fold each scalar lane separately.\n  SmallVector<SDValue, 4> ScalarResults;\n  for (unsigned i = 0; i != NumElts; i++) {\n    SmallVector<SDValue, 4> ScalarOps;\n    for (SDValue Op : Ops) {\n      EVT InSVT = Op.getValueType().getScalarType();\n      BuildVectorSDNode *InBV = dyn_cast<BuildVectorSDNode>(Op);\n      if (!InBV) {\n        // We've checked that this is UNDEF or a constant of some kind.\n        if (Op.isUndef())\n          ScalarOps.push_back(getUNDEF(InSVT));\n        else\n          ScalarOps.push_back(Op);\n        continue;\n      }\n\n      SDValue ScalarOp = InBV->getOperand(i);\n      EVT ScalarVT = ScalarOp.getValueType();\n\n      // Build vector (integer) scalar operands may need implicit\n      // truncation - do this before constant folding.\n      if (ScalarVT.isInteger() && ScalarVT.bitsGT(InSVT))\n        ScalarOp = getNode(ISD::TRUNCATE, DL, InSVT, ScalarOp);\n\n      ScalarOps.push_back(ScalarOp);\n    }\n\n    // Constant fold the scalar operands.\n    SDValue ScalarResult = getNode(Opcode, DL, SVT, ScalarOps, Flags);\n\n    // Legalize the (integer) scalar constant if necessary.\n    if (LegalSVT != SVT)\n      ScalarResult = getNode(ISD::SIGN_EXTEND, DL, LegalSVT, ScalarResult);\n\n    // Scalar folding only succeeded if the result is a constant or UNDEF.\n    if (!ScalarResult.isUndef() && ScalarResult.getOpcode() != ISD::Constant &&\n        ScalarResult.getOpcode() != ISD::ConstantFP)\n      return SDValue();\n    ScalarResults.push_back(ScalarResult);\n  }\n\n  SDValue V = getBuildVector(VT, DL, ScalarResults);\n  NewSDValueDbgMsg(V, \"New node fold constant vector: \", this);\n  return V;\n}\n\nSDValue SelectionDAG::foldConstantFPMath(unsigned Opcode, const SDLoc &DL,\n                                         EVT VT, SDValue N1, SDValue N2) {\n  // TODO: We don't do any constant folding for strict FP opcodes here, but we\n  //       should. That will require dealing with a potentially non-default\n  //       rounding mode, checking the \"opStatus\" return value from the APFloat\n  //       math calculations, and possibly other variations.\n  auto *N1CFP = dyn_cast<ConstantFPSDNode>(N1.getNode());\n  auto *N2CFP = dyn_cast<ConstantFPSDNode>(N2.getNode());\n  if (N1CFP && N2CFP) {\n    APFloat C1 = N1CFP->getValueAPF(), C2 = N2CFP->getValueAPF();\n    switch (Opcode) {\n    case ISD::FADD:\n      C1.add(C2, APFloat::rmNearestTiesToEven);\n      return getConstantFP(C1, DL, VT);\n    case ISD::FSUB:\n      C1.subtract(C2, APFloat::rmNearestTiesToEven);\n      return getConstantFP(C1, DL, VT);\n    case ISD::FMUL:\n      C1.multiply(C2, APFloat::rmNearestTiesToEven);\n      return getConstantFP(C1, DL, VT);\n    case ISD::FDIV:\n      C1.divide(C2, APFloat::rmNearestTiesToEven);\n      return getConstantFP(C1, DL, VT);\n    case ISD::FREM:\n      C1.mod(C2);\n      return getConstantFP(C1, DL, VT);\n    case ISD::FCOPYSIGN:\n      C1.copySign(C2);\n      return getConstantFP(C1, DL, VT);\n    default: break;\n    }\n  }\n  if (N1CFP && Opcode == ISD::FP_ROUND) {\n    APFloat C1 = N1CFP->getValueAPF();    // make copy\n    bool Unused;\n    // This can return overflow, underflow, or inexact; we don't care.\n    // FIXME need to be more flexible about rounding mode.\n    (void) C1.convert(EVTToAPFloatSemantics(VT), APFloat::rmNearestTiesToEven,\n                      &Unused);\n    return getConstantFP(C1, DL, VT);\n  }\n\n  switch (Opcode) {\n  case ISD::FSUB:\n    // -0.0 - undef --> undef (consistent with \"fneg undef\")\n    if (N1CFP && N1CFP->getValueAPF().isNegZero() && N2.isUndef())\n      return getUNDEF(VT);\n    LLVM_FALLTHROUGH;\n\n  case ISD::FADD:\n  case ISD::FMUL:\n  case ISD::FDIV:\n  case ISD::FREM:\n    // If both operands are undef, the result is undef. If 1 operand is undef,\n    // the result is NaN. This should match the behavior of the IR optimizer.\n    if (N1.isUndef() && N2.isUndef())\n      return getUNDEF(VT);\n    if (N1.isUndef() || N2.isUndef())\n      return getConstantFP(APFloat::getNaN(EVTToAPFloatSemantics(VT)), DL, VT);\n  }\n  return SDValue();\n}\n\nSDValue SelectionDAG::getAssertAlign(const SDLoc &DL, SDValue Val, Align A) {\n  assert(Val.getValueType().isInteger() && \"Invalid AssertAlign!\");\n\n  // There's no need to assert on a byte-aligned pointer. All pointers are at\n  // least byte aligned.\n  if (A == Align(1))\n    return Val;\n\n  FoldingSetNodeID ID;\n  AddNodeIDNode(ID, ISD::AssertAlign, getVTList(Val.getValueType()), {Val});\n  ID.AddInteger(A.value());\n\n  void *IP = nullptr;\n  if (SDNode *E = FindNodeOrInsertPos(ID, DL, IP))\n    return SDValue(E, 0);\n\n  auto *N = newSDNode<AssertAlignSDNode>(DL.getIROrder(), DL.getDebugLoc(),\n                                         Val.getValueType(), A);\n  createOperands(N, {Val});\n\n  CSEMap.InsertNode(N, IP);\n  InsertNode(N);\n\n  SDValue V(N, 0);\n  NewSDValueDbgMsg(V, \"Creating new node: \", this);\n  return V;\n}\n\nSDValue SelectionDAG::getNode(unsigned Opcode, const SDLoc &DL, EVT VT,\n                              SDValue N1, SDValue N2) {\n  SDNodeFlags Flags;\n  if (Inserter)\n    Flags = Inserter->getFlags();\n  return getNode(Opcode, DL, VT, N1, N2, Flags);\n}\n\nSDValue SelectionDAG::getNode(unsigned Opcode, const SDLoc &DL, EVT VT,\n                              SDValue N1, SDValue N2, const SDNodeFlags Flags) {\n  assert(N1.getOpcode() != ISD::DELETED_NODE &&\n         N2.getOpcode() != ISD::DELETED_NODE &&\n         \"Operand is DELETED_NODE!\");\n  ConstantSDNode *N1C = dyn_cast<ConstantSDNode>(N1);\n  ConstantSDNode *N2C = dyn_cast<ConstantSDNode>(N2);\n  ConstantFPSDNode *N1CFP = dyn_cast<ConstantFPSDNode>(N1);\n  ConstantFPSDNode *N2CFP = dyn_cast<ConstantFPSDNode>(N2);\n\n  // Canonicalize constant to RHS if commutative.\n  if (TLI->isCommutativeBinOp(Opcode)) {\n    if (N1C && !N2C) {\n      std::swap(N1C, N2C);\n      std::swap(N1, N2);\n    } else if (N1CFP && !N2CFP) {\n      std::swap(N1CFP, N2CFP);\n      std::swap(N1, N2);\n    }\n  }\n\n  switch (Opcode) {\n  default: break;\n  case ISD::TokenFactor:\n    assert(VT == MVT::Other && N1.getValueType() == MVT::Other &&\n           N2.getValueType() == MVT::Other && \"Invalid token factor!\");\n    // Fold trivial token factors.\n    if (N1.getOpcode() == ISD::EntryToken) return N2;\n    if (N2.getOpcode() == ISD::EntryToken) return N1;\n    if (N1 == N2) return N1;\n    break;\n  case ISD::BUILD_VECTOR: {\n    // Attempt to simplify BUILD_VECTOR.\n    SDValue Ops[] = {N1, N2};\n    if (SDValue V = FoldBUILD_VECTOR(DL, VT, Ops, *this))\n      return V;\n    break;\n  }\n  case ISD::CONCAT_VECTORS: {\n    SDValue Ops[] = {N1, N2};\n    if (SDValue V = foldCONCAT_VECTORS(DL, VT, Ops, *this))\n      return V;\n    break;\n  }\n  case ISD::AND:\n    assert(VT.isInteger() && \"This operator does not apply to FP types!\");\n    assert(N1.getValueType() == N2.getValueType() &&\n           N1.getValueType() == VT && \"Binary operator types must match!\");\n    // (X & 0) -> 0.  This commonly occurs when legalizing i64 values, so it's\n    // worth handling here.\n    if (N2C && N2C->isNullValue())\n      return N2;\n    if (N2C && N2C->isAllOnesValue())  // X & -1 -> X\n      return N1;\n    break;\n  case ISD::OR:\n  case ISD::XOR:\n  case ISD::ADD:\n  case ISD::SUB:\n    assert(VT.isInteger() && \"This operator does not apply to FP types!\");\n    assert(N1.getValueType() == N2.getValueType() &&\n           N1.getValueType() == VT && \"Binary operator types must match!\");\n    // (X ^|+- 0) -> X.  This commonly occurs when legalizing i64 values, so\n    // it's worth handling here.\n    if (N2C && N2C->isNullValue())\n      return N1;\n    if ((Opcode == ISD::ADD || Opcode == ISD::SUB) && VT.isVector() &&\n        VT.getVectorElementType() == MVT::i1)\n      return getNode(ISD::XOR, DL, VT, N1, N2);\n    break;\n  case ISD::MUL:\n    assert(VT.isInteger() && \"This operator does not apply to FP types!\");\n    assert(N1.getValueType() == N2.getValueType() &&\n           N1.getValueType() == VT && \"Binary operator types must match!\");\n    if (VT.isVector() && VT.getVectorElementType() == MVT::i1)\n      return getNode(ISD::AND, DL, VT, N1, N2);\n    if (N2C && (N1.getOpcode() == ISD::VSCALE) && Flags.hasNoSignedWrap()) {\n      const APInt &MulImm = N1->getConstantOperandAPInt(0);\n      const APInt &N2CImm = N2C->getAPIntValue();\n      return getVScale(DL, VT, MulImm * N2CImm);\n    }\n    break;\n  case ISD::UDIV:\n  case ISD::UREM:\n  case ISD::MULHU:\n  case ISD::MULHS:\n  case ISD::SDIV:\n  case ISD::SREM:\n  case ISD::SADDSAT:\n  case ISD::SSUBSAT:\n  case ISD::UADDSAT:\n  case ISD::USUBSAT:\n    assert(VT.isInteger() && \"This operator does not apply to FP types!\");\n    assert(N1.getValueType() == N2.getValueType() &&\n           N1.getValueType() == VT && \"Binary operator types must match!\");\n    if (VT.isVector() && VT.getVectorElementType() == MVT::i1) {\n      // fold (add_sat x, y) -> (or x, y) for bool types.\n      if (Opcode == ISD::SADDSAT || Opcode == ISD::UADDSAT)\n        return getNode(ISD::OR, DL, VT, N1, N2);\n      // fold (sub_sat x, y) -> (and x, ~y) for bool types.\n      if (Opcode == ISD::SSUBSAT || Opcode == ISD::USUBSAT)\n        return getNode(ISD::AND, DL, VT, N1, getNOT(DL, N2, VT));\n    }\n    break;\n  case ISD::SMIN:\n  case ISD::UMAX:\n    assert(VT.isInteger() && \"This operator does not apply to FP types!\");\n    assert(N1.getValueType() == N2.getValueType() &&\n           N1.getValueType() == VT && \"Binary operator types must match!\");\n    if (VT.isVector() && VT.getVectorElementType() == MVT::i1)\n      return getNode(ISD::OR, DL, VT, N1, N2);\n    break;\n  case ISD::SMAX:\n  case ISD::UMIN:\n    assert(VT.isInteger() && \"This operator does not apply to FP types!\");\n    assert(N1.getValueType() == N2.getValueType() &&\n           N1.getValueType() == VT && \"Binary operator types must match!\");\n    if (VT.isVector() && VT.getVectorElementType() == MVT::i1)\n      return getNode(ISD::AND, DL, VT, N1, N2);\n    break;\n  case ISD::FADD:\n  case ISD::FSUB:\n  case ISD::FMUL:\n  case ISD::FDIV:\n  case ISD::FREM:\n    assert(VT.isFloatingPoint() && \"This operator only applies to FP types!\");\n    assert(N1.getValueType() == N2.getValueType() &&\n           N1.getValueType() == VT && \"Binary operator types must match!\");\n    if (SDValue V = simplifyFPBinop(Opcode, N1, N2, Flags))\n      return V;\n    break;\n  case ISD::FCOPYSIGN:   // N1 and result must match.  N1/N2 need not match.\n    assert(N1.getValueType() == VT &&\n           N1.getValueType().isFloatingPoint() &&\n           N2.getValueType().isFloatingPoint() &&\n           \"Invalid FCOPYSIGN!\");\n    break;\n  case ISD::SHL:\n    if (N2C && (N1.getOpcode() == ISD::VSCALE) && Flags.hasNoSignedWrap()) {\n      const APInt &MulImm = N1->getConstantOperandAPInt(0);\n      const APInt &ShiftImm = N2C->getAPIntValue();\n      return getVScale(DL, VT, MulImm << ShiftImm);\n    }\n    LLVM_FALLTHROUGH;\n  case ISD::SRA:\n  case ISD::SRL:\n    if (SDValue V = simplifyShift(N1, N2))\n      return V;\n    LLVM_FALLTHROUGH;\n  case ISD::ROTL:\n  case ISD::ROTR:\n    assert(VT == N1.getValueType() &&\n           \"Shift operators return type must be the same as their first arg\");\n    assert(VT.isInteger() && N2.getValueType().isInteger() &&\n           \"Shifts only work on integers\");\n    assert((!VT.isVector() || VT == N2.getValueType()) &&\n           \"Vector shift amounts must be in the same as their first arg\");\n    // Verify that the shift amount VT is big enough to hold valid shift\n    // amounts.  This catches things like trying to shift an i1024 value by an\n    // i8, which is easy to fall into in generic code that uses\n    // TLI.getShiftAmount().\n    assert(N2.getValueType().getScalarSizeInBits() >=\n               Log2_32_Ceil(VT.getScalarSizeInBits()) &&\n           \"Invalid use of small shift amount with oversized value!\");\n\n    // Always fold shifts of i1 values so the code generator doesn't need to\n    // handle them.  Since we know the size of the shift has to be less than the\n    // size of the value, the shift/rotate count is guaranteed to be zero.\n    if (VT == MVT::i1)\n      return N1;\n    if (N2C && N2C->isNullValue())\n      return N1;\n    break;\n  case ISD::FP_ROUND:\n    assert(VT.isFloatingPoint() &&\n           N1.getValueType().isFloatingPoint() &&\n           VT.bitsLE(N1.getValueType()) &&\n           N2C && (N2C->getZExtValue() == 0 || N2C->getZExtValue() == 1) &&\n           \"Invalid FP_ROUND!\");\n    if (N1.getValueType() == VT) return N1;  // noop conversion.\n    break;\n  case ISD::AssertSext:\n  case ISD::AssertZext: {\n    EVT EVT = cast<VTSDNode>(N2)->getVT();\n    assert(VT == N1.getValueType() && \"Not an inreg extend!\");\n    assert(VT.isInteger() && EVT.isInteger() &&\n           \"Cannot *_EXTEND_INREG FP types\");\n    assert(!EVT.isVector() &&\n           \"AssertSExt/AssertZExt type should be the vector element type \"\n           \"rather than the vector type!\");\n    assert(EVT.bitsLE(VT.getScalarType()) && \"Not extending!\");\n    if (VT.getScalarType() == EVT) return N1; // noop assertion.\n    break;\n  }\n  case ISD::SIGN_EXTEND_INREG: {\n    EVT EVT = cast<VTSDNode>(N2)->getVT();\n    assert(VT == N1.getValueType() && \"Not an inreg extend!\");\n    assert(VT.isInteger() && EVT.isInteger() &&\n           \"Cannot *_EXTEND_INREG FP types\");\n    assert(EVT.isVector() == VT.isVector() &&\n           \"SIGN_EXTEND_INREG type should be vector iff the operand \"\n           \"type is vector!\");\n    assert((!EVT.isVector() ||\n            EVT.getVectorElementCount() == VT.getVectorElementCount()) &&\n           \"Vector element counts must match in SIGN_EXTEND_INREG\");\n    assert(EVT.bitsLE(VT) && \"Not extending!\");\n    if (EVT == VT) return N1;  // Not actually extending\n\n    auto SignExtendInReg = [&](APInt Val, llvm::EVT ConstantVT) {\n      unsigned FromBits = EVT.getScalarSizeInBits();\n      Val <<= Val.getBitWidth() - FromBits;\n      Val.ashrInPlace(Val.getBitWidth() - FromBits);\n      return getConstant(Val, DL, ConstantVT);\n    };\n\n    if (N1C) {\n      const APInt &Val = N1C->getAPIntValue();\n      return SignExtendInReg(Val, VT);\n    }\n    if (ISD::isBuildVectorOfConstantSDNodes(N1.getNode())) {\n      SmallVector<SDValue, 8> Ops;\n      llvm::EVT OpVT = N1.getOperand(0).getValueType();\n      for (int i = 0, e = VT.getVectorNumElements(); i != e; ++i) {\n        SDValue Op = N1.getOperand(i);\n        if (Op.isUndef()) {\n          Ops.push_back(getUNDEF(OpVT));\n          continue;\n        }\n        ConstantSDNode *C = cast<ConstantSDNode>(Op);\n        APInt Val = C->getAPIntValue();\n        Ops.push_back(SignExtendInReg(Val, OpVT));\n      }\n      return getBuildVector(VT, DL, Ops);\n    }\n    break;\n  }\n  case ISD::EXTRACT_VECTOR_ELT:\n    assert(VT.getSizeInBits() >= N1.getValueType().getScalarSizeInBits() &&\n           \"The result of EXTRACT_VECTOR_ELT must be at least as wide as the \\\n             element type of the vector.\");\n\n    // Extract from an undefined value or using an undefined index is undefined.\n    if (N1.isUndef() || N2.isUndef())\n      return getUNDEF(VT);\n\n    // EXTRACT_VECTOR_ELT of out-of-bounds element is an UNDEF for fixed length\n    // vectors. For scalable vectors we will provide appropriate support for\n    // dealing with arbitrary indices.\n    if (N2C && N1.getValueType().isFixedLengthVector() &&\n        N2C->getAPIntValue().uge(N1.getValueType().getVectorNumElements()))\n      return getUNDEF(VT);\n\n    // EXTRACT_VECTOR_ELT of CONCAT_VECTORS is often formed while lowering is\n    // expanding copies of large vectors from registers. This only works for\n    // fixed length vectors, since we need to know the exact number of\n    // elements.\n    if (N2C && N1.getOperand(0).getValueType().isFixedLengthVector() &&\n        N1.getOpcode() == ISD::CONCAT_VECTORS && N1.getNumOperands() > 0) {\n      unsigned Factor =\n        N1.getOperand(0).getValueType().getVectorNumElements();\n      return getNode(ISD::EXTRACT_VECTOR_ELT, DL, VT,\n                     N1.getOperand(N2C->getZExtValue() / Factor),\n                     getVectorIdxConstant(N2C->getZExtValue() % Factor, DL));\n    }\n\n    // EXTRACT_VECTOR_ELT of BUILD_VECTOR or SPLAT_VECTOR is often formed while\n    // lowering is expanding large vector constants.\n    if (N2C && (N1.getOpcode() == ISD::BUILD_VECTOR ||\n                N1.getOpcode() == ISD::SPLAT_VECTOR)) {\n      assert((N1.getOpcode() != ISD::BUILD_VECTOR ||\n              N1.getValueType().isFixedLengthVector()) &&\n             \"BUILD_VECTOR used for scalable vectors\");\n      unsigned Index =\n          N1.getOpcode() == ISD::BUILD_VECTOR ? N2C->getZExtValue() : 0;\n      SDValue Elt = N1.getOperand(Index);\n\n      if (VT != Elt.getValueType())\n        // If the vector element type is not legal, the BUILD_VECTOR operands\n        // are promoted and implicitly truncated, and the result implicitly\n        // extended. Make that explicit here.\n        Elt = getAnyExtOrTrunc(Elt, DL, VT);\n\n      return Elt;\n    }\n\n    // EXTRACT_VECTOR_ELT of INSERT_VECTOR_ELT is often formed when vector\n    // operations are lowered to scalars.\n    if (N1.getOpcode() == ISD::INSERT_VECTOR_ELT) {\n      // If the indices are the same, return the inserted element else\n      // if the indices are known different, extract the element from\n      // the original vector.\n      SDValue N1Op2 = N1.getOperand(2);\n      ConstantSDNode *N1Op2C = dyn_cast<ConstantSDNode>(N1Op2);\n\n      if (N1Op2C && N2C) {\n        if (N1Op2C->getZExtValue() == N2C->getZExtValue()) {\n          if (VT == N1.getOperand(1).getValueType())\n            return N1.getOperand(1);\n          else\n            return getSExtOrTrunc(N1.getOperand(1), DL, VT);\n        }\n\n        return getNode(ISD::EXTRACT_VECTOR_ELT, DL, VT, N1.getOperand(0), N2);\n      }\n    }\n\n    // EXTRACT_VECTOR_ELT of v1iX EXTRACT_SUBVECTOR could be formed\n    // when vector types are scalarized and v1iX is legal.\n    // vextract (v1iX extract_subvector(vNiX, Idx)) -> vextract(vNiX,Idx).\n    // Here we are completely ignoring the extract element index (N2),\n    // which is fine for fixed width vectors, since any index other than 0\n    // is undefined anyway. However, this cannot be ignored for scalable\n    // vectors - in theory we could support this, but we don't want to do this\n    // without a profitability check.\n    if (N1.getOpcode() == ISD::EXTRACT_SUBVECTOR &&\n        N1.getValueType().isFixedLengthVector() &&\n        N1.getValueType().getVectorNumElements() == 1) {\n      return getNode(ISD::EXTRACT_VECTOR_ELT, DL, VT, N1.getOperand(0),\n                     N1.getOperand(1));\n    }\n    break;\n  case ISD::EXTRACT_ELEMENT:\n    assert(N2C && (unsigned)N2C->getZExtValue() < 2 && \"Bad EXTRACT_ELEMENT!\");\n    assert(!N1.getValueType().isVector() && !VT.isVector() &&\n           (N1.getValueType().isInteger() == VT.isInteger()) &&\n           N1.getValueType() != VT &&\n           \"Wrong types for EXTRACT_ELEMENT!\");\n\n    // EXTRACT_ELEMENT of BUILD_PAIR is often formed while legalize is expanding\n    // 64-bit integers into 32-bit parts.  Instead of building the extract of\n    // the BUILD_PAIR, only to have legalize rip it apart, just do it now.\n    if (N1.getOpcode() == ISD::BUILD_PAIR)\n      return N1.getOperand(N2C->getZExtValue());\n\n    // EXTRACT_ELEMENT of a constant int is also very common.\n    if (N1C) {\n      unsigned ElementSize = VT.getSizeInBits();\n      unsigned Shift = ElementSize * N2C->getZExtValue();\n      const APInt &Val = N1C->getAPIntValue();\n      return getConstant(Val.extractBits(ElementSize, Shift), DL, VT);\n    }\n    break;\n  case ISD::EXTRACT_SUBVECTOR:\n    EVT N1VT = N1.getValueType();\n    assert(VT.isVector() && N1VT.isVector() &&\n           \"Extract subvector VTs must be vectors!\");\n    assert(VT.getVectorElementType() == N1VT.getVectorElementType() &&\n           \"Extract subvector VTs must have the same element type!\");\n    assert((VT.isFixedLengthVector() || N1VT.isScalableVector()) &&\n           \"Cannot extract a scalable vector from a fixed length vector!\");\n    assert((VT.isScalableVector() != N1VT.isScalableVector() ||\n            VT.getVectorMinNumElements() <= N1VT.getVectorMinNumElements()) &&\n           \"Extract subvector must be from larger vector to smaller vector!\");\n    assert(N2C && \"Extract subvector index must be a constant\");\n    assert((VT.isScalableVector() != N1VT.isScalableVector() ||\n            (VT.getVectorMinNumElements() + N2C->getZExtValue()) <=\n                N1VT.getVectorMinNumElements()) &&\n           \"Extract subvector overflow!\");\n    assert(N2C->getAPIntValue().getBitWidth() ==\n               TLI->getVectorIdxTy(getDataLayout()).getFixedSizeInBits() &&\n           \"Constant index for EXTRACT_SUBVECTOR has an invalid size\");\n\n    // Trivial extraction.\n    if (VT == N1VT)\n      return N1;\n\n    // EXTRACT_SUBVECTOR of an UNDEF is an UNDEF.\n    if (N1.isUndef())\n      return getUNDEF(VT);\n\n    // EXTRACT_SUBVECTOR of CONCAT_VECTOR can be simplified if the pieces of\n    // the concat have the same type as the extract.\n    if (N1.getOpcode() == ISD::CONCAT_VECTORS && N1.getNumOperands() > 0 &&\n        VT == N1.getOperand(0).getValueType()) {\n      unsigned Factor = VT.getVectorMinNumElements();\n      return N1.getOperand(N2C->getZExtValue() / Factor);\n    }\n\n    // EXTRACT_SUBVECTOR of INSERT_SUBVECTOR is often created\n    // during shuffle legalization.\n    if (N1.getOpcode() == ISD::INSERT_SUBVECTOR && N2 == N1.getOperand(2) &&\n        VT == N1.getOperand(1).getValueType())\n      return N1.getOperand(1);\n    break;\n  }\n\n  // Perform trivial constant folding.\n  if (SDValue SV = FoldConstantArithmetic(Opcode, DL, VT, {N1, N2}))\n    return SV;\n\n  if (SDValue V = foldConstantFPMath(Opcode, DL, VT, N1, N2))\n    return V;\n\n  // Canonicalize an UNDEF to the RHS, even over a constant.\n  if (N1.isUndef()) {\n    if (TLI->isCommutativeBinOp(Opcode)) {\n      std::swap(N1, N2);\n    } else {\n      switch (Opcode) {\n      case ISD::SIGN_EXTEND_INREG:\n      case ISD::SUB:\n        return getUNDEF(VT);     // fold op(undef, arg2) -> undef\n      case ISD::UDIV:\n      case ISD::SDIV:\n      case ISD::UREM:\n      case ISD::SREM:\n      case ISD::SSUBSAT:\n      case ISD::USUBSAT:\n        return getConstant(0, DL, VT);    // fold op(undef, arg2) -> 0\n      }\n    }\n  }\n\n  // Fold a bunch of operators when the RHS is undef.\n  if (N2.isUndef()) {\n    switch (Opcode) {\n    case ISD::XOR:\n      if (N1.isUndef())\n        // Handle undef ^ undef -> 0 special case. This is a common\n        // idiom (misuse).\n        return getConstant(0, DL, VT);\n      LLVM_FALLTHROUGH;\n    case ISD::ADD:\n    case ISD::SUB:\n    case ISD::UDIV:\n    case ISD::SDIV:\n    case ISD::UREM:\n    case ISD::SREM:\n      return getUNDEF(VT);       // fold op(arg1, undef) -> undef\n    case ISD::MUL:\n    case ISD::AND:\n    case ISD::SSUBSAT:\n    case ISD::USUBSAT:\n      return getConstant(0, DL, VT);  // fold op(arg1, undef) -> 0\n    case ISD::OR:\n    case ISD::SADDSAT:\n    case ISD::UADDSAT:\n      return getAllOnesConstant(DL, VT);\n    }\n  }\n\n  // Memoize this node if possible.\n  SDNode *N;\n  SDVTList VTs = getVTList(VT);\n  SDValue Ops[] = {N1, N2};\n  if (VT != MVT::Glue) {\n    FoldingSetNodeID ID;\n    AddNodeIDNode(ID, Opcode, VTs, Ops);\n    void *IP = nullptr;\n    if (SDNode *E = FindNodeOrInsertPos(ID, DL, IP)) {\n      E->intersectFlagsWith(Flags);\n      return SDValue(E, 0);\n    }\n\n    N = newSDNode<SDNode>(Opcode, DL.getIROrder(), DL.getDebugLoc(), VTs);\n    N->setFlags(Flags);\n    createOperands(N, Ops);\n    CSEMap.InsertNode(N, IP);\n  } else {\n    N = newSDNode<SDNode>(Opcode, DL.getIROrder(), DL.getDebugLoc(), VTs);\n    createOperands(N, Ops);\n  }\n\n  InsertNode(N);\n  SDValue V = SDValue(N, 0);\n  NewSDValueDbgMsg(V, \"Creating new node: \", this);\n  return V;\n}\n\nSDValue SelectionDAG::getNode(unsigned Opcode, const SDLoc &DL, EVT VT,\n                              SDValue N1, SDValue N2, SDValue N3) {\n  SDNodeFlags Flags;\n  if (Inserter)\n    Flags = Inserter->getFlags();\n  return getNode(Opcode, DL, VT, N1, N2, N3, Flags);\n}\n\nSDValue SelectionDAG::getNode(unsigned Opcode, const SDLoc &DL, EVT VT,\n                              SDValue N1, SDValue N2, SDValue N3,\n                              const SDNodeFlags Flags) {\n  assert(N1.getOpcode() != ISD::DELETED_NODE &&\n         N2.getOpcode() != ISD::DELETED_NODE &&\n         N3.getOpcode() != ISD::DELETED_NODE &&\n         \"Operand is DELETED_NODE!\");\n  // Perform various simplifications.\n  switch (Opcode) {\n  case ISD::FMA: {\n    assert(VT.isFloatingPoint() && \"This operator only applies to FP types!\");\n    assert(N1.getValueType() == VT && N2.getValueType() == VT &&\n           N3.getValueType() == VT && \"FMA types must match!\");\n    ConstantFPSDNode *N1CFP = dyn_cast<ConstantFPSDNode>(N1);\n    ConstantFPSDNode *N2CFP = dyn_cast<ConstantFPSDNode>(N2);\n    ConstantFPSDNode *N3CFP = dyn_cast<ConstantFPSDNode>(N3);\n    if (N1CFP && N2CFP && N3CFP) {\n      APFloat  V1 = N1CFP->getValueAPF();\n      const APFloat &V2 = N2CFP->getValueAPF();\n      const APFloat &V3 = N3CFP->getValueAPF();\n      V1.fusedMultiplyAdd(V2, V3, APFloat::rmNearestTiesToEven);\n      return getConstantFP(V1, DL, VT);\n    }\n    break;\n  }\n  case ISD::BUILD_VECTOR: {\n    // Attempt to simplify BUILD_VECTOR.\n    SDValue Ops[] = {N1, N2, N3};\n    if (SDValue V = FoldBUILD_VECTOR(DL, VT, Ops, *this))\n      return V;\n    break;\n  }\n  case ISD::CONCAT_VECTORS: {\n    SDValue Ops[] = {N1, N2, N3};\n    if (SDValue V = foldCONCAT_VECTORS(DL, VT, Ops, *this))\n      return V;\n    break;\n  }\n  case ISD::SETCC: {\n    assert(VT.isInteger() && \"SETCC result type must be an integer!\");\n    assert(N1.getValueType() == N2.getValueType() &&\n           \"SETCC operands must have the same type!\");\n    assert(VT.isVector() == N1.getValueType().isVector() &&\n           \"SETCC type should be vector iff the operand type is vector!\");\n    assert((!VT.isVector() || VT.getVectorElementCount() ==\n                                  N1.getValueType().getVectorElementCount()) &&\n           \"SETCC vector element counts must match!\");\n    // Use FoldSetCC to simplify SETCC's.\n    if (SDValue V = FoldSetCC(VT, N1, N2, cast<CondCodeSDNode>(N3)->get(), DL))\n      return V;\n    // Vector constant folding.\n    SDValue Ops[] = {N1, N2, N3};\n    if (SDValue V = FoldConstantVectorArithmetic(Opcode, DL, VT, Ops)) {\n      NewSDValueDbgMsg(V, \"New node vector constant folding: \", this);\n      return V;\n    }\n    break;\n  }\n  case ISD::SELECT:\n  case ISD::VSELECT:\n    if (SDValue V = simplifySelect(N1, N2, N3))\n      return V;\n    break;\n  case ISD::VECTOR_SHUFFLE:\n    llvm_unreachable(\"should use getVectorShuffle constructor!\");\n  case ISD::INSERT_VECTOR_ELT: {\n    ConstantSDNode *N3C = dyn_cast<ConstantSDNode>(N3);\n    // INSERT_VECTOR_ELT into out-of-bounds element is an UNDEF, except\n    // for scalable vectors where we will generate appropriate code to\n    // deal with out-of-bounds cases correctly.\n    if (N3C && N1.getValueType().isFixedLengthVector() &&\n        N3C->getZExtValue() >= N1.getValueType().getVectorNumElements())\n      return getUNDEF(VT);\n\n    // Undefined index can be assumed out-of-bounds, so that's UNDEF too.\n    if (N3.isUndef())\n      return getUNDEF(VT);\n\n    // If the inserted element is an UNDEF, just use the input vector.\n    if (N2.isUndef())\n      return N1;\n\n    break;\n  }\n  case ISD::INSERT_SUBVECTOR: {\n    // Inserting undef into undef is still undef.\n    if (N1.isUndef() && N2.isUndef())\n      return getUNDEF(VT);\n\n    EVT N2VT = N2.getValueType();\n    assert(VT == N1.getValueType() &&\n           \"Dest and insert subvector source types must match!\");\n    assert(VT.isVector() && N2VT.isVector() &&\n           \"Insert subvector VTs must be vectors!\");\n    assert((VT.isScalableVector() || N2VT.isFixedLengthVector()) &&\n           \"Cannot insert a scalable vector into a fixed length vector!\");\n    assert((VT.isScalableVector() != N2VT.isScalableVector() ||\n            VT.getVectorMinNumElements() >= N2VT.getVectorMinNumElements()) &&\n           \"Insert subvector must be from smaller vector to larger vector!\");\n    assert(isa<ConstantSDNode>(N3) &&\n           \"Insert subvector index must be constant\");\n    assert((VT.isScalableVector() != N2VT.isScalableVector() ||\n            (N2VT.getVectorMinNumElements() +\n             cast<ConstantSDNode>(N3)->getZExtValue()) <=\n                VT.getVectorMinNumElements()) &&\n           \"Insert subvector overflow!\");\n    assert(cast<ConstantSDNode>(N3)->getAPIntValue().getBitWidth() ==\n               TLI->getVectorIdxTy(getDataLayout()).getFixedSizeInBits() &&\n           \"Constant index for INSERT_SUBVECTOR has an invalid size\");\n\n    // Trivial insertion.\n    if (VT == N2VT)\n      return N2;\n\n    // If this is an insert of an extracted vector into an undef vector, we\n    // can just use the input to the extract.\n    if (N1.isUndef() && N2.getOpcode() == ISD::EXTRACT_SUBVECTOR &&\n        N2.getOperand(1) == N3 && N2.getOperand(0).getValueType() == VT)\n      return N2.getOperand(0);\n    break;\n  }\n  case ISD::BITCAST:\n    // Fold bit_convert nodes from a type to themselves.\n    if (N1.getValueType() == VT)\n      return N1;\n    break;\n  }\n\n  // Memoize node if it doesn't produce a flag.\n  SDNode *N;\n  SDVTList VTs = getVTList(VT);\n  SDValue Ops[] = {N1, N2, N3};\n  if (VT != MVT::Glue) {\n    FoldingSetNodeID ID;\n    AddNodeIDNode(ID, Opcode, VTs, Ops);\n    void *IP = nullptr;\n    if (SDNode *E = FindNodeOrInsertPos(ID, DL, IP)) {\n      E->intersectFlagsWith(Flags);\n      return SDValue(E, 0);\n    }\n\n    N = newSDNode<SDNode>(Opcode, DL.getIROrder(), DL.getDebugLoc(), VTs);\n    N->setFlags(Flags);\n    createOperands(N, Ops);\n    CSEMap.InsertNode(N, IP);\n  } else {\n    N = newSDNode<SDNode>(Opcode, DL.getIROrder(), DL.getDebugLoc(), VTs);\n    createOperands(N, Ops);\n  }\n\n  InsertNode(N);\n  SDValue V = SDValue(N, 0);\n  NewSDValueDbgMsg(V, \"Creating new node: \", this);\n  return V;\n}\n\nSDValue SelectionDAG::getNode(unsigned Opcode, const SDLoc &DL, EVT VT,\n                              SDValue N1, SDValue N2, SDValue N3, SDValue N4) {\n  SDValue Ops[] = { N1, N2, N3, N4 };\n  return getNode(Opcode, DL, VT, Ops);\n}\n\nSDValue SelectionDAG::getNode(unsigned Opcode, const SDLoc &DL, EVT VT,\n                              SDValue N1, SDValue N2, SDValue N3, SDValue N4,\n                              SDValue N5) {\n  SDValue Ops[] = { N1, N2, N3, N4, N5 };\n  return getNode(Opcode, DL, VT, Ops);\n}\n\n/// getStackArgumentTokenFactor - Compute a TokenFactor to force all\n/// the incoming stack arguments to be loaded from the stack.\nSDValue SelectionDAG::getStackArgumentTokenFactor(SDValue Chain) {\n  SmallVector<SDValue, 8> ArgChains;\n\n  // Include the original chain at the beginning of the list. When this is\n  // used by target LowerCall hooks, this helps legalize find the\n  // CALLSEQ_BEGIN node.\n  ArgChains.push_back(Chain);\n\n  // Add a chain value for each stack argument.\n  for (SDNode::use_iterator U = getEntryNode().getNode()->use_begin(),\n       UE = getEntryNode().getNode()->use_end(); U != UE; ++U)\n    if (LoadSDNode *L = dyn_cast<LoadSDNode>(*U))\n      if (FrameIndexSDNode *FI = dyn_cast<FrameIndexSDNode>(L->getBasePtr()))\n        if (FI->getIndex() < 0)\n          ArgChains.push_back(SDValue(L, 1));\n\n  // Build a tokenfactor for all the chains.\n  return getNode(ISD::TokenFactor, SDLoc(Chain), MVT::Other, ArgChains);\n}\n\n/// getMemsetValue - Vectorized representation of the memset value\n/// operand.\nstatic SDValue getMemsetValue(SDValue Value, EVT VT, SelectionDAG &DAG,\n                              const SDLoc &dl) {\n  assert(!Value.isUndef());\n\n  unsigned NumBits = VT.getScalarSizeInBits();\n  if (ConstantSDNode *C = dyn_cast<ConstantSDNode>(Value)) {\n    assert(C->getAPIntValue().getBitWidth() == 8);\n    APInt Val = APInt::getSplat(NumBits, C->getAPIntValue());\n    if (VT.isInteger()) {\n      bool IsOpaque = VT.getSizeInBits() > 64 ||\n          !DAG.getTargetLoweringInfo().isLegalStoreImmediate(C->getSExtValue());\n      return DAG.getConstant(Val, dl, VT, false, IsOpaque);\n    }\n    return DAG.getConstantFP(APFloat(DAG.EVTToAPFloatSemantics(VT), Val), dl,\n                             VT);\n  }\n\n  assert(Value.getValueType() == MVT::i8 && \"memset with non-byte fill value?\");\n  EVT IntVT = VT.getScalarType();\n  if (!IntVT.isInteger())\n    IntVT = EVT::getIntegerVT(*DAG.getContext(), IntVT.getSizeInBits());\n\n  Value = DAG.getNode(ISD::ZERO_EXTEND, dl, IntVT, Value);\n  if (NumBits > 8) {\n    // Use a multiplication with 0x010101... to extend the input to the\n    // required length.\n    APInt Magic = APInt::getSplat(NumBits, APInt(8, 0x01));\n    Value = DAG.getNode(ISD::MUL, dl, IntVT, Value,\n                        DAG.getConstant(Magic, dl, IntVT));\n  }\n\n  if (VT != Value.getValueType() && !VT.isInteger())\n    Value = DAG.getBitcast(VT.getScalarType(), Value);\n  if (VT != Value.getValueType())\n    Value = DAG.getSplatBuildVector(VT, dl, Value);\n\n  return Value;\n}\n\n/// getMemsetStringVal - Similar to getMemsetValue. Except this is only\n/// used when a memcpy is turned into a memset when the source is a constant\n/// string ptr.\nstatic SDValue getMemsetStringVal(EVT VT, const SDLoc &dl, SelectionDAG &DAG,\n                                  const TargetLowering &TLI,\n                                  const ConstantDataArraySlice &Slice) {\n  // Handle vector with all elements zero.\n  if (Slice.Array == nullptr) {\n    if (VT.isInteger())\n      return DAG.getConstant(0, dl, VT);\n    else if (VT == MVT::f32 || VT == MVT::f64 || VT == MVT::f128)\n      return DAG.getConstantFP(0.0, dl, VT);\n    else if (VT.isVector()) {\n      unsigned NumElts = VT.getVectorNumElements();\n      MVT EltVT = (VT.getVectorElementType() == MVT::f32) ? MVT::i32 : MVT::i64;\n      return DAG.getNode(ISD::BITCAST, dl, VT,\n                         DAG.getConstant(0, dl,\n                                         EVT::getVectorVT(*DAG.getContext(),\n                                                          EltVT, NumElts)));\n    } else\n      llvm_unreachable(\"Expected type!\");\n  }\n\n  assert(!VT.isVector() && \"Can't handle vector type here!\");\n  unsigned NumVTBits = VT.getSizeInBits();\n  unsigned NumVTBytes = NumVTBits / 8;\n  unsigned NumBytes = std::min(NumVTBytes, unsigned(Slice.Length));\n\n  APInt Val(NumVTBits, 0);\n  if (DAG.getDataLayout().isLittleEndian()) {\n    for (unsigned i = 0; i != NumBytes; ++i)\n      Val |= (uint64_t)(unsigned char)Slice[i] << i*8;\n  } else {\n    for (unsigned i = 0; i != NumBytes; ++i)\n      Val |= (uint64_t)(unsigned char)Slice[i] << (NumVTBytes-i-1)*8;\n  }\n\n  // If the \"cost\" of materializing the integer immediate is less than the cost\n  // of a load, then it is cost effective to turn the load into the immediate.\n  Type *Ty = VT.getTypeForEVT(*DAG.getContext());\n  if (TLI.shouldConvertConstantLoadToIntImm(Val, Ty))\n    return DAG.getConstant(Val, dl, VT);\n  return SDValue(nullptr, 0);\n}\n\nSDValue SelectionDAG::getMemBasePlusOffset(SDValue Base, TypeSize Offset,\n                                           const SDLoc &DL,\n                                           const SDNodeFlags Flags) {\n  EVT VT = Base.getValueType();\n  SDValue Index;\n\n  if (Offset.isScalable())\n    Index = getVScale(DL, Base.getValueType(),\n                      APInt(Base.getValueSizeInBits().getFixedSize(),\n                            Offset.getKnownMinSize()));\n  else\n    Index = getConstant(Offset.getFixedSize(), DL, VT);\n\n  return getMemBasePlusOffset(Base, Index, DL, Flags);\n}\n\nSDValue SelectionDAG::getMemBasePlusOffset(SDValue Ptr, SDValue Offset,\n                                           const SDLoc &DL,\n                                           const SDNodeFlags Flags) {\n  assert(Offset.getValueType().isInteger());\n  EVT BasePtrVT = Ptr.getValueType();\n  return getNode(ISD::ADD, DL, BasePtrVT, Ptr, Offset, Flags);\n}\n\n/// Returns true if memcpy source is constant data.\nstatic bool isMemSrcFromConstant(SDValue Src, ConstantDataArraySlice &Slice) {\n  uint64_t SrcDelta = 0;\n  GlobalAddressSDNode *G = nullptr;\n  if (Src.getOpcode() == ISD::GlobalAddress)\n    G = cast<GlobalAddressSDNode>(Src);\n  else if (Src.getOpcode() == ISD::ADD &&\n           Src.getOperand(0).getOpcode() == ISD::GlobalAddress &&\n           Src.getOperand(1).getOpcode() == ISD::Constant) {\n    G = cast<GlobalAddressSDNode>(Src.getOperand(0));\n    SrcDelta = cast<ConstantSDNode>(Src.getOperand(1))->getZExtValue();\n  }\n  if (!G)\n    return false;\n\n  return getConstantDataArrayInfo(G->getGlobal(), Slice, 8,\n                                  SrcDelta + G->getOffset());\n}\n\nstatic bool shouldLowerMemFuncForSize(const MachineFunction &MF,\n                                      SelectionDAG &DAG) {\n  // On Darwin, -Os means optimize for size without hurting performance, so\n  // only really optimize for size when -Oz (MinSize) is used.\n  if (MF.getTarget().getTargetTriple().isOSDarwin())\n    return MF.getFunction().hasMinSize();\n  return DAG.shouldOptForSize();\n}\n\nstatic void chainLoadsAndStoresForMemcpy(SelectionDAG &DAG, const SDLoc &dl,\n                          SmallVector<SDValue, 32> &OutChains, unsigned From,\n                          unsigned To, SmallVector<SDValue, 16> &OutLoadChains,\n                          SmallVector<SDValue, 16> &OutStoreChains) {\n  assert(OutLoadChains.size() && \"Missing loads in memcpy inlining\");\n  assert(OutStoreChains.size() && \"Missing stores in memcpy inlining\");\n  SmallVector<SDValue, 16> GluedLoadChains;\n  for (unsigned i = From; i < To; ++i) {\n    OutChains.push_back(OutLoadChains[i]);\n    GluedLoadChains.push_back(OutLoadChains[i]);\n  }\n\n  // Chain for all loads.\n  SDValue LoadToken = DAG.getNode(ISD::TokenFactor, dl, MVT::Other,\n                                  GluedLoadChains);\n\n  for (unsigned i = From; i < To; ++i) {\n    StoreSDNode *ST = dyn_cast<StoreSDNode>(OutStoreChains[i]);\n    SDValue NewStore = DAG.getTruncStore(LoadToken, dl, ST->getValue(),\n                                  ST->getBasePtr(), ST->getMemoryVT(),\n                                  ST->getMemOperand());\n    OutChains.push_back(NewStore);\n  }\n}\n\nstatic SDValue getMemcpyLoadsAndStores(SelectionDAG &DAG, const SDLoc &dl,\n                                       SDValue Chain, SDValue Dst, SDValue Src,\n                                       uint64_t Size, Align Alignment,\n                                       bool isVol, bool AlwaysInline,\n                                       MachinePointerInfo DstPtrInfo,\n                                       MachinePointerInfo SrcPtrInfo) {\n  // Turn a memcpy of undef to nop.\n  // FIXME: We need to honor volatile even is Src is undef.\n  if (Src.isUndef())\n    return Chain;\n\n  // Expand memcpy to a series of load and store ops if the size operand falls\n  // below a certain threshold.\n  // TODO: In the AlwaysInline case, if the size is big then generate a loop\n  // rather than maybe a humongous number of loads and stores.\n  const TargetLowering &TLI = DAG.getTargetLoweringInfo();\n  const DataLayout &DL = DAG.getDataLayout();\n  LLVMContext &C = *DAG.getContext();\n  std::vector<EVT> MemOps;\n  bool DstAlignCanChange = false;\n  MachineFunction &MF = DAG.getMachineFunction();\n  MachineFrameInfo &MFI = MF.getFrameInfo();\n  bool OptSize = shouldLowerMemFuncForSize(MF, DAG);\n  FrameIndexSDNode *FI = dyn_cast<FrameIndexSDNode>(Dst);\n  if (FI && !MFI.isFixedObjectIndex(FI->getIndex()))\n    DstAlignCanChange = true;\n  MaybeAlign SrcAlign = DAG.InferPtrAlign(Src);\n  if (!SrcAlign || Alignment > *SrcAlign)\n    SrcAlign = Alignment;\n  assert(SrcAlign && \"SrcAlign must be set\");\n  ConstantDataArraySlice Slice;\n  // If marked as volatile, perform a copy even when marked as constant.\n  bool CopyFromConstant = !isVol && isMemSrcFromConstant(Src, Slice);\n  bool isZeroConstant = CopyFromConstant && Slice.Array == nullptr;\n  unsigned Limit = AlwaysInline ? ~0U : TLI.getMaxStoresPerMemcpy(OptSize);\n  const MemOp Op = isZeroConstant\n                       ? MemOp::Set(Size, DstAlignCanChange, Alignment,\n                                    /*IsZeroMemset*/ true, isVol)\n                       : MemOp::Copy(Size, DstAlignCanChange, Alignment,\n                                     *SrcAlign, isVol, CopyFromConstant);\n  if (!TLI.findOptimalMemOpLowering(\n          MemOps, Limit, Op, DstPtrInfo.getAddrSpace(),\n          SrcPtrInfo.getAddrSpace(), MF.getFunction().getAttributes()))\n    return SDValue();\n\n  if (DstAlignCanChange) {\n    Type *Ty = MemOps[0].getTypeForEVT(C);\n    Align NewAlign = DL.getABITypeAlign(Ty);\n\n    // Don't promote to an alignment that would require dynamic stack\n    // realignment.\n    const TargetRegisterInfo *TRI = MF.getSubtarget().getRegisterInfo();\n    if (!TRI->needsStackRealignment(MF))\n      while (NewAlign > Alignment && DL.exceedsNaturalStackAlignment(NewAlign))\n        NewAlign = NewAlign / 2;\n\n    if (NewAlign > Alignment) {\n      // Give the stack frame object a larger alignment if needed.\n      if (MFI.getObjectAlign(FI->getIndex()) < NewAlign)\n        MFI.setObjectAlignment(FI->getIndex(), NewAlign);\n      Alignment = NewAlign;\n    }\n  }\n\n  MachineMemOperand::Flags MMOFlags =\n      isVol ? MachineMemOperand::MOVolatile : MachineMemOperand::MONone;\n  SmallVector<SDValue, 16> OutLoadChains;\n  SmallVector<SDValue, 16> OutStoreChains;\n  SmallVector<SDValue, 32> OutChains;\n  unsigned NumMemOps = MemOps.size();\n  uint64_t SrcOff = 0, DstOff = 0;\n  for (unsigned i = 0; i != NumMemOps; ++i) {\n    EVT VT = MemOps[i];\n    unsigned VTSize = VT.getSizeInBits() / 8;\n    SDValue Value, Store;\n\n    if (VTSize > Size) {\n      // Issuing an unaligned load / store pair  that overlaps with the previous\n      // pair. Adjust the offset accordingly.\n      assert(i == NumMemOps-1 && i != 0);\n      SrcOff -= VTSize - Size;\n      DstOff -= VTSize - Size;\n    }\n\n    if (CopyFromConstant &&\n        (isZeroConstant || (VT.isInteger() && !VT.isVector()))) {\n      // It's unlikely a store of a vector immediate can be done in a single\n      // instruction. It would require a load from a constantpool first.\n      // We only handle zero vectors here.\n      // FIXME: Handle other cases where store of vector immediate is done in\n      // a single instruction.\n      ConstantDataArraySlice SubSlice;\n      if (SrcOff < Slice.Length) {\n        SubSlice = Slice;\n        SubSlice.move(SrcOff);\n      } else {\n        // This is an out-of-bounds access and hence UB. Pretend we read zero.\n        SubSlice.Array = nullptr;\n        SubSlice.Offset = 0;\n        SubSlice.Length = VTSize;\n      }\n      Value = getMemsetStringVal(VT, dl, DAG, TLI, SubSlice);\n      if (Value.getNode()) {\n        Store = DAG.getStore(\n            Chain, dl, Value,\n            DAG.getMemBasePlusOffset(Dst, TypeSize::Fixed(DstOff), dl),\n            DstPtrInfo.getWithOffset(DstOff), Alignment, MMOFlags);\n        OutChains.push_back(Store);\n      }\n    }\n\n    if (!Store.getNode()) {\n      // The type might not be legal for the target.  This should only happen\n      // if the type is smaller than a legal type, as on PPC, so the right\n      // thing to do is generate a LoadExt/StoreTrunc pair.  These simplify\n      // to Load/Store if NVT==VT.\n      // FIXME does the case above also need this?\n      EVT NVT = TLI.getTypeToTransformTo(C, VT);\n      assert(NVT.bitsGE(VT));\n\n      bool isDereferenceable =\n        SrcPtrInfo.getWithOffset(SrcOff).isDereferenceable(VTSize, C, DL);\n      MachineMemOperand::Flags SrcMMOFlags = MMOFlags;\n      if (isDereferenceable)\n        SrcMMOFlags |= MachineMemOperand::MODereferenceable;\n\n      Value = DAG.getExtLoad(\n          ISD::EXTLOAD, dl, NVT, Chain,\n          DAG.getMemBasePlusOffset(Src, TypeSize::Fixed(SrcOff), dl),\n          SrcPtrInfo.getWithOffset(SrcOff), VT,\n          commonAlignment(*SrcAlign, SrcOff), SrcMMOFlags);\n      OutLoadChains.push_back(Value.getValue(1));\n\n      Store = DAG.getTruncStore(\n          Chain, dl, Value,\n          DAG.getMemBasePlusOffset(Dst, TypeSize::Fixed(DstOff), dl),\n          DstPtrInfo.getWithOffset(DstOff), VT, Alignment, MMOFlags);\n      OutStoreChains.push_back(Store);\n    }\n    SrcOff += VTSize;\n    DstOff += VTSize;\n    Size -= VTSize;\n  }\n\n  unsigned GluedLdStLimit = MaxLdStGlue == 0 ?\n                                TLI.getMaxGluedStoresPerMemcpy() : MaxLdStGlue;\n  unsigned NumLdStInMemcpy = OutStoreChains.size();\n\n  if (NumLdStInMemcpy) {\n    // It may be that memcpy might be converted to memset if it's memcpy\n    // of constants. In such a case, we won't have loads and stores, but\n    // just stores. In the absence of loads, there is nothing to gang up.\n    if ((GluedLdStLimit <= 1) || !EnableMemCpyDAGOpt) {\n      // If target does not care, just leave as it.\n      for (unsigned i = 0; i < NumLdStInMemcpy; ++i) {\n        OutChains.push_back(OutLoadChains[i]);\n        OutChains.push_back(OutStoreChains[i]);\n      }\n    } else {\n      // Ld/St less than/equal limit set by target.\n      if (NumLdStInMemcpy <= GluedLdStLimit) {\n          chainLoadsAndStoresForMemcpy(DAG, dl, OutChains, 0,\n                                        NumLdStInMemcpy, OutLoadChains,\n                                        OutStoreChains);\n      } else {\n        unsigned NumberLdChain =  NumLdStInMemcpy / GluedLdStLimit;\n        unsigned RemainingLdStInMemcpy = NumLdStInMemcpy % GluedLdStLimit;\n        unsigned GlueIter = 0;\n\n        for (unsigned cnt = 0; cnt < NumberLdChain; ++cnt) {\n          unsigned IndexFrom = NumLdStInMemcpy - GlueIter - GluedLdStLimit;\n          unsigned IndexTo   = NumLdStInMemcpy - GlueIter;\n\n          chainLoadsAndStoresForMemcpy(DAG, dl, OutChains, IndexFrom, IndexTo,\n                                       OutLoadChains, OutStoreChains);\n          GlueIter += GluedLdStLimit;\n        }\n\n        // Residual ld/st.\n        if (RemainingLdStInMemcpy) {\n          chainLoadsAndStoresForMemcpy(DAG, dl, OutChains, 0,\n                                        RemainingLdStInMemcpy, OutLoadChains,\n                                        OutStoreChains);\n        }\n      }\n    }\n  }\n  return DAG.getNode(ISD::TokenFactor, dl, MVT::Other, OutChains);\n}\n\nstatic SDValue getMemmoveLoadsAndStores(SelectionDAG &DAG, const SDLoc &dl,\n                                        SDValue Chain, SDValue Dst, SDValue Src,\n                                        uint64_t Size, Align Alignment,\n                                        bool isVol, bool AlwaysInline,\n                                        MachinePointerInfo DstPtrInfo,\n                                        MachinePointerInfo SrcPtrInfo) {\n  // Turn a memmove of undef to nop.\n  // FIXME: We need to honor volatile even is Src is undef.\n  if (Src.isUndef())\n    return Chain;\n\n  // Expand memmove to a series of load and store ops if the size operand falls\n  // below a certain threshold.\n  const TargetLowering &TLI = DAG.getTargetLoweringInfo();\n  const DataLayout &DL = DAG.getDataLayout();\n  LLVMContext &C = *DAG.getContext();\n  std::vector<EVT> MemOps;\n  bool DstAlignCanChange = false;\n  MachineFunction &MF = DAG.getMachineFunction();\n  MachineFrameInfo &MFI = MF.getFrameInfo();\n  bool OptSize = shouldLowerMemFuncForSize(MF, DAG);\n  FrameIndexSDNode *FI = dyn_cast<FrameIndexSDNode>(Dst);\n  if (FI && !MFI.isFixedObjectIndex(FI->getIndex()))\n    DstAlignCanChange = true;\n  MaybeAlign SrcAlign = DAG.InferPtrAlign(Src);\n  if (!SrcAlign || Alignment > *SrcAlign)\n    SrcAlign = Alignment;\n  assert(SrcAlign && \"SrcAlign must be set\");\n  unsigned Limit = AlwaysInline ? ~0U : TLI.getMaxStoresPerMemmove(OptSize);\n  if (!TLI.findOptimalMemOpLowering(\n          MemOps, Limit,\n          MemOp::Copy(Size, DstAlignCanChange, Alignment, *SrcAlign,\n                      /*IsVolatile*/ true),\n          DstPtrInfo.getAddrSpace(), SrcPtrInfo.getAddrSpace(),\n          MF.getFunction().getAttributes()))\n    return SDValue();\n\n  if (DstAlignCanChange) {\n    Type *Ty = MemOps[0].getTypeForEVT(C);\n    Align NewAlign = DL.getABITypeAlign(Ty);\n    if (NewAlign > Alignment) {\n      // Give the stack frame object a larger alignment if needed.\n      if (MFI.getObjectAlign(FI->getIndex()) < NewAlign)\n        MFI.setObjectAlignment(FI->getIndex(), NewAlign);\n      Alignment = NewAlign;\n    }\n  }\n\n  MachineMemOperand::Flags MMOFlags =\n      isVol ? MachineMemOperand::MOVolatile : MachineMemOperand::MONone;\n  uint64_t SrcOff = 0, DstOff = 0;\n  SmallVector<SDValue, 8> LoadValues;\n  SmallVector<SDValue, 8> LoadChains;\n  SmallVector<SDValue, 8> OutChains;\n  unsigned NumMemOps = MemOps.size();\n  for (unsigned i = 0; i < NumMemOps; i++) {\n    EVT VT = MemOps[i];\n    unsigned VTSize = VT.getSizeInBits() / 8;\n    SDValue Value;\n\n    bool isDereferenceable =\n      SrcPtrInfo.getWithOffset(SrcOff).isDereferenceable(VTSize, C, DL);\n    MachineMemOperand::Flags SrcMMOFlags = MMOFlags;\n    if (isDereferenceable)\n      SrcMMOFlags |= MachineMemOperand::MODereferenceable;\n\n    Value =\n        DAG.getLoad(VT, dl, Chain,\n                    DAG.getMemBasePlusOffset(Src, TypeSize::Fixed(SrcOff), dl),\n                    SrcPtrInfo.getWithOffset(SrcOff), *SrcAlign, SrcMMOFlags);\n    LoadValues.push_back(Value);\n    LoadChains.push_back(Value.getValue(1));\n    SrcOff += VTSize;\n  }\n  Chain = DAG.getNode(ISD::TokenFactor, dl, MVT::Other, LoadChains);\n  OutChains.clear();\n  for (unsigned i = 0; i < NumMemOps; i++) {\n    EVT VT = MemOps[i];\n    unsigned VTSize = VT.getSizeInBits() / 8;\n    SDValue Store;\n\n    Store =\n        DAG.getStore(Chain, dl, LoadValues[i],\n                     DAG.getMemBasePlusOffset(Dst, TypeSize::Fixed(DstOff), dl),\n                     DstPtrInfo.getWithOffset(DstOff), Alignment, MMOFlags);\n    OutChains.push_back(Store);\n    DstOff += VTSize;\n  }\n\n  return DAG.getNode(ISD::TokenFactor, dl, MVT::Other, OutChains);\n}\n\n/// Lower the call to 'memset' intrinsic function into a series of store\n/// operations.\n///\n/// \\param DAG Selection DAG where lowered code is placed.\n/// \\param dl Link to corresponding IR location.\n/// \\param Chain Control flow dependency.\n/// \\param Dst Pointer to destination memory location.\n/// \\param Src Value of byte to write into the memory.\n/// \\param Size Number of bytes to write.\n/// \\param Alignment Alignment of the destination in bytes.\n/// \\param isVol True if destination is volatile.\n/// \\param DstPtrInfo IR information on the memory pointer.\n/// \\returns New head in the control flow, if lowering was successful, empty\n/// SDValue otherwise.\n///\n/// The function tries to replace 'llvm.memset' intrinsic with several store\n/// operations and value calculation code. This is usually profitable for small\n/// memory size.\nstatic SDValue getMemsetStores(SelectionDAG &DAG, const SDLoc &dl,\n                               SDValue Chain, SDValue Dst, SDValue Src,\n                               uint64_t Size, Align Alignment, bool isVol,\n                               MachinePointerInfo DstPtrInfo) {\n  // Turn a memset of undef to nop.\n  // FIXME: We need to honor volatile even is Src is undef.\n  if (Src.isUndef())\n    return Chain;\n\n  // Expand memset to a series of load/store ops if the size operand\n  // falls below a certain threshold.\n  const TargetLowering &TLI = DAG.getTargetLoweringInfo();\n  std::vector<EVT> MemOps;\n  bool DstAlignCanChange = false;\n  MachineFunction &MF = DAG.getMachineFunction();\n  MachineFrameInfo &MFI = MF.getFrameInfo();\n  bool OptSize = shouldLowerMemFuncForSize(MF, DAG);\n  FrameIndexSDNode *FI = dyn_cast<FrameIndexSDNode>(Dst);\n  if (FI && !MFI.isFixedObjectIndex(FI->getIndex()))\n    DstAlignCanChange = true;\n  bool IsZeroVal =\n    isa<ConstantSDNode>(Src) && cast<ConstantSDNode>(Src)->isNullValue();\n  if (!TLI.findOptimalMemOpLowering(\n          MemOps, TLI.getMaxStoresPerMemset(OptSize),\n          MemOp::Set(Size, DstAlignCanChange, Alignment, IsZeroVal, isVol),\n          DstPtrInfo.getAddrSpace(), ~0u, MF.getFunction().getAttributes()))\n    return SDValue();\n\n  if (DstAlignCanChange) {\n    Type *Ty = MemOps[0].getTypeForEVT(*DAG.getContext());\n    Align NewAlign = DAG.getDataLayout().getABITypeAlign(Ty);\n    if (NewAlign > Alignment) {\n      // Give the stack frame object a larger alignment if needed.\n      if (MFI.getObjectAlign(FI->getIndex()) < NewAlign)\n        MFI.setObjectAlignment(FI->getIndex(), NewAlign);\n      Alignment = NewAlign;\n    }\n  }\n\n  SmallVector<SDValue, 8> OutChains;\n  uint64_t DstOff = 0;\n  unsigned NumMemOps = MemOps.size();\n\n  // Find the largest store and generate the bit pattern for it.\n  EVT LargestVT = MemOps[0];\n  for (unsigned i = 1; i < NumMemOps; i++)\n    if (MemOps[i].bitsGT(LargestVT))\n      LargestVT = MemOps[i];\n  SDValue MemSetValue = getMemsetValue(Src, LargestVT, DAG, dl);\n\n  for (unsigned i = 0; i < NumMemOps; i++) {\n    EVT VT = MemOps[i];\n    unsigned VTSize = VT.getSizeInBits() / 8;\n    if (VTSize > Size) {\n      // Issuing an unaligned load / store pair  that overlaps with the previous\n      // pair. Adjust the offset accordingly.\n      assert(i == NumMemOps-1 && i != 0);\n      DstOff -= VTSize - Size;\n    }\n\n    // If this store is smaller than the largest store see whether we can get\n    // the smaller value for free with a truncate.\n    SDValue Value = MemSetValue;\n    if (VT.bitsLT(LargestVT)) {\n      if (!LargestVT.isVector() && !VT.isVector() &&\n          TLI.isTruncateFree(LargestVT, VT))\n        Value = DAG.getNode(ISD::TRUNCATE, dl, VT, MemSetValue);\n      else\n        Value = getMemsetValue(Src, VT, DAG, dl);\n    }\n    assert(Value.getValueType() == VT && \"Value with wrong type.\");\n    SDValue Store = DAG.getStore(\n        Chain, dl, Value,\n        DAG.getMemBasePlusOffset(Dst, TypeSize::Fixed(DstOff), dl),\n        DstPtrInfo.getWithOffset(DstOff), Alignment,\n        isVol ? MachineMemOperand::MOVolatile : MachineMemOperand::MONone);\n    OutChains.push_back(Store);\n    DstOff += VT.getSizeInBits() / 8;\n    Size -= VTSize;\n  }\n\n  return DAG.getNode(ISD::TokenFactor, dl, MVT::Other, OutChains);\n}\n\nstatic void checkAddrSpaceIsValidForLibcall(const TargetLowering *TLI,\n                                            unsigned AS) {\n  // Lowering memcpy / memset / memmove intrinsics to calls is only valid if all\n  // pointer operands can be losslessly bitcasted to pointers of address space 0\n  if (AS != 0 && !TLI->getTargetMachine().isNoopAddrSpaceCast(AS, 0)) {\n    report_fatal_error(\"cannot lower memory intrinsic in address space \" +\n                       Twine(AS));\n  }\n}\n\nSDValue SelectionDAG::getMemcpy(SDValue Chain, const SDLoc &dl, SDValue Dst,\n                                SDValue Src, SDValue Size, Align Alignment,\n                                bool isVol, bool AlwaysInline, bool isTailCall,\n                                MachinePointerInfo DstPtrInfo,\n                                MachinePointerInfo SrcPtrInfo) {\n  // Check to see if we should lower the memcpy to loads and stores first.\n  // For cases within the target-specified limits, this is the best choice.\n  ConstantSDNode *ConstantSize = dyn_cast<ConstantSDNode>(Size);\n  if (ConstantSize) {\n    // Memcpy with size zero? Just return the original chain.\n    if (ConstantSize->isNullValue())\n      return Chain;\n\n    SDValue Result = getMemcpyLoadsAndStores(\n        *this, dl, Chain, Dst, Src, ConstantSize->getZExtValue(), Alignment,\n        isVol, false, DstPtrInfo, SrcPtrInfo);\n    if (Result.getNode())\n      return Result;\n  }\n\n  // Then check to see if we should lower the memcpy with target-specific\n  // code. If the target chooses to do this, this is the next best.\n  if (TSI) {\n    SDValue Result = TSI->EmitTargetCodeForMemcpy(\n        *this, dl, Chain, Dst, Src, Size, Alignment, isVol, AlwaysInline,\n        DstPtrInfo, SrcPtrInfo);\n    if (Result.getNode())\n      return Result;\n  }\n\n  // If we really need inline code and the target declined to provide it,\n  // use a (potentially long) sequence of loads and stores.\n  if (AlwaysInline) {\n    assert(ConstantSize && \"AlwaysInline requires a constant size!\");\n    return getMemcpyLoadsAndStores(*this, dl, Chain, Dst, Src,\n                                   ConstantSize->getZExtValue(), Alignment,\n                                   isVol, true, DstPtrInfo, SrcPtrInfo);\n  }\n\n  checkAddrSpaceIsValidForLibcall(TLI, DstPtrInfo.getAddrSpace());\n  checkAddrSpaceIsValidForLibcall(TLI, SrcPtrInfo.getAddrSpace());\n\n  // FIXME: If the memcpy is volatile (isVol), lowering it to a plain libc\n  // memcpy is not guaranteed to be safe. libc memcpys aren't required to\n  // respect volatile, so they may do things like read or write memory\n  // beyond the given memory regions. But fixing this isn't easy, and most\n  // people don't care.\n\n  // Emit a library call.\n  TargetLowering::ArgListTy Args;\n  TargetLowering::ArgListEntry Entry;\n  Entry.Ty = Type::getInt8PtrTy(*getContext());\n  Entry.Node = Dst; Args.push_back(Entry);\n  Entry.Node = Src; Args.push_back(Entry);\n\n  Entry.Ty = getDataLayout().getIntPtrType(*getContext());\n  Entry.Node = Size; Args.push_back(Entry);\n  // FIXME: pass in SDLoc\n  TargetLowering::CallLoweringInfo CLI(*this);\n  CLI.setDebugLoc(dl)\n      .setChain(Chain)\n      .setLibCallee(TLI->getLibcallCallingConv(RTLIB::MEMCPY),\n                    Dst.getValueType().getTypeForEVT(*getContext()),\n                    getExternalSymbol(TLI->getLibcallName(RTLIB::MEMCPY),\n                                      TLI->getPointerTy(getDataLayout())),\n                    std::move(Args))\n      .setDiscardResult()\n      .setTailCall(isTailCall);\n\n  std::pair<SDValue,SDValue> CallResult = TLI->LowerCallTo(CLI);\n  return CallResult.second;\n}\n\nSDValue SelectionDAG::getAtomicMemcpy(SDValue Chain, const SDLoc &dl,\n                                      SDValue Dst, unsigned DstAlign,\n                                      SDValue Src, unsigned SrcAlign,\n                                      SDValue Size, Type *SizeTy,\n                                      unsigned ElemSz, bool isTailCall,\n                                      MachinePointerInfo DstPtrInfo,\n                                      MachinePointerInfo SrcPtrInfo) {\n  // Emit a library call.\n  TargetLowering::ArgListTy Args;\n  TargetLowering::ArgListEntry Entry;\n  Entry.Ty = getDataLayout().getIntPtrType(*getContext());\n  Entry.Node = Dst;\n  Args.push_back(Entry);\n\n  Entry.Node = Src;\n  Args.push_back(Entry);\n\n  Entry.Ty = SizeTy;\n  Entry.Node = Size;\n  Args.push_back(Entry);\n\n  RTLIB::Libcall LibraryCall =\n      RTLIB::getMEMCPY_ELEMENT_UNORDERED_ATOMIC(ElemSz);\n  if (LibraryCall == RTLIB::UNKNOWN_LIBCALL)\n    report_fatal_error(\"Unsupported element size\");\n\n  TargetLowering::CallLoweringInfo CLI(*this);\n  CLI.setDebugLoc(dl)\n      .setChain(Chain)\n      .setLibCallee(TLI->getLibcallCallingConv(LibraryCall),\n                    Type::getVoidTy(*getContext()),\n                    getExternalSymbol(TLI->getLibcallName(LibraryCall),\n                                      TLI->getPointerTy(getDataLayout())),\n                    std::move(Args))\n      .setDiscardResult()\n      .setTailCall(isTailCall);\n\n  std::pair<SDValue, SDValue> CallResult = TLI->LowerCallTo(CLI);\n  return CallResult.second;\n}\n\nSDValue SelectionDAG::getMemmove(SDValue Chain, const SDLoc &dl, SDValue Dst,\n                                 SDValue Src, SDValue Size, Align Alignment,\n                                 bool isVol, bool isTailCall,\n                                 MachinePointerInfo DstPtrInfo,\n                                 MachinePointerInfo SrcPtrInfo) {\n  // Check to see if we should lower the memmove to loads and stores first.\n  // For cases within the target-specified limits, this is the best choice.\n  ConstantSDNode *ConstantSize = dyn_cast<ConstantSDNode>(Size);\n  if (ConstantSize) {\n    // Memmove with size zero? Just return the original chain.\n    if (ConstantSize->isNullValue())\n      return Chain;\n\n    SDValue Result = getMemmoveLoadsAndStores(\n        *this, dl, Chain, Dst, Src, ConstantSize->getZExtValue(), Alignment,\n        isVol, false, DstPtrInfo, SrcPtrInfo);\n    if (Result.getNode())\n      return Result;\n  }\n\n  // Then check to see if we should lower the memmove with target-specific\n  // code. If the target chooses to do this, this is the next best.\n  if (TSI) {\n    SDValue Result =\n        TSI->EmitTargetCodeForMemmove(*this, dl, Chain, Dst, Src, Size,\n                                      Alignment, isVol, DstPtrInfo, SrcPtrInfo);\n    if (Result.getNode())\n      return Result;\n  }\n\n  checkAddrSpaceIsValidForLibcall(TLI, DstPtrInfo.getAddrSpace());\n  checkAddrSpaceIsValidForLibcall(TLI, SrcPtrInfo.getAddrSpace());\n\n  // FIXME: If the memmove is volatile, lowering it to plain libc memmove may\n  // not be safe.  See memcpy above for more details.\n\n  // Emit a library call.\n  TargetLowering::ArgListTy Args;\n  TargetLowering::ArgListEntry Entry;\n  Entry.Ty = Type::getInt8PtrTy(*getContext());\n  Entry.Node = Dst; Args.push_back(Entry);\n  Entry.Node = Src; Args.push_back(Entry);\n\n  Entry.Ty = getDataLayout().getIntPtrType(*getContext());\n  Entry.Node = Size; Args.push_back(Entry);\n  // FIXME:  pass in SDLoc\n  TargetLowering::CallLoweringInfo CLI(*this);\n  CLI.setDebugLoc(dl)\n      .setChain(Chain)\n      .setLibCallee(TLI->getLibcallCallingConv(RTLIB::MEMMOVE),\n                    Dst.getValueType().getTypeForEVT(*getContext()),\n                    getExternalSymbol(TLI->getLibcallName(RTLIB::MEMMOVE),\n                                      TLI->getPointerTy(getDataLayout())),\n                    std::move(Args))\n      .setDiscardResult()\n      .setTailCall(isTailCall);\n\n  std::pair<SDValue,SDValue> CallResult = TLI->LowerCallTo(CLI);\n  return CallResult.second;\n}\n\nSDValue SelectionDAG::getAtomicMemmove(SDValue Chain, const SDLoc &dl,\n                                       SDValue Dst, unsigned DstAlign,\n                                       SDValue Src, unsigned SrcAlign,\n                                       SDValue Size, Type *SizeTy,\n                                       unsigned ElemSz, bool isTailCall,\n                                       MachinePointerInfo DstPtrInfo,\n                                       MachinePointerInfo SrcPtrInfo) {\n  // Emit a library call.\n  TargetLowering::ArgListTy Args;\n  TargetLowering::ArgListEntry Entry;\n  Entry.Ty = getDataLayout().getIntPtrType(*getContext());\n  Entry.Node = Dst;\n  Args.push_back(Entry);\n\n  Entry.Node = Src;\n  Args.push_back(Entry);\n\n  Entry.Ty = SizeTy;\n  Entry.Node = Size;\n  Args.push_back(Entry);\n\n  RTLIB::Libcall LibraryCall =\n      RTLIB::getMEMMOVE_ELEMENT_UNORDERED_ATOMIC(ElemSz);\n  if (LibraryCall == RTLIB::UNKNOWN_LIBCALL)\n    report_fatal_error(\"Unsupported element size\");\n\n  TargetLowering::CallLoweringInfo CLI(*this);\n  CLI.setDebugLoc(dl)\n      .setChain(Chain)\n      .setLibCallee(TLI->getLibcallCallingConv(LibraryCall),\n                    Type::getVoidTy(*getContext()),\n                    getExternalSymbol(TLI->getLibcallName(LibraryCall),\n                                      TLI->getPointerTy(getDataLayout())),\n                    std::move(Args))\n      .setDiscardResult()\n      .setTailCall(isTailCall);\n\n  std::pair<SDValue, SDValue> CallResult = TLI->LowerCallTo(CLI);\n  return CallResult.second;\n}\n\nSDValue SelectionDAG::getMemset(SDValue Chain, const SDLoc &dl, SDValue Dst,\n                                SDValue Src, SDValue Size, Align Alignment,\n                                bool isVol, bool isTailCall,\n                                MachinePointerInfo DstPtrInfo) {\n  // Check to see if we should lower the memset to stores first.\n  // For cases within the target-specified limits, this is the best choice.\n  ConstantSDNode *ConstantSize = dyn_cast<ConstantSDNode>(Size);\n  if (ConstantSize) {\n    // Memset with size zero? Just return the original chain.\n    if (ConstantSize->isNullValue())\n      return Chain;\n\n    SDValue Result = getMemsetStores(*this, dl, Chain, Dst, Src,\n                                     ConstantSize->getZExtValue(), Alignment,\n                                     isVol, DstPtrInfo);\n\n    if (Result.getNode())\n      return Result;\n  }\n\n  // Then check to see if we should lower the memset with target-specific\n  // code. If the target chooses to do this, this is the next best.\n  if (TSI) {\n    SDValue Result = TSI->EmitTargetCodeForMemset(\n        *this, dl, Chain, Dst, Src, Size, Alignment, isVol, DstPtrInfo);\n    if (Result.getNode())\n      return Result;\n  }\n\n  checkAddrSpaceIsValidForLibcall(TLI, DstPtrInfo.getAddrSpace());\n\n  // Emit a library call.\n  TargetLowering::ArgListTy Args;\n  TargetLowering::ArgListEntry Entry;\n  Entry.Node = Dst; Entry.Ty = Type::getInt8PtrTy(*getContext());\n  Args.push_back(Entry);\n  Entry.Node = Src;\n  Entry.Ty = Src.getValueType().getTypeForEVT(*getContext());\n  Args.push_back(Entry);\n  Entry.Node = Size;\n  Entry.Ty = getDataLayout().getIntPtrType(*getContext());\n  Args.push_back(Entry);\n\n  // FIXME: pass in SDLoc\n  TargetLowering::CallLoweringInfo CLI(*this);\n  CLI.setDebugLoc(dl)\n      .setChain(Chain)\n      .setLibCallee(TLI->getLibcallCallingConv(RTLIB::MEMSET),\n                    Dst.getValueType().getTypeForEVT(*getContext()),\n                    getExternalSymbol(TLI->getLibcallName(RTLIB::MEMSET),\n                                      TLI->getPointerTy(getDataLayout())),\n                    std::move(Args))\n      .setDiscardResult()\n      .setTailCall(isTailCall);\n\n  std::pair<SDValue,SDValue> CallResult = TLI->LowerCallTo(CLI);\n  return CallResult.second;\n}\n\nSDValue SelectionDAG::getAtomicMemset(SDValue Chain, const SDLoc &dl,\n                                      SDValue Dst, unsigned DstAlign,\n                                      SDValue Value, SDValue Size, Type *SizeTy,\n                                      unsigned ElemSz, bool isTailCall,\n                                      MachinePointerInfo DstPtrInfo) {\n  // Emit a library call.\n  TargetLowering::ArgListTy Args;\n  TargetLowering::ArgListEntry Entry;\n  Entry.Ty = getDataLayout().getIntPtrType(*getContext());\n  Entry.Node = Dst;\n  Args.push_back(Entry);\n\n  Entry.Ty = Type::getInt8Ty(*getContext());\n  Entry.Node = Value;\n  Args.push_back(Entry);\n\n  Entry.Ty = SizeTy;\n  Entry.Node = Size;\n  Args.push_back(Entry);\n\n  RTLIB::Libcall LibraryCall =\n      RTLIB::getMEMSET_ELEMENT_UNORDERED_ATOMIC(ElemSz);\n  if (LibraryCall == RTLIB::UNKNOWN_LIBCALL)\n    report_fatal_error(\"Unsupported element size\");\n\n  TargetLowering::CallLoweringInfo CLI(*this);\n  CLI.setDebugLoc(dl)\n      .setChain(Chain)\n      .setLibCallee(TLI->getLibcallCallingConv(LibraryCall),\n                    Type::getVoidTy(*getContext()),\n                    getExternalSymbol(TLI->getLibcallName(LibraryCall),\n                                      TLI->getPointerTy(getDataLayout())),\n                    std::move(Args))\n      .setDiscardResult()\n      .setTailCall(isTailCall);\n\n  std::pair<SDValue, SDValue> CallResult = TLI->LowerCallTo(CLI);\n  return CallResult.second;\n}\n\nSDValue SelectionDAG::getAtomic(unsigned Opcode, const SDLoc &dl, EVT MemVT,\n                                SDVTList VTList, ArrayRef<SDValue> Ops,\n                                MachineMemOperand *MMO) {\n  FoldingSetNodeID ID;\n  ID.AddInteger(MemVT.getRawBits());\n  AddNodeIDNode(ID, Opcode, VTList, Ops);\n  ID.AddInteger(MMO->getPointerInfo().getAddrSpace());\n  void* IP = nullptr;\n  if (SDNode *E = FindNodeOrInsertPos(ID, dl, IP)) {\n    cast<AtomicSDNode>(E)->refineAlignment(MMO);\n    return SDValue(E, 0);\n  }\n\n  auto *N = newSDNode<AtomicSDNode>(Opcode, dl.getIROrder(), dl.getDebugLoc(),\n                                    VTList, MemVT, MMO);\n  createOperands(N, Ops);\n\n  CSEMap.InsertNode(N, IP);\n  InsertNode(N);\n  return SDValue(N, 0);\n}\n\nSDValue SelectionDAG::getAtomicCmpSwap(unsigned Opcode, const SDLoc &dl,\n                                       EVT MemVT, SDVTList VTs, SDValue Chain,\n                                       SDValue Ptr, SDValue Cmp, SDValue Swp,\n                                       MachineMemOperand *MMO) {\n  assert(Opcode == ISD::ATOMIC_CMP_SWAP ||\n         Opcode == ISD::ATOMIC_CMP_SWAP_WITH_SUCCESS);\n  assert(Cmp.getValueType() == Swp.getValueType() && \"Invalid Atomic Op Types\");\n\n  SDValue Ops[] = {Chain, Ptr, Cmp, Swp};\n  return getAtomic(Opcode, dl, MemVT, VTs, Ops, MMO);\n}\n\nSDValue SelectionDAG::getAtomic(unsigned Opcode, const SDLoc &dl, EVT MemVT,\n                                SDValue Chain, SDValue Ptr, SDValue Val,\n                                MachineMemOperand *MMO) {\n  assert((Opcode == ISD::ATOMIC_LOAD_ADD ||\n          Opcode == ISD::ATOMIC_LOAD_SUB ||\n          Opcode == ISD::ATOMIC_LOAD_AND ||\n          Opcode == ISD::ATOMIC_LOAD_CLR ||\n          Opcode == ISD::ATOMIC_LOAD_OR ||\n          Opcode == ISD::ATOMIC_LOAD_XOR ||\n          Opcode == ISD::ATOMIC_LOAD_NAND ||\n          Opcode == ISD::ATOMIC_LOAD_MIN ||\n          Opcode == ISD::ATOMIC_LOAD_MAX ||\n          Opcode == ISD::ATOMIC_LOAD_UMIN ||\n          Opcode == ISD::ATOMIC_LOAD_UMAX ||\n          Opcode == ISD::ATOMIC_LOAD_FADD ||\n          Opcode == ISD::ATOMIC_LOAD_FSUB ||\n          Opcode == ISD::ATOMIC_SWAP ||\n          Opcode == ISD::ATOMIC_STORE) &&\n         \"Invalid Atomic Op\");\n\n  EVT VT = Val.getValueType();\n\n  SDVTList VTs = Opcode == ISD::ATOMIC_STORE ? getVTList(MVT::Other) :\n                                               getVTList(VT, MVT::Other);\n  SDValue Ops[] = {Chain, Ptr, Val};\n  return getAtomic(Opcode, dl, MemVT, VTs, Ops, MMO);\n}\n\nSDValue SelectionDAG::getAtomic(unsigned Opcode, const SDLoc &dl, EVT MemVT,\n                                EVT VT, SDValue Chain, SDValue Ptr,\n                                MachineMemOperand *MMO) {\n  assert(Opcode == ISD::ATOMIC_LOAD && \"Invalid Atomic Op\");\n\n  SDVTList VTs = getVTList(VT, MVT::Other);\n  SDValue Ops[] = {Chain, Ptr};\n  return getAtomic(Opcode, dl, MemVT, VTs, Ops, MMO);\n}\n\n/// getMergeValues - Create a MERGE_VALUES node from the given operands.\nSDValue SelectionDAG::getMergeValues(ArrayRef<SDValue> Ops, const SDLoc &dl) {\n  if (Ops.size() == 1)\n    return Ops[0];\n\n  SmallVector<EVT, 4> VTs;\n  VTs.reserve(Ops.size());\n  for (const SDValue &Op : Ops)\n    VTs.push_back(Op.getValueType());\n  return getNode(ISD::MERGE_VALUES, dl, getVTList(VTs), Ops);\n}\n\nSDValue SelectionDAG::getMemIntrinsicNode(\n    unsigned Opcode, const SDLoc &dl, SDVTList VTList, ArrayRef<SDValue> Ops,\n    EVT MemVT, MachinePointerInfo PtrInfo, Align Alignment,\n    MachineMemOperand::Flags Flags, uint64_t Size, const AAMDNodes &AAInfo) {\n  if (!Size && MemVT.isScalableVector())\n    Size = MemoryLocation::UnknownSize;\n  else if (!Size)\n    Size = MemVT.getStoreSize();\n\n  MachineFunction &MF = getMachineFunction();\n  MachineMemOperand *MMO =\n      MF.getMachineMemOperand(PtrInfo, Flags, Size, Alignment, AAInfo);\n\n  return getMemIntrinsicNode(Opcode, dl, VTList, Ops, MemVT, MMO);\n}\n\nSDValue SelectionDAG::getMemIntrinsicNode(unsigned Opcode, const SDLoc &dl,\n                                          SDVTList VTList,\n                                          ArrayRef<SDValue> Ops, EVT MemVT,\n                                          MachineMemOperand *MMO) {\n  assert((Opcode == ISD::INTRINSIC_VOID ||\n          Opcode == ISD::INTRINSIC_W_CHAIN ||\n          Opcode == ISD::PREFETCH ||\n          ((int)Opcode <= std::numeric_limits<int>::max() &&\n           (int)Opcode >= ISD::FIRST_TARGET_MEMORY_OPCODE)) &&\n         \"Opcode is not a memory-accessing opcode!\");\n\n  // Memoize the node unless it returns a flag.\n  MemIntrinsicSDNode *N;\n  if (VTList.VTs[VTList.NumVTs-1] != MVT::Glue) {\n    FoldingSetNodeID ID;\n    AddNodeIDNode(ID, Opcode, VTList, Ops);\n    ID.AddInteger(getSyntheticNodeSubclassData<MemIntrinsicSDNode>(\n        Opcode, dl.getIROrder(), VTList, MemVT, MMO));\n    ID.AddInteger(MMO->getPointerInfo().getAddrSpace());\n    void *IP = nullptr;\n    if (SDNode *E = FindNodeOrInsertPos(ID, dl, IP)) {\n      cast<MemIntrinsicSDNode>(E)->refineAlignment(MMO);\n      return SDValue(E, 0);\n    }\n\n    N = newSDNode<MemIntrinsicSDNode>(Opcode, dl.getIROrder(), dl.getDebugLoc(),\n                                      VTList, MemVT, MMO);\n    createOperands(N, Ops);\n\n  CSEMap.InsertNode(N, IP);\n  } else {\n    N = newSDNode<MemIntrinsicSDNode>(Opcode, dl.getIROrder(), dl.getDebugLoc(),\n                                      VTList, MemVT, MMO);\n    createOperands(N, Ops);\n  }\n  InsertNode(N);\n  SDValue V(N, 0);\n  NewSDValueDbgMsg(V, \"Creating new node: \", this);\n  return V;\n}\n\nSDValue SelectionDAG::getLifetimeNode(bool IsStart, const SDLoc &dl,\n                                      SDValue Chain, int FrameIndex,\n                                      int64_t Size, int64_t Offset) {\n  const unsigned Opcode = IsStart ? ISD::LIFETIME_START : ISD::LIFETIME_END;\n  const auto VTs = getVTList(MVT::Other);\n  SDValue Ops[2] = {\n      Chain,\n      getFrameIndex(FrameIndex,\n                    getTargetLoweringInfo().getFrameIndexTy(getDataLayout()),\n                    true)};\n\n  FoldingSetNodeID ID;\n  AddNodeIDNode(ID, Opcode, VTs, Ops);\n  ID.AddInteger(FrameIndex);\n  ID.AddInteger(Size);\n  ID.AddInteger(Offset);\n  void *IP = nullptr;\n  if (SDNode *E = FindNodeOrInsertPos(ID, dl, IP))\n    return SDValue(E, 0);\n\n  LifetimeSDNode *N = newSDNode<LifetimeSDNode>(\n      Opcode, dl.getIROrder(), dl.getDebugLoc(), VTs, Size, Offset);\n  createOperands(N, Ops);\n  CSEMap.InsertNode(N, IP);\n  InsertNode(N);\n  SDValue V(N, 0);\n  NewSDValueDbgMsg(V, \"Creating new node: \", this);\n  return V;\n}\n\nSDValue SelectionDAG::getPseudoProbeNode(const SDLoc &Dl, SDValue Chain,\n                                         uint64_t Guid, uint64_t Index,\n                                         uint32_t Attr) {\n  const unsigned Opcode = ISD::PSEUDO_PROBE;\n  const auto VTs = getVTList(MVT::Other);\n  SDValue Ops[] = {Chain};\n  FoldingSetNodeID ID;\n  AddNodeIDNode(ID, Opcode, VTs, Ops);\n  ID.AddInteger(Guid);\n  ID.AddInteger(Index);\n  void *IP = nullptr;\n  if (SDNode *E = FindNodeOrInsertPos(ID, Dl, IP))\n    return SDValue(E, 0);\n\n  auto *N = newSDNode<PseudoProbeSDNode>(\n      Opcode, Dl.getIROrder(), Dl.getDebugLoc(), VTs, Guid, Index, Attr);\n  createOperands(N, Ops);\n  CSEMap.InsertNode(N, IP);\n  InsertNode(N);\n  SDValue V(N, 0);\n  NewSDValueDbgMsg(V, \"Creating new node: \", this);\n  return V;\n}\n\n/// InferPointerInfo - If the specified ptr/offset is a frame index, infer a\n/// MachinePointerInfo record from it.  This is particularly useful because the\n/// code generator has many cases where it doesn't bother passing in a\n/// MachinePointerInfo to getLoad or getStore when it has \"FI+Cst\".\nstatic MachinePointerInfo InferPointerInfo(const MachinePointerInfo &Info,\n                                           SelectionDAG &DAG, SDValue Ptr,\n                                           int64_t Offset = 0) {\n  // If this is FI+Offset, we can model it.\n  if (const FrameIndexSDNode *FI = dyn_cast<FrameIndexSDNode>(Ptr))\n    return MachinePointerInfo::getFixedStack(DAG.getMachineFunction(),\n                                             FI->getIndex(), Offset);\n\n  // If this is (FI+Offset1)+Offset2, we can model it.\n  if (Ptr.getOpcode() != ISD::ADD ||\n      !isa<ConstantSDNode>(Ptr.getOperand(1)) ||\n      !isa<FrameIndexSDNode>(Ptr.getOperand(0)))\n    return Info;\n\n  int FI = cast<FrameIndexSDNode>(Ptr.getOperand(0))->getIndex();\n  return MachinePointerInfo::getFixedStack(\n      DAG.getMachineFunction(), FI,\n      Offset + cast<ConstantSDNode>(Ptr.getOperand(1))->getSExtValue());\n}\n\n/// InferPointerInfo - If the specified ptr/offset is a frame index, infer a\n/// MachinePointerInfo record from it.  This is particularly useful because the\n/// code generator has many cases where it doesn't bother passing in a\n/// MachinePointerInfo to getLoad or getStore when it has \"FI+Cst\".\nstatic MachinePointerInfo InferPointerInfo(const MachinePointerInfo &Info,\n                                           SelectionDAG &DAG, SDValue Ptr,\n                                           SDValue OffsetOp) {\n  // If the 'Offset' value isn't a constant, we can't handle this.\n  if (ConstantSDNode *OffsetNode = dyn_cast<ConstantSDNode>(OffsetOp))\n    return InferPointerInfo(Info, DAG, Ptr, OffsetNode->getSExtValue());\n  if (OffsetOp.isUndef())\n    return InferPointerInfo(Info, DAG, Ptr);\n  return Info;\n}\n\nSDValue SelectionDAG::getLoad(ISD::MemIndexedMode AM, ISD::LoadExtType ExtType,\n                              EVT VT, const SDLoc &dl, SDValue Chain,\n                              SDValue Ptr, SDValue Offset,\n                              MachinePointerInfo PtrInfo, EVT MemVT,\n                              Align Alignment,\n                              MachineMemOperand::Flags MMOFlags,\n                              const AAMDNodes &AAInfo, const MDNode *Ranges) {\n  assert(Chain.getValueType() == MVT::Other &&\n        \"Invalid chain type\");\n\n  MMOFlags |= MachineMemOperand::MOLoad;\n  assert((MMOFlags & MachineMemOperand::MOStore) == 0);\n  // If we don't have a PtrInfo, infer the trivial frame index case to simplify\n  // clients.\n  if (PtrInfo.V.isNull())\n    PtrInfo = InferPointerInfo(PtrInfo, *this, Ptr, Offset);\n\n  uint64_t Size = MemoryLocation::getSizeOrUnknown(MemVT.getStoreSize());\n  MachineFunction &MF = getMachineFunction();\n  MachineMemOperand *MMO = MF.getMachineMemOperand(PtrInfo, MMOFlags, Size,\n                                                   Alignment, AAInfo, Ranges);\n  return getLoad(AM, ExtType, VT, dl, Chain, Ptr, Offset, MemVT, MMO);\n}\n\nSDValue SelectionDAG::getLoad(ISD::MemIndexedMode AM, ISD::LoadExtType ExtType,\n                              EVT VT, const SDLoc &dl, SDValue Chain,\n                              SDValue Ptr, SDValue Offset, EVT MemVT,\n                              MachineMemOperand *MMO) {\n  if (VT == MemVT) {\n    ExtType = ISD::NON_EXTLOAD;\n  } else if (ExtType == ISD::NON_EXTLOAD) {\n    assert(VT == MemVT && \"Non-extending load from different memory type!\");\n  } else {\n    // Extending load.\n    assert(MemVT.getScalarType().bitsLT(VT.getScalarType()) &&\n           \"Should only be an extending load, not truncating!\");\n    assert(VT.isInteger() == MemVT.isInteger() &&\n           \"Cannot convert from FP to Int or Int -> FP!\");\n    assert(VT.isVector() == MemVT.isVector() &&\n           \"Cannot use an ext load to convert to or from a vector!\");\n    assert((!VT.isVector() ||\n            VT.getVectorElementCount() == MemVT.getVectorElementCount()) &&\n           \"Cannot use an ext load to change the number of vector elements!\");\n  }\n\n  bool Indexed = AM != ISD::UNINDEXED;\n  assert((Indexed || Offset.isUndef()) && \"Unindexed load with an offset!\");\n\n  SDVTList VTs = Indexed ?\n    getVTList(VT, Ptr.getValueType(), MVT::Other) : getVTList(VT, MVT::Other);\n  SDValue Ops[] = { Chain, Ptr, Offset };\n  FoldingSetNodeID ID;\n  AddNodeIDNode(ID, ISD::LOAD, VTs, Ops);\n  ID.AddInteger(MemVT.getRawBits());\n  ID.AddInteger(getSyntheticNodeSubclassData<LoadSDNode>(\n      dl.getIROrder(), VTs, AM, ExtType, MemVT, MMO));\n  ID.AddInteger(MMO->getPointerInfo().getAddrSpace());\n  void *IP = nullptr;\n  if (SDNode *E = FindNodeOrInsertPos(ID, dl, IP)) {\n    cast<LoadSDNode>(E)->refineAlignment(MMO);\n    return SDValue(E, 0);\n  }\n  auto *N = newSDNode<LoadSDNode>(dl.getIROrder(), dl.getDebugLoc(), VTs, AM,\n                                  ExtType, MemVT, MMO);\n  createOperands(N, Ops);\n\n  CSEMap.InsertNode(N, IP);\n  InsertNode(N);\n  SDValue V(N, 0);\n  NewSDValueDbgMsg(V, \"Creating new node: \", this);\n  return V;\n}\n\nSDValue SelectionDAG::getLoad(EVT VT, const SDLoc &dl, SDValue Chain,\n                              SDValue Ptr, MachinePointerInfo PtrInfo,\n                              MaybeAlign Alignment,\n                              MachineMemOperand::Flags MMOFlags,\n                              const AAMDNodes &AAInfo, const MDNode *Ranges) {\n  SDValue Undef = getUNDEF(Ptr.getValueType());\n  return getLoad(ISD::UNINDEXED, ISD::NON_EXTLOAD, VT, dl, Chain, Ptr, Undef,\n                 PtrInfo, VT, Alignment, MMOFlags, AAInfo, Ranges);\n}\n\nSDValue SelectionDAG::getLoad(EVT VT, const SDLoc &dl, SDValue Chain,\n                              SDValue Ptr, MachineMemOperand *MMO) {\n  SDValue Undef = getUNDEF(Ptr.getValueType());\n  return getLoad(ISD::UNINDEXED, ISD::NON_EXTLOAD, VT, dl, Chain, Ptr, Undef,\n                 VT, MMO);\n}\n\nSDValue SelectionDAG::getExtLoad(ISD::LoadExtType ExtType, const SDLoc &dl,\n                                 EVT VT, SDValue Chain, SDValue Ptr,\n                                 MachinePointerInfo PtrInfo, EVT MemVT,\n                                 MaybeAlign Alignment,\n                                 MachineMemOperand::Flags MMOFlags,\n                                 const AAMDNodes &AAInfo) {\n  SDValue Undef = getUNDEF(Ptr.getValueType());\n  return getLoad(ISD::UNINDEXED, ExtType, VT, dl, Chain, Ptr, Undef, PtrInfo,\n                 MemVT, Alignment, MMOFlags, AAInfo);\n}\n\nSDValue SelectionDAG::getExtLoad(ISD::LoadExtType ExtType, const SDLoc &dl,\n                                 EVT VT, SDValue Chain, SDValue Ptr, EVT MemVT,\n                                 MachineMemOperand *MMO) {\n  SDValue Undef = getUNDEF(Ptr.getValueType());\n  return getLoad(ISD::UNINDEXED, ExtType, VT, dl, Chain, Ptr, Undef,\n                 MemVT, MMO);\n}\n\nSDValue SelectionDAG::getIndexedLoad(SDValue OrigLoad, const SDLoc &dl,\n                                     SDValue Base, SDValue Offset,\n                                     ISD::MemIndexedMode AM) {\n  LoadSDNode *LD = cast<LoadSDNode>(OrigLoad);\n  assert(LD->getOffset().isUndef() && \"Load is already a indexed load!\");\n  // Don't propagate the invariant or dereferenceable flags.\n  auto MMOFlags =\n      LD->getMemOperand()->getFlags() &\n      ~(MachineMemOperand::MOInvariant | MachineMemOperand::MODereferenceable);\n  return getLoad(AM, LD->getExtensionType(), OrigLoad.getValueType(), dl,\n                 LD->getChain(), Base, Offset, LD->getPointerInfo(),\n                 LD->getMemoryVT(), LD->getAlign(), MMOFlags, LD->getAAInfo());\n}\n\nSDValue SelectionDAG::getStore(SDValue Chain, const SDLoc &dl, SDValue Val,\n                               SDValue Ptr, MachinePointerInfo PtrInfo,\n                               Align Alignment,\n                               MachineMemOperand::Flags MMOFlags,\n                               const AAMDNodes &AAInfo) {\n  assert(Chain.getValueType() == MVT::Other && \"Invalid chain type\");\n\n  MMOFlags |= MachineMemOperand::MOStore;\n  assert((MMOFlags & MachineMemOperand::MOLoad) == 0);\n\n  if (PtrInfo.V.isNull())\n    PtrInfo = InferPointerInfo(PtrInfo, *this, Ptr);\n\n  MachineFunction &MF = getMachineFunction();\n  uint64_t Size =\n      MemoryLocation::getSizeOrUnknown(Val.getValueType().getStoreSize());\n  MachineMemOperand *MMO =\n      MF.getMachineMemOperand(PtrInfo, MMOFlags, Size, Alignment, AAInfo);\n  return getStore(Chain, dl, Val, Ptr, MMO);\n}\n\nSDValue SelectionDAG::getStore(SDValue Chain, const SDLoc &dl, SDValue Val,\n                               SDValue Ptr, MachineMemOperand *MMO) {\n  assert(Chain.getValueType() == MVT::Other &&\n        \"Invalid chain type\");\n  EVT VT = Val.getValueType();\n  SDVTList VTs = getVTList(MVT::Other);\n  SDValue Undef = getUNDEF(Ptr.getValueType());\n  SDValue Ops[] = { Chain, Val, Ptr, Undef };\n  FoldingSetNodeID ID;\n  AddNodeIDNode(ID, ISD::STORE, VTs, Ops);\n  ID.AddInteger(VT.getRawBits());\n  ID.AddInteger(getSyntheticNodeSubclassData<StoreSDNode>(\n      dl.getIROrder(), VTs, ISD::UNINDEXED, false, VT, MMO));\n  ID.AddInteger(MMO->getPointerInfo().getAddrSpace());\n  void *IP = nullptr;\n  if (SDNode *E = FindNodeOrInsertPos(ID, dl, IP)) {\n    cast<StoreSDNode>(E)->refineAlignment(MMO);\n    return SDValue(E, 0);\n  }\n  auto *N = newSDNode<StoreSDNode>(dl.getIROrder(), dl.getDebugLoc(), VTs,\n                                   ISD::UNINDEXED, false, VT, MMO);\n  createOperands(N, Ops);\n\n  CSEMap.InsertNode(N, IP);\n  InsertNode(N);\n  SDValue V(N, 0);\n  NewSDValueDbgMsg(V, \"Creating new node: \", this);\n  return V;\n}\n\nSDValue SelectionDAG::getTruncStore(SDValue Chain, const SDLoc &dl, SDValue Val,\n                                    SDValue Ptr, MachinePointerInfo PtrInfo,\n                                    EVT SVT, Align Alignment,\n                                    MachineMemOperand::Flags MMOFlags,\n                                    const AAMDNodes &AAInfo) {\n  assert(Chain.getValueType() == MVT::Other &&\n        \"Invalid chain type\");\n\n  MMOFlags |= MachineMemOperand::MOStore;\n  assert((MMOFlags & MachineMemOperand::MOLoad) == 0);\n\n  if (PtrInfo.V.isNull())\n    PtrInfo = InferPointerInfo(PtrInfo, *this, Ptr);\n\n  MachineFunction &MF = getMachineFunction();\n  MachineMemOperand *MMO = MF.getMachineMemOperand(\n      PtrInfo, MMOFlags, MemoryLocation::getSizeOrUnknown(SVT.getStoreSize()),\n      Alignment, AAInfo);\n  return getTruncStore(Chain, dl, Val, Ptr, SVT, MMO);\n}\n\nSDValue SelectionDAG::getTruncStore(SDValue Chain, const SDLoc &dl, SDValue Val,\n                                    SDValue Ptr, EVT SVT,\n                                    MachineMemOperand *MMO) {\n  EVT VT = Val.getValueType();\n\n  assert(Chain.getValueType() == MVT::Other &&\n        \"Invalid chain type\");\n  if (VT == SVT)\n    return getStore(Chain, dl, Val, Ptr, MMO);\n\n  assert(SVT.getScalarType().bitsLT(VT.getScalarType()) &&\n         \"Should only be a truncating store, not extending!\");\n  assert(VT.isInteger() == SVT.isInteger() &&\n         \"Can't do FP-INT conversion!\");\n  assert(VT.isVector() == SVT.isVector() &&\n         \"Cannot use trunc store to convert to or from a vector!\");\n  assert((!VT.isVector() ||\n          VT.getVectorElementCount() == SVT.getVectorElementCount()) &&\n         \"Cannot use trunc store to change the number of vector elements!\");\n\n  SDVTList VTs = getVTList(MVT::Other);\n  SDValue Undef = getUNDEF(Ptr.getValueType());\n  SDValue Ops[] = { Chain, Val, Ptr, Undef };\n  FoldingSetNodeID ID;\n  AddNodeIDNode(ID, ISD::STORE, VTs, Ops);\n  ID.AddInteger(SVT.getRawBits());\n  ID.AddInteger(getSyntheticNodeSubclassData<StoreSDNode>(\n      dl.getIROrder(), VTs, ISD::UNINDEXED, true, SVT, MMO));\n  ID.AddInteger(MMO->getPointerInfo().getAddrSpace());\n  void *IP = nullptr;\n  if (SDNode *E = FindNodeOrInsertPos(ID, dl, IP)) {\n    cast<StoreSDNode>(E)->refineAlignment(MMO);\n    return SDValue(E, 0);\n  }\n  auto *N = newSDNode<StoreSDNode>(dl.getIROrder(), dl.getDebugLoc(), VTs,\n                                   ISD::UNINDEXED, true, SVT, MMO);\n  createOperands(N, Ops);\n\n  CSEMap.InsertNode(N, IP);\n  InsertNode(N);\n  SDValue V(N, 0);\n  NewSDValueDbgMsg(V, \"Creating new node: \", this);\n  return V;\n}\n\nSDValue SelectionDAG::getIndexedStore(SDValue OrigStore, const SDLoc &dl,\n                                      SDValue Base, SDValue Offset,\n                                      ISD::MemIndexedMode AM) {\n  StoreSDNode *ST = cast<StoreSDNode>(OrigStore);\n  assert(ST->getOffset().isUndef() && \"Store is already a indexed store!\");\n  SDVTList VTs = getVTList(Base.getValueType(), MVT::Other);\n  SDValue Ops[] = { ST->getChain(), ST->getValue(), Base, Offset };\n  FoldingSetNodeID ID;\n  AddNodeIDNode(ID, ISD::STORE, VTs, Ops);\n  ID.AddInteger(ST->getMemoryVT().getRawBits());\n  ID.AddInteger(ST->getRawSubclassData());\n  ID.AddInteger(ST->getPointerInfo().getAddrSpace());\n  void *IP = nullptr;\n  if (SDNode *E = FindNodeOrInsertPos(ID, dl, IP))\n    return SDValue(E, 0);\n\n  auto *N = newSDNode<StoreSDNode>(dl.getIROrder(), dl.getDebugLoc(), VTs, AM,\n                                   ST->isTruncatingStore(), ST->getMemoryVT(),\n                                   ST->getMemOperand());\n  createOperands(N, Ops);\n\n  CSEMap.InsertNode(N, IP);\n  InsertNode(N);\n  SDValue V(N, 0);\n  NewSDValueDbgMsg(V, \"Creating new node: \", this);\n  return V;\n}\n\nSDValue SelectionDAG::getMaskedLoad(EVT VT, const SDLoc &dl, SDValue Chain,\n                                    SDValue Base, SDValue Offset, SDValue Mask,\n                                    SDValue PassThru, EVT MemVT,\n                                    MachineMemOperand *MMO,\n                                    ISD::MemIndexedMode AM,\n                                    ISD::LoadExtType ExtTy, bool isExpanding) {\n  bool Indexed = AM != ISD::UNINDEXED;\n  assert((Indexed || Offset.isUndef()) &&\n         \"Unindexed masked load with an offset!\");\n  SDVTList VTs = Indexed ? getVTList(VT, Base.getValueType(), MVT::Other)\n                         : getVTList(VT, MVT::Other);\n  SDValue Ops[] = {Chain, Base, Offset, Mask, PassThru};\n  FoldingSetNodeID ID;\n  AddNodeIDNode(ID, ISD::MLOAD, VTs, Ops);\n  ID.AddInteger(MemVT.getRawBits());\n  ID.AddInteger(getSyntheticNodeSubclassData<MaskedLoadSDNode>(\n      dl.getIROrder(), VTs, AM, ExtTy, isExpanding, MemVT, MMO));\n  ID.AddInteger(MMO->getPointerInfo().getAddrSpace());\n  void *IP = nullptr;\n  if (SDNode *E = FindNodeOrInsertPos(ID, dl, IP)) {\n    cast<MaskedLoadSDNode>(E)->refineAlignment(MMO);\n    return SDValue(E, 0);\n  }\n  auto *N = newSDNode<MaskedLoadSDNode>(dl.getIROrder(), dl.getDebugLoc(), VTs,\n                                        AM, ExtTy, isExpanding, MemVT, MMO);\n  createOperands(N, Ops);\n\n  CSEMap.InsertNode(N, IP);\n  InsertNode(N);\n  SDValue V(N, 0);\n  NewSDValueDbgMsg(V, \"Creating new node: \", this);\n  return V;\n}\n\nSDValue SelectionDAG::getIndexedMaskedLoad(SDValue OrigLoad, const SDLoc &dl,\n                                           SDValue Base, SDValue Offset,\n                                           ISD::MemIndexedMode AM) {\n  MaskedLoadSDNode *LD = cast<MaskedLoadSDNode>(OrigLoad);\n  assert(LD->getOffset().isUndef() && \"Masked load is already a indexed load!\");\n  return getMaskedLoad(OrigLoad.getValueType(), dl, LD->getChain(), Base,\n                       Offset, LD->getMask(), LD->getPassThru(),\n                       LD->getMemoryVT(), LD->getMemOperand(), AM,\n                       LD->getExtensionType(), LD->isExpandingLoad());\n}\n\nSDValue SelectionDAG::getMaskedStore(SDValue Chain, const SDLoc &dl,\n                                     SDValue Val, SDValue Base, SDValue Offset,\n                                     SDValue Mask, EVT MemVT,\n                                     MachineMemOperand *MMO,\n                                     ISD::MemIndexedMode AM, bool IsTruncating,\n                                     bool IsCompressing) {\n  assert(Chain.getValueType() == MVT::Other &&\n        \"Invalid chain type\");\n  bool Indexed = AM != ISD::UNINDEXED;\n  assert((Indexed || Offset.isUndef()) &&\n         \"Unindexed masked store with an offset!\");\n  SDVTList VTs = Indexed ? getVTList(Base.getValueType(), MVT::Other)\n                         : getVTList(MVT::Other);\n  SDValue Ops[] = {Chain, Val, Base, Offset, Mask};\n  FoldingSetNodeID ID;\n  AddNodeIDNode(ID, ISD::MSTORE, VTs, Ops);\n  ID.AddInteger(MemVT.getRawBits());\n  ID.AddInteger(getSyntheticNodeSubclassData<MaskedStoreSDNode>(\n      dl.getIROrder(), VTs, AM, IsTruncating, IsCompressing, MemVT, MMO));\n  ID.AddInteger(MMO->getPointerInfo().getAddrSpace());\n  void *IP = nullptr;\n  if (SDNode *E = FindNodeOrInsertPos(ID, dl, IP)) {\n    cast<MaskedStoreSDNode>(E)->refineAlignment(MMO);\n    return SDValue(E, 0);\n  }\n  auto *N =\n      newSDNode<MaskedStoreSDNode>(dl.getIROrder(), dl.getDebugLoc(), VTs, AM,\n                                   IsTruncating, IsCompressing, MemVT, MMO);\n  createOperands(N, Ops);\n\n  CSEMap.InsertNode(N, IP);\n  InsertNode(N);\n  SDValue V(N, 0);\n  NewSDValueDbgMsg(V, \"Creating new node: \", this);\n  return V;\n}\n\nSDValue SelectionDAG::getIndexedMaskedStore(SDValue OrigStore, const SDLoc &dl,\n                                            SDValue Base, SDValue Offset,\n                                            ISD::MemIndexedMode AM) {\n  MaskedStoreSDNode *ST = cast<MaskedStoreSDNode>(OrigStore);\n  assert(ST->getOffset().isUndef() &&\n         \"Masked store is already a indexed store!\");\n  return getMaskedStore(ST->getChain(), dl, ST->getValue(), Base, Offset,\n                        ST->getMask(), ST->getMemoryVT(), ST->getMemOperand(),\n                        AM, ST->isTruncatingStore(), ST->isCompressingStore());\n}\n\nSDValue SelectionDAG::getMaskedGather(SDVTList VTs, EVT VT, const SDLoc &dl,\n                                      ArrayRef<SDValue> Ops,\n                                      MachineMemOperand *MMO,\n                                      ISD::MemIndexType IndexType,\n                                      ISD::LoadExtType ExtTy) {\n  assert(Ops.size() == 6 && \"Incompatible number of operands\");\n\n  FoldingSetNodeID ID;\n  AddNodeIDNode(ID, ISD::MGATHER, VTs, Ops);\n  ID.AddInteger(VT.getRawBits());\n  ID.AddInteger(getSyntheticNodeSubclassData<MaskedGatherSDNode>(\n      dl.getIROrder(), VTs, VT, MMO, IndexType, ExtTy));\n  ID.AddInteger(MMO->getPointerInfo().getAddrSpace());\n  void *IP = nullptr;\n  if (SDNode *E = FindNodeOrInsertPos(ID, dl, IP)) {\n    cast<MaskedGatherSDNode>(E)->refineAlignment(MMO);\n    return SDValue(E, 0);\n  }\n\n  IndexType = TLI->getCanonicalIndexType(IndexType, VT, Ops[4]);\n  auto *N = newSDNode<MaskedGatherSDNode>(dl.getIROrder(), dl.getDebugLoc(),\n                                          VTs, VT, MMO, IndexType, ExtTy);\n  createOperands(N, Ops);\n\n  assert(N->getPassThru().getValueType() == N->getValueType(0) &&\n         \"Incompatible type of the PassThru value in MaskedGatherSDNode\");\n  assert(N->getMask().getValueType().getVectorElementCount() ==\n             N->getValueType(0).getVectorElementCount() &&\n         \"Vector width mismatch between mask and data\");\n  assert(N->getIndex().getValueType().getVectorElementCount().isScalable() ==\n             N->getValueType(0).getVectorElementCount().isScalable() &&\n         \"Scalable flags of index and data do not match\");\n  assert(ElementCount::isKnownGE(\n             N->getIndex().getValueType().getVectorElementCount(),\n             N->getValueType(0).getVectorElementCount()) &&\n         \"Vector width mismatch between index and data\");\n  assert(isa<ConstantSDNode>(N->getScale()) &&\n         cast<ConstantSDNode>(N->getScale())->getAPIntValue().isPowerOf2() &&\n         \"Scale should be a constant power of 2\");\n\n  CSEMap.InsertNode(N, IP);\n  InsertNode(N);\n  SDValue V(N, 0);\n  NewSDValueDbgMsg(V, \"Creating new node: \", this);\n  return V;\n}\n\nSDValue SelectionDAG::getMaskedScatter(SDVTList VTs, EVT VT, const SDLoc &dl,\n                                       ArrayRef<SDValue> Ops,\n                                       MachineMemOperand *MMO,\n                                       ISD::MemIndexType IndexType,\n                                       bool IsTrunc) {\n  assert(Ops.size() == 6 && \"Incompatible number of operands\");\n\n  FoldingSetNodeID ID;\n  AddNodeIDNode(ID, ISD::MSCATTER, VTs, Ops);\n  ID.AddInteger(VT.getRawBits());\n  ID.AddInteger(getSyntheticNodeSubclassData<MaskedScatterSDNode>(\n      dl.getIROrder(), VTs, VT, MMO, IndexType, IsTrunc));\n  ID.AddInteger(MMO->getPointerInfo().getAddrSpace());\n  void *IP = nullptr;\n  if (SDNode *E = FindNodeOrInsertPos(ID, dl, IP)) {\n    cast<MaskedScatterSDNode>(E)->refineAlignment(MMO);\n    return SDValue(E, 0);\n  }\n\n  IndexType = TLI->getCanonicalIndexType(IndexType, VT, Ops[4]);\n  auto *N = newSDNode<MaskedScatterSDNode>(dl.getIROrder(), dl.getDebugLoc(),\n                                           VTs, VT, MMO, IndexType, IsTrunc);\n  createOperands(N, Ops);\n\n  assert(N->getMask().getValueType().getVectorElementCount() ==\n             N->getValue().getValueType().getVectorElementCount() &&\n         \"Vector width mismatch between mask and data\");\n  assert(\n      N->getIndex().getValueType().getVectorElementCount().isScalable() ==\n          N->getValue().getValueType().getVectorElementCount().isScalable() &&\n      \"Scalable flags of index and data do not match\");\n  assert(ElementCount::isKnownGE(\n             N->getIndex().getValueType().getVectorElementCount(),\n             N->getValue().getValueType().getVectorElementCount()) &&\n         \"Vector width mismatch between index and data\");\n  assert(isa<ConstantSDNode>(N->getScale()) &&\n         cast<ConstantSDNode>(N->getScale())->getAPIntValue().isPowerOf2() &&\n         \"Scale should be a constant power of 2\");\n\n  CSEMap.InsertNode(N, IP);\n  InsertNode(N);\n  SDValue V(N, 0);\n  NewSDValueDbgMsg(V, \"Creating new node: \", this);\n  return V;\n}\n\nSDValue SelectionDAG::simplifySelect(SDValue Cond, SDValue T, SDValue F) {\n  // select undef, T, F --> T (if T is a constant), otherwise F\n  // select, ?, undef, F --> F\n  // select, ?, T, undef --> T\n  if (Cond.isUndef())\n    return isConstantValueOfAnyType(T) ? T : F;\n  if (T.isUndef())\n    return F;\n  if (F.isUndef())\n    return T;\n\n  // select true, T, F --> T\n  // select false, T, F --> F\n  if (auto *CondC = dyn_cast<ConstantSDNode>(Cond))\n    return CondC->isNullValue() ? F : T;\n\n  // TODO: This should simplify VSELECT with constant condition using something\n  // like this (but check boolean contents to be complete?):\n  //  if (ISD::isBuildVectorAllOnes(Cond.getNode()))\n  //    return T;\n  //  if (ISD::isBuildVectorAllZeros(Cond.getNode()))\n  //    return F;\n\n  // select ?, T, T --> T\n  if (T == F)\n    return T;\n\n  return SDValue();\n}\n\nSDValue SelectionDAG::simplifyShift(SDValue X, SDValue Y) {\n  // shift undef, Y --> 0 (can always assume that the undef value is 0)\n  if (X.isUndef())\n    return getConstant(0, SDLoc(X.getNode()), X.getValueType());\n  // shift X, undef --> undef (because it may shift by the bitwidth)\n  if (Y.isUndef())\n    return getUNDEF(X.getValueType());\n\n  // shift 0, Y --> 0\n  // shift X, 0 --> X\n  if (isNullOrNullSplat(X) || isNullOrNullSplat(Y))\n    return X;\n\n  // shift X, C >= bitwidth(X) --> undef\n  // All vector elements must be too big (or undef) to avoid partial undefs.\n  auto isShiftTooBig = [X](ConstantSDNode *Val) {\n    return !Val || Val->getAPIntValue().uge(X.getScalarValueSizeInBits());\n  };\n  if (ISD::matchUnaryPredicate(Y, isShiftTooBig, true))\n    return getUNDEF(X.getValueType());\n\n  return SDValue();\n}\n\nSDValue SelectionDAG::simplifyFPBinop(unsigned Opcode, SDValue X, SDValue Y,\n                                      SDNodeFlags Flags) {\n  // If this operation has 'nnan' or 'ninf' and at least 1 disallowed operand\n  // (an undef operand can be chosen to be Nan/Inf), then the result of this\n  // operation is poison. That result can be relaxed to undef.\n  ConstantFPSDNode *XC = isConstOrConstSplatFP(X, /* AllowUndefs */ true);\n  ConstantFPSDNode *YC = isConstOrConstSplatFP(Y, /* AllowUndefs */ true);\n  bool HasNan = (XC && XC->getValueAPF().isNaN()) ||\n                (YC && YC->getValueAPF().isNaN());\n  bool HasInf = (XC && XC->getValueAPF().isInfinity()) ||\n                (YC && YC->getValueAPF().isInfinity());\n\n  if (Flags.hasNoNaNs() && (HasNan || X.isUndef() || Y.isUndef()))\n    return getUNDEF(X.getValueType());\n\n  if (Flags.hasNoInfs() && (HasInf || X.isUndef() || Y.isUndef()))\n    return getUNDEF(X.getValueType());\n\n  if (!YC)\n    return SDValue();\n\n  // X + -0.0 --> X\n  if (Opcode == ISD::FADD)\n    if (YC->getValueAPF().isNegZero())\n      return X;\n\n  // X - +0.0 --> X\n  if (Opcode == ISD::FSUB)\n    if (YC->getValueAPF().isPosZero())\n      return X;\n\n  // X * 1.0 --> X\n  // X / 1.0 --> X\n  if (Opcode == ISD::FMUL || Opcode == ISD::FDIV)\n    if (YC->getValueAPF().isExactlyValue(1.0))\n      return X;\n\n  // X * 0.0 --> 0.0\n  if (Opcode == ISD::FMUL && Flags.hasNoNaNs() && Flags.hasNoSignedZeros())\n    if (YC->getValueAPF().isZero())\n      return getConstantFP(0.0, SDLoc(Y), Y.getValueType());\n\n  return SDValue();\n}\n\nSDValue SelectionDAG::getVAArg(EVT VT, const SDLoc &dl, SDValue Chain,\n                               SDValue Ptr, SDValue SV, unsigned Align) {\n  SDValue Ops[] = { Chain, Ptr, SV, getTargetConstant(Align, dl, MVT::i32) };\n  return getNode(ISD::VAARG, dl, getVTList(VT, MVT::Other), Ops);\n}\n\nSDValue SelectionDAG::getNode(unsigned Opcode, const SDLoc &DL, EVT VT,\n                              ArrayRef<SDUse> Ops) {\n  switch (Ops.size()) {\n  case 0: return getNode(Opcode, DL, VT);\n  case 1: return getNode(Opcode, DL, VT, static_cast<const SDValue>(Ops[0]));\n  case 2: return getNode(Opcode, DL, VT, Ops[0], Ops[1]);\n  case 3: return getNode(Opcode, DL, VT, Ops[0], Ops[1], Ops[2]);\n  default: break;\n  }\n\n  // Copy from an SDUse array into an SDValue array for use with\n  // the regular getNode logic.\n  SmallVector<SDValue, 8> NewOps(Ops.begin(), Ops.end());\n  return getNode(Opcode, DL, VT, NewOps);\n}\n\nSDValue SelectionDAG::getNode(unsigned Opcode, const SDLoc &DL, EVT VT,\n                              ArrayRef<SDValue> Ops) {\n  SDNodeFlags Flags;\n  if (Inserter)\n    Flags = Inserter->getFlags();\n  return getNode(Opcode, DL, VT, Ops, Flags);\n}\n\nSDValue SelectionDAG::getNode(unsigned Opcode, const SDLoc &DL, EVT VT,\n                              ArrayRef<SDValue> Ops, const SDNodeFlags Flags) {\n  unsigned NumOps = Ops.size();\n  switch (NumOps) {\n  case 0: return getNode(Opcode, DL, VT);\n  case 1: return getNode(Opcode, DL, VT, Ops[0], Flags);\n  case 2: return getNode(Opcode, DL, VT, Ops[0], Ops[1], Flags);\n  case 3: return getNode(Opcode, DL, VT, Ops[0], Ops[1], Ops[2], Flags);\n  default: break;\n  }\n\n#ifndef NDEBUG\n  for (auto &Op : Ops)\n    assert(Op.getOpcode() != ISD::DELETED_NODE &&\n           \"Operand is DELETED_NODE!\");\n#endif\n\n  switch (Opcode) {\n  default: break;\n  case ISD::BUILD_VECTOR:\n    // Attempt to simplify BUILD_VECTOR.\n    if (SDValue V = FoldBUILD_VECTOR(DL, VT, Ops, *this))\n      return V;\n    break;\n  case ISD::CONCAT_VECTORS:\n    if (SDValue V = foldCONCAT_VECTORS(DL, VT, Ops, *this))\n      return V;\n    break;\n  case ISD::SELECT_CC:\n    assert(NumOps == 5 && \"SELECT_CC takes 5 operands!\");\n    assert(Ops[0].getValueType() == Ops[1].getValueType() &&\n           \"LHS and RHS of condition must have same type!\");\n    assert(Ops[2].getValueType() == Ops[3].getValueType() &&\n           \"True and False arms of SelectCC must have same type!\");\n    assert(Ops[2].getValueType() == VT &&\n           \"select_cc node must be of same type as true and false value!\");\n    break;\n  case ISD::BR_CC:\n    assert(NumOps == 5 && \"BR_CC takes 5 operands!\");\n    assert(Ops[2].getValueType() == Ops[3].getValueType() &&\n           \"LHS/RHS of comparison should match types!\");\n    break;\n  }\n\n  // Memoize nodes.\n  SDNode *N;\n  SDVTList VTs = getVTList(VT);\n\n  if (VT != MVT::Glue) {\n    FoldingSetNodeID ID;\n    AddNodeIDNode(ID, Opcode, VTs, Ops);\n    void *IP = nullptr;\n\n    if (SDNode *E = FindNodeOrInsertPos(ID, DL, IP))\n      return SDValue(E, 0);\n\n    N = newSDNode<SDNode>(Opcode, DL.getIROrder(), DL.getDebugLoc(), VTs);\n    createOperands(N, Ops);\n\n    CSEMap.InsertNode(N, IP);\n  } else {\n    N = newSDNode<SDNode>(Opcode, DL.getIROrder(), DL.getDebugLoc(), VTs);\n    createOperands(N, Ops);\n  }\n\n  N->setFlags(Flags);\n  InsertNode(N);\n  SDValue V(N, 0);\n  NewSDValueDbgMsg(V, \"Creating new node: \", this);\n  return V;\n}\n\nSDValue SelectionDAG::getNode(unsigned Opcode, const SDLoc &DL,\n                              ArrayRef<EVT> ResultTys, ArrayRef<SDValue> Ops) {\n  return getNode(Opcode, DL, getVTList(ResultTys), Ops);\n}\n\nSDValue SelectionDAG::getNode(unsigned Opcode, const SDLoc &DL, SDVTList VTList,\n                              ArrayRef<SDValue> Ops) {\n  SDNodeFlags Flags;\n  if (Inserter)\n    Flags = Inserter->getFlags();\n  return getNode(Opcode, DL, VTList, Ops, Flags);\n}\n\nSDValue SelectionDAG::getNode(unsigned Opcode, const SDLoc &DL, SDVTList VTList,\n                              ArrayRef<SDValue> Ops, const SDNodeFlags Flags) {\n  if (VTList.NumVTs == 1)\n    return getNode(Opcode, DL, VTList.VTs[0], Ops);\n\n#ifndef NDEBUG\n  for (auto &Op : Ops)\n    assert(Op.getOpcode() != ISD::DELETED_NODE &&\n           \"Operand is DELETED_NODE!\");\n#endif\n\n  switch (Opcode) {\n  case ISD::STRICT_FP_EXTEND:\n    assert(VTList.NumVTs == 2 && Ops.size() == 2 &&\n           \"Invalid STRICT_FP_EXTEND!\");\n    assert(VTList.VTs[0].isFloatingPoint() &&\n           Ops[1].getValueType().isFloatingPoint() && \"Invalid FP cast!\");\n    assert(VTList.VTs[0].isVector() == Ops[1].getValueType().isVector() &&\n           \"STRICT_FP_EXTEND result type should be vector iff the operand \"\n           \"type is vector!\");\n    assert((!VTList.VTs[0].isVector() ||\n            VTList.VTs[0].getVectorNumElements() ==\n            Ops[1].getValueType().getVectorNumElements()) &&\n           \"Vector element count mismatch!\");\n    assert(Ops[1].getValueType().bitsLT(VTList.VTs[0]) &&\n           \"Invalid fpext node, dst <= src!\");\n    break;\n  case ISD::STRICT_FP_ROUND:\n    assert(VTList.NumVTs == 2 && Ops.size() == 3 && \"Invalid STRICT_FP_ROUND!\");\n    assert(VTList.VTs[0].isVector() == Ops[1].getValueType().isVector() &&\n           \"STRICT_FP_ROUND result type should be vector iff the operand \"\n           \"type is vector!\");\n    assert((!VTList.VTs[0].isVector() ||\n            VTList.VTs[0].getVectorNumElements() ==\n            Ops[1].getValueType().getVectorNumElements()) &&\n           \"Vector element count mismatch!\");\n    assert(VTList.VTs[0].isFloatingPoint() &&\n           Ops[1].getValueType().isFloatingPoint() &&\n           VTList.VTs[0].bitsLT(Ops[1].getValueType()) &&\n           isa<ConstantSDNode>(Ops[2]) &&\n           (cast<ConstantSDNode>(Ops[2])->getZExtValue() == 0 ||\n            cast<ConstantSDNode>(Ops[2])->getZExtValue() == 1) &&\n           \"Invalid STRICT_FP_ROUND!\");\n    break;\n#if 0\n  // FIXME: figure out how to safely handle things like\n  // int foo(int x) { return 1 << (x & 255); }\n  // int bar() { return foo(256); }\n  case ISD::SRA_PARTS:\n  case ISD::SRL_PARTS:\n  case ISD::SHL_PARTS:\n    if (N3.getOpcode() == ISD::SIGN_EXTEND_INREG &&\n        cast<VTSDNode>(N3.getOperand(1))->getVT() != MVT::i1)\n      return getNode(Opcode, DL, VT, N1, N2, N3.getOperand(0));\n    else if (N3.getOpcode() == ISD::AND)\n      if (ConstantSDNode *AndRHS = dyn_cast<ConstantSDNode>(N3.getOperand(1))) {\n        // If the and is only masking out bits that cannot effect the shift,\n        // eliminate the and.\n        unsigned NumBits = VT.getScalarSizeInBits()*2;\n        if ((AndRHS->getValue() & (NumBits-1)) == NumBits-1)\n          return getNode(Opcode, DL, VT, N1, N2, N3.getOperand(0));\n      }\n    break;\n#endif\n  }\n\n  // Memoize the node unless it returns a flag.\n  SDNode *N;\n  if (VTList.VTs[VTList.NumVTs-1] != MVT::Glue) {\n    FoldingSetNodeID ID;\n    AddNodeIDNode(ID, Opcode, VTList, Ops);\n    void *IP = nullptr;\n    if (SDNode *E = FindNodeOrInsertPos(ID, DL, IP))\n      return SDValue(E, 0);\n\n    N = newSDNode<SDNode>(Opcode, DL.getIROrder(), DL.getDebugLoc(), VTList);\n    createOperands(N, Ops);\n    CSEMap.InsertNode(N, IP);\n  } else {\n    N = newSDNode<SDNode>(Opcode, DL.getIROrder(), DL.getDebugLoc(), VTList);\n    createOperands(N, Ops);\n  }\n\n  N->setFlags(Flags);\n  InsertNode(N);\n  SDValue V(N, 0);\n  NewSDValueDbgMsg(V, \"Creating new node: \", this);\n  return V;\n}\n\nSDValue SelectionDAG::getNode(unsigned Opcode, const SDLoc &DL,\n                              SDVTList VTList) {\n  return getNode(Opcode, DL, VTList, None);\n}\n\nSDValue SelectionDAG::getNode(unsigned Opcode, const SDLoc &DL, SDVTList VTList,\n                              SDValue N1) {\n  SDValue Ops[] = { N1 };\n  return getNode(Opcode, DL, VTList, Ops);\n}\n\nSDValue SelectionDAG::getNode(unsigned Opcode, const SDLoc &DL, SDVTList VTList,\n                              SDValue N1, SDValue N2) {\n  SDValue Ops[] = { N1, N2 };\n  return getNode(Opcode, DL, VTList, Ops);\n}\n\nSDValue SelectionDAG::getNode(unsigned Opcode, const SDLoc &DL, SDVTList VTList,\n                              SDValue N1, SDValue N2, SDValue N3) {\n  SDValue Ops[] = { N1, N2, N3 };\n  return getNode(Opcode, DL, VTList, Ops);\n}\n\nSDValue SelectionDAG::getNode(unsigned Opcode, const SDLoc &DL, SDVTList VTList,\n                              SDValue N1, SDValue N2, SDValue N3, SDValue N4) {\n  SDValue Ops[] = { N1, N2, N3, N4 };\n  return getNode(Opcode, DL, VTList, Ops);\n}\n\nSDValue SelectionDAG::getNode(unsigned Opcode, const SDLoc &DL, SDVTList VTList,\n                              SDValue N1, SDValue N2, SDValue N3, SDValue N4,\n                              SDValue N5) {\n  SDValue Ops[] = { N1, N2, N3, N4, N5 };\n  return getNode(Opcode, DL, VTList, Ops);\n}\n\nSDVTList SelectionDAG::getVTList(EVT VT) {\n  return makeVTList(SDNode::getValueTypeList(VT), 1);\n}\n\nSDVTList SelectionDAG::getVTList(EVT VT1, EVT VT2) {\n  FoldingSetNodeID ID;\n  ID.AddInteger(2U);\n  ID.AddInteger(VT1.getRawBits());\n  ID.AddInteger(VT2.getRawBits());\n\n  void *IP = nullptr;\n  SDVTListNode *Result = VTListMap.FindNodeOrInsertPos(ID, IP);\n  if (!Result) {\n    EVT *Array = Allocator.Allocate<EVT>(2);\n    Array[0] = VT1;\n    Array[1] = VT2;\n    Result = new (Allocator) SDVTListNode(ID.Intern(Allocator), Array, 2);\n    VTListMap.InsertNode(Result, IP);\n  }\n  return Result->getSDVTList();\n}\n\nSDVTList SelectionDAG::getVTList(EVT VT1, EVT VT2, EVT VT3) {\n  FoldingSetNodeID ID;\n  ID.AddInteger(3U);\n  ID.AddInteger(VT1.getRawBits());\n  ID.AddInteger(VT2.getRawBits());\n  ID.AddInteger(VT3.getRawBits());\n\n  void *IP = nullptr;\n  SDVTListNode *Result = VTListMap.FindNodeOrInsertPos(ID, IP);\n  if (!Result) {\n    EVT *Array = Allocator.Allocate<EVT>(3);\n    Array[0] = VT1;\n    Array[1] = VT2;\n    Array[2] = VT3;\n    Result = new (Allocator) SDVTListNode(ID.Intern(Allocator), Array, 3);\n    VTListMap.InsertNode(Result, IP);\n  }\n  return Result->getSDVTList();\n}\n\nSDVTList SelectionDAG::getVTList(EVT VT1, EVT VT2, EVT VT3, EVT VT4) {\n  FoldingSetNodeID ID;\n  ID.AddInteger(4U);\n  ID.AddInteger(VT1.getRawBits());\n  ID.AddInteger(VT2.getRawBits());\n  ID.AddInteger(VT3.getRawBits());\n  ID.AddInteger(VT4.getRawBits());\n\n  void *IP = nullptr;\n  SDVTListNode *Result = VTListMap.FindNodeOrInsertPos(ID, IP);\n  if (!Result) {\n    EVT *Array = Allocator.Allocate<EVT>(4);\n    Array[0] = VT1;\n    Array[1] = VT2;\n    Array[2] = VT3;\n    Array[3] = VT4;\n    Result = new (Allocator) SDVTListNode(ID.Intern(Allocator), Array, 4);\n    VTListMap.InsertNode(Result, IP);\n  }\n  return Result->getSDVTList();\n}\n\nSDVTList SelectionDAG::getVTList(ArrayRef<EVT> VTs) {\n  unsigned NumVTs = VTs.size();\n  FoldingSetNodeID ID;\n  ID.AddInteger(NumVTs);\n  for (unsigned index = 0; index < NumVTs; index++) {\n    ID.AddInteger(VTs[index].getRawBits());\n  }\n\n  void *IP = nullptr;\n  SDVTListNode *Result = VTListMap.FindNodeOrInsertPos(ID, IP);\n  if (!Result) {\n    EVT *Array = Allocator.Allocate<EVT>(NumVTs);\n    llvm::copy(VTs, Array);\n    Result = new (Allocator) SDVTListNode(ID.Intern(Allocator), Array, NumVTs);\n    VTListMap.InsertNode(Result, IP);\n  }\n  return Result->getSDVTList();\n}\n\n\n/// UpdateNodeOperands - *Mutate* the specified node in-place to have the\n/// specified operands.  If the resultant node already exists in the DAG,\n/// this does not modify the specified node, instead it returns the node that\n/// already exists.  If the resultant node does not exist in the DAG, the\n/// input node is returned.  As a degenerate case, if you specify the same\n/// input operands as the node already has, the input node is returned.\nSDNode *SelectionDAG::UpdateNodeOperands(SDNode *N, SDValue Op) {\n  assert(N->getNumOperands() == 1 && \"Update with wrong number of operands\");\n\n  // Check to see if there is no change.\n  if (Op == N->getOperand(0)) return N;\n\n  // See if the modified node already exists.\n  void *InsertPos = nullptr;\n  if (SDNode *Existing = FindModifiedNodeSlot(N, Op, InsertPos))\n    return Existing;\n\n  // Nope it doesn't.  Remove the node from its current place in the maps.\n  if (InsertPos)\n    if (!RemoveNodeFromCSEMaps(N))\n      InsertPos = nullptr;\n\n  // Now we update the operands.\n  N->OperandList[0].set(Op);\n\n  updateDivergence(N);\n  // If this gets put into a CSE map, add it.\n  if (InsertPos) CSEMap.InsertNode(N, InsertPos);\n  return N;\n}\n\nSDNode *SelectionDAG::UpdateNodeOperands(SDNode *N, SDValue Op1, SDValue Op2) {\n  assert(N->getNumOperands() == 2 && \"Update with wrong number of operands\");\n\n  // Check to see if there is no change.\n  if (Op1 == N->getOperand(0) && Op2 == N->getOperand(1))\n    return N;   // No operands changed, just return the input node.\n\n  // See if the modified node already exists.\n  void *InsertPos = nullptr;\n  if (SDNode *Existing = FindModifiedNodeSlot(N, Op1, Op2, InsertPos))\n    return Existing;\n\n  // Nope it doesn't.  Remove the node from its current place in the maps.\n  if (InsertPos)\n    if (!RemoveNodeFromCSEMaps(N))\n      InsertPos = nullptr;\n\n  // Now we update the operands.\n  if (N->OperandList[0] != Op1)\n    N->OperandList[0].set(Op1);\n  if (N->OperandList[1] != Op2)\n    N->OperandList[1].set(Op2);\n\n  updateDivergence(N);\n  // If this gets put into a CSE map, add it.\n  if (InsertPos) CSEMap.InsertNode(N, InsertPos);\n  return N;\n}\n\nSDNode *SelectionDAG::\nUpdateNodeOperands(SDNode *N, SDValue Op1, SDValue Op2, SDValue Op3) {\n  SDValue Ops[] = { Op1, Op2, Op3 };\n  return UpdateNodeOperands(N, Ops);\n}\n\nSDNode *SelectionDAG::\nUpdateNodeOperands(SDNode *N, SDValue Op1, SDValue Op2,\n                   SDValue Op3, SDValue Op4) {\n  SDValue Ops[] = { Op1, Op2, Op3, Op4 };\n  return UpdateNodeOperands(N, Ops);\n}\n\nSDNode *SelectionDAG::\nUpdateNodeOperands(SDNode *N, SDValue Op1, SDValue Op2,\n                   SDValue Op3, SDValue Op4, SDValue Op5) {\n  SDValue Ops[] = { Op1, Op2, Op3, Op4, Op5 };\n  return UpdateNodeOperands(N, Ops);\n}\n\nSDNode *SelectionDAG::\nUpdateNodeOperands(SDNode *N, ArrayRef<SDValue> Ops) {\n  unsigned NumOps = Ops.size();\n  assert(N->getNumOperands() == NumOps &&\n         \"Update with wrong number of operands\");\n\n  // If no operands changed just return the input node.\n  if (std::equal(Ops.begin(), Ops.end(), N->op_begin()))\n    return N;\n\n  // See if the modified node already exists.\n  void *InsertPos = nullptr;\n  if (SDNode *Existing = FindModifiedNodeSlot(N, Ops, InsertPos))\n    return Existing;\n\n  // Nope it doesn't.  Remove the node from its current place in the maps.\n  if (InsertPos)\n    if (!RemoveNodeFromCSEMaps(N))\n      InsertPos = nullptr;\n\n  // Now we update the operands.\n  for (unsigned i = 0; i != NumOps; ++i)\n    if (N->OperandList[i] != Ops[i])\n      N->OperandList[i].set(Ops[i]);\n\n  updateDivergence(N);\n  // If this gets put into a CSE map, add it.\n  if (InsertPos) CSEMap.InsertNode(N, InsertPos);\n  return N;\n}\n\n/// DropOperands - Release the operands and set this node to have\n/// zero operands.\nvoid SDNode::DropOperands() {\n  // Unlike the code in MorphNodeTo that does this, we don't need to\n  // watch for dead nodes here.\n  for (op_iterator I = op_begin(), E = op_end(); I != E; ) {\n    SDUse &Use = *I++;\n    Use.set(SDValue());\n  }\n}\n\nvoid SelectionDAG::setNodeMemRefs(MachineSDNode *N,\n                                  ArrayRef<MachineMemOperand *> NewMemRefs) {\n  if (NewMemRefs.empty()) {\n    N->clearMemRefs();\n    return;\n  }\n\n  // Check if we can avoid allocating by storing a single reference directly.\n  if (NewMemRefs.size() == 1) {\n    N->MemRefs = NewMemRefs[0];\n    N->NumMemRefs = 1;\n    return;\n  }\n\n  MachineMemOperand **MemRefsBuffer =\n      Allocator.template Allocate<MachineMemOperand *>(NewMemRefs.size());\n  llvm::copy(NewMemRefs, MemRefsBuffer);\n  N->MemRefs = MemRefsBuffer;\n  N->NumMemRefs = static_cast<int>(NewMemRefs.size());\n}\n\n/// SelectNodeTo - These are wrappers around MorphNodeTo that accept a\n/// machine opcode.\n///\nSDNode *SelectionDAG::SelectNodeTo(SDNode *N, unsigned MachineOpc,\n                                   EVT VT) {\n  SDVTList VTs = getVTList(VT);\n  return SelectNodeTo(N, MachineOpc, VTs, None);\n}\n\nSDNode *SelectionDAG::SelectNodeTo(SDNode *N, unsigned MachineOpc,\n                                   EVT VT, SDValue Op1) {\n  SDVTList VTs = getVTList(VT);\n  SDValue Ops[] = { Op1 };\n  return SelectNodeTo(N, MachineOpc, VTs, Ops);\n}\n\nSDNode *SelectionDAG::SelectNodeTo(SDNode *N, unsigned MachineOpc,\n                                   EVT VT, SDValue Op1,\n                                   SDValue Op2) {\n  SDVTList VTs = getVTList(VT);\n  SDValue Ops[] = { Op1, Op2 };\n  return SelectNodeTo(N, MachineOpc, VTs, Ops);\n}\n\nSDNode *SelectionDAG::SelectNodeTo(SDNode *N, unsigned MachineOpc,\n                                   EVT VT, SDValue Op1,\n                                   SDValue Op2, SDValue Op3) {\n  SDVTList VTs = getVTList(VT);\n  SDValue Ops[] = { Op1, Op2, Op3 };\n  return SelectNodeTo(N, MachineOpc, VTs, Ops);\n}\n\nSDNode *SelectionDAG::SelectNodeTo(SDNode *N, unsigned MachineOpc,\n                                   EVT VT, ArrayRef<SDValue> Ops) {\n  SDVTList VTs = getVTList(VT);\n  return SelectNodeTo(N, MachineOpc, VTs, Ops);\n}\n\nSDNode *SelectionDAG::SelectNodeTo(SDNode *N, unsigned MachineOpc,\n                                   EVT VT1, EVT VT2, ArrayRef<SDValue> Ops) {\n  SDVTList VTs = getVTList(VT1, VT2);\n  return SelectNodeTo(N, MachineOpc, VTs, Ops);\n}\n\nSDNode *SelectionDAG::SelectNodeTo(SDNode *N, unsigned MachineOpc,\n                                   EVT VT1, EVT VT2) {\n  SDVTList VTs = getVTList(VT1, VT2);\n  return SelectNodeTo(N, MachineOpc, VTs, None);\n}\n\nSDNode *SelectionDAG::SelectNodeTo(SDNode *N, unsigned MachineOpc,\n                                   EVT VT1, EVT VT2, EVT VT3,\n                                   ArrayRef<SDValue> Ops) {\n  SDVTList VTs = getVTList(VT1, VT2, VT3);\n  return SelectNodeTo(N, MachineOpc, VTs, Ops);\n}\n\nSDNode *SelectionDAG::SelectNodeTo(SDNode *N, unsigned MachineOpc,\n                                   EVT VT1, EVT VT2,\n                                   SDValue Op1, SDValue Op2) {\n  SDVTList VTs = getVTList(VT1, VT2);\n  SDValue Ops[] = { Op1, Op2 };\n  return SelectNodeTo(N, MachineOpc, VTs, Ops);\n}\n\nSDNode *SelectionDAG::SelectNodeTo(SDNode *N, unsigned MachineOpc,\n                                   SDVTList VTs,ArrayRef<SDValue> Ops) {\n  SDNode *New = MorphNodeTo(N, ~MachineOpc, VTs, Ops);\n  // Reset the NodeID to -1.\n  New->setNodeId(-1);\n  if (New != N) {\n    ReplaceAllUsesWith(N, New);\n    RemoveDeadNode(N);\n  }\n  return New;\n}\n\n/// UpdateSDLocOnMergeSDNode - If the opt level is -O0 then it throws away\n/// the line number information on the merged node since it is not possible to\n/// preserve the information that operation is associated with multiple lines.\n/// This will make the debugger working better at -O0, were there is a higher\n/// probability having other instructions associated with that line.\n///\n/// For IROrder, we keep the smaller of the two\nSDNode *SelectionDAG::UpdateSDLocOnMergeSDNode(SDNode *N, const SDLoc &OLoc) {\n  DebugLoc NLoc = N->getDebugLoc();\n  if (NLoc && OptLevel == CodeGenOpt::None && OLoc.getDebugLoc() != NLoc) {\n    N->setDebugLoc(DebugLoc());\n  }\n  unsigned Order = std::min(N->getIROrder(), OLoc.getIROrder());\n  N->setIROrder(Order);\n  return N;\n}\n\n/// MorphNodeTo - This *mutates* the specified node to have the specified\n/// return type, opcode, and operands.\n///\n/// Note that MorphNodeTo returns the resultant node.  If there is already a\n/// node of the specified opcode and operands, it returns that node instead of\n/// the current one.  Note that the SDLoc need not be the same.\n///\n/// Using MorphNodeTo is faster than creating a new node and swapping it in\n/// with ReplaceAllUsesWith both because it often avoids allocating a new\n/// node, and because it doesn't require CSE recalculation for any of\n/// the node's users.\n///\n/// However, note that MorphNodeTo recursively deletes dead nodes from the DAG.\n/// As a consequence it isn't appropriate to use from within the DAG combiner or\n/// the legalizer which maintain worklists that would need to be updated when\n/// deleting things.\nSDNode *SelectionDAG::MorphNodeTo(SDNode *N, unsigned Opc,\n                                  SDVTList VTs, ArrayRef<SDValue> Ops) {\n  // If an identical node already exists, use it.\n  void *IP = nullptr;\n  if (VTs.VTs[VTs.NumVTs-1] != MVT::Glue) {\n    FoldingSetNodeID ID;\n    AddNodeIDNode(ID, Opc, VTs, Ops);\n    if (SDNode *ON = FindNodeOrInsertPos(ID, SDLoc(N), IP))\n      return UpdateSDLocOnMergeSDNode(ON, SDLoc(N));\n  }\n\n  if (!RemoveNodeFromCSEMaps(N))\n    IP = nullptr;\n\n  // Start the morphing.\n  N->NodeType = Opc;\n  N->ValueList = VTs.VTs;\n  N->NumValues = VTs.NumVTs;\n\n  // Clear the operands list, updating used nodes to remove this from their\n  // use list.  Keep track of any operands that become dead as a result.\n  SmallPtrSet<SDNode*, 16> DeadNodeSet;\n  for (SDNode::op_iterator I = N->op_begin(), E = N->op_end(); I != E; ) {\n    SDUse &Use = *I++;\n    SDNode *Used = Use.getNode();\n    Use.set(SDValue());\n    if (Used->use_empty())\n      DeadNodeSet.insert(Used);\n  }\n\n  // For MachineNode, initialize the memory references information.\n  if (MachineSDNode *MN = dyn_cast<MachineSDNode>(N))\n    MN->clearMemRefs();\n\n  // Swap for an appropriately sized array from the recycler.\n  removeOperands(N);\n  createOperands(N, Ops);\n\n  // Delete any nodes that are still dead after adding the uses for the\n  // new operands.\n  if (!DeadNodeSet.empty()) {\n    SmallVector<SDNode *, 16> DeadNodes;\n    for (SDNode *N : DeadNodeSet)\n      if (N->use_empty())\n        DeadNodes.push_back(N);\n    RemoveDeadNodes(DeadNodes);\n  }\n\n  if (IP)\n    CSEMap.InsertNode(N, IP);   // Memoize the new node.\n  return N;\n}\n\nSDNode* SelectionDAG::mutateStrictFPToFP(SDNode *Node) {\n  unsigned OrigOpc = Node->getOpcode();\n  unsigned NewOpc;\n  switch (OrigOpc) {\n  default:\n    llvm_unreachable(\"mutateStrictFPToFP called with unexpected opcode!\");\n#define DAG_INSTRUCTION(NAME, NARG, ROUND_MODE, INTRINSIC, DAGN)               \\\n  case ISD::STRICT_##DAGN: NewOpc = ISD::DAGN; break;\n#define CMP_INSTRUCTION(NAME, NARG, ROUND_MODE, INTRINSIC, DAGN)               \\\n  case ISD::STRICT_##DAGN: NewOpc = ISD::SETCC; break;\n#include \"llvm/IR/ConstrainedOps.def\"\n  }\n\n  assert(Node->getNumValues() == 2 && \"Unexpected number of results!\");\n\n  // We're taking this node out of the chain, so we need to re-link things.\n  SDValue InputChain = Node->getOperand(0);\n  SDValue OutputChain = SDValue(Node, 1);\n  ReplaceAllUsesOfValueWith(OutputChain, InputChain);\n\n  SmallVector<SDValue, 3> Ops;\n  for (unsigned i = 1, e = Node->getNumOperands(); i != e; ++i)\n    Ops.push_back(Node->getOperand(i));\n\n  SDVTList VTs = getVTList(Node->getValueType(0));\n  SDNode *Res = MorphNodeTo(Node, NewOpc, VTs, Ops);\n\n  // MorphNodeTo can operate in two ways: if an existing node with the\n  // specified operands exists, it can just return it.  Otherwise, it\n  // updates the node in place to have the requested operands.\n  if (Res == Node) {\n    // If we updated the node in place, reset the node ID.  To the isel,\n    // this should be just like a newly allocated machine node.\n    Res->setNodeId(-1);\n  } else {\n    ReplaceAllUsesWith(Node, Res);\n    RemoveDeadNode(Node);\n  }\n\n  return Res;\n}\n\n/// getMachineNode - These are used for target selectors to create a new node\n/// with specified return type(s), MachineInstr opcode, and operands.\n///\n/// Note that getMachineNode returns the resultant node.  If there is already a\n/// node of the specified opcode and operands, it returns that node instead of\n/// the current one.\nMachineSDNode *SelectionDAG::getMachineNode(unsigned Opcode, const SDLoc &dl,\n                                            EVT VT) {\n  SDVTList VTs = getVTList(VT);\n  return getMachineNode(Opcode, dl, VTs, None);\n}\n\nMachineSDNode *SelectionDAG::getMachineNode(unsigned Opcode, const SDLoc &dl,\n                                            EVT VT, SDValue Op1) {\n  SDVTList VTs = getVTList(VT);\n  SDValue Ops[] = { Op1 };\n  return getMachineNode(Opcode, dl, VTs, Ops);\n}\n\nMachineSDNode *SelectionDAG::getMachineNode(unsigned Opcode, const SDLoc &dl,\n                                            EVT VT, SDValue Op1, SDValue Op2) {\n  SDVTList VTs = getVTList(VT);\n  SDValue Ops[] = { Op1, Op2 };\n  return getMachineNode(Opcode, dl, VTs, Ops);\n}\n\nMachineSDNode *SelectionDAG::getMachineNode(unsigned Opcode, const SDLoc &dl,\n                                            EVT VT, SDValue Op1, SDValue Op2,\n                                            SDValue Op3) {\n  SDVTList VTs = getVTList(VT);\n  SDValue Ops[] = { Op1, Op2, Op3 };\n  return getMachineNode(Opcode, dl, VTs, Ops);\n}\n\nMachineSDNode *SelectionDAG::getMachineNode(unsigned Opcode, const SDLoc &dl,\n                                            EVT VT, ArrayRef<SDValue> Ops) {\n  SDVTList VTs = getVTList(VT);\n  return getMachineNode(Opcode, dl, VTs, Ops);\n}\n\nMachineSDNode *SelectionDAG::getMachineNode(unsigned Opcode, const SDLoc &dl,\n                                            EVT VT1, EVT VT2, SDValue Op1,\n                                            SDValue Op2) {\n  SDVTList VTs = getVTList(VT1, VT2);\n  SDValue Ops[] = { Op1, Op2 };\n  return getMachineNode(Opcode, dl, VTs, Ops);\n}\n\nMachineSDNode *SelectionDAG::getMachineNode(unsigned Opcode, const SDLoc &dl,\n                                            EVT VT1, EVT VT2, SDValue Op1,\n                                            SDValue Op2, SDValue Op3) {\n  SDVTList VTs = getVTList(VT1, VT2);\n  SDValue Ops[] = { Op1, Op2, Op3 };\n  return getMachineNode(Opcode, dl, VTs, Ops);\n}\n\nMachineSDNode *SelectionDAG::getMachineNode(unsigned Opcode, const SDLoc &dl,\n                                            EVT VT1, EVT VT2,\n                                            ArrayRef<SDValue> Ops) {\n  SDVTList VTs = getVTList(VT1, VT2);\n  return getMachineNode(Opcode, dl, VTs, Ops);\n}\n\nMachineSDNode *SelectionDAG::getMachineNode(unsigned Opcode, const SDLoc &dl,\n                                            EVT VT1, EVT VT2, EVT VT3,\n                                            SDValue Op1, SDValue Op2) {\n  SDVTList VTs = getVTList(VT1, VT2, VT3);\n  SDValue Ops[] = { Op1, Op2 };\n  return getMachineNode(Opcode, dl, VTs, Ops);\n}\n\nMachineSDNode *SelectionDAG::getMachineNode(unsigned Opcode, const SDLoc &dl,\n                                            EVT VT1, EVT VT2, EVT VT3,\n                                            SDValue Op1, SDValue Op2,\n                                            SDValue Op3) {\n  SDVTList VTs = getVTList(VT1, VT2, VT3);\n  SDValue Ops[] = { Op1, Op2, Op3 };\n  return getMachineNode(Opcode, dl, VTs, Ops);\n}\n\nMachineSDNode *SelectionDAG::getMachineNode(unsigned Opcode, const SDLoc &dl,\n                                            EVT VT1, EVT VT2, EVT VT3,\n                                            ArrayRef<SDValue> Ops) {\n  SDVTList VTs = getVTList(VT1, VT2, VT3);\n  return getMachineNode(Opcode, dl, VTs, Ops);\n}\n\nMachineSDNode *SelectionDAG::getMachineNode(unsigned Opcode, const SDLoc &dl,\n                                            ArrayRef<EVT> ResultTys,\n                                            ArrayRef<SDValue> Ops) {\n  SDVTList VTs = getVTList(ResultTys);\n  return getMachineNode(Opcode, dl, VTs, Ops);\n}\n\nMachineSDNode *SelectionDAG::getMachineNode(unsigned Opcode, const SDLoc &DL,\n                                            SDVTList VTs,\n                                            ArrayRef<SDValue> Ops) {\n  bool DoCSE = VTs.VTs[VTs.NumVTs-1] != MVT::Glue;\n  MachineSDNode *N;\n  void *IP = nullptr;\n\n  if (DoCSE) {\n    FoldingSetNodeID ID;\n    AddNodeIDNode(ID, ~Opcode, VTs, Ops);\n    IP = nullptr;\n    if (SDNode *E = FindNodeOrInsertPos(ID, DL, IP)) {\n      return cast<MachineSDNode>(UpdateSDLocOnMergeSDNode(E, DL));\n    }\n  }\n\n  // Allocate a new MachineSDNode.\n  N = newSDNode<MachineSDNode>(~Opcode, DL.getIROrder(), DL.getDebugLoc(), VTs);\n  createOperands(N, Ops);\n\n  if (DoCSE)\n    CSEMap.InsertNode(N, IP);\n\n  InsertNode(N);\n  NewSDValueDbgMsg(SDValue(N, 0), \"Creating new machine node: \", this);\n  return N;\n}\n\n/// getTargetExtractSubreg - A convenience function for creating\n/// TargetOpcode::EXTRACT_SUBREG nodes.\nSDValue SelectionDAG::getTargetExtractSubreg(int SRIdx, const SDLoc &DL, EVT VT,\n                                             SDValue Operand) {\n  SDValue SRIdxVal = getTargetConstant(SRIdx, DL, MVT::i32);\n  SDNode *Subreg = getMachineNode(TargetOpcode::EXTRACT_SUBREG, DL,\n                                  VT, Operand, SRIdxVal);\n  return SDValue(Subreg, 0);\n}\n\n/// getTargetInsertSubreg - A convenience function for creating\n/// TargetOpcode::INSERT_SUBREG nodes.\nSDValue SelectionDAG::getTargetInsertSubreg(int SRIdx, const SDLoc &DL, EVT VT,\n                                            SDValue Operand, SDValue Subreg) {\n  SDValue SRIdxVal = getTargetConstant(SRIdx, DL, MVT::i32);\n  SDNode *Result = getMachineNode(TargetOpcode::INSERT_SUBREG, DL,\n                                  VT, Operand, Subreg, SRIdxVal);\n  return SDValue(Result, 0);\n}\n\n/// getNodeIfExists - Get the specified node if it's already available, or\n/// else return NULL.\nSDNode *SelectionDAG::getNodeIfExists(unsigned Opcode, SDVTList VTList,\n                                      ArrayRef<SDValue> Ops) {\n  SDNodeFlags Flags;\n  if (Inserter)\n    Flags = Inserter->getFlags();\n  return getNodeIfExists(Opcode, VTList, Ops, Flags);\n}\n\nSDNode *SelectionDAG::getNodeIfExists(unsigned Opcode, SDVTList VTList,\n                                      ArrayRef<SDValue> Ops,\n                                      const SDNodeFlags Flags) {\n  if (VTList.VTs[VTList.NumVTs - 1] != MVT::Glue) {\n    FoldingSetNodeID ID;\n    AddNodeIDNode(ID, Opcode, VTList, Ops);\n    void *IP = nullptr;\n    if (SDNode *E = FindNodeOrInsertPos(ID, SDLoc(), IP)) {\n      E->intersectFlagsWith(Flags);\n      return E;\n    }\n  }\n  return nullptr;\n}\n\n/// doesNodeExist - Check if a node exists without modifying its flags.\nbool SelectionDAG::doesNodeExist(unsigned Opcode, SDVTList VTList,\n                                 ArrayRef<SDValue> Ops) {\n  if (VTList.VTs[VTList.NumVTs - 1] != MVT::Glue) {\n    FoldingSetNodeID ID;\n    AddNodeIDNode(ID, Opcode, VTList, Ops);\n    void *IP = nullptr;\n    if (FindNodeOrInsertPos(ID, SDLoc(), IP))\n      return true;\n  }\n  return false;\n}\n\n/// getDbgValue - Creates a SDDbgValue node.\n///\n/// SDNode\nSDDbgValue *SelectionDAG::getDbgValue(DIVariable *Var, DIExpression *Expr,\n                                      SDNode *N, unsigned R, bool IsIndirect,\n                                      const DebugLoc &DL, unsigned O) {\n  assert(cast<DILocalVariable>(Var)->isValidLocationForIntrinsic(DL) &&\n         \"Expected inlined-at fields to agree\");\n  return new (DbgInfo->getAlloc())\n      SDDbgValue(Var, Expr, SDDbgOperand::fromNode(N, R), N, IsIndirect, DL, O,\n                 /*IsVariadic=*/false);\n}\n\n/// Constant\nSDDbgValue *SelectionDAG::getConstantDbgValue(DIVariable *Var,\n                                              DIExpression *Expr,\n                                              const Value *C,\n                                              const DebugLoc &DL, unsigned O) {\n  assert(cast<DILocalVariable>(Var)->isValidLocationForIntrinsic(DL) &&\n         \"Expected inlined-at fields to agree\");\n  return new (DbgInfo->getAlloc()) SDDbgValue(\n      Var, Expr, SDDbgOperand::fromConst(C), {}, /*IsIndirect=*/false, DL, O,\n      /*IsVariadic=*/false);\n}\n\n/// FrameIndex\nSDDbgValue *SelectionDAG::getFrameIndexDbgValue(DIVariable *Var,\n                                                DIExpression *Expr, unsigned FI,\n                                                bool IsIndirect,\n                                                const DebugLoc &DL,\n                                                unsigned O) {\n  assert(cast<DILocalVariable>(Var)->isValidLocationForIntrinsic(DL) &&\n         \"Expected inlined-at fields to agree\");\n  return getFrameIndexDbgValue(Var, Expr, FI, {}, IsIndirect, DL, O);\n}\n\n/// FrameIndex with dependencies\nSDDbgValue *SelectionDAG::getFrameIndexDbgValue(DIVariable *Var,\n                                                DIExpression *Expr, unsigned FI,\n                                                ArrayRef<SDNode *> Dependencies,\n                                                bool IsIndirect,\n                                                const DebugLoc &DL,\n                                                unsigned O) {\n  assert(cast<DILocalVariable>(Var)->isValidLocationForIntrinsic(DL) &&\n         \"Expected inlined-at fields to agree\");\n  return new (DbgInfo->getAlloc())\n      SDDbgValue(Var, Expr, SDDbgOperand::fromFrameIdx(FI), Dependencies,\n                 IsIndirect, DL, O,\n                 /*IsVariadic=*/false);\n}\n\n/// VReg\nSDDbgValue *SelectionDAG::getVRegDbgValue(DIVariable *Var, DIExpression *Expr,\n                                          unsigned VReg, bool IsIndirect,\n                                          const DebugLoc &DL, unsigned O) {\n  assert(cast<DILocalVariable>(Var)->isValidLocationForIntrinsic(DL) &&\n         \"Expected inlined-at fields to agree\");\n  return new (DbgInfo->getAlloc())\n      SDDbgValue(Var, Expr, SDDbgOperand::fromVReg(VReg), {}, IsIndirect, DL, O,\n                 /*IsVariadic=*/false);\n}\n\nSDDbgValue *SelectionDAG::getDbgValueList(DIVariable *Var, DIExpression *Expr,\n                                          ArrayRef<SDDbgOperand> Locs,\n                                          ArrayRef<SDNode *> Dependencies,\n                                          bool IsIndirect, const DebugLoc &DL,\n                                          unsigned O, bool IsVariadic) {\n  assert(cast<DILocalVariable>(Var)->isValidLocationForIntrinsic(DL) &&\n         \"Expected inlined-at fields to agree\");\n  return new (DbgInfo->getAlloc())\n      SDDbgValue(Var, Expr, Locs, Dependencies, IsIndirect, DL, O, IsVariadic);\n}\n\nvoid SelectionDAG::transferDbgValues(SDValue From, SDValue To,\n                                     unsigned OffsetInBits, unsigned SizeInBits,\n                                     bool InvalidateDbg) {\n  SDNode *FromNode = From.getNode();\n  SDNode *ToNode = To.getNode();\n  assert(FromNode && ToNode && \"Can't modify dbg values\");\n\n  // PR35338\n  // TODO: assert(From != To && \"Redundant dbg value transfer\");\n  // TODO: assert(FromNode != ToNode && \"Intranode dbg value transfer\");\n  if (From == To || FromNode == ToNode)\n    return;\n\n  if (!FromNode->getHasDebugValue())\n    return;\n\n  SDDbgOperand FromLocOp =\n      SDDbgOperand::fromNode(From.getNode(), From.getResNo());\n  SDDbgOperand ToLocOp = SDDbgOperand::fromNode(To.getNode(), To.getResNo());\n\n  SmallVector<SDDbgValue *, 2> ClonedDVs;\n  for (SDDbgValue *Dbg : GetDbgValues(FromNode)) {\n    if (Dbg->isInvalidated())\n      continue;\n\n    // TODO: assert(!Dbg->isInvalidated() && \"Transfer of invalid dbg value\");\n\n    // Create a new location ops vector that is equal to the old vector, but\n    // with each instance of FromLocOp replaced with ToLocOp.\n    bool Changed = false;\n    auto NewLocOps = Dbg->copyLocationOps();\n    std::replace_if(\n        NewLocOps.begin(), NewLocOps.end(),\n        [&Changed, FromLocOp](const SDDbgOperand &Op) {\n          bool Match = Op == FromLocOp;\n          Changed |= Match;\n          return Match;\n        },\n        ToLocOp);\n    // Ignore this SDDbgValue if we didn't find a matching location.\n    if (!Changed)\n      continue;\n\n    DIVariable *Var = Dbg->getVariable();\n    auto *Expr = Dbg->getExpression();\n    // If a fragment is requested, update the expression.\n    if (SizeInBits) {\n      // When splitting a larger (e.g., sign-extended) value whose\n      // lower bits are described with an SDDbgValue, do not attempt\n      // to transfer the SDDbgValue to the upper bits.\n      if (auto FI = Expr->getFragmentInfo())\n        if (OffsetInBits + SizeInBits > FI->SizeInBits)\n          continue;\n      auto Fragment = DIExpression::createFragmentExpression(Expr, OffsetInBits,\n                                                             SizeInBits);\n      if (!Fragment)\n        continue;\n      Expr = *Fragment;\n    }\n\n    auto NewDependencies = Dbg->copySDNodes();\n    std::replace(NewDependencies.begin(), NewDependencies.end(), FromNode,\n                 ToNode);\n    // Clone the SDDbgValue and move it to To.\n    SDDbgValue *Clone = getDbgValueList(\n        Var, Expr, NewLocOps, NewDependencies, Dbg->isIndirect(),\n        Dbg->getDebugLoc(), std::max(ToNode->getIROrder(), Dbg->getOrder()),\n        Dbg->isVariadic());\n    ClonedDVs.push_back(Clone);\n\n    if (InvalidateDbg) {\n      // Invalidate value and indicate the SDDbgValue should not be emitted.\n      Dbg->setIsInvalidated();\n      Dbg->setIsEmitted();\n    }\n  }\n\n  for (SDDbgValue *Dbg : ClonedDVs) {\n    assert(is_contained(Dbg->getSDNodes(), ToNode) &&\n           \"Transferred DbgValues should depend on the new SDNode\");\n    AddDbgValue(Dbg, false);\n  }\n}\n\nvoid SelectionDAG::salvageDebugInfo(SDNode &N) {\n  if (!N.getHasDebugValue())\n    return;\n\n  SmallVector<SDDbgValue *, 2> ClonedDVs;\n  for (auto DV : GetDbgValues(&N)) {\n    if (DV->isInvalidated())\n      continue;\n    switch (N.getOpcode()) {\n    default:\n      break;\n    case ISD::ADD:\n      SDValue N0 = N.getOperand(0);\n      SDValue N1 = N.getOperand(1);\n      if (!isConstantIntBuildVectorOrConstantInt(N0) &&\n          isConstantIntBuildVectorOrConstantInt(N1)) {\n        uint64_t Offset = N.getConstantOperandVal(1);\n\n        // Rewrite an ADD constant node into a DIExpression. Since we are\n        // performing arithmetic to compute the variable's *value* in the\n        // DIExpression, we need to mark the expression with a\n        // DW_OP_stack_value.\n        auto *DIExpr = DV->getExpression();\n        auto NewLocOps = DV->copyLocationOps();\n        bool Changed = false;\n        for (size_t i = 0; i < NewLocOps.size(); ++i) {\n          // We're not given a ResNo to compare against because the whole\n          // node is going away. We know that any ISD::ADD only has one\n          // result, so we can assume any node match is using the result.\n          if (NewLocOps[i].getKind() != SDDbgOperand::SDNODE ||\n              NewLocOps[i].getSDNode() != &N)\n            continue;\n          NewLocOps[i] = SDDbgOperand::fromNode(N0.getNode(), N0.getResNo());\n          SmallVector<uint64_t, 3> ExprOps;\n          DIExpression::appendOffset(ExprOps, Offset);\n          DIExpr = DIExpression::appendOpsToArg(DIExpr, ExprOps, i, true);\n          Changed = true;\n        }\n        (void)Changed;\n        assert(Changed && \"Salvage target doesn't use N\");\n\n        auto NewDependencies = DV->copySDNodes();\n        std::replace(NewDependencies.begin(), NewDependencies.end(), &N,\n                     N0.getNode());\n        SDDbgValue *Clone = getDbgValueList(DV->getVariable(), DIExpr,\n                                            NewLocOps, NewDependencies,\n                                            DV->isIndirect(), DV->getDebugLoc(),\n                                            DV->getOrder(), DV->isVariadic());\n        ClonedDVs.push_back(Clone);\n        DV->setIsInvalidated();\n        DV->setIsEmitted();\n        LLVM_DEBUG(dbgs() << \"SALVAGE: Rewriting\";\n                   N0.getNode()->dumprFull(this);\n                   dbgs() << \" into \" << *DIExpr << '\\n');\n      }\n    }\n  }\n\n  for (SDDbgValue *Dbg : ClonedDVs) {\n    assert(!Dbg->getSDNodes().empty() &&\n           \"Salvaged DbgValue should depend on a new SDNode\");\n    AddDbgValue(Dbg, false);\n  }\n}\n\n/// Creates a SDDbgLabel node.\nSDDbgLabel *SelectionDAG::getDbgLabel(DILabel *Label,\n                                      const DebugLoc &DL, unsigned O) {\n  assert(cast<DILabel>(Label)->isValidLocationForIntrinsic(DL) &&\n         \"Expected inlined-at fields to agree\");\n  return new (DbgInfo->getAlloc()) SDDbgLabel(Label, DL, O);\n}\n\nnamespace {\n\n/// RAUWUpdateListener - Helper for ReplaceAllUsesWith - When the node\n/// pointed to by a use iterator is deleted, increment the use iterator\n/// so that it doesn't dangle.\n///\nclass RAUWUpdateListener : public SelectionDAG::DAGUpdateListener {\n  SDNode::use_iterator &UI;\n  SDNode::use_iterator &UE;\n\n  void NodeDeleted(SDNode *N, SDNode *E) override {\n    // Increment the iterator as needed.\n    while (UI != UE && N == *UI)\n      ++UI;\n  }\n\npublic:\n  RAUWUpdateListener(SelectionDAG &d,\n                     SDNode::use_iterator &ui,\n                     SDNode::use_iterator &ue)\n    : SelectionDAG::DAGUpdateListener(d), UI(ui), UE(ue) {}\n};\n\n} // end anonymous namespace\n\n/// ReplaceAllUsesWith - Modify anything using 'From' to use 'To' instead.\n/// This can cause recursive merging of nodes in the DAG.\n///\n/// This version assumes From has a single result value.\n///\nvoid SelectionDAG::ReplaceAllUsesWith(SDValue FromN, SDValue To) {\n  SDNode *From = FromN.getNode();\n  assert(From->getNumValues() == 1 && FromN.getResNo() == 0 &&\n         \"Cannot replace with this method!\");\n  assert(From != To.getNode() && \"Cannot replace uses of with self\");\n\n  // Preserve Debug Values\n  transferDbgValues(FromN, To);\n\n  // Iterate over all the existing uses of From. New uses will be added\n  // to the beginning of the use list, which we avoid visiting.\n  // This specifically avoids visiting uses of From that arise while the\n  // replacement is happening, because any such uses would be the result\n  // of CSE: If an existing node looks like From after one of its operands\n  // is replaced by To, we don't want to replace of all its users with To\n  // too. See PR3018 for more info.\n  SDNode::use_iterator UI = From->use_begin(), UE = From->use_end();\n  RAUWUpdateListener Listener(*this, UI, UE);\n  while (UI != UE) {\n    SDNode *User = *UI;\n\n    // This node is about to morph, remove its old self from the CSE maps.\n    RemoveNodeFromCSEMaps(User);\n\n    // A user can appear in a use list multiple times, and when this\n    // happens the uses are usually next to each other in the list.\n    // To help reduce the number of CSE recomputations, process all\n    // the uses of this user that we can find this way.\n    do {\n      SDUse &Use = UI.getUse();\n      ++UI;\n      Use.set(To);\n      if (To->isDivergent() != From->isDivergent())\n        updateDivergence(User);\n    } while (UI != UE && *UI == User);\n    // Now that we have modified User, add it back to the CSE maps.  If it\n    // already exists there, recursively merge the results together.\n    AddModifiedNodeToCSEMaps(User);\n  }\n\n  // If we just RAUW'd the root, take note.\n  if (FromN == getRoot())\n    setRoot(To);\n}\n\n/// ReplaceAllUsesWith - Modify anything using 'From' to use 'To' instead.\n/// This can cause recursive merging of nodes in the DAG.\n///\n/// This version assumes that for each value of From, there is a\n/// corresponding value in To in the same position with the same type.\n///\nvoid SelectionDAG::ReplaceAllUsesWith(SDNode *From, SDNode *To) {\n#ifndef NDEBUG\n  for (unsigned i = 0, e = From->getNumValues(); i != e; ++i)\n    assert((!From->hasAnyUseOfValue(i) ||\n            From->getValueType(i) == To->getValueType(i)) &&\n           \"Cannot use this version of ReplaceAllUsesWith!\");\n#endif\n\n  // Handle the trivial case.\n  if (From == To)\n    return;\n\n  // Preserve Debug Info. Only do this if there's a use.\n  for (unsigned i = 0, e = From->getNumValues(); i != e; ++i)\n    if (From->hasAnyUseOfValue(i)) {\n      assert((i < To->getNumValues()) && \"Invalid To location\");\n      transferDbgValues(SDValue(From, i), SDValue(To, i));\n    }\n\n  // Iterate over just the existing users of From. See the comments in\n  // the ReplaceAllUsesWith above.\n  SDNode::use_iterator UI = From->use_begin(), UE = From->use_end();\n  RAUWUpdateListener Listener(*this, UI, UE);\n  while (UI != UE) {\n    SDNode *User = *UI;\n\n    // This node is about to morph, remove its old self from the CSE maps.\n    RemoveNodeFromCSEMaps(User);\n\n    // A user can appear in a use list multiple times, and when this\n    // happens the uses are usually next to each other in the list.\n    // To help reduce the number of CSE recomputations, process all\n    // the uses of this user that we can find this way.\n    do {\n      SDUse &Use = UI.getUse();\n      ++UI;\n      Use.setNode(To);\n      if (To->isDivergent() != From->isDivergent())\n        updateDivergence(User);\n    } while (UI != UE && *UI == User);\n\n    // Now that we have modified User, add it back to the CSE maps.  If it\n    // already exists there, recursively merge the results together.\n    AddModifiedNodeToCSEMaps(User);\n  }\n\n  // If we just RAUW'd the root, take note.\n  if (From == getRoot().getNode())\n    setRoot(SDValue(To, getRoot().getResNo()));\n}\n\n/// ReplaceAllUsesWith - Modify anything using 'From' to use 'To' instead.\n/// This can cause recursive merging of nodes in the DAG.\n///\n/// This version can replace From with any result values.  To must match the\n/// number and types of values returned by From.\nvoid SelectionDAG::ReplaceAllUsesWith(SDNode *From, const SDValue *To) {\n  if (From->getNumValues() == 1)  // Handle the simple case efficiently.\n    return ReplaceAllUsesWith(SDValue(From, 0), To[0]);\n\n  // Preserve Debug Info.\n  for (unsigned i = 0, e = From->getNumValues(); i != e; ++i)\n    transferDbgValues(SDValue(From, i), To[i]);\n\n  // Iterate over just the existing users of From. See the comments in\n  // the ReplaceAllUsesWith above.\n  SDNode::use_iterator UI = From->use_begin(), UE = From->use_end();\n  RAUWUpdateListener Listener(*this, UI, UE);\n  while (UI != UE) {\n    SDNode *User = *UI;\n\n    // This node is about to morph, remove its old self from the CSE maps.\n    RemoveNodeFromCSEMaps(User);\n\n    // A user can appear in a use list multiple times, and when this happens the\n    // uses are usually next to each other in the list.  To help reduce the\n    // number of CSE and divergence recomputations, process all the uses of this\n    // user that we can find this way.\n    bool To_IsDivergent = false;\n    do {\n      SDUse &Use = UI.getUse();\n      const SDValue &ToOp = To[Use.getResNo()];\n      ++UI;\n      Use.set(ToOp);\n      To_IsDivergent |= ToOp->isDivergent();\n    } while (UI != UE && *UI == User);\n\n    if (To_IsDivergent != From->isDivergent())\n      updateDivergence(User);\n\n    // Now that we have modified User, add it back to the CSE maps.  If it\n    // already exists there, recursively merge the results together.\n    AddModifiedNodeToCSEMaps(User);\n  }\n\n  // If we just RAUW'd the root, take note.\n  if (From == getRoot().getNode())\n    setRoot(SDValue(To[getRoot().getResNo()]));\n}\n\n/// ReplaceAllUsesOfValueWith - Replace any uses of From with To, leaving\n/// uses of other values produced by From.getNode() alone.  The Deleted\n/// vector is handled the same way as for ReplaceAllUsesWith.\nvoid SelectionDAG::ReplaceAllUsesOfValueWith(SDValue From, SDValue To){\n  // Handle the really simple, really trivial case efficiently.\n  if (From == To) return;\n\n  // Handle the simple, trivial, case efficiently.\n  if (From.getNode()->getNumValues() == 1) {\n    ReplaceAllUsesWith(From, To);\n    return;\n  }\n\n  // Preserve Debug Info.\n  transferDbgValues(From, To);\n\n  // Iterate over just the existing users of From. See the comments in\n  // the ReplaceAllUsesWith above.\n  SDNode::use_iterator UI = From.getNode()->use_begin(),\n                       UE = From.getNode()->use_end();\n  RAUWUpdateListener Listener(*this, UI, UE);\n  while (UI != UE) {\n    SDNode *User = *UI;\n    bool UserRemovedFromCSEMaps = false;\n\n    // A user can appear in a use list multiple times, and when this\n    // happens the uses are usually next to each other in the list.\n    // To help reduce the number of CSE recomputations, process all\n    // the uses of this user that we can find this way.\n    do {\n      SDUse &Use = UI.getUse();\n\n      // Skip uses of different values from the same node.\n      if (Use.getResNo() != From.getResNo()) {\n        ++UI;\n        continue;\n      }\n\n      // If this node hasn't been modified yet, it's still in the CSE maps,\n      // so remove its old self from the CSE maps.\n      if (!UserRemovedFromCSEMaps) {\n        RemoveNodeFromCSEMaps(User);\n        UserRemovedFromCSEMaps = true;\n      }\n\n      ++UI;\n      Use.set(To);\n      if (To->isDivergent() != From->isDivergent())\n        updateDivergence(User);\n    } while (UI != UE && *UI == User);\n    // We are iterating over all uses of the From node, so if a use\n    // doesn't use the specific value, no changes are made.\n    if (!UserRemovedFromCSEMaps)\n      continue;\n\n    // Now that we have modified User, add it back to the CSE maps.  If it\n    // already exists there, recursively merge the results together.\n    AddModifiedNodeToCSEMaps(User);\n  }\n\n  // If we just RAUW'd the root, take note.\n  if (From == getRoot())\n    setRoot(To);\n}\n\nnamespace {\n\n  /// UseMemo - This class is used by SelectionDAG::ReplaceAllUsesOfValuesWith\n  /// to record information about a use.\n  struct UseMemo {\n    SDNode *User;\n    unsigned Index;\n    SDUse *Use;\n  };\n\n  /// operator< - Sort Memos by User.\n  bool operator<(const UseMemo &L, const UseMemo &R) {\n    return (intptr_t)L.User < (intptr_t)R.User;\n  }\n\n} // end anonymous namespace\n\nbool SelectionDAG::calculateDivergence(SDNode *N) {\n  if (TLI->isSDNodeAlwaysUniform(N)) {\n    assert(!TLI->isSDNodeSourceOfDivergence(N, FLI, DA) &&\n           \"Conflicting divergence information!\");\n    return false;\n  }\n  if (TLI->isSDNodeSourceOfDivergence(N, FLI, DA))\n    return true;\n  for (auto &Op : N->ops()) {\n    if (Op.Val.getValueType() != MVT::Other && Op.getNode()->isDivergent())\n      return true;\n  }\n  return false;\n}\n\nvoid SelectionDAG::updateDivergence(SDNode *N) {\n  SmallVector<SDNode *, 16> Worklist(1, N);\n  do {\n    N = Worklist.pop_back_val();\n    bool IsDivergent = calculateDivergence(N);\n    if (N->SDNodeBits.IsDivergent != IsDivergent) {\n      N->SDNodeBits.IsDivergent = IsDivergent;\n      llvm::append_range(Worklist, N->uses());\n    }\n  } while (!Worklist.empty());\n}\n\nvoid SelectionDAG::CreateTopologicalOrder(std::vector<SDNode *> &Order) {\n  DenseMap<SDNode *, unsigned> Degree;\n  Order.reserve(AllNodes.size());\n  for (auto &N : allnodes()) {\n    unsigned NOps = N.getNumOperands();\n    Degree[&N] = NOps;\n    if (0 == NOps)\n      Order.push_back(&N);\n  }\n  for (size_t I = 0; I != Order.size(); ++I) {\n    SDNode *N = Order[I];\n    for (auto U : N->uses()) {\n      unsigned &UnsortedOps = Degree[U];\n      if (0 == --UnsortedOps)\n        Order.push_back(U);\n    }\n  }\n}\n\n#ifndef NDEBUG\nvoid SelectionDAG::VerifyDAGDiverence() {\n  std::vector<SDNode *> TopoOrder;\n  CreateTopologicalOrder(TopoOrder);\n  for (auto *N : TopoOrder) {\n    assert(calculateDivergence(N) == N->isDivergent() &&\n           \"Divergence bit inconsistency detected\");\n  }\n}\n#endif\n\n/// ReplaceAllUsesOfValuesWith - Replace any uses of From with To, leaving\n/// uses of other values produced by From.getNode() alone.  The same value\n/// may appear in both the From and To list.  The Deleted vector is\n/// handled the same way as for ReplaceAllUsesWith.\nvoid SelectionDAG::ReplaceAllUsesOfValuesWith(const SDValue *From,\n                                              const SDValue *To,\n                                              unsigned Num){\n  // Handle the simple, trivial case efficiently.\n  if (Num == 1)\n    return ReplaceAllUsesOfValueWith(*From, *To);\n\n  transferDbgValues(*From, *To);\n\n  // Read up all the uses and make records of them. This helps\n  // processing new uses that are introduced during the\n  // replacement process.\n  SmallVector<UseMemo, 4> Uses;\n  for (unsigned i = 0; i != Num; ++i) {\n    unsigned FromResNo = From[i].getResNo();\n    SDNode *FromNode = From[i].getNode();\n    for (SDNode::use_iterator UI = FromNode->use_begin(),\n         E = FromNode->use_end(); UI != E; ++UI) {\n      SDUse &Use = UI.getUse();\n      if (Use.getResNo() == FromResNo) {\n        UseMemo Memo = { *UI, i, &Use };\n        Uses.push_back(Memo);\n      }\n    }\n  }\n\n  // Sort the uses, so that all the uses from a given User are together.\n  llvm::sort(Uses);\n\n  for (unsigned UseIndex = 0, UseIndexEnd = Uses.size();\n       UseIndex != UseIndexEnd; ) {\n    // We know that this user uses some value of From.  If it is the right\n    // value, update it.\n    SDNode *User = Uses[UseIndex].User;\n\n    // This node is about to morph, remove its old self from the CSE maps.\n    RemoveNodeFromCSEMaps(User);\n\n    // The Uses array is sorted, so all the uses for a given User\n    // are next to each other in the list.\n    // To help reduce the number of CSE recomputations, process all\n    // the uses of this user that we can find this way.\n    do {\n      unsigned i = Uses[UseIndex].Index;\n      SDUse &Use = *Uses[UseIndex].Use;\n      ++UseIndex;\n\n      Use.set(To[i]);\n    } while (UseIndex != UseIndexEnd && Uses[UseIndex].User == User);\n\n    // Now that we have modified User, add it back to the CSE maps.  If it\n    // already exists there, recursively merge the results together.\n    AddModifiedNodeToCSEMaps(User);\n  }\n}\n\n/// AssignTopologicalOrder - Assign a unique node id for each node in the DAG\n/// based on their topological order. It returns the maximum id and a vector\n/// of the SDNodes* in assigned order by reference.\nunsigned SelectionDAG::AssignTopologicalOrder() {\n  unsigned DAGSize = 0;\n\n  // SortedPos tracks the progress of the algorithm. Nodes before it are\n  // sorted, nodes after it are unsorted. When the algorithm completes\n  // it is at the end of the list.\n  allnodes_iterator SortedPos = allnodes_begin();\n\n  // Visit all the nodes. Move nodes with no operands to the front of\n  // the list immediately. Annotate nodes that do have operands with their\n  // operand count. Before we do this, the Node Id fields of the nodes\n  // may contain arbitrary values. After, the Node Id fields for nodes\n  // before SortedPos will contain the topological sort index, and the\n  // Node Id fields for nodes At SortedPos and after will contain the\n  // count of outstanding operands.\n  for (allnodes_iterator I = allnodes_begin(),E = allnodes_end(); I != E; ) {\n    SDNode *N = &*I++;\n    checkForCycles(N, this);\n    unsigned Degree = N->getNumOperands();\n    if (Degree == 0) {\n      // A node with no uses, add it to the result array immediately.\n      N->setNodeId(DAGSize++);\n      allnodes_iterator Q(N);\n      if (Q != SortedPos)\n        SortedPos = AllNodes.insert(SortedPos, AllNodes.remove(Q));\n      assert(SortedPos != AllNodes.end() && \"Overran node list\");\n      ++SortedPos;\n    } else {\n      // Temporarily use the Node Id as scratch space for the degree count.\n      N->setNodeId(Degree);\n    }\n  }\n\n  // Visit all the nodes. As we iterate, move nodes into sorted order,\n  // such that by the time the end is reached all nodes will be sorted.\n  for (SDNode &Node : allnodes()) {\n    SDNode *N = &Node;\n    checkForCycles(N, this);\n    // N is in sorted position, so all its uses have one less operand\n    // that needs to be sorted.\n    for (SDNode *P : N->uses()) {\n      unsigned Degree = P->getNodeId();\n      assert(Degree != 0 && \"Invalid node degree\");\n      --Degree;\n      if (Degree == 0) {\n        // All of P's operands are sorted, so P may sorted now.\n        P->setNodeId(DAGSize++);\n        if (P->getIterator() != SortedPos)\n          SortedPos = AllNodes.insert(SortedPos, AllNodes.remove(P));\n        assert(SortedPos != AllNodes.end() && \"Overran node list\");\n        ++SortedPos;\n      } else {\n        // Update P's outstanding operand count.\n        P->setNodeId(Degree);\n      }\n    }\n    if (Node.getIterator() == SortedPos) {\n#ifndef NDEBUG\n      allnodes_iterator I(N);\n      SDNode *S = &*++I;\n      dbgs() << \"Overran sorted position:\\n\";\n      S->dumprFull(this); dbgs() << \"\\n\";\n      dbgs() << \"Checking if this is due to cycles\\n\";\n      checkForCycles(this, true);\n#endif\n      llvm_unreachable(nullptr);\n    }\n  }\n\n  assert(SortedPos == AllNodes.end() &&\n         \"Topological sort incomplete!\");\n  assert(AllNodes.front().getOpcode() == ISD::EntryToken &&\n         \"First node in topological sort is not the entry token!\");\n  assert(AllNodes.front().getNodeId() == 0 &&\n         \"First node in topological sort has non-zero id!\");\n  assert(AllNodes.front().getNumOperands() == 0 &&\n         \"First node in topological sort has operands!\");\n  assert(AllNodes.back().getNodeId() == (int)DAGSize-1 &&\n         \"Last node in topologic sort has unexpected id!\");\n  assert(AllNodes.back().use_empty() &&\n         \"Last node in topologic sort has users!\");\n  assert(DAGSize == allnodes_size() && \"Node count mismatch!\");\n  return DAGSize;\n}\n\n/// AddDbgValue - Add a dbg_value SDNode. If SD is non-null that means the\n/// value is produced by SD.\nvoid SelectionDAG::AddDbgValue(SDDbgValue *DB, bool isParameter) {\n  for (SDNode *SD : DB->getSDNodes()) {\n    if (!SD)\n      continue;\n    assert(DbgInfo->getSDDbgValues(SD).empty() || SD->getHasDebugValue());\n    SD->setHasDebugValue(true);\n  }\n  DbgInfo->add(DB, isParameter);\n}\n\nvoid SelectionDAG::AddDbgLabel(SDDbgLabel *DB) { DbgInfo->add(DB); }\n\nSDValue SelectionDAG::makeEquivalentMemoryOrdering(SDValue OldChain,\n                                                   SDValue NewMemOpChain) {\n  assert(isa<MemSDNode>(NewMemOpChain) && \"Expected a memop node\");\n  assert(NewMemOpChain.getValueType() == MVT::Other && \"Expected a token VT\");\n  // The new memory operation must have the same position as the old load in\n  // terms of memory dependency. Create a TokenFactor for the old load and new\n  // memory operation and update uses of the old load's output chain to use that\n  // TokenFactor.\n  if (OldChain == NewMemOpChain || OldChain.use_empty())\n    return NewMemOpChain;\n\n  SDValue TokenFactor = getNode(ISD::TokenFactor, SDLoc(OldChain), MVT::Other,\n                                OldChain, NewMemOpChain);\n  ReplaceAllUsesOfValueWith(OldChain, TokenFactor);\n  UpdateNodeOperands(TokenFactor.getNode(), OldChain, NewMemOpChain);\n  return TokenFactor;\n}\n\nSDValue SelectionDAG::makeEquivalentMemoryOrdering(LoadSDNode *OldLoad,\n                                                   SDValue NewMemOp) {\n  assert(isa<MemSDNode>(NewMemOp.getNode()) && \"Expected a memop node\");\n  SDValue OldChain = SDValue(OldLoad, 1);\n  SDValue NewMemOpChain = NewMemOp.getValue(1);\n  return makeEquivalentMemoryOrdering(OldChain, NewMemOpChain);\n}\n\nSDValue SelectionDAG::getSymbolFunctionGlobalAddress(SDValue Op,\n                                                     Function **OutFunction) {\n  assert(isa<ExternalSymbolSDNode>(Op) && \"Node should be an ExternalSymbol\");\n\n  auto *Symbol = cast<ExternalSymbolSDNode>(Op)->getSymbol();\n  auto *Module = MF->getFunction().getParent();\n  auto *Function = Module->getFunction(Symbol);\n\n  if (OutFunction != nullptr)\n      *OutFunction = Function;\n\n  if (Function != nullptr) {\n    auto PtrTy = TLI->getPointerTy(getDataLayout(), Function->getAddressSpace());\n    return getGlobalAddress(Function, SDLoc(Op), PtrTy);\n  }\n\n  std::string ErrorStr;\n  raw_string_ostream ErrorFormatter(ErrorStr);\n\n  ErrorFormatter << \"Undefined external symbol \";\n  ErrorFormatter << '\"' << Symbol << '\"';\n  ErrorFormatter.flush();\n\n  report_fatal_error(ErrorStr);\n}\n\n//===----------------------------------------------------------------------===//\n//                              SDNode Class\n//===----------------------------------------------------------------------===//\n\nbool llvm::isNullConstant(SDValue V) {\n  ConstantSDNode *Const = dyn_cast<ConstantSDNode>(V);\n  return Const != nullptr && Const->isNullValue();\n}\n\nbool llvm::isNullFPConstant(SDValue V) {\n  ConstantFPSDNode *Const = dyn_cast<ConstantFPSDNode>(V);\n  return Const != nullptr && Const->isZero() && !Const->isNegative();\n}\n\nbool llvm::isAllOnesConstant(SDValue V) {\n  ConstantSDNode *Const = dyn_cast<ConstantSDNode>(V);\n  return Const != nullptr && Const->isAllOnesValue();\n}\n\nbool llvm::isOneConstant(SDValue V) {\n  ConstantSDNode *Const = dyn_cast<ConstantSDNode>(V);\n  return Const != nullptr && Const->isOne();\n}\n\nSDValue llvm::peekThroughBitcasts(SDValue V) {\n  while (V.getOpcode() == ISD::BITCAST)\n    V = V.getOperand(0);\n  return V;\n}\n\nSDValue llvm::peekThroughOneUseBitcasts(SDValue V) {\n  while (V.getOpcode() == ISD::BITCAST && V.getOperand(0).hasOneUse())\n    V = V.getOperand(0);\n  return V;\n}\n\nSDValue llvm::peekThroughExtractSubvectors(SDValue V) {\n  while (V.getOpcode() == ISD::EXTRACT_SUBVECTOR)\n    V = V.getOperand(0);\n  return V;\n}\n\nbool llvm::isBitwiseNot(SDValue V, bool AllowUndefs) {\n  if (V.getOpcode() != ISD::XOR)\n    return false;\n  V = peekThroughBitcasts(V.getOperand(1));\n  unsigned NumBits = V.getScalarValueSizeInBits();\n  ConstantSDNode *C =\n      isConstOrConstSplat(V, AllowUndefs, /*AllowTruncation*/ true);\n  return C && (C->getAPIntValue().countTrailingOnes() >= NumBits);\n}\n\nConstantSDNode *llvm::isConstOrConstSplat(SDValue N, bool AllowUndefs,\n                                          bool AllowTruncation) {\n  if (ConstantSDNode *CN = dyn_cast<ConstantSDNode>(N))\n    return CN;\n\n  // SplatVectors can truncate their operands. Ignore that case here unless\n  // AllowTruncation is set.\n  if (N->getOpcode() == ISD::SPLAT_VECTOR) {\n    EVT VecEltVT = N->getValueType(0).getVectorElementType();\n    if (auto *CN = dyn_cast<ConstantSDNode>(N->getOperand(0))) {\n      EVT CVT = CN->getValueType(0);\n      assert(CVT.bitsGE(VecEltVT) && \"Illegal splat_vector element extension\");\n      if (AllowTruncation || CVT == VecEltVT)\n        return CN;\n    }\n  }\n\n  if (BuildVectorSDNode *BV = dyn_cast<BuildVectorSDNode>(N)) {\n    BitVector UndefElements;\n    ConstantSDNode *CN = BV->getConstantSplatNode(&UndefElements);\n\n    // BuildVectors can truncate their operands. Ignore that case here unless\n    // AllowTruncation is set.\n    if (CN && (UndefElements.none() || AllowUndefs)) {\n      EVT CVT = CN->getValueType(0);\n      EVT NSVT = N.getValueType().getScalarType();\n      assert(CVT.bitsGE(NSVT) && \"Illegal build vector element extension\");\n      if (AllowTruncation || (CVT == NSVT))\n        return CN;\n    }\n  }\n\n  return nullptr;\n}\n\nConstantSDNode *llvm::isConstOrConstSplat(SDValue N, const APInt &DemandedElts,\n                                          bool AllowUndefs,\n                                          bool AllowTruncation) {\n  if (ConstantSDNode *CN = dyn_cast<ConstantSDNode>(N))\n    return CN;\n\n  if (BuildVectorSDNode *BV = dyn_cast<BuildVectorSDNode>(N)) {\n    BitVector UndefElements;\n    ConstantSDNode *CN = BV->getConstantSplatNode(DemandedElts, &UndefElements);\n\n    // BuildVectors can truncate their operands. Ignore that case here unless\n    // AllowTruncation is set.\n    if (CN && (UndefElements.none() || AllowUndefs)) {\n      EVT CVT = CN->getValueType(0);\n      EVT NSVT = N.getValueType().getScalarType();\n      assert(CVT.bitsGE(NSVT) && \"Illegal build vector element extension\");\n      if (AllowTruncation || (CVT == NSVT))\n        return CN;\n    }\n  }\n\n  return nullptr;\n}\n\nConstantFPSDNode *llvm::isConstOrConstSplatFP(SDValue N, bool AllowUndefs) {\n  if (ConstantFPSDNode *CN = dyn_cast<ConstantFPSDNode>(N))\n    return CN;\n\n  if (BuildVectorSDNode *BV = dyn_cast<BuildVectorSDNode>(N)) {\n    BitVector UndefElements;\n    ConstantFPSDNode *CN = BV->getConstantFPSplatNode(&UndefElements);\n    if (CN && (UndefElements.none() || AllowUndefs))\n      return CN;\n  }\n\n  if (N.getOpcode() == ISD::SPLAT_VECTOR)\n    if (ConstantFPSDNode *CN = dyn_cast<ConstantFPSDNode>(N.getOperand(0)))\n      return CN;\n\n  return nullptr;\n}\n\nConstantFPSDNode *llvm::isConstOrConstSplatFP(SDValue N,\n                                              const APInt &DemandedElts,\n                                              bool AllowUndefs) {\n  if (ConstantFPSDNode *CN = dyn_cast<ConstantFPSDNode>(N))\n    return CN;\n\n  if (BuildVectorSDNode *BV = dyn_cast<BuildVectorSDNode>(N)) {\n    BitVector UndefElements;\n    ConstantFPSDNode *CN =\n        BV->getConstantFPSplatNode(DemandedElts, &UndefElements);\n    if (CN && (UndefElements.none() || AllowUndefs))\n      return CN;\n  }\n\n  return nullptr;\n}\n\nbool llvm::isNullOrNullSplat(SDValue N, bool AllowUndefs) {\n  // TODO: may want to use peekThroughBitcast() here.\n  ConstantSDNode *C = isConstOrConstSplat(N, AllowUndefs);\n  return C && C->isNullValue();\n}\n\nbool llvm::isOneOrOneSplat(SDValue N, bool AllowUndefs) {\n  // TODO: may want to use peekThroughBitcast() here.\n  unsigned BitWidth = N.getScalarValueSizeInBits();\n  ConstantSDNode *C = isConstOrConstSplat(N, AllowUndefs);\n  return C && C->isOne() && C->getValueSizeInBits(0) == BitWidth;\n}\n\nbool llvm::isAllOnesOrAllOnesSplat(SDValue N, bool AllowUndefs) {\n  N = peekThroughBitcasts(N);\n  unsigned BitWidth = N.getScalarValueSizeInBits();\n  ConstantSDNode *C = isConstOrConstSplat(N, AllowUndefs);\n  return C && C->isAllOnesValue() && C->getValueSizeInBits(0) == BitWidth;\n}\n\nHandleSDNode::~HandleSDNode() {\n  DropOperands();\n}\n\nGlobalAddressSDNode::GlobalAddressSDNode(unsigned Opc, unsigned Order,\n                                         const DebugLoc &DL,\n                                         const GlobalValue *GA, EVT VT,\n                                         int64_t o, unsigned TF)\n    : SDNode(Opc, Order, DL, getSDVTList(VT)), Offset(o), TargetFlags(TF) {\n  TheGlobal = GA;\n}\n\nAddrSpaceCastSDNode::AddrSpaceCastSDNode(unsigned Order, const DebugLoc &dl,\n                                         EVT VT, unsigned SrcAS,\n                                         unsigned DestAS)\n    : SDNode(ISD::ADDRSPACECAST, Order, dl, getSDVTList(VT)),\n      SrcAddrSpace(SrcAS), DestAddrSpace(DestAS) {}\n\nMemSDNode::MemSDNode(unsigned Opc, unsigned Order, const DebugLoc &dl,\n                     SDVTList VTs, EVT memvt, MachineMemOperand *mmo)\n    : SDNode(Opc, Order, dl, VTs), MemoryVT(memvt), MMO(mmo) {\n  MemSDNodeBits.IsVolatile = MMO->isVolatile();\n  MemSDNodeBits.IsNonTemporal = MMO->isNonTemporal();\n  MemSDNodeBits.IsDereferenceable = MMO->isDereferenceable();\n  MemSDNodeBits.IsInvariant = MMO->isInvariant();\n\n  // We check here that the size of the memory operand fits within the size of\n  // the MMO. This is because the MMO might indicate only a possible address\n  // range instead of specifying the affected memory addresses precisely.\n  // TODO: Make MachineMemOperands aware of scalable vectors.\n  assert(memvt.getStoreSize().getKnownMinSize() <= MMO->getSize() &&\n         \"Size mismatch!\");\n}\n\n/// Profile - Gather unique data for the node.\n///\nvoid SDNode::Profile(FoldingSetNodeID &ID) const {\n  AddNodeIDNode(ID, this);\n}\n\nnamespace {\n\n  struct EVTArray {\n    std::vector<EVT> VTs;\n\n    EVTArray() {\n      VTs.reserve(MVT::LAST_VALUETYPE);\n      for (unsigned i = 0; i < MVT::LAST_VALUETYPE; ++i)\n        VTs.push_back(MVT((MVT::SimpleValueType)i));\n    }\n  };\n\n} // end anonymous namespace\n\nstatic ManagedStatic<std::set<EVT, EVT::compareRawBits>> EVTs;\nstatic ManagedStatic<EVTArray> SimpleVTArray;\nstatic ManagedStatic<sys::SmartMutex<true>> VTMutex;\n\n/// getValueTypeList - Return a pointer to the specified value type.\n///\nconst EVT *SDNode::getValueTypeList(EVT VT) {\n  if (VT.isExtended()) {\n    sys::SmartScopedLock<true> Lock(*VTMutex);\n    return &(*EVTs->insert(VT).first);\n  } else {\n    assert(VT.getSimpleVT() < MVT::LAST_VALUETYPE &&\n           \"Value type out of range!\");\n    return &SimpleVTArray->VTs[VT.getSimpleVT().SimpleTy];\n  }\n}\n\n/// hasNUsesOfValue - Return true if there are exactly NUSES uses of the\n/// indicated value.  This method ignores uses of other values defined by this\n/// operation.\nbool SDNode::hasNUsesOfValue(unsigned NUses, unsigned Value) const {\n  assert(Value < getNumValues() && \"Bad value!\");\n\n  // TODO: Only iterate over uses of a given value of the node\n  for (SDNode::use_iterator UI = use_begin(), E = use_end(); UI != E; ++UI) {\n    if (UI.getUse().getResNo() == Value) {\n      if (NUses == 0)\n        return false;\n      --NUses;\n    }\n  }\n\n  // Found exactly the right number of uses?\n  return NUses == 0;\n}\n\n/// hasAnyUseOfValue - Return true if there are any use of the indicated\n/// value. This method ignores uses of other values defined by this operation.\nbool SDNode::hasAnyUseOfValue(unsigned Value) const {\n  assert(Value < getNumValues() && \"Bad value!\");\n\n  for (SDNode::use_iterator UI = use_begin(), E = use_end(); UI != E; ++UI)\n    if (UI.getUse().getResNo() == Value)\n      return true;\n\n  return false;\n}\n\n/// isOnlyUserOf - Return true if this node is the only use of N.\nbool SDNode::isOnlyUserOf(const SDNode *N) const {\n  bool Seen = false;\n  for (SDNode::use_iterator I = N->use_begin(), E = N->use_end(); I != E; ++I) {\n    SDNode *User = *I;\n    if (User == this)\n      Seen = true;\n    else\n      return false;\n  }\n\n  return Seen;\n}\n\n/// Return true if the only users of N are contained in Nodes.\nbool SDNode::areOnlyUsersOf(ArrayRef<const SDNode *> Nodes, const SDNode *N) {\n  bool Seen = false;\n  for (SDNode::use_iterator I = N->use_begin(), E = N->use_end(); I != E; ++I) {\n    SDNode *User = *I;\n    if (llvm::is_contained(Nodes, User))\n      Seen = true;\n    else\n      return false;\n  }\n\n  return Seen;\n}\n\n/// isOperand - Return true if this node is an operand of N.\nbool SDValue::isOperandOf(const SDNode *N) const {\n  return is_contained(N->op_values(), *this);\n}\n\nbool SDNode::isOperandOf(const SDNode *N) const {\n  return any_of(N->op_values(),\n                [this](SDValue Op) { return this == Op.getNode(); });\n}\n\n/// reachesChainWithoutSideEffects - Return true if this operand (which must\n/// be a chain) reaches the specified operand without crossing any\n/// side-effecting instructions on any chain path.  In practice, this looks\n/// through token factors and non-volatile loads.  In order to remain efficient,\n/// this only looks a couple of nodes in, it does not do an exhaustive search.\n///\n/// Note that we only need to examine chains when we're searching for\n/// side-effects; SelectionDAG requires that all side-effects are represented\n/// by chains, even if another operand would force a specific ordering. This\n/// constraint is necessary to allow transformations like splitting loads.\nbool SDValue::reachesChainWithoutSideEffects(SDValue Dest,\n                                             unsigned Depth) const {\n  if (*this == Dest) return true;\n\n  // Don't search too deeply, we just want to be able to see through\n  // TokenFactor's etc.\n  if (Depth == 0) return false;\n\n  // If this is a token factor, all inputs to the TF happen in parallel.\n  if (getOpcode() == ISD::TokenFactor) {\n    // First, try a shallow search.\n    if (is_contained((*this)->ops(), Dest)) {\n      // We found the chain we want as an operand of this TokenFactor.\n      // Essentially, we reach the chain without side-effects if we could\n      // serialize the TokenFactor into a simple chain of operations with\n      // Dest as the last operation. This is automatically true if the\n      // chain has one use: there are no other ordering constraints.\n      // If the chain has more than one use, we give up: some other\n      // use of Dest might force a side-effect between Dest and the current\n      // node.\n      if (Dest.hasOneUse())\n        return true;\n    }\n    // Next, try a deep search: check whether every operand of the TokenFactor\n    // reaches Dest.\n    return llvm::all_of((*this)->ops(), [=](SDValue Op) {\n      return Op.reachesChainWithoutSideEffects(Dest, Depth - 1);\n    });\n  }\n\n  // Loads don't have side effects, look through them.\n  if (LoadSDNode *Ld = dyn_cast<LoadSDNode>(*this)) {\n    if (Ld->isUnordered())\n      return Ld->getChain().reachesChainWithoutSideEffects(Dest, Depth-1);\n  }\n  return false;\n}\n\nbool SDNode::hasPredecessor(const SDNode *N) const {\n  SmallPtrSet<const SDNode *, 32> Visited;\n  SmallVector<const SDNode *, 16> Worklist;\n  Worklist.push_back(this);\n  return hasPredecessorHelper(N, Visited, Worklist);\n}\n\nvoid SDNode::intersectFlagsWith(const SDNodeFlags Flags) {\n  this->Flags.intersectWith(Flags);\n}\n\nSDValue\nSelectionDAG::matchBinOpReduction(SDNode *Extract, ISD::NodeType &BinOp,\n                                  ArrayRef<ISD::NodeType> CandidateBinOps,\n                                  bool AllowPartials) {\n  // The pattern must end in an extract from index 0.\n  if (Extract->getOpcode() != ISD::EXTRACT_VECTOR_ELT ||\n      !isNullConstant(Extract->getOperand(1)))\n    return SDValue();\n\n  // Match against one of the candidate binary ops.\n  SDValue Op = Extract->getOperand(0);\n  if (llvm::none_of(CandidateBinOps, [Op](ISD::NodeType BinOp) {\n        return Op.getOpcode() == unsigned(BinOp);\n      }))\n    return SDValue();\n\n  // Floating-point reductions may require relaxed constraints on the final step\n  // of the reduction because they may reorder intermediate operations.\n  unsigned CandidateBinOp = Op.getOpcode();\n  if (Op.getValueType().isFloatingPoint()) {\n    SDNodeFlags Flags = Op->getFlags();\n    switch (CandidateBinOp) {\n    case ISD::FADD:\n      if (!Flags.hasNoSignedZeros() || !Flags.hasAllowReassociation())\n        return SDValue();\n      break;\n    default:\n      llvm_unreachable(\"Unhandled FP opcode for binop reduction\");\n    }\n  }\n\n  // Matching failed - attempt to see if we did enough stages that a partial\n  // reduction from a subvector is possible.\n  auto PartialReduction = [&](SDValue Op, unsigned NumSubElts) {\n    if (!AllowPartials || !Op)\n      return SDValue();\n    EVT OpVT = Op.getValueType();\n    EVT OpSVT = OpVT.getScalarType();\n    EVT SubVT = EVT::getVectorVT(*getContext(), OpSVT, NumSubElts);\n    if (!TLI->isExtractSubvectorCheap(SubVT, OpVT, 0))\n      return SDValue();\n    BinOp = (ISD::NodeType)CandidateBinOp;\n    return getNode(ISD::EXTRACT_SUBVECTOR, SDLoc(Op), SubVT, Op,\n                   getVectorIdxConstant(0, SDLoc(Op)));\n  };\n\n  // At each stage, we're looking for something that looks like:\n  // %s = shufflevector <8 x i32> %op, <8 x i32> undef,\n  //                    <8 x i32> <i32 2, i32 3, i32 undef, i32 undef,\n  //                               i32 undef, i32 undef, i32 undef, i32 undef>\n  // %a = binop <8 x i32> %op, %s\n  // Where the mask changes according to the stage. E.g. for a 3-stage pyramid,\n  // we expect something like:\n  // <4,5,6,7,u,u,u,u>\n  // <2,3,u,u,u,u,u,u>\n  // <1,u,u,u,u,u,u,u>\n  // While a partial reduction match would be:\n  // <2,3,u,u,u,u,u,u>\n  // <1,u,u,u,u,u,u,u>\n  unsigned Stages = Log2_32(Op.getValueType().getVectorNumElements());\n  SDValue PrevOp;\n  for (unsigned i = 0; i < Stages; ++i) {\n    unsigned MaskEnd = (1 << i);\n\n    if (Op.getOpcode() != CandidateBinOp)\n      return PartialReduction(PrevOp, MaskEnd);\n\n    SDValue Op0 = Op.getOperand(0);\n    SDValue Op1 = Op.getOperand(1);\n\n    ShuffleVectorSDNode *Shuffle = dyn_cast<ShuffleVectorSDNode>(Op0);\n    if (Shuffle) {\n      Op = Op1;\n    } else {\n      Shuffle = dyn_cast<ShuffleVectorSDNode>(Op1);\n      Op = Op0;\n    }\n\n    // The first operand of the shuffle should be the same as the other operand\n    // of the binop.\n    if (!Shuffle || Shuffle->getOperand(0) != Op)\n      return PartialReduction(PrevOp, MaskEnd);\n\n    // Verify the shuffle has the expected (at this stage of the pyramid) mask.\n    for (int Index = 0; Index < (int)MaskEnd; ++Index)\n      if (Shuffle->getMaskElt(Index) != (int)(MaskEnd + Index))\n        return PartialReduction(PrevOp, MaskEnd);\n\n    PrevOp = Op;\n  }\n\n  // Handle subvector reductions, which tend to appear after the shuffle\n  // reduction stages.\n  while (Op.getOpcode() == CandidateBinOp) {\n    unsigned NumElts = Op.getValueType().getVectorNumElements();\n    SDValue Op0 = Op.getOperand(0);\n    SDValue Op1 = Op.getOperand(1);\n    if (Op0.getOpcode() != ISD::EXTRACT_SUBVECTOR ||\n        Op1.getOpcode() != ISD::EXTRACT_SUBVECTOR ||\n        Op0.getOperand(0) != Op1.getOperand(0))\n      break;\n    SDValue Src = Op0.getOperand(0);\n    unsigned NumSrcElts = Src.getValueType().getVectorNumElements();\n    if (NumSrcElts != (2 * NumElts))\n      break;\n    if (!(Op0.getConstantOperandAPInt(1) == 0 &&\n          Op1.getConstantOperandAPInt(1) == NumElts) &&\n        !(Op1.getConstantOperandAPInt(1) == 0 &&\n          Op0.getConstantOperandAPInt(1) == NumElts))\n      break;\n    Op = Src;\n  }\n\n  BinOp = (ISD::NodeType)CandidateBinOp;\n  return Op;\n}\n\nSDValue SelectionDAG::UnrollVectorOp(SDNode *N, unsigned ResNE) {\n  assert(N->getNumValues() == 1 &&\n         \"Can't unroll a vector with multiple results!\");\n\n  EVT VT = N->getValueType(0);\n  unsigned NE = VT.getVectorNumElements();\n  EVT EltVT = VT.getVectorElementType();\n  SDLoc dl(N);\n\n  SmallVector<SDValue, 8> Scalars;\n  SmallVector<SDValue, 4> Operands(N->getNumOperands());\n\n  // If ResNE is 0, fully unroll the vector op.\n  if (ResNE == 0)\n    ResNE = NE;\n  else if (NE > ResNE)\n    NE = ResNE;\n\n  unsigned i;\n  for (i= 0; i != NE; ++i) {\n    for (unsigned j = 0, e = N->getNumOperands(); j != e; ++j) {\n      SDValue Operand = N->getOperand(j);\n      EVT OperandVT = Operand.getValueType();\n      if (OperandVT.isVector()) {\n        // A vector operand; extract a single element.\n        EVT OperandEltVT = OperandVT.getVectorElementType();\n        Operands[j] = getNode(ISD::EXTRACT_VECTOR_ELT, dl, OperandEltVT,\n                              Operand, getVectorIdxConstant(i, dl));\n      } else {\n        // A scalar operand; just use it as is.\n        Operands[j] = Operand;\n      }\n    }\n\n    switch (N->getOpcode()) {\n    default: {\n      Scalars.push_back(getNode(N->getOpcode(), dl, EltVT, Operands,\n                                N->getFlags()));\n      break;\n    }\n    case ISD::VSELECT:\n      Scalars.push_back(getNode(ISD::SELECT, dl, EltVT, Operands));\n      break;\n    case ISD::SHL:\n    case ISD::SRA:\n    case ISD::SRL:\n    case ISD::ROTL:\n    case ISD::ROTR:\n      Scalars.push_back(getNode(N->getOpcode(), dl, EltVT, Operands[0],\n                               getShiftAmountOperand(Operands[0].getValueType(),\n                                                     Operands[1])));\n      break;\n    case ISD::SIGN_EXTEND_INREG: {\n      EVT ExtVT = cast<VTSDNode>(Operands[1])->getVT().getVectorElementType();\n      Scalars.push_back(getNode(N->getOpcode(), dl, EltVT,\n                                Operands[0],\n                                getValueType(ExtVT)));\n    }\n    }\n  }\n\n  for (; i < ResNE; ++i)\n    Scalars.push_back(getUNDEF(EltVT));\n\n  EVT VecVT = EVT::getVectorVT(*getContext(), EltVT, ResNE);\n  return getBuildVector(VecVT, dl, Scalars);\n}\n\nstd::pair<SDValue, SDValue> SelectionDAG::UnrollVectorOverflowOp(\n    SDNode *N, unsigned ResNE) {\n  unsigned Opcode = N->getOpcode();\n  assert((Opcode == ISD::UADDO || Opcode == ISD::SADDO ||\n          Opcode == ISD::USUBO || Opcode == ISD::SSUBO ||\n          Opcode == ISD::UMULO || Opcode == ISD::SMULO) &&\n         \"Expected an overflow opcode\");\n\n  EVT ResVT = N->getValueType(0);\n  EVT OvVT = N->getValueType(1);\n  EVT ResEltVT = ResVT.getVectorElementType();\n  EVT OvEltVT = OvVT.getVectorElementType();\n  SDLoc dl(N);\n\n  // If ResNE is 0, fully unroll the vector op.\n  unsigned NE = ResVT.getVectorNumElements();\n  if (ResNE == 0)\n    ResNE = NE;\n  else if (NE > ResNE)\n    NE = ResNE;\n\n  SmallVector<SDValue, 8> LHSScalars;\n  SmallVector<SDValue, 8> RHSScalars;\n  ExtractVectorElements(N->getOperand(0), LHSScalars, 0, NE);\n  ExtractVectorElements(N->getOperand(1), RHSScalars, 0, NE);\n\n  EVT SVT = TLI->getSetCCResultType(getDataLayout(), *getContext(), ResEltVT);\n  SDVTList VTs = getVTList(ResEltVT, SVT);\n  SmallVector<SDValue, 8> ResScalars;\n  SmallVector<SDValue, 8> OvScalars;\n  for (unsigned i = 0; i < NE; ++i) {\n    SDValue Res = getNode(Opcode, dl, VTs, LHSScalars[i], RHSScalars[i]);\n    SDValue Ov =\n        getSelect(dl, OvEltVT, Res.getValue(1),\n                  getBoolConstant(true, dl, OvEltVT, ResVT),\n                  getConstant(0, dl, OvEltVT));\n\n    ResScalars.push_back(Res);\n    OvScalars.push_back(Ov);\n  }\n\n  ResScalars.append(ResNE - NE, getUNDEF(ResEltVT));\n  OvScalars.append(ResNE - NE, getUNDEF(OvEltVT));\n\n  EVT NewResVT = EVT::getVectorVT(*getContext(), ResEltVT, ResNE);\n  EVT NewOvVT = EVT::getVectorVT(*getContext(), OvEltVT, ResNE);\n  return std::make_pair(getBuildVector(NewResVT, dl, ResScalars),\n                        getBuildVector(NewOvVT, dl, OvScalars));\n}\n\nbool SelectionDAG::areNonVolatileConsecutiveLoads(LoadSDNode *LD,\n                                                  LoadSDNode *Base,\n                                                  unsigned Bytes,\n                                                  int Dist) const {\n  if (LD->isVolatile() || Base->isVolatile())\n    return false;\n  // TODO: probably too restrictive for atomics, revisit\n  if (!LD->isSimple())\n    return false;\n  if (LD->isIndexed() || Base->isIndexed())\n    return false;\n  if (LD->getChain() != Base->getChain())\n    return false;\n  EVT VT = LD->getValueType(0);\n  if (VT.getSizeInBits() / 8 != Bytes)\n    return false;\n\n  auto BaseLocDecomp = BaseIndexOffset::match(Base, *this);\n  auto LocDecomp = BaseIndexOffset::match(LD, *this);\n\n  int64_t Offset = 0;\n  if (BaseLocDecomp.equalBaseIndex(LocDecomp, *this, Offset))\n    return (Dist * Bytes == Offset);\n  return false;\n}\n\n/// InferPtrAlignment - Infer alignment of a load / store address. Return None\n/// if it cannot be inferred.\nMaybeAlign SelectionDAG::InferPtrAlign(SDValue Ptr) const {\n  // If this is a GlobalAddress + cst, return the alignment.\n  const GlobalValue *GV = nullptr;\n  int64_t GVOffset = 0;\n  if (TLI->isGAPlusOffset(Ptr.getNode(), GV, GVOffset)) {\n    unsigned PtrWidth = getDataLayout().getPointerTypeSizeInBits(GV->getType());\n    KnownBits Known(PtrWidth);\n    llvm::computeKnownBits(GV, Known, getDataLayout());\n    unsigned AlignBits = Known.countMinTrailingZeros();\n    if (AlignBits)\n      return commonAlignment(Align(1ull << std::min(31U, AlignBits)), GVOffset);\n  }\n\n  // If this is a direct reference to a stack slot, use information about the\n  // stack slot's alignment.\n  int FrameIdx = INT_MIN;\n  int64_t FrameOffset = 0;\n  if (FrameIndexSDNode *FI = dyn_cast<FrameIndexSDNode>(Ptr)) {\n    FrameIdx = FI->getIndex();\n  } else if (isBaseWithConstantOffset(Ptr) &&\n             isa<FrameIndexSDNode>(Ptr.getOperand(0))) {\n    // Handle FI+Cst\n    FrameIdx = cast<FrameIndexSDNode>(Ptr.getOperand(0))->getIndex();\n    FrameOffset = Ptr.getConstantOperandVal(1);\n  }\n\n  if (FrameIdx != INT_MIN) {\n    const MachineFrameInfo &MFI = getMachineFunction().getFrameInfo();\n    return commonAlignment(MFI.getObjectAlign(FrameIdx), FrameOffset);\n  }\n\n  return None;\n}\n\n/// GetSplitDestVTs - Compute the VTs needed for the low/hi parts of a type\n/// which is split (or expanded) into two not necessarily identical pieces.\nstd::pair<EVT, EVT> SelectionDAG::GetSplitDestVTs(const EVT &VT) const {\n  // Currently all types are split in half.\n  EVT LoVT, HiVT;\n  if (!VT.isVector())\n    LoVT = HiVT = TLI->getTypeToTransformTo(*getContext(), VT);\n  else\n    LoVT = HiVT = VT.getHalfNumVectorElementsVT(*getContext());\n\n  return std::make_pair(LoVT, HiVT);\n}\n\n/// GetDependentSplitDestVTs - Compute the VTs needed for the low/hi parts of a\n/// type, dependent on an enveloping VT that has been split into two identical\n/// pieces. Sets the HiIsEmpty flag when hi type has zero storage size.\nstd::pair<EVT, EVT>\nSelectionDAG::GetDependentSplitDestVTs(const EVT &VT, const EVT &EnvVT,\n                                       bool *HiIsEmpty) const {\n  EVT EltTp = VT.getVectorElementType();\n  // Examples:\n  //   custom VL=8  with enveloping VL=8/8 yields 8/0 (hi empty)\n  //   custom VL=9  with enveloping VL=8/8 yields 8/1\n  //   custom VL=10 with enveloping VL=8/8 yields 8/2\n  //   etc.\n  ElementCount VTNumElts = VT.getVectorElementCount();\n  ElementCount EnvNumElts = EnvVT.getVectorElementCount();\n  assert(VTNumElts.isScalable() == EnvNumElts.isScalable() &&\n         \"Mixing fixed width and scalable vectors when enveloping a type\");\n  EVT LoVT, HiVT;\n  if (VTNumElts.getKnownMinValue() > EnvNumElts.getKnownMinValue()) {\n    LoVT = EnvVT;\n    HiVT = EVT::getVectorVT(*getContext(), EltTp, VTNumElts - EnvNumElts);\n    *HiIsEmpty = false;\n  } else {\n    // Flag that hi type has zero storage size, but return split envelop type\n    // (this would be easier if vector types with zero elements were allowed).\n    LoVT = EVT::getVectorVT(*getContext(), EltTp, VTNumElts);\n    HiVT = EnvVT;\n    *HiIsEmpty = true;\n  }\n  return std::make_pair(LoVT, HiVT);\n}\n\n/// SplitVector - Split the vector with EXTRACT_SUBVECTOR and return the\n/// low/high part.\nstd::pair<SDValue, SDValue>\nSelectionDAG::SplitVector(const SDValue &N, const SDLoc &DL, const EVT &LoVT,\n                          const EVT &HiVT) {\n  assert(LoVT.isScalableVector() == HiVT.isScalableVector() &&\n         LoVT.isScalableVector() == N.getValueType().isScalableVector() &&\n         \"Splitting vector with an invalid mixture of fixed and scalable \"\n         \"vector types\");\n  assert(LoVT.getVectorMinNumElements() + HiVT.getVectorMinNumElements() <=\n             N.getValueType().getVectorMinNumElements() &&\n         \"More vector elements requested than available!\");\n  SDValue Lo, Hi;\n  Lo =\n      getNode(ISD::EXTRACT_SUBVECTOR, DL, LoVT, N, getVectorIdxConstant(0, DL));\n  // For scalable vectors it is safe to use LoVT.getVectorMinNumElements()\n  // (rather than having to use ElementCount), because EXTRACT_SUBVECTOR scales\n  // IDX with the runtime scaling factor of the result vector type. For\n  // fixed-width result vectors, that runtime scaling factor is 1.\n  Hi = getNode(ISD::EXTRACT_SUBVECTOR, DL, HiVT, N,\n               getVectorIdxConstant(LoVT.getVectorMinNumElements(), DL));\n  return std::make_pair(Lo, Hi);\n}\n\n/// Widen the vector up to the next power of two using INSERT_SUBVECTOR.\nSDValue SelectionDAG::WidenVector(const SDValue &N, const SDLoc &DL) {\n  EVT VT = N.getValueType();\n  EVT WideVT = EVT::getVectorVT(*getContext(), VT.getVectorElementType(),\n                                NextPowerOf2(VT.getVectorNumElements()));\n  return getNode(ISD::INSERT_SUBVECTOR, DL, WideVT, getUNDEF(WideVT), N,\n                 getVectorIdxConstant(0, DL));\n}\n\nvoid SelectionDAG::ExtractVectorElements(SDValue Op,\n                                         SmallVectorImpl<SDValue> &Args,\n                                         unsigned Start, unsigned Count,\n                                         EVT EltVT) {\n  EVT VT = Op.getValueType();\n  if (Count == 0)\n    Count = VT.getVectorNumElements();\n  if (EltVT == EVT())\n    EltVT = VT.getVectorElementType();\n  SDLoc SL(Op);\n  for (unsigned i = Start, e = Start + Count; i != e; ++i) {\n    Args.push_back(getNode(ISD::EXTRACT_VECTOR_ELT, SL, EltVT, Op,\n                           getVectorIdxConstant(i, SL)));\n  }\n}\n\n// getAddressSpace - Return the address space this GlobalAddress belongs to.\nunsigned GlobalAddressSDNode::getAddressSpace() const {\n  return getGlobal()->getType()->getAddressSpace();\n}\n\nType *ConstantPoolSDNode::getType() const {\n  if (isMachineConstantPoolEntry())\n    return Val.MachineCPVal->getType();\n  return Val.ConstVal->getType();\n}\n\nbool BuildVectorSDNode::isConstantSplat(APInt &SplatValue, APInt &SplatUndef,\n                                        unsigned &SplatBitSize,\n                                        bool &HasAnyUndefs,\n                                        unsigned MinSplatBits,\n                                        bool IsBigEndian) const {\n  EVT VT = getValueType(0);\n  assert(VT.isVector() && \"Expected a vector type\");\n  unsigned VecWidth = VT.getSizeInBits();\n  if (MinSplatBits > VecWidth)\n    return false;\n\n  // FIXME: The widths are based on this node's type, but build vectors can\n  // truncate their operands.\n  SplatValue = APInt(VecWidth, 0);\n  SplatUndef = APInt(VecWidth, 0);\n\n  // Get the bits. Bits with undefined values (when the corresponding element\n  // of the vector is an ISD::UNDEF value) are set in SplatUndef and cleared\n  // in SplatValue. If any of the values are not constant, give up and return\n  // false.\n  unsigned int NumOps = getNumOperands();\n  assert(NumOps > 0 && \"isConstantSplat has 0-size build vector\");\n  unsigned EltWidth = VT.getScalarSizeInBits();\n\n  for (unsigned j = 0; j < NumOps; ++j) {\n    unsigned i = IsBigEndian ? NumOps - 1 - j : j;\n    SDValue OpVal = getOperand(i);\n    unsigned BitPos = j * EltWidth;\n\n    if (OpVal.isUndef())\n      SplatUndef.setBits(BitPos, BitPos + EltWidth);\n    else if (auto *CN = dyn_cast<ConstantSDNode>(OpVal))\n      SplatValue.insertBits(CN->getAPIntValue().zextOrTrunc(EltWidth), BitPos);\n    else if (auto *CN = dyn_cast<ConstantFPSDNode>(OpVal))\n      SplatValue.insertBits(CN->getValueAPF().bitcastToAPInt(), BitPos);\n    else\n      return false;\n  }\n\n  // The build_vector is all constants or undefs. Find the smallest element\n  // size that splats the vector.\n  HasAnyUndefs = (SplatUndef != 0);\n\n  // FIXME: This does not work for vectors with elements less than 8 bits.\n  while (VecWidth > 8) {\n    unsigned HalfSize = VecWidth / 2;\n    APInt HighValue = SplatValue.lshr(HalfSize).trunc(HalfSize);\n    APInt LowValue = SplatValue.trunc(HalfSize);\n    APInt HighUndef = SplatUndef.lshr(HalfSize).trunc(HalfSize);\n    APInt LowUndef = SplatUndef.trunc(HalfSize);\n\n    // If the two halves do not match (ignoring undef bits), stop here.\n    if ((HighValue & ~LowUndef) != (LowValue & ~HighUndef) ||\n        MinSplatBits > HalfSize)\n      break;\n\n    SplatValue = HighValue | LowValue;\n    SplatUndef = HighUndef & LowUndef;\n\n    VecWidth = HalfSize;\n  }\n\n  SplatBitSize = VecWidth;\n  return true;\n}\n\nSDValue BuildVectorSDNode::getSplatValue(const APInt &DemandedElts,\n                                         BitVector *UndefElements) const {\n  unsigned NumOps = getNumOperands();\n  if (UndefElements) {\n    UndefElements->clear();\n    UndefElements->resize(NumOps);\n  }\n  assert(NumOps == DemandedElts.getBitWidth() && \"Unexpected vector size\");\n  if (!DemandedElts)\n    return SDValue();\n  SDValue Splatted;\n  for (unsigned i = 0; i != NumOps; ++i) {\n    if (!DemandedElts[i])\n      continue;\n    SDValue Op = getOperand(i);\n    if (Op.isUndef()) {\n      if (UndefElements)\n        (*UndefElements)[i] = true;\n    } else if (!Splatted) {\n      Splatted = Op;\n    } else if (Splatted != Op) {\n      return SDValue();\n    }\n  }\n\n  if (!Splatted) {\n    unsigned FirstDemandedIdx = DemandedElts.countTrailingZeros();\n    assert(getOperand(FirstDemandedIdx).isUndef() &&\n           \"Can only have a splat without a constant for all undefs.\");\n    return getOperand(FirstDemandedIdx);\n  }\n\n  return Splatted;\n}\n\nSDValue BuildVectorSDNode::getSplatValue(BitVector *UndefElements) const {\n  APInt DemandedElts = APInt::getAllOnesValue(getNumOperands());\n  return getSplatValue(DemandedElts, UndefElements);\n}\n\nbool BuildVectorSDNode::getRepeatedSequence(const APInt &DemandedElts,\n                                            SmallVectorImpl<SDValue> &Sequence,\n                                            BitVector *UndefElements) const {\n  unsigned NumOps = getNumOperands();\n  Sequence.clear();\n  if (UndefElements) {\n    UndefElements->clear();\n    UndefElements->resize(NumOps);\n  }\n  assert(NumOps == DemandedElts.getBitWidth() && \"Unexpected vector size\");\n  if (!DemandedElts || NumOps < 2 || !isPowerOf2_32(NumOps))\n    return false;\n\n  // Set the undefs even if we don't find a sequence (like getSplatValue).\n  if (UndefElements)\n    for (unsigned I = 0; I != NumOps; ++I)\n      if (DemandedElts[I] && getOperand(I).isUndef())\n        (*UndefElements)[I] = true;\n\n  // Iteratively widen the sequence length looking for repetitions.\n  for (unsigned SeqLen = 1; SeqLen < NumOps; SeqLen *= 2) {\n    Sequence.append(SeqLen, SDValue());\n    for (unsigned I = 0; I != NumOps; ++I) {\n      if (!DemandedElts[I])\n        continue;\n      SDValue &SeqOp = Sequence[I % SeqLen];\n      SDValue Op = getOperand(I);\n      if (Op.isUndef()) {\n        if (!SeqOp)\n          SeqOp = Op;\n        continue;\n      }\n      if (SeqOp && !SeqOp.isUndef() && SeqOp != Op) {\n        Sequence.clear();\n        break;\n      }\n      SeqOp = Op;\n    }\n    if (!Sequence.empty())\n      return true;\n  }\n\n  assert(Sequence.empty() && \"Failed to empty non-repeating sequence pattern\");\n  return false;\n}\n\nbool BuildVectorSDNode::getRepeatedSequence(SmallVectorImpl<SDValue> &Sequence,\n                                            BitVector *UndefElements) const {\n  APInt DemandedElts = APInt::getAllOnesValue(getNumOperands());\n  return getRepeatedSequence(DemandedElts, Sequence, UndefElements);\n}\n\nConstantSDNode *\nBuildVectorSDNode::getConstantSplatNode(const APInt &DemandedElts,\n                                        BitVector *UndefElements) const {\n  return dyn_cast_or_null<ConstantSDNode>(\n      getSplatValue(DemandedElts, UndefElements));\n}\n\nConstantSDNode *\nBuildVectorSDNode::getConstantSplatNode(BitVector *UndefElements) const {\n  return dyn_cast_or_null<ConstantSDNode>(getSplatValue(UndefElements));\n}\n\nConstantFPSDNode *\nBuildVectorSDNode::getConstantFPSplatNode(const APInt &DemandedElts,\n                                          BitVector *UndefElements) const {\n  return dyn_cast_or_null<ConstantFPSDNode>(\n      getSplatValue(DemandedElts, UndefElements));\n}\n\nConstantFPSDNode *\nBuildVectorSDNode::getConstantFPSplatNode(BitVector *UndefElements) const {\n  return dyn_cast_or_null<ConstantFPSDNode>(getSplatValue(UndefElements));\n}\n\nint32_t\nBuildVectorSDNode::getConstantFPSplatPow2ToLog2Int(BitVector *UndefElements,\n                                                   uint32_t BitWidth) const {\n  if (ConstantFPSDNode *CN =\n          dyn_cast_or_null<ConstantFPSDNode>(getSplatValue(UndefElements))) {\n    bool IsExact;\n    APSInt IntVal(BitWidth);\n    const APFloat &APF = CN->getValueAPF();\n    if (APF.convertToInteger(IntVal, APFloat::rmTowardZero, &IsExact) !=\n            APFloat::opOK ||\n        !IsExact)\n      return -1;\n\n    return IntVal.exactLogBase2();\n  }\n  return -1;\n}\n\nbool BuildVectorSDNode::isConstant() const {\n  for (const SDValue &Op : op_values()) {\n    unsigned Opc = Op.getOpcode();\n    if (Opc != ISD::UNDEF && Opc != ISD::Constant && Opc != ISD::ConstantFP)\n      return false;\n  }\n  return true;\n}\n\nbool ShuffleVectorSDNode::isSplatMask(const int *Mask, EVT VT) {\n  // Find the first non-undef value in the shuffle mask.\n  unsigned i, e;\n  for (i = 0, e = VT.getVectorNumElements(); i != e && Mask[i] < 0; ++i)\n    /* search */;\n\n  // If all elements are undefined, this shuffle can be considered a splat\n  // (although it should eventually get simplified away completely).\n  if (i == e)\n    return true;\n\n  // Make sure all remaining elements are either undef or the same as the first\n  // non-undef value.\n  for (int Idx = Mask[i]; i != e; ++i)\n    if (Mask[i] >= 0 && Mask[i] != Idx)\n      return false;\n  return true;\n}\n\n// Returns the SDNode if it is a constant integer BuildVector\n// or constant integer.\nSDNode *SelectionDAG::isConstantIntBuildVectorOrConstantInt(SDValue N) const {\n  if (isa<ConstantSDNode>(N))\n    return N.getNode();\n  if (ISD::isBuildVectorOfConstantSDNodes(N.getNode()))\n    return N.getNode();\n  // Treat a GlobalAddress supporting constant offset folding as a\n  // constant integer.\n  if (GlobalAddressSDNode *GA = dyn_cast<GlobalAddressSDNode>(N))\n    if (GA->getOpcode() == ISD::GlobalAddress &&\n        TLI->isOffsetFoldingLegal(GA))\n      return GA;\n  if ((N.getOpcode() == ISD::SPLAT_VECTOR) &&\n      isa<ConstantSDNode>(N.getOperand(0)))\n    return N.getNode();\n  return nullptr;\n}\n\n// Returns the SDNode if it is a constant float BuildVector\n// or constant float.\nSDNode *SelectionDAG::isConstantFPBuildVectorOrConstantFP(SDValue N) const {\n  if (isa<ConstantFPSDNode>(N))\n    return N.getNode();\n\n  if (ISD::isBuildVectorOfConstantFPSDNodes(N.getNode()))\n    return N.getNode();\n\n  return nullptr;\n}\n\nvoid SelectionDAG::createOperands(SDNode *Node, ArrayRef<SDValue> Vals) {\n  assert(!Node->OperandList && \"Node already has operands\");\n  assert(SDNode::getMaxNumOperands() >= Vals.size() &&\n         \"too many operands to fit into SDNode\");\n  SDUse *Ops = OperandRecycler.allocate(\n      ArrayRecycler<SDUse>::Capacity::get(Vals.size()), OperandAllocator);\n\n  bool IsDivergent = false;\n  for (unsigned I = 0; I != Vals.size(); ++I) {\n    Ops[I].setUser(Node);\n    Ops[I].setInitial(Vals[I]);\n    if (Ops[I].Val.getValueType() != MVT::Other) // Skip Chain. It does not carry divergence.\n      IsDivergent |= Ops[I].getNode()->isDivergent();\n  }\n  Node->NumOperands = Vals.size();\n  Node->OperandList = Ops;\n  if (!TLI->isSDNodeAlwaysUniform(Node)) {\n    IsDivergent |= TLI->isSDNodeSourceOfDivergence(Node, FLI, DA);\n    Node->SDNodeBits.IsDivergent = IsDivergent;\n  }\n  checkForCycles(Node);\n}\n\nSDValue SelectionDAG::getTokenFactor(const SDLoc &DL,\n                                     SmallVectorImpl<SDValue> &Vals) {\n  size_t Limit = SDNode::getMaxNumOperands();\n  while (Vals.size() > Limit) {\n    unsigned SliceIdx = Vals.size() - Limit;\n    auto ExtractedTFs = ArrayRef<SDValue>(Vals).slice(SliceIdx, Limit);\n    SDValue NewTF = getNode(ISD::TokenFactor, DL, MVT::Other, ExtractedTFs);\n    Vals.erase(Vals.begin() + SliceIdx, Vals.end());\n    Vals.emplace_back(NewTF);\n  }\n  return getNode(ISD::TokenFactor, DL, MVT::Other, Vals);\n}\n\nSDValue SelectionDAG::getNeutralElement(unsigned Opcode, const SDLoc &DL,\n                                        EVT VT, SDNodeFlags Flags) {\n  switch (Opcode) {\n  default:\n    return SDValue();\n  case ISD::ADD:\n  case ISD::OR:\n  case ISD::XOR:\n  case ISD::UMAX:\n    return getConstant(0, DL, VT);\n  case ISD::MUL:\n    return getConstant(1, DL, VT);\n  case ISD::AND:\n  case ISD::UMIN:\n    return getAllOnesConstant(DL, VT);\n  case ISD::SMAX:\n    return getConstant(APInt::getSignedMinValue(VT.getSizeInBits()), DL, VT);\n  case ISD::SMIN:\n    return getConstant(APInt::getSignedMaxValue(VT.getSizeInBits()), DL, VT);\n  case ISD::FADD:\n    return getConstantFP(-0.0, DL, VT);\n  case ISD::FMUL:\n    return getConstantFP(1.0, DL, VT);\n  case ISD::FMINNUM:\n  case ISD::FMAXNUM: {\n    // Neutral element for fminnum is NaN, Inf or FLT_MAX, depending on FMF.\n    const fltSemantics &Semantics = EVTToAPFloatSemantics(VT);\n    APFloat NeutralAF = !Flags.hasNoNaNs() ? APFloat::getQNaN(Semantics) :\n                        !Flags.hasNoInfs() ? APFloat::getInf(Semantics) :\n                        APFloat::getLargest(Semantics);\n    if (Opcode == ISD::FMAXNUM)\n      NeutralAF.changeSign();\n\n    return getConstantFP(NeutralAF, DL, VT);\n  }\n  }\n}\n\n#ifndef NDEBUG\nstatic void checkForCyclesHelper(const SDNode *N,\n                                 SmallPtrSetImpl<const SDNode*> &Visited,\n                                 SmallPtrSetImpl<const SDNode*> &Checked,\n                                 const llvm::SelectionDAG *DAG) {\n  // If this node has already been checked, don't check it again.\n  if (Checked.count(N))\n    return;\n\n  // If a node has already been visited on this depth-first walk, reject it as\n  // a cycle.\n  if (!Visited.insert(N).second) {\n    errs() << \"Detected cycle in SelectionDAG\\n\";\n    dbgs() << \"Offending node:\\n\";\n    N->dumprFull(DAG); dbgs() << \"\\n\";\n    abort();\n  }\n\n  for (const SDValue &Op : N->op_values())\n    checkForCyclesHelper(Op.getNode(), Visited, Checked, DAG);\n\n  Checked.insert(N);\n  Visited.erase(N);\n}\n#endif\n\nvoid llvm::checkForCycles(const llvm::SDNode *N,\n                          const llvm::SelectionDAG *DAG,\n                          bool force) {\n#ifndef NDEBUG\n  bool check = force;\n#ifdef EXPENSIVE_CHECKS\n  check = true;\n#endif  // EXPENSIVE_CHECKS\n  if (check) {\n    assert(N && \"Checking nonexistent SDNode\");\n    SmallPtrSet<const SDNode*, 32> visited;\n    SmallPtrSet<const SDNode*, 32> checked;\n    checkForCyclesHelper(N, visited, checked, DAG);\n  }\n#endif  // !NDEBUG\n}\n\nvoid llvm::checkForCycles(const llvm::SelectionDAG *DAG, bool force) {\n  checkForCycles(DAG->getRoot().getNode(), DAG, force);\n}\n"}}, "reports": [{"events": [{"location": {"col": 7, "file": 30, "line": 150}, "message": "destructor '~SDDbgInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h", "reportHash": "271b7618f177e8121f6f7875ebd38f25", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 31, "line": 371}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h", "reportHash": "d7f360f73965c3c2ecc8ff89affedde5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 33, "file": 84, "line": 298}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp", "reportHash": "ece61940b135f0e4fe24cacde26226f5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 23, "file": 84, "line": 1789}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp", "reportHash": "37189987b09a52830f83c1f953d4e0c0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 23, "file": 84, "line": 1789}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp", "reportHash": "42ead8a1f1fb7f8781e2256c734ba595", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 34, "file": 84, "line": 3541}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp", "reportHash": "75d20423132a71bd5ea244a879870be3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 84, "line": 4269}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp", "reportHash": "46478764b741bb56330642ff0727a0b3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 25, "file": 84, "line": 4967}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp", "reportHash": "4971f51fd0577c91dfad9a87d1ed926b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 35, "file": 84, "line": 5114}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp", "reportHash": "3bfb16301efc33227e43d080ad25d38e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 35, "file": 84, "line": 5114}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp", "reportHash": "6c91df57ed2a1dbc212d68929e84daed", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 84, "line": 5119}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp", "reportHash": "ef7eeb0cf966d0eb0a24a005cebeb904", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 39, "file": 84, "line": 5119}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp", "reportHash": "9ae4da55405f05fb7317c7b2ab380944", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 28, "file": 84, "line": 5498}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp", "reportHash": "9b104c2728e7a3f0c284f3bbad402161", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 28, "file": 84, "line": 5498}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp", "reportHash": "4554296eb19f0c106735b777a526a969", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 24, "file": 84, "line": 7563}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp", "reportHash": "4653511abc3863a454137011ea840076", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 24, "file": 84, "line": 7563}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp", "reportHash": "25bae66664e24098a476020a0cf0f59b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 84, "line": 8706}, "message": "destructor '~RAUWUpdateListener' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp", "reportHash": "cf9052ef9c03dca7f75e2c242fbd5585", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 17, "file": 84, "line": 9537}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp", "reportHash": "f542985c7177cc1955c321f5d83acb68", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 41, "file": 84, "line": 9575}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp", "reportHash": "63b4841182a6b27a7f9ddd20eb72ab9b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 27, "file": 84, "line": 9632}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp", "reportHash": "fd5a765230e185f3db7e11ca57327173", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 27, "file": 84, "line": 9632}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp", "reportHash": "ee0d9bfc9a03347de55bd59d74337a7b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
